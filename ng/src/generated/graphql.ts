/* eslint-disable */
export type Maybe<T> = T | null;
export type InputMaybe<T> = Maybe<T>;
export type Exact<T extends { [key: string]: unknown }> = { [K in keyof T]: T[K] };
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]?: Maybe<T[SubKey]> };
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & { [SubKey in K]: Maybe<T[SubKey]> };
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
  ID: string;
  String: string;
  Boolean: boolean;
  Int: number;
  Float: number;
  Cursor: any;
  Time: any;
  Upload: any;
};

export type ApiToken = Node & {
  createdAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  lastUsed?: Maybe<Scalars['Time']>;
  /** User supplied name for this token */
  name: Scalars['String'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
  user: User;
};

/** A connection to a list of items. */
export type ApiTokenConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ApiTokenEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ApiTokenEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ApiToken>;
};

/**
 * APITokenWhereInput is used for filtering APIToken objects.
 * Input was generated by ent.
 */
export type ApiTokenWhereInput = {
  and?: InputMaybe<Array<ApiTokenWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** last_used field predicates */
  lastUsed?: InputMaybe<Scalars['Time']>;
  lastUsedGT?: InputMaybe<Scalars['Time']>;
  lastUsedGTE?: InputMaybe<Scalars['Time']>;
  lastUsedIn?: InputMaybe<Array<Scalars['Time']>>;
  lastUsedIsNil?: InputMaybe<Scalars['Boolean']>;
  lastUsedLT?: InputMaybe<Scalars['Time']>;
  lastUsedLTE?: InputMaybe<Scalars['Time']>;
  lastUsedNEQ?: InputMaybe<Scalars['Time']>;
  lastUsedNotIn?: InputMaybe<Array<Scalars['Time']>>;
  lastUsedNotNil?: InputMaybe<Scalars['Boolean']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ApiTokenWhereInput>;
  or?: InputMaybe<Array<ApiTokenWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type AccessRight = Node & {
  assignedAccessRight?: Maybe<Array<SeatGroup>>;
  id: Scalars['ID'];
  internalID: Scalars['String'];
  label: Scalars['String'];
  seatGroupAccessRight?: Maybe<Array<SeatGroupAccessRight>>;
};

/** A connection to a list of items. */
export type AccessRightConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AccessRightEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AccessRightEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<AccessRight>;
};

/**
 * AccessRightWhereInput is used for filtering AccessRight objects.
 * Input was generated by ent.
 */
export type AccessRightWhereInput = {
  and?: InputMaybe<Array<AccessRightWhereInput>>;
  /** assigned_access_right edge predicates */
  hasAssignedAccessRight?: InputMaybe<Scalars['Boolean']>;
  hasAssignedAccessRightWith?: InputMaybe<Array<SeatGroupWhereInput>>;
  /** seat_group_access_right edge predicates */
  hasSeatGroupAccessRight?: InputMaybe<Scalars['Boolean']>;
  hasSeatGroupAccessRightWith?: InputMaybe<Array<SeatGroupAccessRightWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_id field predicates */
  internalID?: InputMaybe<Scalars['String']>;
  internalIDContains?: InputMaybe<Scalars['String']>;
  internalIDContainsFold?: InputMaybe<Scalars['String']>;
  internalIDEqualFold?: InputMaybe<Scalars['String']>;
  internalIDGT?: InputMaybe<Scalars['String']>;
  internalIDGTE?: InputMaybe<Scalars['String']>;
  internalIDHasPrefix?: InputMaybe<Scalars['String']>;
  internalIDHasSuffix?: InputMaybe<Scalars['String']>;
  internalIDIn?: InputMaybe<Array<Scalars['String']>>;
  internalIDLT?: InputMaybe<Scalars['String']>;
  internalIDLTE?: InputMaybe<Scalars['String']>;
  internalIDNEQ?: InputMaybe<Scalars['String']>;
  internalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<AccessRightWhereInput>;
  or?: InputMaybe<Array<AccessRightWhereInput>>;
};

export type Address = Node & {
  addressOne: Scalars['String'];
  addressTwo: Scalars['String'];
  city: Scalars['String'];
  company?: Maybe<Scalars['String']>;
  companyAddress?: Maybe<Array<Tenant>>;
  country: Country;
  email: Scalars['String'];
  firstName: Scalars['String'];
  id: Scalars['ID'];
  lastName: Scalars['String'];
  location?: Maybe<Array<Location>>;
  phoneNumber: Scalars['String'];
  /** Some applications have both mobile and generic */
  phoneNumber2?: Maybe<Scalars['String']>;
  recipientColli?: Maybe<Array<Colli>>;
  recipientConsolidation?: Maybe<Consolidation>;
  returnRecipientColli?: Maybe<Array<ReturnColli>>;
  returnSenderColli?: Maybe<Array<ReturnColli>>;
  senderColli?: Maybe<Array<Colli>>;
  senderConsolidation?: Maybe<Consolidation>;
  state?: Maybe<Scalars['String']>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  /** Electronic customs */
  vatNumber?: Maybe<Scalars['String']>;
  zip: Scalars['String'];
};

/** A connection to a list of items. */
export type AddressConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AddressEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AddressEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Address>;
};

export type AddressGlobal = Node & {
  addressOne: Scalars['String'];
  addressTwo?: Maybe<Scalars['String']>;
  city: Scalars['String'];
  company?: Maybe<Scalars['String']>;
  country: Country;
  id: Scalars['ID'];
  latitude: Scalars['Float'];
  longitude: Scalars['Float'];
  parcelShop?: Maybe<ParcelShop>;
  parcelShopBringDelivery?: Maybe<ParcelShopBring>;
  parcelShopPostNordDelivery?: Maybe<ParcelShopPostNord>;
  state?: Maybe<Scalars['String']>;
  zip: Scalars['String'];
};

/** A connection to a list of items. */
export type AddressGlobalConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<AddressGlobalEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type AddressGlobalEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<AddressGlobal>;
};

/**
 * AddressGlobalWhereInput is used for filtering AddressGlobal objects.
 * Input was generated by ent.
 */
export type AddressGlobalWhereInput = {
  /** address_one field predicates */
  addressOne?: InputMaybe<Scalars['String']>;
  addressOneContains?: InputMaybe<Scalars['String']>;
  addressOneContainsFold?: InputMaybe<Scalars['String']>;
  addressOneEqualFold?: InputMaybe<Scalars['String']>;
  addressOneGT?: InputMaybe<Scalars['String']>;
  addressOneGTE?: InputMaybe<Scalars['String']>;
  addressOneHasPrefix?: InputMaybe<Scalars['String']>;
  addressOneHasSuffix?: InputMaybe<Scalars['String']>;
  addressOneIn?: InputMaybe<Array<Scalars['String']>>;
  addressOneLT?: InputMaybe<Scalars['String']>;
  addressOneLTE?: InputMaybe<Scalars['String']>;
  addressOneNEQ?: InputMaybe<Scalars['String']>;
  addressOneNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** address_two field predicates */
  addressTwo?: InputMaybe<Scalars['String']>;
  addressTwoContains?: InputMaybe<Scalars['String']>;
  addressTwoContainsFold?: InputMaybe<Scalars['String']>;
  addressTwoEqualFold?: InputMaybe<Scalars['String']>;
  addressTwoGT?: InputMaybe<Scalars['String']>;
  addressTwoGTE?: InputMaybe<Scalars['String']>;
  addressTwoHasPrefix?: InputMaybe<Scalars['String']>;
  addressTwoHasSuffix?: InputMaybe<Scalars['String']>;
  addressTwoIn?: InputMaybe<Array<Scalars['String']>>;
  addressTwoIsNil?: InputMaybe<Scalars['Boolean']>;
  addressTwoLT?: InputMaybe<Scalars['String']>;
  addressTwoLTE?: InputMaybe<Scalars['String']>;
  addressTwoNEQ?: InputMaybe<Scalars['String']>;
  addressTwoNotIn?: InputMaybe<Array<Scalars['String']>>;
  addressTwoNotNil?: InputMaybe<Scalars['Boolean']>;
  and?: InputMaybe<Array<AddressGlobalWhereInput>>;
  /** city field predicates */
  city?: InputMaybe<Scalars['String']>;
  cityContains?: InputMaybe<Scalars['String']>;
  cityContainsFold?: InputMaybe<Scalars['String']>;
  cityEqualFold?: InputMaybe<Scalars['String']>;
  cityGT?: InputMaybe<Scalars['String']>;
  cityGTE?: InputMaybe<Scalars['String']>;
  cityHasPrefix?: InputMaybe<Scalars['String']>;
  cityHasSuffix?: InputMaybe<Scalars['String']>;
  cityIn?: InputMaybe<Array<Scalars['String']>>;
  cityLT?: InputMaybe<Scalars['String']>;
  cityLTE?: InputMaybe<Scalars['String']>;
  cityNEQ?: InputMaybe<Scalars['String']>;
  cityNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** company field predicates */
  company?: InputMaybe<Scalars['String']>;
  companyContains?: InputMaybe<Scalars['String']>;
  companyContainsFold?: InputMaybe<Scalars['String']>;
  companyEqualFold?: InputMaybe<Scalars['String']>;
  companyGT?: InputMaybe<Scalars['String']>;
  companyGTE?: InputMaybe<Scalars['String']>;
  companyHasPrefix?: InputMaybe<Scalars['String']>;
  companyHasSuffix?: InputMaybe<Scalars['String']>;
  companyIn?: InputMaybe<Array<Scalars['String']>>;
  companyIsNil?: InputMaybe<Scalars['Boolean']>;
  companyLT?: InputMaybe<Scalars['String']>;
  companyLTE?: InputMaybe<Scalars['String']>;
  companyNEQ?: InputMaybe<Scalars['String']>;
  companyNotIn?: InputMaybe<Array<Scalars['String']>>;
  companyNotNil?: InputMaybe<Scalars['Boolean']>;
  /** country edge predicates */
  hasCountry?: InputMaybe<Scalars['Boolean']>;
  hasCountryWith?: InputMaybe<Array<CountryWhereInput>>;
  /** parcel_shop edge predicates */
  hasParcelShop?: InputMaybe<Scalars['Boolean']>;
  /** parcel_shop_bring_delivery edge predicates */
  hasParcelShopBringDelivery?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopBringDeliveryWith?: InputMaybe<Array<ParcelShopBringWhereInput>>;
  /** parcel_shop_post_nord_delivery edge predicates */
  hasParcelShopPostNordDelivery?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopPostNordDeliveryWith?: InputMaybe<Array<ParcelShopPostNordWhereInput>>;
  hasParcelShopWith?: InputMaybe<Array<ParcelShopWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** latitude field predicates */
  latitude?: InputMaybe<Scalars['Float']>;
  latitudeGT?: InputMaybe<Scalars['Float']>;
  latitudeGTE?: InputMaybe<Scalars['Float']>;
  latitudeIn?: InputMaybe<Array<Scalars['Float']>>;
  latitudeLT?: InputMaybe<Scalars['Float']>;
  latitudeLTE?: InputMaybe<Scalars['Float']>;
  latitudeNEQ?: InputMaybe<Scalars['Float']>;
  latitudeNotIn?: InputMaybe<Array<Scalars['Float']>>;
  /** longitude field predicates */
  longitude?: InputMaybe<Scalars['Float']>;
  longitudeGT?: InputMaybe<Scalars['Float']>;
  longitudeGTE?: InputMaybe<Scalars['Float']>;
  longitudeIn?: InputMaybe<Array<Scalars['Float']>>;
  longitudeLT?: InputMaybe<Scalars['Float']>;
  longitudeLTE?: InputMaybe<Scalars['Float']>;
  longitudeNEQ?: InputMaybe<Scalars['Float']>;
  longitudeNotIn?: InputMaybe<Array<Scalars['Float']>>;
  not?: InputMaybe<AddressGlobalWhereInput>;
  or?: InputMaybe<Array<AddressGlobalWhereInput>>;
  /** state field predicates */
  state?: InputMaybe<Scalars['String']>;
  stateContains?: InputMaybe<Scalars['String']>;
  stateContainsFold?: InputMaybe<Scalars['String']>;
  stateEqualFold?: InputMaybe<Scalars['String']>;
  stateGT?: InputMaybe<Scalars['String']>;
  stateGTE?: InputMaybe<Scalars['String']>;
  stateHasPrefix?: InputMaybe<Scalars['String']>;
  stateHasSuffix?: InputMaybe<Scalars['String']>;
  stateIn?: InputMaybe<Array<Scalars['String']>>;
  stateIsNil?: InputMaybe<Scalars['Boolean']>;
  stateLT?: InputMaybe<Scalars['String']>;
  stateLTE?: InputMaybe<Scalars['String']>;
  stateNEQ?: InputMaybe<Scalars['String']>;
  stateNotIn?: InputMaybe<Array<Scalars['String']>>;
  stateNotNil?: InputMaybe<Scalars['Boolean']>;
  /** zip field predicates */
  zip?: InputMaybe<Scalars['String']>;
  zipContains?: InputMaybe<Scalars['String']>;
  zipContainsFold?: InputMaybe<Scalars['String']>;
  zipEqualFold?: InputMaybe<Scalars['String']>;
  zipGT?: InputMaybe<Scalars['String']>;
  zipGTE?: InputMaybe<Scalars['String']>;
  zipHasPrefix?: InputMaybe<Scalars['String']>;
  zipHasSuffix?: InputMaybe<Scalars['String']>;
  zipIn?: InputMaybe<Array<Scalars['String']>>;
  zipLT?: InputMaybe<Scalars['String']>;
  zipLTE?: InputMaybe<Scalars['String']>;
  zipNEQ?: InputMaybe<Scalars['String']>;
  zipNotIn?: InputMaybe<Array<Scalars['String']>>;
};

/**
 * AddressWhereInput is used for filtering Address objects.
 * Input was generated by ent.
 */
export type AddressWhereInput = {
  /** address_one field predicates */
  addressOne?: InputMaybe<Scalars['String']>;
  addressOneContains?: InputMaybe<Scalars['String']>;
  addressOneContainsFold?: InputMaybe<Scalars['String']>;
  addressOneEqualFold?: InputMaybe<Scalars['String']>;
  addressOneGT?: InputMaybe<Scalars['String']>;
  addressOneGTE?: InputMaybe<Scalars['String']>;
  addressOneHasPrefix?: InputMaybe<Scalars['String']>;
  addressOneHasSuffix?: InputMaybe<Scalars['String']>;
  addressOneIn?: InputMaybe<Array<Scalars['String']>>;
  addressOneLT?: InputMaybe<Scalars['String']>;
  addressOneLTE?: InputMaybe<Scalars['String']>;
  addressOneNEQ?: InputMaybe<Scalars['String']>;
  addressOneNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** address_two field predicates */
  addressTwo?: InputMaybe<Scalars['String']>;
  addressTwoContains?: InputMaybe<Scalars['String']>;
  addressTwoContainsFold?: InputMaybe<Scalars['String']>;
  addressTwoEqualFold?: InputMaybe<Scalars['String']>;
  addressTwoGT?: InputMaybe<Scalars['String']>;
  addressTwoGTE?: InputMaybe<Scalars['String']>;
  addressTwoHasPrefix?: InputMaybe<Scalars['String']>;
  addressTwoHasSuffix?: InputMaybe<Scalars['String']>;
  addressTwoIn?: InputMaybe<Array<Scalars['String']>>;
  addressTwoLT?: InputMaybe<Scalars['String']>;
  addressTwoLTE?: InputMaybe<Scalars['String']>;
  addressTwoNEQ?: InputMaybe<Scalars['String']>;
  addressTwoNotIn?: InputMaybe<Array<Scalars['String']>>;
  and?: InputMaybe<Array<AddressWhereInput>>;
  /** city field predicates */
  city?: InputMaybe<Scalars['String']>;
  cityContains?: InputMaybe<Scalars['String']>;
  cityContainsFold?: InputMaybe<Scalars['String']>;
  cityEqualFold?: InputMaybe<Scalars['String']>;
  cityGT?: InputMaybe<Scalars['String']>;
  cityGTE?: InputMaybe<Scalars['String']>;
  cityHasPrefix?: InputMaybe<Scalars['String']>;
  cityHasSuffix?: InputMaybe<Scalars['String']>;
  cityIn?: InputMaybe<Array<Scalars['String']>>;
  cityLT?: InputMaybe<Scalars['String']>;
  cityLTE?: InputMaybe<Scalars['String']>;
  cityNEQ?: InputMaybe<Scalars['String']>;
  cityNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** company field predicates */
  company?: InputMaybe<Scalars['String']>;
  companyContains?: InputMaybe<Scalars['String']>;
  companyContainsFold?: InputMaybe<Scalars['String']>;
  companyEqualFold?: InputMaybe<Scalars['String']>;
  companyGT?: InputMaybe<Scalars['String']>;
  companyGTE?: InputMaybe<Scalars['String']>;
  companyHasPrefix?: InputMaybe<Scalars['String']>;
  companyHasSuffix?: InputMaybe<Scalars['String']>;
  companyIn?: InputMaybe<Array<Scalars['String']>>;
  companyIsNil?: InputMaybe<Scalars['Boolean']>;
  companyLT?: InputMaybe<Scalars['String']>;
  companyLTE?: InputMaybe<Scalars['String']>;
  companyNEQ?: InputMaybe<Scalars['String']>;
  companyNotIn?: InputMaybe<Array<Scalars['String']>>;
  companyNotNil?: InputMaybe<Scalars['Boolean']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** first_name field predicates */
  firstName?: InputMaybe<Scalars['String']>;
  firstNameContains?: InputMaybe<Scalars['String']>;
  firstNameContainsFold?: InputMaybe<Scalars['String']>;
  firstNameEqualFold?: InputMaybe<Scalars['String']>;
  firstNameGT?: InputMaybe<Scalars['String']>;
  firstNameGTE?: InputMaybe<Scalars['String']>;
  firstNameHasPrefix?: InputMaybe<Scalars['String']>;
  firstNameHasSuffix?: InputMaybe<Scalars['String']>;
  firstNameIn?: InputMaybe<Array<Scalars['String']>>;
  firstNameLT?: InputMaybe<Scalars['String']>;
  firstNameLTE?: InputMaybe<Scalars['String']>;
  firstNameNEQ?: InputMaybe<Scalars['String']>;
  firstNameNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** company_address edge predicates */
  hasCompanyAddress?: InputMaybe<Scalars['Boolean']>;
  hasCompanyAddressWith?: InputMaybe<Array<TenantWhereInput>>;
  /** country edge predicates */
  hasCountry?: InputMaybe<Scalars['Boolean']>;
  hasCountryWith?: InputMaybe<Array<CountryWhereInput>>;
  /** location edge predicates */
  hasLocation?: InputMaybe<Scalars['Boolean']>;
  hasLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** recipient_colli edge predicates */
  hasRecipientColli?: InputMaybe<Scalars['Boolean']>;
  hasRecipientColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** recipient_consolidation edge predicates */
  hasRecipientConsolidation?: InputMaybe<Scalars['Boolean']>;
  hasRecipientConsolidationWith?: InputMaybe<Array<ConsolidationWhereInput>>;
  /** return_recipient_colli edge predicates */
  hasReturnRecipientColli?: InputMaybe<Scalars['Boolean']>;
  hasReturnRecipientColliWith?: InputMaybe<Array<ReturnColliWhereInput>>;
  /** return_sender_colli edge predicates */
  hasReturnSenderColli?: InputMaybe<Scalars['Boolean']>;
  hasReturnSenderColliWith?: InputMaybe<Array<ReturnColliWhereInput>>;
  /** sender_colli edge predicates */
  hasSenderColli?: InputMaybe<Scalars['Boolean']>;
  hasSenderColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** sender_consolidation edge predicates */
  hasSenderConsolidation?: InputMaybe<Scalars['Boolean']>;
  hasSenderConsolidationWith?: InputMaybe<Array<ConsolidationWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** last_name field predicates */
  lastName?: InputMaybe<Scalars['String']>;
  lastNameContains?: InputMaybe<Scalars['String']>;
  lastNameContainsFold?: InputMaybe<Scalars['String']>;
  lastNameEqualFold?: InputMaybe<Scalars['String']>;
  lastNameGT?: InputMaybe<Scalars['String']>;
  lastNameGTE?: InputMaybe<Scalars['String']>;
  lastNameHasPrefix?: InputMaybe<Scalars['String']>;
  lastNameHasSuffix?: InputMaybe<Scalars['String']>;
  lastNameIn?: InputMaybe<Array<Scalars['String']>>;
  lastNameLT?: InputMaybe<Scalars['String']>;
  lastNameLTE?: InputMaybe<Scalars['String']>;
  lastNameNEQ?: InputMaybe<Scalars['String']>;
  lastNameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<AddressWhereInput>;
  or?: InputMaybe<Array<AddressWhereInput>>;
  /** phone_number field predicates */
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** phone_number_2 field predicates */
  phoneNumber2?: InputMaybe<Scalars['String']>;
  phoneNumber2Contains?: InputMaybe<Scalars['String']>;
  phoneNumber2ContainsFold?: InputMaybe<Scalars['String']>;
  phoneNumber2EqualFold?: InputMaybe<Scalars['String']>;
  phoneNumber2GT?: InputMaybe<Scalars['String']>;
  phoneNumber2GTE?: InputMaybe<Scalars['String']>;
  phoneNumber2HasPrefix?: InputMaybe<Scalars['String']>;
  phoneNumber2HasSuffix?: InputMaybe<Scalars['String']>;
  phoneNumber2In?: InputMaybe<Array<Scalars['String']>>;
  phoneNumber2IsNil?: InputMaybe<Scalars['Boolean']>;
  phoneNumber2LT?: InputMaybe<Scalars['String']>;
  phoneNumber2LTE?: InputMaybe<Scalars['String']>;
  phoneNumber2NEQ?: InputMaybe<Scalars['String']>;
  phoneNumber2NotIn?: InputMaybe<Array<Scalars['String']>>;
  phoneNumber2NotNil?: InputMaybe<Scalars['Boolean']>;
  phoneNumberContains?: InputMaybe<Scalars['String']>;
  phoneNumberContainsFold?: InputMaybe<Scalars['String']>;
  phoneNumberEqualFold?: InputMaybe<Scalars['String']>;
  phoneNumberGT?: InputMaybe<Scalars['String']>;
  phoneNumberGTE?: InputMaybe<Scalars['String']>;
  phoneNumberHasPrefix?: InputMaybe<Scalars['String']>;
  phoneNumberHasSuffix?: InputMaybe<Scalars['String']>;
  phoneNumberIn?: InputMaybe<Array<Scalars['String']>>;
  phoneNumberLT?: InputMaybe<Scalars['String']>;
  phoneNumberLTE?: InputMaybe<Scalars['String']>;
  phoneNumberNEQ?: InputMaybe<Scalars['String']>;
  phoneNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** state field predicates */
  state?: InputMaybe<Scalars['String']>;
  stateContains?: InputMaybe<Scalars['String']>;
  stateContainsFold?: InputMaybe<Scalars['String']>;
  stateEqualFold?: InputMaybe<Scalars['String']>;
  stateGT?: InputMaybe<Scalars['String']>;
  stateGTE?: InputMaybe<Scalars['String']>;
  stateHasPrefix?: InputMaybe<Scalars['String']>;
  stateHasSuffix?: InputMaybe<Scalars['String']>;
  stateIn?: InputMaybe<Array<Scalars['String']>>;
  stateIsNil?: InputMaybe<Scalars['Boolean']>;
  stateLT?: InputMaybe<Scalars['String']>;
  stateLTE?: InputMaybe<Scalars['String']>;
  stateNEQ?: InputMaybe<Scalars['String']>;
  stateNotIn?: InputMaybe<Array<Scalars['String']>>;
  stateNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** vat_number field predicates */
  vatNumber?: InputMaybe<Scalars['String']>;
  vatNumberContains?: InputMaybe<Scalars['String']>;
  vatNumberContainsFold?: InputMaybe<Scalars['String']>;
  vatNumberEqualFold?: InputMaybe<Scalars['String']>;
  vatNumberGT?: InputMaybe<Scalars['String']>;
  vatNumberGTE?: InputMaybe<Scalars['String']>;
  vatNumberHasPrefix?: InputMaybe<Scalars['String']>;
  vatNumberHasSuffix?: InputMaybe<Scalars['String']>;
  vatNumberIn?: InputMaybe<Array<Scalars['String']>>;
  vatNumberIsNil?: InputMaybe<Scalars['Boolean']>;
  vatNumberLT?: InputMaybe<Scalars['String']>;
  vatNumberLTE?: InputMaybe<Scalars['String']>;
  vatNumberNEQ?: InputMaybe<Scalars['String']>;
  vatNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  vatNumberNotNil?: InputMaybe<Scalars['Boolean']>;
  /** zip field predicates */
  zip?: InputMaybe<Scalars['String']>;
  zipContains?: InputMaybe<Scalars['String']>;
  zipContainsFold?: InputMaybe<Scalars['String']>;
  zipEqualFold?: InputMaybe<Scalars['String']>;
  zipGT?: InputMaybe<Scalars['String']>;
  zipGTE?: InputMaybe<Scalars['String']>;
  zipHasPrefix?: InputMaybe<Scalars['String']>;
  zipHasSuffix?: InputMaybe<Scalars['String']>;
  zipIn?: InputMaybe<Array<Scalars['String']>>;
  zipLT?: InputMaybe<Scalars['String']>;
  zipLTE?: InputMaybe<Scalars['String']>;
  zipNEQ?: InputMaybe<Scalars['String']>;
  zipNotIn?: InputMaybe<Array<Scalars['String']>>;
};

export type BuildInfo = {
  Hash: Scalars['String'];
  LimitedSystem: Scalars['Boolean'];
  Time: Scalars['String'];
};

export type BulkUpdateMessage = {
  msg: Scalars['String'];
  success: Scalars['Boolean'];
};

export type BusinessHoursPeriod = Node & {
  closing: Scalars['Time'];
  dayOfWeek: BusinessHoursPeriodDayOfWeek;
  id: Scalars['ID'];
  opening: Scalars['Time'];
  parcelShop: ParcelShop;
};

/** A connection to a list of items. */
export type BusinessHoursPeriodConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<BusinessHoursPeriodEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** BusinessHoursPeriodDayOfWeek is enum for the field day_of_week */
export enum BusinessHoursPeriodDayOfWeek {
  Friday = 'FRIDAY',
  Monday = 'MONDAY',
  Saturday = 'SATURDAY',
  Sunday = 'SUNDAY',
  Thursday = 'THURSDAY',
  Tuesday = 'TUESDAY',
  Wednesday = 'WEDNESDAY'
}

/** An edge in a connection. */
export type BusinessHoursPeriodEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<BusinessHoursPeriod>;
};

/**
 * BusinessHoursPeriodWhereInput is used for filtering BusinessHoursPeriod objects.
 * Input was generated by ent.
 */
export type BusinessHoursPeriodWhereInput = {
  and?: InputMaybe<Array<BusinessHoursPeriodWhereInput>>;
  /** closing field predicates */
  closing?: InputMaybe<Scalars['Time']>;
  closingGT?: InputMaybe<Scalars['Time']>;
  closingGTE?: InputMaybe<Scalars['Time']>;
  closingIn?: InputMaybe<Array<Scalars['Time']>>;
  closingLT?: InputMaybe<Scalars['Time']>;
  closingLTE?: InputMaybe<Scalars['Time']>;
  closingNEQ?: InputMaybe<Scalars['Time']>;
  closingNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** day_of_week field predicates */
  dayOfWeek?: InputMaybe<BusinessHoursPeriodDayOfWeek>;
  dayOfWeekIn?: InputMaybe<Array<BusinessHoursPeriodDayOfWeek>>;
  dayOfWeekNEQ?: InputMaybe<BusinessHoursPeriodDayOfWeek>;
  dayOfWeekNotIn?: InputMaybe<Array<BusinessHoursPeriodDayOfWeek>>;
  /** parcel_shop edge predicates */
  hasParcelShop?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopWith?: InputMaybe<Array<ParcelShopWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<BusinessHoursPeriodWhereInput>;
  /** opening field predicates */
  opening?: InputMaybe<Scalars['Time']>;
  openingGT?: InputMaybe<Scalars['Time']>;
  openingGTE?: InputMaybe<Scalars['Time']>;
  openingIn?: InputMaybe<Array<Scalars['Time']>>;
  openingLT?: InputMaybe<Scalars['Time']>;
  openingLTE?: InputMaybe<Scalars['Time']>;
  openingNEQ?: InputMaybe<Scalars['Time']>;
  openingNotIn?: InputMaybe<Array<Scalars['Time']>>;
  or?: InputMaybe<Array<BusinessHoursPeriodWhereInput>>;
};

export type Carrier = Node & {
  carrierBrand: CarrierBrand;
  carrierBring?: Maybe<CarrierBring>;
  carrierDAO?: Maybe<CarrierDao>;
  carrierDF?: Maybe<CarrierDf>;
  carrierDSV?: Maybe<CarrierDsv>;
  carrierEasyPost?: Maybe<CarrierEasyPost>;
  carrierGLS?: Maybe<CarrierGls>;
  carrierPostNord?: Maybe<CarrierPostNord>;
  carrierUSPS?: Maybe<CarrierUsps>;
  deliveryOption?: Maybe<Array<DeliveryOption>>;
  id: Scalars['ID'];
  name: Scalars['String'];
  shipment?: Maybe<Array<Shipment>>;
  syncCancelation: Scalars['Boolean'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

export type CarrierAdditionalServiceBring = Node & {
  apiCodeBooking: Scalars['String'];
  carrierServiceBring?: Maybe<CarrierServiceBring>;
  deliveryOptionBring?: Maybe<Array<DeliveryOptionBring>>;
  id: Scalars['ID'];
  label: Scalars['String'];
};

/** A connection to a list of items. */
export type CarrierAdditionalServiceBringConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierAdditionalServiceBringEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierAdditionalServiceBringEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierAdditionalServiceBring>;
};

/**
 * CarrierAdditionalServiceBringWhereInput is used for filtering CarrierAdditionalServiceBring objects.
 * Input was generated by ent.
 */
export type CarrierAdditionalServiceBringWhereInput = {
  and?: InputMaybe<Array<CarrierAdditionalServiceBringWhereInput>>;
  /** api_code_booking field predicates */
  apiCodeBooking?: InputMaybe<Scalars['String']>;
  apiCodeBookingContains?: InputMaybe<Scalars['String']>;
  apiCodeBookingContainsFold?: InputMaybe<Scalars['String']>;
  apiCodeBookingEqualFold?: InputMaybe<Scalars['String']>;
  apiCodeBookingGT?: InputMaybe<Scalars['String']>;
  apiCodeBookingGTE?: InputMaybe<Scalars['String']>;
  apiCodeBookingHasPrefix?: InputMaybe<Scalars['String']>;
  apiCodeBookingHasSuffix?: InputMaybe<Scalars['String']>;
  apiCodeBookingIn?: InputMaybe<Array<Scalars['String']>>;
  apiCodeBookingLT?: InputMaybe<Scalars['String']>;
  apiCodeBookingLTE?: InputMaybe<Scalars['String']>;
  apiCodeBookingNEQ?: InputMaybe<Scalars['String']>;
  apiCodeBookingNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier_service_bring edge predicates */
  hasCarrierServiceBring?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceBringWith?: InputMaybe<Array<CarrierServiceBringWhereInput>>;
  /** delivery_option_bring edge predicates */
  hasDeliveryOptionBring?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionBringWith?: InputMaybe<Array<DeliveryOptionBringWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CarrierAdditionalServiceBringWhereInput>;
  or?: InputMaybe<Array<CarrierAdditionalServiceBringWhereInput>>;
};

export type CarrierAdditionalServiceDao = Node & {
  apiCode: Scalars['String'];
  carrierServiceDAO?: Maybe<Array<CarrierServiceDao>>;
  deliveryOptionDAO?: Maybe<Array<DeliveryOptionDao>>;
  id: Scalars['ID'];
  label: Scalars['String'];
};

/** A connection to a list of items. */
export type CarrierAdditionalServiceDaoConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierAdditionalServiceDaoEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierAdditionalServiceDaoEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierAdditionalServiceDao>;
};

/**
 * CarrierAdditionalServiceDAOWhereInput is used for filtering CarrierAdditionalServiceDAO objects.
 * Input was generated by ent.
 */
export type CarrierAdditionalServiceDaoWhereInput = {
  and?: InputMaybe<Array<CarrierAdditionalServiceDaoWhereInput>>;
  /** api_code field predicates */
  apiCode?: InputMaybe<Scalars['String']>;
  apiCodeContains?: InputMaybe<Scalars['String']>;
  apiCodeContainsFold?: InputMaybe<Scalars['String']>;
  apiCodeEqualFold?: InputMaybe<Scalars['String']>;
  apiCodeGT?: InputMaybe<Scalars['String']>;
  apiCodeGTE?: InputMaybe<Scalars['String']>;
  apiCodeHasPrefix?: InputMaybe<Scalars['String']>;
  apiCodeHasSuffix?: InputMaybe<Scalars['String']>;
  apiCodeIn?: InputMaybe<Array<Scalars['String']>>;
  apiCodeLT?: InputMaybe<Scalars['String']>;
  apiCodeLTE?: InputMaybe<Scalars['String']>;
  apiCodeNEQ?: InputMaybe<Scalars['String']>;
  apiCodeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier_service_dao edge predicates */
  hasCarrierServiceDAO?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceDAOWith?: InputMaybe<Array<CarrierServiceDaoWhereInput>>;
  /** delivery_option_dao edge predicates */
  hasDeliveryOptionDAO?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionDAOWith?: InputMaybe<Array<DeliveryOptionDaoWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CarrierAdditionalServiceDaoWhereInput>;
  or?: InputMaybe<Array<CarrierAdditionalServiceDaoWhereInput>>;
};

export type CarrierAdditionalServiceDf = Node & {
  apiCode: Scalars['String'];
  carrierServiceDF?: Maybe<Array<CarrierServiceDf>>;
  deliveryOptionDF?: Maybe<Array<DeliveryOptionDf>>;
  id: Scalars['ID'];
  label: Scalars['String'];
};

/** A connection to a list of items. */
export type CarrierAdditionalServiceDfConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierAdditionalServiceDfEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierAdditionalServiceDfEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierAdditionalServiceDf>;
};

/**
 * CarrierAdditionalServiceDFWhereInput is used for filtering CarrierAdditionalServiceDF objects.
 * Input was generated by ent.
 */
export type CarrierAdditionalServiceDfWhereInput = {
  and?: InputMaybe<Array<CarrierAdditionalServiceDfWhereInput>>;
  /** api_code field predicates */
  apiCode?: InputMaybe<Scalars['String']>;
  apiCodeContains?: InputMaybe<Scalars['String']>;
  apiCodeContainsFold?: InputMaybe<Scalars['String']>;
  apiCodeEqualFold?: InputMaybe<Scalars['String']>;
  apiCodeGT?: InputMaybe<Scalars['String']>;
  apiCodeGTE?: InputMaybe<Scalars['String']>;
  apiCodeHasPrefix?: InputMaybe<Scalars['String']>;
  apiCodeHasSuffix?: InputMaybe<Scalars['String']>;
  apiCodeIn?: InputMaybe<Array<Scalars['String']>>;
  apiCodeLT?: InputMaybe<Scalars['String']>;
  apiCodeLTE?: InputMaybe<Scalars['String']>;
  apiCodeNEQ?: InputMaybe<Scalars['String']>;
  apiCodeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier_service_df edge predicates */
  hasCarrierServiceDF?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceDFWith?: InputMaybe<Array<CarrierServiceDfWhereInput>>;
  /** delivery_option_df edge predicates */
  hasDeliveryOptionDF?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionDFWith?: InputMaybe<Array<DeliveryOptionDfWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CarrierAdditionalServiceDfWhereInput>;
  or?: InputMaybe<Array<CarrierAdditionalServiceDfWhereInput>>;
};

export type CarrierAdditionalServiceDsv = Node & {
  apiCode: Scalars['String'];
  carrierServiceDSV?: Maybe<Array<CarrierServiceDsv>>;
  deliveryOptionDSV?: Maybe<Array<DeliveryOptionDsv>>;
  id: Scalars['ID'];
  label: Scalars['String'];
};

/** A connection to a list of items. */
export type CarrierAdditionalServiceDsvConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierAdditionalServiceDsvEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierAdditionalServiceDsvEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierAdditionalServiceDsv>;
};

/**
 * CarrierAdditionalServiceDSVWhereInput is used for filtering CarrierAdditionalServiceDSV objects.
 * Input was generated by ent.
 */
export type CarrierAdditionalServiceDsvWhereInput = {
  and?: InputMaybe<Array<CarrierAdditionalServiceDsvWhereInput>>;
  /** api_code field predicates */
  apiCode?: InputMaybe<Scalars['String']>;
  apiCodeContains?: InputMaybe<Scalars['String']>;
  apiCodeContainsFold?: InputMaybe<Scalars['String']>;
  apiCodeEqualFold?: InputMaybe<Scalars['String']>;
  apiCodeGT?: InputMaybe<Scalars['String']>;
  apiCodeGTE?: InputMaybe<Scalars['String']>;
  apiCodeHasPrefix?: InputMaybe<Scalars['String']>;
  apiCodeHasSuffix?: InputMaybe<Scalars['String']>;
  apiCodeIn?: InputMaybe<Array<Scalars['String']>>;
  apiCodeLT?: InputMaybe<Scalars['String']>;
  apiCodeLTE?: InputMaybe<Scalars['String']>;
  apiCodeNEQ?: InputMaybe<Scalars['String']>;
  apiCodeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier_service_dsv edge predicates */
  hasCarrierServiceDSV?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceDSVWith?: InputMaybe<Array<CarrierServiceDsvWhereInput>>;
  /** delivery_option_dsv edge predicates */
  hasDeliveryOptionDSV?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionDSVWith?: InputMaybe<Array<DeliveryOptionDsvWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CarrierAdditionalServiceDsvWhereInput>;
  or?: InputMaybe<Array<CarrierAdditionalServiceDsvWhereInput>>;
};

export type CarrierAdditionalServiceEasyPost = Node & {
  apiKey: Scalars['String'];
  apiValue: Scalars['String'];
  carrierServiceEasyPost?: Maybe<Array<CarrierServiceEasyPost>>;
  deliveryOptionEasyPost?: Maybe<Array<DeliveryOptionEasyPost>>;
  id: Scalars['ID'];
  label: Scalars['String'];
};

/** A connection to a list of items. */
export type CarrierAdditionalServiceEasyPostConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierAdditionalServiceEasyPostEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierAdditionalServiceEasyPostEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierAdditionalServiceEasyPost>;
};

/**
 * CarrierAdditionalServiceEasyPostWhereInput is used for filtering CarrierAdditionalServiceEasyPost objects.
 * Input was generated by ent.
 */
export type CarrierAdditionalServiceEasyPostWhereInput = {
  and?: InputMaybe<Array<CarrierAdditionalServiceEasyPostWhereInput>>;
  /** api_key field predicates */
  apiKey?: InputMaybe<Scalars['String']>;
  apiKeyContains?: InputMaybe<Scalars['String']>;
  apiKeyContainsFold?: InputMaybe<Scalars['String']>;
  apiKeyEqualFold?: InputMaybe<Scalars['String']>;
  apiKeyGT?: InputMaybe<Scalars['String']>;
  apiKeyGTE?: InputMaybe<Scalars['String']>;
  apiKeyHasPrefix?: InputMaybe<Scalars['String']>;
  apiKeyHasSuffix?: InputMaybe<Scalars['String']>;
  apiKeyIn?: InputMaybe<Array<Scalars['String']>>;
  apiKeyLT?: InputMaybe<Scalars['String']>;
  apiKeyLTE?: InputMaybe<Scalars['String']>;
  apiKeyNEQ?: InputMaybe<Scalars['String']>;
  apiKeyNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** api_value field predicates */
  apiValue?: InputMaybe<Scalars['String']>;
  apiValueContains?: InputMaybe<Scalars['String']>;
  apiValueContainsFold?: InputMaybe<Scalars['String']>;
  apiValueEqualFold?: InputMaybe<Scalars['String']>;
  apiValueGT?: InputMaybe<Scalars['String']>;
  apiValueGTE?: InputMaybe<Scalars['String']>;
  apiValueHasPrefix?: InputMaybe<Scalars['String']>;
  apiValueHasSuffix?: InputMaybe<Scalars['String']>;
  apiValueIn?: InputMaybe<Array<Scalars['String']>>;
  apiValueLT?: InputMaybe<Scalars['String']>;
  apiValueLTE?: InputMaybe<Scalars['String']>;
  apiValueNEQ?: InputMaybe<Scalars['String']>;
  apiValueNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier_service_easy_post edge predicates */
  hasCarrierServiceEasyPost?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceEasyPostWith?: InputMaybe<Array<CarrierServiceEasyPostWhereInput>>;
  /** delivery_option_easy_post edge predicates */
  hasDeliveryOptionEasyPost?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionEasyPostWith?: InputMaybe<Array<DeliveryOptionEasyPostWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CarrierAdditionalServiceEasyPostWhereInput>;
  or?: InputMaybe<Array<CarrierAdditionalServiceEasyPostWhereInput>>;
};

export type CarrierAdditionalServiceGls = Node & {
  /** When false, only edge countries will validate on this consignee service */
  allCountriesConsignee: Scalars['Boolean'];
  /** When false, only edge countries will validate on this consignor service */
  allCountriesConsignor: Scalars['Boolean'];
  carrierServiceGLS?: Maybe<CarrierServiceGls>;
  countriesConsignee?: Maybe<Array<Country>>;
  countriesConsignor?: Maybe<Array<Country>>;
  deliveryOptionGLS?: Maybe<Array<DeliveryOptionGls>>;
  id: Scalars['ID'];
  internalID: Scalars['String'];
  label: Scalars['String'];
  mandatory: Scalars['Boolean'];
};

/** A connection to a list of items. */
export type CarrierAdditionalServiceGlsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierAdditionalServiceGlsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierAdditionalServiceGlsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierAdditionalServiceGls>;
};

/**
 * CarrierAdditionalServiceGLSWhereInput is used for filtering CarrierAdditionalServiceGLS objects.
 * Input was generated by ent.
 */
export type CarrierAdditionalServiceGlsWhereInput = {
  /** all_countries_consignee field predicates */
  allCountriesConsignee?: InputMaybe<Scalars['Boolean']>;
  allCountriesConsigneeNEQ?: InputMaybe<Scalars['Boolean']>;
  /** all_countries_consignor field predicates */
  allCountriesConsignor?: InputMaybe<Scalars['Boolean']>;
  allCountriesConsignorNEQ?: InputMaybe<Scalars['Boolean']>;
  and?: InputMaybe<Array<CarrierAdditionalServiceGlsWhereInput>>;
  /** carrier_service_gls edge predicates */
  hasCarrierServiceGLS?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceGLSWith?: InputMaybe<Array<CarrierServiceGlsWhereInput>>;
  /** countries_consignee edge predicates */
  hasCountriesConsignee?: InputMaybe<Scalars['Boolean']>;
  hasCountriesConsigneeWith?: InputMaybe<Array<CountryWhereInput>>;
  /** countries_consignor edge predicates */
  hasCountriesConsignor?: InputMaybe<Scalars['Boolean']>;
  hasCountriesConsignorWith?: InputMaybe<Array<CountryWhereInput>>;
  /** delivery_option_gls edge predicates */
  hasDeliveryOptionGLS?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionGLSWith?: InputMaybe<Array<DeliveryOptionGlsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_id field predicates */
  internalID?: InputMaybe<Scalars['String']>;
  internalIDContains?: InputMaybe<Scalars['String']>;
  internalIDContainsFold?: InputMaybe<Scalars['String']>;
  internalIDEqualFold?: InputMaybe<Scalars['String']>;
  internalIDGT?: InputMaybe<Scalars['String']>;
  internalIDGTE?: InputMaybe<Scalars['String']>;
  internalIDHasPrefix?: InputMaybe<Scalars['String']>;
  internalIDHasSuffix?: InputMaybe<Scalars['String']>;
  internalIDIn?: InputMaybe<Array<Scalars['String']>>;
  internalIDLT?: InputMaybe<Scalars['String']>;
  internalIDLTE?: InputMaybe<Scalars['String']>;
  internalIDNEQ?: InputMaybe<Scalars['String']>;
  internalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** mandatory field predicates */
  mandatory?: InputMaybe<Scalars['Boolean']>;
  mandatoryNEQ?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<CarrierAdditionalServiceGlsWhereInput>;
  or?: InputMaybe<Array<CarrierAdditionalServiceGlsWhereInput>>;
};

export type CarrierAdditionalServicePostNord = Node & {
  /** When false, only edge countries will validate on this consignee service */
  allCountriesConsignee: Scalars['Boolean'];
  /** When false, only edge countries will validate on this consignor service */
  allCountriesConsignor: Scalars['Boolean'];
  /** 2 characters code identifying the additional service in the API request */
  apiCode: Scalars['String'];
  carrierServicePostNord?: Maybe<CarrierServicePostNord>;
  countriesConsignee?: Maybe<Array<Country>>;
  countriesConsignor?: Maybe<Array<Country>>;
  deliveryOptionPostNord?: Maybe<Array<DeliveryOptionPostNord>>;
  id: Scalars['ID'];
  internalID: Scalars['String'];
  label: Scalars['String'];
  mandatory: Scalars['Boolean'];
};

/** A connection to a list of items. */
export type CarrierAdditionalServicePostNordConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierAdditionalServicePostNordEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierAdditionalServicePostNordEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierAdditionalServicePostNord>;
};

/**
 * CarrierAdditionalServicePostNordWhereInput is used for filtering CarrierAdditionalServicePostNord objects.
 * Input was generated by ent.
 */
export type CarrierAdditionalServicePostNordWhereInput = {
  /** all_countries_consignee field predicates */
  allCountriesConsignee?: InputMaybe<Scalars['Boolean']>;
  allCountriesConsigneeNEQ?: InputMaybe<Scalars['Boolean']>;
  /** all_countries_consignor field predicates */
  allCountriesConsignor?: InputMaybe<Scalars['Boolean']>;
  allCountriesConsignorNEQ?: InputMaybe<Scalars['Boolean']>;
  and?: InputMaybe<Array<CarrierAdditionalServicePostNordWhereInput>>;
  /** api_code field predicates */
  apiCode?: InputMaybe<Scalars['String']>;
  apiCodeContains?: InputMaybe<Scalars['String']>;
  apiCodeContainsFold?: InputMaybe<Scalars['String']>;
  apiCodeEqualFold?: InputMaybe<Scalars['String']>;
  apiCodeGT?: InputMaybe<Scalars['String']>;
  apiCodeGTE?: InputMaybe<Scalars['String']>;
  apiCodeHasPrefix?: InputMaybe<Scalars['String']>;
  apiCodeHasSuffix?: InputMaybe<Scalars['String']>;
  apiCodeIn?: InputMaybe<Array<Scalars['String']>>;
  apiCodeLT?: InputMaybe<Scalars['String']>;
  apiCodeLTE?: InputMaybe<Scalars['String']>;
  apiCodeNEQ?: InputMaybe<Scalars['String']>;
  apiCodeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier_service_post_nord edge predicates */
  hasCarrierServicePostNord?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServicePostNordWith?: InputMaybe<Array<CarrierServicePostNordWhereInput>>;
  /** countries_consignee edge predicates */
  hasCountriesConsignee?: InputMaybe<Scalars['Boolean']>;
  hasCountriesConsigneeWith?: InputMaybe<Array<CountryWhereInput>>;
  /** countries_consignor edge predicates */
  hasCountriesConsignor?: InputMaybe<Scalars['Boolean']>;
  hasCountriesConsignorWith?: InputMaybe<Array<CountryWhereInput>>;
  /** delivery_option_post_nord edge predicates */
  hasDeliveryOptionPostNord?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionPostNordWith?: InputMaybe<Array<DeliveryOptionPostNordWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_id field predicates */
  internalID?: InputMaybe<Scalars['String']>;
  internalIDContains?: InputMaybe<Scalars['String']>;
  internalIDContainsFold?: InputMaybe<Scalars['String']>;
  internalIDEqualFold?: InputMaybe<Scalars['String']>;
  internalIDGT?: InputMaybe<Scalars['String']>;
  internalIDGTE?: InputMaybe<Scalars['String']>;
  internalIDHasPrefix?: InputMaybe<Scalars['String']>;
  internalIDHasSuffix?: InputMaybe<Scalars['String']>;
  internalIDIn?: InputMaybe<Array<Scalars['String']>>;
  internalIDLT?: InputMaybe<Scalars['String']>;
  internalIDLTE?: InputMaybe<Scalars['String']>;
  internalIDNEQ?: InputMaybe<Scalars['String']>;
  internalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** mandatory field predicates */
  mandatory?: InputMaybe<Scalars['Boolean']>;
  mandatoryNEQ?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<CarrierAdditionalServicePostNordWhereInput>;
  or?: InputMaybe<Array<CarrierAdditionalServicePostNordWhereInput>>;
};

export type CarrierAdditionalServiceUsps = Node & {
  /** ServiceID to be included in XML payload */
  apiCode: Scalars['String'];
  carrierServiceUSPS?: Maybe<CarrierServiceUsps>;
  /** For filtering away rarely used options in the UI */
  commonlyUsed: Scalars['Boolean'];
  deliveryOptionUSPS?: Maybe<Array<DeliveryOptionUsps>>;
  id: Scalars['ID'];
  internalID: CarrierAdditionalServiceUspsInternalId;
  label: Scalars['String'];
};

/** A connection to a list of items. */
export type CarrierAdditionalServiceUspsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierAdditionalServiceUspsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierAdditionalServiceUspsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierAdditionalServiceUsps>;
};

/** CarrierAdditionalServiceUSPSInternalID is enum for the field internal_id */
export enum CarrierAdditionalServiceUspsInternalId {
  AdultSignatureRequired = 'adult_signature_required',
  AdultSignatureRestrictedDelivery = 'adult_signature_restricted_delivery',
  CertifiedMail = 'certified_mail',
  CertifiedMailAdultSignatureRequired = 'certified_mail_adult_signature_required',
  CertifiedMailAdultSignatureRestrictedDelivery = 'certified_mail_adult_signature_restricted_delivery',
  CertifiedMailRestrictedDelivery = 'certified_mail_restricted_delivery',
  GlobalDirectEntry = 'global_direct_entry',
  HazardousMaterials = 'hazardous_materials',
  HazardousMaterialsAirEligibleEthanol = 'hazardous_materials_air_eligible_ethanol',
  HazardousMaterialsAirEligibleId8000ConsumerCommodity = 'hazardous_materials_air_eligible_id8000_consumer_commodity',
  HazardousMaterialsClass_1ToyPropellant = 'hazardous_materials_class_1_toy_propellant',
  HazardousMaterialsClass_3FlammableAndCombustibleLiquids = 'hazardous_materials_class_3_flammable_and_combustible_liquids',
  HazardousMaterialsClass_7RadioactiveMaterials = 'hazardous_materials_class_7_radioactive_materials',
  HazardousMaterialsClass_8AirEligibleCorrosiveMaterials = 'hazardous_materials_class_8_air_eligible_corrosive_materials',
  HazardousMaterialsClass_8NonspillableWetBatteries = 'hazardous_materials_class_8_nonspillable_wet_batteries',
  HazardousMaterialsClass_9DryIce = 'hazardous_materials_class_9_dry_ice',
  HazardousMaterialsClass_9LithiumBatteryMarkedGroundOnly = 'hazardous_materials_class_9_lithium_battery_marked_ground_only',
  HazardousMaterialsClass_9LithiumBatteryReturns = 'hazardous_materials_class_9_lithium_battery_returns',
  HazardousMaterialsClass_9MagnetizedMaterials = 'hazardous_materials_class_9_magnetized_materials',
  HazardousMaterialsClass_9MarkedLithiumBattery = 'hazardous_materials_class_9_marked_lithium_battery',
  HazardousMaterialsClass_9UnmarkedLithiumBatteries = 'hazardous_materials_class_9_unmarked_lithium_batteries',
  HazardousMaterialsDivision_4_1MailableFlammableSolidsAndSafetyMatches = 'hazardous_materials_division_4_1_mailable_flammable_solids_and_safety_matches',
  HazardousMaterialsDivision_5_2OrganicPeroxides = 'hazardous_materials_division_5_2_organic_peroxides',
  HazardousMaterialsDivision_6_1ToxicMaterials = 'hazardous_materials_division_6_1_toxic_materials',
  HazardousMaterialsDivision_6_2BiologicalMaterials = 'hazardous_materials_division_6_2_biological_materials',
  HazardousMaterialsExceptedQuantityProvision = 'hazardous_materials_excepted_quantity_provision',
  HazardousMaterialsGroundOnlyHazardousMaterials = 'hazardous_materials_ground_only_hazardous_materials',
  HazardousMaterialsLighters = 'hazardous_materials_lighters',
  HazardousMaterialsLimitedQuantityGround = 'hazardous_materials_limited_quantity_ground',
  HazardousMaterialsSmallQuantityProvisionMarkingsRequired = 'hazardous_materials_small_quantity_provision_markings_required',
  Insurance = 'insurance',
  InsuranceRestrictedDelivery = 'insurance_restricted_delivery',
  PoToAddresseePriorityMailExpressOnly = 'po_to_addressee_priority_mail_express_only',
  PriorityMailExpressInsurance = 'priority_mail_express_insurance',
  ReturnReceipt = 'return_receipt',
  ReturnReceiptElectronic = 'return_receipt_electronic',
  SignatureConfirmation = 'signature_confirmation',
  SignatureConfirmationRestrictedDelivery = 'signature_confirmation_restricted_delivery',
  SignatureRequestedPriorityMailExpressOnly = 'signature_requested_priority_mail_express_only',
  SundayDelivery = 'sunday_delivery',
  TrackingPlus_1Year = 'tracking_plus_1_year',
  TrackingPlus_3Years = 'tracking_plus_3_years',
  TrackingPlus_5Years = 'tracking_plus_5_years',
  TrackingPlus_6Months = 'tracking_plus_6_months',
  TrackingPlus_7Years = 'tracking_plus_7_years',
  TrackingPlus_10Years = 'tracking_plus_10_years',
  TrackingPlusSignature_3Years = 'tracking_plus_signature_3_years',
  TrackingPlusSignature_5Years = 'tracking_plus_signature_5_years',
  TrackingPlusSignature_7Years = 'tracking_plus_signature_7_years',
  TrackingPlusSignature_10Years = 'tracking_plus_signature_10_years',
  UspsLabelDeliveryService = 'usps_label_delivery_service',
  UspsTrackingElectronic = 'usps_tracking_electronic'
}

/**
 * CarrierAdditionalServiceUSPSWhereInput is used for filtering CarrierAdditionalServiceUSPS objects.
 * Input was generated by ent.
 */
export type CarrierAdditionalServiceUspsWhereInput = {
  and?: InputMaybe<Array<CarrierAdditionalServiceUspsWhereInput>>;
  /** api_code field predicates */
  apiCode?: InputMaybe<Scalars['String']>;
  apiCodeContains?: InputMaybe<Scalars['String']>;
  apiCodeContainsFold?: InputMaybe<Scalars['String']>;
  apiCodeEqualFold?: InputMaybe<Scalars['String']>;
  apiCodeGT?: InputMaybe<Scalars['String']>;
  apiCodeGTE?: InputMaybe<Scalars['String']>;
  apiCodeHasPrefix?: InputMaybe<Scalars['String']>;
  apiCodeHasSuffix?: InputMaybe<Scalars['String']>;
  apiCodeIn?: InputMaybe<Array<Scalars['String']>>;
  apiCodeLT?: InputMaybe<Scalars['String']>;
  apiCodeLTE?: InputMaybe<Scalars['String']>;
  apiCodeNEQ?: InputMaybe<Scalars['String']>;
  apiCodeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** commonly_used field predicates */
  commonlyUsed?: InputMaybe<Scalars['Boolean']>;
  commonlyUsedNEQ?: InputMaybe<Scalars['Boolean']>;
  /** carrier_service_usps edge predicates */
  hasCarrierServiceUSPS?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceUSPSWith?: InputMaybe<Array<CarrierServiceUspsWhereInput>>;
  /** delivery_option_usps edge predicates */
  hasDeliveryOptionUSPS?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionUSPSWith?: InputMaybe<Array<DeliveryOptionUspsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_id field predicates */
  internalID?: InputMaybe<CarrierAdditionalServiceUspsInternalId>;
  internalIDIn?: InputMaybe<Array<CarrierAdditionalServiceUspsInternalId>>;
  internalIDNEQ?: InputMaybe<CarrierAdditionalServiceUspsInternalId>;
  internalIDNotIn?: InputMaybe<Array<CarrierAdditionalServiceUspsInternalId>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CarrierAdditionalServiceUspsWhereInput>;
  or?: InputMaybe<Array<CarrierAdditionalServiceUspsWhereInput>>;
};

export type CarrierBrand = Node & {
  backgroundColor?: Maybe<Scalars['String']>;
  carrier?: Maybe<Array<Carrier>>;
  carrierService?: Maybe<Array<CarrierService>>;
  document?: Maybe<Array<Document>>;
  id: Scalars['ID'];
  internalID: CarrierBrandInternalId;
  label: Scalars['String'];
  /** Accommodation for PostNord to become PN */
  labelShort: Scalars['String'];
  logoURL?: Maybe<Scalars['String']>;
  packaging?: Maybe<Array<Packaging>>;
  parcelShop?: Maybe<Array<ParcelShop>>;
  textColor?: Maybe<Scalars['String']>;
};

/** A connection to a list of items. */
export type CarrierBrandConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierBrandEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierBrandEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierBrand>;
};

/** CarrierBrandInternalID is enum for the field internal_id */
export enum CarrierBrandInternalId {
  Bring = 'bring',
  Dao = 'dao',
  Df = 'df',
  Dhl = 'dhl',
  Dsv = 'dsv',
  EasyPost = 'easy_post',
  Gls = 'gls',
  PostNord = 'post_nord',
  Usps = 'usps'
}

/**
 * CarrierBrandWhereInput is used for filtering CarrierBrand objects.
 * Input was generated by ent.
 */
export type CarrierBrandWhereInput = {
  and?: InputMaybe<Array<CarrierBrandWhereInput>>;
  /** background_color field predicates */
  backgroundColor?: InputMaybe<Scalars['String']>;
  backgroundColorContains?: InputMaybe<Scalars['String']>;
  backgroundColorContainsFold?: InputMaybe<Scalars['String']>;
  backgroundColorEqualFold?: InputMaybe<Scalars['String']>;
  backgroundColorGT?: InputMaybe<Scalars['String']>;
  backgroundColorGTE?: InputMaybe<Scalars['String']>;
  backgroundColorHasPrefix?: InputMaybe<Scalars['String']>;
  backgroundColorHasSuffix?: InputMaybe<Scalars['String']>;
  backgroundColorIn?: InputMaybe<Array<Scalars['String']>>;
  backgroundColorIsNil?: InputMaybe<Scalars['Boolean']>;
  backgroundColorLT?: InputMaybe<Scalars['String']>;
  backgroundColorLTE?: InputMaybe<Scalars['String']>;
  backgroundColorNEQ?: InputMaybe<Scalars['String']>;
  backgroundColorNotIn?: InputMaybe<Array<Scalars['String']>>;
  backgroundColorNotNil?: InputMaybe<Scalars['Boolean']>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  /** carrier_service edge predicates */
  hasCarrierService?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceWith?: InputMaybe<Array<CarrierServiceWhereInput>>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** document edge predicates */
  hasDocument?: InputMaybe<Scalars['Boolean']>;
  hasDocumentWith?: InputMaybe<Array<DocumentWhereInput>>;
  /** packaging edge predicates */
  hasPackaging?: InputMaybe<Scalars['Boolean']>;
  hasPackagingWith?: InputMaybe<Array<PackagingWhereInput>>;
  /** parcel_shop edge predicates */
  hasParcelShop?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopWith?: InputMaybe<Array<ParcelShopWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_id field predicates */
  internalID?: InputMaybe<CarrierBrandInternalId>;
  internalIDIn?: InputMaybe<Array<CarrierBrandInternalId>>;
  internalIDNEQ?: InputMaybe<CarrierBrandInternalId>;
  internalIDNotIn?: InputMaybe<Array<CarrierBrandInternalId>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** label_short field predicates */
  labelShort?: InputMaybe<Scalars['String']>;
  labelShortContains?: InputMaybe<Scalars['String']>;
  labelShortContainsFold?: InputMaybe<Scalars['String']>;
  labelShortEqualFold?: InputMaybe<Scalars['String']>;
  labelShortGT?: InputMaybe<Scalars['String']>;
  labelShortGTE?: InputMaybe<Scalars['String']>;
  labelShortHasPrefix?: InputMaybe<Scalars['String']>;
  labelShortHasSuffix?: InputMaybe<Scalars['String']>;
  labelShortIn?: InputMaybe<Array<Scalars['String']>>;
  labelShortLT?: InputMaybe<Scalars['String']>;
  labelShortLTE?: InputMaybe<Scalars['String']>;
  labelShortNEQ?: InputMaybe<Scalars['String']>;
  labelShortNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** logo_url field predicates */
  logoURL?: InputMaybe<Scalars['String']>;
  logoURLContains?: InputMaybe<Scalars['String']>;
  logoURLContainsFold?: InputMaybe<Scalars['String']>;
  logoURLEqualFold?: InputMaybe<Scalars['String']>;
  logoURLGT?: InputMaybe<Scalars['String']>;
  logoURLGTE?: InputMaybe<Scalars['String']>;
  logoURLHasPrefix?: InputMaybe<Scalars['String']>;
  logoURLHasSuffix?: InputMaybe<Scalars['String']>;
  logoURLIn?: InputMaybe<Array<Scalars['String']>>;
  logoURLIsNil?: InputMaybe<Scalars['Boolean']>;
  logoURLLT?: InputMaybe<Scalars['String']>;
  logoURLLTE?: InputMaybe<Scalars['String']>;
  logoURLNEQ?: InputMaybe<Scalars['String']>;
  logoURLNotIn?: InputMaybe<Array<Scalars['String']>>;
  logoURLNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<CarrierBrandWhereInput>;
  or?: InputMaybe<Array<CarrierBrandWhereInput>>;
  /** text_color field predicates */
  textColor?: InputMaybe<Scalars['String']>;
  textColorContains?: InputMaybe<Scalars['String']>;
  textColorContainsFold?: InputMaybe<Scalars['String']>;
  textColorEqualFold?: InputMaybe<Scalars['String']>;
  textColorGT?: InputMaybe<Scalars['String']>;
  textColorGTE?: InputMaybe<Scalars['String']>;
  textColorHasPrefix?: InputMaybe<Scalars['String']>;
  textColorHasSuffix?: InputMaybe<Scalars['String']>;
  textColorIn?: InputMaybe<Array<Scalars['String']>>;
  textColorIsNil?: InputMaybe<Scalars['Boolean']>;
  textColorLT?: InputMaybe<Scalars['String']>;
  textColorLTE?: InputMaybe<Scalars['String']>;
  textColorNEQ?: InputMaybe<Scalars['String']>;
  textColorNotIn?: InputMaybe<Array<Scalars['String']>>;
  textColorNotNil?: InputMaybe<Scalars['Boolean']>;
};

export type CarrierBring = Node & {
  apiKey?: Maybe<Scalars['String']>;
  carrier: Carrier;
  customerNumber?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
  test: Scalars['Boolean'];
};

/** A connection to a list of items. */
export type CarrierBringConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierBringEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierBringEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierBring>;
};

/**
 * CarrierBringWhereInput is used for filtering CarrierBring objects.
 * Input was generated by ent.
 */
export type CarrierBringWhereInput = {
  and?: InputMaybe<Array<CarrierBringWhereInput>>;
  /** api_key field predicates */
  apiKey?: InputMaybe<Scalars['String']>;
  apiKeyContains?: InputMaybe<Scalars['String']>;
  apiKeyContainsFold?: InputMaybe<Scalars['String']>;
  apiKeyEqualFold?: InputMaybe<Scalars['String']>;
  apiKeyGT?: InputMaybe<Scalars['String']>;
  apiKeyGTE?: InputMaybe<Scalars['String']>;
  apiKeyHasPrefix?: InputMaybe<Scalars['String']>;
  apiKeyHasSuffix?: InputMaybe<Scalars['String']>;
  apiKeyIn?: InputMaybe<Array<Scalars['String']>>;
  apiKeyIsNil?: InputMaybe<Scalars['Boolean']>;
  apiKeyLT?: InputMaybe<Scalars['String']>;
  apiKeyLTE?: InputMaybe<Scalars['String']>;
  apiKeyNEQ?: InputMaybe<Scalars['String']>;
  apiKeyNotIn?: InputMaybe<Array<Scalars['String']>>;
  apiKeyNotNil?: InputMaybe<Scalars['Boolean']>;
  /** customer_number field predicates */
  customerNumber?: InputMaybe<Scalars['String']>;
  customerNumberContains?: InputMaybe<Scalars['String']>;
  customerNumberContainsFold?: InputMaybe<Scalars['String']>;
  customerNumberEqualFold?: InputMaybe<Scalars['String']>;
  customerNumberGT?: InputMaybe<Scalars['String']>;
  customerNumberGTE?: InputMaybe<Scalars['String']>;
  customerNumberHasPrefix?: InputMaybe<Scalars['String']>;
  customerNumberHasSuffix?: InputMaybe<Scalars['String']>;
  customerNumberIn?: InputMaybe<Array<Scalars['String']>>;
  customerNumberIsNil?: InputMaybe<Scalars['Boolean']>;
  customerNumberLT?: InputMaybe<Scalars['String']>;
  customerNumberLTE?: InputMaybe<Scalars['String']>;
  customerNumberNEQ?: InputMaybe<Scalars['String']>;
  customerNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  customerNumberNotNil?: InputMaybe<Scalars['Boolean']>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierBringWhereInput>;
  or?: InputMaybe<Array<CarrierBringWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** test field predicates */
  test?: InputMaybe<Scalars['Boolean']>;
  testNEQ?: InputMaybe<Scalars['Boolean']>;
};

/** A connection to a list of items. */
export type CarrierConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

export type CarrierDao = Node & {
  apiKey?: Maybe<Scalars['String']>;
  carrier: Carrier;
  customerID?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
  test: Scalars['Boolean'];
};

/** A connection to a list of items. */
export type CarrierDaoConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierDaoEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierDaoEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierDao>;
};

/**
 * CarrierDAOWhereInput is used for filtering CarrierDAO objects.
 * Input was generated by ent.
 */
export type CarrierDaoWhereInput = {
  and?: InputMaybe<Array<CarrierDaoWhereInput>>;
  /** api_key field predicates */
  apiKey?: InputMaybe<Scalars['String']>;
  apiKeyContains?: InputMaybe<Scalars['String']>;
  apiKeyContainsFold?: InputMaybe<Scalars['String']>;
  apiKeyEqualFold?: InputMaybe<Scalars['String']>;
  apiKeyGT?: InputMaybe<Scalars['String']>;
  apiKeyGTE?: InputMaybe<Scalars['String']>;
  apiKeyHasPrefix?: InputMaybe<Scalars['String']>;
  apiKeyHasSuffix?: InputMaybe<Scalars['String']>;
  apiKeyIn?: InputMaybe<Array<Scalars['String']>>;
  apiKeyIsNil?: InputMaybe<Scalars['Boolean']>;
  apiKeyLT?: InputMaybe<Scalars['String']>;
  apiKeyLTE?: InputMaybe<Scalars['String']>;
  apiKeyNEQ?: InputMaybe<Scalars['String']>;
  apiKeyNotIn?: InputMaybe<Array<Scalars['String']>>;
  apiKeyNotNil?: InputMaybe<Scalars['Boolean']>;
  /** customer_id field predicates */
  customerID?: InputMaybe<Scalars['String']>;
  customerIDContains?: InputMaybe<Scalars['String']>;
  customerIDContainsFold?: InputMaybe<Scalars['String']>;
  customerIDEqualFold?: InputMaybe<Scalars['String']>;
  customerIDGT?: InputMaybe<Scalars['String']>;
  customerIDGTE?: InputMaybe<Scalars['String']>;
  customerIDHasPrefix?: InputMaybe<Scalars['String']>;
  customerIDHasSuffix?: InputMaybe<Scalars['String']>;
  customerIDIn?: InputMaybe<Array<Scalars['String']>>;
  customerIDIsNil?: InputMaybe<Scalars['Boolean']>;
  customerIDLT?: InputMaybe<Scalars['String']>;
  customerIDLTE?: InputMaybe<Scalars['String']>;
  customerIDNEQ?: InputMaybe<Scalars['String']>;
  customerIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  customerIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierDaoWhereInput>;
  or?: InputMaybe<Array<CarrierDaoWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** Test field predicates */
  test?: InputMaybe<Scalars['Boolean']>;
  testNEQ?: InputMaybe<Scalars['Boolean']>;
};

export type CarrierDf = Node & {
  agreementNumber: Scalars['String'];
  carrier: Carrier;
  customerID: Scalars['String'];
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
  test: Scalars['Boolean'];
  whoPays: CarrierDfWhoPays;
};

/** A connection to a list of items. */
export type CarrierDfConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierDfEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierDfEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierDf>;
};

/**
 * CarrierDFWhereInput is used for filtering CarrierDF objects.
 * Input was generated by ent.
 */
export type CarrierDfWhereInput = {
  /** agreement_number field predicates */
  agreementNumber?: InputMaybe<Scalars['String']>;
  agreementNumberContains?: InputMaybe<Scalars['String']>;
  agreementNumberContainsFold?: InputMaybe<Scalars['String']>;
  agreementNumberEqualFold?: InputMaybe<Scalars['String']>;
  agreementNumberGT?: InputMaybe<Scalars['String']>;
  agreementNumberGTE?: InputMaybe<Scalars['String']>;
  agreementNumberHasPrefix?: InputMaybe<Scalars['String']>;
  agreementNumberHasSuffix?: InputMaybe<Scalars['String']>;
  agreementNumberIn?: InputMaybe<Array<Scalars['String']>>;
  agreementNumberLT?: InputMaybe<Scalars['String']>;
  agreementNumberLTE?: InputMaybe<Scalars['String']>;
  agreementNumberNEQ?: InputMaybe<Scalars['String']>;
  agreementNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  and?: InputMaybe<Array<CarrierDfWhereInput>>;
  /** customer_id field predicates */
  customerID?: InputMaybe<Scalars['String']>;
  customerIDContains?: InputMaybe<Scalars['String']>;
  customerIDContainsFold?: InputMaybe<Scalars['String']>;
  customerIDEqualFold?: InputMaybe<Scalars['String']>;
  customerIDGT?: InputMaybe<Scalars['String']>;
  customerIDGTE?: InputMaybe<Scalars['String']>;
  customerIDHasPrefix?: InputMaybe<Scalars['String']>;
  customerIDHasSuffix?: InputMaybe<Scalars['String']>;
  customerIDIn?: InputMaybe<Array<Scalars['String']>>;
  customerIDLT?: InputMaybe<Scalars['String']>;
  customerIDLTE?: InputMaybe<Scalars['String']>;
  customerIDNEQ?: InputMaybe<Scalars['String']>;
  customerIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierDfWhereInput>;
  or?: InputMaybe<Array<CarrierDfWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** test field predicates */
  test?: InputMaybe<Scalars['Boolean']>;
  testNEQ?: InputMaybe<Scalars['Boolean']>;
  /** who_pays field predicates */
  whoPays?: InputMaybe<CarrierDfWhoPays>;
  whoPaysIn?: InputMaybe<Array<CarrierDfWhoPays>>;
  whoPaysNEQ?: InputMaybe<CarrierDfWhoPays>;
  whoPaysNotIn?: InputMaybe<Array<CarrierDfWhoPays>>;
};

/** CarrierDFWhoPays is enum for the field who_pays */
export enum CarrierDfWhoPays {
  Collect = 'Collect',
  Prepaid = 'Prepaid'
}

export type CarrierDsv = Node & {
  carrier: Carrier;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type CarrierDsvConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierDsvEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierDsvEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierDsv>;
};

/**
 * CarrierDSVWhereInput is used for filtering CarrierDSV objects.
 * Input was generated by ent.
 */
export type CarrierDsvWhereInput = {
  and?: InputMaybe<Array<CarrierDsvWhereInput>>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierDsvWhereInput>;
  or?: InputMaybe<Array<CarrierDsvWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type CarrierEasyPost = Node & {
  apiKey: Scalars['String'];
  carrier: Carrier;
  /** When > 1, then we use rate, then buy. =1 one-call buy. Former not implemented in first round. */
  carrierAccounts: Array<Scalars['String']>;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
  test: Scalars['Boolean'];
};

/** A connection to a list of items. */
export type CarrierEasyPostConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierEasyPostEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierEasyPostEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierEasyPost>;
};

/**
 * CarrierEasyPostWhereInput is used for filtering CarrierEasyPost objects.
 * Input was generated by ent.
 */
export type CarrierEasyPostWhereInput = {
  and?: InputMaybe<Array<CarrierEasyPostWhereInput>>;
  /** api_key field predicates */
  apiKey?: InputMaybe<Scalars['String']>;
  apiKeyContains?: InputMaybe<Scalars['String']>;
  apiKeyContainsFold?: InputMaybe<Scalars['String']>;
  apiKeyEqualFold?: InputMaybe<Scalars['String']>;
  apiKeyGT?: InputMaybe<Scalars['String']>;
  apiKeyGTE?: InputMaybe<Scalars['String']>;
  apiKeyHasPrefix?: InputMaybe<Scalars['String']>;
  apiKeyHasSuffix?: InputMaybe<Scalars['String']>;
  apiKeyIn?: InputMaybe<Array<Scalars['String']>>;
  apiKeyLT?: InputMaybe<Scalars['String']>;
  apiKeyLTE?: InputMaybe<Scalars['String']>;
  apiKeyNEQ?: InputMaybe<Scalars['String']>;
  apiKeyNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierEasyPostWhereInput>;
  or?: InputMaybe<Array<CarrierEasyPostWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** test field predicates */
  test?: InputMaybe<Scalars['Boolean']>;
  testNEQ?: InputMaybe<Scalars['Boolean']>;
};

/** An edge in a connection. */
export type CarrierEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Carrier>;
};

export type CarrierGls = Node & {
  carrier: Carrier;
  contactID?: Maybe<Scalars['String']>;
  customerID?: Maybe<Scalars['String']>;
  glsCountryCode?: Maybe<Scalars['String']>;
  glsPassword?: Maybe<Scalars['String']>;
  glsUsername?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  printErrorOnLabel?: Maybe<Scalars['Boolean']>;
  syncShipmentCancellation?: Maybe<Scalars['Boolean']>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type CarrierGlsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierGlsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierGlsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierGls>;
};

/**
 * CarrierGLSWhereInput is used for filtering CarrierGLS objects.
 * Input was generated by ent.
 */
export type CarrierGlsWhereInput = {
  and?: InputMaybe<Array<CarrierGlsWhereInput>>;
  /** contact_id field predicates */
  contactID?: InputMaybe<Scalars['String']>;
  contactIDContains?: InputMaybe<Scalars['String']>;
  contactIDContainsFold?: InputMaybe<Scalars['String']>;
  contactIDEqualFold?: InputMaybe<Scalars['String']>;
  contactIDGT?: InputMaybe<Scalars['String']>;
  contactIDGTE?: InputMaybe<Scalars['String']>;
  contactIDHasPrefix?: InputMaybe<Scalars['String']>;
  contactIDHasSuffix?: InputMaybe<Scalars['String']>;
  contactIDIn?: InputMaybe<Array<Scalars['String']>>;
  contactIDIsNil?: InputMaybe<Scalars['Boolean']>;
  contactIDLT?: InputMaybe<Scalars['String']>;
  contactIDLTE?: InputMaybe<Scalars['String']>;
  contactIDNEQ?: InputMaybe<Scalars['String']>;
  contactIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  contactIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** customer_id field predicates */
  customerID?: InputMaybe<Scalars['String']>;
  customerIDContains?: InputMaybe<Scalars['String']>;
  customerIDContainsFold?: InputMaybe<Scalars['String']>;
  customerIDEqualFold?: InputMaybe<Scalars['String']>;
  customerIDGT?: InputMaybe<Scalars['String']>;
  customerIDGTE?: InputMaybe<Scalars['String']>;
  customerIDHasPrefix?: InputMaybe<Scalars['String']>;
  customerIDHasSuffix?: InputMaybe<Scalars['String']>;
  customerIDIn?: InputMaybe<Array<Scalars['String']>>;
  customerIDIsNil?: InputMaybe<Scalars['Boolean']>;
  customerIDLT?: InputMaybe<Scalars['String']>;
  customerIDLTE?: InputMaybe<Scalars['String']>;
  customerIDNEQ?: InputMaybe<Scalars['String']>;
  customerIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  customerIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** gls_country_code field predicates */
  glsCountryCode?: InputMaybe<Scalars['String']>;
  glsCountryCodeContains?: InputMaybe<Scalars['String']>;
  glsCountryCodeContainsFold?: InputMaybe<Scalars['String']>;
  glsCountryCodeEqualFold?: InputMaybe<Scalars['String']>;
  glsCountryCodeGT?: InputMaybe<Scalars['String']>;
  glsCountryCodeGTE?: InputMaybe<Scalars['String']>;
  glsCountryCodeHasPrefix?: InputMaybe<Scalars['String']>;
  glsCountryCodeHasSuffix?: InputMaybe<Scalars['String']>;
  glsCountryCodeIn?: InputMaybe<Array<Scalars['String']>>;
  glsCountryCodeIsNil?: InputMaybe<Scalars['Boolean']>;
  glsCountryCodeLT?: InputMaybe<Scalars['String']>;
  glsCountryCodeLTE?: InputMaybe<Scalars['String']>;
  glsCountryCodeNEQ?: InputMaybe<Scalars['String']>;
  glsCountryCodeNotIn?: InputMaybe<Array<Scalars['String']>>;
  glsCountryCodeNotNil?: InputMaybe<Scalars['Boolean']>;
  /** gls_password field predicates */
  glsPassword?: InputMaybe<Scalars['String']>;
  glsPasswordContains?: InputMaybe<Scalars['String']>;
  glsPasswordContainsFold?: InputMaybe<Scalars['String']>;
  glsPasswordEqualFold?: InputMaybe<Scalars['String']>;
  glsPasswordGT?: InputMaybe<Scalars['String']>;
  glsPasswordGTE?: InputMaybe<Scalars['String']>;
  glsPasswordHasPrefix?: InputMaybe<Scalars['String']>;
  glsPasswordHasSuffix?: InputMaybe<Scalars['String']>;
  glsPasswordIn?: InputMaybe<Array<Scalars['String']>>;
  glsPasswordIsNil?: InputMaybe<Scalars['Boolean']>;
  glsPasswordLT?: InputMaybe<Scalars['String']>;
  glsPasswordLTE?: InputMaybe<Scalars['String']>;
  glsPasswordNEQ?: InputMaybe<Scalars['String']>;
  glsPasswordNotIn?: InputMaybe<Array<Scalars['String']>>;
  glsPasswordNotNil?: InputMaybe<Scalars['Boolean']>;
  /** gls_username field predicates */
  glsUsername?: InputMaybe<Scalars['String']>;
  glsUsernameContains?: InputMaybe<Scalars['String']>;
  glsUsernameContainsFold?: InputMaybe<Scalars['String']>;
  glsUsernameEqualFold?: InputMaybe<Scalars['String']>;
  glsUsernameGT?: InputMaybe<Scalars['String']>;
  glsUsernameGTE?: InputMaybe<Scalars['String']>;
  glsUsernameHasPrefix?: InputMaybe<Scalars['String']>;
  glsUsernameHasSuffix?: InputMaybe<Scalars['String']>;
  glsUsernameIn?: InputMaybe<Array<Scalars['String']>>;
  glsUsernameIsNil?: InputMaybe<Scalars['Boolean']>;
  glsUsernameLT?: InputMaybe<Scalars['String']>;
  glsUsernameLTE?: InputMaybe<Scalars['String']>;
  glsUsernameNEQ?: InputMaybe<Scalars['String']>;
  glsUsernameNotIn?: InputMaybe<Array<Scalars['String']>>;
  glsUsernameNotNil?: InputMaybe<Scalars['Boolean']>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierGlsWhereInput>;
  or?: InputMaybe<Array<CarrierGlsWhereInput>>;
  /** print_error_on_label field predicates */
  printErrorOnLabel?: InputMaybe<Scalars['Boolean']>;
  printErrorOnLabelIsNil?: InputMaybe<Scalars['Boolean']>;
  printErrorOnLabelNEQ?: InputMaybe<Scalars['Boolean']>;
  printErrorOnLabelNotNil?: InputMaybe<Scalars['Boolean']>;
  /** sync_shipment_cancellation field predicates */
  syncShipmentCancellation?: InputMaybe<Scalars['Boolean']>;
  syncShipmentCancellationIsNil?: InputMaybe<Scalars['Boolean']>;
  syncShipmentCancellationNEQ?: InputMaybe<Scalars['Boolean']>;
  syncShipmentCancellationNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type CarrierPostNord = Node & {
  carrier: Carrier;
  /** Default empty to allow creation from dialog with followup editing */
  customerNumber: Scalars['String'];
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type CarrierPostNordConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierPostNordEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierPostNordEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierPostNord>;
};

/**
 * CarrierPostNordWhereInput is used for filtering CarrierPostNord objects.
 * Input was generated by ent.
 */
export type CarrierPostNordWhereInput = {
  and?: InputMaybe<Array<CarrierPostNordWhereInput>>;
  /** customer_number field predicates */
  customerNumber?: InputMaybe<Scalars['String']>;
  customerNumberContains?: InputMaybe<Scalars['String']>;
  customerNumberContainsFold?: InputMaybe<Scalars['String']>;
  customerNumberEqualFold?: InputMaybe<Scalars['String']>;
  customerNumberGT?: InputMaybe<Scalars['String']>;
  customerNumberGTE?: InputMaybe<Scalars['String']>;
  customerNumberHasPrefix?: InputMaybe<Scalars['String']>;
  customerNumberHasSuffix?: InputMaybe<Scalars['String']>;
  customerNumberIn?: InputMaybe<Array<Scalars['String']>>;
  customerNumberLT?: InputMaybe<Scalars['String']>;
  customerNumberLTE?: InputMaybe<Scalars['String']>;
  customerNumberNEQ?: InputMaybe<Scalars['String']>;
  customerNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierPostNordWhereInput>;
  or?: InputMaybe<Array<CarrierPostNordWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type CarrierService = Node & {
  carrierBrand: CarrierBrand;
  carrierServEasyPost?: Maybe<CarrierServiceEasyPost>;
  carrierServiceBring?: Maybe<CarrierServiceBring>;
  carrierServiceDAO?: Maybe<CarrierServiceDao>;
  carrierServiceDF?: Maybe<CarrierServiceDf>;
  carrierServiceDSV?: Maybe<CarrierServiceDsv>;
  carrierServiceGLS?: Maybe<CarrierServiceGls>;
  carrierServicePostNord?: Maybe<CarrierServicePostNord>;
  carrierServiceUSPS?: Maybe<CarrierServiceUsps>;
  consolidation: Scalars['Boolean'];
  deliveryOption?: Maybe<Array<DeliveryOption>>;
  deliveryPointOptional: Scalars['Boolean'];
  deliveryPointRequired: Scalars['Boolean'];
  id: Scalars['ID'];
  internalID: Scalars['String'];
  label: Scalars['String'];
  return: Scalars['Boolean'];
};

export type CarrierServiceBring = Node & {
  apiRequest: Scalars['String'];
  apiServiceCode: Scalars['String'];
  carrierAdditionalServiceBring?: Maybe<Array<CarrierAdditionalServiceBring>>;
  carrierService: CarrierService;
  id: Scalars['ID'];
};

/** A connection to a list of items. */
export type CarrierServiceBringConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierServiceBringEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierServiceBringEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierServiceBring>;
};

/**
 * CarrierServiceBringWhereInput is used for filtering CarrierServiceBring objects.
 * Input was generated by ent.
 */
export type CarrierServiceBringWhereInput = {
  and?: InputMaybe<Array<CarrierServiceBringWhereInput>>;
  /** api_request field predicates */
  apiRequest?: InputMaybe<Scalars['String']>;
  apiRequestContains?: InputMaybe<Scalars['String']>;
  apiRequestContainsFold?: InputMaybe<Scalars['String']>;
  apiRequestEqualFold?: InputMaybe<Scalars['String']>;
  apiRequestGT?: InputMaybe<Scalars['String']>;
  apiRequestGTE?: InputMaybe<Scalars['String']>;
  apiRequestHasPrefix?: InputMaybe<Scalars['String']>;
  apiRequestHasSuffix?: InputMaybe<Scalars['String']>;
  apiRequestIn?: InputMaybe<Array<Scalars['String']>>;
  apiRequestLT?: InputMaybe<Scalars['String']>;
  apiRequestLTE?: InputMaybe<Scalars['String']>;
  apiRequestNEQ?: InputMaybe<Scalars['String']>;
  apiRequestNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** api_service_code field predicates */
  apiServiceCode?: InputMaybe<Scalars['String']>;
  apiServiceCodeContains?: InputMaybe<Scalars['String']>;
  apiServiceCodeContainsFold?: InputMaybe<Scalars['String']>;
  apiServiceCodeEqualFold?: InputMaybe<Scalars['String']>;
  apiServiceCodeGT?: InputMaybe<Scalars['String']>;
  apiServiceCodeGTE?: InputMaybe<Scalars['String']>;
  apiServiceCodeHasPrefix?: InputMaybe<Scalars['String']>;
  apiServiceCodeHasSuffix?: InputMaybe<Scalars['String']>;
  apiServiceCodeIn?: InputMaybe<Array<Scalars['String']>>;
  apiServiceCodeLT?: InputMaybe<Scalars['String']>;
  apiServiceCodeLTE?: InputMaybe<Scalars['String']>;
  apiServiceCodeNEQ?: InputMaybe<Scalars['String']>;
  apiServiceCodeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier_additional_service_bring edge predicates */
  hasCarrierAdditionalServiceBring?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceBringWith?: InputMaybe<Array<CarrierAdditionalServiceBringWhereInput>>;
  /** carrier_service edge predicates */
  hasCarrierService?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceWith?: InputMaybe<Array<CarrierServiceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierServiceBringWhereInput>;
  or?: InputMaybe<Array<CarrierServiceBringWhereInput>>;
};

/** A connection to a list of items. */
export type CarrierServiceConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierServiceEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

export type CarrierServiceDao = Node & {
  carrierAdditionalServiceDAO?: Maybe<Array<CarrierAdditionalServiceDao>>;
  carrierService: CarrierService;
  id: Scalars['ID'];
};

/** A connection to a list of items. */
export type CarrierServiceDaoConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierServiceDaoEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierServiceDaoEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierServiceDao>;
};

/**
 * CarrierServiceDAOWhereInput is used for filtering CarrierServiceDAO objects.
 * Input was generated by ent.
 */
export type CarrierServiceDaoWhereInput = {
  and?: InputMaybe<Array<CarrierServiceDaoWhereInput>>;
  /** carrier_additional_service_dao edge predicates */
  hasCarrierAdditionalServiceDAO?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceDAOWith?: InputMaybe<Array<CarrierAdditionalServiceDaoWhereInput>>;
  /** carrier_service edge predicates */
  hasCarrierService?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceWith?: InputMaybe<Array<CarrierServiceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierServiceDaoWhereInput>;
  or?: InputMaybe<Array<CarrierServiceDaoWhereInput>>;
};

export type CarrierServiceDf = Node & {
  carrierAdditionalServiceDF?: Maybe<Array<CarrierAdditionalServiceDf>>;
  carrierService: CarrierService;
  id: Scalars['ID'];
};

/** A connection to a list of items. */
export type CarrierServiceDfConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierServiceDfEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierServiceDfEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierServiceDf>;
};

/**
 * CarrierServiceDFWhereInput is used for filtering CarrierServiceDF objects.
 * Input was generated by ent.
 */
export type CarrierServiceDfWhereInput = {
  and?: InputMaybe<Array<CarrierServiceDfWhereInput>>;
  /** carrier_additional_service_df edge predicates */
  hasCarrierAdditionalServiceDF?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceDFWith?: InputMaybe<Array<CarrierAdditionalServiceDfWhereInput>>;
  /** carrier_service edge predicates */
  hasCarrierService?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceWith?: InputMaybe<Array<CarrierServiceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierServiceDfWhereInput>;
  or?: InputMaybe<Array<CarrierServiceDfWhereInput>>;
};

export type CarrierServiceDsv = Node & {
  carrierAdditionalServiceDSV?: Maybe<Array<CarrierAdditionalServiceDsv>>;
  carrierService: CarrierService;
  id: Scalars['ID'];
};

/** A connection to a list of items. */
export type CarrierServiceDsvConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierServiceDsvEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierServiceDsvEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierServiceDsv>;
};

/**
 * CarrierServiceDSVWhereInput is used for filtering CarrierServiceDSV objects.
 * Input was generated by ent.
 */
export type CarrierServiceDsvWhereInput = {
  and?: InputMaybe<Array<CarrierServiceDsvWhereInput>>;
  /** carrier_additional_service_dsv edge predicates */
  hasCarrierAdditionalServiceDSV?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceDSVWith?: InputMaybe<Array<CarrierAdditionalServiceDsvWhereInput>>;
  /** carrier_service edge predicates */
  hasCarrierService?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceWith?: InputMaybe<Array<CarrierServiceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierServiceDsvWhereInput>;
  or?: InputMaybe<Array<CarrierServiceDsvWhereInput>>;
};

export type CarrierServiceEasyPost = Node & {
  carrierAddServEasyPost?: Maybe<Array<CarrierAdditionalServiceEasyPost>>;
  carrierService: CarrierService;
  id: Scalars['ID'];
};

/**
 * CarrierServiceEasyPostWhereInput is used for filtering CarrierServiceEasyPost objects.
 * Input was generated by ent.
 */
export type CarrierServiceEasyPostWhereInput = {
  and?: InputMaybe<Array<CarrierServiceEasyPostWhereInput>>;
  /** carrier_add_serv_easy_post edge predicates */
  hasCarrierAddServEasyPost?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAddServEasyPostWith?: InputMaybe<Array<CarrierAdditionalServiceEasyPostWhereInput>>;
  /** carrier_service edge predicates */
  hasCarrierService?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceWith?: InputMaybe<Array<CarrierServiceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierServiceEasyPostWhereInput>;
  or?: InputMaybe<Array<CarrierServiceEasyPostWhereInput>>;
};

/** An edge in a connection. */
export type CarrierServiceEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierService>;
};

export type CarrierServiceGls = Node & {
  apiKey?: Maybe<Scalars['String']>;
  apiValue: CarrierServiceGlsapiValue;
  carrierAdditionalServiceGLS?: Maybe<Array<CarrierAdditionalServiceGls>>;
  carrierService: CarrierService;
  id: Scalars['ID'];
};

/** CarrierServiceGLSAPIValue is enum for the field api_value */
export enum CarrierServiceGlsapiValue {
  Y = 'Y',
  None = 'none',
  NumericString = 'numeric_string'
}

/**
 * CarrierServiceGLSWhereInput is used for filtering CarrierServiceGLS objects.
 * Input was generated by ent.
 */
export type CarrierServiceGlsWhereInput = {
  and?: InputMaybe<Array<CarrierServiceGlsWhereInput>>;
  /** api_key field predicates */
  apiKey?: InputMaybe<Scalars['String']>;
  apiKeyContains?: InputMaybe<Scalars['String']>;
  apiKeyContainsFold?: InputMaybe<Scalars['String']>;
  apiKeyEqualFold?: InputMaybe<Scalars['String']>;
  apiKeyGT?: InputMaybe<Scalars['String']>;
  apiKeyGTE?: InputMaybe<Scalars['String']>;
  apiKeyHasPrefix?: InputMaybe<Scalars['String']>;
  apiKeyHasSuffix?: InputMaybe<Scalars['String']>;
  apiKeyIn?: InputMaybe<Array<Scalars['String']>>;
  apiKeyIsNil?: InputMaybe<Scalars['Boolean']>;
  apiKeyLT?: InputMaybe<Scalars['String']>;
  apiKeyLTE?: InputMaybe<Scalars['String']>;
  apiKeyNEQ?: InputMaybe<Scalars['String']>;
  apiKeyNotIn?: InputMaybe<Array<Scalars['String']>>;
  apiKeyNotNil?: InputMaybe<Scalars['Boolean']>;
  /** api_value field predicates */
  apiValue?: InputMaybe<CarrierServiceGlsapiValue>;
  apiValueIn?: InputMaybe<Array<CarrierServiceGlsapiValue>>;
  apiValueNEQ?: InputMaybe<CarrierServiceGlsapiValue>;
  apiValueNotIn?: InputMaybe<Array<CarrierServiceGlsapiValue>>;
  /** carrier_additional_service_gls edge predicates */
  hasCarrierAdditionalServiceGLS?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceGLSWith?: InputMaybe<Array<CarrierAdditionalServiceGlsWhereInput>>;
  /** carrier_service edge predicates */
  hasCarrierService?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceWith?: InputMaybe<Array<CarrierServiceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierServiceGlsWhereInput>;
  or?: InputMaybe<Array<CarrierServiceGlsWhereInput>>;
};

export type CarrierServicePostNord = Node & {
  apiCode: Scalars['String'];
  carrierAddServPostNord?: Maybe<Array<CarrierAdditionalServicePostNord>>;
  carrierService: CarrierService;
  id: Scalars['ID'];
  internalID: Scalars['String'];
  label: Scalars['String'];
};

/**
 * CarrierServicePostNordWhereInput is used for filtering CarrierServicePostNord objects.
 * Input was generated by ent.
 */
export type CarrierServicePostNordWhereInput = {
  and?: InputMaybe<Array<CarrierServicePostNordWhereInput>>;
  /** api_code field predicates */
  apiCode?: InputMaybe<Scalars['String']>;
  apiCodeContains?: InputMaybe<Scalars['String']>;
  apiCodeContainsFold?: InputMaybe<Scalars['String']>;
  apiCodeEqualFold?: InputMaybe<Scalars['String']>;
  apiCodeGT?: InputMaybe<Scalars['String']>;
  apiCodeGTE?: InputMaybe<Scalars['String']>;
  apiCodeHasPrefix?: InputMaybe<Scalars['String']>;
  apiCodeHasSuffix?: InputMaybe<Scalars['String']>;
  apiCodeIn?: InputMaybe<Array<Scalars['String']>>;
  apiCodeLT?: InputMaybe<Scalars['String']>;
  apiCodeLTE?: InputMaybe<Scalars['String']>;
  apiCodeNEQ?: InputMaybe<Scalars['String']>;
  apiCodeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier_add_serv_post_nord edge predicates */
  hasCarrierAddServPostNord?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAddServPostNordWith?: InputMaybe<Array<CarrierAdditionalServicePostNordWhereInput>>;
  /** carrier_service edge predicates */
  hasCarrierService?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceWith?: InputMaybe<Array<CarrierServiceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_id field predicates */
  internalID?: InputMaybe<Scalars['String']>;
  internalIDContains?: InputMaybe<Scalars['String']>;
  internalIDContainsFold?: InputMaybe<Scalars['String']>;
  internalIDEqualFold?: InputMaybe<Scalars['String']>;
  internalIDGT?: InputMaybe<Scalars['String']>;
  internalIDGTE?: InputMaybe<Scalars['String']>;
  internalIDHasPrefix?: InputMaybe<Scalars['String']>;
  internalIDHasSuffix?: InputMaybe<Scalars['String']>;
  internalIDIn?: InputMaybe<Array<Scalars['String']>>;
  internalIDLT?: InputMaybe<Scalars['String']>;
  internalIDLTE?: InputMaybe<Scalars['String']>;
  internalIDNEQ?: InputMaybe<Scalars['String']>;
  internalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CarrierServicePostNordWhereInput>;
  or?: InputMaybe<Array<CarrierServicePostNordWhereInput>>;
};

export type CarrierServiceUsps = Node & {
  carrierAdditionalServiceUSPS?: Maybe<Array<CarrierAdditionalServiceUsps>>;
  carrierService: CarrierService;
  id: Scalars['ID'];
};

/**
 * CarrierServiceUSPSWhereInput is used for filtering CarrierServiceUSPS objects.
 * Input was generated by ent.
 */
export type CarrierServiceUspsWhereInput = {
  and?: InputMaybe<Array<CarrierServiceUspsWhereInput>>;
  /** carrier_additional_service_usps edge predicates */
  hasCarrierAdditionalServiceUSPS?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceUSPSWith?: InputMaybe<Array<CarrierAdditionalServiceUspsWhereInput>>;
  /** carrier_service edge predicates */
  hasCarrierService?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceWith?: InputMaybe<Array<CarrierServiceWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CarrierServiceUspsWhereInput>;
  or?: InputMaybe<Array<CarrierServiceUspsWhereInput>>;
};

/**
 * CarrierServiceWhereInput is used for filtering CarrierService objects.
 * Input was generated by ent.
 */
export type CarrierServiceWhereInput = {
  and?: InputMaybe<Array<CarrierServiceWhereInput>>;
  /** consolidation field predicates */
  consolidation?: InputMaybe<Scalars['Boolean']>;
  consolidationNEQ?: InputMaybe<Scalars['Boolean']>;
  /** delivery_point_optional field predicates */
  deliveryPointOptional?: InputMaybe<Scalars['Boolean']>;
  deliveryPointOptionalNEQ?: InputMaybe<Scalars['Boolean']>;
  /** delivery_point_required field predicates */
  deliveryPointRequired?: InputMaybe<Scalars['Boolean']>;
  deliveryPointRequiredNEQ?: InputMaybe<Scalars['Boolean']>;
  /** carrier_brand edge predicates */
  hasCarrierBrand?: InputMaybe<Scalars['Boolean']>;
  hasCarrierBrandWith?: InputMaybe<Array<CarrierBrandWhereInput>>;
  /** carrier_serv_easy_post edge predicates */
  hasCarrierServEasyPost?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServEasyPostWith?: InputMaybe<Array<CarrierServiceEasyPostWhereInput>>;
  /** carrier_service_bring edge predicates */
  hasCarrierServiceBring?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceBringWith?: InputMaybe<Array<CarrierServiceBringWhereInput>>;
  /** carrier_service_dao edge predicates */
  hasCarrierServiceDAO?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceDAOWith?: InputMaybe<Array<CarrierServiceDaoWhereInput>>;
  /** carrier_service_df edge predicates */
  hasCarrierServiceDF?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceDFWith?: InputMaybe<Array<CarrierServiceDfWhereInput>>;
  /** carrier_service_dsv edge predicates */
  hasCarrierServiceDSV?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceDSVWith?: InputMaybe<Array<CarrierServiceDsvWhereInput>>;
  /** carrier_service_gls edge predicates */
  hasCarrierServiceGLS?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceGLSWith?: InputMaybe<Array<CarrierServiceGlsWhereInput>>;
  /** carrier_service_post_nord edge predicates */
  hasCarrierServicePostNord?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServicePostNordWith?: InputMaybe<Array<CarrierServicePostNordWhereInput>>;
  /** carrier_service_usps edge predicates */
  hasCarrierServiceUSPS?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceUSPSWith?: InputMaybe<Array<CarrierServiceUspsWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_id field predicates */
  internalID?: InputMaybe<Scalars['String']>;
  internalIDContains?: InputMaybe<Scalars['String']>;
  internalIDContainsFold?: InputMaybe<Scalars['String']>;
  internalIDEqualFold?: InputMaybe<Scalars['String']>;
  internalIDGT?: InputMaybe<Scalars['String']>;
  internalIDGTE?: InputMaybe<Scalars['String']>;
  internalIDHasPrefix?: InputMaybe<Scalars['String']>;
  internalIDHasSuffix?: InputMaybe<Scalars['String']>;
  internalIDIn?: InputMaybe<Array<Scalars['String']>>;
  internalIDLT?: InputMaybe<Scalars['String']>;
  internalIDLTE?: InputMaybe<Scalars['String']>;
  internalIDNEQ?: InputMaybe<Scalars['String']>;
  internalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CarrierServiceWhereInput>;
  or?: InputMaybe<Array<CarrierServiceWhereInput>>;
  /** return field predicates */
  return?: InputMaybe<Scalars['Boolean']>;
  returnNEQ?: InputMaybe<Scalars['Boolean']>;
};

export type CarrierUsps = Node & {
  carrier: Carrier;
  consumerKey?: Maybe<Scalars['String']>;
  consumerSecret?: Maybe<Scalars['String']>;
  crid?: Maybe<Scalars['String']>;
  epsAccountNumber?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  isTestAPI: Scalars['Boolean'];
  manifestMid?: Maybe<Scalars['String']>;
  mid?: Maybe<Scalars['String']>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type CarrierUspsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CarrierUspsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CarrierUspsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CarrierUsps>;
};

/**
 * CarrierUSPSWhereInput is used for filtering CarrierUSPS objects.
 * Input was generated by ent.
 */
export type CarrierUspsWhereInput = {
  and?: InputMaybe<Array<CarrierUspsWhereInput>>;
  /** consumer_key field predicates */
  consumerKey?: InputMaybe<Scalars['String']>;
  consumerKeyContains?: InputMaybe<Scalars['String']>;
  consumerKeyContainsFold?: InputMaybe<Scalars['String']>;
  consumerKeyEqualFold?: InputMaybe<Scalars['String']>;
  consumerKeyGT?: InputMaybe<Scalars['String']>;
  consumerKeyGTE?: InputMaybe<Scalars['String']>;
  consumerKeyHasPrefix?: InputMaybe<Scalars['String']>;
  consumerKeyHasSuffix?: InputMaybe<Scalars['String']>;
  consumerKeyIn?: InputMaybe<Array<Scalars['String']>>;
  consumerKeyIsNil?: InputMaybe<Scalars['Boolean']>;
  consumerKeyLT?: InputMaybe<Scalars['String']>;
  consumerKeyLTE?: InputMaybe<Scalars['String']>;
  consumerKeyNEQ?: InputMaybe<Scalars['String']>;
  consumerKeyNotIn?: InputMaybe<Array<Scalars['String']>>;
  consumerKeyNotNil?: InputMaybe<Scalars['Boolean']>;
  /** consumer_secret field predicates */
  consumerSecret?: InputMaybe<Scalars['String']>;
  consumerSecretContains?: InputMaybe<Scalars['String']>;
  consumerSecretContainsFold?: InputMaybe<Scalars['String']>;
  consumerSecretEqualFold?: InputMaybe<Scalars['String']>;
  consumerSecretGT?: InputMaybe<Scalars['String']>;
  consumerSecretGTE?: InputMaybe<Scalars['String']>;
  consumerSecretHasPrefix?: InputMaybe<Scalars['String']>;
  consumerSecretHasSuffix?: InputMaybe<Scalars['String']>;
  consumerSecretIn?: InputMaybe<Array<Scalars['String']>>;
  consumerSecretIsNil?: InputMaybe<Scalars['Boolean']>;
  consumerSecretLT?: InputMaybe<Scalars['String']>;
  consumerSecretLTE?: InputMaybe<Scalars['String']>;
  consumerSecretNEQ?: InputMaybe<Scalars['String']>;
  consumerSecretNotIn?: InputMaybe<Array<Scalars['String']>>;
  consumerSecretNotNil?: InputMaybe<Scalars['Boolean']>;
  /** crid field predicates */
  crid?: InputMaybe<Scalars['String']>;
  cridContains?: InputMaybe<Scalars['String']>;
  cridContainsFold?: InputMaybe<Scalars['String']>;
  cridEqualFold?: InputMaybe<Scalars['String']>;
  cridGT?: InputMaybe<Scalars['String']>;
  cridGTE?: InputMaybe<Scalars['String']>;
  cridHasPrefix?: InputMaybe<Scalars['String']>;
  cridHasSuffix?: InputMaybe<Scalars['String']>;
  cridIn?: InputMaybe<Array<Scalars['String']>>;
  cridIsNil?: InputMaybe<Scalars['Boolean']>;
  cridLT?: InputMaybe<Scalars['String']>;
  cridLTE?: InputMaybe<Scalars['String']>;
  cridNEQ?: InputMaybe<Scalars['String']>;
  cridNotIn?: InputMaybe<Array<Scalars['String']>>;
  cridNotNil?: InputMaybe<Scalars['Boolean']>;
  /** eps_account_number field predicates */
  epsAccountNumber?: InputMaybe<Scalars['String']>;
  epsAccountNumberContains?: InputMaybe<Scalars['String']>;
  epsAccountNumberContainsFold?: InputMaybe<Scalars['String']>;
  epsAccountNumberEqualFold?: InputMaybe<Scalars['String']>;
  epsAccountNumberGT?: InputMaybe<Scalars['String']>;
  epsAccountNumberGTE?: InputMaybe<Scalars['String']>;
  epsAccountNumberHasPrefix?: InputMaybe<Scalars['String']>;
  epsAccountNumberHasSuffix?: InputMaybe<Scalars['String']>;
  epsAccountNumberIn?: InputMaybe<Array<Scalars['String']>>;
  epsAccountNumberIsNil?: InputMaybe<Scalars['Boolean']>;
  epsAccountNumberLT?: InputMaybe<Scalars['String']>;
  epsAccountNumberLTE?: InputMaybe<Scalars['String']>;
  epsAccountNumberNEQ?: InputMaybe<Scalars['String']>;
  epsAccountNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  epsAccountNumberNotNil?: InputMaybe<Scalars['Boolean']>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** is_test_api field predicates */
  isTestAPI?: InputMaybe<Scalars['Boolean']>;
  isTestAPINEQ?: InputMaybe<Scalars['Boolean']>;
  /** manifest_mid field predicates */
  manifestMid?: InputMaybe<Scalars['String']>;
  manifestMidContains?: InputMaybe<Scalars['String']>;
  manifestMidContainsFold?: InputMaybe<Scalars['String']>;
  manifestMidEqualFold?: InputMaybe<Scalars['String']>;
  manifestMidGT?: InputMaybe<Scalars['String']>;
  manifestMidGTE?: InputMaybe<Scalars['String']>;
  manifestMidHasPrefix?: InputMaybe<Scalars['String']>;
  manifestMidHasSuffix?: InputMaybe<Scalars['String']>;
  manifestMidIn?: InputMaybe<Array<Scalars['String']>>;
  manifestMidIsNil?: InputMaybe<Scalars['Boolean']>;
  manifestMidLT?: InputMaybe<Scalars['String']>;
  manifestMidLTE?: InputMaybe<Scalars['String']>;
  manifestMidNEQ?: InputMaybe<Scalars['String']>;
  manifestMidNotIn?: InputMaybe<Array<Scalars['String']>>;
  manifestMidNotNil?: InputMaybe<Scalars['Boolean']>;
  /** mid field predicates */
  mid?: InputMaybe<Scalars['String']>;
  midContains?: InputMaybe<Scalars['String']>;
  midContainsFold?: InputMaybe<Scalars['String']>;
  midEqualFold?: InputMaybe<Scalars['String']>;
  midGT?: InputMaybe<Scalars['String']>;
  midGTE?: InputMaybe<Scalars['String']>;
  midHasPrefix?: InputMaybe<Scalars['String']>;
  midHasSuffix?: InputMaybe<Scalars['String']>;
  midIn?: InputMaybe<Array<Scalars['String']>>;
  midIsNil?: InputMaybe<Scalars['Boolean']>;
  midLT?: InputMaybe<Scalars['String']>;
  midLTE?: InputMaybe<Scalars['String']>;
  midNEQ?: InputMaybe<Scalars['String']>;
  midNotIn?: InputMaybe<Array<Scalars['String']>>;
  midNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<CarrierUspsWhereInput>;
  or?: InputMaybe<Array<CarrierUspsWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CarrierWhereInput is used for filtering Carrier objects.
 * Input was generated by ent.
 */
export type CarrierWhereInput = {
  and?: InputMaybe<Array<CarrierWhereInput>>;
  /** carrier_brand edge predicates */
  hasCarrierBrand?: InputMaybe<Scalars['Boolean']>;
  hasCarrierBrandWith?: InputMaybe<Array<CarrierBrandWhereInput>>;
  /** carrier_bring edge predicates */
  hasCarrierBring?: InputMaybe<Scalars['Boolean']>;
  hasCarrierBringWith?: InputMaybe<Array<CarrierBringWhereInput>>;
  /** carrier_dao edge predicates */
  hasCarrierDAO?: InputMaybe<Scalars['Boolean']>;
  hasCarrierDAOWith?: InputMaybe<Array<CarrierDaoWhereInput>>;
  /** carrier_df edge predicates */
  hasCarrierDF?: InputMaybe<Scalars['Boolean']>;
  hasCarrierDFWith?: InputMaybe<Array<CarrierDfWhereInput>>;
  /** carrier_dsv edge predicates */
  hasCarrierDSV?: InputMaybe<Scalars['Boolean']>;
  hasCarrierDSVWith?: InputMaybe<Array<CarrierDsvWhereInput>>;
  /** carrier_easy_post edge predicates */
  hasCarrierEasyPost?: InputMaybe<Scalars['Boolean']>;
  hasCarrierEasyPostWith?: InputMaybe<Array<CarrierEasyPostWhereInput>>;
  /** carrier_gls edge predicates */
  hasCarrierGLS?: InputMaybe<Scalars['Boolean']>;
  hasCarrierGLSWith?: InputMaybe<Array<CarrierGlsWhereInput>>;
  /** carrier_post_nord edge predicates */
  hasCarrierPostNord?: InputMaybe<Scalars['Boolean']>;
  hasCarrierPostNordWith?: InputMaybe<Array<CarrierPostNordWhereInput>>;
  /** carrier_usps edge predicates */
  hasCarrierUSPS?: InputMaybe<Scalars['Boolean']>;
  hasCarrierUSPSWith?: InputMaybe<Array<CarrierUspsWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CarrierWhereInput>;
  or?: InputMaybe<Array<CarrierWhereInput>>;
  /** sync_cancelation field predicates */
  syncCancelation?: InputMaybe<Scalars['Boolean']>;
  syncCancelationNEQ?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ChangeHistory = Node & {
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  orderHistory?: Maybe<Array<OrderHistory>>;
  origin: ChangeHistoryOrigin;
  planHistory?: Maybe<Array<PlanHistory>>;
  returnColliHistory?: Maybe<Array<ReturnColliHistory>>;
  shipmentHistory?: Maybe<Array<ShipmentHistory>>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  user?: Maybe<User>;
};

/** A connection to a list of items. */
export type ChangeHistoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ChangeHistoryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ChangeHistoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ChangeHistory>;
};

/** Ordering options for ChangeHistory connections */
export type ChangeHistoryOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order ChangeHistories. */
  field: ChangeHistoryOrderField;
};

/** Properties by which ChangeHistory connections can be ordered. */
export enum ChangeHistoryOrderField {
  CreatedAt = 'CREATED_AT'
}

/** ChangeHistoryOrigin is enum for the field origin */
export enum ChangeHistoryOrigin {
  Background = 'background',
  PrintClient = 'print_client',
  RestApi = 'rest_api',
  Seed = 'seed',
  Unknown = 'unknown',
  WebClient = 'web_client'
}

/**
 * ChangeHistoryWhereInput is used for filtering ChangeHistory objects.
 * Input was generated by ent.
 */
export type ChangeHistoryWhereInput = {
  and?: InputMaybe<Array<ChangeHistoryWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** order_history edge predicates */
  hasOrderHistory?: InputMaybe<Scalars['Boolean']>;
  hasOrderHistoryWith?: InputMaybe<Array<OrderHistoryWhereInput>>;
  /** plan_history edge predicates */
  hasPlanHistory?: InputMaybe<Scalars['Boolean']>;
  hasPlanHistoryWith?: InputMaybe<Array<PlanHistoryWhereInput>>;
  /** return_colli_history edge predicates */
  hasReturnColliHistory?: InputMaybe<Scalars['Boolean']>;
  hasReturnColliHistoryWith?: InputMaybe<Array<ReturnColliHistoryWhereInput>>;
  /** shipment_history edge predicates */
  hasShipmentHistory?: InputMaybe<Scalars['Boolean']>;
  hasShipmentHistoryWith?: InputMaybe<Array<ShipmentHistoryWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ChangeHistoryWhereInput>;
  or?: InputMaybe<Array<ChangeHistoryWhereInput>>;
  /** origin field predicates */
  origin?: InputMaybe<ChangeHistoryOrigin>;
  originIn?: InputMaybe<Array<ChangeHistoryOrigin>>;
  originNEQ?: InputMaybe<ChangeHistoryOrigin>;
  originNotIn?: InputMaybe<Array<ChangeHistoryOrigin>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type Colli = Node & {
  /** A ref to all cancelled shipments */
  cancelledShipmentParcel?: Maybe<Array<ShipmentParcel>>;
  clickCollectLocation?: Maybe<Location>;
  createdAt: Scalars['Time'];
  deliveryOption?: Maybe<DeliveryOption>;
  /** Stores packing slips for quick printing. Carrier labels are attached to the shipment. */
  documentFile?: Maybe<Array<DocumentFile>>;
  /** When filled, the packing slip email has been fired. Consider moving to shipping parcel? There are trade offs */
  emailLabelPrintedAt?: Maybe<Scalars['Time']>;
  /** When filled, the packing slip email has been fired */
  emailPackingSlipPrintedAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  /** Code128 type C compatible for faster reads */
  internalBarcode?: Maybe<Scalars['Int']>;
  order: Order;
  orderLines?: Maybe<Array<OrderLine>>;
  /** Allows packaging to be predefined for this colli and will be used for the shipment parcel */
  packaging?: Maybe<Packaging>;
  parcelShop?: Maybe<ParcelShop>;
  printJob?: Maybe<Array<PrintJob>>;
  recipient: Address;
  sender: Address;
  /** A colli may only have 1 active shipment, cancelled shipments are moved to the other edge */
  shipmentParcel?: Maybe<ShipmentParcel>;
  slipPrintStatus: ColliSlipPrintStatus;
  status: ColliStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ColliConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ColliEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ColliEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Colli>;
};

/** ColliSlipPrintStatus is enum for the field slip_print_status */
export enum ColliSlipPrintStatus {
  Pending = 'pending',
  Printed = 'printed'
}

/** ColliStatus is enum for the field status */
export enum ColliStatus {
  Cancelled = 'Cancelled',
  Dispatched = 'Dispatched',
  Pending = 'Pending'
}

/**
 * ColliWhereInput is used for filtering Colli objects.
 * Input was generated by ent.
 */
export type ColliWhereInput = {
  and?: InputMaybe<Array<ColliWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** email_label_printed_at field predicates */
  emailLabelPrintedAt?: InputMaybe<Scalars['Time']>;
  emailLabelPrintedAtGT?: InputMaybe<Scalars['Time']>;
  emailLabelPrintedAtGTE?: InputMaybe<Scalars['Time']>;
  emailLabelPrintedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  emailLabelPrintedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  emailLabelPrintedAtLT?: InputMaybe<Scalars['Time']>;
  emailLabelPrintedAtLTE?: InputMaybe<Scalars['Time']>;
  emailLabelPrintedAtNEQ?: InputMaybe<Scalars['Time']>;
  emailLabelPrintedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  emailLabelPrintedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** email_packing_slip_printed_at field predicates */
  emailPackingSlipPrintedAt?: InputMaybe<Scalars['Time']>;
  emailPackingSlipPrintedAtGT?: InputMaybe<Scalars['Time']>;
  emailPackingSlipPrintedAtGTE?: InputMaybe<Scalars['Time']>;
  emailPackingSlipPrintedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  emailPackingSlipPrintedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  emailPackingSlipPrintedAtLT?: InputMaybe<Scalars['Time']>;
  emailPackingSlipPrintedAtLTE?: InputMaybe<Scalars['Time']>;
  emailPackingSlipPrintedAtNEQ?: InputMaybe<Scalars['Time']>;
  emailPackingSlipPrintedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  emailPackingSlipPrintedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** cancelled_shipment_parcel edge predicates */
  hasCancelledShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  hasCancelledShipmentParcelWith?: InputMaybe<Array<ShipmentParcelWhereInput>>;
  /** click_collect_location edge predicates */
  hasClickCollectLocation?: InputMaybe<Scalars['Boolean']>;
  hasClickCollectLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** document_file edge predicates */
  hasDocumentFile?: InputMaybe<Scalars['Boolean']>;
  hasDocumentFileWith?: InputMaybe<Array<DocumentFileWhereInput>>;
  /** order edge predicates */
  hasOrder?: InputMaybe<Scalars['Boolean']>;
  /** order_lines edge predicates */
  hasOrderLines?: InputMaybe<Scalars['Boolean']>;
  hasOrderLinesWith?: InputMaybe<Array<OrderLineWhereInput>>;
  hasOrderWith?: InputMaybe<Array<OrderWhereInput>>;
  /** packaging edge predicates */
  hasPackaging?: InputMaybe<Scalars['Boolean']>;
  hasPackagingWith?: InputMaybe<Array<PackagingWhereInput>>;
  /** parcel_shop edge predicates */
  hasParcelShop?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopWith?: InputMaybe<Array<ParcelShopWhereInput>>;
  /** print_job edge predicates */
  hasPrintJob?: InputMaybe<Scalars['Boolean']>;
  hasPrintJobWith?: InputMaybe<Array<PrintJobWhereInput>>;
  /** recipient edge predicates */
  hasRecipient?: InputMaybe<Scalars['Boolean']>;
  hasRecipientWith?: InputMaybe<Array<AddressWhereInput>>;
  /** sender edge predicates */
  hasSender?: InputMaybe<Scalars['Boolean']>;
  hasSenderWith?: InputMaybe<Array<AddressWhereInput>>;
  /** shipment_parcel edge predicates */
  hasShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  hasShipmentParcelWith?: InputMaybe<Array<ShipmentParcelWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_barcode field predicates */
  internalBarcode?: InputMaybe<Scalars['Int']>;
  internalBarcodeGT?: InputMaybe<Scalars['Int']>;
  internalBarcodeGTE?: InputMaybe<Scalars['Int']>;
  internalBarcodeIn?: InputMaybe<Array<Scalars['Int']>>;
  internalBarcodeIsNil?: InputMaybe<Scalars['Boolean']>;
  internalBarcodeLT?: InputMaybe<Scalars['Int']>;
  internalBarcodeLTE?: InputMaybe<Scalars['Int']>;
  internalBarcodeNEQ?: InputMaybe<Scalars['Int']>;
  internalBarcodeNotIn?: InputMaybe<Array<Scalars['Int']>>;
  internalBarcodeNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<ColliWhereInput>;
  or?: InputMaybe<Array<ColliWhereInput>>;
  /** slip_print_status field predicates */
  slipPrintStatus?: InputMaybe<ColliSlipPrintStatus>;
  slipPrintStatusIn?: InputMaybe<Array<ColliSlipPrintStatus>>;
  slipPrintStatusNEQ?: InputMaybe<ColliSlipPrintStatus>;
  slipPrintStatusNotIn?: InputMaybe<Array<ColliSlipPrintStatus>>;
  /** status field predicates */
  status?: InputMaybe<ColliStatus>;
  statusIn?: InputMaybe<Array<ColliStatus>>;
  statusNEQ?: InputMaybe<ColliStatus>;
  statusNotIn?: InputMaybe<Array<ColliStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ConnectOptionCarrier = Node & {
  id: Scalars['ID'];
  name: Scalars['String'];
  tenant?: Maybe<Array<Tenant>>;
};

/** A connection to a list of items. */
export type ConnectOptionCarrierConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConnectOptionCarrierEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ConnectOptionCarrierEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ConnectOptionCarrier>;
};

/**
 * ConnectOptionCarrierWhereInput is used for filtering ConnectOptionCarrier objects.
 * Input was generated by ent.
 */
export type ConnectOptionCarrierWhereInput = {
  and?: InputMaybe<Array<ConnectOptionCarrierWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ConnectOptionCarrierWhereInput>;
  or?: InputMaybe<Array<ConnectOptionCarrierWhereInput>>;
};

export type ConnectOptionPlatform = Node & {
  id: Scalars['ID'];
  name: Scalars['String'];
  tenant?: Maybe<Array<Tenant>>;
};

/** A connection to a list of items. */
export type ConnectOptionPlatformConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConnectOptionPlatformEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ConnectOptionPlatformEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ConnectOptionPlatform>;
};

/**
 * ConnectOptionPlatformWhereInput is used for filtering ConnectOptionPlatform objects.
 * Input was generated by ent.
 */
export type ConnectOptionPlatformWhereInput = {
  and?: InputMaybe<Array<ConnectOptionPlatformWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ConnectOptionPlatformWhereInput>;
  or?: InputMaybe<Array<ConnectOptionPlatformWhereInput>>;
};

export type Connection = Node & {
  autoPrintParcelSlip: Scalars['Boolean'];
  connectionBrand: ConnectionBrand;
  connectionLookup?: Maybe<Array<ConnectionLookup>>;
  connectionShopify?: Maybe<ConnectionShopify>;
  convertCurrency: Scalars['Boolean'];
  currency: Currency;
  /** Delivery option to be set when none specified via sync or API */
  defaultDeliveryOption?: Maybe<DeliveryOption>;
  deliveryOption?: Maybe<Array<DeliveryOption>>;
  dispatchAutomatically: Scalars['Boolean'];
  fulfillAutomatically: Scalars['Boolean'];
  hypothesisTest?: Maybe<Array<HypothesisTest>>;
  id: Scalars['ID'];
  name: Scalars['String'];
  notifications?: Maybe<Array<Notification>>;
  orders?: Maybe<Array<Order>>;
  packingSlipTemplate?: Maybe<Document>;
  pickupLocation: Location;
  returnLocation: Location;
  returnPortal?: Maybe<ReturnPortal>;
  sellerLocation: Location;
  senderLocation: Location;
  syncOrders: Scalars['Boolean'];
  syncProducts: Scalars['Boolean'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

export type ConnectionBrand = Node & {
  connection?: Maybe<Array<Connection>>;
  id: Scalars['ID'];
  internalID: ConnectionBrandInternalId;
  label: Scalars['String'];
  logoURL?: Maybe<Scalars['String']>;
};

/** A connection to a list of items. */
export type ConnectionBrandConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConnectionBrandEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ConnectionBrandEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ConnectionBrand>;
};

/** ConnectionBrandInternalID is enum for the field internal_id */
export enum ConnectionBrandInternalId {
  Shopify = 'shopify'
}

/**
 * ConnectionBrandWhereInput is used for filtering ConnectionBrand objects.
 * Input was generated by ent.
 */
export type ConnectionBrandWhereInput = {
  and?: InputMaybe<Array<ConnectionBrandWhereInput>>;
  /** connection edge predicates */
  hasConnection?: InputMaybe<Scalars['Boolean']>;
  hasConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_id field predicates */
  internalID?: InputMaybe<ConnectionBrandInternalId>;
  internalIDIn?: InputMaybe<Array<ConnectionBrandInternalId>>;
  internalIDNEQ?: InputMaybe<ConnectionBrandInternalId>;
  internalIDNotIn?: InputMaybe<Array<ConnectionBrandInternalId>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** logo_url field predicates */
  logoURL?: InputMaybe<Scalars['String']>;
  logoURLContains?: InputMaybe<Scalars['String']>;
  logoURLContainsFold?: InputMaybe<Scalars['String']>;
  logoURLEqualFold?: InputMaybe<Scalars['String']>;
  logoURLGT?: InputMaybe<Scalars['String']>;
  logoURLGTE?: InputMaybe<Scalars['String']>;
  logoURLHasPrefix?: InputMaybe<Scalars['String']>;
  logoURLHasSuffix?: InputMaybe<Scalars['String']>;
  logoURLIn?: InputMaybe<Array<Scalars['String']>>;
  logoURLIsNil?: InputMaybe<Scalars['Boolean']>;
  logoURLLT?: InputMaybe<Scalars['String']>;
  logoURLLTE?: InputMaybe<Scalars['String']>;
  logoURLNEQ?: InputMaybe<Scalars['String']>;
  logoURLNotIn?: InputMaybe<Array<Scalars['String']>>;
  logoURLNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<ConnectionBrandWhereInput>;
  or?: InputMaybe<Array<ConnectionBrandWhereInput>>;
};

/** A connection to a list of items. */
export type ConnectionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConnectionEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ConnectionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Connection>;
};

export type ConnectionListItem = {
  connectionBrand: ConnectionBrand;
  id: Scalars['String'];
  name: Scalars['String'];
};

export type ConnectionLookup = Node & {
  connections?: Maybe<Connection>;
  createdAt: Scalars['Time'];
  error?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  optionsOutputCount: Scalars['Int'];
  payload: Scalars['String'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ConnectionLookupConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConnectionLookupEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ConnectionLookupEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ConnectionLookup>;
};

/** Ordering options for ConnectionLookup connections */
export type ConnectionLookupOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order ConnectionLookups. */
  field: ConnectionLookupOrderField;
};

/** Properties by which ConnectionLookup connections can be ordered. */
export enum ConnectionLookupOrderField {
  CreatedAt = 'CREATED_AT'
}

/**
 * ConnectionLookupWhereInput is used for filtering ConnectionLookup objects.
 * Input was generated by ent.
 */
export type ConnectionLookupWhereInput = {
  and?: InputMaybe<Array<ConnectionLookupWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** error field predicates */
  error?: InputMaybe<Scalars['String']>;
  errorContains?: InputMaybe<Scalars['String']>;
  errorContainsFold?: InputMaybe<Scalars['String']>;
  errorEqualFold?: InputMaybe<Scalars['String']>;
  errorGT?: InputMaybe<Scalars['String']>;
  errorGTE?: InputMaybe<Scalars['String']>;
  errorHasPrefix?: InputMaybe<Scalars['String']>;
  errorHasSuffix?: InputMaybe<Scalars['String']>;
  errorIn?: InputMaybe<Array<Scalars['String']>>;
  errorIsNil?: InputMaybe<Scalars['Boolean']>;
  errorLT?: InputMaybe<Scalars['String']>;
  errorLTE?: InputMaybe<Scalars['String']>;
  errorNEQ?: InputMaybe<Scalars['String']>;
  errorNotIn?: InputMaybe<Array<Scalars['String']>>;
  errorNotNil?: InputMaybe<Scalars['Boolean']>;
  /** connections edge predicates */
  hasConnections?: InputMaybe<Scalars['Boolean']>;
  hasConnectionsWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ConnectionLookupWhereInput>;
  /** options_output_count field predicates */
  optionsOutputCount?: InputMaybe<Scalars['Int']>;
  optionsOutputCountGT?: InputMaybe<Scalars['Int']>;
  optionsOutputCountGTE?: InputMaybe<Scalars['Int']>;
  optionsOutputCountIn?: InputMaybe<Array<Scalars['Int']>>;
  optionsOutputCountLT?: InputMaybe<Scalars['Int']>;
  optionsOutputCountLTE?: InputMaybe<Scalars['Int']>;
  optionsOutputCountNEQ?: InputMaybe<Scalars['Int']>;
  optionsOutputCountNotIn?: InputMaybe<Array<Scalars['Int']>>;
  or?: InputMaybe<Array<ConnectionLookupWhereInput>>;
  /** payload field predicates */
  payload?: InputMaybe<Scalars['String']>;
  payloadContains?: InputMaybe<Scalars['String']>;
  payloadContainsFold?: InputMaybe<Scalars['String']>;
  payloadEqualFold?: InputMaybe<Scalars['String']>;
  payloadGT?: InputMaybe<Scalars['String']>;
  payloadGTE?: InputMaybe<Scalars['String']>;
  payloadHasPrefix?: InputMaybe<Scalars['String']>;
  payloadHasSuffix?: InputMaybe<Scalars['String']>;
  payloadIn?: InputMaybe<Array<Scalars['String']>>;
  payloadLT?: InputMaybe<Scalars['String']>;
  payloadLTE?: InputMaybe<Scalars['String']>;
  payloadNEQ?: InputMaybe<Scalars['String']>;
  payloadNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ConnectionShopify = Node & {
  apiKey?: Maybe<Scalars['String']>;
  connection: Connection;
  /** When set, only orders with these tags will be synchronized. Supports a  */
  filterTags?: Maybe<Array<Scalars['String']>>;
  id: Scalars['ID'];
  /** Used for token-authenticating Shopify rate lookups */
  lookupKey?: Maybe<Scalars['String']>;
  /** Since certain plans don't allow for external rates */
  rateIntegration: Scalars['Boolean'];
  storeURL?: Maybe<Scalars['String']>;
  syncFrom?: Maybe<Scalars['Time']>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ConnectionShopifyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConnectionShopifyEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ConnectionShopifyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ConnectionShopify>;
};

/**
 * ConnectionShopifyWhereInput is used for filtering ConnectionShopify objects.
 * Input was generated by ent.
 */
export type ConnectionShopifyWhereInput = {
  and?: InputMaybe<Array<ConnectionShopifyWhereInput>>;
  /** api_key field predicates */
  apiKey?: InputMaybe<Scalars['String']>;
  apiKeyContains?: InputMaybe<Scalars['String']>;
  apiKeyContainsFold?: InputMaybe<Scalars['String']>;
  apiKeyEqualFold?: InputMaybe<Scalars['String']>;
  apiKeyGT?: InputMaybe<Scalars['String']>;
  apiKeyGTE?: InputMaybe<Scalars['String']>;
  apiKeyHasPrefix?: InputMaybe<Scalars['String']>;
  apiKeyHasSuffix?: InputMaybe<Scalars['String']>;
  apiKeyIn?: InputMaybe<Array<Scalars['String']>>;
  apiKeyIsNil?: InputMaybe<Scalars['Boolean']>;
  apiKeyLT?: InputMaybe<Scalars['String']>;
  apiKeyLTE?: InputMaybe<Scalars['String']>;
  apiKeyNEQ?: InputMaybe<Scalars['String']>;
  apiKeyNotIn?: InputMaybe<Array<Scalars['String']>>;
  apiKeyNotNil?: InputMaybe<Scalars['Boolean']>;
  /** connection edge predicates */
  hasConnection?: InputMaybe<Scalars['Boolean']>;
  hasConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** lookup_key field predicates */
  lookupKey?: InputMaybe<Scalars['String']>;
  lookupKeyContains?: InputMaybe<Scalars['String']>;
  lookupKeyContainsFold?: InputMaybe<Scalars['String']>;
  lookupKeyEqualFold?: InputMaybe<Scalars['String']>;
  lookupKeyGT?: InputMaybe<Scalars['String']>;
  lookupKeyGTE?: InputMaybe<Scalars['String']>;
  lookupKeyHasPrefix?: InputMaybe<Scalars['String']>;
  lookupKeyHasSuffix?: InputMaybe<Scalars['String']>;
  lookupKeyIn?: InputMaybe<Array<Scalars['String']>>;
  lookupKeyIsNil?: InputMaybe<Scalars['Boolean']>;
  lookupKeyLT?: InputMaybe<Scalars['String']>;
  lookupKeyLTE?: InputMaybe<Scalars['String']>;
  lookupKeyNEQ?: InputMaybe<Scalars['String']>;
  lookupKeyNotIn?: InputMaybe<Array<Scalars['String']>>;
  lookupKeyNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<ConnectionShopifyWhereInput>;
  or?: InputMaybe<Array<ConnectionShopifyWhereInput>>;
  /** rate_integration field predicates */
  rateIntegration?: InputMaybe<Scalars['Boolean']>;
  rateIntegrationNEQ?: InputMaybe<Scalars['Boolean']>;
  /** store_url field predicates */
  storeURL?: InputMaybe<Scalars['String']>;
  storeURLContains?: InputMaybe<Scalars['String']>;
  storeURLContainsFold?: InputMaybe<Scalars['String']>;
  storeURLEqualFold?: InputMaybe<Scalars['String']>;
  storeURLGT?: InputMaybe<Scalars['String']>;
  storeURLGTE?: InputMaybe<Scalars['String']>;
  storeURLHasPrefix?: InputMaybe<Scalars['String']>;
  storeURLHasSuffix?: InputMaybe<Scalars['String']>;
  storeURLIn?: InputMaybe<Array<Scalars['String']>>;
  storeURLIsNil?: InputMaybe<Scalars['Boolean']>;
  storeURLLT?: InputMaybe<Scalars['String']>;
  storeURLLTE?: InputMaybe<Scalars['String']>;
  storeURLNEQ?: InputMaybe<Scalars['String']>;
  storeURLNotIn?: InputMaybe<Array<Scalars['String']>>;
  storeURLNotNil?: InputMaybe<Scalars['Boolean']>;
  /** sync_from field predicates */
  syncFrom?: InputMaybe<Scalars['Time']>;
  syncFromGT?: InputMaybe<Scalars['Time']>;
  syncFromGTE?: InputMaybe<Scalars['Time']>;
  syncFromIn?: InputMaybe<Array<Scalars['Time']>>;
  syncFromIsNil?: InputMaybe<Scalars['Boolean']>;
  syncFromLT?: InputMaybe<Scalars['Time']>;
  syncFromLTE?: InputMaybe<Scalars['Time']>;
  syncFromNEQ?: InputMaybe<Scalars['Time']>;
  syncFromNotIn?: InputMaybe<Array<Scalars['Time']>>;
  syncFromNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * ConnectionWhereInput is used for filtering Connection objects.
 * Input was generated by ent.
 */
export type ConnectionWhereInput = {
  and?: InputMaybe<Array<ConnectionWhereInput>>;
  /** auto_print_parcel_slip field predicates */
  autoPrintParcelSlip?: InputMaybe<Scalars['Boolean']>;
  autoPrintParcelSlipNEQ?: InputMaybe<Scalars['Boolean']>;
  /** convert_currency field predicates */
  convertCurrency?: InputMaybe<Scalars['Boolean']>;
  convertCurrencyNEQ?: InputMaybe<Scalars['Boolean']>;
  /** dispatch_automatically field predicates */
  dispatchAutomatically?: InputMaybe<Scalars['Boolean']>;
  dispatchAutomaticallyNEQ?: InputMaybe<Scalars['Boolean']>;
  /** fulfill_automatically field predicates */
  fulfillAutomatically?: InputMaybe<Scalars['Boolean']>;
  fulfillAutomaticallyNEQ?: InputMaybe<Scalars['Boolean']>;
  /** connection_brand edge predicates */
  hasConnectionBrand?: InputMaybe<Scalars['Boolean']>;
  hasConnectionBrandWith?: InputMaybe<Array<ConnectionBrandWhereInput>>;
  /** connection_lookup edge predicates */
  hasConnectionLookup?: InputMaybe<Scalars['Boolean']>;
  hasConnectionLookupWith?: InputMaybe<Array<ConnectionLookupWhereInput>>;
  /** connection_shopify edge predicates */
  hasConnectionShopify?: InputMaybe<Scalars['Boolean']>;
  hasConnectionShopifyWith?: InputMaybe<Array<ConnectionShopifyWhereInput>>;
  /** currency edge predicates */
  hasCurrency?: InputMaybe<Scalars['Boolean']>;
  hasCurrencyWith?: InputMaybe<Array<CurrencyWhereInput>>;
  /** default_delivery_option edge predicates */
  hasDefaultDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDefaultDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** hypothesis_test edge predicates */
  hasHypothesisTest?: InputMaybe<Scalars['Boolean']>;
  hasHypothesisTestWith?: InputMaybe<Array<HypothesisTestWhereInput>>;
  /** notifications edge predicates */
  hasNotifications?: InputMaybe<Scalars['Boolean']>;
  hasNotificationsWith?: InputMaybe<Array<NotificationWhereInput>>;
  /** orders edge predicates */
  hasOrders?: InputMaybe<Scalars['Boolean']>;
  hasOrdersWith?: InputMaybe<Array<OrderWhereInput>>;
  /** packing_slip_template edge predicates */
  hasPackingSlipTemplate?: InputMaybe<Scalars['Boolean']>;
  hasPackingSlipTemplateWith?: InputMaybe<Array<DocumentWhereInput>>;
  /** pickup_location edge predicates */
  hasPickupLocation?: InputMaybe<Scalars['Boolean']>;
  hasPickupLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** return_location edge predicates */
  hasReturnLocation?: InputMaybe<Scalars['Boolean']>;
  hasReturnLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** return_portal edge predicates */
  hasReturnPortal?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalWith?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** seller_location edge predicates */
  hasSellerLocation?: InputMaybe<Scalars['Boolean']>;
  hasSellerLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** sender_location edge predicates */
  hasSenderLocation?: InputMaybe<Scalars['Boolean']>;
  hasSenderLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ConnectionWhereInput>;
  or?: InputMaybe<Array<ConnectionWhereInput>>;
  /** sync_orders field predicates */
  syncOrders?: InputMaybe<Scalars['Boolean']>;
  syncOrdersNEQ?: InputMaybe<Scalars['Boolean']>;
  /** sync_products field predicates */
  syncProducts?: InputMaybe<Scalars['Boolean']>;
  syncProductsNEQ?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type Consolidation = Node & {
  cancelledShipments?: Maybe<Array<Shipment>>;
  createdAt?: Maybe<Scalars['Time']>;
  deliveryOption?: Maybe<DeliveryOption>;
  description?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  orders?: Maybe<Array<Order>>;
  pallets?: Maybe<Array<Pallet>>;
  publicID: Scalars['String'];
  recipient?: Maybe<Address>;
  sender?: Maybe<Address>;
  shipment?: Maybe<Shipment>;
  status: ConsolidationStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ConsolidationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ConsolidationEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ConsolidationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Consolidation>;
};

/** Ordering options for Consolidation connections */
export type ConsolidationOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Consolidations. */
  field: ConsolidationOrderField;
};

/** Properties by which Consolidation connections can be ordered. */
export enum ConsolidationOrderField {
  CreatedAt = 'CREATED_AT'
}

export type ConsolidationShipmentStatus = {
  mayBook: Scalars['Boolean'];
  mayPrebook: Scalars['Boolean'];
  shipment?: Maybe<Shipment>;
};

/** ConsolidationStatus is enum for the field status */
export enum ConsolidationStatus {
  Booked = 'Booked',
  Cancelled = 'Cancelled',
  Pending = 'Pending',
  Prebooked = 'Prebooked'
}

/**
 * ConsolidationWhereInput is used for filtering Consolidation objects.
 * Input was generated by ent.
 */
export type ConsolidationWhereInput = {
  and?: InputMaybe<Array<ConsolidationWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** cancelled_shipments edge predicates */
  hasCancelledShipments?: InputMaybe<Scalars['Boolean']>;
  hasCancelledShipmentsWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** orders edge predicates */
  hasOrders?: InputMaybe<Scalars['Boolean']>;
  hasOrdersWith?: InputMaybe<Array<OrderWhereInput>>;
  /** pallets edge predicates */
  hasPallets?: InputMaybe<Scalars['Boolean']>;
  hasPalletsWith?: InputMaybe<Array<PalletWhereInput>>;
  /** recipient edge predicates */
  hasRecipient?: InputMaybe<Scalars['Boolean']>;
  hasRecipientWith?: InputMaybe<Array<AddressWhereInput>>;
  /** sender edge predicates */
  hasSender?: InputMaybe<Scalars['Boolean']>;
  hasSenderWith?: InputMaybe<Array<AddressWhereInput>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ConsolidationWhereInput>;
  or?: InputMaybe<Array<ConsolidationWhereInput>>;
  /** public_id field predicates */
  publicID?: InputMaybe<Scalars['String']>;
  publicIDContains?: InputMaybe<Scalars['String']>;
  publicIDContainsFold?: InputMaybe<Scalars['String']>;
  publicIDEqualFold?: InputMaybe<Scalars['String']>;
  publicIDGT?: InputMaybe<Scalars['String']>;
  publicIDGTE?: InputMaybe<Scalars['String']>;
  publicIDHasPrefix?: InputMaybe<Scalars['String']>;
  publicIDHasSuffix?: InputMaybe<Scalars['String']>;
  publicIDIn?: InputMaybe<Array<Scalars['String']>>;
  publicIDLT?: InputMaybe<Scalars['String']>;
  publicIDLTE?: InputMaybe<Scalars['String']>;
  publicIDNEQ?: InputMaybe<Scalars['String']>;
  publicIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** status field predicates */
  status?: InputMaybe<ConsolidationStatus>;
  statusIn?: InputMaybe<Array<ConsolidationStatus>>;
  statusNEQ?: InputMaybe<ConsolidationStatus>;
  statusNotIn?: InputMaybe<Array<ConsolidationStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type Contact = Node & {
  adminContact?: Maybe<Array<Tenant>>;
  billingContact?: Maybe<Array<Tenant>>;
  email: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  phoneNumber: Scalars['String'];
  surname: Scalars['String'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ContactConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ContactEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ContactEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Contact>;
};

/**
 * ContactWhereInput is used for filtering Contact objects.
 * Input was generated by ent.
 */
export type ContactWhereInput = {
  and?: InputMaybe<Array<ContactWhereInput>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** admin_contact edge predicates */
  hasAdminContact?: InputMaybe<Scalars['Boolean']>;
  hasAdminContactWith?: InputMaybe<Array<TenantWhereInput>>;
  /** billing_contact edge predicates */
  hasBillingContact?: InputMaybe<Scalars['Boolean']>;
  hasBillingContactWith?: InputMaybe<Array<TenantWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ContactWhereInput>;
  or?: InputMaybe<Array<ContactWhereInput>>;
  /** phone_number field predicates */
  phoneNumber?: InputMaybe<Scalars['String']>;
  phoneNumberContains?: InputMaybe<Scalars['String']>;
  phoneNumberContainsFold?: InputMaybe<Scalars['String']>;
  phoneNumberEqualFold?: InputMaybe<Scalars['String']>;
  phoneNumberGT?: InputMaybe<Scalars['String']>;
  phoneNumberGTE?: InputMaybe<Scalars['String']>;
  phoneNumberHasPrefix?: InputMaybe<Scalars['String']>;
  phoneNumberHasSuffix?: InputMaybe<Scalars['String']>;
  phoneNumberIn?: InputMaybe<Array<Scalars['String']>>;
  phoneNumberLT?: InputMaybe<Scalars['String']>;
  phoneNumberLTE?: InputMaybe<Scalars['String']>;
  phoneNumberNEQ?: InputMaybe<Scalars['String']>;
  phoneNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** surname field predicates */
  surname?: InputMaybe<Scalars['String']>;
  surnameContains?: InputMaybe<Scalars['String']>;
  surnameContainsFold?: InputMaybe<Scalars['String']>;
  surnameEqualFold?: InputMaybe<Scalars['String']>;
  surnameGT?: InputMaybe<Scalars['String']>;
  surnameGTE?: InputMaybe<Scalars['String']>;
  surnameHasPrefix?: InputMaybe<Scalars['String']>;
  surnameHasSuffix?: InputMaybe<Scalars['String']>;
  surnameIn?: InputMaybe<Array<Scalars['String']>>;
  surnameLT?: InputMaybe<Scalars['String']>;
  surnameLTE?: InputMaybe<Scalars['String']>;
  surnameNEQ?: InputMaybe<Scalars['String']>;
  surnameNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type Country = Node & {
  address?: Maybe<Array<Address>>;
  addressGlobal?: Maybe<Array<AddressGlobal>>;
  alpha2: Scalars['String'];
  alpha3: Scalars['String'];
  carrierAdditionalServiceGLSConsignee?: Maybe<Array<CarrierAdditionalServiceGls>>;
  carrierAdditionalServiceGLSConsignor?: Maybe<Array<CarrierAdditionalServiceGls>>;
  carrierAdditionalServicePostNordConsignee?: Maybe<Array<CarrierAdditionalServicePostNord>>;
  carrierAdditionalServicePostNordConsignor?: Maybe<Array<CarrierAdditionalServicePostNord>>;
  code: Scalars['String'];
  countryHarmonizedCode?: Maybe<Array<CountryHarmonizedCode>>;
  deliveryRule?: Maybe<Array<DeliveryRule>>;
  id: Scalars['ID'];
  inventoryItem?: Maybe<Array<InventoryItem>>;
  label: Scalars['String'];
  region: CountryRegion;
};

/** A connection to a list of items. */
export type CountryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CountryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CountryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Country>;
};

export type CountryHarmonizedCode = Node & {
  code: Scalars['String'];
  country: Country;
  id: Scalars['ID'];
  inventoryItem: InventoryItem;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type CountryHarmonizedCodeConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CountryHarmonizedCodeEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type CountryHarmonizedCodeEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<CountryHarmonizedCode>;
};

/**
 * CountryHarmonizedCodeWhereInput is used for filtering CountryHarmonizedCode objects.
 * Input was generated by ent.
 */
export type CountryHarmonizedCodeWhereInput = {
  and?: InputMaybe<Array<CountryHarmonizedCodeWhereInput>>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']>;
  codeContains?: InputMaybe<Scalars['String']>;
  codeContainsFold?: InputMaybe<Scalars['String']>;
  codeEqualFold?: InputMaybe<Scalars['String']>;
  codeGT?: InputMaybe<Scalars['String']>;
  codeGTE?: InputMaybe<Scalars['String']>;
  codeHasPrefix?: InputMaybe<Scalars['String']>;
  codeHasSuffix?: InputMaybe<Scalars['String']>;
  codeIn?: InputMaybe<Array<Scalars['String']>>;
  codeLT?: InputMaybe<Scalars['String']>;
  codeLTE?: InputMaybe<Scalars['String']>;
  codeNEQ?: InputMaybe<Scalars['String']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** country edge predicates */
  hasCountry?: InputMaybe<Scalars['Boolean']>;
  hasCountryWith?: InputMaybe<Array<CountryWhereInput>>;
  /** inventory_item edge predicates */
  hasInventoryItem?: InputMaybe<Scalars['Boolean']>;
  hasInventoryItemWith?: InputMaybe<Array<InventoryItemWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CountryHarmonizedCodeWhereInput>;
  or?: InputMaybe<Array<CountryHarmonizedCodeWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/** CountryRegion is enum for the field region */
export enum CountryRegion {
  Africa = 'Africa',
  Americas = 'Americas',
  Asia = 'Asia',
  Europe = 'Europe',
  Oceania = 'Oceania'
}

/**
 * CountryWhereInput is used for filtering Country objects.
 * Input was generated by ent.
 */
export type CountryWhereInput = {
  /** alpha_2 field predicates */
  alpha2?: InputMaybe<Scalars['String']>;
  alpha2Contains?: InputMaybe<Scalars['String']>;
  alpha2ContainsFold?: InputMaybe<Scalars['String']>;
  alpha2EqualFold?: InputMaybe<Scalars['String']>;
  alpha2GT?: InputMaybe<Scalars['String']>;
  alpha2GTE?: InputMaybe<Scalars['String']>;
  alpha2HasPrefix?: InputMaybe<Scalars['String']>;
  alpha2HasSuffix?: InputMaybe<Scalars['String']>;
  alpha2In?: InputMaybe<Array<Scalars['String']>>;
  alpha2LT?: InputMaybe<Scalars['String']>;
  alpha2LTE?: InputMaybe<Scalars['String']>;
  alpha2NEQ?: InputMaybe<Scalars['String']>;
  alpha2NotIn?: InputMaybe<Array<Scalars['String']>>;
  /** alpha_3 field predicates */
  alpha3?: InputMaybe<Scalars['String']>;
  alpha3Contains?: InputMaybe<Scalars['String']>;
  alpha3ContainsFold?: InputMaybe<Scalars['String']>;
  alpha3EqualFold?: InputMaybe<Scalars['String']>;
  alpha3GT?: InputMaybe<Scalars['String']>;
  alpha3GTE?: InputMaybe<Scalars['String']>;
  alpha3HasPrefix?: InputMaybe<Scalars['String']>;
  alpha3HasSuffix?: InputMaybe<Scalars['String']>;
  alpha3In?: InputMaybe<Array<Scalars['String']>>;
  alpha3LT?: InputMaybe<Scalars['String']>;
  alpha3LTE?: InputMaybe<Scalars['String']>;
  alpha3NEQ?: InputMaybe<Scalars['String']>;
  alpha3NotIn?: InputMaybe<Array<Scalars['String']>>;
  and?: InputMaybe<Array<CountryWhereInput>>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']>;
  codeContains?: InputMaybe<Scalars['String']>;
  codeContainsFold?: InputMaybe<Scalars['String']>;
  codeEqualFold?: InputMaybe<Scalars['String']>;
  codeGT?: InputMaybe<Scalars['String']>;
  codeGTE?: InputMaybe<Scalars['String']>;
  codeHasPrefix?: InputMaybe<Scalars['String']>;
  codeHasSuffix?: InputMaybe<Scalars['String']>;
  codeIn?: InputMaybe<Array<Scalars['String']>>;
  codeLT?: InputMaybe<Scalars['String']>;
  codeLTE?: InputMaybe<Scalars['String']>;
  codeNEQ?: InputMaybe<Scalars['String']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** address edge predicates */
  hasAddress?: InputMaybe<Scalars['Boolean']>;
  /** address_global edge predicates */
  hasAddressGlobal?: InputMaybe<Scalars['Boolean']>;
  hasAddressGlobalWith?: InputMaybe<Array<AddressGlobalWhereInput>>;
  hasAddressWith?: InputMaybe<Array<AddressWhereInput>>;
  /** carrier_additional_service_gls_consignee edge predicates */
  hasCarrierAdditionalServiceGLSConsignee?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceGLSConsigneeWith?: InputMaybe<Array<CarrierAdditionalServiceGlsWhereInput>>;
  /** carrier_additional_service_gls_consignor edge predicates */
  hasCarrierAdditionalServiceGLSConsignor?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceGLSConsignorWith?: InputMaybe<Array<CarrierAdditionalServiceGlsWhereInput>>;
  /** carrier_additional_service_post_nord_consignee edge predicates */
  hasCarrierAdditionalServicePostNordConsignee?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServicePostNordConsigneeWith?: InputMaybe<Array<CarrierAdditionalServicePostNordWhereInput>>;
  /** carrier_additional_service_post_nord_consignor edge predicates */
  hasCarrierAdditionalServicePostNordConsignor?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServicePostNordConsignorWith?: InputMaybe<Array<CarrierAdditionalServicePostNordWhereInput>>;
  /** country_harmonized_code edge predicates */
  hasCountryHarmonizedCode?: InputMaybe<Scalars['Boolean']>;
  hasCountryHarmonizedCodeWith?: InputMaybe<Array<CountryHarmonizedCodeWhereInput>>;
  /** delivery_rule edge predicates */
  hasDeliveryRule?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryRuleWith?: InputMaybe<Array<DeliveryRuleWhereInput>>;
  /** inventory_item edge predicates */
  hasInventoryItem?: InputMaybe<Scalars['Boolean']>;
  hasInventoryItemWith?: InputMaybe<Array<InventoryItemWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<CountryWhereInput>;
  or?: InputMaybe<Array<CountryWhereInput>>;
  /** region field predicates */
  region?: InputMaybe<CountryRegion>;
  regionIn?: InputMaybe<Array<CountryRegion>>;
  regionNEQ?: InputMaybe<CountryRegion>;
  regionNotIn?: InputMaybe<Array<CountryRegion>>;
};

export type CreateApiTokenSuccess = {
  id: Scalars['ID'];
  token: Scalars['String'];
};

/**
 * CreateAddressGlobalInput is used for create AddressGlobal object.
 * Input was generated by ent.
 */
export type CreateAddressGlobalInput = {
  addressOne: Scalars['String'];
  addressTwo?: InputMaybe<Scalars['String']>;
  city: Scalars['String'];
  company?: InputMaybe<Scalars['String']>;
  countryID: Scalars['ID'];
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  parcelShopBringDeliveryID?: InputMaybe<Scalars['ID']>;
  parcelShopID?: InputMaybe<Scalars['ID']>;
  parcelShopPostNordDeliveryID?: InputMaybe<Scalars['ID']>;
  state?: InputMaybe<Scalars['String']>;
  zip: Scalars['String'];
};

/**
 * CreateAddressInput is used for create Address object.
 * Input was generated by ent.
 */
export type CreateAddressInput = {
  addressOne: Scalars['String'];
  addressTwo: Scalars['String'];
  city: Scalars['String'];
  company?: InputMaybe<Scalars['String']>;
  companyAddresIDs?: InputMaybe<Array<Scalars['ID']>>;
  countryID: Scalars['ID'];
  email: Scalars['String'];
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  locationIDs?: InputMaybe<Array<Scalars['ID']>>;
  phoneNumber: Scalars['String'];
  /** Some applications have both mobile and generic */
  phoneNumber2?: InputMaybe<Scalars['String']>;
  recipientColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  recipientConsolidationID?: InputMaybe<Scalars['ID']>;
  returnRecipientColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnSenderColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  senderColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  senderConsolidationID?: InputMaybe<Scalars['ID']>;
  state?: InputMaybe<Scalars['String']>;
  /** Electronic customs */
  vatNumber?: InputMaybe<Scalars['String']>;
  zip: Scalars['String'];
};

/**
 * CreateCarrierAdditionalServiceBringInput is used for create CarrierAdditionalServiceBring object.
 * Input was generated by ent.
 */
export type CreateCarrierAdditionalServiceBringInput = {
  apiCodeBooking: Scalars['String'];
  carrierServiceBringID?: InputMaybe<Scalars['ID']>;
  deliveryOptionBringIDs?: InputMaybe<Array<Scalars['ID']>>;
  label: Scalars['String'];
};

/**
 * CreateCarrierAdditionalServiceDAOInput is used for create CarrierAdditionalServiceDAO object.
 * Input was generated by ent.
 */
export type CreateCarrierAdditionalServiceDaoInput = {
  apiCode: Scalars['String'];
  carrierServiceDAOIDs?: InputMaybe<Array<Scalars['ID']>>;
  deliveryOptionDAOIDs?: InputMaybe<Array<Scalars['ID']>>;
  label: Scalars['String'];
};

/**
 * CreateCarrierAdditionalServiceDSVInput is used for create CarrierAdditionalServiceDSV object.
 * Input was generated by ent.
 */
export type CreateCarrierAdditionalServiceDsvInput = {
  apiCode: Scalars['String'];
  carrierServiceDSVIDs?: InputMaybe<Array<Scalars['ID']>>;
  deliveryOptionDSVIDs?: InputMaybe<Array<Scalars['ID']>>;
  label: Scalars['String'];
};

/**
 * CreateCarrierAdditionalServiceGLSInput is used for create CarrierAdditionalServiceGLS object.
 * Input was generated by ent.
 */
export type CreateCarrierAdditionalServiceGlsInput = {
  /** When false, only edge countries will validate on this consignee service */
  allCountriesConsignee?: InputMaybe<Scalars['Boolean']>;
  /** When false, only edge countries will validate on this consignor service */
  allCountriesConsignor?: InputMaybe<Scalars['Boolean']>;
  carrierServiceGLSID?: InputMaybe<Scalars['ID']>;
  countriesConsigneeIDs?: InputMaybe<Array<Scalars['ID']>>;
  countriesConsignorIDs?: InputMaybe<Array<Scalars['ID']>>;
  deliveryOptionGlIDs?: InputMaybe<Array<Scalars['ID']>>;
  internalID: Scalars['String'];
  label: Scalars['String'];
  mandatory: Scalars['Boolean'];
};

export type CreateCarrierAgreementSuccess = {
  carrier: CarrierBrandInternalId;
  id: Scalars['ID'];
};

/**
 * CreateCarrierBringInput is used for create CarrierBring object.
 * Input was generated by ent.
 */
export type CreateCarrierBringInput = {
  apiKey?: InputMaybe<Scalars['String']>;
  carrierID: Scalars['ID'];
  customerNumber?: InputMaybe<Scalars['String']>;
  test?: InputMaybe<Scalars['Boolean']>;
};

/**
 * CreateCarrierDAOInput is used for create CarrierDAO object.
 * Input was generated by ent.
 */
export type CreateCarrierDaoInput = {
  apiKey?: InputMaybe<Scalars['String']>;
  carrierID: Scalars['ID'];
  customerID?: InputMaybe<Scalars['String']>;
  test?: InputMaybe<Scalars['Boolean']>;
};

/**
 * CreateCarrierDFInput is used for create CarrierDF object.
 * Input was generated by ent.
 */
export type CreateCarrierDfInput = {
  agreementNumber: Scalars['String'];
  carrierID: Scalars['ID'];
  customerID: Scalars['String'];
  test?: InputMaybe<Scalars['Boolean']>;
  whoPays?: InputMaybe<CarrierDfWhoPays>;
};

/**
 * CreateCarrierDSVInput is used for create CarrierDSV object.
 * Input was generated by ent.
 */
export type CreateCarrierDsvInput = {
  carrierID: Scalars['ID'];
};

/**
 * CreateCarrierEasyPostInput is used for create CarrierEasyPost object.
 * Input was generated by ent.
 */
export type CreateCarrierEasyPostInput = {
  apiKey: Scalars['String'];
  /** When > 1, then we use rate, then buy. =1 one-call buy. Former not implemented in first round. */
  carrierAccounts?: InputMaybe<Array<Scalars['String']>>;
  carrierID: Scalars['ID'];
  test?: InputMaybe<Scalars['Boolean']>;
};

/**
 * CreateCarrierGLSInput is used for create CarrierGLS object.
 * Input was generated by ent.
 */
export type CreateCarrierGlsInput = {
  carrierID: Scalars['ID'];
  contactID?: InputMaybe<Scalars['String']>;
  customerID?: InputMaybe<Scalars['String']>;
  glsCountryCode?: InputMaybe<Scalars['String']>;
  glsPassword?: InputMaybe<Scalars['String']>;
  glsUsername?: InputMaybe<Scalars['String']>;
  printErrorOnLabel?: InputMaybe<Scalars['Boolean']>;
  syncShipmentCancellation?: InputMaybe<Scalars['Boolean']>;
};

/**
 * CreateCarrierPostNordInput is used for create CarrierPostNord object.
 * Input was generated by ent.
 */
export type CreateCarrierPostNordInput = {
  carrierID: Scalars['ID'];
  /** Default empty to allow creation from dialog with followup editing */
  customerNumber?: InputMaybe<Scalars['String']>;
};

/**
 * CreateCarrierUSPSInput is used for create CarrierUSPS object.
 * Input was generated by ent.
 */
export type CreateCarrierUspsInput = {
  carrierID: Scalars['ID'];
  consumerKey?: InputMaybe<Scalars['String']>;
  consumerSecret?: InputMaybe<Scalars['String']>;
  crid?: InputMaybe<Scalars['String']>;
  epsAccountNumber?: InputMaybe<Scalars['String']>;
  isTestAPI?: InputMaybe<Scalars['Boolean']>;
  manifestMid?: InputMaybe<Scalars['String']>;
  mid?: InputMaybe<Scalars['String']>;
};

/**
 * CreateColliInput is used for create Colli object.
 * Input was generated by ent.
 */
export type CreateColliInput = {
  cancelledShipmentParcelIDs?: InputMaybe<Array<Scalars['ID']>>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  documentFileIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** Code128 type C compatible for faster reads */
  internalBarcode?: InputMaybe<Scalars['Int']>;
  orderID: Scalars['ID'];
  packagingID?: InputMaybe<Scalars['ID']>;
  printJobIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentParcelID?: InputMaybe<Scalars['ID']>;
  slipPrintStatus?: InputMaybe<ColliSlipPrintStatus>;
};

/**
 * CreateConnectOptionCarrierInput is used for create ConnectOptionCarrier object.
 * Input was generated by ent.
 */
export type CreateConnectOptionCarrierInput = {
  name: Scalars['String'];
  tenantIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CreateConnectOptionPlatformInput is used for create ConnectOptionPlatform object.
 * Input was generated by ent.
 */
export type CreateConnectOptionPlatformInput = {
  name: Scalars['String'];
  tenantIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CreateConnectionInput is used for create Connection object.
 * Input was generated by ent.
 */
export type CreateConnectionInput = {
  autoPrintParcelSlip?: InputMaybe<Scalars['Boolean']>;
  connectionLookupIDs?: InputMaybe<Array<Scalars['ID']>>;
  connectionShopifyID?: InputMaybe<Scalars['ID']>;
  convertCurrency?: InputMaybe<Scalars['Boolean']>;
  currencyID: Scalars['ID'];
  defaultDeliveryOptionID?: InputMaybe<Scalars['ID']>;
  deliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  dispatchAutomatically?: InputMaybe<Scalars['Boolean']>;
  fulfillAutomatically?: InputMaybe<Scalars['Boolean']>;
  hypothesisTestIDs?: InputMaybe<Array<Scalars['ID']>>;
  name: Scalars['String'];
  notificationIDs?: InputMaybe<Array<Scalars['ID']>>;
  orderIDs?: InputMaybe<Array<Scalars['ID']>>;
  packingSlipTemplateID?: InputMaybe<Scalars['ID']>;
  pickupLocationID: Scalars['ID'];
  returnLocationID: Scalars['ID'];
  returnPortalID?: InputMaybe<Scalars['ID']>;
  sellerLocationID: Scalars['ID'];
  senderLocationID: Scalars['ID'];
  syncOrders?: InputMaybe<Scalars['Boolean']>;
  syncProducts?: InputMaybe<Scalars['Boolean']>;
};

/**
 * CreateConnectionShopifyInput is used for create ConnectionShopify object.
 * Input was generated by ent.
 */
export type CreateConnectionShopifyInput = {
  apiKey?: InputMaybe<Scalars['String']>;
  /** When set, only orders with these tags will be synchronized. Supports a  */
  filterTags?: InputMaybe<Array<Scalars['String']>>;
  /** Since certain plans don't allow for external rates */
  rateIntegration?: InputMaybe<Scalars['Boolean']>;
  storeURL?: InputMaybe<Scalars['String']>;
  syncFrom?: InputMaybe<Scalars['Time']>;
};

/**
 * CreateConsolidationInput is used for create Consolidation object.
 * Input was generated by ent.
 */
export type CreateConsolidationInput = {
  cancelledShipmentIDs?: InputMaybe<Array<Scalars['ID']>>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  orderIDs?: InputMaybe<Array<Scalars['ID']>>;
  palletIDs?: InputMaybe<Array<Scalars['ID']>>;
  publicID: Scalars['String'];
  shipmentID?: InputMaybe<Scalars['ID']>;
  status?: InputMaybe<ConsolidationStatus>;
};

/**
 * CreateContactInput is used for create Contact object.
 * Input was generated by ent.
 */
export type CreateContactInput = {
  adminContactIDs?: InputMaybe<Array<Scalars['ID']>>;
  billingContactIDs?: InputMaybe<Array<Scalars['ID']>>;
  email: Scalars['String'];
  name: Scalars['String'];
  phoneNumber: Scalars['String'];
  surname: Scalars['String'];
};

/**
 * CreateCountryHarmonizedCodeInput is used for create CountryHarmonizedCode object.
 * Input was generated by ent.
 */
export type CreateCountryHarmonizedCodeInput = {
  code: Scalars['String'];
  countryID: Scalars['ID'];
  inventoryItemID: Scalars['ID'];
};

/**
 * CreateDeliveryOptionBringInput is used for create DeliveryOptionBring object.
 * Input was generated by ent.
 */
export type CreateDeliveryOptionBringInput = {
  electronicCustoms?: InputMaybe<Scalars['Boolean']>;
};

/**
 * CreateDeliveryOptionEasyPostInput is used for create DeliveryOptionEasyPost object.
 * Input was generated by ent.
 */
export type CreateDeliveryOptionEasyPostInput = {
  carrierAddServEasyPostIDs?: InputMaybe<Array<Scalars['ID']>>;
  deliveryOptionID: Scalars['ID'];
};

/**
 * CreateDeliveryOptionInput is used for create DeliveryOption object.
 * Input was generated by ent.
 */
export type CreateDeliveryOptionInput = {
  archivedAt?: InputMaybe<Scalars['Time']>;
  carrierID: Scalars['ID'];
  carrierServiceID: Scalars['ID'];
  clickCollect?: InputMaybe<Scalars['Boolean']>;
  clickCollectLocationIDs?: InputMaybe<Array<Scalars['ID']>>;
  clickOptionDisplayCount?: InputMaybe<Scalars['Int']>;
  colliIDs?: InputMaybe<Array<Scalars['ID']>>;
  connectionDefaultID?: InputMaybe<Scalars['ID']>;
  connectionID: Scalars['ID'];
  consolidationIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** Since some services are customs optional */
  customsEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Who is responsible for signing of custom docs */
  customsSigner?: InputMaybe<Scalars['String']>;
  defaultPackagingID?: InputMaybe<Scalars['ID']>;
  deliveryEstimateFrom?: InputMaybe<Scalars['Int']>;
  deliveryEstimateTo?: InputMaybe<Scalars['Int']>;
  deliveryOptionBringID?: InputMaybe<Scalars['ID']>;
  deliveryOptionDAOID?: InputMaybe<Scalars['ID']>;
  deliveryOptionDFID?: InputMaybe<Scalars['ID']>;
  deliveryOptionDSVID?: InputMaybe<Scalars['ID']>;
  deliveryOptionEasyPostID?: InputMaybe<Scalars['ID']>;
  deliveryOptionGLSID?: InputMaybe<Scalars['ID']>;
  deliveryOptionPostNordID?: InputMaybe<Scalars['ID']>;
  deliveryOptionUSPSID?: InputMaybe<Scalars['ID']>;
  deliveryRuleIDs?: InputMaybe<Array<Scalars['ID']>>;
  description?: InputMaybe<Scalars['String']>;
  emailClickCollectAtStoreID?: InputMaybe<Scalars['ID']>;
  hideDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  /** Toggle to hide this rate if a company field is not provided. */
  hideIfCompanyEmpty?: InputMaybe<Scalars['Boolean']>;
  hypothesisTestDeliveryOptionGroupOneIDs?: InputMaybe<Array<Scalars['ID']>>;
  hypothesisTestDeliveryOptionGroupTwoIDs?: InputMaybe<Array<Scalars['ID']>>;
  hypothesisTestDeliveryOptionLookupIDs?: InputMaybe<Array<Scalars['ID']>>;
  name: Scalars['String'];
  overrideReturnAddress?: InputMaybe<Scalars['Boolean']>;
  overrideSenderAddress?: InputMaybe<Scalars['Boolean']>;
  returnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnPortalIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** May contain placeholders */
  shipmondoDeliveryOption?: InputMaybe<Scalars['String']>;
  shipmondoIntegration?: InputMaybe<Scalars['Boolean']>;
  sortOrder: Scalars['Int'];
  webshipperID?: InputMaybe<Scalars['Int']>;
  webshipperIntegration?: InputMaybe<Scalars['Boolean']>;
};

/**
 * CreateDeliveryOptionPostNordInput is used for create DeliveryOptionPostNord object.
 * Input was generated by ent.
 */
export type CreateDeliveryOptionPostNordInput = {
  deliveryOptionID: Scalars['ID'];
  formatZpl?: InputMaybe<Scalars['Boolean']>;
};

export type CreateDeliveryOptionSuccess = {
  carrier: CarrierBrandInternalId;
  id: Scalars['ID'];
};

/**
 * CreateDeliveryOptionUSPSInput is used for create DeliveryOptionUSPS object.
 * Input was generated by ent.
 */
export type CreateDeliveryOptionUspsInput = {
  formatZpl?: InputMaybe<Scalars['Boolean']>;
};

/**
 * CreateDeliveryRuleConstraintGroupInput is used for create DeliveryRuleConstraintGroup object.
 * Input was generated by ent.
 */
export type CreateDeliveryRuleConstraintGroupInput = {
  constraintLogic?: InputMaybe<DeliveryRuleConstraintGroupConstraintLogic>;
  deliveryRuleConstraintIDs?: InputMaybe<Array<Scalars['ID']>>;
  deliveryRuleID: Scalars['ID'];
};

/**
 * CreateDeliveryRuleConstraintInput is used for create DeliveryRuleConstraint object.
 * Input was generated by ent.
 */
export type CreateDeliveryRuleConstraintInput = {
  comparison: DeliveryRuleConstraintComparison;
  propertyType: DeliveryRuleConstraintPropertyType;
  selectedValue: DeliveryRuleConstraintSelectedValueInput;
};

/**
 * CreateDeliveryRuleInput is used for create DeliveryRule object.
 * Input was generated by ent.
 */
export type CreateDeliveryRuleInput = {
  countryIDs?: InputMaybe<Array<Scalars['ID']>>;
  currencyID?: InputMaybe<Scalars['ID']>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  deliveryRuleConstraintGroupIDs?: InputMaybe<Array<Scalars['ID']>>;
  name: Scalars['String'];
  price?: InputMaybe<Scalars['Float']>;
};

/**
 * CreateDocumentInput is used for create Document object.
 * Input was generated by ent.
 */
export type CreateDocumentInput = {
  carrierBrandID?: InputMaybe<Scalars['ID']>;
  connectionPackingSlipIDs?: InputMaybe<Array<Scalars['ID']>>;
  endAt?: InputMaybe<Scalars['Time']>;
  htmlFooter?: InputMaybe<Scalars['String']>;
  htmlHeader?: InputMaybe<Scalars['String']>;
  htmlTemplate?: InputMaybe<Scalars['String']>;
  /** Facilitates printing by saving the latest version of this document */
  lastBase64Pdf?: InputMaybe<Scalars['String']>;
  mergeType?: InputMaybe<DocumentMergeType>;
  name: Scalars['String'];
  paperSize?: InputMaybe<DocumentPaperSize>;
  startAt?: InputMaybe<Scalars['Time']>;
};

/**
 * CreateEmailTemplateInput is used for create EmailTemplate object.
 * Input was generated by ent.
 */
export type CreateEmailTemplateInput = {
  deliveryOptionClickCollectAtStoreIDs?: InputMaybe<Array<Scalars['ID']>>;
  htmlTemplate?: InputMaybe<Scalars['String']>;
  mergeType?: InputMaybe<EmailTemplateMergeType>;
  name: Scalars['String'];
  notificationIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnPortalAcceptedIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnPortalConfirmationLabelIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnPortalConfirmationQrCodeIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnPortalReceivedIDs?: InputMaybe<Array<Scalars['ID']>>;
  subject?: InputMaybe<Scalars['String']>;
};

/**
 * CreateHypothesisTestDeliveryOptionInput is used for create HypothesisTestDeliveryOption object.
 * Input was generated by ent.
 */
export type CreateHypothesisTestDeliveryOptionInput = {
  byIntervalRotation?: InputMaybe<Scalars['Boolean']>;
  byOrder?: InputMaybe<Scalars['Boolean']>;
  deliveryOptionGroupOneIDs?: InputMaybe<Array<Scalars['ID']>>;
  deliveryOptionGroupTwoIDs?: InputMaybe<Array<Scalars['ID']>>;
  hypothesisTestDeliveryOptionRequestIDs?: InputMaybe<Array<Scalars['ID']>>;
  hypothesisTestID: Scalars['ID'];
  randomizeWithinGroupSort?: InputMaybe<Scalars['Boolean']>;
  rotationIntervalHours?: InputMaybe<Scalars['Int']>;
};

/**
 * CreateHypothesisTestDeliveryOptionLookupInput is used for create HypothesisTestDeliveryOptionLookup object.
 * Input was generated by ent.
 */
export type CreateHypothesisTestDeliveryOptionLookupInput = {
  deliveryOptionID: Scalars['ID'];
  hypothesisTestDeliveryOptionRequestID: Scalars['ID'];
};

/**
 * CreateHypothesisTestDeliveryOptionRequestInput is used for create HypothesisTestDeliveryOptionRequest object.
 * Input was generated by ent.
 */
export type CreateHypothesisTestDeliveryOptionRequestInput = {
  hypothesisTestDeliveryOptionID: Scalars['ID'];
  hypothesisTestDeliveryOptionLookupIDs?: InputMaybe<Array<Scalars['ID']>>;
  isControlGroup: Scalars['Boolean'];
  orderHash: Scalars['String'];
  orderID?: InputMaybe<Scalars['ID']>;
  requestCount: Scalars['Int'];
  shippingAddressHash: Scalars['String'];
};

/**
 * CreateHypothesisTestInput is used for create HypothesisTest object.
 * Input was generated by ent.
 */
export type CreateHypothesisTestInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  connectionID: Scalars['ID'];
  hypothesisTestDeliveryOptionID?: InputMaybe<Scalars['ID']>;
  name: Scalars['String'];
};

/**
 * CreateInventoryItemInput is used for create InventoryItem object.
 * Input was generated by ent.
 */
export type CreateInventoryItemInput = {
  /** Used when country specific code not available */
  code?: InputMaybe<Scalars['String']>;
  countryHarmonizedCodeIDs?: InputMaybe<Array<Scalars['ID']>>;
  countryOfOriginID?: InputMaybe<Scalars['ID']>;
  productVariantID: Scalars['ID'];
  /** Duplicated to match Shopify InventoryItem/ProductVariant */
  sku?: InputMaybe<Scalars['String']>;
};

/**
 * CreateLocationInput is used for create Location object.
 * Input was generated by ent.
 */
export type CreateLocationInput = {
  colliIDs?: InputMaybe<Array<Scalars['ID']>>;
  deliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  locationTagIDs: Array<Scalars['ID']>;
  /** Location name, not used in the address */
  name: Scalars['String'];
  pickupConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnPortalIDs?: InputMaybe<Array<Scalars['ID']>>;
  sellerConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  senderConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CreateNotificationInput is used for create Notification object.
 * Input was generated by ent.
 */
export type CreateNotificationInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  connectionID: Scalars['ID'];
  emailTemplateID: Scalars['ID'];
  name: Scalars['String'];
};

export type CreateOrUpdatePallet = {
  create: CreatePalletInput;
  id: Scalars['ID'];
};

/**
 * CreateOrderInput is used for create Order object.
 * Input was generated by ent.
 */
export type CreateOrderInput = {
  commentExternal?: InputMaybe<Scalars['String']>;
  commentInternal?: InputMaybe<Scalars['String']>;
  connectionID: Scalars['ID'];
  consolidationID?: InputMaybe<Scalars['ID']>;
  hypothesisTestDeliveryOptionRequestID?: InputMaybe<Scalars['ID']>;
  orderPublicID: Scalars['String'];
  palletID?: InputMaybe<Scalars['ID']>;
  returnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CreateOrderSenderInput is used for create OrderSender object.
 * Input was generated by ent.
 */
export type CreateOrderSenderInput = {
  email: Scalars['String'];
  firstName: Scalars['String'];
  lastName: Scalars['String'];
  phoneNumber: Scalars['String'];
  vatNumber: Scalars['String'];
};

/**
 * CreatePackagingDFInput is used for create PackagingDF object.
 * Input was generated by ent.
 */
export type CreatePackagingDfInput = {
  apiType: PackagingDfapiType;
  maxWeight?: InputMaybe<Scalars['Float']>;
  minWeight?: InputMaybe<Scalars['Float']>;
  /** Some carriers this is not boolean, so this is not a general toggle */
  stackable?: InputMaybe<Scalars['Boolean']>;
};

/**
 * CreatePackagingInput is used for create Packaging object.
 * Input was generated by ent.
 */
export type CreatePackagingInput = {
  archivedAt?: InputMaybe<Scalars['Time']>;
  carrierBrandID?: InputMaybe<Scalars['ID']>;
  colliIDs?: InputMaybe<Array<Scalars['ID']>>;
  deliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  heightCm: Scalars['Int'];
  lengthCm: Scalars['Int'];
  name: Scalars['String'];
  packagingDFID?: InputMaybe<Scalars['ID']>;
  packagingUSPSID?: InputMaybe<Scalars['ID']>;
  palletIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentParcelIDs?: InputMaybe<Array<Scalars['ID']>>;
  widthCm: Scalars['Int'];
};

/**
 * CreatePackagingUSPSInput is used for create PackagingUSPS object.
 * Input was generated by ent.
 */
export type CreatePackagingUspsInput = {
  packagingUSPSProcessingCategoryID: Scalars['ID'];
  packagingUSPSRateIndicatorID: Scalars['ID'];
};

/**
 * CreatePackagingUSPSProcessingCategoryInput is used for create PackagingUSPSProcessingCategory object.
 * Input was generated by ent.
 */
export type CreatePackagingUspsProcessingCategoryInput = {
  name: Scalars['String'];
  processingCategory: PackagingUspsProcessingCategoryProcessingCategory;
};

/**
 * CreatePalletInput is used for create Pallet object.
 * Input was generated by ent.
 */
export type CreatePalletInput = {
  cancelledShipmentPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  consolidationID: Scalars['ID'];
  description: Scalars['String'];
  orderIDs?: InputMaybe<Array<Scalars['ID']>>;
  packagingID?: InputMaybe<Scalars['ID']>;
  publicID: Scalars['String'];
  shipmentPalletID?: InputMaybe<Scalars['ID']>;
};

/**
 * CreateParcelShopBringInput is used for create ParcelShopBring object.
 * Input was generated by ent.
 */
export type CreateParcelShopBringInput = {
  addressDeliveryID: Scalars['ID'];
  bringID: Scalars['String'];
  parcelShopID: Scalars['ID'];
  /** https://developer.bring.com/api/pickup-point/#pickup-point-types */
  pointType: ParcelShopBringPointType;
};

/**
 * CreateParcelShopDAOInput is used for create ParcelShopDAO object.
 * Input was generated by ent.
 */
export type CreateParcelShopDaoInput = {
  parcelShopID: Scalars['ID'];
  shopID: Scalars['String'];
};

/**
 * CreateParcelShopGLSInput is used for create ParcelShopGLS object.
 * Input was generated by ent.
 */
export type CreateParcelShopGlsInput = {
  glsParcelShopID: Scalars['String'];
  parcelShopID: Scalars['ID'];
  /** Only available in Group API */
  partnerID?: InputMaybe<Scalars['String']>;
  /** Only available in Group API */
  type?: InputMaybe<Scalars['String']>;
};

/**
 * CreateParcelShopInput is used for create ParcelShop object.
 * Input was generated by ent.
 */
export type CreateParcelShopInput = {
  addressID: Scalars['ID'];
  businessHoursPeriodIDs?: InputMaybe<Array<Scalars['ID']>>;
  carrierBrandID: Scalars['ID'];
  colliIDs?: InputMaybe<Array<Scalars['ID']>>;
  name: Scalars['String'];
  parcelShopBringID?: InputMaybe<Scalars['ID']>;
  parcelShopDAOID?: InputMaybe<Scalars['ID']>;
  parcelShopGLSID?: InputMaybe<Scalars['ID']>;
  parcelShopPostNordID?: InputMaybe<Scalars['ID']>;
};

/**
 * CreateParcelShopPostNordInput is used for create ParcelShopPostNord object.
 * Input was generated by ent.
 */
export type CreateParcelShopPostNordInput = {
  addressDeliveryID: Scalars['ID'];
  parcelShopID: Scalars['ID'];
  pudoid: Scalars['String'];
  servicePointID: Scalars['String'];
  /** No idea what the options are aside from the default: 156. Maybe box, shop, etc?? */
  typeID: Scalars['String'];
};

/**
 * CreatePrinterInput is used for create Printer object.
 * Input was generated by ent.
 */
export type CreatePrinterInput = {
  document?: InputMaybe<Scalars['Boolean']>;
  labelPdf?: InputMaybe<Scalars['Boolean']>;
  labelPng?: InputMaybe<Scalars['Boolean']>;
  labelZpl?: InputMaybe<Scalars['Boolean']>;
  name: Scalars['String'];
  printJobIDs?: InputMaybe<Array<Scalars['ID']>>;
  printSize?: InputMaybe<PrinterPrintSize>;
  rotate180?: InputMaybe<Scalars['Boolean']>;
  useShell?: InputMaybe<Scalars['Boolean']>;
  workstationID: Scalars['ID'];
};

/**
 * CreateProductInput is used for create Product object.
 * Input was generated by ent.
 */
export type CreateProductInput = {
  bodyHTML?: InputMaybe<Scalars['String']>;
  productImageIDs?: InputMaybe<Array<Scalars['ID']>>;
  productTagIDs?: InputMaybe<Array<Scalars['ID']>>;
  productVariantIDs?: InputMaybe<Array<Scalars['ID']>>;
  status?: InputMaybe<ProductStatus>;
  title: Scalars['String'];
};

/**
 * CreateProductTagInput is used for create ProductTag object.
 * Input was generated by ent.
 */
export type CreateProductTagInput = {
  createdAt?: InputMaybe<Scalars['Time']>;
  name: Scalars['String'];
  productIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CreateProductVariantInput is used for create ProductVariant object.
 * Input was generated by ent.
 */
export type CreateProductVariantInput = {
  archived?: InputMaybe<Scalars['Boolean']>;
  description?: InputMaybe<Scalars['String']>;
  dimensionHeight?: InputMaybe<Scalars['Int']>;
  dimensionLength?: InputMaybe<Scalars['Int']>;
  dimensionWidth?: InputMaybe<Scalars['Int']>;
  eanNumber?: InputMaybe<Scalars['String']>;
  inventoryItemID?: InputMaybe<Scalars['ID']>;
  orderLineIDs?: InputMaybe<Array<Scalars['ID']>>;
  productImageIDs?: InputMaybe<Array<Scalars['ID']>>;
  weightG?: InputMaybe<Scalars['Int']>;
};

/**
 * CreateReturnColliInput is used for create ReturnColli object.
 * Input was generated by ent.
 */
export type CreateReturnColliInput = {
  comment?: InputMaybe<Scalars['String']>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  /** Timestamp of email successfully sent after status changed to accepted */
  emailAccepted?: InputMaybe<Scalars['Time']>;
  /** Timestamp of email successfully sent after status changed to pending */
  emailConfirmationLabel?: InputMaybe<Scalars['Time']>;
  /** Timestamp of email successfully sent after status changed to pending */
  emailConfirmationQrCode?: InputMaybe<Scalars['Time']>;
  /** Timestamp of email successfully sent after status changed to received */
  emailReceived?: InputMaybe<Scalars['Time']>;
  expectedAt?: InputMaybe<Scalars['Time']>;
  labelPdf?: InputMaybe<Scalars['String']>;
  labelPng?: InputMaybe<Scalars['String']>;
  orderID: Scalars['ID'];
  packagingID?: InputMaybe<Scalars['ID']>;
  qrCodePng?: InputMaybe<Scalars['String']>;
  returnOrderLineIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnPortalID: Scalars['ID'];
  status?: InputMaybe<ReturnColliStatus>;
};

/**
 * CreateReturnOrderLineInput is used for create ReturnOrderLine object.
 * Input was generated by ent.
 */
export type CreateReturnOrderLineInput = {
  orderLineID: Scalars['ID'];
  returnColliID: Scalars['ID'];
  returnPortalClaimID: Scalars['ID'];
  units: Scalars['Int'];
};

/**
 * CreateReturnPortalClaimInput is used for create ReturnPortalClaim object.
 * Input was generated by ent.
 */
export type CreateReturnPortalClaimInput = {
  description: Scalars['String'];
  name: Scalars['String'];
  restockable: Scalars['Boolean'];
  returnLocationID?: InputMaybe<Scalars['ID']>;
  returnOrderLineIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnPortalID: Scalars['ID'];
};

/**
 * CreateReturnPortalInput is used for create ReturnPortal object.
 * Input was generated by ent.
 */
export type CreateReturnPortalInput = {
  automaticallyAccept?: InputMaybe<Scalars['Boolean']>;
  connectionID?: InputMaybe<Scalars['ID']>;
  deliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  emailAcceptedID?: InputMaybe<Scalars['ID']>;
  emailConfirmationLabelID?: InputMaybe<Scalars['ID']>;
  emailConfirmationQrCodeID?: InputMaybe<Scalars['ID']>;
  emailReceivedID?: InputMaybe<Scalars['ID']>;
  name: Scalars['String'];
  returnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnLocationIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnOpenHours?: InputMaybe<Scalars['Int']>;
  returnPortalClaimIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CreateSeatGroupAccessRightInput is used for create SeatGroupAccessRight object.
 * Input was generated by ent.
 */
export type CreateSeatGroupAccessRightInput = {
  accessRightID: Scalars['ID'];
  level?: InputMaybe<SeatGroupAccessRightLevel>;
  seatGroupID: Scalars['ID'];
};

/**
 * CreateSeatGroupInput is used for create SeatGroup object.
 * Input was generated by ent.
 */
export type CreateSeatGroupInput = {
  assignedAccessRightIDs?: InputMaybe<Array<Scalars['ID']>>;
  createdAt?: InputMaybe<Scalars['Time']>;
  name: Scalars['String'];
  userIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CreateShipmentBringInput is used for create ShipmentBring object.
 * Input was generated by ent.
 */
export type CreateShipmentBringInput = {
  consignmentNumber: Scalars['String'];
  shipmentID: Scalars['ID'];
};

export type CreateShipmentConsolidationResponse = {
  allLabels: Scalars['String'];
  labelsPDF: Array<Scalars['String']>;
  shipment: Shipment;
};

/**
 * CreateShipmentDAOInput is used for create ShipmentDAO object.
 * Input was generated by ent.
 */
export type CreateShipmentDaoInput = {
  barcodeID: Scalars['String'];
  shipmentID: Scalars['ID'];
};

/**
 * CreateShipmentDSVInput is used for create ShipmentDSV object.
 * Input was generated by ent.
 */
export type CreateShipmentDsvInput = {
  barcodeID: Scalars['String'];
  shipmentID: Scalars['ID'];
};

/**
 * CreateShipmentInput is used for create Shipment object.
 * Input was generated by ent.
 */
export type CreateShipmentInput = {
  carrierID: Scalars['ID'];
  consolidationID?: InputMaybe<Scalars['ID']>;
  oldConsolidationIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentBringID?: InputMaybe<Scalars['ID']>;
  shipmentDAOID?: InputMaybe<Scalars['ID']>;
  shipmentDFID?: InputMaybe<Scalars['ID']>;
  shipmentDSVID?: InputMaybe<Scalars['ID']>;
  shipmentEasyPostID?: InputMaybe<Scalars['ID']>;
  shipmentGLSID?: InputMaybe<Scalars['ID']>;
  shipmentHistoryIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentParcelIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentPostNordID?: InputMaybe<Scalars['ID']>;
  shipmentPublicID: Scalars['String'];
  shipmentUSPSID?: InputMaybe<Scalars['ID']>;
  status: ShipmentStatus;
};

/**
 * CreateShipmentPalletInput is used for create ShipmentPallet object.
 * Input was generated by ent.
 */
export type CreateShipmentPalletInput = {
  barcode: Scalars['String'];
  carrierID: Scalars['String'];
  colliNumber: Scalars['String'];
  labelPdf?: InputMaybe<Scalars['String']>;
  labelZpl?: InputMaybe<Scalars['String']>;
  oldPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  palletID?: InputMaybe<Scalars['ID']>;
  shipmentID: Scalars['ID'];
  status?: InputMaybe<ShipmentPalletStatus>;
};

/**
 * CreateShipmentParcelInput is used for create ShipmentParcel object.
 * Input was generated by ent.
 */
export type CreateShipmentParcelInput = {
  ccPickupSignatureUrls?: InputMaybe<Array<Scalars['String']>>;
  colliID?: InputMaybe<Scalars['ID']>;
  documentFileID?: InputMaybe<Scalars['ID']>;
  itemID?: InputMaybe<Scalars['String']>;
  oldColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  packagingID?: InputMaybe<Scalars['ID']>;
  printJobIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentID: Scalars['ID'];
  status?: InputMaybe<ShipmentParcelStatus>;
  workspaceRecentScanIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CreateShipmentPostNordInput is used for create ShipmentPostNord object.
 * Input was generated by ent.
 */
export type CreateShipmentPostNordInput = {
  /** Multiple labels. May contain unrelated shipments. */
  bookingID: Scalars['String'];
  /** Individual label. Can be grouped to same address. Probably should not be on this ent? */
  itemID: Scalars['String'];
  shipmentID: Scalars['ID'];
  /** Shipment can contain multiple parcels to same address. */
  shipmentReferenceNo: Scalars['String'];
};

/**
 * CreateShipmentUSPSInput is used for create ShipmentUSPS object.
 * Input was generated by ent.
 */
export type CreateShipmentUspsInput = {
  postage?: InputMaybe<Scalars['Float']>;
  scheduledDeliveryDate?: InputMaybe<Scalars['Time']>;
  shipmentID: Scalars['ID'];
  trackingNumber?: InputMaybe<Scalars['String']>;
};

export type CreateShipmentsResponse = {
  allLabels: Scalars['String'];
  labelsPDF: Array<Scalars['String']>;
  order: Order;
  shipments: Array<ShipmentLabelsResponse>;
};

/**
 * CreateSignupOptionsInput is used for create SignupOptions object.
 * Input was generated by ent.
 */
export type CreateSignupOptionsInput = {
  betterDeliveryOptions: Scalars['Boolean'];
  clickCollect: Scalars['Boolean'];
  customDocs: Scalars['Boolean'];
  easyReturns: Scalars['Boolean'];
  improvePickPack: Scalars['Boolean'];
  numShipments: Scalars['Int'];
  reducedCosts: Scalars['Boolean'];
  shippingLabel: Scalars['Boolean'];
  usersID: Scalars['ID'];
};

/**
 * CreateTenantInput is used for create Tenant object.
 * Input was generated by ent.
 */
export type CreateTenantInput = {
  adminContactID?: InputMaybe<Scalars['ID']>;
  billingContactID?: InputMaybe<Scalars['ID']>;
  companyAddressID?: InputMaybe<Scalars['ID']>;
  connectOptionCarrierIDs?: InputMaybe<Array<Scalars['ID']>>;
  connectOptionPlatformIDs?: InputMaybe<Array<Scalars['ID']>>;
  invoiceReference?: InputMaybe<Scalars['String']>;
  name: Scalars['String'];
  vatNumber?: InputMaybe<Scalars['String']>;
};

/**
 * CreateUserInput is used for create User object.
 * Input was generated by ent.
 */
export type CreateUserInput = {
  apiTokenIDs?: InputMaybe<Array<Scalars['ID']>>;
  archivedAt?: InputMaybe<Scalars['Time']>;
  changeHistoryIDs?: InputMaybe<Array<Scalars['ID']>>;
  createdAt?: InputMaybe<Scalars['Time']>;
  email: Scalars['String'];
  languageID?: InputMaybe<Scalars['ID']>;
  marketingConsent?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  otkRequestIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** Field is just for front end convenience. Password gets stored as hash. */
  password?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** When fulfilling, the next carrier pickup date for the package can be selected */
  pickupDay?: InputMaybe<UserPickupDay>;
  /** So we can ask the user to confirm their pickup day after X hours */
  pickupDayLastChanged?: InputMaybe<Scalars['Time']>;
  planHistoryUserIDs?: InputMaybe<Array<Scalars['ID']>>;
  seatGroupID?: InputMaybe<Scalars['ID']>;
  selectedWorkstationID?: InputMaybe<Scalars['ID']>;
  signupOptionsID?: InputMaybe<Scalars['ID']>;
  surname?: InputMaybe<Scalars['String']>;
  workspaceRecentScanIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * CreateUserSeatInput is used for create UserSeat object.
 * Input was generated by ent.
 */
export type CreateUserSeatInput = {
  createdAt?: InputMaybe<Scalars['Time']>;
  email: Scalars['String'];
  name?: InputMaybe<Scalars['String']>;
  surname?: InputMaybe<Scalars['String']>;
};

/**
 * CreateWorkstationInput is used for create Workstation object.
 * Input was generated by ent.
 */
export type CreateWorkstationInput = {
  archivedAt?: InputMaybe<Scalars['Time']>;
  autoPrintReceiver?: InputMaybe<Scalars['Boolean']>;
  deviceType?: InputMaybe<WorkstationDeviceType>;
  name: Scalars['String'];
  printerIDs?: InputMaybe<Array<Scalars['ID']>>;
  selectedUserID?: InputMaybe<Scalars['ID']>;
  status?: InputMaybe<WorkstationStatus>;
  userID?: InputMaybe<Scalars['ID']>;
};

export type CreateWorkstationSuccess = {
  id: Scalars['ID'];
  registrationToken: Scalars['String'];
  registrationTokenImg: Scalars['String'];
};

export type Currency = Node & {
  currencyCode: CurrencyCurrencyCode;
  deliveryRule?: Maybe<Array<DeliveryRule>>;
  display: Scalars['String'];
  id: Scalars['ID'];
  orderLine?: Maybe<Array<OrderLine>>;
};

/** A connection to a list of items. */
export type CurrencyConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<CurrencyEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** CurrencyCurrencyCode is enum for the field currency_code */
export enum CurrencyCurrencyCode {
  Dkk = 'DKK',
  Eur = 'EUR',
  Usd = 'USD'
}

/** An edge in a connection. */
export type CurrencyEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Currency>;
};

/**
 * CurrencyWhereInput is used for filtering Currency objects.
 * Input was generated by ent.
 */
export type CurrencyWhereInput = {
  and?: InputMaybe<Array<CurrencyWhereInput>>;
  /** currency_code field predicates */
  currencyCode?: InputMaybe<CurrencyCurrencyCode>;
  currencyCodeIn?: InputMaybe<Array<CurrencyCurrencyCode>>;
  currencyCodeNEQ?: InputMaybe<CurrencyCurrencyCode>;
  currencyCodeNotIn?: InputMaybe<Array<CurrencyCurrencyCode>>;
  /** display field predicates */
  display?: InputMaybe<Scalars['String']>;
  displayContains?: InputMaybe<Scalars['String']>;
  displayContainsFold?: InputMaybe<Scalars['String']>;
  displayEqualFold?: InputMaybe<Scalars['String']>;
  displayGT?: InputMaybe<Scalars['String']>;
  displayGTE?: InputMaybe<Scalars['String']>;
  displayHasPrefix?: InputMaybe<Scalars['String']>;
  displayHasSuffix?: InputMaybe<Scalars['String']>;
  displayIn?: InputMaybe<Array<Scalars['String']>>;
  displayLT?: InputMaybe<Scalars['String']>;
  displayLTE?: InputMaybe<Scalars['String']>;
  displayNEQ?: InputMaybe<Scalars['String']>;
  displayNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** delivery_rule edge predicates */
  hasDeliveryRule?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryRuleWith?: InputMaybe<Array<DeliveryRuleWhereInput>>;
  /** order_line edge predicates */
  hasOrderLine?: InputMaybe<Scalars['Boolean']>;
  hasOrderLineWith?: InputMaybe<Array<OrderLineWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<CurrencyWhereInput>;
  or?: InputMaybe<Array<CurrencyWhereInput>>;
};

export type DashboardHypothesisTestResult = {
  ControlFailure: Scalars['Int'];
  ControlSuccess: Scalars['Int'];
  ControlWin: Scalars['Float'];
  Name: Scalars['String'];
  SignificantlyDifferent: Scalars['Boolean'];
  TestFailure: Scalars['Int'];
  TestSuccess: Scalars['Int'];
  TestWin: Scalars['Float'];
  id: Scalars['ID'];
};

export type DashboardTile = {
  id: Scalars['ID'];
  title: Scalars['String'];
  value: Scalars['String'];
};

export type DeliveryOption = Node & {
  archivedAt?: Maybe<Scalars['Time']>;
  carrier: Carrier;
  carrierService: CarrierService;
  clickCollect?: Maybe<Scalars['Boolean']>;
  clickCollectLocation?: Maybe<Array<Location>>;
  clickOptionDisplayCount?: Maybe<Scalars['Int']>;
  colli?: Maybe<Array<Colli>>;
  connection: Connection;
  /** The default delivery option for the connection. Unique since DO is already pinned to a single connection. */
  connectionDefault?: Maybe<Connection>;
  consolidation?: Maybe<Array<Consolidation>>;
  /** Since some services are customs optional */
  customsEnabled: Scalars['Boolean'];
  /** Who is responsible for signing of custom docs */
  customsSigner?: Maybe<Scalars['String']>;
  defaultPackaging?: Maybe<Packaging>;
  deliveryEstimateFrom?: Maybe<Scalars['Int']>;
  deliveryEstimateTo?: Maybe<Scalars['Int']>;
  deliveryOptionBring?: Maybe<DeliveryOptionBring>;
  deliveryOptionDAO?: Maybe<DeliveryOptionDao>;
  deliveryOptionDF?: Maybe<DeliveryOptionDf>;
  deliveryOptionDSV?: Maybe<DeliveryOptionDsv>;
  deliveryOptionEasyPost?: Maybe<DeliveryOptionEasyPost>;
  deliveryOptionGLS?: Maybe<DeliveryOptionGls>;
  deliveryOptionPostNord?: Maybe<DeliveryOptionPostNord>;
  deliveryOptionUSPS?: Maybe<DeliveryOptionUsps>;
  deliveryRule?: Maybe<Array<DeliveryRule>>;
  description?: Maybe<Scalars['String']>;
  emailClickCollectAtStore?: Maybe<EmailTemplate>;
  hideDeliveryOption?: Maybe<Scalars['Boolean']>;
  /** Toggle to hide this rate if a company field is not provided. */
  hideIfCompanyEmpty: Scalars['Boolean'];
  hypothesisTestDeliveryOptionGroupOne?: Maybe<Array<HypothesisTestDeliveryOption>>;
  hypothesisTestDeliveryOptionGroupTwo?: Maybe<Array<HypothesisTestDeliveryOption>>;
  hypothesisTestDeliveryOptionLookup?: Maybe<Array<HypothesisTestDeliveryOptionLookup>>;
  id: Scalars['ID'];
  name: Scalars['String'];
  overrideReturnAddress?: Maybe<Scalars['Boolean']>;
  overrideSenderAddress?: Maybe<Scalars['Boolean']>;
  returnColli?: Maybe<Array<ReturnColli>>;
  returnPortals?: Maybe<Array<ReturnPortal>>;
  /** May contain placeholders */
  shipmondoDeliveryOption?: Maybe<Scalars['String']>;
  shipmondoIntegration: Scalars['Boolean'];
  sortOrder: Scalars['Int'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
  webshipperID?: Maybe<Scalars['Int']>;
  webshipperIntegration: Scalars['Boolean'];
};

export type DeliveryOptionBrandName = {
  clickAndCollect: Scalars['Boolean'];
  currency?: Maybe<Currency>;
  deliveryOptionID: Scalars['ID'];
  deliveryPoint: Scalars['Boolean'];
  description: Scalars['String'];
  name: Scalars['String'];
  price?: Maybe<Scalars['String']>;
  requiresDeliveryPoint: Scalars['Boolean'];
  status: DeliveryOptionBrandNameStatus;
  warning?: Maybe<Scalars['String']>;
};

export enum DeliveryOptionBrandNameStatus {
  Available = 'AVAILABLE',
  NotAvailable = 'NOT_AVAILABLE',
  Selected = 'SELECTED'
}

export type DeliveryOptionBring = Node & {
  carrierAdditionalServiceBring?: Maybe<Array<CarrierAdditionalServiceBring>>;
  deliveryOption: DeliveryOption;
  electronicCustoms: Scalars['Boolean'];
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DeliveryOptionBringConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryOptionBringEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DeliveryOptionBringEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryOptionBring>;
};

/**
 * DeliveryOptionBringWhereInput is used for filtering DeliveryOptionBring objects.
 * Input was generated by ent.
 */
export type DeliveryOptionBringWhereInput = {
  and?: InputMaybe<Array<DeliveryOptionBringWhereInput>>;
  /** electronic_customs field predicates */
  electronicCustoms?: InputMaybe<Scalars['Boolean']>;
  electronicCustomsNEQ?: InputMaybe<Scalars['Boolean']>;
  /** carrier_additional_service_bring edge predicates */
  hasCarrierAdditionalServiceBring?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceBringWith?: InputMaybe<Array<CarrierAdditionalServiceBringWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DeliveryOptionBringWhereInput>;
  or?: InputMaybe<Array<DeliveryOptionBringWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/** A connection to a list of items. */
export type DeliveryOptionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryOptionEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

export type DeliveryOptionDao = Node & {
  carrierAdditionalServiceDAO?: Maybe<Array<CarrierAdditionalServiceDao>>;
  deliveryOption: DeliveryOption;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DeliveryOptionDaoConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryOptionDaoEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DeliveryOptionDaoEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryOptionDao>;
};

/**
 * DeliveryOptionDAOWhereInput is used for filtering DeliveryOptionDAO objects.
 * Input was generated by ent.
 */
export type DeliveryOptionDaoWhereInput = {
  and?: InputMaybe<Array<DeliveryOptionDaoWhereInput>>;
  /** carrier_additional_service_dao edge predicates */
  hasCarrierAdditionalServiceDAO?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceDAOWith?: InputMaybe<Array<CarrierAdditionalServiceDaoWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DeliveryOptionDaoWhereInput>;
  or?: InputMaybe<Array<DeliveryOptionDaoWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type DeliveryOptionDf = Node & {
  carrierAdditionalServiceDF?: Maybe<Array<CarrierAdditionalServiceDf>>;
  deliveryOption: DeliveryOption;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DeliveryOptionDfConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryOptionDfEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DeliveryOptionDfEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryOptionDf>;
};

/**
 * DeliveryOptionDFWhereInput is used for filtering DeliveryOptionDF objects.
 * Input was generated by ent.
 */
export type DeliveryOptionDfWhereInput = {
  and?: InputMaybe<Array<DeliveryOptionDfWhereInput>>;
  /** carrier_additional_service_df edge predicates */
  hasCarrierAdditionalServiceDF?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceDFWith?: InputMaybe<Array<CarrierAdditionalServiceDfWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DeliveryOptionDfWhereInput>;
  or?: InputMaybe<Array<DeliveryOptionDfWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type DeliveryOptionDsv = Node & {
  carrierAdditionalServiceDSV?: Maybe<Array<CarrierAdditionalServiceDsv>>;
  deliveryOption: DeliveryOption;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DeliveryOptionDsvConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryOptionDsvEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DeliveryOptionDsvEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryOptionDsv>;
};

/**
 * DeliveryOptionDSVWhereInput is used for filtering DeliveryOptionDSV objects.
 * Input was generated by ent.
 */
export type DeliveryOptionDsvWhereInput = {
  and?: InputMaybe<Array<DeliveryOptionDsvWhereInput>>;
  /** carrier_additional_service_dsv edge predicates */
  hasCarrierAdditionalServiceDSV?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceDSVWith?: InputMaybe<Array<CarrierAdditionalServiceDsvWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DeliveryOptionDsvWhereInput>;
  or?: InputMaybe<Array<DeliveryOptionDsvWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type DeliveryOptionEasyPost = Node & {
  carrierAddServEasyPost?: Maybe<Array<CarrierAdditionalServiceEasyPost>>;
  deliveryOption: DeliveryOption;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DeliveryOptionEasyPostConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryOptionEasyPostEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DeliveryOptionEasyPostEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryOptionEasyPost>;
};

/**
 * DeliveryOptionEasyPostWhereInput is used for filtering DeliveryOptionEasyPost objects.
 * Input was generated by ent.
 */
export type DeliveryOptionEasyPostWhereInput = {
  and?: InputMaybe<Array<DeliveryOptionEasyPostWhereInput>>;
  /** carrier_add_serv_easy_post edge predicates */
  hasCarrierAddServEasyPost?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAddServEasyPostWith?: InputMaybe<Array<CarrierAdditionalServiceEasyPostWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DeliveryOptionEasyPostWhereInput>;
  or?: InputMaybe<Array<DeliveryOptionEasyPostWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/** An edge in a connection. */
export type DeliveryOptionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryOption>;
};

export type DeliveryOptionGls = Node & {
  /** The lookup is done via the internalID, so edge input not included here. Consider refactoring to a generic entity on top of the GLS entity. */
  carrierAdditionalServiceGLS?: Maybe<Array<CarrierAdditionalServiceGls>>;
  deliveryOption: DeliveryOption;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DeliveryOptionGlsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryOptionGlsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DeliveryOptionGlsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryOptionGls>;
};

/**
 * DeliveryOptionGLSWhereInput is used for filtering DeliveryOptionGLS objects.
 * Input was generated by ent.
 */
export type DeliveryOptionGlsWhereInput = {
  and?: InputMaybe<Array<DeliveryOptionGlsWhereInput>>;
  /** carrier_additional_service_gls edge predicates */
  hasCarrierAdditionalServiceGLS?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceGLSWith?: InputMaybe<Array<CarrierAdditionalServiceGlsWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DeliveryOptionGlsWhereInput>;
  or?: InputMaybe<Array<DeliveryOptionGlsWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type DeliveryOptionPostNord = Node & {
  /** The lookup is done via the internalID, so edge input not included here. Consider refactoring to a generic entity on top of the PN entity. */
  carrierAddServPostNord?: Maybe<Array<CarrierAdditionalServicePostNord>>;
  deliveryOption: DeliveryOption;
  formatZpl: Scalars['Boolean'];
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DeliveryOptionPostNordConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryOptionPostNordEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DeliveryOptionPostNordEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryOptionPostNord>;
};

/**
 * DeliveryOptionPostNordWhereInput is used for filtering DeliveryOptionPostNord objects.
 * Input was generated by ent.
 */
export type DeliveryOptionPostNordWhereInput = {
  and?: InputMaybe<Array<DeliveryOptionPostNordWhereInput>>;
  /** format_zpl field predicates */
  formatZpl?: InputMaybe<Scalars['Boolean']>;
  formatZplNEQ?: InputMaybe<Scalars['Boolean']>;
  /** carrier_add_serv_post_nord edge predicates */
  hasCarrierAddServPostNord?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAddServPostNordWith?: InputMaybe<Array<CarrierAdditionalServicePostNordWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DeliveryOptionPostNordWhereInput>;
  or?: InputMaybe<Array<DeliveryOptionPostNordWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type DeliveryOptionProductLineInput = {
  productVariantID: Scalars['ID'];
  unitPrice: Scalars['Float'];
  units: Scalars['Int'];
};

export type DeliveryOptionSeedInput = {
  connectionID: Scalars['ID'];
  country: Scalars['ID'];
  productLines?: InputMaybe<Array<DeliveryOptionProductLineInput>>;
  zip: Scalars['String'];
};

export type DeliveryOptionUsps = Node & {
  carrierAdditionalServiceUSPS?: Maybe<Array<CarrierAdditionalServiceUsps>>;
  deliveryOption: DeliveryOption;
  formatZpl: Scalars['Boolean'];
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DeliveryOptionUspsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryOptionUspsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DeliveryOptionUspsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryOptionUsps>;
};

/**
 * DeliveryOptionUSPSWhereInput is used for filtering DeliveryOptionUSPS objects.
 * Input was generated by ent.
 */
export type DeliveryOptionUspsWhereInput = {
  and?: InputMaybe<Array<DeliveryOptionUspsWhereInput>>;
  /** format_zpl field predicates */
  formatZpl?: InputMaybe<Scalars['Boolean']>;
  formatZplNEQ?: InputMaybe<Scalars['Boolean']>;
  /** carrier_additional_service_usps edge predicates */
  hasCarrierAdditionalServiceUSPS?: InputMaybe<Scalars['Boolean']>;
  hasCarrierAdditionalServiceUSPSWith?: InputMaybe<Array<CarrierAdditionalServiceUspsWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DeliveryOptionUspsWhereInput>;
  or?: InputMaybe<Array<DeliveryOptionUspsWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * DeliveryOptionWhereInput is used for filtering DeliveryOption objects.
 * Input was generated by ent.
 */
export type DeliveryOptionWhereInput = {
  and?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** archived_at field predicates */
  archivedAt?: InputMaybe<Scalars['Time']>;
  archivedAtGT?: InputMaybe<Scalars['Time']>;
  archivedAtGTE?: InputMaybe<Scalars['Time']>;
  archivedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  archivedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  archivedAtLT?: InputMaybe<Scalars['Time']>;
  archivedAtLTE?: InputMaybe<Scalars['Time']>;
  archivedAtNEQ?: InputMaybe<Scalars['Time']>;
  archivedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  archivedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** click_collect field predicates */
  clickCollect?: InputMaybe<Scalars['Boolean']>;
  clickCollectIsNil?: InputMaybe<Scalars['Boolean']>;
  clickCollectNEQ?: InputMaybe<Scalars['Boolean']>;
  clickCollectNotNil?: InputMaybe<Scalars['Boolean']>;
  /** click_option_display_count field predicates */
  clickOptionDisplayCount?: InputMaybe<Scalars['Int']>;
  clickOptionDisplayCountGT?: InputMaybe<Scalars['Int']>;
  clickOptionDisplayCountGTE?: InputMaybe<Scalars['Int']>;
  clickOptionDisplayCountIn?: InputMaybe<Array<Scalars['Int']>>;
  clickOptionDisplayCountIsNil?: InputMaybe<Scalars['Boolean']>;
  clickOptionDisplayCountLT?: InputMaybe<Scalars['Int']>;
  clickOptionDisplayCountLTE?: InputMaybe<Scalars['Int']>;
  clickOptionDisplayCountNEQ?: InputMaybe<Scalars['Int']>;
  clickOptionDisplayCountNotIn?: InputMaybe<Array<Scalars['Int']>>;
  clickOptionDisplayCountNotNil?: InputMaybe<Scalars['Boolean']>;
  /** customs_enabled field predicates */
  customsEnabled?: InputMaybe<Scalars['Boolean']>;
  customsEnabledNEQ?: InputMaybe<Scalars['Boolean']>;
  /** customs_signer field predicates */
  customsSigner?: InputMaybe<Scalars['String']>;
  customsSignerContains?: InputMaybe<Scalars['String']>;
  customsSignerContainsFold?: InputMaybe<Scalars['String']>;
  customsSignerEqualFold?: InputMaybe<Scalars['String']>;
  customsSignerGT?: InputMaybe<Scalars['String']>;
  customsSignerGTE?: InputMaybe<Scalars['String']>;
  customsSignerHasPrefix?: InputMaybe<Scalars['String']>;
  customsSignerHasSuffix?: InputMaybe<Scalars['String']>;
  customsSignerIn?: InputMaybe<Array<Scalars['String']>>;
  customsSignerIsNil?: InputMaybe<Scalars['Boolean']>;
  customsSignerLT?: InputMaybe<Scalars['String']>;
  customsSignerLTE?: InputMaybe<Scalars['String']>;
  customsSignerNEQ?: InputMaybe<Scalars['String']>;
  customsSignerNotIn?: InputMaybe<Array<Scalars['String']>>;
  customsSignerNotNil?: InputMaybe<Scalars['Boolean']>;
  /** delivery_estimate_from field predicates */
  deliveryEstimateFrom?: InputMaybe<Scalars['Int']>;
  deliveryEstimateFromGT?: InputMaybe<Scalars['Int']>;
  deliveryEstimateFromGTE?: InputMaybe<Scalars['Int']>;
  deliveryEstimateFromIn?: InputMaybe<Array<Scalars['Int']>>;
  deliveryEstimateFromIsNil?: InputMaybe<Scalars['Boolean']>;
  deliveryEstimateFromLT?: InputMaybe<Scalars['Int']>;
  deliveryEstimateFromLTE?: InputMaybe<Scalars['Int']>;
  deliveryEstimateFromNEQ?: InputMaybe<Scalars['Int']>;
  deliveryEstimateFromNotIn?: InputMaybe<Array<Scalars['Int']>>;
  deliveryEstimateFromNotNil?: InputMaybe<Scalars['Boolean']>;
  /** delivery_estimate_to field predicates */
  deliveryEstimateTo?: InputMaybe<Scalars['Int']>;
  deliveryEstimateToGT?: InputMaybe<Scalars['Int']>;
  deliveryEstimateToGTE?: InputMaybe<Scalars['Int']>;
  deliveryEstimateToIn?: InputMaybe<Array<Scalars['Int']>>;
  deliveryEstimateToIsNil?: InputMaybe<Scalars['Boolean']>;
  deliveryEstimateToLT?: InputMaybe<Scalars['Int']>;
  deliveryEstimateToLTE?: InputMaybe<Scalars['Int']>;
  deliveryEstimateToNEQ?: InputMaybe<Scalars['Int']>;
  deliveryEstimateToNotIn?: InputMaybe<Array<Scalars['Int']>>;
  deliveryEstimateToNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  /** carrier_service edge predicates */
  hasCarrierService?: InputMaybe<Scalars['Boolean']>;
  hasCarrierServiceWith?: InputMaybe<Array<CarrierServiceWhereInput>>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** click_collect_location edge predicates */
  hasClickCollectLocation?: InputMaybe<Scalars['Boolean']>;
  hasClickCollectLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** colli edge predicates */
  hasColli?: InputMaybe<Scalars['Boolean']>;
  hasColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** connection edge predicates */
  hasConnection?: InputMaybe<Scalars['Boolean']>;
  /** connection_default edge predicates */
  hasConnectionDefault?: InputMaybe<Scalars['Boolean']>;
  hasConnectionDefaultWith?: InputMaybe<Array<ConnectionWhereInput>>;
  hasConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** consolidation edge predicates */
  hasConsolidation?: InputMaybe<Scalars['Boolean']>;
  hasConsolidationWith?: InputMaybe<Array<ConsolidationWhereInput>>;
  /** default_packaging edge predicates */
  hasDefaultPackaging?: InputMaybe<Scalars['Boolean']>;
  hasDefaultPackagingWith?: InputMaybe<Array<PackagingWhereInput>>;
  /** delivery_option_bring edge predicates */
  hasDeliveryOptionBring?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionBringWith?: InputMaybe<Array<DeliveryOptionBringWhereInput>>;
  /** delivery_option_dao edge predicates */
  hasDeliveryOptionDAO?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionDAOWith?: InputMaybe<Array<DeliveryOptionDaoWhereInput>>;
  /** delivery_option_df edge predicates */
  hasDeliveryOptionDF?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionDFWith?: InputMaybe<Array<DeliveryOptionDfWhereInput>>;
  /** delivery_option_dsv edge predicates */
  hasDeliveryOptionDSV?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionDSVWith?: InputMaybe<Array<DeliveryOptionDsvWhereInput>>;
  /** delivery_option_easy_post edge predicates */
  hasDeliveryOptionEasyPost?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionEasyPostWith?: InputMaybe<Array<DeliveryOptionEasyPostWhereInput>>;
  /** delivery_option_gls edge predicates */
  hasDeliveryOptionGLS?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionGLSWith?: InputMaybe<Array<DeliveryOptionGlsWhereInput>>;
  /** delivery_option_post_nord edge predicates */
  hasDeliveryOptionPostNord?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionPostNordWith?: InputMaybe<Array<DeliveryOptionPostNordWhereInput>>;
  /** delivery_option_usps edge predicates */
  hasDeliveryOptionUSPS?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionUSPSWith?: InputMaybe<Array<DeliveryOptionUspsWhereInput>>;
  /** delivery_rule edge predicates */
  hasDeliveryRule?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryRuleWith?: InputMaybe<Array<DeliveryRuleWhereInput>>;
  /** email_click_collect_at_store edge predicates */
  hasEmailClickCollectAtStore?: InputMaybe<Scalars['Boolean']>;
  hasEmailClickCollectAtStoreWith?: InputMaybe<Array<EmailTemplateWhereInput>>;
  /** hypothesis_test_delivery_option_group_one edge predicates */
  hasHypothesisTestDeliveryOptionGroupOne?: InputMaybe<Scalars['Boolean']>;
  hasHypothesisTestDeliveryOptionGroupOneWith?: InputMaybe<Array<HypothesisTestDeliveryOptionWhereInput>>;
  /** hypothesis_test_delivery_option_group_two edge predicates */
  hasHypothesisTestDeliveryOptionGroupTwo?: InputMaybe<Scalars['Boolean']>;
  hasHypothesisTestDeliveryOptionGroupTwoWith?: InputMaybe<Array<HypothesisTestDeliveryOptionWhereInput>>;
  /** hypothesis_test_delivery_option_lookup edge predicates */
  hasHypothesisTestDeliveryOptionLookup?: InputMaybe<Scalars['Boolean']>;
  hasHypothesisTestDeliveryOptionLookupWith?: InputMaybe<Array<HypothesisTestDeliveryOptionLookupWhereInput>>;
  /** return_colli edge predicates */
  hasReturnColli?: InputMaybe<Scalars['Boolean']>;
  hasReturnColliWith?: InputMaybe<Array<ReturnColliWhereInput>>;
  /** return_portals edge predicates */
  hasReturnPortals?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalsWith?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** hide_delivery_option field predicates */
  hideDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hideDeliveryOptionIsNil?: InputMaybe<Scalars['Boolean']>;
  hideDeliveryOptionNEQ?: InputMaybe<Scalars['Boolean']>;
  hideDeliveryOptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** hide_if_company_empty field predicates */
  hideIfCompanyEmpty?: InputMaybe<Scalars['Boolean']>;
  hideIfCompanyEmptyNEQ?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<DeliveryOptionWhereInput>;
  or?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** override_return_address field predicates */
  overrideReturnAddress?: InputMaybe<Scalars['Boolean']>;
  overrideReturnAddressIsNil?: InputMaybe<Scalars['Boolean']>;
  overrideReturnAddressNEQ?: InputMaybe<Scalars['Boolean']>;
  overrideReturnAddressNotNil?: InputMaybe<Scalars['Boolean']>;
  /** override_sender_address field predicates */
  overrideSenderAddress?: InputMaybe<Scalars['Boolean']>;
  overrideSenderAddressIsNil?: InputMaybe<Scalars['Boolean']>;
  overrideSenderAddressNEQ?: InputMaybe<Scalars['Boolean']>;
  overrideSenderAddressNotNil?: InputMaybe<Scalars['Boolean']>;
  /** shipmondo_delivery_option field predicates */
  shipmondoDeliveryOption?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionContains?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionContainsFold?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionEqualFold?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionGT?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionGTE?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionHasPrefix?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionHasSuffix?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionIn?: InputMaybe<Array<Scalars['String']>>;
  shipmondoDeliveryOptionIsNil?: InputMaybe<Scalars['Boolean']>;
  shipmondoDeliveryOptionLT?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionLTE?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionNEQ?: InputMaybe<Scalars['String']>;
  shipmondoDeliveryOptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  shipmondoDeliveryOptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** shipmondo_integration field predicates */
  shipmondoIntegration?: InputMaybe<Scalars['Boolean']>;
  shipmondoIntegrationNEQ?: InputMaybe<Scalars['Boolean']>;
  /** sort_order field predicates */
  sortOrder?: InputMaybe<Scalars['Int']>;
  sortOrderGT?: InputMaybe<Scalars['Int']>;
  sortOrderGTE?: InputMaybe<Scalars['Int']>;
  sortOrderIn?: InputMaybe<Array<Scalars['Int']>>;
  sortOrderLT?: InputMaybe<Scalars['Int']>;
  sortOrderLTE?: InputMaybe<Scalars['Int']>;
  sortOrderNEQ?: InputMaybe<Scalars['Int']>;
  sortOrderNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** webshipper_id field predicates */
  webshipperID?: InputMaybe<Scalars['Int']>;
  webshipperIDGT?: InputMaybe<Scalars['Int']>;
  webshipperIDGTE?: InputMaybe<Scalars['Int']>;
  webshipperIDIn?: InputMaybe<Array<Scalars['Int']>>;
  webshipperIDIsNil?: InputMaybe<Scalars['Boolean']>;
  webshipperIDLT?: InputMaybe<Scalars['Int']>;
  webshipperIDLTE?: InputMaybe<Scalars['Int']>;
  webshipperIDNEQ?: InputMaybe<Scalars['Int']>;
  webshipperIDNotIn?: InputMaybe<Array<Scalars['Int']>>;
  webshipperIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** webshipper_integration field predicates */
  webshipperIntegration?: InputMaybe<Scalars['Boolean']>;
  webshipperIntegrationNEQ?: InputMaybe<Scalars['Boolean']>;
};

export type DeliveryPoint = {
  address: AddressGlobal;
  id: Scalars['ID'];
  name: Scalars['String'];
};

export type DeliveryRule = Node & {
  country?: Maybe<Array<Country>>;
  currency?: Maybe<Currency>;
  deliveryOption?: Maybe<DeliveryOption>;
  /** Since constraint groups can be && or ||, we need to have groups of multiple constraints */
  deliveryRuleConstraintGroup?: Maybe<Array<DeliveryRuleConstraintGroup>>;
  id: Scalars['ID'];
  name: Scalars['String'];
  price: Scalars['Float'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DeliveryRuleConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryRuleEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

export type DeliveryRuleConstraint = Node & {
  comparison: DeliveryRuleConstraintComparison;
  deliveryRuleConstraintGroup: DeliveryRuleConstraintGroup;
  id: Scalars['ID'];
  propertyType: DeliveryRuleConstraintPropertyType;
  selectedValue: DeliveryRuleConstraintSelectedValue;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** DeliveryRuleConstraintComparison is enum for the field comparison */
export enum DeliveryRuleConstraintComparison {
  Between = 'between',
  Contains = 'contains',
  Equals = 'equals',
  GreaterThan = 'greater_than',
  LessThan = 'less_than',
  NotEquals = 'not_equals',
  Outside = 'outside',
  Prefix = 'prefix',
  Suffix = 'suffix'
}

/** A connection to a list of items. */
export type DeliveryRuleConstraintConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryRuleConstraintEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type DeliveryRuleConstraintEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryRuleConstraint>;
};

export type DeliveryRuleConstraintGroup = Node & {
  constraintLogic: DeliveryRuleConstraintGroupConstraintLogic;
  deliveryRule: DeliveryRule;
  deliveryRuleConstraints?: Maybe<Array<DeliveryRuleConstraint>>;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DeliveryRuleConstraintGroupConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DeliveryRuleConstraintGroupEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** DeliveryRuleConstraintGroupConstraintLogic is enum for the field constraint_logic */
export enum DeliveryRuleConstraintGroupConstraintLogic {
  And = 'and',
  Or = 'or'
}

/** An edge in a connection. */
export type DeliveryRuleConstraintGroupEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryRuleConstraintGroup>;
};

/**
 * DeliveryRuleConstraintGroupWhereInput is used for filtering DeliveryRuleConstraintGroup objects.
 * Input was generated by ent.
 */
export type DeliveryRuleConstraintGroupWhereInput = {
  and?: InputMaybe<Array<DeliveryRuleConstraintGroupWhereInput>>;
  /** constraint_logic field predicates */
  constraintLogic?: InputMaybe<DeliveryRuleConstraintGroupConstraintLogic>;
  constraintLogicIn?: InputMaybe<Array<DeliveryRuleConstraintGroupConstraintLogic>>;
  constraintLogicNEQ?: InputMaybe<DeliveryRuleConstraintGroupConstraintLogic>;
  constraintLogicNotIn?: InputMaybe<Array<DeliveryRuleConstraintGroupConstraintLogic>>;
  /** delivery_rule edge predicates */
  hasDeliveryRule?: InputMaybe<Scalars['Boolean']>;
  /** delivery_rule_constraints edge predicates */
  hasDeliveryRuleConstraints?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryRuleConstraintsWith?: InputMaybe<Array<DeliveryRuleConstraintWhereInput>>;
  hasDeliveryRuleWith?: InputMaybe<Array<DeliveryRuleWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DeliveryRuleConstraintGroupWhereInput>;
  or?: InputMaybe<Array<DeliveryRuleConstraintGroupWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/** DeliveryRuleConstraintPropertyType is enum for the field property_type */
export enum DeliveryRuleConstraintPropertyType {
  AllProductsTagged = 'all_products_tagged',
  CartTotal = 'cart_total',
  DayOfWeek = 'day_of_week',
  OrderLines = 'order_lines',
  PostalCodeNumeric = 'postal_code_numeric',
  PostalCodeString = 'postal_code_string',
  ProductTag = 'product_tag',
  Sku = 'sku',
  TimeOfDay = 'time_of_day',
  TotalWeight = 'total_weight'
}

export type DeliveryRuleConstraintSelectedValue = {
  dayOfWeek?: Maybe<Array<Scalars['String']>>;
  ids?: Maybe<Array<Scalars['String']>>;
  numeric?: Maybe<Scalars['Int']>;
  numericRange?: Maybe<Array<Scalars['Int']>>;
  text?: Maybe<Scalars['String']>;
  timeOfDay?: Maybe<Array<Scalars['String']>>;
  values?: Maybe<Array<Scalars['String']>>;
};

export type DeliveryRuleConstraintSelectedValueInput = {
  dayOfWeek?: InputMaybe<Array<Scalars['String']>>;
  ids?: InputMaybe<Array<Scalars['String']>>;
  numeric?: InputMaybe<Scalars['Int']>;
  numericRange?: InputMaybe<Array<Scalars['Int']>>;
  text?: InputMaybe<Scalars['String']>;
  timeOfDay?: InputMaybe<Array<Scalars['String']>>;
  values?: InputMaybe<Array<Scalars['String']>>;
};

/**
 * DeliveryRuleConstraintWhereInput is used for filtering DeliveryRuleConstraint objects.
 * Input was generated by ent.
 */
export type DeliveryRuleConstraintWhereInput = {
  and?: InputMaybe<Array<DeliveryRuleConstraintWhereInput>>;
  /** comparison field predicates */
  comparison?: InputMaybe<DeliveryRuleConstraintComparison>;
  comparisonIn?: InputMaybe<Array<DeliveryRuleConstraintComparison>>;
  comparisonNEQ?: InputMaybe<DeliveryRuleConstraintComparison>;
  comparisonNotIn?: InputMaybe<Array<DeliveryRuleConstraintComparison>>;
  /** delivery_rule_constraint_group edge predicates */
  hasDeliveryRuleConstraintGroup?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryRuleConstraintGroupWith?: InputMaybe<Array<DeliveryRuleConstraintGroupWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DeliveryRuleConstraintWhereInput>;
  or?: InputMaybe<Array<DeliveryRuleConstraintWhereInput>>;
  /** property_type field predicates */
  propertyType?: InputMaybe<DeliveryRuleConstraintPropertyType>;
  propertyTypeIn?: InputMaybe<Array<DeliveryRuleConstraintPropertyType>>;
  propertyTypeNEQ?: InputMaybe<DeliveryRuleConstraintPropertyType>;
  propertyTypeNotIn?: InputMaybe<Array<DeliveryRuleConstraintPropertyType>>;
  /** selected_value field predicates */
  selectedValue?: InputMaybe<DeliveryRuleConstraintSelectedValueInput>;
  selectedValueGT?: InputMaybe<DeliveryRuleConstraintSelectedValueInput>;
  selectedValueGTE?: InputMaybe<DeliveryRuleConstraintSelectedValueInput>;
  selectedValueIn?: InputMaybe<Array<DeliveryRuleConstraintSelectedValueInput>>;
  selectedValueLT?: InputMaybe<DeliveryRuleConstraintSelectedValueInput>;
  selectedValueLTE?: InputMaybe<DeliveryRuleConstraintSelectedValueInput>;
  selectedValueNEQ?: InputMaybe<DeliveryRuleConstraintSelectedValueInput>;
  selectedValueNotIn?: InputMaybe<Array<DeliveryRuleConstraintSelectedValueInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type DeliveryRuleConstraintWithTags = {
  constraint?: Maybe<DeliveryRuleConstraint>;
  tags?: Maybe<Array<ProductTag>>;
};

export type DeliveryRuleCountries = {
  countries: Array<Scalars['ID']>;
  ruleID: Scalars['ID'];
};

/** An edge in a connection. */
export type DeliveryRuleEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DeliveryRule>;
};

/**
 * DeliveryRuleWhereInput is used for filtering DeliveryRule objects.
 * Input was generated by ent.
 */
export type DeliveryRuleWhereInput = {
  and?: InputMaybe<Array<DeliveryRuleWhereInput>>;
  /** country edge predicates */
  hasCountry?: InputMaybe<Scalars['Boolean']>;
  hasCountryWith?: InputMaybe<Array<CountryWhereInput>>;
  /** currency edge predicates */
  hasCurrency?: InputMaybe<Scalars['Boolean']>;
  hasCurrencyWith?: InputMaybe<Array<CurrencyWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** delivery_rule_constraint_group edge predicates */
  hasDeliveryRuleConstraintGroup?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryRuleConstraintGroupWith?: InputMaybe<Array<DeliveryRuleConstraintGroupWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<DeliveryRuleWhereInput>;
  or?: InputMaybe<Array<DeliveryRuleWhereInput>>;
  /** price field predicates */
  price?: InputMaybe<Scalars['Float']>;
  priceGT?: InputMaybe<Scalars['Float']>;
  priceGTE?: InputMaybe<Scalars['Float']>;
  priceIn?: InputMaybe<Array<Scalars['Float']>>;
  priceLT?: InputMaybe<Scalars['Float']>;
  priceLTE?: InputMaybe<Scalars['Float']>;
  priceNEQ?: InputMaybe<Scalars['Float']>;
  priceNotIn?: InputMaybe<Array<Scalars['Float']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type Document = Node & {
  carrierBrand?: Maybe<CarrierBrand>;
  connectionPackingSlip?: Maybe<Array<Connection>>;
  createdAt: Scalars['Time'];
  endAt: Scalars['Time'];
  htmlFooter?: Maybe<Scalars['String']>;
  htmlHeader?: Maybe<Scalars['String']>;
  htmlTemplate?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  /** Facilitates printing by saving the latest version of this document */
  lastBase64Pdf?: Maybe<Scalars['String']>;
  mergeType: DocumentMergeType;
  name: Scalars['String'];
  paperSize: DocumentPaperSize;
  startAt: Scalars['Time'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DocumentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DocumentEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

export type DocumentDownload = {
  base64PDF: Scalars['String'];
};

/** An edge in a connection. */
export type DocumentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Document>;
};

export type DocumentFile = Node & {
  colli?: Maybe<Colli>;
  createdAt: Scalars['Time'];
  dataPdfBase64?: Maybe<Scalars['String']>;
  dataZplBase64?: Maybe<Scalars['String']>;
  docType: DocumentFileDocType;
  id: Scalars['ID'];
  shipmentParcel?: Maybe<ShipmentParcel>;
  storagePath?: Maybe<Scalars['String']>;
  storagePathZpl?: Maybe<Scalars['String']>;
  storageType: DocumentFileStorageType;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type DocumentFileConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<DocumentFileEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** DocumentFileDocType is enum for the field doc_type */
export enum DocumentFileDocType {
  CarrierLabel = 'carrier_label',
  PackingSlip = 'packing_slip'
}

/** An edge in a connection. */
export type DocumentFileEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<DocumentFile>;
};

/** DocumentFileStorageType is enum for the field storage_type */
export enum DocumentFileStorageType {
  Bucket = 'bucket',
  Database = 'database'
}

/**
 * DocumentFileWhereInput is used for filtering DocumentFile objects.
 * Input was generated by ent.
 */
export type DocumentFileWhereInput = {
  and?: InputMaybe<Array<DocumentFileWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** data_pdf_base64 field predicates */
  dataPdfBase64?: InputMaybe<Scalars['String']>;
  dataPdfBase64Contains?: InputMaybe<Scalars['String']>;
  dataPdfBase64ContainsFold?: InputMaybe<Scalars['String']>;
  dataPdfBase64EqualFold?: InputMaybe<Scalars['String']>;
  dataPdfBase64GT?: InputMaybe<Scalars['String']>;
  dataPdfBase64GTE?: InputMaybe<Scalars['String']>;
  dataPdfBase64HasPrefix?: InputMaybe<Scalars['String']>;
  dataPdfBase64HasSuffix?: InputMaybe<Scalars['String']>;
  dataPdfBase64In?: InputMaybe<Array<Scalars['String']>>;
  dataPdfBase64IsNil?: InputMaybe<Scalars['Boolean']>;
  dataPdfBase64LT?: InputMaybe<Scalars['String']>;
  dataPdfBase64LTE?: InputMaybe<Scalars['String']>;
  dataPdfBase64NEQ?: InputMaybe<Scalars['String']>;
  dataPdfBase64NotIn?: InputMaybe<Array<Scalars['String']>>;
  dataPdfBase64NotNil?: InputMaybe<Scalars['Boolean']>;
  /** data_zpl_base64 field predicates */
  dataZplBase64?: InputMaybe<Scalars['String']>;
  dataZplBase64Contains?: InputMaybe<Scalars['String']>;
  dataZplBase64ContainsFold?: InputMaybe<Scalars['String']>;
  dataZplBase64EqualFold?: InputMaybe<Scalars['String']>;
  dataZplBase64GT?: InputMaybe<Scalars['String']>;
  dataZplBase64GTE?: InputMaybe<Scalars['String']>;
  dataZplBase64HasPrefix?: InputMaybe<Scalars['String']>;
  dataZplBase64HasSuffix?: InputMaybe<Scalars['String']>;
  dataZplBase64In?: InputMaybe<Array<Scalars['String']>>;
  dataZplBase64IsNil?: InputMaybe<Scalars['Boolean']>;
  dataZplBase64LT?: InputMaybe<Scalars['String']>;
  dataZplBase64LTE?: InputMaybe<Scalars['String']>;
  dataZplBase64NEQ?: InputMaybe<Scalars['String']>;
  dataZplBase64NotIn?: InputMaybe<Array<Scalars['String']>>;
  dataZplBase64NotNil?: InputMaybe<Scalars['Boolean']>;
  /** doc_type field predicates */
  docType?: InputMaybe<DocumentFileDocType>;
  docTypeIn?: InputMaybe<Array<DocumentFileDocType>>;
  docTypeNEQ?: InputMaybe<DocumentFileDocType>;
  docTypeNotIn?: InputMaybe<Array<DocumentFileDocType>>;
  /** colli edge predicates */
  hasColli?: InputMaybe<Scalars['Boolean']>;
  hasColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** shipment_parcel edge predicates */
  hasShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  hasShipmentParcelWith?: InputMaybe<Array<ShipmentParcelWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<DocumentFileWhereInput>;
  or?: InputMaybe<Array<DocumentFileWhereInput>>;
  /** storage_path field predicates */
  storagePath?: InputMaybe<Scalars['String']>;
  storagePathContains?: InputMaybe<Scalars['String']>;
  storagePathContainsFold?: InputMaybe<Scalars['String']>;
  storagePathEqualFold?: InputMaybe<Scalars['String']>;
  storagePathGT?: InputMaybe<Scalars['String']>;
  storagePathGTE?: InputMaybe<Scalars['String']>;
  storagePathHasPrefix?: InputMaybe<Scalars['String']>;
  storagePathHasSuffix?: InputMaybe<Scalars['String']>;
  storagePathIn?: InputMaybe<Array<Scalars['String']>>;
  storagePathIsNil?: InputMaybe<Scalars['Boolean']>;
  storagePathLT?: InputMaybe<Scalars['String']>;
  storagePathLTE?: InputMaybe<Scalars['String']>;
  storagePathNEQ?: InputMaybe<Scalars['String']>;
  storagePathNotIn?: InputMaybe<Array<Scalars['String']>>;
  storagePathNotNil?: InputMaybe<Scalars['Boolean']>;
  /** storage_path_zpl field predicates */
  storagePathZpl?: InputMaybe<Scalars['String']>;
  storagePathZplContains?: InputMaybe<Scalars['String']>;
  storagePathZplContainsFold?: InputMaybe<Scalars['String']>;
  storagePathZplEqualFold?: InputMaybe<Scalars['String']>;
  storagePathZplGT?: InputMaybe<Scalars['String']>;
  storagePathZplGTE?: InputMaybe<Scalars['String']>;
  storagePathZplHasPrefix?: InputMaybe<Scalars['String']>;
  storagePathZplHasSuffix?: InputMaybe<Scalars['String']>;
  storagePathZplIn?: InputMaybe<Array<Scalars['String']>>;
  storagePathZplIsNil?: InputMaybe<Scalars['Boolean']>;
  storagePathZplLT?: InputMaybe<Scalars['String']>;
  storagePathZplLTE?: InputMaybe<Scalars['String']>;
  storagePathZplNEQ?: InputMaybe<Scalars['String']>;
  storagePathZplNotIn?: InputMaybe<Array<Scalars['String']>>;
  storagePathZplNotNil?: InputMaybe<Scalars['Boolean']>;
  /** storage_type field predicates */
  storageType?: InputMaybe<DocumentFileStorageType>;
  storageTypeIn?: InputMaybe<Array<DocumentFileStorageType>>;
  storageTypeNEQ?: InputMaybe<DocumentFileStorageType>;
  storageTypeNotIn?: InputMaybe<Array<DocumentFileStorageType>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/** DocumentMergeType is enum for the field merge_type */
export enum DocumentMergeType {
  Orders = 'Orders',
  PackingSlip = 'PackingSlip',
  Waybill = 'Waybill'
}

/** DocumentPaperSize is enum for the field paper_size */
export enum DocumentPaperSize {
  A4 = 'A4',
  FourXSix = 'Four_x_six'
}

/**
 * DocumentWhereInput is used for filtering Document objects.
 * Input was generated by ent.
 */
export type DocumentWhereInput = {
  and?: InputMaybe<Array<DocumentWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** end_at field predicates */
  endAt?: InputMaybe<Scalars['Time']>;
  endAtGT?: InputMaybe<Scalars['Time']>;
  endAtGTE?: InputMaybe<Scalars['Time']>;
  endAtIn?: InputMaybe<Array<Scalars['Time']>>;
  endAtLT?: InputMaybe<Scalars['Time']>;
  endAtLTE?: InputMaybe<Scalars['Time']>;
  endAtNEQ?: InputMaybe<Scalars['Time']>;
  endAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** carrier_brand edge predicates */
  hasCarrierBrand?: InputMaybe<Scalars['Boolean']>;
  hasCarrierBrandWith?: InputMaybe<Array<CarrierBrandWhereInput>>;
  /** connection_packing_slip edge predicates */
  hasConnectionPackingSlip?: InputMaybe<Scalars['Boolean']>;
  hasConnectionPackingSlipWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** html_footer field predicates */
  htmlFooter?: InputMaybe<Scalars['String']>;
  htmlFooterContains?: InputMaybe<Scalars['String']>;
  htmlFooterContainsFold?: InputMaybe<Scalars['String']>;
  htmlFooterEqualFold?: InputMaybe<Scalars['String']>;
  htmlFooterGT?: InputMaybe<Scalars['String']>;
  htmlFooterGTE?: InputMaybe<Scalars['String']>;
  htmlFooterHasPrefix?: InputMaybe<Scalars['String']>;
  htmlFooterHasSuffix?: InputMaybe<Scalars['String']>;
  htmlFooterIn?: InputMaybe<Array<Scalars['String']>>;
  htmlFooterIsNil?: InputMaybe<Scalars['Boolean']>;
  htmlFooterLT?: InputMaybe<Scalars['String']>;
  htmlFooterLTE?: InputMaybe<Scalars['String']>;
  htmlFooterNEQ?: InputMaybe<Scalars['String']>;
  htmlFooterNotIn?: InputMaybe<Array<Scalars['String']>>;
  htmlFooterNotNil?: InputMaybe<Scalars['Boolean']>;
  /** html_header field predicates */
  htmlHeader?: InputMaybe<Scalars['String']>;
  htmlHeaderContains?: InputMaybe<Scalars['String']>;
  htmlHeaderContainsFold?: InputMaybe<Scalars['String']>;
  htmlHeaderEqualFold?: InputMaybe<Scalars['String']>;
  htmlHeaderGT?: InputMaybe<Scalars['String']>;
  htmlHeaderGTE?: InputMaybe<Scalars['String']>;
  htmlHeaderHasPrefix?: InputMaybe<Scalars['String']>;
  htmlHeaderHasSuffix?: InputMaybe<Scalars['String']>;
  htmlHeaderIn?: InputMaybe<Array<Scalars['String']>>;
  htmlHeaderIsNil?: InputMaybe<Scalars['Boolean']>;
  htmlHeaderLT?: InputMaybe<Scalars['String']>;
  htmlHeaderLTE?: InputMaybe<Scalars['String']>;
  htmlHeaderNEQ?: InputMaybe<Scalars['String']>;
  htmlHeaderNotIn?: InputMaybe<Array<Scalars['String']>>;
  htmlHeaderNotNil?: InputMaybe<Scalars['Boolean']>;
  /** html_template field predicates */
  htmlTemplate?: InputMaybe<Scalars['String']>;
  htmlTemplateContains?: InputMaybe<Scalars['String']>;
  htmlTemplateContainsFold?: InputMaybe<Scalars['String']>;
  htmlTemplateEqualFold?: InputMaybe<Scalars['String']>;
  htmlTemplateGT?: InputMaybe<Scalars['String']>;
  htmlTemplateGTE?: InputMaybe<Scalars['String']>;
  htmlTemplateHasPrefix?: InputMaybe<Scalars['String']>;
  htmlTemplateHasSuffix?: InputMaybe<Scalars['String']>;
  htmlTemplateIn?: InputMaybe<Array<Scalars['String']>>;
  htmlTemplateIsNil?: InputMaybe<Scalars['Boolean']>;
  htmlTemplateLT?: InputMaybe<Scalars['String']>;
  htmlTemplateLTE?: InputMaybe<Scalars['String']>;
  htmlTemplateNEQ?: InputMaybe<Scalars['String']>;
  htmlTemplateNotIn?: InputMaybe<Array<Scalars['String']>>;
  htmlTemplateNotNil?: InputMaybe<Scalars['Boolean']>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** last_base64_pdf field predicates */
  lastBase64Pdf?: InputMaybe<Scalars['String']>;
  lastBase64PdfContains?: InputMaybe<Scalars['String']>;
  lastBase64PdfContainsFold?: InputMaybe<Scalars['String']>;
  lastBase64PdfEqualFold?: InputMaybe<Scalars['String']>;
  lastBase64PdfGT?: InputMaybe<Scalars['String']>;
  lastBase64PdfGTE?: InputMaybe<Scalars['String']>;
  lastBase64PdfHasPrefix?: InputMaybe<Scalars['String']>;
  lastBase64PdfHasSuffix?: InputMaybe<Scalars['String']>;
  lastBase64PdfIn?: InputMaybe<Array<Scalars['String']>>;
  lastBase64PdfIsNil?: InputMaybe<Scalars['Boolean']>;
  lastBase64PdfLT?: InputMaybe<Scalars['String']>;
  lastBase64PdfLTE?: InputMaybe<Scalars['String']>;
  lastBase64PdfNEQ?: InputMaybe<Scalars['String']>;
  lastBase64PdfNotIn?: InputMaybe<Array<Scalars['String']>>;
  lastBase64PdfNotNil?: InputMaybe<Scalars['Boolean']>;
  /** merge_type field predicates */
  mergeType?: InputMaybe<DocumentMergeType>;
  mergeTypeIn?: InputMaybe<Array<DocumentMergeType>>;
  mergeTypeNEQ?: InputMaybe<DocumentMergeType>;
  mergeTypeNotIn?: InputMaybe<Array<DocumentMergeType>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<DocumentWhereInput>;
  or?: InputMaybe<Array<DocumentWhereInput>>;
  /** paper_size field predicates */
  paperSize?: InputMaybe<DocumentPaperSize>;
  paperSizeIn?: InputMaybe<Array<DocumentPaperSize>>;
  paperSizeNEQ?: InputMaybe<DocumentPaperSize>;
  paperSizeNotIn?: InputMaybe<Array<DocumentPaperSize>>;
  /** start_at field predicates */
  startAt?: InputMaybe<Scalars['Time']>;
  startAtGT?: InputMaybe<Scalars['Time']>;
  startAtGTE?: InputMaybe<Scalars['Time']>;
  startAtIn?: InputMaybe<Array<Scalars['Time']>>;
  startAtLT?: InputMaybe<Scalars['Time']>;
  startAtLTE?: InputMaybe<Scalars['Time']>;
  startAtNEQ?: InputMaybe<Scalars['Time']>;
  startAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type EmailTemplate = Node & {
  createdAt?: Maybe<Scalars['Time']>;
  deliveryOptionClickCollectAtStore?: Maybe<Array<DeliveryOption>>;
  htmlTemplate: Scalars['String'];
  id: Scalars['ID'];
  mergeType: EmailTemplateMergeType;
  name: Scalars['String'];
  notifications?: Maybe<Array<Notification>>;
  returnPortalAccepted?: Maybe<Array<ReturnPortal>>;
  returnPortalConfirmationLabel?: Maybe<Array<ReturnPortal>>;
  returnPortalConfirmationQrCode?: Maybe<Array<ReturnPortal>>;
  returnPortalReceived?: Maybe<Array<ReturnPortal>>;
  subject: Scalars['String'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
  updatedAt: Scalars['Time'];
};

/** A connection to a list of items. */
export type EmailTemplateConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<EmailTemplateEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type EmailTemplateEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<EmailTemplate>;
};

/** EmailTemplateMergeType is enum for the field merge_type */
export enum EmailTemplateMergeType {
  OrderConfirmation = 'order_confirmation',
  OrderPicked = 'order_picked',
  ReturnColliAccepted = 'return_colli_accepted',
  ReturnColliLabel = 'return_colli_label',
  ReturnColliQr = 'return_colli_qr',
  ReturnColliReceived = 'return_colli_received'
}

/**
 * EmailTemplateWhereInput is used for filtering EmailTemplate objects.
 * Input was generated by ent.
 */
export type EmailTemplateWhereInput = {
  and?: InputMaybe<Array<EmailTemplateWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** delivery_option_click_collect_at_store edge predicates */
  hasDeliveryOptionClickCollectAtStore?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionClickCollectAtStoreWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** notifications edge predicates */
  hasNotifications?: InputMaybe<Scalars['Boolean']>;
  hasNotificationsWith?: InputMaybe<Array<NotificationWhereInput>>;
  /** return_portal_accepted edge predicates */
  hasReturnPortalAccepted?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalAcceptedWith?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** return_portal_confirmation_label edge predicates */
  hasReturnPortalConfirmationLabel?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalConfirmationLabelWith?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** return_portal_confirmation_qr_code edge predicates */
  hasReturnPortalConfirmationQrCode?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalConfirmationQrCodeWith?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** return_portal_received edge predicates */
  hasReturnPortalReceived?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalReceivedWith?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** html_template field predicates */
  htmlTemplate?: InputMaybe<Scalars['String']>;
  htmlTemplateContains?: InputMaybe<Scalars['String']>;
  htmlTemplateContainsFold?: InputMaybe<Scalars['String']>;
  htmlTemplateEqualFold?: InputMaybe<Scalars['String']>;
  htmlTemplateGT?: InputMaybe<Scalars['String']>;
  htmlTemplateGTE?: InputMaybe<Scalars['String']>;
  htmlTemplateHasPrefix?: InputMaybe<Scalars['String']>;
  htmlTemplateHasSuffix?: InputMaybe<Scalars['String']>;
  htmlTemplateIn?: InputMaybe<Array<Scalars['String']>>;
  htmlTemplateLT?: InputMaybe<Scalars['String']>;
  htmlTemplateLTE?: InputMaybe<Scalars['String']>;
  htmlTemplateNEQ?: InputMaybe<Scalars['String']>;
  htmlTemplateNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** merge_type field predicates */
  mergeType?: InputMaybe<EmailTemplateMergeType>;
  mergeTypeIn?: InputMaybe<Array<EmailTemplateMergeType>>;
  mergeTypeNEQ?: InputMaybe<EmailTemplateMergeType>;
  mergeTypeNotIn?: InputMaybe<Array<EmailTemplateMergeType>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<EmailTemplateWhereInput>;
  or?: InputMaybe<Array<EmailTemplateWhereInput>>;
  /** subject field predicates */
  subject?: InputMaybe<Scalars['String']>;
  subjectContains?: InputMaybe<Scalars['String']>;
  subjectContainsFold?: InputMaybe<Scalars['String']>;
  subjectEqualFold?: InputMaybe<Scalars['String']>;
  subjectGT?: InputMaybe<Scalars['String']>;
  subjectGTE?: InputMaybe<Scalars['String']>;
  subjectHasPrefix?: InputMaybe<Scalars['String']>;
  subjectHasSuffix?: InputMaybe<Scalars['String']>;
  subjectIn?: InputMaybe<Array<Scalars['String']>>;
  subjectLT?: InputMaybe<Scalars['String']>;
  subjectLTE?: InputMaybe<Scalars['String']>;
  subjectNEQ?: InputMaybe<Scalars['String']>;
  subjectNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export enum EntityType {
  Order = 'ORDER',
  Product = 'PRODUCT'
}

export type HistoryLog = {
  histories: Array<ChangeHistory>;
  system_event: Array<SystemEvents>;
};

export type HypothesisTest = Node & {
  active: Scalars['Boolean'];
  connection: Connection;
  hypothesisTestDeliveryOption?: Maybe<HypothesisTestDeliveryOption>;
  id: Scalars['ID'];
  name: Scalars['String'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type HypothesisTestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<HypothesisTestEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

export type HypothesisTestDeliveryOption = Node & {
  byIntervalRotation: Scalars['Boolean'];
  byOrder: Scalars['Boolean'];
  deliveryOptionGroupOne?: Maybe<Array<DeliveryOption>>;
  deliveryOptionGroupTwo?: Maybe<Array<DeliveryOption>>;
  hypothesisTest: HypothesisTest;
  hypothesisTestDeliveryOptionRequest?: Maybe<Array<HypothesisTestDeliveryOptionRequest>>;
  id: Scalars['ID'];
  randomizeWithinGroupSort: Scalars['Boolean'];
  rotationIntervalHours: Scalars['Int'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type HypothesisTestDeliveryOptionConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<HypothesisTestDeliveryOptionEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type HypothesisTestDeliveryOptionEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<HypothesisTestDeliveryOption>;
};

export type HypothesisTestDeliveryOptionLookup = Node & {
  deliveryOption: DeliveryOption;
  hypothesisTestDeliveryOptionRequest: HypothesisTestDeliveryOptionRequest;
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type HypothesisTestDeliveryOptionLookupConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<HypothesisTestDeliveryOptionLookupEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type HypothesisTestDeliveryOptionLookupEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<HypothesisTestDeliveryOptionLookup>;
};

/**
 * HypothesisTestDeliveryOptionLookupWhereInput is used for filtering HypothesisTestDeliveryOptionLookup objects.
 * Input was generated by ent.
 */
export type HypothesisTestDeliveryOptionLookupWhereInput = {
  and?: InputMaybe<Array<HypothesisTestDeliveryOptionLookupWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** hypothesis_test_delivery_option_request edge predicates */
  hasHypothesisTestDeliveryOptionRequest?: InputMaybe<Scalars['Boolean']>;
  hasHypothesisTestDeliveryOptionRequestWith?: InputMaybe<Array<HypothesisTestDeliveryOptionRequestWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<HypothesisTestDeliveryOptionLookupWhereInput>;
  or?: InputMaybe<Array<HypothesisTestDeliveryOptionLookupWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type HypothesisTestDeliveryOptionRequest = Node & {
  createdAt: Scalars['Time'];
  hypothesisTestDeliveryOption: HypothesisTestDeliveryOption;
  hypothesisTestDeliveryOptionLookup?: Maybe<Array<HypothesisTestDeliveryOptionLookup>>;
  id: Scalars['ID'];
  isControlGroup: Scalars['Boolean'];
  lastRequestedAt: Scalars['Time'];
  order?: Maybe<Order>;
  orderHash: Scalars['String'];
  requestCount: Scalars['Int'];
  shippingAddressHash: Scalars['String'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type HypothesisTestDeliveryOptionRequestConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<HypothesisTestDeliveryOptionRequestEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type HypothesisTestDeliveryOptionRequestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<HypothesisTestDeliveryOptionRequest>;
};

/**
 * HypothesisTestDeliveryOptionRequestWhereInput is used for filtering HypothesisTestDeliveryOptionRequest objects.
 * Input was generated by ent.
 */
export type HypothesisTestDeliveryOptionRequestWhereInput = {
  and?: InputMaybe<Array<HypothesisTestDeliveryOptionRequestWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** hypothesis_test_delivery_option edge predicates */
  hasHypothesisTestDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  /** hypothesis_test_delivery_option_lookup edge predicates */
  hasHypothesisTestDeliveryOptionLookup?: InputMaybe<Scalars['Boolean']>;
  hasHypothesisTestDeliveryOptionLookupWith?: InputMaybe<Array<HypothesisTestDeliveryOptionLookupWhereInput>>;
  hasHypothesisTestDeliveryOptionWith?: InputMaybe<Array<HypothesisTestDeliveryOptionWhereInput>>;
  /** order edge predicates */
  hasOrder?: InputMaybe<Scalars['Boolean']>;
  hasOrderWith?: InputMaybe<Array<OrderWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** is_control_group field predicates */
  isControlGroup?: InputMaybe<Scalars['Boolean']>;
  isControlGroupNEQ?: InputMaybe<Scalars['Boolean']>;
  /** last_requested_at field predicates */
  lastRequestedAt?: InputMaybe<Scalars['Time']>;
  lastRequestedAtGT?: InputMaybe<Scalars['Time']>;
  lastRequestedAtGTE?: InputMaybe<Scalars['Time']>;
  lastRequestedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  lastRequestedAtLT?: InputMaybe<Scalars['Time']>;
  lastRequestedAtLTE?: InputMaybe<Scalars['Time']>;
  lastRequestedAtNEQ?: InputMaybe<Scalars['Time']>;
  lastRequestedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  not?: InputMaybe<HypothesisTestDeliveryOptionRequestWhereInput>;
  or?: InputMaybe<Array<HypothesisTestDeliveryOptionRequestWhereInput>>;
  /** order_hash field predicates */
  orderHash?: InputMaybe<Scalars['String']>;
  orderHashContains?: InputMaybe<Scalars['String']>;
  orderHashContainsFold?: InputMaybe<Scalars['String']>;
  orderHashEqualFold?: InputMaybe<Scalars['String']>;
  orderHashGT?: InputMaybe<Scalars['String']>;
  orderHashGTE?: InputMaybe<Scalars['String']>;
  orderHashHasPrefix?: InputMaybe<Scalars['String']>;
  orderHashHasSuffix?: InputMaybe<Scalars['String']>;
  orderHashIn?: InputMaybe<Array<Scalars['String']>>;
  orderHashLT?: InputMaybe<Scalars['String']>;
  orderHashLTE?: InputMaybe<Scalars['String']>;
  orderHashNEQ?: InputMaybe<Scalars['String']>;
  orderHashNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** request_count field predicates */
  requestCount?: InputMaybe<Scalars['Int']>;
  requestCountGT?: InputMaybe<Scalars['Int']>;
  requestCountGTE?: InputMaybe<Scalars['Int']>;
  requestCountIn?: InputMaybe<Array<Scalars['Int']>>;
  requestCountLT?: InputMaybe<Scalars['Int']>;
  requestCountLTE?: InputMaybe<Scalars['Int']>;
  requestCountNEQ?: InputMaybe<Scalars['Int']>;
  requestCountNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** shipping_address_hash field predicates */
  shippingAddressHash?: InputMaybe<Scalars['String']>;
  shippingAddressHashContains?: InputMaybe<Scalars['String']>;
  shippingAddressHashContainsFold?: InputMaybe<Scalars['String']>;
  shippingAddressHashEqualFold?: InputMaybe<Scalars['String']>;
  shippingAddressHashGT?: InputMaybe<Scalars['String']>;
  shippingAddressHashGTE?: InputMaybe<Scalars['String']>;
  shippingAddressHashHasPrefix?: InputMaybe<Scalars['String']>;
  shippingAddressHashHasSuffix?: InputMaybe<Scalars['String']>;
  shippingAddressHashIn?: InputMaybe<Array<Scalars['String']>>;
  shippingAddressHashLT?: InputMaybe<Scalars['String']>;
  shippingAddressHashLTE?: InputMaybe<Scalars['String']>;
  shippingAddressHashNEQ?: InputMaybe<Scalars['String']>;
  shippingAddressHashNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * HypothesisTestDeliveryOptionWhereInput is used for filtering HypothesisTestDeliveryOption objects.
 * Input was generated by ent.
 */
export type HypothesisTestDeliveryOptionWhereInput = {
  and?: InputMaybe<Array<HypothesisTestDeliveryOptionWhereInput>>;
  /** by_interval_rotation field predicates */
  byIntervalRotation?: InputMaybe<Scalars['Boolean']>;
  byIntervalRotationNEQ?: InputMaybe<Scalars['Boolean']>;
  /** by_order field predicates */
  byOrder?: InputMaybe<Scalars['Boolean']>;
  byOrderNEQ?: InputMaybe<Scalars['Boolean']>;
  /** delivery_option_group_one edge predicates */
  hasDeliveryOptionGroupOne?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionGroupOneWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** delivery_option_group_two edge predicates */
  hasDeliveryOptionGroupTwo?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionGroupTwoWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** hypothesis_test edge predicates */
  hasHypothesisTest?: InputMaybe<Scalars['Boolean']>;
  /** hypothesis_test_delivery_option_request edge predicates */
  hasHypothesisTestDeliveryOptionRequest?: InputMaybe<Scalars['Boolean']>;
  hasHypothesisTestDeliveryOptionRequestWith?: InputMaybe<Array<HypothesisTestDeliveryOptionRequestWhereInput>>;
  hasHypothesisTestWith?: InputMaybe<Array<HypothesisTestWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<HypothesisTestDeliveryOptionWhereInput>;
  or?: InputMaybe<Array<HypothesisTestDeliveryOptionWhereInput>>;
  /** randomize_within_group_sort field predicates */
  randomizeWithinGroupSort?: InputMaybe<Scalars['Boolean']>;
  randomizeWithinGroupSortNEQ?: InputMaybe<Scalars['Boolean']>;
  /** rotation_interval_hours field predicates */
  rotationIntervalHours?: InputMaybe<Scalars['Int']>;
  rotationIntervalHoursGT?: InputMaybe<Scalars['Int']>;
  rotationIntervalHoursGTE?: InputMaybe<Scalars['Int']>;
  rotationIntervalHoursIn?: InputMaybe<Array<Scalars['Int']>>;
  rotationIntervalHoursLT?: InputMaybe<Scalars['Int']>;
  rotationIntervalHoursLTE?: InputMaybe<Scalars['Int']>;
  rotationIntervalHoursNEQ?: InputMaybe<Scalars['Int']>;
  rotationIntervalHoursNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/** An edge in a connection. */
export type HypothesisTestEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<HypothesisTest>;
};

/**
 * HypothesisTestWhereInput is used for filtering HypothesisTest objects.
 * Input was generated by ent.
 */
export type HypothesisTestWhereInput = {
  /** active field predicates */
  active?: InputMaybe<Scalars['Boolean']>;
  activeNEQ?: InputMaybe<Scalars['Boolean']>;
  and?: InputMaybe<Array<HypothesisTestWhereInput>>;
  /** connection edge predicates */
  hasConnection?: InputMaybe<Scalars['Boolean']>;
  hasConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** hypothesis_test_delivery_option edge predicates */
  hasHypothesisTestDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasHypothesisTestDeliveryOptionWith?: InputMaybe<Array<HypothesisTestDeliveryOptionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<HypothesisTestWhereInput>;
  or?: InputMaybe<Array<HypothesisTestWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type InventoryItem = Node & {
  /** Used when country specific code not available */
  code?: Maybe<Scalars['String']>;
  /** Takes precedent over general HS code */
  countryHarmonizedCode?: Maybe<Array<CountryHarmonizedCode>>;
  /** Can be null in Shopify */
  countryOfOrigin?: Maybe<Country>;
  externalID?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  productVariant: ProductVariant;
  /** Duplicated to match Shopify InventoryItem/ProductVariant */
  sku?: Maybe<Scalars['String']>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type InventoryItemConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<InventoryItemEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type InventoryItemEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<InventoryItem>;
};

/**
 * InventoryItemWhereInput is used for filtering InventoryItem objects.
 * Input was generated by ent.
 */
export type InventoryItemWhereInput = {
  and?: InputMaybe<Array<InventoryItemWhereInput>>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']>;
  codeContains?: InputMaybe<Scalars['String']>;
  codeContainsFold?: InputMaybe<Scalars['String']>;
  codeEqualFold?: InputMaybe<Scalars['String']>;
  codeGT?: InputMaybe<Scalars['String']>;
  codeGTE?: InputMaybe<Scalars['String']>;
  codeHasPrefix?: InputMaybe<Scalars['String']>;
  codeHasSuffix?: InputMaybe<Scalars['String']>;
  codeIn?: InputMaybe<Array<Scalars['String']>>;
  codeIsNil?: InputMaybe<Scalars['Boolean']>;
  codeLT?: InputMaybe<Scalars['String']>;
  codeLTE?: InputMaybe<Scalars['String']>;
  codeNEQ?: InputMaybe<Scalars['String']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']>>;
  codeNotNil?: InputMaybe<Scalars['Boolean']>;
  /** external_ID field predicates */
  externalID?: InputMaybe<Scalars['String']>;
  externalIDContains?: InputMaybe<Scalars['String']>;
  externalIDContainsFold?: InputMaybe<Scalars['String']>;
  externalIDEqualFold?: InputMaybe<Scalars['String']>;
  externalIDGT?: InputMaybe<Scalars['String']>;
  externalIDGTE?: InputMaybe<Scalars['String']>;
  externalIDHasPrefix?: InputMaybe<Scalars['String']>;
  externalIDHasSuffix?: InputMaybe<Scalars['String']>;
  externalIDIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDIsNil?: InputMaybe<Scalars['Boolean']>;
  externalIDLT?: InputMaybe<Scalars['String']>;
  externalIDLTE?: InputMaybe<Scalars['String']>;
  externalIDNEQ?: InputMaybe<Scalars['String']>;
  externalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** country_harmonized_code edge predicates */
  hasCountryHarmonizedCode?: InputMaybe<Scalars['Boolean']>;
  hasCountryHarmonizedCodeWith?: InputMaybe<Array<CountryHarmonizedCodeWhereInput>>;
  /** country_of_origin edge predicates */
  hasCountryOfOrigin?: InputMaybe<Scalars['Boolean']>;
  hasCountryOfOriginWith?: InputMaybe<Array<CountryWhereInput>>;
  /** product_variant edge predicates */
  hasProductVariant?: InputMaybe<Scalars['Boolean']>;
  hasProductVariantWith?: InputMaybe<Array<ProductVariantWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<InventoryItemWhereInput>;
  or?: InputMaybe<Array<InventoryItemWhereInput>>;
  /** sku field predicates */
  sku?: InputMaybe<Scalars['String']>;
  skuContains?: InputMaybe<Scalars['String']>;
  skuContainsFold?: InputMaybe<Scalars['String']>;
  skuEqualFold?: InputMaybe<Scalars['String']>;
  skuGT?: InputMaybe<Scalars['String']>;
  skuGTE?: InputMaybe<Scalars['String']>;
  skuHasPrefix?: InputMaybe<Scalars['String']>;
  skuHasSuffix?: InputMaybe<Scalars['String']>;
  skuIn?: InputMaybe<Array<Scalars['String']>>;
  skuIsNil?: InputMaybe<Scalars['Boolean']>;
  skuLT?: InputMaybe<Scalars['String']>;
  skuLTE?: InputMaybe<Scalars['String']>;
  skuNEQ?: InputMaybe<Scalars['String']>;
  skuNotIn?: InputMaybe<Array<Scalars['String']>>;
  skuNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type Language = Node & {
  id: Scalars['ID'];
  internalID: LanguageInternalId;
  label: Scalars['String'];
  language?: Maybe<Array<Tenant>>;
  users?: Maybe<Array<User>>;
};

/** A connection to a list of items. */
export type LanguageConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LanguageEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type LanguageEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Language>;
};

/** LanguageInternalID is enum for the field internal_id */
export enum LanguageInternalId {
  Da = 'DA',
  En = 'EN'
}

/**
 * LanguageWhereInput is used for filtering Language objects.
 * Input was generated by ent.
 */
export type LanguageWhereInput = {
  and?: InputMaybe<Array<LanguageWhereInput>>;
  /** language edge predicates */
  hasLanguage?: InputMaybe<Scalars['Boolean']>;
  hasLanguageWith?: InputMaybe<Array<TenantWhereInput>>;
  /** users edge predicates */
  hasUsers?: InputMaybe<Scalars['Boolean']>;
  hasUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_id field predicates */
  internalID?: InputMaybe<LanguageInternalId>;
  internalIDIn?: InputMaybe<Array<LanguageInternalId>>;
  internalIDNEQ?: InputMaybe<LanguageInternalId>;
  internalIDNotIn?: InputMaybe<Array<LanguageInternalId>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<LanguageWhereInput>;
  or?: InputMaybe<Array<LanguageWhereInput>>;
};

export type Location = Node & {
  address: Address;
  colli?: Maybe<Array<Colli>>;
  deliveryOption?: Maybe<Array<DeliveryOption>>;
  id: Scalars['ID'];
  locationTags: Array<LocationTag>;
  /** Location name, not used in the address */
  name: Scalars['String'];
  pickupConnection?: Maybe<Array<Connection>>;
  returnConnection?: Maybe<Array<Connection>>;
  returnPortal?: Maybe<Array<ReturnPortal>>;
  sellerConnection?: Maybe<Array<Connection>>;
  senderConnection?: Maybe<Array<Connection>>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type LocationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LocationEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type LocationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Location>;
};

export type LocationTag = Node & {
  id: Scalars['ID'];
  internalID: Scalars['String'];
  label: Scalars['String'];
  location?: Maybe<Array<Location>>;
};

/** A connection to a list of items. */
export type LocationTagConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<LocationTagEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type LocationTagEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<LocationTag>;
};

/**
 * LocationTagWhereInput is used for filtering LocationTag objects.
 * Input was generated by ent.
 */
export type LocationTagWhereInput = {
  and?: InputMaybe<Array<LocationTagWhereInput>>;
  /** location edge predicates */
  hasLocation?: InputMaybe<Scalars['Boolean']>;
  hasLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** internal_id field predicates */
  internalID?: InputMaybe<Scalars['String']>;
  internalIDContains?: InputMaybe<Scalars['String']>;
  internalIDContainsFold?: InputMaybe<Scalars['String']>;
  internalIDEqualFold?: InputMaybe<Scalars['String']>;
  internalIDGT?: InputMaybe<Scalars['String']>;
  internalIDGTE?: InputMaybe<Scalars['String']>;
  internalIDHasPrefix?: InputMaybe<Scalars['String']>;
  internalIDHasSuffix?: InputMaybe<Scalars['String']>;
  internalIDIn?: InputMaybe<Array<Scalars['String']>>;
  internalIDLT?: InputMaybe<Scalars['String']>;
  internalIDLTE?: InputMaybe<Scalars['String']>;
  internalIDNEQ?: InputMaybe<Scalars['String']>;
  internalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<LocationTagWhereInput>;
  or?: InputMaybe<Array<LocationTagWhereInput>>;
};

/**
 * LocationWhereInput is used for filtering Location objects.
 * Input was generated by ent.
 */
export type LocationWhereInput = {
  and?: InputMaybe<Array<LocationWhereInput>>;
  /** address edge predicates */
  hasAddress?: InputMaybe<Scalars['Boolean']>;
  hasAddressWith?: InputMaybe<Array<AddressWhereInput>>;
  /** colli edge predicates */
  hasColli?: InputMaybe<Scalars['Boolean']>;
  hasColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** location_tags edge predicates */
  hasLocationTags?: InputMaybe<Scalars['Boolean']>;
  hasLocationTagsWith?: InputMaybe<Array<LocationTagWhereInput>>;
  /** pickup_connection edge predicates */
  hasPickupConnection?: InputMaybe<Scalars['Boolean']>;
  hasPickupConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** return_connection edge predicates */
  hasReturnConnection?: InputMaybe<Scalars['Boolean']>;
  hasReturnConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** return_portal edge predicates */
  hasReturnPortal?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalWith?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** seller_connection edge predicates */
  hasSellerConnection?: InputMaybe<Scalars['Boolean']>;
  hasSellerConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** sender_connection edge predicates */
  hasSenderConnection?: InputMaybe<Scalars['Boolean']>;
  hasSenderConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<LocationWhereInput>;
  or?: InputMaybe<Array<LocationWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type MutateReturnDeliveryOption = {
  deliveryOptionID: Scalars['ID'];
  returnColliID: Scalars['ID'];
};

export type MutateReturnItems = {
  claimID: Scalars['ID'];
  orderLineID: Scalars['ID'];
  units: Scalars['Int'];
};

export type MutateReturnPortalClaim = {
  id: Scalars['ID'];
  input: CreateReturnPortalClaimInput;
};

export type Mutation = {
  archivePackaging: Scalars['Boolean'];
  archiveProductVariant: Product;
  archiveWorkstation: Scalars['Boolean'];
  bulkUpdatePackaging: BulkUpdateMessage;
  cancelCancelSync: Scalars['Boolean'];
  cancelFulfillmentSync: Scalars['Boolean'];
  cancelShipment: Shipment;
  cancelShipmentByColliIDs: Scalars['Boolean'];
  createAPIToken: CreateApiTokenSuccess;
  createCarrierAgreement: CreateCarrierAgreementSuccess;
  createColli: Order;
  createConsolidation: Consolidation;
  createDeliveryOption: CreateDeliveryOptionSuccess;
  createDeliveryRule: DeliveryRule;
  createDeliveryRuleConstraintGroup: DeliveryRuleConstraintGroup;
  createDeliveryRuleConstraintGroupConstraints?: Maybe<Array<DeliveryRuleConstraintWithTags>>;
  createDocument: Scalars['ID'];
  createEmailTemplates: Scalars['ID'];
  createEmptyOrder?: Maybe<Order>;
  createHypothesisTestDeliveryOption: Scalars['ID'];
  createLocation?: Maybe<Location>;
  createNotification: Array<Notification>;
  createPackaging: Array<Packaging>;
  createProduct?: Maybe<Product>;
  createProductTags?: Maybe<Array<Maybe<ProductTag>>>;
  createReturnOrder: Array<Scalars['ID']>;
  createReturnPortal: Scalars['ID'];
  createSeatGroup?: Maybe<SeatGroup>;
  createShopifyConnection?: Maybe<ConnectionShopify>;
  createUserSeat?: Maybe<User>;
  createVariant: ProductVariant;
  createWorkstation?: Maybe<CreateWorkstationSuccess>;
  debugUpdateLabelIDs: Scalars['Boolean'];
  deleteAPIToken: Array<ApiToken>;
  deleteColli: Order;
  deleteDeliveryRule: Array<Maybe<DeliveryRule>>;
  deleteDeliveryRuleConstraintGroupConstraints: Array<Maybe<DeliveryRule>>;
  deleteProductImage: Product;
  deleteTag?: Maybe<Array<Maybe<ProductTag>>>;
  deliveryOptionArchive: Scalars['Boolean'];
  duplicateColli: Order;
  markColliDeleted: Scalars['Boolean'];
  moveOrderLine?: Maybe<Array<Colli>>;
  mustInventory: InventoryItem;
  replaceDeliveryRuleConstraintGroupConstraints?: Maybe<Array<DeliveryRuleConstraintWithTags>>;
  replaceDeliveryRuleCountries: DeliveryRule;
  replaceInterestedCarriersPlatforms?: Maybe<User>;
  replaceSeatGroup?: Maybe<SeatGroup>;
  replaceSignupOptions?: Maybe<SignupOptions>;
  saveSelectedWorkstation: Scalars['Boolean'];
  toggleNotification: Scalars['Boolean'];
  updateAPIToken: Scalars['Boolean'];
  updateCarrierAgreementBring: Carrier;
  updateCarrierAgreementDAO: Carrier;
  updateCarrierAgreementDF: Carrier;
  updateCarrierAgreementDSV: Carrier;
  updateCarrierAgreementEasyPost: Carrier;
  updateCarrierAgreementGLS: CarrierGls;
  updateCarrierAgreementPostNord: CarrierPostNord;
  updateCarrierAgreementUSPS: CarrierUsps;
  updateColli?: Maybe<Colli>;
  updateCompanyInfo?: Maybe<Tenant>;
  updateConsolidation: Consolidation;
  updateDeliveryOptionBring: DeliveryOptionBring;
  updateDeliveryOptionDAO: DeliveryOptionDao;
  updateDeliveryOptionDF: DeliveryOptionDf;
  updateDeliveryOptionDSV: DeliveryOptionDsv;
  updateDeliveryOptionEasyPost: DeliveryOptionEasyPost;
  updateDeliveryOptionGLS: DeliveryOptionGls;
  updateDeliveryOptionPostNord: DeliveryOptionPostNord;
  updateDeliveryOptionSortOrder: Array<DeliveryOption>;
  updateDeliveryOptionUSPS: DeliveryOptionUsps;
  updateDeliveryRule: DeliveryRule;
  updateDocument: Document;
  updateEmailTemplate: EmailTemplate;
  updateHypothesisTestDeliveryOption: HypothesisTest;
  updateInventory: InventoryItem;
  updateLocation?: Maybe<Location>;
  updateOrder?: Maybe<Order>;
  updatePackaging: Array<Packaging>;
  updatePlan?: Maybe<Tenant>;
  updateProduct?: Maybe<Product>;
  updateReturnColliStatus: ReturnColliEdit;
  updateReturnPortal: ReturnPortal;
  updateShopifyConnection?: Maybe<ConnectionShopify>;
  updateUser?: Maybe<User>;
  updateUserPassword?: Maybe<User>;
  updateUserSeat?: Maybe<User>;
  updateWorkstation?: Maybe<Workstation>;
  uploadProductImage: Product;
};


export type MutationArchivePackagingArgs = {
  id: Scalars['ID'];
};


export type MutationArchiveProductVariantArgs = {
  variantID: Scalars['ID'];
};


export type MutationArchiveWorkstationArgs = {
  id: Scalars['ID'];
};


export type MutationBulkUpdatePackagingArgs = {
  orderIDs: Array<Scalars['ID']>;
  packagingID?: InputMaybe<Scalars['ID']>;
};


export type MutationCancelCancelSyncArgs = {
  shipmentParcelID: Scalars['ID'];
};


export type MutationCancelFulfillmentSyncArgs = {
  shipmentParcelID: Scalars['ID'];
};


export type MutationCancelShipmentArgs = {
  shipmentID: Scalars['ID'];
};


export type MutationCancelShipmentByColliIDsArgs = {
  colliIDs: Array<Scalars['ID']>;
};


export type MutationCreateApiTokenArgs = {
  name: Scalars['String'];
};


export type MutationCreateCarrierAgreementArgs = {
  carrierBrand: Scalars['ID'];
  name: Scalars['String'];
};


export type MutationCreateColliArgs = {
  ccLocationID?: InputMaybe<Scalars['ID']>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  deliveryPointID?: InputMaybe<Scalars['ID']>;
  input: CreateColliInput;
  orderID: Scalars['ID'];
  packagingID?: InputMaybe<Scalars['ID']>;
  products: Array<ProductVariantQuantity>;
  recipientAddress: CreateAddressInput;
  senderAddress: CreateAddressInput;
};


export type MutationCreateConsolidationArgs = {
  description: Scalars['String'];
  publicID: Scalars['String'];
};


export type MutationCreateDeliveryOptionArgs = {
  agreementID: Scalars['ID'];
  connectionID: Scalars['ID'];
  name: Scalars['String'];
};


export type MutationCreateDeliveryRuleArgs = {
  input: CreateDeliveryRuleInput;
};


export type MutationCreateDeliveryRuleConstraintGroupArgs = {
  input: CreateDeliveryRuleConstraintGroupInput;
};


export type MutationCreateDeliveryRuleConstraintGroupConstraintsArgs = {
  deliveryRuleId: Scalars['ID'];
  input?: InputMaybe<Array<InputMaybe<CreateDeliveryRuleConstraintInput>>>;
  logicType: DeliveryRuleConstraintGroupConstraintLogic;
};


export type MutationCreateDocumentArgs = {
  mergeType: DocumentMergeType;
  name: Scalars['String'];
};


export type MutationCreateEmailTemplatesArgs = {
  merge: EmailTemplateMergeType;
  name: Scalars['String'];
};


export type MutationCreateEmptyOrderArgs = {
  input: CreateOrderInput;
};


export type MutationCreateHypothesisTestDeliveryOptionArgs = {
  connectionID: Scalars['ID'];
  name: Scalars['String'];
};


export type MutationCreateLocationArgs = {
  input: CreateLocationInput;
  inputAddress: CreateAddressInput;
};


export type MutationCreateNotificationArgs = {
  connectionID: Scalars['ID'];
  emailTemplateID: Scalars['ID'];
  name: Scalars['String'];
};


export type MutationCreatePackagingArgs = {
  input: CreatePackagingInput;
  inputPackagingDF?: InputMaybe<CreatePackagingDfInput>;
  inputPackagingUSPS?: InputMaybe<CreatePackagingUspsInput>;
};


export type MutationCreateProductArgs = {
  images?: InputMaybe<Array<Scalars['String']>>;
  input: CreateProductInput;
  variants?: InputMaybe<Array<CreateProductVariantInput>>;
};


export type MutationCreateProductTagsArgs = {
  input?: InputMaybe<Array<Scalars['String']>>;
};


export type MutationCreateReturnOrderArgs = {
  orderID: Scalars['ID'];
  orderLines: Array<MutateReturnItems>;
  portalID: Scalars['ID'];
};


export type MutationCreateReturnPortalArgs = {
  connection: Scalars['ID'];
  name: Scalars['String'];
};


export type MutationCreateSeatGroupArgs = {
  accessRights?: InputMaybe<Array<CreateSeatGroupAccessRightInput>>;
  input: CreateSeatGroupInput;
};


export type MutationCreateShopifyConnectionArgs = {
  input: CreateConnectionShopifyInput;
  inputConnection: CreateConnectionInput;
};


export type MutationCreateUserSeatArgs = {
  input: CreateUserInput;
};


export type MutationCreateVariantArgs = {
  input?: InputMaybe<CreateProductVariantInput>;
  productID: Scalars['ID'];
};


export type MutationCreateWorkstationArgs = {
  input: CreateWorkstationInput;
};


export type MutationDebugUpdateLabelIDsArgs = {
  itemID: Scalars['String'];
  parcelID: Scalars['ID'];
};


export type MutationDeleteApiTokenArgs = {
  id: Scalars['ID'];
};


export type MutationDeleteColliArgs = {
  colliID: Scalars['ID'];
};


export type MutationDeleteDeliveryRuleArgs = {
  deliveryRuleID: Scalars['ID'];
};


export type MutationDeleteDeliveryRuleConstraintGroupConstraintsArgs = {
  deliveryGroupId: Scalars['ID'];
};


export type MutationDeleteProductImageArgs = {
  imageID: Scalars['ID'];
};


export type MutationDeleteTagArgs = {
  id: Scalars['ID'];
};


export type MutationDeliveryOptionArchiveArgs = {
  deliveryOptionID: Scalars['ID'];
};


export type MutationDuplicateColliArgs = {
  fromColliID: Scalars['ID'];
};


export type MutationMarkColliDeletedArgs = {
  returnColliID: Scalars['ID'];
};


export type MutationMoveOrderLineArgs = {
  colliID: Scalars['ID'];
  orderLineID: Scalars['ID'];
};


export type MutationMustInventoryArgs = {
  productVariantID: Scalars['ID'];
};


export type MutationReplaceDeliveryRuleConstraintGroupConstraintsArgs = {
  deliveryGroupId: Scalars['ID'];
  input?: InputMaybe<Array<InputMaybe<CreateDeliveryRuleConstraintInput>>>;
  logicType: DeliveryRuleConstraintGroupConstraintLogic;
};


export type MutationReplaceDeliveryRuleCountriesArgs = {
  countries: Array<Scalars['ID']>;
  ruleID: Scalars['ID'];
};


export type MutationReplaceInterestedCarriersPlatformsArgs = {
  inputCarriers: Array<Scalars['ID']>;
  inputPlatforms: Array<Scalars['ID']>;
  userID: Scalars['ID'];
};


export type MutationReplaceSeatGroupArgs = {
  accessRights?: InputMaybe<Array<CreateSeatGroupAccessRightInput>>;
  id: Scalars['ID'];
  input: UpdateSeatGroupInput;
};


export type MutationReplaceSignupOptionsArgs = {
  input: CreateSignupOptionsInput;
  userID: Scalars['ID'];
};


export type MutationSaveSelectedWorkstationArgs = {
  id: Scalars['ID'];
  pickupDay: UserPickupDay;
};


export type MutationToggleNotificationArgs = {
  checked: Scalars['Boolean'];
  notificationID: Scalars['ID'];
};


export type MutationUpdateApiTokenArgs = {
  id: Scalars['ID'];
  name: Scalars['String'];
};


export type MutationUpdateCarrierAgreementBringArgs = {
  id: Scalars['ID'];
  input: UpdateCarrierBringInput;
  name: Scalars['String'];
};


export type MutationUpdateCarrierAgreementDaoArgs = {
  id: Scalars['ID'];
  input: UpdateCarrierDaoInput;
  name: Scalars['String'];
};


export type MutationUpdateCarrierAgreementDfArgs = {
  id: Scalars['ID'];
  input: UpdateCarrierDfInput;
  name: Scalars['String'];
};


export type MutationUpdateCarrierAgreementDsvArgs = {
  id: Scalars['ID'];
  input: UpdateCarrierDsvInput;
  name: Scalars['String'];
};


export type MutationUpdateCarrierAgreementEasyPostArgs = {
  id: Scalars['ID'];
  input: UpdateCarrierEasyPostInput;
  name: Scalars['String'];
};


export type MutationUpdateCarrierAgreementGlsArgs = {
  id: Scalars['ID'];
  input: UpdateCarrierGlsInput;
  name: Scalars['String'];
};


export type MutationUpdateCarrierAgreementPostNordArgs = {
  id: Scalars['ID'];
  input: UpdateCarrierPostNordInput;
  name: Scalars['String'];
};


export type MutationUpdateCarrierAgreementUspsArgs = {
  id: Scalars['ID'];
  input: UpdateCarrierUspsInput;
  name: Scalars['String'];
};


export type MutationUpdateColliArgs = {
  ccLocationID?: InputMaybe<Scalars['ID']>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  deliveryPointID?: InputMaybe<Scalars['ID']>;
  id: Scalars['ID'];
  input: UpdateColliInput;
  packagingID?: InputMaybe<Scalars['ID']>;
  products: Array<ProductVariantQuantity>;
  recipientAddress: UpdateAddressInput;
  recipientAddressID: Scalars['ID'];
  removeProducts: Array<Scalars['ID']>;
  senderAddress: UpdateAddressInput;
  senderAddressID: Scalars['ID'];
  updateExistingRecipient?: InputMaybe<Scalars['Boolean']>;
};


export type MutationUpdateCompanyInfoArgs = {
  address: CreateAddressInput;
  adminContact: CreateContactInput;
  billingContact: CreateContactInput;
  defaultLanguage: Scalars['ID'];
  input: UpdateTenantInput;
};


export type MutationUpdateConsolidationArgs = {
  id: Scalars['ID'];
  input: UpdateConsolidationInput;
  inputPallets: Array<CreateOrUpdatePallet>;
  recipient?: InputMaybe<CreateAddressInput>;
  sender?: InputMaybe<CreateAddressInput>;
};


export type MutationUpdateDeliveryOptionBringArgs = {
  id: Scalars['ID'];
  input: UpdateDeliveryOptionBringInput;
  inputDeliveryOption: UpdateDeliveryOptionInput;
};


export type MutationUpdateDeliveryOptionDaoArgs = {
  id: Scalars['ID'];
  inputDeliveryOption: UpdateDeliveryOptionInput;
};


export type MutationUpdateDeliveryOptionDfArgs = {
  id: Scalars['ID'];
  inputDeliveryOption: UpdateDeliveryOptionInput;
};


export type MutationUpdateDeliveryOptionDsvArgs = {
  id: Scalars['ID'];
  inputDeliveryOption: UpdateDeliveryOptionInput;
};


export type MutationUpdateDeliveryOptionEasyPostArgs = {
  id: Scalars['ID'];
  input: UpdateDeliveryOptionEasyPostInput;
  inputDeliveryOption: UpdateDeliveryOptionInput;
};


export type MutationUpdateDeliveryOptionGlsArgs = {
  id: Scalars['ID'];
  inputDeliveryOption: UpdateDeliveryOptionInput;
};


export type MutationUpdateDeliveryOptionPostNordArgs = {
  id: Scalars['ID'];
  input: UpdateDeliveryOptionPostNordInput;
  inputAdditionalServices: Array<Scalars['String']>;
  inputDeliveryOption: UpdateDeliveryOptionInput;
};


export type MutationUpdateDeliveryOptionSortOrderArgs = {
  newOrder: Array<Scalars['ID']>;
};


export type MutationUpdateDeliveryOptionUspsArgs = {
  id: Scalars['ID'];
  input: UpdateDeliveryOptionUspsInput;
  inputAdditionalServices: Array<Scalars['ID']>;
  inputDeliveryOption: UpdateDeliveryOptionInput;
};


export type MutationUpdateDeliveryRuleArgs = {
  deliveryRuleID: Scalars['ID'];
  val: UpdateDeliveryRuleInput;
};


export type MutationUpdateDocumentArgs = {
  id: Scalars['ID'];
  input: UpdateDocumentInput;
};


export type MutationUpdateEmailTemplateArgs = {
  id: Scalars['ID'];
  input: UpdateEmailTemplateInput;
};


export type MutationUpdateHypothesisTestDeliveryOptionArgs = {
  id: Scalars['ID'];
  input: UpdateHypothesisTestInput;
  inputDeliveryOption: UpdateHypothesisTestDeliveryOptionInput;
};


export type MutationUpdateInventoryArgs = {
  input: UpdateInventoryItemInput;
  iventoryItemID: Scalars['ID'];
};


export type MutationUpdateLocationArgs = {
  id: Scalars['ID'];
  input: UpdateLocationInput;
  inputAddress: UpdateAddressInput;
};


export type MutationUpdateOrderArgs = {
  id: Scalars['ID'];
  input: UpdateOrderInput;
};


export type MutationUpdatePackagingArgs = {
  input: UpdatePackagingInput;
  inputPackagingDF?: InputMaybe<CreatePackagingDfInput>;
  inputPackagingUSPS?: InputMaybe<UpdatePackagingUspsInput>;
};


export type MutationUpdatePlanArgs = {
  planID: Scalars['ID'];
};


export type MutationUpdateProductArgs = {
  id: Scalars['ID'];
  images?: InputMaybe<Array<ProductVariantImageInput>>;
  input: UpdateProductInput;
  variants?: InputMaybe<Array<UpdateProductVariantIdInput>>;
};


export type MutationUpdateReturnColliStatusArgs = {
  returnColliID: Scalars['ID'];
  status: ReturnColliStatus;
};


export type MutationUpdateReturnPortalArgs = {
  id: Scalars['ID'];
  input: UpdateReturnPortalInput;
  inputClaims: Array<MutateReturnPortalClaim>;
};


export type MutationUpdateShopifyConnectionArgs = {
  id: Scalars['ID'];
  input: UpdateConnectionShopifyInput;
  inputConnection: UpdateConnectionInput;
};


export type MutationUpdateUserArgs = {
  input: UpdateUserInput;
  newTenantID?: InputMaybe<Scalars['ID']>;
};


export type MutationUpdateUserPasswordArgs = {
  id: Scalars['ID'];
  input: Scalars['String'];
};


export type MutationUpdateUserSeatArgs = {
  id: Scalars['ID'];
  input: UpdateUserInput;
};


export type MutationUpdateWorkstationArgs = {
  id: Scalars['ID'];
  input: UpdateWorkstationInput;
};


export type MutationUploadProductImageArgs = {
  image: Scalars['String'];
  productID: Scalars['ID'];
};

/**
 * An object with an ID.
 * Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
 */
export type Node = {
  /** The id of the object. */
  id: Scalars['ID'];
};

export type Notification = Node & {
  active: Scalars['Boolean'];
  connection: Connection;
  emailTemplate: EmailTemplate;
  id: Scalars['ID'];
  name: Scalars['String'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type NotificationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<NotificationEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type NotificationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Notification>;
};

/**
 * NotificationWhereInput is used for filtering Notification objects.
 * Input was generated by ent.
 */
export type NotificationWhereInput = {
  /** active field predicates */
  active?: InputMaybe<Scalars['Boolean']>;
  activeNEQ?: InputMaybe<Scalars['Boolean']>;
  and?: InputMaybe<Array<NotificationWhereInput>>;
  /** connection edge predicates */
  hasConnection?: InputMaybe<Scalars['Boolean']>;
  hasConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** email_template edge predicates */
  hasEmailTemplate?: InputMaybe<Scalars['Boolean']>;
  hasEmailTemplateWith?: InputMaybe<Array<EmailTemplateWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<NotificationWhereInput>;
  or?: InputMaybe<Array<NotificationWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type OtkRequests = Node & {
  id: Scalars['ID'];
  otk: Scalars['String'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
  users?: Maybe<User>;
};

/**
 * OTKRequestsWhereInput is used for filtering OTKRequests objects.
 * Input was generated by ent.
 */
export type OtkRequestsWhereInput = {
  and?: InputMaybe<Array<OtkRequestsWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** users edge predicates */
  hasUsers?: InputMaybe<Scalars['Boolean']>;
  hasUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<OtkRequestsWhereInput>;
  or?: InputMaybe<Array<OtkRequestsWhereInput>>;
  /** otk field predicates */
  otk?: InputMaybe<Scalars['String']>;
  otkContains?: InputMaybe<Scalars['String']>;
  otkContainsFold?: InputMaybe<Scalars['String']>;
  otkEqualFold?: InputMaybe<Scalars['String']>;
  otkGT?: InputMaybe<Scalars['String']>;
  otkGTE?: InputMaybe<Scalars['String']>;
  otkHasPrefix?: InputMaybe<Scalars['String']>;
  otkHasSuffix?: InputMaybe<Scalars['String']>;
  otkIn?: InputMaybe<Array<Scalars['String']>>;
  otkLT?: InputMaybe<Scalars['String']>;
  otkLTE?: InputMaybe<Scalars['String']>;
  otkNEQ?: InputMaybe<Scalars['String']>;
  otkNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type Order = Node & {
  colli?: Maybe<Array<Colli>>;
  commentExternal?: Maybe<Scalars['String']>;
  commentInternal?: Maybe<Scalars['String']>;
  connection: Connection;
  /** Orders may be added to consolidation either through a pallet or directly */
  consolidation?: Maybe<Consolidation>;
  createdAt: Scalars['Time'];
  emailSyncConfirmationAt?: Maybe<Scalars['Time']>;
  externalID?: Maybe<Scalars['String']>;
  hypothesisTestDeliveryOptionRequest?: Maybe<HypothesisTestDeliveryOptionRequest>;
  id: Scalars['ID'];
  orderHistory?: Maybe<Array<OrderHistory>>;
  orderPublicID: Scalars['String'];
  /** Orders may be added to consolidation either through a pallet or directly */
  pallet?: Maybe<Pallet>;
  returnColli?: Maybe<Array<ReturnColli>>;
  status: OrderStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type OrderConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrderEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** Possible directions in which to order a list of items when provided an `orderBy` argument. */
export enum OrderDirection {
  /** Specifies an ascending order for a given `orderBy` argument. */
  Asc = 'ASC',
  /** Specifies a descending order for a given `orderBy` argument. */
  Desc = 'DESC'
}

/** An edge in a connection. */
export type OrderEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Order>;
};

export type OrderHistory = Node & {
  changeHistory: ChangeHistory;
  description: Scalars['String'];
  id: Scalars['ID'];
  order: Order;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  type: OrderHistoryType;
};

/** OrderHistoryType is enum for the field type */
export enum OrderHistoryType {
  Create = 'create',
  Delete = 'delete',
  Notify = 'notify',
  Update = 'update'
}

/**
 * OrderHistoryWhereInput is used for filtering OrderHistory objects.
 * Input was generated by ent.
 */
export type OrderHistoryWhereInput = {
  and?: InputMaybe<Array<OrderHistoryWhereInput>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** change_history edge predicates */
  hasChangeHistory?: InputMaybe<Scalars['Boolean']>;
  hasChangeHistoryWith?: InputMaybe<Array<ChangeHistoryWhereInput>>;
  /** order edge predicates */
  hasOrder?: InputMaybe<Scalars['Boolean']>;
  hasOrderWith?: InputMaybe<Array<OrderWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<OrderHistoryWhereInput>;
  or?: InputMaybe<Array<OrderHistoryWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** type field predicates */
  type?: InputMaybe<OrderHistoryType>;
  typeIn?: InputMaybe<Array<OrderHistoryType>>;
  typeNEQ?: InputMaybe<OrderHistoryType>;
  typeNotIn?: InputMaybe<Array<OrderHistoryType>>;
};

export type OrderLine = Node & {
  colli: Colli;
  colliID: Scalars['ID'];
  createdAt?: Maybe<Scalars['Time']>;
  currency: Currency;
  /** Amount removed from unit_price*units for customs docs */
  discountAllocationAmount: Scalars['Float'];
  externalID?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  productVariant: ProductVariant;
  productVariantID: Scalars['ID'];
  returnOrderLine?: Maybe<Array<ReturnOrderLine>>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  unitPrice: Scalars['Float'];
  units: Scalars['Int'];
  updatedAt: Scalars['Time'];
};

/**
 * OrderLineWhereInput is used for filtering OrderLine objects.
 * Input was generated by ent.
 */
export type OrderLineWhereInput = {
  and?: InputMaybe<Array<OrderLineWhereInput>>;
  /** colli_id field predicates */
  colliID?: InputMaybe<Scalars['ID']>;
  colliIDContains?: InputMaybe<Scalars['ID']>;
  colliIDContainsFold?: InputMaybe<Scalars['ID']>;
  colliIDEqualFold?: InputMaybe<Scalars['ID']>;
  colliIDGT?: InputMaybe<Scalars['ID']>;
  colliIDGTE?: InputMaybe<Scalars['ID']>;
  colliIDHasPrefix?: InputMaybe<Scalars['ID']>;
  colliIDHasSuffix?: InputMaybe<Scalars['ID']>;
  colliIDIn?: InputMaybe<Array<Scalars['ID']>>;
  colliIDLT?: InputMaybe<Scalars['ID']>;
  colliIDLTE?: InputMaybe<Scalars['ID']>;
  colliIDNEQ?: InputMaybe<Scalars['ID']>;
  colliIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** discount_allocation_amount field predicates */
  discountAllocationAmount?: InputMaybe<Scalars['Float']>;
  discountAllocationAmountGT?: InputMaybe<Scalars['Float']>;
  discountAllocationAmountGTE?: InputMaybe<Scalars['Float']>;
  discountAllocationAmountIn?: InputMaybe<Array<Scalars['Float']>>;
  discountAllocationAmountLT?: InputMaybe<Scalars['Float']>;
  discountAllocationAmountLTE?: InputMaybe<Scalars['Float']>;
  discountAllocationAmountNEQ?: InputMaybe<Scalars['Float']>;
  discountAllocationAmountNotIn?: InputMaybe<Array<Scalars['Float']>>;
  /** external_id field predicates */
  externalID?: InputMaybe<Scalars['String']>;
  externalIDContains?: InputMaybe<Scalars['String']>;
  externalIDContainsFold?: InputMaybe<Scalars['String']>;
  externalIDEqualFold?: InputMaybe<Scalars['String']>;
  externalIDGT?: InputMaybe<Scalars['String']>;
  externalIDGTE?: InputMaybe<Scalars['String']>;
  externalIDHasPrefix?: InputMaybe<Scalars['String']>;
  externalIDHasSuffix?: InputMaybe<Scalars['String']>;
  externalIDIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDIsNil?: InputMaybe<Scalars['Boolean']>;
  externalIDLT?: InputMaybe<Scalars['String']>;
  externalIDLTE?: InputMaybe<Scalars['String']>;
  externalIDNEQ?: InputMaybe<Scalars['String']>;
  externalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** colli edge predicates */
  hasColli?: InputMaybe<Scalars['Boolean']>;
  hasColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** currency edge predicates */
  hasCurrency?: InputMaybe<Scalars['Boolean']>;
  hasCurrencyWith?: InputMaybe<Array<CurrencyWhereInput>>;
  /** product_variant edge predicates */
  hasProductVariant?: InputMaybe<Scalars['Boolean']>;
  hasProductVariantWith?: InputMaybe<Array<ProductVariantWhereInput>>;
  /** return_order_line edge predicates */
  hasReturnOrderLine?: InputMaybe<Scalars['Boolean']>;
  hasReturnOrderLineWith?: InputMaybe<Array<ReturnOrderLineWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<OrderLineWhereInput>;
  or?: InputMaybe<Array<OrderLineWhereInput>>;
  /** product_variant_id field predicates */
  productVariantID?: InputMaybe<Scalars['ID']>;
  productVariantIDContains?: InputMaybe<Scalars['ID']>;
  productVariantIDContainsFold?: InputMaybe<Scalars['ID']>;
  productVariantIDEqualFold?: InputMaybe<Scalars['ID']>;
  productVariantIDGT?: InputMaybe<Scalars['ID']>;
  productVariantIDGTE?: InputMaybe<Scalars['ID']>;
  productVariantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  productVariantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  productVariantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  productVariantIDLT?: InputMaybe<Scalars['ID']>;
  productVariantIDLTE?: InputMaybe<Scalars['ID']>;
  productVariantIDNEQ?: InputMaybe<Scalars['ID']>;
  productVariantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** unit_price field predicates */
  unitPrice?: InputMaybe<Scalars['Float']>;
  unitPriceGT?: InputMaybe<Scalars['Float']>;
  unitPriceGTE?: InputMaybe<Scalars['Float']>;
  unitPriceIn?: InputMaybe<Array<Scalars['Float']>>;
  unitPriceLT?: InputMaybe<Scalars['Float']>;
  unitPriceLTE?: InputMaybe<Scalars['Float']>;
  unitPriceNEQ?: InputMaybe<Scalars['Float']>;
  unitPriceNotIn?: InputMaybe<Array<Scalars['Float']>>;
  /** units field predicates */
  units?: InputMaybe<Scalars['Int']>;
  unitsGT?: InputMaybe<Scalars['Int']>;
  unitsGTE?: InputMaybe<Scalars['Int']>;
  unitsIn?: InputMaybe<Array<Scalars['Int']>>;
  unitsLT?: InputMaybe<Scalars['Int']>;
  unitsLTE?: InputMaybe<Scalars['Int']>;
  unitsNEQ?: InputMaybe<Scalars['Int']>;
  unitsNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

/** Ordering options for Order connections */
export type OrderOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Orders. */
  field: OrderOrderField;
};

/** Properties by which Order connections can be ordered. */
export enum OrderOrderField {
  CreatedAt = 'CREATED_AT'
}

export type OrderSender = Node & {
  email: Scalars['String'];
  firstName: Scalars['String'];
  id: Scalars['ID'];
  lastName: Scalars['String'];
  phoneNumber: Scalars['String'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
  vatNumber: Scalars['String'];
};

/** A connection to a list of items. */
export type OrderSenderConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<OrderSenderEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type OrderSenderEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<OrderSender>;
};

/**
 * OrderSenderWhereInput is used for filtering OrderSender objects.
 * Input was generated by ent.
 */
export type OrderSenderWhereInput = {
  and?: InputMaybe<Array<OrderSenderWhereInput>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** first_name field predicates */
  firstName?: InputMaybe<Scalars['String']>;
  firstNameContains?: InputMaybe<Scalars['String']>;
  firstNameContainsFold?: InputMaybe<Scalars['String']>;
  firstNameEqualFold?: InputMaybe<Scalars['String']>;
  firstNameGT?: InputMaybe<Scalars['String']>;
  firstNameGTE?: InputMaybe<Scalars['String']>;
  firstNameHasPrefix?: InputMaybe<Scalars['String']>;
  firstNameHasSuffix?: InputMaybe<Scalars['String']>;
  firstNameIn?: InputMaybe<Array<Scalars['String']>>;
  firstNameLT?: InputMaybe<Scalars['String']>;
  firstNameLTE?: InputMaybe<Scalars['String']>;
  firstNameNEQ?: InputMaybe<Scalars['String']>;
  firstNameNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** last_name field predicates */
  lastName?: InputMaybe<Scalars['String']>;
  lastNameContains?: InputMaybe<Scalars['String']>;
  lastNameContainsFold?: InputMaybe<Scalars['String']>;
  lastNameEqualFold?: InputMaybe<Scalars['String']>;
  lastNameGT?: InputMaybe<Scalars['String']>;
  lastNameGTE?: InputMaybe<Scalars['String']>;
  lastNameHasPrefix?: InputMaybe<Scalars['String']>;
  lastNameHasSuffix?: InputMaybe<Scalars['String']>;
  lastNameIn?: InputMaybe<Array<Scalars['String']>>;
  lastNameLT?: InputMaybe<Scalars['String']>;
  lastNameLTE?: InputMaybe<Scalars['String']>;
  lastNameNEQ?: InputMaybe<Scalars['String']>;
  lastNameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<OrderSenderWhereInput>;
  or?: InputMaybe<Array<OrderSenderWhereInput>>;
  /** phone_number field predicates */
  phoneNumber?: InputMaybe<Scalars['String']>;
  phoneNumberContains?: InputMaybe<Scalars['String']>;
  phoneNumberContainsFold?: InputMaybe<Scalars['String']>;
  phoneNumberEqualFold?: InputMaybe<Scalars['String']>;
  phoneNumberGT?: InputMaybe<Scalars['String']>;
  phoneNumberGTE?: InputMaybe<Scalars['String']>;
  phoneNumberHasPrefix?: InputMaybe<Scalars['String']>;
  phoneNumberHasSuffix?: InputMaybe<Scalars['String']>;
  phoneNumberIn?: InputMaybe<Array<Scalars['String']>>;
  phoneNumberLT?: InputMaybe<Scalars['String']>;
  phoneNumberLTE?: InputMaybe<Scalars['String']>;
  phoneNumberNEQ?: InputMaybe<Scalars['String']>;
  phoneNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** vat_number field predicates */
  vatNumber?: InputMaybe<Scalars['String']>;
  vatNumberContains?: InputMaybe<Scalars['String']>;
  vatNumberContainsFold?: InputMaybe<Scalars['String']>;
  vatNumberEqualFold?: InputMaybe<Scalars['String']>;
  vatNumberGT?: InputMaybe<Scalars['String']>;
  vatNumberGTE?: InputMaybe<Scalars['String']>;
  vatNumberHasPrefix?: InputMaybe<Scalars['String']>;
  vatNumberHasSuffix?: InputMaybe<Scalars['String']>;
  vatNumberIn?: InputMaybe<Array<Scalars['String']>>;
  vatNumberLT?: InputMaybe<Scalars['String']>;
  vatNumberLTE?: InputMaybe<Scalars['String']>;
  vatNumberNEQ?: InputMaybe<Scalars['String']>;
  vatNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
};

export type OrderShipmentStatus = {
  mayShipRemaining: Scalars['Boolean'];
  shipmentStatuses: Array<ParcelStatuses>;
};

/** OrderStatus is enum for the field status */
export enum OrderStatus {
  Cancelled = 'Cancelled',
  Dispatched = 'Dispatched',
  PartiallyDispatched = 'Partially_dispatched',
  Pending = 'Pending'
}

/**
 * OrderWhereInput is used for filtering Order objects.
 * Input was generated by ent.
 */
export type OrderWhereInput = {
  and?: InputMaybe<Array<OrderWhereInput>>;
  /** comment_external field predicates */
  commentExternal?: InputMaybe<Scalars['String']>;
  commentExternalContains?: InputMaybe<Scalars['String']>;
  commentExternalContainsFold?: InputMaybe<Scalars['String']>;
  commentExternalEqualFold?: InputMaybe<Scalars['String']>;
  commentExternalGT?: InputMaybe<Scalars['String']>;
  commentExternalGTE?: InputMaybe<Scalars['String']>;
  commentExternalHasPrefix?: InputMaybe<Scalars['String']>;
  commentExternalHasSuffix?: InputMaybe<Scalars['String']>;
  commentExternalIn?: InputMaybe<Array<Scalars['String']>>;
  commentExternalIsNil?: InputMaybe<Scalars['Boolean']>;
  commentExternalLT?: InputMaybe<Scalars['String']>;
  commentExternalLTE?: InputMaybe<Scalars['String']>;
  commentExternalNEQ?: InputMaybe<Scalars['String']>;
  commentExternalNotIn?: InputMaybe<Array<Scalars['String']>>;
  commentExternalNotNil?: InputMaybe<Scalars['Boolean']>;
  /** comment_internal field predicates */
  commentInternal?: InputMaybe<Scalars['String']>;
  commentInternalContains?: InputMaybe<Scalars['String']>;
  commentInternalContainsFold?: InputMaybe<Scalars['String']>;
  commentInternalEqualFold?: InputMaybe<Scalars['String']>;
  commentInternalGT?: InputMaybe<Scalars['String']>;
  commentInternalGTE?: InputMaybe<Scalars['String']>;
  commentInternalHasPrefix?: InputMaybe<Scalars['String']>;
  commentInternalHasSuffix?: InputMaybe<Scalars['String']>;
  commentInternalIn?: InputMaybe<Array<Scalars['String']>>;
  commentInternalIsNil?: InputMaybe<Scalars['Boolean']>;
  commentInternalLT?: InputMaybe<Scalars['String']>;
  commentInternalLTE?: InputMaybe<Scalars['String']>;
  commentInternalNEQ?: InputMaybe<Scalars['String']>;
  commentInternalNotIn?: InputMaybe<Array<Scalars['String']>>;
  commentInternalNotNil?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** email_sync_confirmation_at field predicates */
  emailSyncConfirmationAt?: InputMaybe<Scalars['Time']>;
  emailSyncConfirmationAtGT?: InputMaybe<Scalars['Time']>;
  emailSyncConfirmationAtGTE?: InputMaybe<Scalars['Time']>;
  emailSyncConfirmationAtIn?: InputMaybe<Array<Scalars['Time']>>;
  emailSyncConfirmationAtIsNil?: InputMaybe<Scalars['Boolean']>;
  emailSyncConfirmationAtLT?: InputMaybe<Scalars['Time']>;
  emailSyncConfirmationAtLTE?: InputMaybe<Scalars['Time']>;
  emailSyncConfirmationAtNEQ?: InputMaybe<Scalars['Time']>;
  emailSyncConfirmationAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  emailSyncConfirmationAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** external_id field predicates */
  externalID?: InputMaybe<Scalars['String']>;
  externalIDContains?: InputMaybe<Scalars['String']>;
  externalIDContainsFold?: InputMaybe<Scalars['String']>;
  externalIDEqualFold?: InputMaybe<Scalars['String']>;
  externalIDGT?: InputMaybe<Scalars['String']>;
  externalIDGTE?: InputMaybe<Scalars['String']>;
  externalIDHasPrefix?: InputMaybe<Scalars['String']>;
  externalIDHasSuffix?: InputMaybe<Scalars['String']>;
  externalIDIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDIsNil?: InputMaybe<Scalars['Boolean']>;
  externalIDLT?: InputMaybe<Scalars['String']>;
  externalIDLTE?: InputMaybe<Scalars['String']>;
  externalIDNEQ?: InputMaybe<Scalars['String']>;
  externalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** colli edge predicates */
  hasColli?: InputMaybe<Scalars['Boolean']>;
  hasColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** connection edge predicates */
  hasConnection?: InputMaybe<Scalars['Boolean']>;
  hasConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** consolidation edge predicates */
  hasConsolidation?: InputMaybe<Scalars['Boolean']>;
  hasConsolidationWith?: InputMaybe<Array<ConsolidationWhereInput>>;
  /** hypothesis_test_delivery_option_request edge predicates */
  hasHypothesisTestDeliveryOptionRequest?: InputMaybe<Scalars['Boolean']>;
  hasHypothesisTestDeliveryOptionRequestWith?: InputMaybe<Array<HypothesisTestDeliveryOptionRequestWhereInput>>;
  /** order_history edge predicates */
  hasOrderHistory?: InputMaybe<Scalars['Boolean']>;
  hasOrderHistoryWith?: InputMaybe<Array<OrderHistoryWhereInput>>;
  /** pallet edge predicates */
  hasPallet?: InputMaybe<Scalars['Boolean']>;
  hasPalletWith?: InputMaybe<Array<PalletWhereInput>>;
  /** return_colli edge predicates */
  hasReturnColli?: InputMaybe<Scalars['Boolean']>;
  hasReturnColliWith?: InputMaybe<Array<ReturnColliWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<OrderWhereInput>;
  or?: InputMaybe<Array<OrderWhereInput>>;
  /** order_public_id field predicates */
  orderPublicID?: InputMaybe<Scalars['String']>;
  orderPublicIDContains?: InputMaybe<Scalars['String']>;
  orderPublicIDContainsFold?: InputMaybe<Scalars['String']>;
  orderPublicIDEqualFold?: InputMaybe<Scalars['String']>;
  orderPublicIDGT?: InputMaybe<Scalars['String']>;
  orderPublicIDGTE?: InputMaybe<Scalars['String']>;
  orderPublicIDHasPrefix?: InputMaybe<Scalars['String']>;
  orderPublicIDHasSuffix?: InputMaybe<Scalars['String']>;
  orderPublicIDIn?: InputMaybe<Array<Scalars['String']>>;
  orderPublicIDLT?: InputMaybe<Scalars['String']>;
  orderPublicIDLTE?: InputMaybe<Scalars['String']>;
  orderPublicIDNEQ?: InputMaybe<Scalars['String']>;
  orderPublicIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** status field predicates */
  status?: InputMaybe<OrderStatus>;
  statusIn?: InputMaybe<Array<OrderStatus>>;
  statusNEQ?: InputMaybe<OrderStatus>;
  statusNotIn?: InputMaybe<Array<OrderStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type Packaging = Node & {
  archivedAt?: Maybe<Scalars['Time']>;
  carrierBrand?: Maybe<CarrierBrand>;
  colli?: Maybe<Array<Colli>>;
  deliveryOption?: Maybe<Array<DeliveryOption>>;
  heightCm: Scalars['Int'];
  id: Scalars['ID'];
  lengthCm: Scalars['Int'];
  name: Scalars['String'];
  packagingDF?: Maybe<PackagingDf>;
  packagingUSPS?: Maybe<PackagingUsps>;
  pallet?: Maybe<Array<Pallet>>;
  returnColli?: Maybe<Array<ReturnColli>>;
  shipmentParcel?: Maybe<Array<ShipmentParcel>>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  widthCm: Scalars['Int'];
};

/** A connection to a list of items. */
export type PackagingConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackagingEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

export type PackagingDf = Node & {
  apiType: PackagingDfapiType;
  id: Scalars['ID'];
  maxWeight?: Maybe<Scalars['Float']>;
  minWeight?: Maybe<Scalars['Float']>;
  packaging: Packaging;
  /** Some carriers this is not boolean, so this is not a general toggle */
  stackable: Scalars['Boolean'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** PackagingDFAPIType is enum for the field api_type */
export enum PackagingDfapiType {
  C10 = 'C10',
  Cll = 'CLL',
  K10 = 'K10',
  K20 = 'K20',
  Pkk = 'PKK',
  Pl1 = 'PL1',
  Pl2 = 'PL2',
  Pl4 = 'PL4',
  Pl7 = 'PL7',
  Pll = 'PLL'
}

/** A connection to a list of items. */
export type PackagingDfConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackagingDfEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PackagingDfEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<PackagingDf>;
};

/**
 * PackagingDFWhereInput is used for filtering PackagingDF objects.
 * Input was generated by ent.
 */
export type PackagingDfWhereInput = {
  and?: InputMaybe<Array<PackagingDfWhereInput>>;
  /** api_type field predicates */
  apiType?: InputMaybe<PackagingDfapiType>;
  apiTypeIn?: InputMaybe<Array<PackagingDfapiType>>;
  apiTypeNEQ?: InputMaybe<PackagingDfapiType>;
  apiTypeNotIn?: InputMaybe<Array<PackagingDfapiType>>;
  /** packaging edge predicates */
  hasPackaging?: InputMaybe<Scalars['Boolean']>;
  hasPackagingWith?: InputMaybe<Array<PackagingWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** max_weight field predicates */
  maxWeight?: InputMaybe<Scalars['Float']>;
  maxWeightGT?: InputMaybe<Scalars['Float']>;
  maxWeightGTE?: InputMaybe<Scalars['Float']>;
  maxWeightIn?: InputMaybe<Array<Scalars['Float']>>;
  maxWeightIsNil?: InputMaybe<Scalars['Boolean']>;
  maxWeightLT?: InputMaybe<Scalars['Float']>;
  maxWeightLTE?: InputMaybe<Scalars['Float']>;
  maxWeightNEQ?: InputMaybe<Scalars['Float']>;
  maxWeightNotIn?: InputMaybe<Array<Scalars['Float']>>;
  maxWeightNotNil?: InputMaybe<Scalars['Boolean']>;
  /** min_weight field predicates */
  minWeight?: InputMaybe<Scalars['Float']>;
  minWeightGT?: InputMaybe<Scalars['Float']>;
  minWeightGTE?: InputMaybe<Scalars['Float']>;
  minWeightIn?: InputMaybe<Array<Scalars['Float']>>;
  minWeightIsNil?: InputMaybe<Scalars['Boolean']>;
  minWeightLT?: InputMaybe<Scalars['Float']>;
  minWeightLTE?: InputMaybe<Scalars['Float']>;
  minWeightNEQ?: InputMaybe<Scalars['Float']>;
  minWeightNotIn?: InputMaybe<Array<Scalars['Float']>>;
  minWeightNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<PackagingDfWhereInput>;
  or?: InputMaybe<Array<PackagingDfWhereInput>>;
  /** stackable field predicates */
  stackable?: InputMaybe<Scalars['Boolean']>;
  stackableNEQ?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/** An edge in a connection. */
export type PackagingEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Packaging>;
};

export type PackagingUsps = Node & {
  id: Scalars['ID'];
  packaging: Packaging;
  packagingUSPSProcessingCategory: PackagingUspsProcessingCategory;
  packagingUSPSRateIndicator: PackagingUspsRateIndicator;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type PackagingUspsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackagingUspsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PackagingUspsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<PackagingUsps>;
};

export type PackagingUspsProcessingCategory = Node & {
  id: Scalars['ID'];
  name: Scalars['String'];
  processingCategory: PackagingUspsProcessingCategoryProcessingCategory;
};

/** A connection to a list of items. */
export type PackagingUspsProcessingCategoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackagingUspsProcessingCategoryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PackagingUspsProcessingCategoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<PackagingUspsProcessingCategory>;
};

/** PackagingUSPSProcessingCategoryProcessingCategory is enum for the field processing_category */
export enum PackagingUspsProcessingCategoryProcessingCategory {
  Flats = 'FLATS',
  Irregular = 'IRREGULAR',
  Letters = 'LETTERS',
  Machinable = 'MACHINABLE',
  NonMachinable = 'NON_MACHINABLE'
}

/**
 * PackagingUSPSProcessingCategoryWhereInput is used for filtering PackagingUSPSProcessingCategory objects.
 * Input was generated by ent.
 */
export type PackagingUspsProcessingCategoryWhereInput = {
  and?: InputMaybe<Array<PackagingUspsProcessingCategoryWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<PackagingUspsProcessingCategoryWhereInput>;
  or?: InputMaybe<Array<PackagingUspsProcessingCategoryWhereInput>>;
  /** processing_category field predicates */
  processingCategory?: InputMaybe<PackagingUspsProcessingCategoryProcessingCategory>;
  processingCategoryIn?: InputMaybe<Array<PackagingUspsProcessingCategoryProcessingCategory>>;
  processingCategoryNEQ?: InputMaybe<PackagingUspsProcessingCategoryProcessingCategory>;
  processingCategoryNotIn?: InputMaybe<Array<PackagingUspsProcessingCategoryProcessingCategory>>;
};

export type PackagingUspsRateIndicator = Node & {
  code: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  packagingUSPS?: Maybe<Array<PackagingUsps>>;
};

/** A connection to a list of items. */
export type PackagingUspsRateIndicatorConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PackagingUspsRateIndicatorEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PackagingUspsRateIndicatorEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<PackagingUspsRateIndicator>;
};

/**
 * PackagingUSPSRateIndicatorWhereInput is used for filtering PackagingUSPSRateIndicator objects.
 * Input was generated by ent.
 */
export type PackagingUspsRateIndicatorWhereInput = {
  and?: InputMaybe<Array<PackagingUspsRateIndicatorWhereInput>>;
  /** code field predicates */
  code?: InputMaybe<Scalars['String']>;
  codeContains?: InputMaybe<Scalars['String']>;
  codeContainsFold?: InputMaybe<Scalars['String']>;
  codeEqualFold?: InputMaybe<Scalars['String']>;
  codeGT?: InputMaybe<Scalars['String']>;
  codeGTE?: InputMaybe<Scalars['String']>;
  codeHasPrefix?: InputMaybe<Scalars['String']>;
  codeHasSuffix?: InputMaybe<Scalars['String']>;
  codeIn?: InputMaybe<Array<Scalars['String']>>;
  codeLT?: InputMaybe<Scalars['String']>;
  codeLTE?: InputMaybe<Scalars['String']>;
  codeNEQ?: InputMaybe<Scalars['String']>;
  codeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** packaging_usps edge predicates */
  hasPackagingUSPS?: InputMaybe<Scalars['Boolean']>;
  hasPackagingUSPSWith?: InputMaybe<Array<PackagingUspsWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<PackagingUspsRateIndicatorWhereInput>;
  or?: InputMaybe<Array<PackagingUspsRateIndicatorWhereInput>>;
};

/**
 * PackagingUSPSWhereInput is used for filtering PackagingUSPS objects.
 * Input was generated by ent.
 */
export type PackagingUspsWhereInput = {
  and?: InputMaybe<Array<PackagingUspsWhereInput>>;
  /** packaging edge predicates */
  hasPackaging?: InputMaybe<Scalars['Boolean']>;
  /** packaging_usps_processing_category edge predicates */
  hasPackagingUSPSProcessingCategory?: InputMaybe<Scalars['Boolean']>;
  hasPackagingUSPSProcessingCategoryWith?: InputMaybe<Array<PackagingUspsProcessingCategoryWhereInput>>;
  /** packaging_usps_rate_indicator edge predicates */
  hasPackagingUSPSRateIndicator?: InputMaybe<Scalars['Boolean']>;
  hasPackagingUSPSRateIndicatorWith?: InputMaybe<Array<PackagingUspsRateIndicatorWhereInput>>;
  hasPackagingWith?: InputMaybe<Array<PackagingWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<PackagingUspsWhereInput>;
  or?: InputMaybe<Array<PackagingUspsWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * PackagingWhereInput is used for filtering Packaging objects.
 * Input was generated by ent.
 */
export type PackagingWhereInput = {
  and?: InputMaybe<Array<PackagingWhereInput>>;
  /** archived_at field predicates */
  archivedAt?: InputMaybe<Scalars['Time']>;
  archivedAtGT?: InputMaybe<Scalars['Time']>;
  archivedAtGTE?: InputMaybe<Scalars['Time']>;
  archivedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  archivedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  archivedAtLT?: InputMaybe<Scalars['Time']>;
  archivedAtLTE?: InputMaybe<Scalars['Time']>;
  archivedAtNEQ?: InputMaybe<Scalars['Time']>;
  archivedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  archivedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** carrier_brand edge predicates */
  hasCarrierBrand?: InputMaybe<Scalars['Boolean']>;
  hasCarrierBrandWith?: InputMaybe<Array<CarrierBrandWhereInput>>;
  /** colli edge predicates */
  hasColli?: InputMaybe<Scalars['Boolean']>;
  hasColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** packaging_df edge predicates */
  hasPackagingDF?: InputMaybe<Scalars['Boolean']>;
  hasPackagingDFWith?: InputMaybe<Array<PackagingDfWhereInput>>;
  /** packaging_usps edge predicates */
  hasPackagingUSPS?: InputMaybe<Scalars['Boolean']>;
  hasPackagingUSPSWith?: InputMaybe<Array<PackagingUspsWhereInput>>;
  /** pallet edge predicates */
  hasPallet?: InputMaybe<Scalars['Boolean']>;
  hasPalletWith?: InputMaybe<Array<PalletWhereInput>>;
  /** return_colli edge predicates */
  hasReturnColli?: InputMaybe<Scalars['Boolean']>;
  hasReturnColliWith?: InputMaybe<Array<ReturnColliWhereInput>>;
  /** shipment_parcel edge predicates */
  hasShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  hasShipmentParcelWith?: InputMaybe<Array<ShipmentParcelWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** height_cm field predicates */
  heightCm?: InputMaybe<Scalars['Int']>;
  heightCmGT?: InputMaybe<Scalars['Int']>;
  heightCmGTE?: InputMaybe<Scalars['Int']>;
  heightCmIn?: InputMaybe<Array<Scalars['Int']>>;
  heightCmLT?: InputMaybe<Scalars['Int']>;
  heightCmLTE?: InputMaybe<Scalars['Int']>;
  heightCmNEQ?: InputMaybe<Scalars['Int']>;
  heightCmNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** length_cm field predicates */
  lengthCm?: InputMaybe<Scalars['Int']>;
  lengthCmGT?: InputMaybe<Scalars['Int']>;
  lengthCmGTE?: InputMaybe<Scalars['Int']>;
  lengthCmIn?: InputMaybe<Array<Scalars['Int']>>;
  lengthCmLT?: InputMaybe<Scalars['Int']>;
  lengthCmLTE?: InputMaybe<Scalars['Int']>;
  lengthCmNEQ?: InputMaybe<Scalars['Int']>;
  lengthCmNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<PackagingWhereInput>;
  or?: InputMaybe<Array<PackagingWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** width_cm field predicates */
  widthCm?: InputMaybe<Scalars['Int']>;
  widthCmGT?: InputMaybe<Scalars['Int']>;
  widthCmGTE?: InputMaybe<Scalars['Int']>;
  widthCmIn?: InputMaybe<Array<Scalars['Int']>>;
  widthCmLT?: InputMaybe<Scalars['Int']>;
  widthCmLTE?: InputMaybe<Scalars['Int']>;
  widthCmNEQ?: InputMaybe<Scalars['Int']>;
  widthCmNotIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type PackingSlipsOutput = {
  allPackingSlips: Scalars['String'];
  packingSlips: Array<Scalars['String']>;
};

/**
 * Information about pagination in a connection.
 * https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
 */
export type PageInfo = {
  /** When paginating forwards, the cursor to continue. */
  endCursor?: Maybe<Scalars['Cursor']>;
  /** When paginating forwards, are there more items? */
  hasNextPage: Scalars['Boolean'];
  /** When paginating backwards, are there more items? */
  hasPreviousPage: Scalars['Boolean'];
  /** When paginating backwards, the cursor to continue. */
  startCursor?: Maybe<Scalars['Cursor']>;
};

export type Pallet = Node & {
  /** Cancelled shipments move here to maintain the ref */
  cancelledShipmentPallet?: Maybe<Array<ShipmentPallet>>;
  consolidation: Consolidation;
  description: Scalars['String'];
  id: Scalars['ID'];
  orders?: Maybe<Array<Order>>;
  packaging?: Maybe<Packaging>;
  publicID: Scalars['String'];
  /** A pallet may only have 1 active shipment */
  shipmentPallet?: Maybe<ShipmentPallet>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type PalletConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PalletEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PalletEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Pallet>;
};

/**
 * PalletWhereInput is used for filtering Pallet objects.
 * Input was generated by ent.
 */
export type PalletWhereInput = {
  and?: InputMaybe<Array<PalletWhereInput>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** cancelled_shipment_pallet edge predicates */
  hasCancelledShipmentPallet?: InputMaybe<Scalars['Boolean']>;
  hasCancelledShipmentPalletWith?: InputMaybe<Array<ShipmentPalletWhereInput>>;
  /** consolidation edge predicates */
  hasConsolidation?: InputMaybe<Scalars['Boolean']>;
  hasConsolidationWith?: InputMaybe<Array<ConsolidationWhereInput>>;
  /** orders edge predicates */
  hasOrders?: InputMaybe<Scalars['Boolean']>;
  hasOrdersWith?: InputMaybe<Array<OrderWhereInput>>;
  /** packaging edge predicates */
  hasPackaging?: InputMaybe<Scalars['Boolean']>;
  hasPackagingWith?: InputMaybe<Array<PackagingWhereInput>>;
  /** shipment_pallet edge predicates */
  hasShipmentPallet?: InputMaybe<Scalars['Boolean']>;
  hasShipmentPalletWith?: InputMaybe<Array<ShipmentPalletWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<PalletWhereInput>;
  or?: InputMaybe<Array<PalletWhereInput>>;
  /** public_id field predicates */
  publicID?: InputMaybe<Scalars['String']>;
  publicIDContains?: InputMaybe<Scalars['String']>;
  publicIDContainsFold?: InputMaybe<Scalars['String']>;
  publicIDEqualFold?: InputMaybe<Scalars['String']>;
  publicIDGT?: InputMaybe<Scalars['String']>;
  publicIDGTE?: InputMaybe<Scalars['String']>;
  publicIDHasPrefix?: InputMaybe<Scalars['String']>;
  publicIDHasSuffix?: InputMaybe<Scalars['String']>;
  publicIDIn?: InputMaybe<Array<Scalars['String']>>;
  publicIDLT?: InputMaybe<Scalars['String']>;
  publicIDLTE?: InputMaybe<Scalars['String']>;
  publicIDNEQ?: InputMaybe<Scalars['String']>;
  publicIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ParcelShop = Node & {
  address: AddressGlobal;
  businessHoursPeriod?: Maybe<Array<BusinessHoursPeriod>>;
  carrierBrand: CarrierBrand;
  colli?: Maybe<Array<Colli>>;
  id: Scalars['ID'];
  lastUpdated: Scalars['Time'];
  name: Scalars['String'];
  parcelShopBring?: Maybe<ParcelShopBring>;
  parcelShopDAO?: Maybe<ParcelShopDao>;
  parcelShopGLS?: Maybe<ParcelShopGls>;
  parcelShopPostNord?: Maybe<ParcelShopPostNord>;
};

export type ParcelShopBring = Node & {
  addressDelivery: AddressGlobal;
  bringID: Scalars['String'];
  id: Scalars['ID'];
  parcelShop: ParcelShop;
  /** https://developer.bring.com/api/pickup-point/#pickup-point-types */
  pointType: ParcelShopBringPointType;
};

/** A connection to a list of items. */
export type ParcelShopBringConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ParcelShopBringEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ParcelShopBringEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ParcelShopBring>;
};

/** ParcelShopBringPointType is enum for the field point_type */
export enum ParcelShopBringPointType {
  Locker = 'LOCKER',
  Noutopiste = 'Noutopiste',
  Posti = 'Posti',
  SmartPost = 'SmartPOST',
  Unknown = 'Unknown',
  EightyFive = 'eighty_five',
  EightySix = 'eighty_six',
  Four = 'four',
  Nineteen = 'nineteen',
  One = 'one',
  ThirtyEight = 'thirty_eight',
  ThirtyFour = 'thirty_four',
  ThirtyNine = 'thirty_nine',
  ThirtySeven = 'thirty_seven',
  ThirtyTwo = 'thirty_two',
  TwentyOne = 'twenty_one'
}

/**
 * ParcelShopBringWhereInput is used for filtering ParcelShopBring objects.
 * Input was generated by ent.
 */
export type ParcelShopBringWhereInput = {
  and?: InputMaybe<Array<ParcelShopBringWhereInput>>;
  /** bring_id field predicates */
  bringID?: InputMaybe<Scalars['String']>;
  bringIDContains?: InputMaybe<Scalars['String']>;
  bringIDContainsFold?: InputMaybe<Scalars['String']>;
  bringIDEqualFold?: InputMaybe<Scalars['String']>;
  bringIDGT?: InputMaybe<Scalars['String']>;
  bringIDGTE?: InputMaybe<Scalars['String']>;
  bringIDHasPrefix?: InputMaybe<Scalars['String']>;
  bringIDHasSuffix?: InputMaybe<Scalars['String']>;
  bringIDIn?: InputMaybe<Array<Scalars['String']>>;
  bringIDLT?: InputMaybe<Scalars['String']>;
  bringIDLTE?: InputMaybe<Scalars['String']>;
  bringIDNEQ?: InputMaybe<Scalars['String']>;
  bringIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** address_delivery edge predicates */
  hasAddressDelivery?: InputMaybe<Scalars['Boolean']>;
  hasAddressDeliveryWith?: InputMaybe<Array<AddressGlobalWhereInput>>;
  /** parcel_shop edge predicates */
  hasParcelShop?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopWith?: InputMaybe<Array<ParcelShopWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ParcelShopBringWhereInput>;
  or?: InputMaybe<Array<ParcelShopBringWhereInput>>;
  /** point_type field predicates */
  pointType?: InputMaybe<ParcelShopBringPointType>;
  pointTypeIn?: InputMaybe<Array<ParcelShopBringPointType>>;
  pointTypeNEQ?: InputMaybe<ParcelShopBringPointType>;
  pointTypeNotIn?: InputMaybe<Array<ParcelShopBringPointType>>;
};

/** A connection to a list of items. */
export type ParcelShopConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ParcelShopEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

export type ParcelShopDao = Node & {
  id: Scalars['ID'];
  parcelShop: ParcelShop;
  shopID: Scalars['String'];
};

/** A connection to a list of items. */
export type ParcelShopDaoConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ParcelShopDaoEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ParcelShopDaoEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ParcelShopDao>;
};

/**
 * ParcelShopDAOWhereInput is used for filtering ParcelShopDAO objects.
 * Input was generated by ent.
 */
export type ParcelShopDaoWhereInput = {
  and?: InputMaybe<Array<ParcelShopDaoWhereInput>>;
  /** parcel_shop edge predicates */
  hasParcelShop?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopWith?: InputMaybe<Array<ParcelShopWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ParcelShopDaoWhereInput>;
  or?: InputMaybe<Array<ParcelShopDaoWhereInput>>;
  /** shop_id field predicates */
  shopID?: InputMaybe<Scalars['String']>;
  shopIDContains?: InputMaybe<Scalars['String']>;
  shopIDContainsFold?: InputMaybe<Scalars['String']>;
  shopIDEqualFold?: InputMaybe<Scalars['String']>;
  shopIDGT?: InputMaybe<Scalars['String']>;
  shopIDGTE?: InputMaybe<Scalars['String']>;
  shopIDHasPrefix?: InputMaybe<Scalars['String']>;
  shopIDHasSuffix?: InputMaybe<Scalars['String']>;
  shopIDIn?: InputMaybe<Array<Scalars['String']>>;
  shopIDLT?: InputMaybe<Scalars['String']>;
  shopIDLTE?: InputMaybe<Scalars['String']>;
  shopIDNEQ?: InputMaybe<Scalars['String']>;
  shopIDNotIn?: InputMaybe<Array<Scalars['String']>>;
};

/** An edge in a connection. */
export type ParcelShopEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ParcelShop>;
};

export type ParcelShopGls = Node & {
  glsParcelShopID: Scalars['String'];
  id: Scalars['ID'];
  parcelShop: ParcelShop;
  /** Only available in Group API */
  partnerID?: Maybe<Scalars['String']>;
  /** Only available in Group API */
  type?: Maybe<Scalars['String']>;
};

/** A connection to a list of items. */
export type ParcelShopGlsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ParcelShopGlsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ParcelShopGlsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ParcelShopGls>;
};

/**
 * ParcelShopGLSWhereInput is used for filtering ParcelShopGLS objects.
 * Input was generated by ent.
 */
export type ParcelShopGlsWhereInput = {
  and?: InputMaybe<Array<ParcelShopGlsWhereInput>>;
  /** gls_parcel_shop_id field predicates */
  glsParcelShopID?: InputMaybe<Scalars['String']>;
  glsParcelShopIDContains?: InputMaybe<Scalars['String']>;
  glsParcelShopIDContainsFold?: InputMaybe<Scalars['String']>;
  glsParcelShopIDEqualFold?: InputMaybe<Scalars['String']>;
  glsParcelShopIDGT?: InputMaybe<Scalars['String']>;
  glsParcelShopIDGTE?: InputMaybe<Scalars['String']>;
  glsParcelShopIDHasPrefix?: InputMaybe<Scalars['String']>;
  glsParcelShopIDHasSuffix?: InputMaybe<Scalars['String']>;
  glsParcelShopIDIn?: InputMaybe<Array<Scalars['String']>>;
  glsParcelShopIDLT?: InputMaybe<Scalars['String']>;
  glsParcelShopIDLTE?: InputMaybe<Scalars['String']>;
  glsParcelShopIDNEQ?: InputMaybe<Scalars['String']>;
  glsParcelShopIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** parcel_shop edge predicates */
  hasParcelShop?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopWith?: InputMaybe<Array<ParcelShopWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ParcelShopGlsWhereInput>;
  or?: InputMaybe<Array<ParcelShopGlsWhereInput>>;
  /** partner_id field predicates */
  partnerID?: InputMaybe<Scalars['String']>;
  partnerIDContains?: InputMaybe<Scalars['String']>;
  partnerIDContainsFold?: InputMaybe<Scalars['String']>;
  partnerIDEqualFold?: InputMaybe<Scalars['String']>;
  partnerIDGT?: InputMaybe<Scalars['String']>;
  partnerIDGTE?: InputMaybe<Scalars['String']>;
  partnerIDHasPrefix?: InputMaybe<Scalars['String']>;
  partnerIDHasSuffix?: InputMaybe<Scalars['String']>;
  partnerIDIn?: InputMaybe<Array<Scalars['String']>>;
  partnerIDIsNil?: InputMaybe<Scalars['Boolean']>;
  partnerIDLT?: InputMaybe<Scalars['String']>;
  partnerIDLTE?: InputMaybe<Scalars['String']>;
  partnerIDNEQ?: InputMaybe<Scalars['String']>;
  partnerIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  partnerIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** type field predicates */
  type?: InputMaybe<Scalars['String']>;
  typeContains?: InputMaybe<Scalars['String']>;
  typeContainsFold?: InputMaybe<Scalars['String']>;
  typeEqualFold?: InputMaybe<Scalars['String']>;
  typeGT?: InputMaybe<Scalars['String']>;
  typeGTE?: InputMaybe<Scalars['String']>;
  typeHasPrefix?: InputMaybe<Scalars['String']>;
  typeHasSuffix?: InputMaybe<Scalars['String']>;
  typeIn?: InputMaybe<Array<Scalars['String']>>;
  typeIsNil?: InputMaybe<Scalars['Boolean']>;
  typeLT?: InputMaybe<Scalars['String']>;
  typeLTE?: InputMaybe<Scalars['String']>;
  typeNEQ?: InputMaybe<Scalars['String']>;
  typeNotIn?: InputMaybe<Array<Scalars['String']>>;
  typeNotNil?: InputMaybe<Scalars['Boolean']>;
};

export type ParcelShopPostNord = Node & {
  addressDelivery: AddressGlobal;
  id: Scalars['ID'];
  parcelShop: ParcelShop;
  pudoid: Scalars['String'];
  servicePointID: Scalars['String'];
  /** No idea what the options are aside from the default: 156. Maybe box, shop, etc?? */
  typeID: Scalars['String'];
};

/** A connection to a list of items. */
export type ParcelShopPostNordConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ParcelShopPostNordEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ParcelShopPostNordEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ParcelShopPostNord>;
};

/**
 * ParcelShopPostNordWhereInput is used for filtering ParcelShopPostNord objects.
 * Input was generated by ent.
 */
export type ParcelShopPostNordWhereInput = {
  and?: InputMaybe<Array<ParcelShopPostNordWhereInput>>;
  /** address_delivery edge predicates */
  hasAddressDelivery?: InputMaybe<Scalars['Boolean']>;
  hasAddressDeliveryWith?: InputMaybe<Array<AddressGlobalWhereInput>>;
  /** parcel_shop edge predicates */
  hasParcelShop?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopWith?: InputMaybe<Array<ParcelShopWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ParcelShopPostNordWhereInput>;
  or?: InputMaybe<Array<ParcelShopPostNordWhereInput>>;
  /** pudoid field predicates */
  pudoid?: InputMaybe<Scalars['String']>;
  pudoidContains?: InputMaybe<Scalars['String']>;
  pudoidContainsFold?: InputMaybe<Scalars['String']>;
  pudoidEqualFold?: InputMaybe<Scalars['String']>;
  pudoidGT?: InputMaybe<Scalars['String']>;
  pudoidGTE?: InputMaybe<Scalars['String']>;
  pudoidHasPrefix?: InputMaybe<Scalars['String']>;
  pudoidHasSuffix?: InputMaybe<Scalars['String']>;
  pudoidIn?: InputMaybe<Array<Scalars['String']>>;
  pudoidLT?: InputMaybe<Scalars['String']>;
  pudoidLTE?: InputMaybe<Scalars['String']>;
  pudoidNEQ?: InputMaybe<Scalars['String']>;
  pudoidNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** service_point_id field predicates */
  servicePointID?: InputMaybe<Scalars['String']>;
  servicePointIDContains?: InputMaybe<Scalars['String']>;
  servicePointIDContainsFold?: InputMaybe<Scalars['String']>;
  servicePointIDEqualFold?: InputMaybe<Scalars['String']>;
  servicePointIDGT?: InputMaybe<Scalars['String']>;
  servicePointIDGTE?: InputMaybe<Scalars['String']>;
  servicePointIDHasPrefix?: InputMaybe<Scalars['String']>;
  servicePointIDHasSuffix?: InputMaybe<Scalars['String']>;
  servicePointIDIn?: InputMaybe<Array<Scalars['String']>>;
  servicePointIDLT?: InputMaybe<Scalars['String']>;
  servicePointIDLTE?: InputMaybe<Scalars['String']>;
  servicePointIDNEQ?: InputMaybe<Scalars['String']>;
  servicePointIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** type_id field predicates */
  typeID?: InputMaybe<Scalars['String']>;
  typeIDContains?: InputMaybe<Scalars['String']>;
  typeIDContainsFold?: InputMaybe<Scalars['String']>;
  typeIDEqualFold?: InputMaybe<Scalars['String']>;
  typeIDGT?: InputMaybe<Scalars['String']>;
  typeIDGTE?: InputMaybe<Scalars['String']>;
  typeIDHasPrefix?: InputMaybe<Scalars['String']>;
  typeIDHasSuffix?: InputMaybe<Scalars['String']>;
  typeIDIn?: InputMaybe<Array<Scalars['String']>>;
  typeIDLT?: InputMaybe<Scalars['String']>;
  typeIDLTE?: InputMaybe<Scalars['String']>;
  typeIDNEQ?: InputMaybe<Scalars['String']>;
  typeIDNotIn?: InputMaybe<Array<Scalars['String']>>;
};

/**
 * ParcelShopWhereInput is used for filtering ParcelShop objects.
 * Input was generated by ent.
 */
export type ParcelShopWhereInput = {
  and?: InputMaybe<Array<ParcelShopWhereInput>>;
  /** address edge predicates */
  hasAddress?: InputMaybe<Scalars['Boolean']>;
  hasAddressWith?: InputMaybe<Array<AddressGlobalWhereInput>>;
  /** business_hours_period edge predicates */
  hasBusinessHoursPeriod?: InputMaybe<Scalars['Boolean']>;
  hasBusinessHoursPeriodWith?: InputMaybe<Array<BusinessHoursPeriodWhereInput>>;
  /** carrier_brand edge predicates */
  hasCarrierBrand?: InputMaybe<Scalars['Boolean']>;
  hasCarrierBrandWith?: InputMaybe<Array<CarrierBrandWhereInput>>;
  /** colli edge predicates */
  hasColli?: InputMaybe<Scalars['Boolean']>;
  hasColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** parcel_shop_bring edge predicates */
  hasParcelShopBring?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopBringWith?: InputMaybe<Array<ParcelShopBringWhereInput>>;
  /** parcel_shop_dao edge predicates */
  hasParcelShopDAO?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopDAOWith?: InputMaybe<Array<ParcelShopDaoWhereInput>>;
  /** parcel_shop_gls edge predicates */
  hasParcelShopGLS?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopGLSWith?: InputMaybe<Array<ParcelShopGlsWhereInput>>;
  /** parcel_shop_post_nord edge predicates */
  hasParcelShopPostNord?: InputMaybe<Scalars['Boolean']>;
  hasParcelShopPostNordWith?: InputMaybe<Array<ParcelShopPostNordWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** last_updated field predicates */
  lastUpdated?: InputMaybe<Scalars['Time']>;
  lastUpdatedGT?: InputMaybe<Scalars['Time']>;
  lastUpdatedGTE?: InputMaybe<Scalars['Time']>;
  lastUpdatedIn?: InputMaybe<Array<Scalars['Time']>>;
  lastUpdatedLT?: InputMaybe<Scalars['Time']>;
  lastUpdatedLTE?: InputMaybe<Scalars['Time']>;
  lastUpdatedNEQ?: InputMaybe<Scalars['Time']>;
  lastUpdatedNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ParcelShopWhereInput>;
  or?: InputMaybe<Array<ParcelShopWhereInput>>;
};

export type ParcelStatuses = {
  ccSignatures: Array<Scalars['String']>;
  colliID: Scalars['ID'];
  shipmentID?: Maybe<Scalars['ID']>;
};

export type Plan = Node & {
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  label: Scalars['String'];
  planHistoryPlan?: Maybe<Array<PlanHistory>>;
  priceDkk: Scalars['Int'];
  rank: Scalars['Int'];
  tenant?: Maybe<Array<Tenant>>;
};

/** A connection to a list of items. */
export type PlanConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PlanEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PlanEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Plan>;
};

export type PlanHistory = Node & {
  changeHistory: ChangeHistory;
  changedBy: User;
  changedFrom: Plan;
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/**
 * PlanHistoryWhereInput is used for filtering PlanHistory objects.
 * Input was generated by ent.
 */
export type PlanHistoryWhereInput = {
  and?: InputMaybe<Array<PlanHistoryWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** change_history edge predicates */
  hasChangeHistory?: InputMaybe<Scalars['Boolean']>;
  hasChangeHistoryWith?: InputMaybe<Array<ChangeHistoryWhereInput>>;
  /** changed_by edge predicates */
  hasChangedBy?: InputMaybe<Scalars['Boolean']>;
  hasChangedByWith?: InputMaybe<Array<UserWhereInput>>;
  /** changed_from edge predicates */
  hasChangedFrom?: InputMaybe<Scalars['Boolean']>;
  hasChangedFromWith?: InputMaybe<Array<PlanWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<PlanHistoryWhereInput>;
  or?: InputMaybe<Array<PlanHistoryWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * PlanWhereInput is used for filtering Plan objects.
 * Input was generated by ent.
 */
export type PlanWhereInput = {
  and?: InputMaybe<Array<PlanWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** plan_history_plan edge predicates */
  hasPlanHistoryPlan?: InputMaybe<Scalars['Boolean']>;
  hasPlanHistoryPlanWith?: InputMaybe<Array<PlanHistoryWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** label field predicates */
  label?: InputMaybe<Scalars['String']>;
  labelContains?: InputMaybe<Scalars['String']>;
  labelContainsFold?: InputMaybe<Scalars['String']>;
  labelEqualFold?: InputMaybe<Scalars['String']>;
  labelGT?: InputMaybe<Scalars['String']>;
  labelGTE?: InputMaybe<Scalars['String']>;
  labelHasPrefix?: InputMaybe<Scalars['String']>;
  labelHasSuffix?: InputMaybe<Scalars['String']>;
  labelIn?: InputMaybe<Array<Scalars['String']>>;
  labelLT?: InputMaybe<Scalars['String']>;
  labelLTE?: InputMaybe<Scalars['String']>;
  labelNEQ?: InputMaybe<Scalars['String']>;
  labelNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<PlanWhereInput>;
  or?: InputMaybe<Array<PlanWhereInput>>;
  /** price_dkk field predicates */
  priceDkk?: InputMaybe<Scalars['Int']>;
  priceDkkGT?: InputMaybe<Scalars['Int']>;
  priceDkkGTE?: InputMaybe<Scalars['Int']>;
  priceDkkIn?: InputMaybe<Array<Scalars['Int']>>;
  priceDkkLT?: InputMaybe<Scalars['Int']>;
  priceDkkLTE?: InputMaybe<Scalars['Int']>;
  priceDkkNEQ?: InputMaybe<Scalars['Int']>;
  priceDkkNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** rank field predicates */
  rank?: InputMaybe<Scalars['Int']>;
  rankGT?: InputMaybe<Scalars['Int']>;
  rankGTE?: InputMaybe<Scalars['Int']>;
  rankIn?: InputMaybe<Array<Scalars['Int']>>;
  rankLT?: InputMaybe<Scalars['Int']>;
  rankLTE?: InputMaybe<Scalars['Int']>;
  rankNEQ?: InputMaybe<Scalars['Int']>;
  rankNotIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type PrintJob = Node & {
  base64PrintData: Scalars['String'];
  colli?: Maybe<Colli>;
  createdAt: Scalars['Time'];
  documentType: PrintJobDocumentType;
  fileExtension: PrintJobFileExtension;
  id: Scalars['ID'];
  printer: Printer;
  printerMessages?: Maybe<Array<Scalars['String']>>;
  shipmentParcel?: Maybe<ShipmentParcel>;
  status: PrintJobStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** PrintJobDocumentType is enum for the field document_type */
export enum PrintJobDocumentType {
  PackingList = 'packing_list',
  ParcelLabel = 'parcel_label',
  Unknown = 'unknown'
}

/** PrintJobFileExtension is enum for the field file_extension */
export enum PrintJobFileExtension {
  Pdf = 'pdf',
  Png = 'png',
  Txt = 'txt',
  Zpl = 'zpl'
}

/** PrintJobStatus is enum for the field status */
export enum PrintJobStatus {
  AtPrinter = 'at_printer',
  Canceled = 'canceled',
  Pending = 'pending',
  Success = 'success'
}

/**
 * PrintJobWhereInput is used for filtering PrintJob objects.
 * Input was generated by ent.
 */
export type PrintJobWhereInput = {
  and?: InputMaybe<Array<PrintJobWhereInput>>;
  /** base64_print_data field predicates */
  base64PrintData?: InputMaybe<Scalars['String']>;
  base64PrintDataContains?: InputMaybe<Scalars['String']>;
  base64PrintDataContainsFold?: InputMaybe<Scalars['String']>;
  base64PrintDataEqualFold?: InputMaybe<Scalars['String']>;
  base64PrintDataGT?: InputMaybe<Scalars['String']>;
  base64PrintDataGTE?: InputMaybe<Scalars['String']>;
  base64PrintDataHasPrefix?: InputMaybe<Scalars['String']>;
  base64PrintDataHasSuffix?: InputMaybe<Scalars['String']>;
  base64PrintDataIn?: InputMaybe<Array<Scalars['String']>>;
  base64PrintDataLT?: InputMaybe<Scalars['String']>;
  base64PrintDataLTE?: InputMaybe<Scalars['String']>;
  base64PrintDataNEQ?: InputMaybe<Scalars['String']>;
  base64PrintDataNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** document_type field predicates */
  documentType?: InputMaybe<PrintJobDocumentType>;
  documentTypeIn?: InputMaybe<Array<PrintJobDocumentType>>;
  documentTypeNEQ?: InputMaybe<PrintJobDocumentType>;
  documentTypeNotIn?: InputMaybe<Array<PrintJobDocumentType>>;
  /** file_extension field predicates */
  fileExtension?: InputMaybe<PrintJobFileExtension>;
  fileExtensionIn?: InputMaybe<Array<PrintJobFileExtension>>;
  fileExtensionNEQ?: InputMaybe<PrintJobFileExtension>;
  fileExtensionNotIn?: InputMaybe<Array<PrintJobFileExtension>>;
  /** colli edge predicates */
  hasColli?: InputMaybe<Scalars['Boolean']>;
  hasColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** printer edge predicates */
  hasPrinter?: InputMaybe<Scalars['Boolean']>;
  hasPrinterWith?: InputMaybe<Array<PrinterWhereInput>>;
  /** shipment_parcel edge predicates */
  hasShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  hasShipmentParcelWith?: InputMaybe<Array<ShipmentParcelWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<PrintJobWhereInput>;
  or?: InputMaybe<Array<PrintJobWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<PrintJobStatus>;
  statusIn?: InputMaybe<Array<PrintJobStatus>>;
  statusNEQ?: InputMaybe<PrintJobStatus>;
  statusNotIn?: InputMaybe<Array<PrintJobStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type Printer = Node & {
  createdAt: Scalars['Time'];
  /** ID from desktop print client */
  deviceID: Scalars['String'];
  document: Scalars['Boolean'];
  id: Scalars['ID'];
  labelPdf: Scalars['Boolean'];
  labelPng: Scalars['Boolean'];
  labelZpl: Scalars['Boolean'];
  lastPing: Scalars['Time'];
  name: Scalars['String'];
  printJobs?: Maybe<Array<PrintJob>>;
  printSize: PrinterPrintSize;
  rotate180: Scalars['Boolean'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
  useShell: Scalars['Boolean'];
  workstation: Workstation;
};

/** A connection to a list of items. */
export type PrinterConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<PrinterEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type PrinterEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Printer>;
};

/** PrinterPrintSize is enum for the field print_size */
export enum PrinterPrintSize {
  A4 = 'A4',
  Cm_100_150 = 'cm_100_150',
  Cm_100_192 = 'cm_100_192'
}

/**
 * PrinterWhereInput is used for filtering Printer objects.
 * Input was generated by ent.
 */
export type PrinterWhereInput = {
  and?: InputMaybe<Array<PrinterWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** device_id field predicates */
  deviceID?: InputMaybe<Scalars['String']>;
  deviceIDContains?: InputMaybe<Scalars['String']>;
  deviceIDContainsFold?: InputMaybe<Scalars['String']>;
  deviceIDEqualFold?: InputMaybe<Scalars['String']>;
  deviceIDGT?: InputMaybe<Scalars['String']>;
  deviceIDGTE?: InputMaybe<Scalars['String']>;
  deviceIDHasPrefix?: InputMaybe<Scalars['String']>;
  deviceIDHasSuffix?: InputMaybe<Scalars['String']>;
  deviceIDIn?: InputMaybe<Array<Scalars['String']>>;
  deviceIDLT?: InputMaybe<Scalars['String']>;
  deviceIDLTE?: InputMaybe<Scalars['String']>;
  deviceIDNEQ?: InputMaybe<Scalars['String']>;
  deviceIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** document field predicates */
  document?: InputMaybe<Scalars['Boolean']>;
  documentNEQ?: InputMaybe<Scalars['Boolean']>;
  /** print_jobs edge predicates */
  hasPrintJobs?: InputMaybe<Scalars['Boolean']>;
  hasPrintJobsWith?: InputMaybe<Array<PrintJobWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** workstation edge predicates */
  hasWorkstation?: InputMaybe<Scalars['Boolean']>;
  hasWorkstationWith?: InputMaybe<Array<WorkstationWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** label_pdf field predicates */
  labelPdf?: InputMaybe<Scalars['Boolean']>;
  labelPdfNEQ?: InputMaybe<Scalars['Boolean']>;
  /** label_png field predicates */
  labelPng?: InputMaybe<Scalars['Boolean']>;
  labelPngNEQ?: InputMaybe<Scalars['Boolean']>;
  /** label_zpl field predicates */
  labelZpl?: InputMaybe<Scalars['Boolean']>;
  labelZplNEQ?: InputMaybe<Scalars['Boolean']>;
  /** last_ping field predicates */
  lastPing?: InputMaybe<Scalars['Time']>;
  lastPingGT?: InputMaybe<Scalars['Time']>;
  lastPingGTE?: InputMaybe<Scalars['Time']>;
  lastPingIn?: InputMaybe<Array<Scalars['Time']>>;
  lastPingLT?: InputMaybe<Scalars['Time']>;
  lastPingLTE?: InputMaybe<Scalars['Time']>;
  lastPingNEQ?: InputMaybe<Scalars['Time']>;
  lastPingNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<PrinterWhereInput>;
  or?: InputMaybe<Array<PrinterWhereInput>>;
  /** print_size field predicates */
  printSize?: InputMaybe<PrinterPrintSize>;
  printSizeIn?: InputMaybe<Array<PrinterPrintSize>>;
  printSizeNEQ?: InputMaybe<PrinterPrintSize>;
  printSizeNotIn?: InputMaybe<Array<PrinterPrintSize>>;
  /** rotate_180 field predicates */
  rotate180?: InputMaybe<Scalars['Boolean']>;
  rotate180NEQ?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** use_shell field predicates */
  useShell?: InputMaybe<Scalars['Boolean']>;
  useShellNEQ?: InputMaybe<Scalars['Boolean']>;
};

export type Product = Node & {
  bodyHTML?: Maybe<Scalars['String']>;
  createdAt?: Maybe<Scalars['Time']>;
  externalID?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  productImage?: Maybe<Array<ProductImage>>;
  productTags?: Maybe<Array<ProductTag>>;
  productVariant?: Maybe<Array<ProductVariant>>;
  status: ProductStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  title: Scalars['String'];
  updatedAt: Scalars['Time'];
};

/** A connection to a list of items. */
export type ProductConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ProductEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Product>;
};

export type ProductImage = Node & {
  externalID?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  product: Product;
  productVariant?: Maybe<Array<ProductVariant>>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  url: Scalars['String'];
};

/** A connection to a list of items. */
export type ProductImageConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductImageEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ProductImageEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ProductImage>;
};

/**
 * ProductImageWhereInput is used for filtering ProductImage objects.
 * Input was generated by ent.
 */
export type ProductImageWhereInput = {
  and?: InputMaybe<Array<ProductImageWhereInput>>;
  /** external_id field predicates */
  externalID?: InputMaybe<Scalars['String']>;
  externalIDContains?: InputMaybe<Scalars['String']>;
  externalIDContainsFold?: InputMaybe<Scalars['String']>;
  externalIDEqualFold?: InputMaybe<Scalars['String']>;
  externalIDGT?: InputMaybe<Scalars['String']>;
  externalIDGTE?: InputMaybe<Scalars['String']>;
  externalIDHasPrefix?: InputMaybe<Scalars['String']>;
  externalIDHasSuffix?: InputMaybe<Scalars['String']>;
  externalIDIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDIsNil?: InputMaybe<Scalars['Boolean']>;
  externalIDLT?: InputMaybe<Scalars['String']>;
  externalIDLTE?: InputMaybe<Scalars['String']>;
  externalIDNEQ?: InputMaybe<Scalars['String']>;
  externalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** product edge predicates */
  hasProduct?: InputMaybe<Scalars['Boolean']>;
  /** product_variant edge predicates */
  hasProductVariant?: InputMaybe<Scalars['Boolean']>;
  hasProductVariantWith?: InputMaybe<Array<ProductVariantWhereInput>>;
  hasProductWith?: InputMaybe<Array<ProductWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ProductImageWhereInput>;
  or?: InputMaybe<Array<ProductImageWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** url field predicates */
  url?: InputMaybe<Scalars['String']>;
  urlContains?: InputMaybe<Scalars['String']>;
  urlContainsFold?: InputMaybe<Scalars['String']>;
  urlEqualFold?: InputMaybe<Scalars['String']>;
  urlGT?: InputMaybe<Scalars['String']>;
  urlGTE?: InputMaybe<Scalars['String']>;
  urlHasPrefix?: InputMaybe<Scalars['String']>;
  urlHasSuffix?: InputMaybe<Scalars['String']>;
  urlIn?: InputMaybe<Array<Scalars['String']>>;
  urlLT?: InputMaybe<Scalars['String']>;
  urlLTE?: InputMaybe<Scalars['String']>;
  urlNEQ?: InputMaybe<Scalars['String']>;
  urlNotIn?: InputMaybe<Array<Scalars['String']>>;
};

/** ProductStatus is enum for the field status */
export enum ProductStatus {
  Active = 'active',
  Archived = 'archived',
  Draft = 'draft'
}

export type ProductTag = Node & {
  createdAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  products?: Maybe<Array<Product>>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ProductTagConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductTagEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ProductTagEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ProductTag>;
};

/**
 * ProductTagWhereInput is used for filtering ProductTag objects.
 * Input was generated by ent.
 */
export type ProductTagWhereInput = {
  and?: InputMaybe<Array<ProductTagWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** products edge predicates */
  hasProducts?: InputMaybe<Scalars['Boolean']>;
  hasProductsWith?: InputMaybe<Array<ProductWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ProductTagWhereInput>;
  or?: InputMaybe<Array<ProductTagWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ProductVariant = Node & {
  archived: Scalars['Boolean'];
  createdAt?: Maybe<Scalars['Time']>;
  description?: Maybe<Scalars['String']>;
  dimensionHeight?: Maybe<Scalars['Int']>;
  dimensionLength?: Maybe<Scalars['Int']>;
  dimensionWidth?: Maybe<Scalars['Int']>;
  eanNumber?: Maybe<Scalars['String']>;
  externalID?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  inventoryItem?: Maybe<InventoryItem>;
  orderLines?: Maybe<Array<OrderLine>>;
  product: Product;
  productImage?: Maybe<Array<ProductImage>>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  updatedAt: Scalars['Time'];
  weightG?: Maybe<Scalars['Int']>;
};

/** A connection to a list of items. */
export type ProductVariantConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ProductVariantEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ProductVariantEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ProductVariant>;
};

export type ProductVariantImageInput = {
  imageID: Scalars['ID'];
  variantIDs: Array<Scalars['ID']>;
};

export type ProductVariantQuantity = {
  currency: Scalars['String'];
  discount: Scalars['Float'];
  orderLineID: Scalars['ID'];
  price: Scalars['Float'];
  units: Scalars['Int'];
  variantID: Scalars['ID'];
};

/**
 * ProductVariantWhereInput is used for filtering ProductVariant objects.
 * Input was generated by ent.
 */
export type ProductVariantWhereInput = {
  and?: InputMaybe<Array<ProductVariantWhereInput>>;
  /** archived field predicates */
  archived?: InputMaybe<Scalars['Boolean']>;
  archivedNEQ?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionIsNil?: InputMaybe<Scalars['Boolean']>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionNotNil?: InputMaybe<Scalars['Boolean']>;
  /** dimension_height field predicates */
  dimensionHeight?: InputMaybe<Scalars['Int']>;
  dimensionHeightGT?: InputMaybe<Scalars['Int']>;
  dimensionHeightGTE?: InputMaybe<Scalars['Int']>;
  dimensionHeightIn?: InputMaybe<Array<Scalars['Int']>>;
  dimensionHeightIsNil?: InputMaybe<Scalars['Boolean']>;
  dimensionHeightLT?: InputMaybe<Scalars['Int']>;
  dimensionHeightLTE?: InputMaybe<Scalars['Int']>;
  dimensionHeightNEQ?: InputMaybe<Scalars['Int']>;
  dimensionHeightNotIn?: InputMaybe<Array<Scalars['Int']>>;
  dimensionHeightNotNil?: InputMaybe<Scalars['Boolean']>;
  /** dimension_length field predicates */
  dimensionLength?: InputMaybe<Scalars['Int']>;
  dimensionLengthGT?: InputMaybe<Scalars['Int']>;
  dimensionLengthGTE?: InputMaybe<Scalars['Int']>;
  dimensionLengthIn?: InputMaybe<Array<Scalars['Int']>>;
  dimensionLengthIsNil?: InputMaybe<Scalars['Boolean']>;
  dimensionLengthLT?: InputMaybe<Scalars['Int']>;
  dimensionLengthLTE?: InputMaybe<Scalars['Int']>;
  dimensionLengthNEQ?: InputMaybe<Scalars['Int']>;
  dimensionLengthNotIn?: InputMaybe<Array<Scalars['Int']>>;
  dimensionLengthNotNil?: InputMaybe<Scalars['Boolean']>;
  /** dimension_width field predicates */
  dimensionWidth?: InputMaybe<Scalars['Int']>;
  dimensionWidthGT?: InputMaybe<Scalars['Int']>;
  dimensionWidthGTE?: InputMaybe<Scalars['Int']>;
  dimensionWidthIn?: InputMaybe<Array<Scalars['Int']>>;
  dimensionWidthIsNil?: InputMaybe<Scalars['Boolean']>;
  dimensionWidthLT?: InputMaybe<Scalars['Int']>;
  dimensionWidthLTE?: InputMaybe<Scalars['Int']>;
  dimensionWidthNEQ?: InputMaybe<Scalars['Int']>;
  dimensionWidthNotIn?: InputMaybe<Array<Scalars['Int']>>;
  dimensionWidthNotNil?: InputMaybe<Scalars['Boolean']>;
  /** ean_number field predicates */
  eanNumber?: InputMaybe<Scalars['String']>;
  eanNumberContains?: InputMaybe<Scalars['String']>;
  eanNumberContainsFold?: InputMaybe<Scalars['String']>;
  eanNumberEqualFold?: InputMaybe<Scalars['String']>;
  eanNumberGT?: InputMaybe<Scalars['String']>;
  eanNumberGTE?: InputMaybe<Scalars['String']>;
  eanNumberHasPrefix?: InputMaybe<Scalars['String']>;
  eanNumberHasSuffix?: InputMaybe<Scalars['String']>;
  eanNumberIn?: InputMaybe<Array<Scalars['String']>>;
  eanNumberIsNil?: InputMaybe<Scalars['Boolean']>;
  eanNumberLT?: InputMaybe<Scalars['String']>;
  eanNumberLTE?: InputMaybe<Scalars['String']>;
  eanNumberNEQ?: InputMaybe<Scalars['String']>;
  eanNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  eanNumberNotNil?: InputMaybe<Scalars['Boolean']>;
  /** external_ID field predicates */
  externalID?: InputMaybe<Scalars['String']>;
  externalIDContains?: InputMaybe<Scalars['String']>;
  externalIDContainsFold?: InputMaybe<Scalars['String']>;
  externalIDEqualFold?: InputMaybe<Scalars['String']>;
  externalIDGT?: InputMaybe<Scalars['String']>;
  externalIDGTE?: InputMaybe<Scalars['String']>;
  externalIDHasPrefix?: InputMaybe<Scalars['String']>;
  externalIDHasSuffix?: InputMaybe<Scalars['String']>;
  externalIDIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDIsNil?: InputMaybe<Scalars['Boolean']>;
  externalIDLT?: InputMaybe<Scalars['String']>;
  externalIDLTE?: InputMaybe<Scalars['String']>;
  externalIDNEQ?: InputMaybe<Scalars['String']>;
  externalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** inventory_item edge predicates */
  hasInventoryItem?: InputMaybe<Scalars['Boolean']>;
  hasInventoryItemWith?: InputMaybe<Array<InventoryItemWhereInput>>;
  /** order_lines edge predicates */
  hasOrderLines?: InputMaybe<Scalars['Boolean']>;
  hasOrderLinesWith?: InputMaybe<Array<OrderLineWhereInput>>;
  /** product edge predicates */
  hasProduct?: InputMaybe<Scalars['Boolean']>;
  /** product_image edge predicates */
  hasProductImage?: InputMaybe<Scalars['Boolean']>;
  hasProductImageWith?: InputMaybe<Array<ProductImageWhereInput>>;
  hasProductWith?: InputMaybe<Array<ProductWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ProductVariantWhereInput>;
  or?: InputMaybe<Array<ProductVariantWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** weight_g field predicates */
  weightG?: InputMaybe<Scalars['Int']>;
  weightGGT?: InputMaybe<Scalars['Int']>;
  weightGGTE?: InputMaybe<Scalars['Int']>;
  weightGIn?: InputMaybe<Array<Scalars['Int']>>;
  weightGIsNil?: InputMaybe<Scalars['Boolean']>;
  weightGLT?: InputMaybe<Scalars['Int']>;
  weightGLTE?: InputMaybe<Scalars['Int']>;
  weightGNEQ?: InputMaybe<Scalars['Int']>;
  weightGNotIn?: InputMaybe<Array<Scalars['Int']>>;
  weightGNotNil?: InputMaybe<Scalars['Boolean']>;
};

/**
 * ProductWhereInput is used for filtering Product objects.
 * Input was generated by ent.
 */
export type ProductWhereInput = {
  and?: InputMaybe<Array<ProductWhereInput>>;
  /** body_html field predicates */
  bodyHTML?: InputMaybe<Scalars['String']>;
  bodyHTMLContains?: InputMaybe<Scalars['String']>;
  bodyHTMLContainsFold?: InputMaybe<Scalars['String']>;
  bodyHTMLEqualFold?: InputMaybe<Scalars['String']>;
  bodyHTMLGT?: InputMaybe<Scalars['String']>;
  bodyHTMLGTE?: InputMaybe<Scalars['String']>;
  bodyHTMLHasPrefix?: InputMaybe<Scalars['String']>;
  bodyHTMLHasSuffix?: InputMaybe<Scalars['String']>;
  bodyHTMLIn?: InputMaybe<Array<Scalars['String']>>;
  bodyHTMLIsNil?: InputMaybe<Scalars['Boolean']>;
  bodyHTMLLT?: InputMaybe<Scalars['String']>;
  bodyHTMLLTE?: InputMaybe<Scalars['String']>;
  bodyHTMLNEQ?: InputMaybe<Scalars['String']>;
  bodyHTMLNotIn?: InputMaybe<Array<Scalars['String']>>;
  bodyHTMLNotNil?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** external_id field predicates */
  externalID?: InputMaybe<Scalars['String']>;
  externalIDContains?: InputMaybe<Scalars['String']>;
  externalIDContainsFold?: InputMaybe<Scalars['String']>;
  externalIDEqualFold?: InputMaybe<Scalars['String']>;
  externalIDGT?: InputMaybe<Scalars['String']>;
  externalIDGTE?: InputMaybe<Scalars['String']>;
  externalIDHasPrefix?: InputMaybe<Scalars['String']>;
  externalIDHasSuffix?: InputMaybe<Scalars['String']>;
  externalIDIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDIsNil?: InputMaybe<Scalars['Boolean']>;
  externalIDLT?: InputMaybe<Scalars['String']>;
  externalIDLTE?: InputMaybe<Scalars['String']>;
  externalIDNEQ?: InputMaybe<Scalars['String']>;
  externalIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  externalIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** product_image edge predicates */
  hasProductImage?: InputMaybe<Scalars['Boolean']>;
  hasProductImageWith?: InputMaybe<Array<ProductImageWhereInput>>;
  /** product_tags edge predicates */
  hasProductTags?: InputMaybe<Scalars['Boolean']>;
  hasProductTagsWith?: InputMaybe<Array<ProductTagWhereInput>>;
  /** product_variant edge predicates */
  hasProductVariant?: InputMaybe<Scalars['Boolean']>;
  hasProductVariantWith?: InputMaybe<Array<ProductVariantWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ProductWhereInput>;
  or?: InputMaybe<Array<ProductWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<ProductStatus>;
  statusIn?: InputMaybe<Array<ProductStatus>>;
  statusNEQ?: InputMaybe<ProductStatus>;
  statusNotIn?: InputMaybe<Array<ProductStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** title field predicates */
  title?: InputMaybe<Scalars['String']>;
  titleContains?: InputMaybe<Scalars['String']>;
  titleContainsFold?: InputMaybe<Scalars['String']>;
  titleEqualFold?: InputMaybe<Scalars['String']>;
  titleGT?: InputMaybe<Scalars['String']>;
  titleGTE?: InputMaybe<Scalars['String']>;
  titleHasPrefix?: InputMaybe<Scalars['String']>;
  titleHasSuffix?: InputMaybe<Scalars['String']>;
  titleIn?: InputMaybe<Array<Scalars['String']>>;
  titleLT?: InputMaybe<Scalars['String']>;
  titleLTE?: InputMaybe<Scalars['String']>;
  titleNEQ?: InputMaybe<Scalars['String']>;
  titleNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Query = {
  accessRights: AccessRightConnection;
  addReturnDeliveryOption: Scalars['ID'];
  addressGlobals: AddressGlobalConnection;
  addresses: AddressConnection;
  allLocationsIn: Array<Location>;
  apiTokens: ApiTokenConnection;
  availableAdditionalServicesPostNord: Array<Scalars['String']>;
  availableAdditionalServicesUSPS: Array<CarrierAdditionalServiceUsps>;
  availableDeliveryPoints: Array<DeliveryPoint>;
  availableTenants: Array<Tenant>;
  buildInfo: BuildInfo;
  businessHoursPeriods: BusinessHoursPeriodConnection;
  carrier?: Maybe<Carrier>;
  carrierAdditionalServiceBrings: CarrierAdditionalServiceBringConnection;
  carrierAdditionalServiceDaOs: CarrierAdditionalServiceDaoConnection;
  carrierAdditionalServiceDfs: CarrierAdditionalServiceDfConnection;
  carrierAdditionalServiceDsVs: CarrierAdditionalServiceDsvConnection;
  carrierAdditionalServiceEasyPosts: CarrierAdditionalServiceEasyPostConnection;
  carrierAdditionalServiceGlSs: CarrierAdditionalServiceGlsConnection;
  carrierAdditionalServicePostNords: CarrierAdditionalServicePostNordConnection;
  carrierAdditionalServiceUspSs: CarrierAdditionalServiceUspsConnection;
  carrierBrands: CarrierBrandConnection;
  carrierBrings: CarrierBringConnection;
  carrierDaOs: CarrierDaoConnection;
  carrierDfs: CarrierDfConnection;
  carrierDsVs: CarrierDsvConnection;
  carrierEasyPosts: CarrierEasyPostConnection;
  carrierGLS?: Maybe<CarrierGls>;
  carrierGlSs: CarrierGlsConnection;
  carrierPostNord?: Maybe<CarrierPostNord>;
  carrierPostNords: CarrierPostNordConnection;
  carrierServiceBrings: CarrierServiceBringConnection;
  carrierServiceDaOs: CarrierServiceDaoConnection;
  carrierServiceDfs: CarrierServiceDfConnection;
  carrierServiceDsVs: CarrierServiceDsvConnection;
  carrierServiceEasyPosts: Array<CarrierServiceEasyPost>;
  carrierServiceGlSs: Array<CarrierServiceGls>;
  carrierServicePostNords: Array<CarrierServicePostNord>;
  carrierServices: CarrierServiceConnection;
  carrierUSPS?: Maybe<CarrierUsps>;
  carrierUspSs: CarrierUspsConnection;
  carriers: CarrierConnection;
  changeHistories: ChangeHistoryConnection;
  clickCollectLocation?: Maybe<Location>;
  colli?: Maybe<Colli>;
  collis: ColliConnection;
  connectOptionCarriers: ConnectOptionCarrierConnection;
  connectOptionPlatforms: ConnectOptionPlatformConnection;
  connection?: Maybe<Connection>;
  connectionBrands: ConnectionBrandConnection;
  connectionList: Array<Maybe<ConnectionListItem>>;
  connectionLookups: ConnectionLookupConnection;
  connectionShopifies: ConnectionShopifyConnection;
  connectionShopify?: Maybe<ConnectionShopify>;
  connections: ConnectionConnection;
  consolidation: Consolidation;
  consolidationShipments: ConsolidationShipmentStatus;
  consolidations: ConsolidationConnection;
  constraintGroup?: Maybe<DeliveryRuleConstraintGroup>;
  constraints?: Maybe<Array<DeliveryRuleConstraintWithTags>>;
  contacts: ContactConnection;
  countries: CountryConnection;
  country?: Maybe<Country>;
  countryHarmonizedCodes: CountryHarmonizedCodeConnection;
  createConsolidationShipment: CreateShipmentConsolidationResponse;
  createLabelsPrintJob: Scalars['Boolean'];
  createPackingListPrintJob: Scalars['Boolean'];
  createShipments: CreateShipmentsResponse;
  currencies: CurrencyConnection;
  dashboardTiles: Array<DashboardTile>;
  deliveryOptionBring?: Maybe<DeliveryOptionBring>;
  deliveryOptionBrings: DeliveryOptionBringConnection;
  deliveryOptionDAO?: Maybe<DeliveryOptionDao>;
  deliveryOptionDF?: Maybe<DeliveryOptionDf>;
  deliveryOptionDSV?: Maybe<DeliveryOptionDsv>;
  deliveryOptionDaOs: DeliveryOptionDaoConnection;
  deliveryOptionDfs: DeliveryOptionDfConnection;
  deliveryOptionDsVs: DeliveryOptionDsvConnection;
  deliveryOptionEasyPost?: Maybe<DeliveryOptionEasyPost>;
  deliveryOptionEasyPosts: DeliveryOptionEasyPostConnection;
  deliveryOptionGLS?: Maybe<DeliveryOptionGls>;
  deliveryOptionGlSs: DeliveryOptionGlsConnection;
  deliveryOptionPostNord?: Maybe<DeliveryOptionPostNord>;
  deliveryOptionPostNords: DeliveryOptionPostNordConnection;
  deliveryOptionUSPS?: Maybe<DeliveryOptionUsps>;
  deliveryOptionUspSs: DeliveryOptionUspsConnection;
  deliveryOptions: DeliveryOptionConnection;
  deliveryOptionsFiltered: Array<DeliveryOption>;
  deliveryOptionsList: Array<Maybe<DeliveryOptionBrandName>>;
  deliveryPoint?: Maybe<DeliveryPoint>;
  deliveryRuleConstraintGroups: DeliveryRuleConstraintGroupConnection;
  deliveryRuleConstraints: DeliveryRuleConstraintConnection;
  deliveryRules: DeliveryRuleConnection;
  devicePing: Scalars['Boolean'];
  document: Document;
  documentDownload: DocumentDownload;
  documentFiles: DocumentFileConnection;
  documents: DocumentConnection;
  emailTemplate: EmailTemplate;
  emailTemplates: EmailTemplateConnection;
  filteredWorkstations: Array<Workstation>;
  historyLogs: HistoryLog;
  hypothesisTest: HypothesisTest;
  hypothesisTestDeliveryOptionLookups: HypothesisTestDeliveryOptionLookupConnection;
  hypothesisTestDeliveryOptionRequests: HypothesisTestDeliveryOptionRequestConnection;
  hypothesisTestDeliveryOptions: HypothesisTestDeliveryOptionConnection;
  hypothesisTestResultsDashboard: Array<DashboardHypothesisTestResult>;
  hypothesisTests: HypothesisTestConnection;
  inventoryItems: InventoryItemConnection;
  languages: LanguageConnection;
  location?: Maybe<Location>;
  locationTags: LocationTagConnection;
  locations: LocationConnection;
  myAPITokens: Array<ApiToken>;
  /** Fetches an object given its ID. */
  node?: Maybe<Node>;
  /** Lookup nodes by a list of IDs. */
  nodes: Array<Maybe<Node>>;
  notifications: NotificationConnection;
  order?: Maybe<Order>;
  orderSenders: OrderSenderConnection;
  orderShipments?: Maybe<OrderShipmentStatus>;
  orderTimeline: Array<Maybe<ChangeHistory>>;
  orders: OrderConnection;
  packagingDfs: PackagingDfConnection;
  packagingFiltered: Array<Packaging>;
  packagingUSPSProcessingCategories: PackagingUspsProcessingCategoryConnection;
  packagingUSPSRateIndicators: PackagingUspsRateIndicatorConnection;
  packagingUspSs: PackagingUspsConnection;
  packagings: PackagingConnection;
  packingSlips: PackingSlipsOutput;
  packingSlipsByOrder: PackingSlipsOutput;
  packingSlipsClearCache: Scalars['Boolean'];
  pallets: PalletConnection;
  parcelShopBrings: ParcelShopBringConnection;
  parcelShopDaOs: ParcelShopDaoConnection;
  parcelShopGlSs: ParcelShopGlsConnection;
  parcelShopPostNords: ParcelShopPostNordConnection;
  parcelShops: ParcelShopConnection;
  plans: PlanConnection;
  printers: PrinterConnection;
  product?: Maybe<Product>;
  productImages: ProductImageConnection;
  productTags: ProductTagConnection;
  productVariants: ProductVariantConnection;
  products: ProductConnection;
  rateRequests: RateRequests;
  returnClaimsByOrder: Array<ReturnPortalClaim>;
  returnColli: ReturnColliEdit;
  returnColliHistories: ReturnColliHistoryConnection;
  returnCollis: ReturnColliConnection;
  returnDeliveryOptions: Array<Maybe<Array<Maybe<DeliveryOptionBrandName>>>>;
  returnOrderLines: ReturnOrderLineConnection;
  returnPortal: ReturnPortal;
  returnPortalClaims: ReturnPortalClaimConnection;
  returnPortals: ReturnPortalConnection;
  search: Array<SearchResult>;
  seatGroup?: Maybe<SeatGroup>;
  seatGroupAccessRights: SeatGroupAccessRightConnection;
  seatGroups: SeatGroupConnection;
  selectedWorkstation?: Maybe<SelectedWorkstation>;
  sendOverviewEmail: Scalars['Boolean'];
  sendTestEmail: Scalars['Boolean'];
  shipment: Shipment;
  shipmentBrings: ShipmentBringConnection;
  shipmentDaOs: ShipmentDaoConnection;
  shipmentDfs: ShipmentDfConnection;
  shipmentDsVs: ShipmentDsvConnection;
  shipmentEasyPosts: ShipmentEasyPostConnection;
  shipmentGlSs: ShipmentGlsConnection;
  shipmentLabels: ShipmentLabelsResponse;
  shipmentPallets: ShipmentPalletConnection;
  shipmentParcels: ShipmentParcelConnection;
  shipmentPostNords: ShipmentPostNordConnection;
  shipmentUspSs: ShipmentUspsConnection;
  shipments: ShipmentConnection;
  shipmentsList?: Maybe<Array<ShipmentListItem>>;
  signupOptionsSlice: SignupOptionsConnection;
  systemEventsSlice: SystemEventsConnection;
  tenant?: Maybe<Tenant>;
  tenants: TenantConnection;
  trailingProductUpdates: Array<Scalars['Int']>;
  unassignedDeliveryOptions: Array<DeliveryOption>;
  user?: Maybe<User>;
  userSeats: UserSeatConnection;
  users: UserConnection;
  workstation: Workstation;
  workstations: WorkstationConnection;
};


export type QueryAccessRightsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AccessRightWhereInput>;
};


export type QueryAddReturnDeliveryOptionArgs = {
  deliveryOptions: Array<MutateReturnDeliveryOption>;
};


export type QueryAddressGlobalsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AddressGlobalWhereInput>;
};


export type QueryAddressesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<AddressWhereInput>;
};


export type QueryAllLocationsInArgs = {
  country?: InputMaybe<Scalars['ID']>;
};


export type QueryApiTokensArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ApiTokenWhereInput>;
};


export type QueryAvailableAdditionalServicesPostNordArgs = {
  carrierServiceID: Scalars['ID'];
};


export type QueryAvailableAdditionalServicesUspsArgs = {
  carrierServiceID: Scalars['ID'];
};


export type QueryAvailableDeliveryPointsArgs = {
  address?: InputMaybe<CreateAddressInput>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
};


export type QueryBusinessHoursPeriodsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<BusinessHoursPeriodWhereInput>;
};


export type QueryCarrierArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryCarrierAdditionalServiceBringsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierAdditionalServiceBringWhereInput>;
};


export type QueryCarrierAdditionalServiceDaOsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierAdditionalServiceDaoWhereInput>;
};


export type QueryCarrierAdditionalServiceDfsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierAdditionalServiceDfWhereInput>;
};


export type QueryCarrierAdditionalServiceDsVsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierAdditionalServiceDsvWhereInput>;
};


export type QueryCarrierAdditionalServiceEasyPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierAdditionalServiceEasyPostWhereInput>;
};


export type QueryCarrierAdditionalServiceGlSsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierAdditionalServiceGlsWhereInput>;
};


export type QueryCarrierAdditionalServicePostNordsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierAdditionalServicePostNordWhereInput>;
};


export type QueryCarrierAdditionalServiceUspSsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierAdditionalServiceUspsWhereInput>;
};


export type QueryCarrierBrandsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierBrandWhereInput>;
};


export type QueryCarrierBringsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierBringWhereInput>;
};


export type QueryCarrierDaOsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierDaoWhereInput>;
};


export type QueryCarrierDfsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierDfWhereInput>;
};


export type QueryCarrierDsVsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierDsvWhereInput>;
};


export type QueryCarrierEasyPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierEasyPostWhereInput>;
};


export type QueryCarrierGlsArgs = {
  id: Scalars['ID'];
};


export type QueryCarrierGlSsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierGlsWhereInput>;
};


export type QueryCarrierPostNordArgs = {
  id: Scalars['ID'];
};


export type QueryCarrierPostNordsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierPostNordWhereInput>;
};


export type QueryCarrierServiceBringsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierServiceBringWhereInput>;
};


export type QueryCarrierServiceDaOsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierServiceDaoWhereInput>;
};


export type QueryCarrierServiceDfsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierServiceDfWhereInput>;
};


export type QueryCarrierServiceDsVsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierServiceDsvWhereInput>;
};


export type QueryCarrierServicesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierServiceWhereInput>;
};


export type QueryCarrierUspsArgs = {
  id: Scalars['ID'];
};


export type QueryCarrierUspSsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierUspsWhereInput>;
};


export type QueryCarriersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CarrierWhereInput>;
};


export type QueryChangeHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ChangeHistoryOrder>;
  where?: InputMaybe<ChangeHistoryWhereInput>;
};


export type QueryClickCollectLocationArgs = {
  colliID: Scalars['ID'];
};


export type QueryColliArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryCollisArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ColliWhereInput>;
};


export type QueryConnectOptionCarriersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ConnectOptionCarrierWhereInput>;
};


export type QueryConnectOptionPlatformsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ConnectOptionPlatformWhereInput>;
};


export type QueryConnectionArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryConnectionBrandsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ConnectionBrandWhereInput>;
};


export type QueryConnectionLookupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ConnectionLookupOrder>;
  where?: InputMaybe<ConnectionLookupWhereInput>;
};


export type QueryConnectionShopifiesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ConnectionShopifyWhereInput>;
};


export type QueryConnectionShopifyArgs = {
  id: Scalars['ID'];
};


export type QueryConnectionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ConnectionWhereInput>;
};


export type QueryConsolidationArgs = {
  id: Scalars['ID'];
};


export type QueryConsolidationShipmentsArgs = {
  consolidationID: Scalars['ID'];
};


export type QueryConsolidationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ConsolidationOrder>;
  where?: InputMaybe<ConsolidationWhereInput>;
};


export type QueryConstraintGroupArgs = {
  id: Scalars['ID'];
};


export type QueryConstraintsArgs = {
  groupID: Scalars['ID'];
};


export type QueryContactsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ContactWhereInput>;
};


export type QueryCountriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CountryWhereInput>;
};


export type QueryCountryArgs = {
  id: Scalars['ID'];
};


export type QueryCountryHarmonizedCodesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CountryHarmonizedCodeWhereInput>;
};


export type QueryCreateConsolidationShipmentArgs = {
  consolidationID: Scalars['ID'];
  prebook: Scalars['Boolean'];
};


export type QueryCreateLabelsPrintJobArgs = {
  colliIDs: Array<Scalars['ID']>;
};


export type QueryCreatePackingListPrintJobArgs = {
  colliIDs: Array<Scalars['ID']>;
};


export type QueryCreateShipmentsArgs = {
  orderID: Scalars['ID'];
  packageIDs: Array<Scalars['ID']>;
};


export type QueryCurrenciesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<CurrencyWhereInput>;
};


export type QueryDeliveryOptionBringArgs = {
  id: Scalars['ID'];
};


export type QueryDeliveryOptionBringsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryOptionBringWhereInput>;
};


export type QueryDeliveryOptionDaoArgs = {
  id: Scalars['ID'];
};


export type QueryDeliveryOptionDfArgs = {
  id: Scalars['ID'];
};


export type QueryDeliveryOptionDsvArgs = {
  id: Scalars['ID'];
};


export type QueryDeliveryOptionDaOsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryOptionDaoWhereInput>;
};


export type QueryDeliveryOptionDfsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryOptionDfWhereInput>;
};


export type QueryDeliveryOptionDsVsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryOptionDsvWhereInput>;
};


export type QueryDeliveryOptionEasyPostArgs = {
  id: Scalars['ID'];
};


export type QueryDeliveryOptionEasyPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryOptionEasyPostWhereInput>;
};


export type QueryDeliveryOptionGlsArgs = {
  id: Scalars['ID'];
};


export type QueryDeliveryOptionGlSsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryOptionGlsWhereInput>;
};


export type QueryDeliveryOptionPostNordArgs = {
  deliveryOptionID: Scalars['ID'];
};


export type QueryDeliveryOptionPostNordsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryOptionPostNordWhereInput>;
};


export type QueryDeliveryOptionUspsArgs = {
  deliveryOptionID: Scalars['ID'];
};


export type QueryDeliveryOptionUspSsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryOptionUspsWhereInput>;
};


export type QueryDeliveryOptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryOptionWhereInput>;
};


export type QueryDeliveryOptionsFilteredArgs = {
  showArchived: Scalars['Boolean'];
};


export type QueryDeliveryOptionsListArgs = {
  orderInfo: DeliveryOptionSeedInput;
};


export type QueryDeliveryPointArgs = {
  colliID: Scalars['ID'];
};


export type QueryDeliveryRuleConstraintGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryRuleConstraintGroupWhereInput>;
};


export type QueryDeliveryRuleConstraintsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryRuleConstraintWhereInput>;
};


export type QueryDeliveryRulesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DeliveryRuleWhereInput>;
};


export type QueryDevicePingArgs = {
  token: Scalars['String'];
};


export type QueryDocumentArgs = {
  id: Scalars['ID'];
};


export type QueryDocumentDownloadArgs = {
  id: Scalars['ID'];
};


export type QueryDocumentFilesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DocumentFileWhereInput>;
};


export type QueryDocumentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<DocumentWhereInput>;
};


export type QueryEmailTemplateArgs = {
  id: Scalars['ID'];
};


export type QueryEmailTemplatesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<EmailTemplateWhereInput>;
};


export type QueryFilteredWorkstationsArgs = {
  showArchived: Scalars['Boolean'];
};


export type QueryHypothesisTestArgs = {
  id: Scalars['ID'];
};


export type QueryHypothesisTestDeliveryOptionLookupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<HypothesisTestDeliveryOptionLookupWhereInput>;
};


export type QueryHypothesisTestDeliveryOptionRequestsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<HypothesisTestDeliveryOptionRequestWhereInput>;
};


export type QueryHypothesisTestDeliveryOptionsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<HypothesisTestDeliveryOptionWhereInput>;
};


export type QueryHypothesisTestsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<HypothesisTestWhereInput>;
};


export type QueryInventoryItemsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<InventoryItemWhereInput>;
};


export type QueryLanguagesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LanguageWhereInput>;
};


export type QueryLocationArgs = {
  id: Scalars['ID'];
};


export type QueryLocationTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LocationTagWhereInput>;
};


export type QueryLocationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<LocationWhereInput>;
};


export type QueryNodeArgs = {
  id: Scalars['ID'];
};


export type QueryNodesArgs = {
  ids: Array<Scalars['ID']>;
};


export type QueryNotificationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<NotificationWhereInput>;
};


export type QueryOrderArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryOrderSendersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<OrderSenderWhereInput>;
};


export type QueryOrderShipmentsArgs = {
  orderID: Scalars['ID'];
};


export type QueryOrderTimelineArgs = {
  orderID: Scalars['ID'];
};


export type QueryOrdersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<OrderOrder>;
  where?: InputMaybe<OrderWhereInput>;
};


export type QueryPackagingDfsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PackagingDfWhereInput>;
};


export type QueryPackagingFilteredArgs = {
  showArchived: Scalars['Boolean'];
};


export type QueryPackagingUspsProcessingCategoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PackagingUspsProcessingCategoryWhereInput>;
};


export type QueryPackagingUspsRateIndicatorsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PackagingUspsRateIndicatorWhereInput>;
};


export type QueryPackagingUspSsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PackagingUspsWhereInput>;
};


export type QueryPackagingsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PackagingWhereInput>;
};


export type QueryPackingSlipsArgs = {
  colliIDs: Array<Scalars['ID']>;
};


export type QueryPackingSlipsByOrderArgs = {
  orderIDs: Array<Scalars['ID']>;
};


export type QueryPackingSlipsClearCacheArgs = {
  orderIDs: Array<Scalars['ID']>;
};


export type QueryPalletsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PalletWhereInput>;
};


export type QueryParcelShopBringsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ParcelShopBringWhereInput>;
};


export type QueryParcelShopDaOsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ParcelShopDaoWhereInput>;
};


export type QueryParcelShopGlSsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ParcelShopGlsWhereInput>;
};


export type QueryParcelShopPostNordsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ParcelShopPostNordWhereInput>;
};


export type QueryParcelShopsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ParcelShopWhereInput>;
};


export type QueryPlansArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PlanWhereInput>;
};


export type QueryPrintersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<PrinterWhereInput>;
};


export type QueryProductArgs = {
  id: Scalars['ID'];
};


export type QueryProductImagesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProductImageWhereInput>;
};


export type QueryProductTagsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProductTagWhereInput>;
};


export type QueryProductVariantsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProductVariantWhereInput>;
};


export type QueryProductsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ProductWhereInput>;
};


export type QueryReturnClaimsByOrderArgs = {
  orderID: Scalars['ID'];
};


export type QueryReturnColliArgs = {
  orderID: Scalars['ID'];
};


export type QueryReturnColliHistoriesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ReturnColliHistoryWhereInput>;
};


export type QueryReturnCollisArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ReturnColliOrder>;
  where?: InputMaybe<ReturnColliWhereInput>;
};


export type QueryReturnDeliveryOptionsArgs = {
  returnColliIDs: Array<Scalars['ID']>;
};


export type QueryReturnOrderLinesArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ReturnOrderLineWhereInput>;
};


export type QueryReturnPortalArgs = {
  id: Scalars['ID'];
};


export type QueryReturnPortalClaimsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ReturnPortalClaimWhereInput>;
};


export type QueryReturnPortalsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ReturnPortalWhereInput>;
};


export type QuerySearchArgs = {
  filter?: InputMaybe<Array<EntityType>>;
  term: Scalars['String'];
};


export type QuerySeatGroupArgs = {
  id: Scalars['ID'];
};


export type QuerySeatGroupAccessRightsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SeatGroupAccessRightWhereInput>;
};


export type QuerySeatGroupsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SeatGroupWhereInput>;
};


export type QuerySendOverviewEmailArgs = {
  emailTpl: Scalars['ID'];
  to: Scalars['String'];
  where: ShipmentWhereInput;
};


export type QuerySendTestEmailArgs = {
  id: Scalars['ID'];
  toEmail: Scalars['String'];
};


export type QueryShipmentArgs = {
  id: Scalars['ID'];
};


export type QueryShipmentBringsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ShipmentBringWhereInput>;
};


export type QueryShipmentDaOsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ShipmentDaoWhereInput>;
};


export type QueryShipmentDfsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ShipmentDfWhereInput>;
};


export type QueryShipmentDsVsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ShipmentDsvWhereInput>;
};


export type QueryShipmentEasyPostsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ShipmentEasyPostWhereInput>;
};


export type QueryShipmentGlSsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ShipmentGlsWhereInput>;
};


export type QueryShipmentLabelsArgs = {
  colliIDs: Array<Scalars['ID']>;
};


export type QueryShipmentPalletsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ShipmentPalletWhereInput>;
};


export type QueryShipmentParcelsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ShipmentParcelOrder>;
  where?: InputMaybe<ShipmentParcelWhereInput>;
};


export type QueryShipmentPostNordsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ShipmentPostNordWhereInput>;
};


export type QueryShipmentUspSsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ShipmentUspsWhereInput>;
};


export type QueryShipmentsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  orderBy?: InputMaybe<ShipmentOrder>;
  where?: InputMaybe<ShipmentWhereInput>;
};


export type QueryShipmentsListArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<ShipmentWhereInput>;
};


export type QuerySignupOptionsSliceArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SignupOptionsWhereInput>;
};


export type QuerySystemEventsSliceArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<SystemEventsWhereInput>;
};


export type QueryTenantArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryTenantsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<TenantWhereInput>;
};


export type QueryUnassignedDeliveryOptionsArgs = {
  hypothesisTestID: Scalars['ID'];
};


export type QueryUserArgs = {
  id?: InputMaybe<Scalars['ID']>;
};


export type QueryUserSeatsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<UserSeatWhereInput>;
};


export type QueryUsersArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<UserWhereInput>;
};


export type QueryWorkstationArgs = {
  id: Scalars['ID'];
};


export type QueryWorkstationsArgs = {
  after?: InputMaybe<Scalars['Cursor']>;
  before?: InputMaybe<Scalars['Cursor']>;
  first?: InputMaybe<Scalars['Int']>;
  last?: InputMaybe<Scalars['Int']>;
  where?: InputMaybe<WorkstationWhereInput>;
};

export type RateRequest = {
  date: Scalars['String'];
  error?: Maybe<Scalars['String']>;
  optionCount: Scalars['Int'];
  req?: Maybe<Scalars['String']>;
};

export type RateRequests = {
  requests: Array<RateRequest>;
  requestsError: Array<RateRequest>;
};

export type ReturnColli = Node & {
  comment?: Maybe<Scalars['String']>;
  createdAt: Scalars['Time'];
  deliveryOption?: Maybe<DeliveryOption>;
  /** Timestamp of email successfully sent after status changed to accepted */
  emailAccepted?: Maybe<Scalars['Time']>;
  /** Timestamp of email successfully sent after status changed to pending */
  emailConfirmationLabel?: Maybe<Scalars['Time']>;
  /** Timestamp of email successfully sent after status changed to pending */
  emailConfirmationQrCode?: Maybe<Scalars['Time']>;
  /** Timestamp of email successfully sent after status changed to received */
  emailReceived?: Maybe<Scalars['Time']>;
  expectedAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  labelPdf?: Maybe<Scalars['String']>;
  labelPng?: Maybe<Scalars['String']>;
  order: Order;
  /** Allows packaging to be predefined for this colli and will be used for the return shipment parcel */
  packaging?: Maybe<Packaging>;
  qrCodePng?: Maybe<Scalars['String']>;
  recipient: Address;
  returnColliHistory?: Maybe<Array<ReturnColliHistory>>;
  returnOrderLine?: Maybe<Array<ReturnOrderLine>>;
  returnPortal: ReturnPortal;
  sender: Address;
  status: ReturnColliStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ReturnColliConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReturnColliEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ReturnColliEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ReturnColli>;
};

export type ReturnColliEdit = {
  collis: Array<ReturnColliTimeline>;
  order: Order;
};

export type ReturnColliHistory = Node & {
  changeHistory: ChangeHistory;
  description: Scalars['String'];
  id: Scalars['ID'];
  returnColli: ReturnColli;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  type: ReturnColliHistoryType;
};

/** A connection to a list of items. */
export type ReturnColliHistoryConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReturnColliHistoryEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ReturnColliHistoryEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ReturnColliHistory>;
};

/** ReturnColliHistoryType is enum for the field type */
export enum ReturnColliHistoryType {
  Create = 'create',
  Delete = 'delete',
  Notify = 'notify',
  Update = 'update'
}

/**
 * ReturnColliHistoryWhereInput is used for filtering ReturnColliHistory objects.
 * Input was generated by ent.
 */
export type ReturnColliHistoryWhereInput = {
  and?: InputMaybe<Array<ReturnColliHistoryWhereInput>>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** change_history edge predicates */
  hasChangeHistory?: InputMaybe<Scalars['Boolean']>;
  hasChangeHistoryWith?: InputMaybe<Array<ChangeHistoryWhereInput>>;
  /** return_colli edge predicates */
  hasReturnColli?: InputMaybe<Scalars['Boolean']>;
  hasReturnColliWith?: InputMaybe<Array<ReturnColliWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ReturnColliHistoryWhereInput>;
  or?: InputMaybe<Array<ReturnColliHistoryWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** type field predicates */
  type?: InputMaybe<ReturnColliHistoryType>;
  typeIn?: InputMaybe<Array<ReturnColliHistoryType>>;
  typeNEQ?: InputMaybe<ReturnColliHistoryType>;
  typeNotIn?: InputMaybe<Array<ReturnColliHistoryType>>;
};

/** Ordering options for ReturnColli connections */
export type ReturnColliOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order ReturnCollis. */
  field: ReturnColliOrderField;
};

/** Properties by which ReturnColli connections can be ordered. */
export enum ReturnColliOrderField {
  CreatedAt = 'CREATED_AT'
}

/** ReturnColliStatus is enum for the field status */
export enum ReturnColliStatus {
  Accepted = 'Accepted',
  Declined = 'Declined',
  Deleted = 'Deleted',
  Inbound = 'Inbound',
  Opened = 'Opened',
  Pending = 'Pending',
  Received = 'Received'
}

export type ReturnColliTimeline = {
  colli: ReturnColli;
  timeline: Array<ChangeHistory>;
};

/**
 * ReturnColliWhereInput is used for filtering ReturnColli objects.
 * Input was generated by ent.
 */
export type ReturnColliWhereInput = {
  and?: InputMaybe<Array<ReturnColliWhereInput>>;
  /** comment field predicates */
  comment?: InputMaybe<Scalars['String']>;
  commentContains?: InputMaybe<Scalars['String']>;
  commentContainsFold?: InputMaybe<Scalars['String']>;
  commentEqualFold?: InputMaybe<Scalars['String']>;
  commentGT?: InputMaybe<Scalars['String']>;
  commentGTE?: InputMaybe<Scalars['String']>;
  commentHasPrefix?: InputMaybe<Scalars['String']>;
  commentHasSuffix?: InputMaybe<Scalars['String']>;
  commentIn?: InputMaybe<Array<Scalars['String']>>;
  commentIsNil?: InputMaybe<Scalars['Boolean']>;
  commentLT?: InputMaybe<Scalars['String']>;
  commentLTE?: InputMaybe<Scalars['String']>;
  commentNEQ?: InputMaybe<Scalars['String']>;
  commentNotIn?: InputMaybe<Array<Scalars['String']>>;
  commentNotNil?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** email_accepted field predicates */
  emailAccepted?: InputMaybe<Scalars['Time']>;
  emailAcceptedGT?: InputMaybe<Scalars['Time']>;
  emailAcceptedGTE?: InputMaybe<Scalars['Time']>;
  emailAcceptedIn?: InputMaybe<Array<Scalars['Time']>>;
  emailAcceptedIsNil?: InputMaybe<Scalars['Boolean']>;
  emailAcceptedLT?: InputMaybe<Scalars['Time']>;
  emailAcceptedLTE?: InputMaybe<Scalars['Time']>;
  emailAcceptedNEQ?: InputMaybe<Scalars['Time']>;
  emailAcceptedNotIn?: InputMaybe<Array<Scalars['Time']>>;
  emailAcceptedNotNil?: InputMaybe<Scalars['Boolean']>;
  /** email_confirmation_label field predicates */
  emailConfirmationLabel?: InputMaybe<Scalars['Time']>;
  emailConfirmationLabelGT?: InputMaybe<Scalars['Time']>;
  emailConfirmationLabelGTE?: InputMaybe<Scalars['Time']>;
  emailConfirmationLabelIn?: InputMaybe<Array<Scalars['Time']>>;
  emailConfirmationLabelIsNil?: InputMaybe<Scalars['Boolean']>;
  emailConfirmationLabelLT?: InputMaybe<Scalars['Time']>;
  emailConfirmationLabelLTE?: InputMaybe<Scalars['Time']>;
  emailConfirmationLabelNEQ?: InputMaybe<Scalars['Time']>;
  emailConfirmationLabelNotIn?: InputMaybe<Array<Scalars['Time']>>;
  emailConfirmationLabelNotNil?: InputMaybe<Scalars['Boolean']>;
  /** email_confirmation_qr_code field predicates */
  emailConfirmationQrCode?: InputMaybe<Scalars['Time']>;
  emailConfirmationQrCodeGT?: InputMaybe<Scalars['Time']>;
  emailConfirmationQrCodeGTE?: InputMaybe<Scalars['Time']>;
  emailConfirmationQrCodeIn?: InputMaybe<Array<Scalars['Time']>>;
  emailConfirmationQrCodeIsNil?: InputMaybe<Scalars['Boolean']>;
  emailConfirmationQrCodeLT?: InputMaybe<Scalars['Time']>;
  emailConfirmationQrCodeLTE?: InputMaybe<Scalars['Time']>;
  emailConfirmationQrCodeNEQ?: InputMaybe<Scalars['Time']>;
  emailConfirmationQrCodeNotIn?: InputMaybe<Array<Scalars['Time']>>;
  emailConfirmationQrCodeNotNil?: InputMaybe<Scalars['Boolean']>;
  /** email_received field predicates */
  emailReceived?: InputMaybe<Scalars['Time']>;
  emailReceivedGT?: InputMaybe<Scalars['Time']>;
  emailReceivedGTE?: InputMaybe<Scalars['Time']>;
  emailReceivedIn?: InputMaybe<Array<Scalars['Time']>>;
  emailReceivedIsNil?: InputMaybe<Scalars['Boolean']>;
  emailReceivedLT?: InputMaybe<Scalars['Time']>;
  emailReceivedLTE?: InputMaybe<Scalars['Time']>;
  emailReceivedNEQ?: InputMaybe<Scalars['Time']>;
  emailReceivedNotIn?: InputMaybe<Array<Scalars['Time']>>;
  emailReceivedNotNil?: InputMaybe<Scalars['Boolean']>;
  /** expected_at field predicates */
  expectedAt?: InputMaybe<Scalars['Time']>;
  expectedAtGT?: InputMaybe<Scalars['Time']>;
  expectedAtGTE?: InputMaybe<Scalars['Time']>;
  expectedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  expectedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  expectedAtLT?: InputMaybe<Scalars['Time']>;
  expectedAtLTE?: InputMaybe<Scalars['Time']>;
  expectedAtNEQ?: InputMaybe<Scalars['Time']>;
  expectedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  expectedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** delivery_option edge predicates */
  hasDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** order edge predicates */
  hasOrder?: InputMaybe<Scalars['Boolean']>;
  hasOrderWith?: InputMaybe<Array<OrderWhereInput>>;
  /** packaging edge predicates */
  hasPackaging?: InputMaybe<Scalars['Boolean']>;
  hasPackagingWith?: InputMaybe<Array<PackagingWhereInput>>;
  /** recipient edge predicates */
  hasRecipient?: InputMaybe<Scalars['Boolean']>;
  hasRecipientWith?: InputMaybe<Array<AddressWhereInput>>;
  /** return_colli_history edge predicates */
  hasReturnColliHistory?: InputMaybe<Scalars['Boolean']>;
  hasReturnColliHistoryWith?: InputMaybe<Array<ReturnColliHistoryWhereInput>>;
  /** return_order_line edge predicates */
  hasReturnOrderLine?: InputMaybe<Scalars['Boolean']>;
  hasReturnOrderLineWith?: InputMaybe<Array<ReturnOrderLineWhereInput>>;
  /** return_portal edge predicates */
  hasReturnPortal?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalWith?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** sender edge predicates */
  hasSender?: InputMaybe<Scalars['Boolean']>;
  hasSenderWith?: InputMaybe<Array<AddressWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** label_pdf field predicates */
  labelPdf?: InputMaybe<Scalars['String']>;
  labelPdfContains?: InputMaybe<Scalars['String']>;
  labelPdfContainsFold?: InputMaybe<Scalars['String']>;
  labelPdfEqualFold?: InputMaybe<Scalars['String']>;
  labelPdfGT?: InputMaybe<Scalars['String']>;
  labelPdfGTE?: InputMaybe<Scalars['String']>;
  labelPdfHasPrefix?: InputMaybe<Scalars['String']>;
  labelPdfHasSuffix?: InputMaybe<Scalars['String']>;
  labelPdfIn?: InputMaybe<Array<Scalars['String']>>;
  labelPdfIsNil?: InputMaybe<Scalars['Boolean']>;
  labelPdfLT?: InputMaybe<Scalars['String']>;
  labelPdfLTE?: InputMaybe<Scalars['String']>;
  labelPdfNEQ?: InputMaybe<Scalars['String']>;
  labelPdfNotIn?: InputMaybe<Array<Scalars['String']>>;
  labelPdfNotNil?: InputMaybe<Scalars['Boolean']>;
  /** label_png field predicates */
  labelPng?: InputMaybe<Scalars['String']>;
  labelPngContains?: InputMaybe<Scalars['String']>;
  labelPngContainsFold?: InputMaybe<Scalars['String']>;
  labelPngEqualFold?: InputMaybe<Scalars['String']>;
  labelPngGT?: InputMaybe<Scalars['String']>;
  labelPngGTE?: InputMaybe<Scalars['String']>;
  labelPngHasPrefix?: InputMaybe<Scalars['String']>;
  labelPngHasSuffix?: InputMaybe<Scalars['String']>;
  labelPngIn?: InputMaybe<Array<Scalars['String']>>;
  labelPngIsNil?: InputMaybe<Scalars['Boolean']>;
  labelPngLT?: InputMaybe<Scalars['String']>;
  labelPngLTE?: InputMaybe<Scalars['String']>;
  labelPngNEQ?: InputMaybe<Scalars['String']>;
  labelPngNotIn?: InputMaybe<Array<Scalars['String']>>;
  labelPngNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<ReturnColliWhereInput>;
  or?: InputMaybe<Array<ReturnColliWhereInput>>;
  /** qr_code_png field predicates */
  qrCodePng?: InputMaybe<Scalars['String']>;
  qrCodePngContains?: InputMaybe<Scalars['String']>;
  qrCodePngContainsFold?: InputMaybe<Scalars['String']>;
  qrCodePngEqualFold?: InputMaybe<Scalars['String']>;
  qrCodePngGT?: InputMaybe<Scalars['String']>;
  qrCodePngGTE?: InputMaybe<Scalars['String']>;
  qrCodePngHasPrefix?: InputMaybe<Scalars['String']>;
  qrCodePngHasSuffix?: InputMaybe<Scalars['String']>;
  qrCodePngIn?: InputMaybe<Array<Scalars['String']>>;
  qrCodePngIsNil?: InputMaybe<Scalars['Boolean']>;
  qrCodePngLT?: InputMaybe<Scalars['String']>;
  qrCodePngLTE?: InputMaybe<Scalars['String']>;
  qrCodePngNEQ?: InputMaybe<Scalars['String']>;
  qrCodePngNotIn?: InputMaybe<Array<Scalars['String']>>;
  qrCodePngNotNil?: InputMaybe<Scalars['Boolean']>;
  /** status field predicates */
  status?: InputMaybe<ReturnColliStatus>;
  statusIn?: InputMaybe<Array<ReturnColliStatus>>;
  statusNEQ?: InputMaybe<ReturnColliStatus>;
  statusNotIn?: InputMaybe<Array<ReturnColliStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ReturnOrderLine = Node & {
  id: Scalars['ID'];
  orderLine: OrderLine;
  returnColli: ReturnColli;
  returnPortalClaim: ReturnPortalClaim;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  units: Scalars['Int'];
};

/** A connection to a list of items. */
export type ReturnOrderLineConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReturnOrderLineEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ReturnOrderLineEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ReturnOrderLine>;
};

/**
 * ReturnOrderLineWhereInput is used for filtering ReturnOrderLine objects.
 * Input was generated by ent.
 */
export type ReturnOrderLineWhereInput = {
  and?: InputMaybe<Array<ReturnOrderLineWhereInput>>;
  /** order_line edge predicates */
  hasOrderLine?: InputMaybe<Scalars['Boolean']>;
  hasOrderLineWith?: InputMaybe<Array<OrderLineWhereInput>>;
  /** return_colli edge predicates */
  hasReturnColli?: InputMaybe<Scalars['Boolean']>;
  hasReturnColliWith?: InputMaybe<Array<ReturnColliWhereInput>>;
  /** return_portal_claim edge predicates */
  hasReturnPortalClaim?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalClaimWith?: InputMaybe<Array<ReturnPortalClaimWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ReturnOrderLineWhereInput>;
  or?: InputMaybe<Array<ReturnOrderLineWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** units field predicates */
  units?: InputMaybe<Scalars['Int']>;
  unitsGT?: InputMaybe<Scalars['Int']>;
  unitsGTE?: InputMaybe<Scalars['Int']>;
  unitsIn?: InputMaybe<Array<Scalars['Int']>>;
  unitsLT?: InputMaybe<Scalars['Int']>;
  unitsLTE?: InputMaybe<Scalars['Int']>;
  unitsNEQ?: InputMaybe<Scalars['Int']>;
  unitsNotIn?: InputMaybe<Array<Scalars['Int']>>;
};

export type ReturnPortal = Node & {
  automaticallyAccept: Scalars['Boolean'];
  connection?: Maybe<Connection>;
  deliveryOptions?: Maybe<Array<DeliveryOption>>;
  emailAccepted?: Maybe<EmailTemplate>;
  emailConfirmationLabel?: Maybe<EmailTemplate>;
  emailConfirmationQrCode?: Maybe<EmailTemplate>;
  emailReceived?: Maybe<EmailTemplate>;
  id: Scalars['ID'];
  name: Scalars['String'];
  returnColli?: Maybe<Array<ReturnColli>>;
  returnLocation?: Maybe<Array<Location>>;
  returnOpenHours: Scalars['Int'];
  returnPortalClaim?: Maybe<Array<ReturnPortalClaim>>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

export type ReturnPortalClaim = Node & {
  archived: Scalars['Boolean'];
  description: Scalars['String'];
  id: Scalars['ID'];
  name: Scalars['String'];
  restockable: Scalars['Boolean'];
  /** Return to address */
  returnLocation?: Maybe<Location>;
  returnOrderLine?: Maybe<Array<ReturnOrderLine>>;
  returnPortal: ReturnPortal;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ReturnPortalClaimConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReturnPortalClaimEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ReturnPortalClaimEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ReturnPortalClaim>;
};

/**
 * ReturnPortalClaimWhereInput is used for filtering ReturnPortalClaim objects.
 * Input was generated by ent.
 */
export type ReturnPortalClaimWhereInput = {
  and?: InputMaybe<Array<ReturnPortalClaimWhereInput>>;
  /** archived field predicates */
  archived?: InputMaybe<Scalars['Boolean']>;
  archivedNEQ?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** return_location edge predicates */
  hasReturnLocation?: InputMaybe<Scalars['Boolean']>;
  hasReturnLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** return_order_line edge predicates */
  hasReturnOrderLine?: InputMaybe<Scalars['Boolean']>;
  hasReturnOrderLineWith?: InputMaybe<Array<ReturnOrderLineWhereInput>>;
  /** return_portal edge predicates */
  hasReturnPortal?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalWith?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ReturnPortalClaimWhereInput>;
  or?: InputMaybe<Array<ReturnPortalClaimWhereInput>>;
  /** restockable field predicates */
  restockable?: InputMaybe<Scalars['Boolean']>;
  restockableNEQ?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/** A connection to a list of items. */
export type ReturnPortalConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ReturnPortalEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ReturnPortalEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ReturnPortal>;
};

/**
 * ReturnPortalWhereInput is used for filtering ReturnPortal objects.
 * Input was generated by ent.
 */
export type ReturnPortalWhereInput = {
  and?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** automatically_accept field predicates */
  automaticallyAccept?: InputMaybe<Scalars['Boolean']>;
  automaticallyAcceptNEQ?: InputMaybe<Scalars['Boolean']>;
  /** connection edge predicates */
  hasConnection?: InputMaybe<Scalars['Boolean']>;
  hasConnectionWith?: InputMaybe<Array<ConnectionWhereInput>>;
  /** delivery_options edge predicates */
  hasDeliveryOptions?: InputMaybe<Scalars['Boolean']>;
  hasDeliveryOptionsWith?: InputMaybe<Array<DeliveryOptionWhereInput>>;
  /** email_accepted edge predicates */
  hasEmailAccepted?: InputMaybe<Scalars['Boolean']>;
  hasEmailAcceptedWith?: InputMaybe<Array<EmailTemplateWhereInput>>;
  /** email_confirmation_label edge predicates */
  hasEmailConfirmationLabel?: InputMaybe<Scalars['Boolean']>;
  hasEmailConfirmationLabelWith?: InputMaybe<Array<EmailTemplateWhereInput>>;
  /** email_confirmation_qr_code edge predicates */
  hasEmailConfirmationQrCode?: InputMaybe<Scalars['Boolean']>;
  hasEmailConfirmationQrCodeWith?: InputMaybe<Array<EmailTemplateWhereInput>>;
  /** email_received edge predicates */
  hasEmailReceived?: InputMaybe<Scalars['Boolean']>;
  hasEmailReceivedWith?: InputMaybe<Array<EmailTemplateWhereInput>>;
  /** return_colli edge predicates */
  hasReturnColli?: InputMaybe<Scalars['Boolean']>;
  hasReturnColliWith?: InputMaybe<Array<ReturnColliWhereInput>>;
  /** return_location edge predicates */
  hasReturnLocation?: InputMaybe<Scalars['Boolean']>;
  hasReturnLocationWith?: InputMaybe<Array<LocationWhereInput>>;
  /** return_portal_claim edge predicates */
  hasReturnPortalClaim?: InputMaybe<Scalars['Boolean']>;
  hasReturnPortalClaimWith?: InputMaybe<Array<ReturnPortalClaimWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ReturnPortalWhereInput>;
  or?: InputMaybe<Array<ReturnPortalWhereInput>>;
  /** return_open_hours field predicates */
  returnOpenHours?: InputMaybe<Scalars['Int']>;
  returnOpenHoursGT?: InputMaybe<Scalars['Int']>;
  returnOpenHoursGTE?: InputMaybe<Scalars['Int']>;
  returnOpenHoursIn?: InputMaybe<Array<Scalars['Int']>>;
  returnOpenHoursLT?: InputMaybe<Scalars['Int']>;
  returnOpenHoursLTE?: InputMaybe<Scalars['Int']>;
  returnOpenHoursNEQ?: InputMaybe<Scalars['Int']>;
  returnOpenHoursNotIn?: InputMaybe<Array<Scalars['Int']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type SearchResult = {
  entity: EntityType;
  id: Scalars['ID'];
  imagePath?: Maybe<Scalars['String']>;
  title: Scalars['String'];
};

export type SeatGroup = Node & {
  assignedAccessRight?: Maybe<Array<AccessRight>>;
  createdAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  name: Scalars['String'];
  seatGroupAccessRight?: Maybe<Array<SeatGroupAccessRight>>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  user?: Maybe<Array<User>>;
};

export type SeatGroupAccessRight = Node & {
  accessRight: AccessRight;
  accessRightID: Scalars['ID'];
  id: Scalars['ID'];
  level: SeatGroupAccessRightLevel;
  seatGroup: SeatGroup;
  seatGroupID: Scalars['ID'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type SeatGroupAccessRightConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SeatGroupAccessRightEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type SeatGroupAccessRightEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<SeatGroupAccessRight>;
};

/** SeatGroupAccessRightLevel is enum for the field level */
export enum SeatGroupAccessRightLevel {
  None = 'none',
  Read = 'read',
  Write = 'write'
}

/**
 * SeatGroupAccessRightWhereInput is used for filtering SeatGroupAccessRight objects.
 * Input was generated by ent.
 */
export type SeatGroupAccessRightWhereInput = {
  and?: InputMaybe<Array<SeatGroupAccessRightWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** level field predicates */
  level?: InputMaybe<SeatGroupAccessRightLevel>;
  levelIn?: InputMaybe<Array<SeatGroupAccessRightLevel>>;
  levelNEQ?: InputMaybe<SeatGroupAccessRightLevel>;
  levelNotIn?: InputMaybe<Array<SeatGroupAccessRightLevel>>;
  not?: InputMaybe<SeatGroupAccessRightWhereInput>;
  or?: InputMaybe<Array<SeatGroupAccessRightWhereInput>>;
};

/** A connection to a list of items. */
export type SeatGroupConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SeatGroupEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type SeatGroupEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<SeatGroup>;
};

/**
 * SeatGroupWhereInput is used for filtering SeatGroup objects.
 * Input was generated by ent.
 */
export type SeatGroupWhereInput = {
  and?: InputMaybe<Array<SeatGroupWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** assigned_access_right edge predicates */
  hasAssignedAccessRight?: InputMaybe<Scalars['Boolean']>;
  hasAssignedAccessRightWith?: InputMaybe<Array<AccessRightWhereInput>>;
  /** seat_group_access_right edge predicates */
  hasSeatGroupAccessRight?: InputMaybe<Scalars['Boolean']>;
  hasSeatGroupAccessRightWith?: InputMaybe<Array<SeatGroupAccessRightWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<SeatGroupWhereInput>;
  or?: InputMaybe<Array<SeatGroupWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type SelectedWorkstation = {
  jobs: Array<PrintJob>;
  limitExceeded: Scalars['Boolean'];
  workstation?: Maybe<Workstation>;
};

export type Shipment = Node & {
  /** Can get this from edges, but want the reference to persist even after cancelling */
  carrier: Carrier;
  /** A shipment may have 0 or more collis */
  consolidation?: Maybe<Consolidation>;
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  /** After a shipment is cancelled */
  oldConsolidation?: Maybe<Array<Consolidation>>;
  shipmentBring?: Maybe<ShipmentBring>;
  shipmentDAO?: Maybe<ShipmentDao>;
  shipmentDF?: Maybe<ShipmentDf>;
  shipmentDSV?: Maybe<ShipmentDsv>;
  shipmentEasyPost?: Maybe<ShipmentEasyPost>;
  shipmentGLS?: Maybe<ShipmentGls>;
  shipmentHistory?: Maybe<Array<ShipmentHistory>>;
  /** A shipment may have 0 or more pallets */
  shipmentPallet?: Maybe<Array<ShipmentPallet>>;
  /** A shipment may have 0 or more collis */
  shipmentParcel?: Maybe<Array<ShipmentParcel>>;
  shipmentPostNord?: Maybe<ShipmentPostNord>;
  shipmentPublicID: Scalars['String'];
  shipmentUSPS?: Maybe<ShipmentUsps>;
  status: ShipmentStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

export type ShipmentBring = Node & {
  consignmentNumber: Scalars['String'];
  id: Scalars['ID'];
  shipment: Shipment;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ShipmentBringConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentBringEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ShipmentBringEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ShipmentBring>;
};

/**
 * ShipmentBringWhereInput is used for filtering ShipmentBring objects.
 * Input was generated by ent.
 */
export type ShipmentBringWhereInput = {
  and?: InputMaybe<Array<ShipmentBringWhereInput>>;
  /** consignment_number field predicates */
  consignmentNumber?: InputMaybe<Scalars['String']>;
  consignmentNumberContains?: InputMaybe<Scalars['String']>;
  consignmentNumberContainsFold?: InputMaybe<Scalars['String']>;
  consignmentNumberEqualFold?: InputMaybe<Scalars['String']>;
  consignmentNumberGT?: InputMaybe<Scalars['String']>;
  consignmentNumberGTE?: InputMaybe<Scalars['String']>;
  consignmentNumberHasPrefix?: InputMaybe<Scalars['String']>;
  consignmentNumberHasSuffix?: InputMaybe<Scalars['String']>;
  consignmentNumberIn?: InputMaybe<Array<Scalars['String']>>;
  consignmentNumberLT?: InputMaybe<Scalars['String']>;
  consignmentNumberLTE?: InputMaybe<Scalars['String']>;
  consignmentNumberNEQ?: InputMaybe<Scalars['String']>;
  consignmentNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ShipmentBringWhereInput>;
  or?: InputMaybe<Array<ShipmentBringWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/** A connection to a list of items. */
export type ShipmentConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

export type ShipmentDao = Node & {
  barcodeID: Scalars['String'];
  id: Scalars['ID'];
  shipment: Shipment;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ShipmentDaoConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentDaoEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ShipmentDaoEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ShipmentDao>;
};

/**
 * ShipmentDAOWhereInput is used for filtering ShipmentDAO objects.
 * Input was generated by ent.
 */
export type ShipmentDaoWhereInput = {
  and?: InputMaybe<Array<ShipmentDaoWhereInput>>;
  /** barcode_id field predicates */
  barcodeID?: InputMaybe<Scalars['String']>;
  barcodeIDContains?: InputMaybe<Scalars['String']>;
  barcodeIDContainsFold?: InputMaybe<Scalars['String']>;
  barcodeIDEqualFold?: InputMaybe<Scalars['String']>;
  barcodeIDGT?: InputMaybe<Scalars['String']>;
  barcodeIDGTE?: InputMaybe<Scalars['String']>;
  barcodeIDHasPrefix?: InputMaybe<Scalars['String']>;
  barcodeIDHasSuffix?: InputMaybe<Scalars['String']>;
  barcodeIDIn?: InputMaybe<Array<Scalars['String']>>;
  barcodeIDLT?: InputMaybe<Scalars['String']>;
  barcodeIDLTE?: InputMaybe<Scalars['String']>;
  barcodeIDNEQ?: InputMaybe<Scalars['String']>;
  barcodeIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ShipmentDaoWhereInput>;
  or?: InputMaybe<Array<ShipmentDaoWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ShipmentDf = Node & {
  id: Scalars['ID'];
  shipment: Shipment;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ShipmentDfConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentDfEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ShipmentDfEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ShipmentDf>;
};

/**
 * ShipmentDFWhereInput is used for filtering ShipmentDF objects.
 * Input was generated by ent.
 */
export type ShipmentDfWhereInput = {
  and?: InputMaybe<Array<ShipmentDfWhereInput>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ShipmentDfWhereInput>;
  or?: InputMaybe<Array<ShipmentDfWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ShipmentDsv = Node & {
  barcodeID: Scalars['String'];
  id: Scalars['ID'];
  shipment: Shipment;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ShipmentDsvConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentDsvEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ShipmentDsvEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ShipmentDsv>;
};

/**
 * ShipmentDSVWhereInput is used for filtering ShipmentDSV objects.
 * Input was generated by ent.
 */
export type ShipmentDsvWhereInput = {
  and?: InputMaybe<Array<ShipmentDsvWhereInput>>;
  /** barcode_id field predicates */
  barcodeID?: InputMaybe<Scalars['String']>;
  barcodeIDContains?: InputMaybe<Scalars['String']>;
  barcodeIDContainsFold?: InputMaybe<Scalars['String']>;
  barcodeIDEqualFold?: InputMaybe<Scalars['String']>;
  barcodeIDGT?: InputMaybe<Scalars['String']>;
  barcodeIDGTE?: InputMaybe<Scalars['String']>;
  barcodeIDHasPrefix?: InputMaybe<Scalars['String']>;
  barcodeIDHasSuffix?: InputMaybe<Scalars['String']>;
  barcodeIDIn?: InputMaybe<Array<Scalars['String']>>;
  barcodeIDLT?: InputMaybe<Scalars['String']>;
  barcodeIDLTE?: InputMaybe<Scalars['String']>;
  barcodeIDNEQ?: InputMaybe<Scalars['String']>;
  barcodeIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ShipmentDsvWhereInput>;
  or?: InputMaybe<Array<ShipmentDsvWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ShipmentEasyPost = Node & {
  epShipmentID?: Maybe<Scalars['String']>;
  estDeliveryDate?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  rate?: Maybe<Scalars['Float']>;
  shipment: Shipment;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  /** duplicate, may be dropped after verifying */
  trackingNumber?: Maybe<Scalars['String']>;
};

/** A connection to a list of items. */
export type ShipmentEasyPostConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentEasyPostEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ShipmentEasyPostEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ShipmentEasyPost>;
};

/**
 * ShipmentEasyPostWhereInput is used for filtering ShipmentEasyPost objects.
 * Input was generated by ent.
 */
export type ShipmentEasyPostWhereInput = {
  and?: InputMaybe<Array<ShipmentEasyPostWhereInput>>;
  /** ep_shipment_id field predicates */
  epShipmentID?: InputMaybe<Scalars['String']>;
  epShipmentIDContains?: InputMaybe<Scalars['String']>;
  epShipmentIDContainsFold?: InputMaybe<Scalars['String']>;
  epShipmentIDEqualFold?: InputMaybe<Scalars['String']>;
  epShipmentIDGT?: InputMaybe<Scalars['String']>;
  epShipmentIDGTE?: InputMaybe<Scalars['String']>;
  epShipmentIDHasPrefix?: InputMaybe<Scalars['String']>;
  epShipmentIDHasSuffix?: InputMaybe<Scalars['String']>;
  epShipmentIDIn?: InputMaybe<Array<Scalars['String']>>;
  epShipmentIDIsNil?: InputMaybe<Scalars['Boolean']>;
  epShipmentIDLT?: InputMaybe<Scalars['String']>;
  epShipmentIDLTE?: InputMaybe<Scalars['String']>;
  epShipmentIDNEQ?: InputMaybe<Scalars['String']>;
  epShipmentIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  epShipmentIDNotNil?: InputMaybe<Scalars['Boolean']>;
  /** est_delivery_date field predicates */
  estDeliveryDate?: InputMaybe<Scalars['Time']>;
  estDeliveryDateGT?: InputMaybe<Scalars['Time']>;
  estDeliveryDateGTE?: InputMaybe<Scalars['Time']>;
  estDeliveryDateIn?: InputMaybe<Array<Scalars['Time']>>;
  estDeliveryDateIsNil?: InputMaybe<Scalars['Boolean']>;
  estDeliveryDateLT?: InputMaybe<Scalars['Time']>;
  estDeliveryDateLTE?: InputMaybe<Scalars['Time']>;
  estDeliveryDateNEQ?: InputMaybe<Scalars['Time']>;
  estDeliveryDateNotIn?: InputMaybe<Array<Scalars['Time']>>;
  estDeliveryDateNotNil?: InputMaybe<Scalars['Boolean']>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ShipmentEasyPostWhereInput>;
  or?: InputMaybe<Array<ShipmentEasyPostWhereInput>>;
  /** rate field predicates */
  rate?: InputMaybe<Scalars['Float']>;
  rateGT?: InputMaybe<Scalars['Float']>;
  rateGTE?: InputMaybe<Scalars['Float']>;
  rateIn?: InputMaybe<Array<Scalars['Float']>>;
  rateIsNil?: InputMaybe<Scalars['Boolean']>;
  rateLT?: InputMaybe<Scalars['Float']>;
  rateLTE?: InputMaybe<Scalars['Float']>;
  rateNEQ?: InputMaybe<Scalars['Float']>;
  rateNotIn?: InputMaybe<Array<Scalars['Float']>>;
  rateNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** tracking_number field predicates */
  trackingNumber?: InputMaybe<Scalars['String']>;
  trackingNumberContains?: InputMaybe<Scalars['String']>;
  trackingNumberContainsFold?: InputMaybe<Scalars['String']>;
  trackingNumberEqualFold?: InputMaybe<Scalars['String']>;
  trackingNumberGT?: InputMaybe<Scalars['String']>;
  trackingNumberGTE?: InputMaybe<Scalars['String']>;
  trackingNumberHasPrefix?: InputMaybe<Scalars['String']>;
  trackingNumberHasSuffix?: InputMaybe<Scalars['String']>;
  trackingNumberIn?: InputMaybe<Array<Scalars['String']>>;
  trackingNumberIsNil?: InputMaybe<Scalars['Boolean']>;
  trackingNumberLT?: InputMaybe<Scalars['String']>;
  trackingNumberLTE?: InputMaybe<Scalars['String']>;
  trackingNumberNEQ?: InputMaybe<Scalars['String']>;
  trackingNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  trackingNumberNotNil?: InputMaybe<Scalars['Boolean']>;
};

/** An edge in a connection. */
export type ShipmentEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Shipment>;
};

export type ShipmentGls = Node & {
  consignmentID: Scalars['String'];
  id: Scalars['ID'];
  shipment: Shipment;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ShipmentGlsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentGlsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ShipmentGlsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ShipmentGls>;
};

/**
 * ShipmentGLSWhereInput is used for filtering ShipmentGLS objects.
 * Input was generated by ent.
 */
export type ShipmentGlsWhereInput = {
  and?: InputMaybe<Array<ShipmentGlsWhereInput>>;
  /** consignment_id field predicates */
  consignmentID?: InputMaybe<Scalars['String']>;
  consignmentIDContains?: InputMaybe<Scalars['String']>;
  consignmentIDContainsFold?: InputMaybe<Scalars['String']>;
  consignmentIDEqualFold?: InputMaybe<Scalars['String']>;
  consignmentIDGT?: InputMaybe<Scalars['String']>;
  consignmentIDGTE?: InputMaybe<Scalars['String']>;
  consignmentIDHasPrefix?: InputMaybe<Scalars['String']>;
  consignmentIDHasSuffix?: InputMaybe<Scalars['String']>;
  consignmentIDIn?: InputMaybe<Array<Scalars['String']>>;
  consignmentIDLT?: InputMaybe<Scalars['String']>;
  consignmentIDLTE?: InputMaybe<Scalars['String']>;
  consignmentIDNEQ?: InputMaybe<Scalars['String']>;
  consignmentIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ShipmentGlsWhereInput>;
  or?: InputMaybe<Array<ShipmentGlsWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ShipmentHistory = Node & {
  changeHistory: ChangeHistory;
  id: Scalars['ID'];
  shipment: Shipment;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  type: ShipmentHistoryType;
};

/** ShipmentHistoryType is enum for the field type */
export enum ShipmentHistoryType {
  Create = 'create',
  Delete = 'delete',
  Update = 'update'
}

/**
 * ShipmentHistoryWhereInput is used for filtering ShipmentHistory objects.
 * Input was generated by ent.
 */
export type ShipmentHistoryWhereInput = {
  and?: InputMaybe<Array<ShipmentHistoryWhereInput>>;
  /** change_history edge predicates */
  hasChangeHistory?: InputMaybe<Scalars['Boolean']>;
  hasChangeHistoryWith?: InputMaybe<Array<ChangeHistoryWhereInput>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ShipmentHistoryWhereInput>;
  or?: InputMaybe<Array<ShipmentHistoryWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** type field predicates */
  type?: InputMaybe<ShipmentHistoryType>;
  typeIn?: InputMaybe<Array<ShipmentHistoryType>>;
  typeNEQ?: InputMaybe<ShipmentHistoryType>;
  typeNotIn?: InputMaybe<Array<ShipmentHistoryType>>;
};

export type ShipmentLabelsResponse = {
  allLabels: Scalars['String'];
  labelsPDF: Array<Scalars['String']>;
};

export type ShipmentListItem = {
  deliveryOption: DeliveryOption;
  id: Scalars['ID'];
  orderIDDisplay: Array<Scalars['String']>;
  recipient: Address;
  sender: Address;
  shipment: Shipment;
};

/** Ordering options for Shipment connections */
export type ShipmentOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order Shipments. */
  field: ShipmentOrderField;
};

/** Properties by which Shipment connections can be ordered. */
export enum ShipmentOrderField {
  CreatedAt = 'CREATED_AT'
}

export type ShipmentPallet = Node & {
  barcode: Scalars['String'];
  carrierID: Scalars['String'];
  colliNumber: Scalars['String'];
  id: Scalars['ID'];
  labelPdf?: Maybe<Scalars['String']>;
  labelZpl?: Maybe<Scalars['String']>;
  /** After shipment cancelled, ref moved here. Mostly for consistency, since the Shipment is also connected still. */
  oldPallet?: Maybe<Array<Pallet>>;
  pallet?: Maybe<Pallet>;
  shipment: Shipment;
  status: ShipmentPalletStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ShipmentPalletConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentPalletEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ShipmentPalletEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ShipmentPallet>;
};

/** ShipmentPalletStatus is enum for the field status */
export enum ShipmentPalletStatus {
  Pending = 'pending',
  Printed = 'printed'
}

/**
 * ShipmentPalletWhereInput is used for filtering ShipmentPallet objects.
 * Input was generated by ent.
 */
export type ShipmentPalletWhereInput = {
  and?: InputMaybe<Array<ShipmentPalletWhereInput>>;
  /** barcode field predicates */
  barcode?: InputMaybe<Scalars['String']>;
  barcodeContains?: InputMaybe<Scalars['String']>;
  barcodeContainsFold?: InputMaybe<Scalars['String']>;
  barcodeEqualFold?: InputMaybe<Scalars['String']>;
  barcodeGT?: InputMaybe<Scalars['String']>;
  barcodeGTE?: InputMaybe<Scalars['String']>;
  barcodeHasPrefix?: InputMaybe<Scalars['String']>;
  barcodeHasSuffix?: InputMaybe<Scalars['String']>;
  barcodeIn?: InputMaybe<Array<Scalars['String']>>;
  barcodeLT?: InputMaybe<Scalars['String']>;
  barcodeLTE?: InputMaybe<Scalars['String']>;
  barcodeNEQ?: InputMaybe<Scalars['String']>;
  barcodeNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** carrier_id field predicates */
  carrierID?: InputMaybe<Scalars['String']>;
  carrierIDContains?: InputMaybe<Scalars['String']>;
  carrierIDContainsFold?: InputMaybe<Scalars['String']>;
  carrierIDEqualFold?: InputMaybe<Scalars['String']>;
  carrierIDGT?: InputMaybe<Scalars['String']>;
  carrierIDGTE?: InputMaybe<Scalars['String']>;
  carrierIDHasPrefix?: InputMaybe<Scalars['String']>;
  carrierIDHasSuffix?: InputMaybe<Scalars['String']>;
  carrierIDIn?: InputMaybe<Array<Scalars['String']>>;
  carrierIDLT?: InputMaybe<Scalars['String']>;
  carrierIDLTE?: InputMaybe<Scalars['String']>;
  carrierIDNEQ?: InputMaybe<Scalars['String']>;
  carrierIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** colli_number field predicates */
  colliNumber?: InputMaybe<Scalars['String']>;
  colliNumberContains?: InputMaybe<Scalars['String']>;
  colliNumberContainsFold?: InputMaybe<Scalars['String']>;
  colliNumberEqualFold?: InputMaybe<Scalars['String']>;
  colliNumberGT?: InputMaybe<Scalars['String']>;
  colliNumberGTE?: InputMaybe<Scalars['String']>;
  colliNumberHasPrefix?: InputMaybe<Scalars['String']>;
  colliNumberHasSuffix?: InputMaybe<Scalars['String']>;
  colliNumberIn?: InputMaybe<Array<Scalars['String']>>;
  colliNumberLT?: InputMaybe<Scalars['String']>;
  colliNumberLTE?: InputMaybe<Scalars['String']>;
  colliNumberNEQ?: InputMaybe<Scalars['String']>;
  colliNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** old_pallet edge predicates */
  hasOldPallet?: InputMaybe<Scalars['Boolean']>;
  hasOldPalletWith?: InputMaybe<Array<PalletWhereInput>>;
  /** pallet edge predicates */
  hasPallet?: InputMaybe<Scalars['Boolean']>;
  hasPalletWith?: InputMaybe<Array<PalletWhereInput>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** label_pdf field predicates */
  labelPdf?: InputMaybe<Scalars['String']>;
  labelPdfContains?: InputMaybe<Scalars['String']>;
  labelPdfContainsFold?: InputMaybe<Scalars['String']>;
  labelPdfEqualFold?: InputMaybe<Scalars['String']>;
  labelPdfGT?: InputMaybe<Scalars['String']>;
  labelPdfGTE?: InputMaybe<Scalars['String']>;
  labelPdfHasPrefix?: InputMaybe<Scalars['String']>;
  labelPdfHasSuffix?: InputMaybe<Scalars['String']>;
  labelPdfIn?: InputMaybe<Array<Scalars['String']>>;
  labelPdfIsNil?: InputMaybe<Scalars['Boolean']>;
  labelPdfLT?: InputMaybe<Scalars['String']>;
  labelPdfLTE?: InputMaybe<Scalars['String']>;
  labelPdfNEQ?: InputMaybe<Scalars['String']>;
  labelPdfNotIn?: InputMaybe<Array<Scalars['String']>>;
  labelPdfNotNil?: InputMaybe<Scalars['Boolean']>;
  /** label_zpl field predicates */
  labelZpl?: InputMaybe<Scalars['String']>;
  labelZplContains?: InputMaybe<Scalars['String']>;
  labelZplContainsFold?: InputMaybe<Scalars['String']>;
  labelZplEqualFold?: InputMaybe<Scalars['String']>;
  labelZplGT?: InputMaybe<Scalars['String']>;
  labelZplGTE?: InputMaybe<Scalars['String']>;
  labelZplHasPrefix?: InputMaybe<Scalars['String']>;
  labelZplHasSuffix?: InputMaybe<Scalars['String']>;
  labelZplIn?: InputMaybe<Array<Scalars['String']>>;
  labelZplIsNil?: InputMaybe<Scalars['Boolean']>;
  labelZplLT?: InputMaybe<Scalars['String']>;
  labelZplLTE?: InputMaybe<Scalars['String']>;
  labelZplNEQ?: InputMaybe<Scalars['String']>;
  labelZplNotIn?: InputMaybe<Array<Scalars['String']>>;
  labelZplNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<ShipmentPalletWhereInput>;
  or?: InputMaybe<Array<ShipmentPalletWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<ShipmentPalletStatus>;
  statusIn?: InputMaybe<Array<ShipmentPalletStatus>>;
  statusNEQ?: InputMaybe<ShipmentPalletStatus>;
  statusNotIn?: InputMaybe<Array<ShipmentPalletStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ShipmentParcel = Node & {
  /** For supported carriers will attempt to cancel shipment via the API */
  cancelSyncedAt?: Maybe<Scalars['Time']>;
  ccPickupSignatureUrls?: Maybe<Array<Scalars['String']>>;
  colli?: Maybe<Colli>;
  documentFile?: Maybe<DocumentFile>;
  expectedAt?: Maybe<Scalars['Time']>;
  fulfillmentSyncedAt?: Maybe<Scalars['Time']>;
  id: Scalars['ID'];
  itemID?: Maybe<Scalars['String']>;
  /** After shipment cancelled, ref moved here. */
  oldColli?: Maybe<Array<Colli>>;
  packaging?: Maybe<Packaging>;
  printJob?: Maybe<Array<PrintJob>>;
  shipment: Shipment;
  status: ShipmentParcelStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  workspaceRecentScan?: Maybe<Array<WorkspaceRecentScan>>;
};

/** A connection to a list of items. */
export type ShipmentParcelConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentParcelEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ShipmentParcelEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ShipmentParcel>;
};

/** Ordering options for ShipmentParcel connections */
export type ShipmentParcelOrder = {
  /** The ordering direction. */
  direction?: OrderDirection;
  /** The field by which to order ShipmentParcels. */
  field: ShipmentParcelOrderField;
};

/** Properties by which ShipmentParcel connections can be ordered. */
export enum ShipmentParcelOrderField {
  CancelSyncedAt = 'CANCEL_SYNCED_AT',
  ExpectedAt = 'EXPECTED_AT',
  ShipmentCreatedAt = 'SHIPMENT_CREATED_AT'
}

/** ShipmentParcelStatus is enum for the field status */
export enum ShipmentParcelStatus {
  AwaitingCcPickup = 'awaiting_cc_pickup',
  Delivered = 'delivered',
  InTransit = 'in_transit',
  OutForDelivery = 'out_for_delivery',
  Pending = 'pending',
  PickedUp = 'picked_up',
  Printed = 'printed'
}

/**
 * ShipmentParcelWhereInput is used for filtering ShipmentParcel objects.
 * Input was generated by ent.
 */
export type ShipmentParcelWhereInput = {
  and?: InputMaybe<Array<ShipmentParcelWhereInput>>;
  /** cancel_synced_at field predicates */
  cancelSyncedAt?: InputMaybe<Scalars['Time']>;
  cancelSyncedAtGT?: InputMaybe<Scalars['Time']>;
  cancelSyncedAtGTE?: InputMaybe<Scalars['Time']>;
  cancelSyncedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  cancelSyncedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  cancelSyncedAtLT?: InputMaybe<Scalars['Time']>;
  cancelSyncedAtLTE?: InputMaybe<Scalars['Time']>;
  cancelSyncedAtNEQ?: InputMaybe<Scalars['Time']>;
  cancelSyncedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  cancelSyncedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** expected_at field predicates */
  expectedAt?: InputMaybe<Scalars['Time']>;
  expectedAtGT?: InputMaybe<Scalars['Time']>;
  expectedAtGTE?: InputMaybe<Scalars['Time']>;
  expectedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  expectedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  expectedAtLT?: InputMaybe<Scalars['Time']>;
  expectedAtLTE?: InputMaybe<Scalars['Time']>;
  expectedAtNEQ?: InputMaybe<Scalars['Time']>;
  expectedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  expectedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** fulfillment_synced_at field predicates */
  fulfillmentSyncedAt?: InputMaybe<Scalars['Time']>;
  fulfillmentSyncedAtGT?: InputMaybe<Scalars['Time']>;
  fulfillmentSyncedAtGTE?: InputMaybe<Scalars['Time']>;
  fulfillmentSyncedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  fulfillmentSyncedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  fulfillmentSyncedAtLT?: InputMaybe<Scalars['Time']>;
  fulfillmentSyncedAtLTE?: InputMaybe<Scalars['Time']>;
  fulfillmentSyncedAtNEQ?: InputMaybe<Scalars['Time']>;
  fulfillmentSyncedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  fulfillmentSyncedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** colli edge predicates */
  hasColli?: InputMaybe<Scalars['Boolean']>;
  hasColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** document_file edge predicates */
  hasDocumentFile?: InputMaybe<Scalars['Boolean']>;
  hasDocumentFileWith?: InputMaybe<Array<DocumentFileWhereInput>>;
  /** old_colli edge predicates */
  hasOldColli?: InputMaybe<Scalars['Boolean']>;
  hasOldColliWith?: InputMaybe<Array<ColliWhereInput>>;
  /** packaging edge predicates */
  hasPackaging?: InputMaybe<Scalars['Boolean']>;
  hasPackagingWith?: InputMaybe<Array<PackagingWhereInput>>;
  /** print_job edge predicates */
  hasPrintJob?: InputMaybe<Scalars['Boolean']>;
  hasPrintJobWith?: InputMaybe<Array<PrintJobWhereInput>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** workspace_recent_scan edge predicates */
  hasWorkspaceRecentScan?: InputMaybe<Scalars['Boolean']>;
  hasWorkspaceRecentScanWith?: InputMaybe<Array<WorkspaceRecentScanWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** item_id field predicates */
  itemID?: InputMaybe<Scalars['String']>;
  itemIDContains?: InputMaybe<Scalars['String']>;
  itemIDContainsFold?: InputMaybe<Scalars['String']>;
  itemIDEqualFold?: InputMaybe<Scalars['String']>;
  itemIDGT?: InputMaybe<Scalars['String']>;
  itemIDGTE?: InputMaybe<Scalars['String']>;
  itemIDHasPrefix?: InputMaybe<Scalars['String']>;
  itemIDHasSuffix?: InputMaybe<Scalars['String']>;
  itemIDIn?: InputMaybe<Array<Scalars['String']>>;
  itemIDIsNil?: InputMaybe<Scalars['Boolean']>;
  itemIDLT?: InputMaybe<Scalars['String']>;
  itemIDLTE?: InputMaybe<Scalars['String']>;
  itemIDNEQ?: InputMaybe<Scalars['String']>;
  itemIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  itemIDNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<ShipmentParcelWhereInput>;
  or?: InputMaybe<Array<ShipmentParcelWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<ShipmentParcelStatus>;
  statusIn?: InputMaybe<Array<ShipmentParcelStatus>>;
  statusNEQ?: InputMaybe<ShipmentParcelStatus>;
  statusNotIn?: InputMaybe<Array<ShipmentParcelStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type ShipmentPostNord = Node & {
  /** Multiple labels. May contain unrelated shipments. */
  bookingID: Scalars['String'];
  id: Scalars['ID'];
  /** Individual label. Can be grouped to same address. Probably should not be on this ent? */
  itemID: Scalars['String'];
  shipment: Shipment;
  /** Shipment can contain multiple parcels to same address. */
  shipmentReferenceNo: Scalars['String'];
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type ShipmentPostNordConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentPostNordEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ShipmentPostNordEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ShipmentPostNord>;
};

/**
 * ShipmentPostNordWhereInput is used for filtering ShipmentPostNord objects.
 * Input was generated by ent.
 */
export type ShipmentPostNordWhereInput = {
  and?: InputMaybe<Array<ShipmentPostNordWhereInput>>;
  /** booking_id field predicates */
  bookingID?: InputMaybe<Scalars['String']>;
  bookingIDContains?: InputMaybe<Scalars['String']>;
  bookingIDContainsFold?: InputMaybe<Scalars['String']>;
  bookingIDEqualFold?: InputMaybe<Scalars['String']>;
  bookingIDGT?: InputMaybe<Scalars['String']>;
  bookingIDGTE?: InputMaybe<Scalars['String']>;
  bookingIDHasPrefix?: InputMaybe<Scalars['String']>;
  bookingIDHasSuffix?: InputMaybe<Scalars['String']>;
  bookingIDIn?: InputMaybe<Array<Scalars['String']>>;
  bookingIDLT?: InputMaybe<Scalars['String']>;
  bookingIDLTE?: InputMaybe<Scalars['String']>;
  bookingIDNEQ?: InputMaybe<Scalars['String']>;
  bookingIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** item_id field predicates */
  itemID?: InputMaybe<Scalars['String']>;
  itemIDContains?: InputMaybe<Scalars['String']>;
  itemIDContainsFold?: InputMaybe<Scalars['String']>;
  itemIDEqualFold?: InputMaybe<Scalars['String']>;
  itemIDGT?: InputMaybe<Scalars['String']>;
  itemIDGTE?: InputMaybe<Scalars['String']>;
  itemIDHasPrefix?: InputMaybe<Scalars['String']>;
  itemIDHasSuffix?: InputMaybe<Scalars['String']>;
  itemIDIn?: InputMaybe<Array<Scalars['String']>>;
  itemIDLT?: InputMaybe<Scalars['String']>;
  itemIDLTE?: InputMaybe<Scalars['String']>;
  itemIDNEQ?: InputMaybe<Scalars['String']>;
  itemIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<ShipmentPostNordWhereInput>;
  or?: InputMaybe<Array<ShipmentPostNordWhereInput>>;
  /** shipment_reference_no field predicates */
  shipmentReferenceNo?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoContains?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoContainsFold?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoEqualFold?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoGT?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoGTE?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoHasPrefix?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoHasSuffix?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoIn?: InputMaybe<Array<Scalars['String']>>;
  shipmentReferenceNoLT?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoLTE?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoNEQ?: InputMaybe<Scalars['String']>;
  shipmentReferenceNoNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/** ShipmentStatus is enum for the field status */
export enum ShipmentStatus {
  Booked = 'Booked',
  Deleted = 'Deleted',
  Dispatched = 'Dispatched',
  PartiallyDispatched = 'Partially_dispatched',
  Pending = 'Pending',
  Prebooked = 'Prebooked'
}

export type ShipmentUsps = Node & {
  id: Scalars['ID'];
  postage?: Maybe<Scalars['Float']>;
  scheduledDeliveryDate?: Maybe<Scalars['Time']>;
  shipment: Shipment;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  trackingNumber?: Maybe<Scalars['String']>;
};

/** A connection to a list of items. */
export type ShipmentUspsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<ShipmentUspsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type ShipmentUspsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<ShipmentUsps>;
};

/**
 * ShipmentUSPSWhereInput is used for filtering ShipmentUSPS objects.
 * Input was generated by ent.
 */
export type ShipmentUspsWhereInput = {
  and?: InputMaybe<Array<ShipmentUspsWhereInput>>;
  /** shipment edge predicates */
  hasShipment?: InputMaybe<Scalars['Boolean']>;
  hasShipmentWith?: InputMaybe<Array<ShipmentWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ShipmentUspsWhereInput>;
  or?: InputMaybe<Array<ShipmentUspsWhereInput>>;
  /** postage field predicates */
  postage?: InputMaybe<Scalars['Float']>;
  postageGT?: InputMaybe<Scalars['Float']>;
  postageGTE?: InputMaybe<Scalars['Float']>;
  postageIn?: InputMaybe<Array<Scalars['Float']>>;
  postageIsNil?: InputMaybe<Scalars['Boolean']>;
  postageLT?: InputMaybe<Scalars['Float']>;
  postageLTE?: InputMaybe<Scalars['Float']>;
  postageNEQ?: InputMaybe<Scalars['Float']>;
  postageNotIn?: InputMaybe<Array<Scalars['Float']>>;
  postageNotNil?: InputMaybe<Scalars['Boolean']>;
  /** scheduled_delivery_date field predicates */
  scheduledDeliveryDate?: InputMaybe<Scalars['Time']>;
  scheduledDeliveryDateGT?: InputMaybe<Scalars['Time']>;
  scheduledDeliveryDateGTE?: InputMaybe<Scalars['Time']>;
  scheduledDeliveryDateIn?: InputMaybe<Array<Scalars['Time']>>;
  scheduledDeliveryDateIsNil?: InputMaybe<Scalars['Boolean']>;
  scheduledDeliveryDateLT?: InputMaybe<Scalars['Time']>;
  scheduledDeliveryDateLTE?: InputMaybe<Scalars['Time']>;
  scheduledDeliveryDateNEQ?: InputMaybe<Scalars['Time']>;
  scheduledDeliveryDateNotIn?: InputMaybe<Array<Scalars['Time']>>;
  scheduledDeliveryDateNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** tracking_number field predicates */
  trackingNumber?: InputMaybe<Scalars['String']>;
  trackingNumberContains?: InputMaybe<Scalars['String']>;
  trackingNumberContainsFold?: InputMaybe<Scalars['String']>;
  trackingNumberEqualFold?: InputMaybe<Scalars['String']>;
  trackingNumberGT?: InputMaybe<Scalars['String']>;
  trackingNumberGTE?: InputMaybe<Scalars['String']>;
  trackingNumberHasPrefix?: InputMaybe<Scalars['String']>;
  trackingNumberHasSuffix?: InputMaybe<Scalars['String']>;
  trackingNumberIn?: InputMaybe<Array<Scalars['String']>>;
  trackingNumberIsNil?: InputMaybe<Scalars['Boolean']>;
  trackingNumberLT?: InputMaybe<Scalars['String']>;
  trackingNumberLTE?: InputMaybe<Scalars['String']>;
  trackingNumberNEQ?: InputMaybe<Scalars['String']>;
  trackingNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  trackingNumberNotNil?: InputMaybe<Scalars['Boolean']>;
};

/**
 * ShipmentWhereInput is used for filtering Shipment objects.
 * Input was generated by ent.
 */
export type ShipmentWhereInput = {
  and?: InputMaybe<Array<ShipmentWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** carrier edge predicates */
  hasCarrier?: InputMaybe<Scalars['Boolean']>;
  hasCarrierWith?: InputMaybe<Array<CarrierWhereInput>>;
  /** consolidation edge predicates */
  hasConsolidation?: InputMaybe<Scalars['Boolean']>;
  hasConsolidationWith?: InputMaybe<Array<ConsolidationWhereInput>>;
  /** old_consolidation edge predicates */
  hasOldConsolidation?: InputMaybe<Scalars['Boolean']>;
  hasOldConsolidationWith?: InputMaybe<Array<ConsolidationWhereInput>>;
  /** shipment_bring edge predicates */
  hasShipmentBring?: InputMaybe<Scalars['Boolean']>;
  hasShipmentBringWith?: InputMaybe<Array<ShipmentBringWhereInput>>;
  /** shipment_dao edge predicates */
  hasShipmentDAO?: InputMaybe<Scalars['Boolean']>;
  hasShipmentDAOWith?: InputMaybe<Array<ShipmentDaoWhereInput>>;
  /** shipment_df edge predicates */
  hasShipmentDF?: InputMaybe<Scalars['Boolean']>;
  hasShipmentDFWith?: InputMaybe<Array<ShipmentDfWhereInput>>;
  /** shipment_dsv edge predicates */
  hasShipmentDSV?: InputMaybe<Scalars['Boolean']>;
  hasShipmentDSVWith?: InputMaybe<Array<ShipmentDsvWhereInput>>;
  /** shipment_easy_post edge predicates */
  hasShipmentEasyPost?: InputMaybe<Scalars['Boolean']>;
  hasShipmentEasyPostWith?: InputMaybe<Array<ShipmentEasyPostWhereInput>>;
  /** shipment_gls edge predicates */
  hasShipmentGLS?: InputMaybe<Scalars['Boolean']>;
  hasShipmentGLSWith?: InputMaybe<Array<ShipmentGlsWhereInput>>;
  /** shipment_history edge predicates */
  hasShipmentHistory?: InputMaybe<Scalars['Boolean']>;
  hasShipmentHistoryWith?: InputMaybe<Array<ShipmentHistoryWhereInput>>;
  /** shipment_pallet edge predicates */
  hasShipmentPallet?: InputMaybe<Scalars['Boolean']>;
  hasShipmentPalletWith?: InputMaybe<Array<ShipmentPalletWhereInput>>;
  /** shipment_parcel edge predicates */
  hasShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  hasShipmentParcelWith?: InputMaybe<Array<ShipmentParcelWhereInput>>;
  /** shipment_post_nord edge predicates */
  hasShipmentPostNord?: InputMaybe<Scalars['Boolean']>;
  hasShipmentPostNordWith?: InputMaybe<Array<ShipmentPostNordWhereInput>>;
  /** shipment_usps edge predicates */
  hasShipmentUSPS?: InputMaybe<Scalars['Boolean']>;
  hasShipmentUSPSWith?: InputMaybe<Array<ShipmentUspsWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<ShipmentWhereInput>;
  or?: InputMaybe<Array<ShipmentWhereInput>>;
  /** shipment_public_id field predicates */
  shipmentPublicID?: InputMaybe<Scalars['String']>;
  shipmentPublicIDContains?: InputMaybe<Scalars['String']>;
  shipmentPublicIDContainsFold?: InputMaybe<Scalars['String']>;
  shipmentPublicIDEqualFold?: InputMaybe<Scalars['String']>;
  shipmentPublicIDGT?: InputMaybe<Scalars['String']>;
  shipmentPublicIDGTE?: InputMaybe<Scalars['String']>;
  shipmentPublicIDHasPrefix?: InputMaybe<Scalars['String']>;
  shipmentPublicIDHasSuffix?: InputMaybe<Scalars['String']>;
  shipmentPublicIDIn?: InputMaybe<Array<Scalars['String']>>;
  shipmentPublicIDLT?: InputMaybe<Scalars['String']>;
  shipmentPublicIDLTE?: InputMaybe<Scalars['String']>;
  shipmentPublicIDNEQ?: InputMaybe<Scalars['String']>;
  shipmentPublicIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** status field predicates */
  status?: InputMaybe<ShipmentStatus>;
  statusIn?: InputMaybe<Array<ShipmentStatus>>;
  statusNEQ?: InputMaybe<ShipmentStatus>;
  statusNotIn?: InputMaybe<Array<ShipmentStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type SignupOptions = Node & {
  betterDeliveryOptions: Scalars['Boolean'];
  clickCollect: Scalars['Boolean'];
  customDocs: Scalars['Boolean'];
  easyReturns: Scalars['Boolean'];
  id: Scalars['ID'];
  improvePickPack: Scalars['Boolean'];
  numShipments: Scalars['Int'];
  reducedCosts: Scalars['Boolean'];
  shippingLabel: Scalars['Boolean'];
  users: User;
};

/** A connection to a list of items. */
export type SignupOptionsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SignupOptionsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type SignupOptionsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<SignupOptions>;
};

/**
 * SignupOptionsWhereInput is used for filtering SignupOptions objects.
 * Input was generated by ent.
 */
export type SignupOptionsWhereInput = {
  and?: InputMaybe<Array<SignupOptionsWhereInput>>;
  /** better_delivery_options field predicates */
  betterDeliveryOptions?: InputMaybe<Scalars['Boolean']>;
  betterDeliveryOptionsNEQ?: InputMaybe<Scalars['Boolean']>;
  /** click_collect field predicates */
  clickCollect?: InputMaybe<Scalars['Boolean']>;
  clickCollectNEQ?: InputMaybe<Scalars['Boolean']>;
  /** custom_docs field predicates */
  customDocs?: InputMaybe<Scalars['Boolean']>;
  customDocsNEQ?: InputMaybe<Scalars['Boolean']>;
  /** easy_returns field predicates */
  easyReturns?: InputMaybe<Scalars['Boolean']>;
  easyReturnsNEQ?: InputMaybe<Scalars['Boolean']>;
  /** users edge predicates */
  hasUsers?: InputMaybe<Scalars['Boolean']>;
  hasUsersWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** improve_pick_pack field predicates */
  improvePickPack?: InputMaybe<Scalars['Boolean']>;
  improvePickPackNEQ?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<SignupOptionsWhereInput>;
  /** num_shipments field predicates */
  numShipments?: InputMaybe<Scalars['Int']>;
  numShipmentsGT?: InputMaybe<Scalars['Int']>;
  numShipmentsGTE?: InputMaybe<Scalars['Int']>;
  numShipmentsIn?: InputMaybe<Array<Scalars['Int']>>;
  numShipmentsLT?: InputMaybe<Scalars['Int']>;
  numShipmentsLTE?: InputMaybe<Scalars['Int']>;
  numShipmentsNEQ?: InputMaybe<Scalars['Int']>;
  numShipmentsNotIn?: InputMaybe<Array<Scalars['Int']>>;
  or?: InputMaybe<Array<SignupOptionsWhereInput>>;
  /** reduced_costs field predicates */
  reducedCosts?: InputMaybe<Scalars['Boolean']>;
  reducedCostsNEQ?: InputMaybe<Scalars['Boolean']>;
  /** shipping_label field predicates */
  shippingLabel?: InputMaybe<Scalars['Boolean']>;
  shippingLabelNEQ?: InputMaybe<Scalars['Boolean']>;
};

export type SystemEvents = Node & {
  createdAt?: Maybe<Scalars['Time']>;
  data?: Maybe<Scalars['String']>;
  description: Scalars['String'];
  eventType: SystemEventsEventType;
  eventTypeID?: Maybe<Scalars['String']>;
  id: Scalars['ID'];
  status: SystemEventsStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  updatedAt: Scalars['Time'];
};

/** A connection to a list of items. */
export type SystemEventsConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<SystemEventsEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type SystemEventsEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<SystemEvents>;
};

/** SystemEventsEventType is enum for the field event_type */
export enum SystemEventsEventType {
  BackgroundProductMutate = 'background_product_mutate',
  BackgroundTasks = 'background_tasks',
  SendNotifications = 'send_notifications',
  ShopifyOrderCancelledSync = 'shopify_order_cancelled_sync',
  ShopifyOrderSync = 'shopify_order_sync',
  ShopifyProductSync = 'shopify_product_sync',
  SyncCancelledShipments = 'sync_cancelled_shipments'
}

/** SystemEventsStatus is enum for the field status */
export enum SystemEventsStatus {
  Fail = 'fail',
  Running = 'running',
  Success = 'success'
}

/**
 * SystemEventsWhereInput is used for filtering SystemEvents objects.
 * Input was generated by ent.
 */
export type SystemEventsWhereInput = {
  and?: InputMaybe<Array<SystemEventsWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** data field predicates */
  data?: InputMaybe<Scalars['String']>;
  dataContains?: InputMaybe<Scalars['String']>;
  dataContainsFold?: InputMaybe<Scalars['String']>;
  dataEqualFold?: InputMaybe<Scalars['String']>;
  dataGT?: InputMaybe<Scalars['String']>;
  dataGTE?: InputMaybe<Scalars['String']>;
  dataHasPrefix?: InputMaybe<Scalars['String']>;
  dataHasSuffix?: InputMaybe<Scalars['String']>;
  dataIn?: InputMaybe<Array<Scalars['String']>>;
  dataIsNil?: InputMaybe<Scalars['Boolean']>;
  dataLT?: InputMaybe<Scalars['String']>;
  dataLTE?: InputMaybe<Scalars['String']>;
  dataNEQ?: InputMaybe<Scalars['String']>;
  dataNotIn?: InputMaybe<Array<Scalars['String']>>;
  dataNotNil?: InputMaybe<Scalars['Boolean']>;
  /** description field predicates */
  description?: InputMaybe<Scalars['String']>;
  descriptionContains?: InputMaybe<Scalars['String']>;
  descriptionContainsFold?: InputMaybe<Scalars['String']>;
  descriptionEqualFold?: InputMaybe<Scalars['String']>;
  descriptionGT?: InputMaybe<Scalars['String']>;
  descriptionGTE?: InputMaybe<Scalars['String']>;
  descriptionHasPrefix?: InputMaybe<Scalars['String']>;
  descriptionHasSuffix?: InputMaybe<Scalars['String']>;
  descriptionIn?: InputMaybe<Array<Scalars['String']>>;
  descriptionLT?: InputMaybe<Scalars['String']>;
  descriptionLTE?: InputMaybe<Scalars['String']>;
  descriptionNEQ?: InputMaybe<Scalars['String']>;
  descriptionNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** event_type field predicates */
  eventType?: InputMaybe<SystemEventsEventType>;
  /** event_type_id field predicates */
  eventTypeID?: InputMaybe<Scalars['String']>;
  eventTypeIDContains?: InputMaybe<Scalars['String']>;
  eventTypeIDContainsFold?: InputMaybe<Scalars['String']>;
  eventTypeIDEqualFold?: InputMaybe<Scalars['String']>;
  eventTypeIDGT?: InputMaybe<Scalars['String']>;
  eventTypeIDGTE?: InputMaybe<Scalars['String']>;
  eventTypeIDHasPrefix?: InputMaybe<Scalars['String']>;
  eventTypeIDHasSuffix?: InputMaybe<Scalars['String']>;
  eventTypeIDIn?: InputMaybe<Array<Scalars['String']>>;
  eventTypeIDIsNil?: InputMaybe<Scalars['Boolean']>;
  eventTypeIDLT?: InputMaybe<Scalars['String']>;
  eventTypeIDLTE?: InputMaybe<Scalars['String']>;
  eventTypeIDNEQ?: InputMaybe<Scalars['String']>;
  eventTypeIDNotIn?: InputMaybe<Array<Scalars['String']>>;
  eventTypeIDNotNil?: InputMaybe<Scalars['Boolean']>;
  eventTypeIn?: InputMaybe<Array<SystemEventsEventType>>;
  eventTypeNEQ?: InputMaybe<SystemEventsEventType>;
  eventTypeNotIn?: InputMaybe<Array<SystemEventsEventType>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<SystemEventsWhereInput>;
  or?: InputMaybe<Array<SystemEventsWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<SystemEventsStatus>;
  statusIn?: InputMaybe<Array<SystemEventsStatus>>;
  statusNEQ?: InputMaybe<SystemEventsStatus>;
  statusNotIn?: InputMaybe<Array<SystemEventsStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** updated_at field predicates */
  updatedAt?: InputMaybe<Scalars['Time']>;
  updatedAtGT?: InputMaybe<Scalars['Time']>;
  updatedAtGTE?: InputMaybe<Scalars['Time']>;
  updatedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  updatedAtLT?: InputMaybe<Scalars['Time']>;
  updatedAtLTE?: InputMaybe<Scalars['Time']>;
  updatedAtNEQ?: InputMaybe<Scalars['Time']>;
  updatedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
};

export type Tenant = Node & {
  adminContact?: Maybe<Contact>;
  billingContact?: Maybe<Contact>;
  companyAddress?: Maybe<Address>;
  connectOptionCarriers?: Maybe<Array<ConnectOptionCarrier>>;
  connectOptionPlatforms?: Maybe<Array<ConnectOptionPlatform>>;
  defaultLanguage: Language;
  id: Scalars['ID'];
  invoiceReference?: Maybe<Scalars['String']>;
  name: Scalars['String'];
  plan: Plan;
  vatNumber?: Maybe<Scalars['String']>;
};

/** A connection to a list of items. */
export type TenantConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<TenantEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type TenantEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Tenant>;
};

/**
 * TenantWhereInput is used for filtering Tenant objects.
 * Input was generated by ent.
 */
export type TenantWhereInput = {
  and?: InputMaybe<Array<TenantWhereInput>>;
  /** admin_contact edge predicates */
  hasAdminContact?: InputMaybe<Scalars['Boolean']>;
  hasAdminContactWith?: InputMaybe<Array<ContactWhereInput>>;
  /** billing_contact edge predicates */
  hasBillingContact?: InputMaybe<Scalars['Boolean']>;
  hasBillingContactWith?: InputMaybe<Array<ContactWhereInput>>;
  /** company_address edge predicates */
  hasCompanyAddress?: InputMaybe<Scalars['Boolean']>;
  hasCompanyAddressWith?: InputMaybe<Array<AddressWhereInput>>;
  /** connect_option_carriers edge predicates */
  hasConnectOptionCarriers?: InputMaybe<Scalars['Boolean']>;
  hasConnectOptionCarriersWith?: InputMaybe<Array<ConnectOptionCarrierWhereInput>>;
  /** connect_option_platforms edge predicates */
  hasConnectOptionPlatforms?: InputMaybe<Scalars['Boolean']>;
  hasConnectOptionPlatformsWith?: InputMaybe<Array<ConnectOptionPlatformWhereInput>>;
  /** default_language edge predicates */
  hasDefaultLanguage?: InputMaybe<Scalars['Boolean']>;
  hasDefaultLanguageWith?: InputMaybe<Array<LanguageWhereInput>>;
  /** plan edge predicates */
  hasPlan?: InputMaybe<Scalars['Boolean']>;
  hasPlanWith?: InputMaybe<Array<PlanWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** invoice_reference field predicates */
  invoiceReference?: InputMaybe<Scalars['String']>;
  invoiceReferenceContains?: InputMaybe<Scalars['String']>;
  invoiceReferenceContainsFold?: InputMaybe<Scalars['String']>;
  invoiceReferenceEqualFold?: InputMaybe<Scalars['String']>;
  invoiceReferenceGT?: InputMaybe<Scalars['String']>;
  invoiceReferenceGTE?: InputMaybe<Scalars['String']>;
  invoiceReferenceHasPrefix?: InputMaybe<Scalars['String']>;
  invoiceReferenceHasSuffix?: InputMaybe<Scalars['String']>;
  invoiceReferenceIn?: InputMaybe<Array<Scalars['String']>>;
  invoiceReferenceIsNil?: InputMaybe<Scalars['Boolean']>;
  invoiceReferenceLT?: InputMaybe<Scalars['String']>;
  invoiceReferenceLTE?: InputMaybe<Scalars['String']>;
  invoiceReferenceNEQ?: InputMaybe<Scalars['String']>;
  invoiceReferenceNotIn?: InputMaybe<Array<Scalars['String']>>;
  invoiceReferenceNotNil?: InputMaybe<Scalars['Boolean']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<TenantWhereInput>;
  or?: InputMaybe<Array<TenantWhereInput>>;
  /** vat_number field predicates */
  vatNumber?: InputMaybe<Scalars['String']>;
  vatNumberContains?: InputMaybe<Scalars['String']>;
  vatNumberContainsFold?: InputMaybe<Scalars['String']>;
  vatNumberEqualFold?: InputMaybe<Scalars['String']>;
  vatNumberGT?: InputMaybe<Scalars['String']>;
  vatNumberGTE?: InputMaybe<Scalars['String']>;
  vatNumberHasPrefix?: InputMaybe<Scalars['String']>;
  vatNumberHasSuffix?: InputMaybe<Scalars['String']>;
  vatNumberIn?: InputMaybe<Array<Scalars['String']>>;
  vatNumberIsNil?: InputMaybe<Scalars['Boolean']>;
  vatNumberLT?: InputMaybe<Scalars['String']>;
  vatNumberLTE?: InputMaybe<Scalars['String']>;
  vatNumberNEQ?: InputMaybe<Scalars['String']>;
  vatNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  vatNumberNotNil?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdateAddressGlobalInput is used for update AddressGlobal object.
 * Input was generated by ent.
 */
export type UpdateAddressGlobalInput = {
  addressOne?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  clearAddressTwo?: InputMaybe<Scalars['Boolean']>;
  clearCompany?: InputMaybe<Scalars['Boolean']>;
  clearParcelShop?: InputMaybe<Scalars['Boolean']>;
  clearParcelShopBringDelivery?: InputMaybe<Scalars['Boolean']>;
  clearParcelShopPostNordDelivery?: InputMaybe<Scalars['Boolean']>;
  clearState?: InputMaybe<Scalars['Boolean']>;
  company?: InputMaybe<Scalars['String']>;
  countryID?: InputMaybe<Scalars['ID']>;
  latitude?: InputMaybe<Scalars['Float']>;
  longitude?: InputMaybe<Scalars['Float']>;
  parcelShopBringDeliveryID?: InputMaybe<Scalars['ID']>;
  parcelShopID?: InputMaybe<Scalars['ID']>;
  parcelShopPostNordDeliveryID?: InputMaybe<Scalars['ID']>;
  state?: InputMaybe<Scalars['String']>;
  zip?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateAddressInput is used for update Address object.
 * Input was generated by ent.
 */
export type UpdateAddressInput = {
  addCompanyAddresIDs?: InputMaybe<Array<Scalars['ID']>>;
  addLocationIDs?: InputMaybe<Array<Scalars['ID']>>;
  addRecipientColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnRecipientColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnSenderColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addSenderColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addressOne?: InputMaybe<Scalars['String']>;
  addressTwo?: InputMaybe<Scalars['String']>;
  city?: InputMaybe<Scalars['String']>;
  clearCompany?: InputMaybe<Scalars['Boolean']>;
  clearCompanyAddress?: InputMaybe<Scalars['Boolean']>;
  clearLocation?: InputMaybe<Scalars['Boolean']>;
  clearPhoneNumber2?: InputMaybe<Scalars['Boolean']>;
  clearRecipientColli?: InputMaybe<Scalars['Boolean']>;
  clearRecipientConsolidation?: InputMaybe<Scalars['Boolean']>;
  clearReturnRecipientColli?: InputMaybe<Scalars['Boolean']>;
  clearReturnSenderColli?: InputMaybe<Scalars['Boolean']>;
  clearSenderColli?: InputMaybe<Scalars['Boolean']>;
  clearSenderConsolidation?: InputMaybe<Scalars['Boolean']>;
  clearState?: InputMaybe<Scalars['Boolean']>;
  clearVatNumber?: InputMaybe<Scalars['Boolean']>;
  company?: InputMaybe<Scalars['String']>;
  countryID?: InputMaybe<Scalars['ID']>;
  email?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** Some applications have both mobile and generic */
  phoneNumber2?: InputMaybe<Scalars['String']>;
  recipientConsolidationID?: InputMaybe<Scalars['ID']>;
  removeCompanyAddresIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeLocationIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeRecipientColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnRecipientColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnSenderColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeSenderColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  senderConsolidationID?: InputMaybe<Scalars['ID']>;
  state?: InputMaybe<Scalars['String']>;
  /** Electronic customs */
  vatNumber?: InputMaybe<Scalars['String']>;
  zip?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateCarrierAdditionalServiceBringInput is used for update CarrierAdditionalServiceBring object.
 * Input was generated by ent.
 */
export type UpdateCarrierAdditionalServiceBringInput = {
  addDeliveryOptionBringIDs?: InputMaybe<Array<Scalars['ID']>>;
  apiCodeBooking?: InputMaybe<Scalars['String']>;
  carrierServiceBringID?: InputMaybe<Scalars['ID']>;
  clearCarrierServiceBring?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionBring?: InputMaybe<Scalars['Boolean']>;
  label?: InputMaybe<Scalars['String']>;
  removeDeliveryOptionBringIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateCarrierAdditionalServiceDAOInput is used for update CarrierAdditionalServiceDAO object.
 * Input was generated by ent.
 */
export type UpdateCarrierAdditionalServiceDaoInput = {
  addCarrierServiceDAOIDs?: InputMaybe<Array<Scalars['ID']>>;
  addDeliveryOptionDAOIDs?: InputMaybe<Array<Scalars['ID']>>;
  apiCode?: InputMaybe<Scalars['String']>;
  clearCarrierServiceDAO?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionDAO?: InputMaybe<Scalars['Boolean']>;
  label?: InputMaybe<Scalars['String']>;
  removeCarrierServiceDAOIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeDeliveryOptionDAOIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateCarrierAdditionalServiceDSVInput is used for update CarrierAdditionalServiceDSV object.
 * Input was generated by ent.
 */
export type UpdateCarrierAdditionalServiceDsvInput = {
  addCarrierServiceDSVIDs?: InputMaybe<Array<Scalars['ID']>>;
  addDeliveryOptionDSVIDs?: InputMaybe<Array<Scalars['ID']>>;
  apiCode?: InputMaybe<Scalars['String']>;
  clearCarrierServiceDSV?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionDSV?: InputMaybe<Scalars['Boolean']>;
  label?: InputMaybe<Scalars['String']>;
  removeCarrierServiceDSVIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeDeliveryOptionDSVIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateCarrierAdditionalServiceGLSInput is used for update CarrierAdditionalServiceGLS object.
 * Input was generated by ent.
 */
export type UpdateCarrierAdditionalServiceGlsInput = {
  addCountriesConsigneeIDs?: InputMaybe<Array<Scalars['ID']>>;
  addCountriesConsignorIDs?: InputMaybe<Array<Scalars['ID']>>;
  addDeliveryOptionGlIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** When false, only edge countries will validate on this consignee service */
  allCountriesConsignee?: InputMaybe<Scalars['Boolean']>;
  /** When false, only edge countries will validate on this consignor service */
  allCountriesConsignor?: InputMaybe<Scalars['Boolean']>;
  carrierServiceGLSID?: InputMaybe<Scalars['ID']>;
  clearCarrierServiceGLS?: InputMaybe<Scalars['Boolean']>;
  clearCountriesConsignee?: InputMaybe<Scalars['Boolean']>;
  clearCountriesConsignor?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionGLS?: InputMaybe<Scalars['Boolean']>;
  internalID?: InputMaybe<Scalars['String']>;
  label?: InputMaybe<Scalars['String']>;
  mandatory?: InputMaybe<Scalars['Boolean']>;
  removeCountriesConsigneeIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeCountriesConsignorIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeDeliveryOptionGlIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateCarrierBringInput is used for update CarrierBring object.
 * Input was generated by ent.
 */
export type UpdateCarrierBringInput = {
  apiKey?: InputMaybe<Scalars['String']>;
  carrierID?: InputMaybe<Scalars['ID']>;
  clearAPIKey?: InputMaybe<Scalars['Boolean']>;
  clearCustomerNumber?: InputMaybe<Scalars['Boolean']>;
  customerNumber?: InputMaybe<Scalars['String']>;
  test?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdateCarrierDAOInput is used for update CarrierDAO object.
 * Input was generated by ent.
 */
export type UpdateCarrierDaoInput = {
  apiKey?: InputMaybe<Scalars['String']>;
  carrierID?: InputMaybe<Scalars['ID']>;
  clearAPIKey?: InputMaybe<Scalars['Boolean']>;
  clearCustomerID?: InputMaybe<Scalars['Boolean']>;
  customerID?: InputMaybe<Scalars['String']>;
  test?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdateCarrierDFInput is used for update CarrierDF object.
 * Input was generated by ent.
 */
export type UpdateCarrierDfInput = {
  agreementNumber?: InputMaybe<Scalars['String']>;
  carrierID?: InputMaybe<Scalars['ID']>;
  customerID?: InputMaybe<Scalars['String']>;
  test?: InputMaybe<Scalars['Boolean']>;
  whoPays?: InputMaybe<CarrierDfWhoPays>;
};

/**
 * UpdateCarrierDSVInput is used for update CarrierDSV object.
 * Input was generated by ent.
 */
export type UpdateCarrierDsvInput = {
  carrierID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateCarrierEasyPostInput is used for update CarrierEasyPost object.
 * Input was generated by ent.
 */
export type UpdateCarrierEasyPostInput = {
  apiKey?: InputMaybe<Scalars['String']>;
  appendCarrierAccounts?: InputMaybe<Array<Scalars['String']>>;
  /** When > 1, then we use rate, then buy. =1 one-call buy. Former not implemented in first round. */
  carrierAccounts?: InputMaybe<Array<Scalars['String']>>;
  carrierID?: InputMaybe<Scalars['ID']>;
  test?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdateCarrierGLSInput is used for update CarrierGLS object.
 * Input was generated by ent.
 */
export type UpdateCarrierGlsInput = {
  carrierID?: InputMaybe<Scalars['ID']>;
  clearContactID?: InputMaybe<Scalars['Boolean']>;
  clearCustomerID?: InputMaybe<Scalars['Boolean']>;
  clearGLSCountryCode?: InputMaybe<Scalars['Boolean']>;
  clearGLSPassword?: InputMaybe<Scalars['Boolean']>;
  clearGLSUsername?: InputMaybe<Scalars['Boolean']>;
  clearPrintErrorOnLabel?: InputMaybe<Scalars['Boolean']>;
  clearSyncShipmentCancellation?: InputMaybe<Scalars['Boolean']>;
  contactID?: InputMaybe<Scalars['String']>;
  customerID?: InputMaybe<Scalars['String']>;
  glsCountryCode?: InputMaybe<Scalars['String']>;
  glsPassword?: InputMaybe<Scalars['String']>;
  glsUsername?: InputMaybe<Scalars['String']>;
  printErrorOnLabel?: InputMaybe<Scalars['Boolean']>;
  syncShipmentCancellation?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdateCarrierPostNordInput is used for update CarrierPostNord object.
 * Input was generated by ent.
 */
export type UpdateCarrierPostNordInput = {
  carrierID?: InputMaybe<Scalars['ID']>;
  /** Default empty to allow creation from dialog with followup editing */
  customerNumber?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateCarrierUSPSInput is used for update CarrierUSPS object.
 * Input was generated by ent.
 */
export type UpdateCarrierUspsInput = {
  carrierID?: InputMaybe<Scalars['ID']>;
  clearConsumerKey?: InputMaybe<Scalars['Boolean']>;
  clearConsumerSecret?: InputMaybe<Scalars['Boolean']>;
  clearCrid?: InputMaybe<Scalars['Boolean']>;
  clearEpsAccountNumber?: InputMaybe<Scalars['Boolean']>;
  clearManifestMid?: InputMaybe<Scalars['Boolean']>;
  clearMid?: InputMaybe<Scalars['Boolean']>;
  consumerKey?: InputMaybe<Scalars['String']>;
  consumerSecret?: InputMaybe<Scalars['String']>;
  crid?: InputMaybe<Scalars['String']>;
  epsAccountNumber?: InputMaybe<Scalars['String']>;
  isTestAPI?: InputMaybe<Scalars['Boolean']>;
  manifestMid?: InputMaybe<Scalars['String']>;
  mid?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateColliInput is used for update Colli object.
 * Input was generated by ent.
 */
export type UpdateColliInput = {
  addCancelledShipmentParcelIDs?: InputMaybe<Array<Scalars['ID']>>;
  addDocumentFileIDs?: InputMaybe<Array<Scalars['ID']>>;
  addPrintJobIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearCancelledShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  clearDocumentFile?: InputMaybe<Scalars['Boolean']>;
  clearInternalBarcode?: InputMaybe<Scalars['Boolean']>;
  clearPackaging?: InputMaybe<Scalars['Boolean']>;
  clearPrintJob?: InputMaybe<Scalars['Boolean']>;
  clearShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  /** Code128 type C compatible for faster reads */
  internalBarcode?: InputMaybe<Scalars['Int']>;
  orderID?: InputMaybe<Scalars['ID']>;
  packagingID?: InputMaybe<Scalars['ID']>;
  removeCancelledShipmentParcelIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeDocumentFileIDs?: InputMaybe<Array<Scalars['ID']>>;
  removePrintJobIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentParcelID?: InputMaybe<Scalars['ID']>;
  slipPrintStatus?: InputMaybe<ColliSlipPrintStatus>;
};

/**
 * UpdateConnectOptionCarrierInput is used for update ConnectOptionCarrier object.
 * Input was generated by ent.
 */
export type UpdateConnectOptionCarrierInput = {
  addTenantIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearTenant?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  removeTenantIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateConnectOptionPlatformInput is used for update ConnectOptionPlatform object.
 * Input was generated by ent.
 */
export type UpdateConnectOptionPlatformInput = {
  addTenantIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearTenant?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  removeTenantIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateConnectionInput is used for update Connection object.
 * Input was generated by ent.
 */
export type UpdateConnectionInput = {
  addConnectionLookupIDs?: InputMaybe<Array<Scalars['ID']>>;
  addDeliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  addHypothesisTestIDs?: InputMaybe<Array<Scalars['ID']>>;
  addNotificationIDs?: InputMaybe<Array<Scalars['ID']>>;
  addOrderIDs?: InputMaybe<Array<Scalars['ID']>>;
  autoPrintParcelSlip?: InputMaybe<Scalars['Boolean']>;
  clearConnectionLookup?: InputMaybe<Scalars['Boolean']>;
  clearConnectionShopify?: InputMaybe<Scalars['Boolean']>;
  clearDefaultDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  clearHypothesisTest?: InputMaybe<Scalars['Boolean']>;
  clearNotifications?: InputMaybe<Scalars['Boolean']>;
  clearOrders?: InputMaybe<Scalars['Boolean']>;
  clearPackingSlipTemplate?: InputMaybe<Scalars['Boolean']>;
  clearReturnPortal?: InputMaybe<Scalars['Boolean']>;
  connectionShopifyID?: InputMaybe<Scalars['ID']>;
  convertCurrency?: InputMaybe<Scalars['Boolean']>;
  currencyID?: InputMaybe<Scalars['ID']>;
  defaultDeliveryOptionID?: InputMaybe<Scalars['ID']>;
  dispatchAutomatically?: InputMaybe<Scalars['Boolean']>;
  fulfillAutomatically?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  packingSlipTemplateID?: InputMaybe<Scalars['ID']>;
  pickupLocationID?: InputMaybe<Scalars['ID']>;
  removeConnectionLookupIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeDeliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeHypothesisTestIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeNotificationIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeOrderIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnLocationID?: InputMaybe<Scalars['ID']>;
  returnPortalID?: InputMaybe<Scalars['ID']>;
  sellerLocationID?: InputMaybe<Scalars['ID']>;
  senderLocationID?: InputMaybe<Scalars['ID']>;
  syncOrders?: InputMaybe<Scalars['Boolean']>;
  syncProducts?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdateConnectionShopifyInput is used for update ConnectionShopify object.
 * Input was generated by ent.
 */
export type UpdateConnectionShopifyInput = {
  apiKey?: InputMaybe<Scalars['String']>;
  appendFilterTags?: InputMaybe<Array<Scalars['String']>>;
  clearAPIKey?: InputMaybe<Scalars['Boolean']>;
  clearFilterTags?: InputMaybe<Scalars['Boolean']>;
  clearStoreURL?: InputMaybe<Scalars['Boolean']>;
  clearSyncFrom?: InputMaybe<Scalars['Boolean']>;
  /** When set, only orders with these tags will be synchronized. Supports a  */
  filterTags?: InputMaybe<Array<Scalars['String']>>;
  /** Since certain plans don't allow for external rates */
  rateIntegration?: InputMaybe<Scalars['Boolean']>;
  storeURL?: InputMaybe<Scalars['String']>;
  syncFrom?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateConsolidationInput is used for update Consolidation object.
 * Input was generated by ent.
 */
export type UpdateConsolidationInput = {
  addCancelledShipmentIDs?: InputMaybe<Array<Scalars['ID']>>;
  addOrderIDs?: InputMaybe<Array<Scalars['ID']>>;
  addPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearCancelledShipments?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  clearDescription?: InputMaybe<Scalars['Boolean']>;
  clearOrders?: InputMaybe<Scalars['Boolean']>;
  clearPallets?: InputMaybe<Scalars['Boolean']>;
  clearShipment?: InputMaybe<Scalars['Boolean']>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  publicID?: InputMaybe<Scalars['String']>;
  removeCancelledShipmentIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeOrderIDs?: InputMaybe<Array<Scalars['ID']>>;
  removePalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentID?: InputMaybe<Scalars['ID']>;
  status?: InputMaybe<ConsolidationStatus>;
};

/**
 * UpdateContactInput is used for update Contact object.
 * Input was generated by ent.
 */
export type UpdateContactInput = {
  addAdminContactIDs?: InputMaybe<Array<Scalars['ID']>>;
  addBillingContactIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearAdminContact?: InputMaybe<Scalars['Boolean']>;
  clearBillingContact?: InputMaybe<Scalars['Boolean']>;
  email?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  removeAdminContactIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeBillingContactIDs?: InputMaybe<Array<Scalars['ID']>>;
  surname?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateCountryHarmonizedCodeInput is used for update CountryHarmonizedCode object.
 * Input was generated by ent.
 */
export type UpdateCountryHarmonizedCodeInput = {
  code?: InputMaybe<Scalars['String']>;
  countryID?: InputMaybe<Scalars['ID']>;
  inventoryItemID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateDeliveryOptionBringInput is used for update DeliveryOptionBring object.
 * Input was generated by ent.
 */
export type UpdateDeliveryOptionBringInput = {
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  electronicCustoms?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdateDeliveryOptionEasyPostInput is used for update DeliveryOptionEasyPost object.
 * Input was generated by ent.
 */
export type UpdateDeliveryOptionEasyPostInput = {
  addCarrierAddServEasyPostIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearCarrierAddServEasyPost?: InputMaybe<Scalars['Boolean']>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  removeCarrierAddServEasyPostIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateDeliveryOptionInput is used for update DeliveryOption object.
 * Input was generated by ent.
 */
export type UpdateDeliveryOptionInput = {
  addClickCollectLocationIDs?: InputMaybe<Array<Scalars['ID']>>;
  addColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addConsolidationIDs?: InputMaybe<Array<Scalars['ID']>>;
  addDeliveryRuleIDs?: InputMaybe<Array<Scalars['ID']>>;
  addHypothesisTestDeliveryOptionGroupOneIDs?: InputMaybe<Array<Scalars['ID']>>;
  addHypothesisTestDeliveryOptionGroupTwoIDs?: InputMaybe<Array<Scalars['ID']>>;
  addHypothesisTestDeliveryOptionLookupIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnPortalIDs?: InputMaybe<Array<Scalars['ID']>>;
  archivedAt?: InputMaybe<Scalars['Time']>;
  carrierID?: InputMaybe<Scalars['ID']>;
  carrierServiceID?: InputMaybe<Scalars['ID']>;
  clearArchivedAt?: InputMaybe<Scalars['Boolean']>;
  clearClickCollect?: InputMaybe<Scalars['Boolean']>;
  clearClickCollectLocation?: InputMaybe<Scalars['Boolean']>;
  clearClickOptionDisplayCount?: InputMaybe<Scalars['Boolean']>;
  clearColli?: InputMaybe<Scalars['Boolean']>;
  clearConnectionDefault?: InputMaybe<Scalars['Boolean']>;
  clearConsolidation?: InputMaybe<Scalars['Boolean']>;
  clearCustomsSigner?: InputMaybe<Scalars['Boolean']>;
  clearDefaultPackaging?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryEstimateFrom?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryEstimateTo?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionBring?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionDAO?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionDF?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionDSV?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionEasyPost?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionGLS?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionPostNord?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionUSPS?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryRule?: InputMaybe<Scalars['Boolean']>;
  clearDescription?: InputMaybe<Scalars['Boolean']>;
  clearEmailClickCollectAtStore?: InputMaybe<Scalars['Boolean']>;
  clearHideDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  clearHypothesisTestDeliveryOptionGroupOne?: InputMaybe<Scalars['Boolean']>;
  clearHypothesisTestDeliveryOptionGroupTwo?: InputMaybe<Scalars['Boolean']>;
  clearHypothesisTestDeliveryOptionLookup?: InputMaybe<Scalars['Boolean']>;
  clearOverrideReturnAddress?: InputMaybe<Scalars['Boolean']>;
  clearOverrideSenderAddress?: InputMaybe<Scalars['Boolean']>;
  clearReturnColli?: InputMaybe<Scalars['Boolean']>;
  clearReturnPortals?: InputMaybe<Scalars['Boolean']>;
  clearShipmondoDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  clearWebshipperID?: InputMaybe<Scalars['Boolean']>;
  clickCollect?: InputMaybe<Scalars['Boolean']>;
  clickOptionDisplayCount?: InputMaybe<Scalars['Int']>;
  connectionDefaultID?: InputMaybe<Scalars['ID']>;
  connectionID?: InputMaybe<Scalars['ID']>;
  /** Since some services are customs optional */
  customsEnabled?: InputMaybe<Scalars['Boolean']>;
  /** Who is responsible for signing of custom docs */
  customsSigner?: InputMaybe<Scalars['String']>;
  defaultPackagingID?: InputMaybe<Scalars['ID']>;
  deliveryEstimateFrom?: InputMaybe<Scalars['Int']>;
  deliveryEstimateTo?: InputMaybe<Scalars['Int']>;
  deliveryOptionBringID?: InputMaybe<Scalars['ID']>;
  deliveryOptionDAOID?: InputMaybe<Scalars['ID']>;
  deliveryOptionDFID?: InputMaybe<Scalars['ID']>;
  deliveryOptionDSVID?: InputMaybe<Scalars['ID']>;
  deliveryOptionEasyPostID?: InputMaybe<Scalars['ID']>;
  deliveryOptionGLSID?: InputMaybe<Scalars['ID']>;
  deliveryOptionPostNordID?: InputMaybe<Scalars['ID']>;
  deliveryOptionUSPSID?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  emailClickCollectAtStoreID?: InputMaybe<Scalars['ID']>;
  hideDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  /** Toggle to hide this rate if a company field is not provided. */
  hideIfCompanyEmpty?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  overrideReturnAddress?: InputMaybe<Scalars['Boolean']>;
  overrideSenderAddress?: InputMaybe<Scalars['Boolean']>;
  removeClickCollectLocationIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeConsolidationIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeDeliveryRuleIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeHypothesisTestDeliveryOptionGroupOneIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeHypothesisTestDeliveryOptionGroupTwoIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeHypothesisTestDeliveryOptionLookupIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnPortalIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** May contain placeholders */
  shipmondoDeliveryOption?: InputMaybe<Scalars['String']>;
  shipmondoIntegration?: InputMaybe<Scalars['Boolean']>;
  sortOrder?: InputMaybe<Scalars['Int']>;
  webshipperID?: InputMaybe<Scalars['Int']>;
  webshipperIntegration?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdateDeliveryOptionPostNordInput is used for update DeliveryOptionPostNord object.
 * Input was generated by ent.
 */
export type UpdateDeliveryOptionPostNordInput = {
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  formatZpl?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdateDeliveryOptionUSPSInput is used for update DeliveryOptionUSPS object.
 * Input was generated by ent.
 */
export type UpdateDeliveryOptionUspsInput = {
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  formatZpl?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdateDeliveryRuleConstraintGroupInput is used for update DeliveryRuleConstraintGroup object.
 * Input was generated by ent.
 */
export type UpdateDeliveryRuleConstraintGroupInput = {
  addDeliveryRuleConstraintIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearDeliveryRuleConstraints?: InputMaybe<Scalars['Boolean']>;
  constraintLogic?: InputMaybe<DeliveryRuleConstraintGroupConstraintLogic>;
  deliveryRuleID?: InputMaybe<Scalars['ID']>;
  removeDeliveryRuleConstraintIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateDeliveryRuleConstraintInput is used for update DeliveryRuleConstraint object.
 * Input was generated by ent.
 */
export type UpdateDeliveryRuleConstraintInput = {
  comparison?: InputMaybe<DeliveryRuleConstraintComparison>;
  propertyType?: InputMaybe<DeliveryRuleConstraintPropertyType>;
  selectedValue?: InputMaybe<DeliveryRuleConstraintSelectedValueInput>;
};

/**
 * UpdateDeliveryRuleInput is used for update DeliveryRule object.
 * Input was generated by ent.
 */
export type UpdateDeliveryRuleInput = {
  addCountryIDs?: InputMaybe<Array<Scalars['ID']>>;
  addDeliveryRuleConstraintGroupIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearCountry?: InputMaybe<Scalars['Boolean']>;
  clearCurrency?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryRuleConstraintGroup?: InputMaybe<Scalars['Boolean']>;
  currencyID?: InputMaybe<Scalars['ID']>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  price?: InputMaybe<Scalars['Float']>;
  removeCountryIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeDeliveryRuleConstraintGroupIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateDocumentInput is used for update Document object.
 * Input was generated by ent.
 */
export type UpdateDocumentInput = {
  addConnectionPackingSlipIDs?: InputMaybe<Array<Scalars['ID']>>;
  carrierBrandID?: InputMaybe<Scalars['ID']>;
  clearCarrierBrand?: InputMaybe<Scalars['Boolean']>;
  clearConnectionPackingSlip?: InputMaybe<Scalars['Boolean']>;
  clearHTMLFooter?: InputMaybe<Scalars['Boolean']>;
  clearHTMLHeader?: InputMaybe<Scalars['Boolean']>;
  clearHTMLTemplate?: InputMaybe<Scalars['Boolean']>;
  clearLastBase64Pdf?: InputMaybe<Scalars['Boolean']>;
  endAt?: InputMaybe<Scalars['Time']>;
  htmlFooter?: InputMaybe<Scalars['String']>;
  htmlHeader?: InputMaybe<Scalars['String']>;
  htmlTemplate?: InputMaybe<Scalars['String']>;
  /** Facilitates printing by saving the latest version of this document */
  lastBase64Pdf?: InputMaybe<Scalars['String']>;
  mergeType?: InputMaybe<DocumentMergeType>;
  name?: InputMaybe<Scalars['String']>;
  paperSize?: InputMaybe<DocumentPaperSize>;
  removeConnectionPackingSlipIDs?: InputMaybe<Array<Scalars['ID']>>;
  startAt?: InputMaybe<Scalars['Time']>;
};

/**
 * UpdateEmailTemplateInput is used for update EmailTemplate object.
 * Input was generated by ent.
 */
export type UpdateEmailTemplateInput = {
  addDeliveryOptionClickCollectAtStoreIDs?: InputMaybe<Array<Scalars['ID']>>;
  addNotificationIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnPortalAcceptedIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnPortalConfirmationLabelIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnPortalConfirmationQrCodeIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnPortalReceivedIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearDeliveryOptionClickCollectAtStore?: InputMaybe<Scalars['Boolean']>;
  clearNotifications?: InputMaybe<Scalars['Boolean']>;
  clearReturnPortalAccepted?: InputMaybe<Scalars['Boolean']>;
  clearReturnPortalConfirmationLabel?: InputMaybe<Scalars['Boolean']>;
  clearReturnPortalConfirmationQrCode?: InputMaybe<Scalars['Boolean']>;
  clearReturnPortalReceived?: InputMaybe<Scalars['Boolean']>;
  htmlTemplate?: InputMaybe<Scalars['String']>;
  mergeType?: InputMaybe<EmailTemplateMergeType>;
  name?: InputMaybe<Scalars['String']>;
  removeDeliveryOptionClickCollectAtStoreIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeNotificationIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnPortalAcceptedIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnPortalConfirmationLabelIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnPortalConfirmationQrCodeIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnPortalReceivedIDs?: InputMaybe<Array<Scalars['ID']>>;
  subject?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateHypothesisTestDeliveryOptionInput is used for update HypothesisTestDeliveryOption object.
 * Input was generated by ent.
 */
export type UpdateHypothesisTestDeliveryOptionInput = {
  addDeliveryOptionGroupOneIDs?: InputMaybe<Array<Scalars['ID']>>;
  addDeliveryOptionGroupTwoIDs?: InputMaybe<Array<Scalars['ID']>>;
  addHypothesisTestDeliveryOptionRequestIDs?: InputMaybe<Array<Scalars['ID']>>;
  byIntervalRotation?: InputMaybe<Scalars['Boolean']>;
  byOrder?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionGroupOne?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptionGroupTwo?: InputMaybe<Scalars['Boolean']>;
  clearHypothesisTestDeliveryOptionRequest?: InputMaybe<Scalars['Boolean']>;
  hypothesisTestID?: InputMaybe<Scalars['ID']>;
  randomizeWithinGroupSort?: InputMaybe<Scalars['Boolean']>;
  removeDeliveryOptionGroupOneIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeDeliveryOptionGroupTwoIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeHypothesisTestDeliveryOptionRequestIDs?: InputMaybe<Array<Scalars['ID']>>;
  rotationIntervalHours?: InputMaybe<Scalars['Int']>;
};

/**
 * UpdateHypothesisTestDeliveryOptionLookupInput is used for update HypothesisTestDeliveryOptionLookup object.
 * Input was generated by ent.
 */
export type UpdateHypothesisTestDeliveryOptionLookupInput = {
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  hypothesisTestDeliveryOptionRequestID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateHypothesisTestDeliveryOptionRequestInput is used for update HypothesisTestDeliveryOptionRequest object.
 * Input was generated by ent.
 */
export type UpdateHypothesisTestDeliveryOptionRequestInput = {
  addHypothesisTestDeliveryOptionLookupIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearHypothesisTestDeliveryOptionLookup?: InputMaybe<Scalars['Boolean']>;
  clearOrder?: InputMaybe<Scalars['Boolean']>;
  hypothesisTestDeliveryOptionID?: InputMaybe<Scalars['ID']>;
  isControlGroup?: InputMaybe<Scalars['Boolean']>;
  orderHash?: InputMaybe<Scalars['String']>;
  orderID?: InputMaybe<Scalars['ID']>;
  removeHypothesisTestDeliveryOptionLookupIDs?: InputMaybe<Array<Scalars['ID']>>;
  requestCount?: InputMaybe<Scalars['Int']>;
  shippingAddressHash?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateHypothesisTestInput is used for update HypothesisTest object.
 * Input was generated by ent.
 */
export type UpdateHypothesisTestInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  clearHypothesisTestDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  connectionID?: InputMaybe<Scalars['ID']>;
  hypothesisTestDeliveryOptionID?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateInventoryItemInput is used for update InventoryItem object.
 * Input was generated by ent.
 */
export type UpdateInventoryItemInput = {
  addCountryHarmonizedCodeIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearCode?: InputMaybe<Scalars['Boolean']>;
  clearCountryHarmonizedCode?: InputMaybe<Scalars['Boolean']>;
  clearCountryOfOrigin?: InputMaybe<Scalars['Boolean']>;
  clearSku?: InputMaybe<Scalars['Boolean']>;
  /** Used when country specific code not available */
  code?: InputMaybe<Scalars['String']>;
  countryOfOriginID?: InputMaybe<Scalars['ID']>;
  productVariantID?: InputMaybe<Scalars['ID']>;
  removeCountryHarmonizedCodeIDs?: InputMaybe<Array<Scalars['ID']>>;
  /** Duplicated to match Shopify InventoryItem/ProductVariant */
  sku?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateLocationInput is used for update Location object.
 * Input was generated by ent.
 */
export type UpdateLocationInput = {
  addColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addDeliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  addLocationTagIDs?: InputMaybe<Array<Scalars['ID']>>;
  addPickupConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnPortalIDs?: InputMaybe<Array<Scalars['ID']>>;
  addSellerConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  addSenderConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  addressID?: InputMaybe<Scalars['ID']>;
  clearColli?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  clearPickupConnection?: InputMaybe<Scalars['Boolean']>;
  clearReturnConnection?: InputMaybe<Scalars['Boolean']>;
  clearReturnPortal?: InputMaybe<Scalars['Boolean']>;
  clearSellerConnection?: InputMaybe<Scalars['Boolean']>;
  clearSenderConnection?: InputMaybe<Scalars['Boolean']>;
  /** Location name, not used in the address */
  name?: InputMaybe<Scalars['String']>;
  removeColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeDeliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeLocationTagIDs?: InputMaybe<Array<Scalars['ID']>>;
  removePickupConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnPortalIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeSellerConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeSenderConnectionIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateNotificationInput is used for update Notification object.
 * Input was generated by ent.
 */
export type UpdateNotificationInput = {
  active?: InputMaybe<Scalars['Boolean']>;
  connectionID?: InputMaybe<Scalars['ID']>;
  emailTemplateID?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateOrderInput is used for update Order object.
 * Input was generated by ent.
 */
export type UpdateOrderInput = {
  addReturnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearCommentExternal?: InputMaybe<Scalars['Boolean']>;
  clearCommentInternal?: InputMaybe<Scalars['Boolean']>;
  clearConsolidation?: InputMaybe<Scalars['Boolean']>;
  clearHypothesisTestDeliveryOptionRequest?: InputMaybe<Scalars['Boolean']>;
  clearPallet?: InputMaybe<Scalars['Boolean']>;
  clearReturnColli?: InputMaybe<Scalars['Boolean']>;
  commentExternal?: InputMaybe<Scalars['String']>;
  commentInternal?: InputMaybe<Scalars['String']>;
  connectionID?: InputMaybe<Scalars['ID']>;
  consolidationID?: InputMaybe<Scalars['ID']>;
  hypothesisTestDeliveryOptionRequestID?: InputMaybe<Scalars['ID']>;
  orderPublicID?: InputMaybe<Scalars['String']>;
  palletID?: InputMaybe<Scalars['ID']>;
  removeReturnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateOrderSenderInput is used for update OrderSender object.
 * Input was generated by ent.
 */
export type UpdateOrderSenderInput = {
  email?: InputMaybe<Scalars['String']>;
  firstName?: InputMaybe<Scalars['String']>;
  lastName?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  vatNumber?: InputMaybe<Scalars['String']>;
};

/**
 * UpdatePackagingDFInput is used for update PackagingDF object.
 * Input was generated by ent.
 */
export type UpdatePackagingDfInput = {
  apiType?: InputMaybe<PackagingDfapiType>;
  clearMaxWeight?: InputMaybe<Scalars['Boolean']>;
  clearMinWeight?: InputMaybe<Scalars['Boolean']>;
  maxWeight?: InputMaybe<Scalars['Float']>;
  minWeight?: InputMaybe<Scalars['Float']>;
  /** Some carriers this is not boolean, so this is not a general toggle */
  stackable?: InputMaybe<Scalars['Boolean']>;
};

/**
 * UpdatePackagingInput is used for update Packaging object.
 * Input was generated by ent.
 */
export type UpdatePackagingInput = {
  addColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addDeliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  addPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addShipmentParcelIDs?: InputMaybe<Array<Scalars['ID']>>;
  archivedAt?: InputMaybe<Scalars['Time']>;
  carrierBrandID?: InputMaybe<Scalars['ID']>;
  clearArchivedAt?: InputMaybe<Scalars['Boolean']>;
  clearCarrierBrand?: InputMaybe<Scalars['Boolean']>;
  clearColli?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  clearPackagingDF?: InputMaybe<Scalars['Boolean']>;
  clearPackagingUSPS?: InputMaybe<Scalars['Boolean']>;
  clearPallet?: InputMaybe<Scalars['Boolean']>;
  clearReturnColli?: InputMaybe<Scalars['Boolean']>;
  clearShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  heightCm?: InputMaybe<Scalars['Int']>;
  lengthCm?: InputMaybe<Scalars['Int']>;
  name?: InputMaybe<Scalars['String']>;
  packagingDFID?: InputMaybe<Scalars['ID']>;
  packagingUSPSID?: InputMaybe<Scalars['ID']>;
  removeColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeDeliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  removePalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeShipmentParcelIDs?: InputMaybe<Array<Scalars['ID']>>;
  widthCm?: InputMaybe<Scalars['Int']>;
};

/**
 * UpdatePackagingUSPSInput is used for update PackagingUSPS object.
 * Input was generated by ent.
 */
export type UpdatePackagingUspsInput = {
  packagingUSPSProcessingCategoryID?: InputMaybe<Scalars['ID']>;
  packagingUSPSRateIndicatorID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdatePackagingUSPSProcessingCategoryInput is used for update PackagingUSPSProcessingCategory object.
 * Input was generated by ent.
 */
export type UpdatePackagingUspsProcessingCategoryInput = {
  name?: InputMaybe<Scalars['String']>;
  processingCategory?: InputMaybe<PackagingUspsProcessingCategoryProcessingCategory>;
};

/**
 * UpdatePalletInput is used for update Pallet object.
 * Input was generated by ent.
 */
export type UpdatePalletInput = {
  addCancelledShipmentPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  addOrderIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearCancelledShipmentPallet?: InputMaybe<Scalars['Boolean']>;
  clearOrders?: InputMaybe<Scalars['Boolean']>;
  clearPackaging?: InputMaybe<Scalars['Boolean']>;
  clearShipmentPallet?: InputMaybe<Scalars['Boolean']>;
  consolidationID?: InputMaybe<Scalars['ID']>;
  description?: InputMaybe<Scalars['String']>;
  packagingID?: InputMaybe<Scalars['ID']>;
  publicID?: InputMaybe<Scalars['String']>;
  removeCancelledShipmentPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeOrderIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentPalletID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateParcelShopBringInput is used for update ParcelShopBring object.
 * Input was generated by ent.
 */
export type UpdateParcelShopBringInput = {
  addressDeliveryID?: InputMaybe<Scalars['ID']>;
  bringID?: InputMaybe<Scalars['String']>;
  parcelShopID?: InputMaybe<Scalars['ID']>;
  /** https://developer.bring.com/api/pickup-point/#pickup-point-types */
  pointType?: InputMaybe<ParcelShopBringPointType>;
};

/**
 * UpdateParcelShopDAOInput is used for update ParcelShopDAO object.
 * Input was generated by ent.
 */
export type UpdateParcelShopDaoInput = {
  parcelShopID?: InputMaybe<Scalars['ID']>;
  shopID?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateParcelShopGLSInput is used for update ParcelShopGLS object.
 * Input was generated by ent.
 */
export type UpdateParcelShopGlsInput = {
  clearPartnerID?: InputMaybe<Scalars['Boolean']>;
  clearType?: InputMaybe<Scalars['Boolean']>;
  glsParcelShopID?: InputMaybe<Scalars['String']>;
  parcelShopID?: InputMaybe<Scalars['ID']>;
  /** Only available in Group API */
  partnerID?: InputMaybe<Scalars['String']>;
  /** Only available in Group API */
  type?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateParcelShopInput is used for update ParcelShop object.
 * Input was generated by ent.
 */
export type UpdateParcelShopInput = {
  addBusinessHoursPeriodIDs?: InputMaybe<Array<Scalars['ID']>>;
  addColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addressID?: InputMaybe<Scalars['ID']>;
  carrierBrandID?: InputMaybe<Scalars['ID']>;
  clearBusinessHoursPeriod?: InputMaybe<Scalars['Boolean']>;
  clearColli?: InputMaybe<Scalars['Boolean']>;
  clearParcelShopBring?: InputMaybe<Scalars['Boolean']>;
  clearParcelShopDAO?: InputMaybe<Scalars['Boolean']>;
  clearParcelShopGLS?: InputMaybe<Scalars['Boolean']>;
  clearParcelShopPostNord?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  parcelShopBringID?: InputMaybe<Scalars['ID']>;
  parcelShopDAOID?: InputMaybe<Scalars['ID']>;
  parcelShopGLSID?: InputMaybe<Scalars['ID']>;
  parcelShopPostNordID?: InputMaybe<Scalars['ID']>;
  removeBusinessHoursPeriodIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeColliIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateParcelShopPostNordInput is used for update ParcelShopPostNord object.
 * Input was generated by ent.
 */
export type UpdateParcelShopPostNordInput = {
  addressDeliveryID?: InputMaybe<Scalars['ID']>;
  parcelShopID?: InputMaybe<Scalars['ID']>;
  pudoid?: InputMaybe<Scalars['String']>;
  servicePointID?: InputMaybe<Scalars['String']>;
  /** No idea what the options are aside from the default: 156. Maybe box, shop, etc?? */
  typeID?: InputMaybe<Scalars['String']>;
};

/**
 * UpdatePrinterInput is used for update Printer object.
 * Input was generated by ent.
 */
export type UpdatePrinterInput = {
  addPrintJobIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearPrintJobs?: InputMaybe<Scalars['Boolean']>;
  document?: InputMaybe<Scalars['Boolean']>;
  labelPdf?: InputMaybe<Scalars['Boolean']>;
  labelPng?: InputMaybe<Scalars['Boolean']>;
  labelZpl?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  printSize?: InputMaybe<PrinterPrintSize>;
  removePrintJobIDs?: InputMaybe<Array<Scalars['ID']>>;
  rotate180?: InputMaybe<Scalars['Boolean']>;
  useShell?: InputMaybe<Scalars['Boolean']>;
  workstationID?: InputMaybe<Scalars['ID']>;
};

export type UpdatePrinterWithIdInput = {
  id: Scalars['ID'];
  updatePrinters: UpdatePrinterInput;
};

/**
 * UpdateProductInput is used for update Product object.
 * Input was generated by ent.
 */
export type UpdateProductInput = {
  addProductImageIDs?: InputMaybe<Array<Scalars['ID']>>;
  addProductTagIDs?: InputMaybe<Array<Scalars['ID']>>;
  addProductVariantIDs?: InputMaybe<Array<Scalars['ID']>>;
  bodyHTML?: InputMaybe<Scalars['String']>;
  clearBodyHTML?: InputMaybe<Scalars['Boolean']>;
  clearProductImage?: InputMaybe<Scalars['Boolean']>;
  clearProductTags?: InputMaybe<Scalars['Boolean']>;
  clearProductVariant?: InputMaybe<Scalars['Boolean']>;
  removeProductImageIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeProductTagIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeProductVariantIDs?: InputMaybe<Array<Scalars['ID']>>;
  status?: InputMaybe<ProductStatus>;
  title?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateProductTagInput is used for update ProductTag object.
 * Input was generated by ent.
 */
export type UpdateProductTagInput = {
  addProductIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearProducts?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  removeProductIDs?: InputMaybe<Array<Scalars['ID']>>;
};

export type UpdateProductVariantIdInput = {
  id: Scalars['ID'];
  variant: UpdateProductVariantInput;
};

/**
 * UpdateProductVariantInput is used for update ProductVariant object.
 * Input was generated by ent.
 */
export type UpdateProductVariantInput = {
  addOrderLineIDs?: InputMaybe<Array<Scalars['ID']>>;
  addProductImageIDs?: InputMaybe<Array<Scalars['ID']>>;
  archived?: InputMaybe<Scalars['Boolean']>;
  clearDescription?: InputMaybe<Scalars['Boolean']>;
  clearDimensionHeight?: InputMaybe<Scalars['Boolean']>;
  clearDimensionLength?: InputMaybe<Scalars['Boolean']>;
  clearDimensionWidth?: InputMaybe<Scalars['Boolean']>;
  clearEanNumber?: InputMaybe<Scalars['Boolean']>;
  clearInventoryItem?: InputMaybe<Scalars['Boolean']>;
  clearOrderLines?: InputMaybe<Scalars['Boolean']>;
  clearProductImage?: InputMaybe<Scalars['Boolean']>;
  clearWeightG?: InputMaybe<Scalars['Boolean']>;
  description?: InputMaybe<Scalars['String']>;
  dimensionHeight?: InputMaybe<Scalars['Int']>;
  dimensionLength?: InputMaybe<Scalars['Int']>;
  dimensionWidth?: InputMaybe<Scalars['Int']>;
  eanNumber?: InputMaybe<Scalars['String']>;
  inventoryItemID?: InputMaybe<Scalars['ID']>;
  removeOrderLineIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeProductImageIDs?: InputMaybe<Array<Scalars['ID']>>;
  weightG?: InputMaybe<Scalars['Int']>;
};

/**
 * UpdateReturnColliInput is used for update ReturnColli object.
 * Input was generated by ent.
 */
export type UpdateReturnColliInput = {
  addReturnOrderLineIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearComment?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOption?: InputMaybe<Scalars['Boolean']>;
  clearEmailAccepted?: InputMaybe<Scalars['Boolean']>;
  clearEmailConfirmationLabel?: InputMaybe<Scalars['Boolean']>;
  clearEmailConfirmationQrCode?: InputMaybe<Scalars['Boolean']>;
  clearEmailReceived?: InputMaybe<Scalars['Boolean']>;
  clearExpectedAt?: InputMaybe<Scalars['Boolean']>;
  clearLabelPdf?: InputMaybe<Scalars['Boolean']>;
  clearLabelPng?: InputMaybe<Scalars['Boolean']>;
  clearPackaging?: InputMaybe<Scalars['Boolean']>;
  clearQrCodePng?: InputMaybe<Scalars['Boolean']>;
  clearReturnOrderLine?: InputMaybe<Scalars['Boolean']>;
  comment?: InputMaybe<Scalars['String']>;
  deliveryOptionID?: InputMaybe<Scalars['ID']>;
  /** Timestamp of email successfully sent after status changed to accepted */
  emailAccepted?: InputMaybe<Scalars['Time']>;
  /** Timestamp of email successfully sent after status changed to pending */
  emailConfirmationLabel?: InputMaybe<Scalars['Time']>;
  /** Timestamp of email successfully sent after status changed to pending */
  emailConfirmationQrCode?: InputMaybe<Scalars['Time']>;
  /** Timestamp of email successfully sent after status changed to received */
  emailReceived?: InputMaybe<Scalars['Time']>;
  expectedAt?: InputMaybe<Scalars['Time']>;
  labelPdf?: InputMaybe<Scalars['String']>;
  labelPng?: InputMaybe<Scalars['String']>;
  orderID?: InputMaybe<Scalars['ID']>;
  packagingID?: InputMaybe<Scalars['ID']>;
  qrCodePng?: InputMaybe<Scalars['String']>;
  removeReturnOrderLineIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnPortalID?: InputMaybe<Scalars['ID']>;
  status?: InputMaybe<ReturnColliStatus>;
};

/**
 * UpdateReturnOrderLineInput is used for update ReturnOrderLine object.
 * Input was generated by ent.
 */
export type UpdateReturnOrderLineInput = {
  orderLineID?: InputMaybe<Scalars['ID']>;
  returnColliID?: InputMaybe<Scalars['ID']>;
  returnPortalClaimID?: InputMaybe<Scalars['ID']>;
  units?: InputMaybe<Scalars['Int']>;
};

/**
 * UpdateReturnPortalClaimInput is used for update ReturnPortalClaim object.
 * Input was generated by ent.
 */
export type UpdateReturnPortalClaimInput = {
  addReturnOrderLineIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearReturnLocation?: InputMaybe<Scalars['Boolean']>;
  clearReturnOrderLine?: InputMaybe<Scalars['Boolean']>;
  description?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  removeReturnOrderLineIDs?: InputMaybe<Array<Scalars['ID']>>;
  restockable?: InputMaybe<Scalars['Boolean']>;
  returnLocationID?: InputMaybe<Scalars['ID']>;
  returnPortalID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateReturnPortalInput is used for update ReturnPortal object.
 * Input was generated by ent.
 */
export type UpdateReturnPortalInput = {
  addDeliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnLocationIDs?: InputMaybe<Array<Scalars['ID']>>;
  addReturnPortalClaimIDs?: InputMaybe<Array<Scalars['ID']>>;
  automaticallyAccept?: InputMaybe<Scalars['Boolean']>;
  clearConnection?: InputMaybe<Scalars['Boolean']>;
  clearDeliveryOptions?: InputMaybe<Scalars['Boolean']>;
  clearEmailAccepted?: InputMaybe<Scalars['Boolean']>;
  clearEmailConfirmationLabel?: InputMaybe<Scalars['Boolean']>;
  clearEmailConfirmationQrCode?: InputMaybe<Scalars['Boolean']>;
  clearEmailReceived?: InputMaybe<Scalars['Boolean']>;
  clearReturnColli?: InputMaybe<Scalars['Boolean']>;
  clearReturnLocation?: InputMaybe<Scalars['Boolean']>;
  clearReturnPortalClaim?: InputMaybe<Scalars['Boolean']>;
  connectionID?: InputMaybe<Scalars['ID']>;
  emailAcceptedID?: InputMaybe<Scalars['ID']>;
  emailConfirmationLabelID?: InputMaybe<Scalars['ID']>;
  emailConfirmationQrCodeID?: InputMaybe<Scalars['ID']>;
  emailReceivedID?: InputMaybe<Scalars['ID']>;
  name?: InputMaybe<Scalars['String']>;
  removeDeliveryOptionIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnLocationIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeReturnPortalClaimIDs?: InputMaybe<Array<Scalars['ID']>>;
  returnOpenHours?: InputMaybe<Scalars['Int']>;
};

/**
 * UpdateSeatGroupAccessRightInput is used for update SeatGroupAccessRight object.
 * Input was generated by ent.
 */
export type UpdateSeatGroupAccessRightInput = {
  accessRightID?: InputMaybe<Scalars['ID']>;
  level?: InputMaybe<SeatGroupAccessRightLevel>;
  seatGroupID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateSeatGroupInput is used for update SeatGroup object.
 * Input was generated by ent.
 */
export type UpdateSeatGroupInput = {
  addAssignedAccessRightIDs?: InputMaybe<Array<Scalars['ID']>>;
  addUserIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearAssignedAccessRight?: InputMaybe<Scalars['Boolean']>;
  clearUser?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  removeAssignedAccessRightIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeUserIDs?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UpdateShipmentBringInput is used for update ShipmentBring object.
 * Input was generated by ent.
 */
export type UpdateShipmentBringInput = {
  consignmentNumber?: InputMaybe<Scalars['String']>;
  shipmentID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateShipmentDAOInput is used for update ShipmentDAO object.
 * Input was generated by ent.
 */
export type UpdateShipmentDaoInput = {
  barcodeID?: InputMaybe<Scalars['String']>;
  shipmentID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateShipmentDSVInput is used for update ShipmentDSV object.
 * Input was generated by ent.
 */
export type UpdateShipmentDsvInput = {
  barcodeID?: InputMaybe<Scalars['String']>;
  shipmentID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateShipmentInput is used for update Shipment object.
 * Input was generated by ent.
 */
export type UpdateShipmentInput = {
  addOldConsolidationIDs?: InputMaybe<Array<Scalars['ID']>>;
  addShipmentHistoryIDs?: InputMaybe<Array<Scalars['ID']>>;
  addShipmentPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  addShipmentParcelIDs?: InputMaybe<Array<Scalars['ID']>>;
  clearConsolidation?: InputMaybe<Scalars['Boolean']>;
  clearOldConsolidation?: InputMaybe<Scalars['Boolean']>;
  clearShipmentBring?: InputMaybe<Scalars['Boolean']>;
  clearShipmentDAO?: InputMaybe<Scalars['Boolean']>;
  clearShipmentDF?: InputMaybe<Scalars['Boolean']>;
  clearShipmentDSV?: InputMaybe<Scalars['Boolean']>;
  clearShipmentEasyPost?: InputMaybe<Scalars['Boolean']>;
  clearShipmentGLS?: InputMaybe<Scalars['Boolean']>;
  clearShipmentHistory?: InputMaybe<Scalars['Boolean']>;
  clearShipmentPallet?: InputMaybe<Scalars['Boolean']>;
  clearShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  clearShipmentPostNord?: InputMaybe<Scalars['Boolean']>;
  clearShipmentUSPS?: InputMaybe<Scalars['Boolean']>;
  consolidationID?: InputMaybe<Scalars['ID']>;
  removeOldConsolidationIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeShipmentHistoryIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeShipmentPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeShipmentParcelIDs?: InputMaybe<Array<Scalars['ID']>>;
  shipmentBringID?: InputMaybe<Scalars['ID']>;
  shipmentDAOID?: InputMaybe<Scalars['ID']>;
  shipmentDFID?: InputMaybe<Scalars['ID']>;
  shipmentDSVID?: InputMaybe<Scalars['ID']>;
  shipmentEasyPostID?: InputMaybe<Scalars['ID']>;
  shipmentGLSID?: InputMaybe<Scalars['ID']>;
  shipmentPostNordID?: InputMaybe<Scalars['ID']>;
  shipmentPublicID?: InputMaybe<Scalars['String']>;
  shipmentUSPSID?: InputMaybe<Scalars['ID']>;
  status?: InputMaybe<ShipmentStatus>;
};

/**
 * UpdateShipmentPalletInput is used for update ShipmentPallet object.
 * Input was generated by ent.
 */
export type UpdateShipmentPalletInput = {
  addOldPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  barcode?: InputMaybe<Scalars['String']>;
  carrierID?: InputMaybe<Scalars['String']>;
  clearLabelPdf?: InputMaybe<Scalars['Boolean']>;
  clearLabelZpl?: InputMaybe<Scalars['Boolean']>;
  clearOldPallet?: InputMaybe<Scalars['Boolean']>;
  clearPallet?: InputMaybe<Scalars['Boolean']>;
  colliNumber?: InputMaybe<Scalars['String']>;
  labelPdf?: InputMaybe<Scalars['String']>;
  labelZpl?: InputMaybe<Scalars['String']>;
  palletID?: InputMaybe<Scalars['ID']>;
  removeOldPalletIDs?: InputMaybe<Array<Scalars['ID']>>;
  status?: InputMaybe<ShipmentPalletStatus>;
};

/**
 * UpdateShipmentParcelInput is used for update ShipmentParcel object.
 * Input was generated by ent.
 */
export type UpdateShipmentParcelInput = {
  addOldColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  addPrintJobIDs?: InputMaybe<Array<Scalars['ID']>>;
  addWorkspaceRecentScanIDs?: InputMaybe<Array<Scalars['ID']>>;
  appendCcPickupSignatureUrls?: InputMaybe<Array<Scalars['String']>>;
  ccPickupSignatureUrls?: InputMaybe<Array<Scalars['String']>>;
  clearCcPickupSignatureUrls?: InputMaybe<Scalars['Boolean']>;
  clearColli?: InputMaybe<Scalars['Boolean']>;
  clearDocumentFile?: InputMaybe<Scalars['Boolean']>;
  clearItemID?: InputMaybe<Scalars['Boolean']>;
  clearOldColli?: InputMaybe<Scalars['Boolean']>;
  clearPackaging?: InputMaybe<Scalars['Boolean']>;
  clearPrintJob?: InputMaybe<Scalars['Boolean']>;
  clearWorkspaceRecentScan?: InputMaybe<Scalars['Boolean']>;
  colliID?: InputMaybe<Scalars['ID']>;
  documentFileID?: InputMaybe<Scalars['ID']>;
  itemID?: InputMaybe<Scalars['String']>;
  packagingID?: InputMaybe<Scalars['ID']>;
  removeOldColliIDs?: InputMaybe<Array<Scalars['ID']>>;
  removePrintJobIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeWorkspaceRecentScanIDs?: InputMaybe<Array<Scalars['ID']>>;
  status?: InputMaybe<ShipmentParcelStatus>;
};

/**
 * UpdateShipmentPostNordInput is used for update ShipmentPostNord object.
 * Input was generated by ent.
 */
export type UpdateShipmentPostNordInput = {
  /** Multiple labels. May contain unrelated shipments. */
  bookingID?: InputMaybe<Scalars['String']>;
  /** Individual label. Can be grouped to same address. Probably should not be on this ent? */
  itemID?: InputMaybe<Scalars['String']>;
  shipmentID?: InputMaybe<Scalars['ID']>;
  /** Shipment can contain multiple parcels to same address. */
  shipmentReferenceNo?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateShipmentUSPSInput is used for update ShipmentUSPS object.
 * Input was generated by ent.
 */
export type UpdateShipmentUspsInput = {
  clearPostage?: InputMaybe<Scalars['Boolean']>;
  clearScheduledDeliveryDate?: InputMaybe<Scalars['Boolean']>;
  clearTrackingNumber?: InputMaybe<Scalars['Boolean']>;
  postage?: InputMaybe<Scalars['Float']>;
  scheduledDeliveryDate?: InputMaybe<Scalars['Time']>;
  shipmentID?: InputMaybe<Scalars['ID']>;
  trackingNumber?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateSignupOptionsInput is used for update SignupOptions object.
 * Input was generated by ent.
 */
export type UpdateSignupOptionsInput = {
  betterDeliveryOptions?: InputMaybe<Scalars['Boolean']>;
  clickCollect?: InputMaybe<Scalars['Boolean']>;
  customDocs?: InputMaybe<Scalars['Boolean']>;
  easyReturns?: InputMaybe<Scalars['Boolean']>;
  improvePickPack?: InputMaybe<Scalars['Boolean']>;
  numShipments?: InputMaybe<Scalars['Int']>;
  reducedCosts?: InputMaybe<Scalars['Boolean']>;
  shippingLabel?: InputMaybe<Scalars['Boolean']>;
  usersID?: InputMaybe<Scalars['ID']>;
};

/**
 * UpdateTenantInput is used for update Tenant object.
 * Input was generated by ent.
 */
export type UpdateTenantInput = {
  addConnectOptionCarrierIDs?: InputMaybe<Array<Scalars['ID']>>;
  addConnectOptionPlatformIDs?: InputMaybe<Array<Scalars['ID']>>;
  adminContactID?: InputMaybe<Scalars['ID']>;
  billingContactID?: InputMaybe<Scalars['ID']>;
  clearAdminContact?: InputMaybe<Scalars['Boolean']>;
  clearBillingContact?: InputMaybe<Scalars['Boolean']>;
  clearCompanyAddress?: InputMaybe<Scalars['Boolean']>;
  clearConnectOptionCarriers?: InputMaybe<Scalars['Boolean']>;
  clearConnectOptionPlatforms?: InputMaybe<Scalars['Boolean']>;
  clearInvoiceReference?: InputMaybe<Scalars['Boolean']>;
  clearVatNumber?: InputMaybe<Scalars['Boolean']>;
  companyAddressID?: InputMaybe<Scalars['ID']>;
  defaultLanguageID?: InputMaybe<Scalars['ID']>;
  invoiceReference?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  planID?: InputMaybe<Scalars['ID']>;
  removeConnectOptionCarrierIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeConnectOptionPlatformIDs?: InputMaybe<Array<Scalars['ID']>>;
  vatNumber?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateUserInput is used for update User object.
 * Input was generated by ent.
 */
export type UpdateUserInput = {
  addAPITokenIDs?: InputMaybe<Array<Scalars['ID']>>;
  addChangeHistoryIDs?: InputMaybe<Array<Scalars['ID']>>;
  addOtkRequestIDs?: InputMaybe<Array<Scalars['ID']>>;
  addPlanHistoryUserIDs?: InputMaybe<Array<Scalars['ID']>>;
  addWorkspaceRecentScanIDs?: InputMaybe<Array<Scalars['ID']>>;
  archivedAt?: InputMaybe<Scalars['Time']>;
  clearAPIToken?: InputMaybe<Scalars['Boolean']>;
  clearArchivedAt?: InputMaybe<Scalars['Boolean']>;
  clearChangeHistory?: InputMaybe<Scalars['Boolean']>;
  clearLanguage?: InputMaybe<Scalars['Boolean']>;
  clearMarketingConsent?: InputMaybe<Scalars['Boolean']>;
  clearName?: InputMaybe<Scalars['Boolean']>;
  clearOtkRequests?: InputMaybe<Scalars['Boolean']>;
  clearPassword?: InputMaybe<Scalars['Boolean']>;
  clearPhoneNumber?: InputMaybe<Scalars['Boolean']>;
  clearPickupDayLastChanged?: InputMaybe<Scalars['Boolean']>;
  clearPlanHistoryUser?: InputMaybe<Scalars['Boolean']>;
  clearSeatGroup?: InputMaybe<Scalars['Boolean']>;
  clearSelectedWorkstation?: InputMaybe<Scalars['Boolean']>;
  clearSignupOptions?: InputMaybe<Scalars['Boolean']>;
  clearSurname?: InputMaybe<Scalars['Boolean']>;
  clearWorkspaceRecentScan?: InputMaybe<Scalars['Boolean']>;
  email?: InputMaybe<Scalars['String']>;
  languageID?: InputMaybe<Scalars['ID']>;
  marketingConsent?: InputMaybe<Scalars['Boolean']>;
  name?: InputMaybe<Scalars['String']>;
  /** Field is just for front end convenience. Password gets stored as hash. */
  password?: InputMaybe<Scalars['String']>;
  phoneNumber?: InputMaybe<Scalars['String']>;
  /** When fulfilling, the next carrier pickup date for the package can be selected */
  pickupDay?: InputMaybe<UserPickupDay>;
  /** So we can ask the user to confirm their pickup day after X hours */
  pickupDayLastChanged?: InputMaybe<Scalars['Time']>;
  removeAPITokenIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeChangeHistoryIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeOtkRequestIDs?: InputMaybe<Array<Scalars['ID']>>;
  removePlanHistoryUserIDs?: InputMaybe<Array<Scalars['ID']>>;
  removeWorkspaceRecentScanIDs?: InputMaybe<Array<Scalars['ID']>>;
  seatGroupID?: InputMaybe<Scalars['ID']>;
  selectedWorkstationID?: InputMaybe<Scalars['ID']>;
  signupOptionsID?: InputMaybe<Scalars['ID']>;
  surname?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateUserSeatInput is used for update UserSeat object.
 * Input was generated by ent.
 */
export type UpdateUserSeatInput = {
  clearName?: InputMaybe<Scalars['Boolean']>;
  clearSurname?: InputMaybe<Scalars['Boolean']>;
  email?: InputMaybe<Scalars['String']>;
  name?: InputMaybe<Scalars['String']>;
  surname?: InputMaybe<Scalars['String']>;
};

/**
 * UpdateWorkstationInput is used for update Workstation object.
 * Input was generated by ent.
 */
export type UpdateWorkstationInput = {
  addPrinterIDs?: InputMaybe<Array<Scalars['ID']>>;
  archivedAt?: InputMaybe<Scalars['Time']>;
  autoPrintReceiver?: InputMaybe<Scalars['Boolean']>;
  clearArchivedAt?: InputMaybe<Scalars['Boolean']>;
  clearPrinter?: InputMaybe<Scalars['Boolean']>;
  clearSelectedUser?: InputMaybe<Scalars['Boolean']>;
  deviceType?: InputMaybe<WorkstationDeviceType>;
  name?: InputMaybe<Scalars['String']>;
  removePrinterIDs?: InputMaybe<Array<Scalars['ID']>>;
  selectedUserID?: InputMaybe<Scalars['ID']>;
  status?: InputMaybe<WorkstationStatus>;
  updatePrinters: Array<UpdatePrinterWithIdInput>;
};

export type User = Node & {
  apiToken?: Maybe<Array<ApiToken>>;
  archivedAt?: Maybe<Scalars['Time']>;
  changeHistory?: Maybe<Array<ChangeHistory>>;
  createdAt?: Maybe<Scalars['Time']>;
  email: Scalars['String'];
  id: Scalars['ID'];
  isAccountOwner: Scalars['Boolean'];
  isGlobalAdmin: Scalars['Boolean'];
  language?: Maybe<Language>;
  marketingConsent?: Maybe<Scalars['Boolean']>;
  name?: Maybe<Scalars['String']>;
  otkRequests?: Maybe<Array<OtkRequests>>;
  phoneNumber?: Maybe<Scalars['String']>;
  /** When fulfilling, the next carrier pickup date for the package can be selected */
  pickupDay: UserPickupDay;
  /** So we can ask the user to confirm their pickup day after X hours */
  pickupDayLastChanged?: Maybe<Scalars['Time']>;
  planHistoryUser?: Maybe<Array<PlanHistory>>;
  seatGroup?: Maybe<SeatGroup>;
  selectedWorkstation?: Maybe<Workstation>;
  signupOptions?: Maybe<SignupOptions>;
  surname?: Maybe<Scalars['String']>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  workspaceRecentScan?: Maybe<Array<WorkspaceRecentScan>>;
};

/** A connection to a list of items. */
export type UserConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type UserEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<User>;
};

/** UserPickupDay is enum for the field pickup_day */
export enum UserPickupDay {
  In_2Days = 'In_2_Days',
  In_3Days = 'In_3_Days',
  In_4Days = 'In_4_Days',
  In_5Days = 'In_5_Days',
  Today = 'Today',
  Tomorrow = 'Tomorrow'
}

export type UserSeat = Node & {
  createdAt: Scalars['Time'];
  email: Scalars['String'];
  id: Scalars['ID'];
  name?: Maybe<Scalars['String']>;
  surname?: Maybe<Scalars['String']>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
};

/** A connection to a list of items. */
export type UserSeatConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<UserSeatEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** An edge in a connection. */
export type UserSeatEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<UserSeat>;
};

/**
 * UserSeatWhereInput is used for filtering UserSeat objects.
 * Input was generated by ent.
 */
export type UserSeatWhereInput = {
  and?: InputMaybe<Array<UserSeatWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<UserSeatWhereInput>;
  or?: InputMaybe<Array<UserSeatWhereInput>>;
  /** surname field predicates */
  surname?: InputMaybe<Scalars['String']>;
  surnameContains?: InputMaybe<Scalars['String']>;
  surnameContainsFold?: InputMaybe<Scalars['String']>;
  surnameEqualFold?: InputMaybe<Scalars['String']>;
  surnameGT?: InputMaybe<Scalars['String']>;
  surnameGTE?: InputMaybe<Scalars['String']>;
  surnameHasPrefix?: InputMaybe<Scalars['String']>;
  surnameHasSuffix?: InputMaybe<Scalars['String']>;
  surnameIn?: InputMaybe<Array<Scalars['String']>>;
  surnameIsNil?: InputMaybe<Scalars['Boolean']>;
  surnameLT?: InputMaybe<Scalars['String']>;
  surnameLTE?: InputMaybe<Scalars['String']>;
  surnameNEQ?: InputMaybe<Scalars['String']>;
  surnameNotIn?: InputMaybe<Array<Scalars['String']>>;
  surnameNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

/**
 * UserWhereInput is used for filtering User objects.
 * Input was generated by ent.
 */
export type UserWhereInput = {
  and?: InputMaybe<Array<UserWhereInput>>;
  /** archived_at field predicates */
  archivedAt?: InputMaybe<Scalars['Time']>;
  archivedAtGT?: InputMaybe<Scalars['Time']>;
  archivedAtGTE?: InputMaybe<Scalars['Time']>;
  archivedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  archivedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  archivedAtLT?: InputMaybe<Scalars['Time']>;
  archivedAtLTE?: InputMaybe<Scalars['Time']>;
  archivedAtNEQ?: InputMaybe<Scalars['Time']>;
  archivedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  archivedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtIsNil?: InputMaybe<Scalars['Boolean']>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** email field predicates */
  email?: InputMaybe<Scalars['String']>;
  emailContains?: InputMaybe<Scalars['String']>;
  emailContainsFold?: InputMaybe<Scalars['String']>;
  emailEqualFold?: InputMaybe<Scalars['String']>;
  emailGT?: InputMaybe<Scalars['String']>;
  emailGTE?: InputMaybe<Scalars['String']>;
  emailHasPrefix?: InputMaybe<Scalars['String']>;
  emailHasSuffix?: InputMaybe<Scalars['String']>;
  emailIn?: InputMaybe<Array<Scalars['String']>>;
  emailLT?: InputMaybe<Scalars['String']>;
  emailLTE?: InputMaybe<Scalars['String']>;
  emailNEQ?: InputMaybe<Scalars['String']>;
  emailNotIn?: InputMaybe<Array<Scalars['String']>>;
  /** api_token edge predicates */
  hasAPIToken?: InputMaybe<Scalars['Boolean']>;
  hasAPITokenWith?: InputMaybe<Array<ApiTokenWhereInput>>;
  /** change_history edge predicates */
  hasChangeHistory?: InputMaybe<Scalars['Boolean']>;
  hasChangeHistoryWith?: InputMaybe<Array<ChangeHistoryWhereInput>>;
  /** language edge predicates */
  hasLanguage?: InputMaybe<Scalars['Boolean']>;
  hasLanguageWith?: InputMaybe<Array<LanguageWhereInput>>;
  /** otk_requests edge predicates */
  hasOtkRequests?: InputMaybe<Scalars['Boolean']>;
  hasOtkRequestsWith?: InputMaybe<Array<OtkRequestsWhereInput>>;
  /** plan_history_user edge predicates */
  hasPlanHistoryUser?: InputMaybe<Scalars['Boolean']>;
  hasPlanHistoryUserWith?: InputMaybe<Array<PlanHistoryWhereInput>>;
  /** seat_group edge predicates */
  hasSeatGroup?: InputMaybe<Scalars['Boolean']>;
  hasSeatGroupWith?: InputMaybe<Array<SeatGroupWhereInput>>;
  /** selected_workstation edge predicates */
  hasSelectedWorkstation?: InputMaybe<Scalars['Boolean']>;
  hasSelectedWorkstationWith?: InputMaybe<Array<WorkstationWhereInput>>;
  /** signup_options edge predicates */
  hasSignupOptions?: InputMaybe<Scalars['Boolean']>;
  hasSignupOptionsWith?: InputMaybe<Array<SignupOptionsWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** workspace_recent_scan edge predicates */
  hasWorkspaceRecentScan?: InputMaybe<Scalars['Boolean']>;
  hasWorkspaceRecentScanWith?: InputMaybe<Array<WorkspaceRecentScanWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** is_account_owner field predicates */
  isAccountOwner?: InputMaybe<Scalars['Boolean']>;
  isAccountOwnerNEQ?: InputMaybe<Scalars['Boolean']>;
  /** is_global_admin field predicates */
  isGlobalAdmin?: InputMaybe<Scalars['Boolean']>;
  isGlobalAdminNEQ?: InputMaybe<Scalars['Boolean']>;
  /** marketing_consent field predicates */
  marketingConsent?: InputMaybe<Scalars['Boolean']>;
  marketingConsentIsNil?: InputMaybe<Scalars['Boolean']>;
  marketingConsentNEQ?: InputMaybe<Scalars['Boolean']>;
  marketingConsentNotNil?: InputMaybe<Scalars['Boolean']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameIsNil?: InputMaybe<Scalars['Boolean']>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  nameNotNil?: InputMaybe<Scalars['Boolean']>;
  not?: InputMaybe<UserWhereInput>;
  or?: InputMaybe<Array<UserWhereInput>>;
  /** phone_number field predicates */
  phoneNumber?: InputMaybe<Scalars['String']>;
  phoneNumberContains?: InputMaybe<Scalars['String']>;
  phoneNumberContainsFold?: InputMaybe<Scalars['String']>;
  phoneNumberEqualFold?: InputMaybe<Scalars['String']>;
  phoneNumberGT?: InputMaybe<Scalars['String']>;
  phoneNumberGTE?: InputMaybe<Scalars['String']>;
  phoneNumberHasPrefix?: InputMaybe<Scalars['String']>;
  phoneNumberHasSuffix?: InputMaybe<Scalars['String']>;
  phoneNumberIn?: InputMaybe<Array<Scalars['String']>>;
  phoneNumberIsNil?: InputMaybe<Scalars['Boolean']>;
  phoneNumberLT?: InputMaybe<Scalars['String']>;
  phoneNumberLTE?: InputMaybe<Scalars['String']>;
  phoneNumberNEQ?: InputMaybe<Scalars['String']>;
  phoneNumberNotIn?: InputMaybe<Array<Scalars['String']>>;
  phoneNumberNotNil?: InputMaybe<Scalars['Boolean']>;
  /** pickup_day field predicates */
  pickupDay?: InputMaybe<UserPickupDay>;
  pickupDayIn?: InputMaybe<Array<UserPickupDay>>;
  /** pickup_day_last_changed field predicates */
  pickupDayLastChanged?: InputMaybe<Scalars['Time']>;
  pickupDayLastChangedGT?: InputMaybe<Scalars['Time']>;
  pickupDayLastChangedGTE?: InputMaybe<Scalars['Time']>;
  pickupDayLastChangedIn?: InputMaybe<Array<Scalars['Time']>>;
  pickupDayLastChangedIsNil?: InputMaybe<Scalars['Boolean']>;
  pickupDayLastChangedLT?: InputMaybe<Scalars['Time']>;
  pickupDayLastChangedLTE?: InputMaybe<Scalars['Time']>;
  pickupDayLastChangedNEQ?: InputMaybe<Scalars['Time']>;
  pickupDayLastChangedNotIn?: InputMaybe<Array<Scalars['Time']>>;
  pickupDayLastChangedNotNil?: InputMaybe<Scalars['Boolean']>;
  pickupDayNEQ?: InputMaybe<UserPickupDay>;
  pickupDayNotIn?: InputMaybe<Array<UserPickupDay>>;
  /** surname field predicates */
  surname?: InputMaybe<Scalars['String']>;
  surnameContains?: InputMaybe<Scalars['String']>;
  surnameContainsFold?: InputMaybe<Scalars['String']>;
  surnameEqualFold?: InputMaybe<Scalars['String']>;
  surnameGT?: InputMaybe<Scalars['String']>;
  surnameGTE?: InputMaybe<Scalars['String']>;
  surnameHasPrefix?: InputMaybe<Scalars['String']>;
  surnameHasSuffix?: InputMaybe<Scalars['String']>;
  surnameIn?: InputMaybe<Array<Scalars['String']>>;
  surnameIsNil?: InputMaybe<Scalars['Boolean']>;
  surnameLT?: InputMaybe<Scalars['String']>;
  surnameLTE?: InputMaybe<Scalars['String']>;
  surnameNEQ?: InputMaybe<Scalars['String']>;
  surnameNotIn?: InputMaybe<Array<Scalars['String']>>;
  surnameNotNil?: InputMaybe<Scalars['Boolean']>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type WorkspaceRecentScan = Node & {
  createdAt: Scalars['Time'];
  id: Scalars['ID'];
  shipmentParcel?: Maybe<ShipmentParcel>;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  user: User;
};

/**
 * WorkspaceRecentScanWhereInput is used for filtering WorkspaceRecentScan objects.
 * Input was generated by ent.
 */
export type WorkspaceRecentScanWhereInput = {
  and?: InputMaybe<Array<WorkspaceRecentScanWhereInput>>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** shipment_parcel edge predicates */
  hasShipmentParcel?: InputMaybe<Scalars['Boolean']>;
  hasShipmentParcelWith?: InputMaybe<Array<ShipmentParcelWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  not?: InputMaybe<WorkspaceRecentScanWhereInput>;
  or?: InputMaybe<Array<WorkspaceRecentScanWhereInput>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
};

export type Workstation = Node & {
  archivedAt?: Maybe<Scalars['Time']>;
  autoPrintReceiver: Scalars['Boolean'];
  createdAt: Scalars['Time'];
  deviceType: WorkstationDeviceType;
  id: Scalars['ID'];
  lastPing?: Maybe<Scalars['Time']>;
  name: Scalars['String'];
  printer?: Maybe<Array<Printer>>;
  /** the user currently sending print jobs to this workstation */
  selectedUser?: Maybe<User>;
  status: WorkstationStatus;
  tenant: Tenant;
  tenantID: Scalars['ID'];
  /** the user who created the workstation */
  user?: Maybe<User>;
  workstationID: Scalars['String'];
};

/** A connection to a list of items. */
export type WorkstationConnection = {
  /** A list of edges. */
  edges?: Maybe<Array<Maybe<WorkstationEdge>>>;
  /** Information to aid in pagination. */
  pageInfo: PageInfo;
  /** Identifies the total count of items in the connection. */
  totalCount: Scalars['Int'];
};

/** WorkstationDeviceType is enum for the field device_type */
export enum WorkstationDeviceType {
  App = 'app',
  LabelStation = 'label_station'
}

/** An edge in a connection. */
export type WorkstationEdge = {
  /** A cursor for use in pagination. */
  cursor: Scalars['Cursor'];
  /** The item at the end of the edge. */
  node?: Maybe<Workstation>;
};

/** WorkstationStatus is enum for the field status */
export enum WorkstationStatus {
  Active = 'active',
  Disabled = 'disabled',
  Offline = 'offline',
  Pending = 'pending'
}

/**
 * WorkstationWhereInput is used for filtering Workstation objects.
 * Input was generated by ent.
 */
export type WorkstationWhereInput = {
  and?: InputMaybe<Array<WorkstationWhereInput>>;
  /** archived_at field predicates */
  archivedAt?: InputMaybe<Scalars['Time']>;
  archivedAtGT?: InputMaybe<Scalars['Time']>;
  archivedAtGTE?: InputMaybe<Scalars['Time']>;
  archivedAtIn?: InputMaybe<Array<Scalars['Time']>>;
  archivedAtIsNil?: InputMaybe<Scalars['Boolean']>;
  archivedAtLT?: InputMaybe<Scalars['Time']>;
  archivedAtLTE?: InputMaybe<Scalars['Time']>;
  archivedAtNEQ?: InputMaybe<Scalars['Time']>;
  archivedAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  archivedAtNotNil?: InputMaybe<Scalars['Boolean']>;
  /** auto_print_receiver field predicates */
  autoPrintReceiver?: InputMaybe<Scalars['Boolean']>;
  autoPrintReceiverNEQ?: InputMaybe<Scalars['Boolean']>;
  /** created_at field predicates */
  createdAt?: InputMaybe<Scalars['Time']>;
  createdAtGT?: InputMaybe<Scalars['Time']>;
  createdAtGTE?: InputMaybe<Scalars['Time']>;
  createdAtIn?: InputMaybe<Array<Scalars['Time']>>;
  createdAtLT?: InputMaybe<Scalars['Time']>;
  createdAtLTE?: InputMaybe<Scalars['Time']>;
  createdAtNEQ?: InputMaybe<Scalars['Time']>;
  createdAtNotIn?: InputMaybe<Array<Scalars['Time']>>;
  /** device_type field predicates */
  deviceType?: InputMaybe<WorkstationDeviceType>;
  deviceTypeIn?: InputMaybe<Array<WorkstationDeviceType>>;
  deviceTypeNEQ?: InputMaybe<WorkstationDeviceType>;
  deviceTypeNotIn?: InputMaybe<Array<WorkstationDeviceType>>;
  /** printer edge predicates */
  hasPrinter?: InputMaybe<Scalars['Boolean']>;
  hasPrinterWith?: InputMaybe<Array<PrinterWhereInput>>;
  /** selected_user edge predicates */
  hasSelectedUser?: InputMaybe<Scalars['Boolean']>;
  hasSelectedUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** tenant edge predicates */
  hasTenant?: InputMaybe<Scalars['Boolean']>;
  hasTenantWith?: InputMaybe<Array<TenantWhereInput>>;
  /** user edge predicates */
  hasUser?: InputMaybe<Scalars['Boolean']>;
  hasUserWith?: InputMaybe<Array<UserWhereInput>>;
  /** id field predicates */
  id?: InputMaybe<Scalars['ID']>;
  idGT?: InputMaybe<Scalars['ID']>;
  idGTE?: InputMaybe<Scalars['ID']>;
  idIn?: InputMaybe<Array<Scalars['ID']>>;
  idLT?: InputMaybe<Scalars['ID']>;
  idLTE?: InputMaybe<Scalars['ID']>;
  idNEQ?: InputMaybe<Scalars['ID']>;
  idNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** last_ping field predicates */
  lastPing?: InputMaybe<Scalars['Time']>;
  lastPingGT?: InputMaybe<Scalars['Time']>;
  lastPingGTE?: InputMaybe<Scalars['Time']>;
  lastPingIn?: InputMaybe<Array<Scalars['Time']>>;
  lastPingIsNil?: InputMaybe<Scalars['Boolean']>;
  lastPingLT?: InputMaybe<Scalars['Time']>;
  lastPingLTE?: InputMaybe<Scalars['Time']>;
  lastPingNEQ?: InputMaybe<Scalars['Time']>;
  lastPingNotIn?: InputMaybe<Array<Scalars['Time']>>;
  lastPingNotNil?: InputMaybe<Scalars['Boolean']>;
  /** name field predicates */
  name?: InputMaybe<Scalars['String']>;
  nameContains?: InputMaybe<Scalars['String']>;
  nameContainsFold?: InputMaybe<Scalars['String']>;
  nameEqualFold?: InputMaybe<Scalars['String']>;
  nameGT?: InputMaybe<Scalars['String']>;
  nameGTE?: InputMaybe<Scalars['String']>;
  nameHasPrefix?: InputMaybe<Scalars['String']>;
  nameHasSuffix?: InputMaybe<Scalars['String']>;
  nameIn?: InputMaybe<Array<Scalars['String']>>;
  nameLT?: InputMaybe<Scalars['String']>;
  nameLTE?: InputMaybe<Scalars['String']>;
  nameNEQ?: InputMaybe<Scalars['String']>;
  nameNotIn?: InputMaybe<Array<Scalars['String']>>;
  not?: InputMaybe<WorkstationWhereInput>;
  or?: InputMaybe<Array<WorkstationWhereInput>>;
  /** status field predicates */
  status?: InputMaybe<WorkstationStatus>;
  statusIn?: InputMaybe<Array<WorkstationStatus>>;
  statusNEQ?: InputMaybe<WorkstationStatus>;
  statusNotIn?: InputMaybe<Array<WorkstationStatus>>;
  /** tenant_id field predicates */
  tenantID?: InputMaybe<Scalars['ID']>;
  tenantIDContains?: InputMaybe<Scalars['ID']>;
  tenantIDContainsFold?: InputMaybe<Scalars['ID']>;
  tenantIDEqualFold?: InputMaybe<Scalars['ID']>;
  tenantIDGT?: InputMaybe<Scalars['ID']>;
  tenantIDGTE?: InputMaybe<Scalars['ID']>;
  tenantIDHasPrefix?: InputMaybe<Scalars['ID']>;
  tenantIDHasSuffix?: InputMaybe<Scalars['ID']>;
  tenantIDIn?: InputMaybe<Array<Scalars['ID']>>;
  tenantIDLT?: InputMaybe<Scalars['ID']>;
  tenantIDLTE?: InputMaybe<Scalars['ID']>;
  tenantIDNEQ?: InputMaybe<Scalars['ID']>;
  tenantIDNotIn?: InputMaybe<Array<Scalars['ID']>>;
  /** workstation_id field predicates */
  workstationID?: InputMaybe<Scalars['String']>;
  workstationIDContains?: InputMaybe<Scalars['String']>;
  workstationIDContainsFold?: InputMaybe<Scalars['String']>;
  workstationIDEqualFold?: InputMaybe<Scalars['String']>;
  workstationIDGT?: InputMaybe<Scalars['String']>;
  workstationIDGTE?: InputMaybe<Scalars['String']>;
  workstationIDHasPrefix?: InputMaybe<Scalars['String']>;
  workstationIDHasSuffix?: InputMaybe<Scalars['String']>;
  workstationIDIn?: InputMaybe<Array<Scalars['String']>>;
  workstationIDLT?: InputMaybe<Scalars['String']>;
  workstationIDLTE?: InputMaybe<Scalars['String']>;
  workstationIDNEQ?: InputMaybe<Scalars['String']>;
  workstationIDNotIn?: InputMaybe<Array<Scalars['String']>>;
};
