package gengql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"

	"delivrio.io/go/ent"
	"delivrio.io/go/ent/document"
	"delivrio.io/go/gengql/generated/models"
	"delivrio.io/go/mergeutils"
	"delivrio.io/go/utils"
	"delivrio.io/go/viewer"
	"delivrio.io/shared-utils/pulid"
)

// CreateDocument is the resolver for the createDocument field.
func (r *mutationResolver) CreateDocument(ctx context.Context, name string, mergeType document.MergeType) (pulid.ID, error) {
	view := viewer.FromContext(ctx)
	tx := ent.FromContext(ctx)

	doc, err := tx.Document.Create().
		SetName(name).
		SetMergeType(mergeType).
		SetTenantID(view.TenantID()).
		Save(ctx)
	if err != nil {
		return "", err
	}

	return doc.ID, nil
}

// UpdateDocument is the resolver for the updateDocument field.
func (r *mutationResolver) UpdateDocument(ctx context.Context, id pulid.ID, input ent.UpdateDocumentInput) (*ent.Document, error) {
	tx := ent.FromContext(ctx)

	err := mergeutils.ValidateMergeVariables(ctx, input)
	if err != nil {
		return nil, err
	}

	err = tx.Document.Update().
		SetInput(input).
		Where(document.ID(id)).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return tx.Document.Query().
		Where(document.ID(id)).
		Only(ctx)
}

// Document is the resolver for the document field.
func (r *queryResolver) Document(ctx context.Context, id pulid.ID) (*ent.Document, error) {
	cli := ent.FromContext(ctx)

	return cli.Document.Query().
		Where(document.ID(id)).
		Only(ctx)
}

// DocumentDownload is the resolver for the documentDownload field.
func (r *queryResolver) DocumentDownload(ctx context.Context, id pulid.ID) (*models.DocumentDownload, error) {
	cli := ent.FromContext(ctx)
	doc, err := cli.Document.Query().
		WithCarrierBrand().
		Where(document.ID(id)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	var cbID *pulid.ID
	if doc.Edges.CarrierBrand != nil {
		cbID = &doc.Edges.CarrierBrand.ID
	}

	var mergeVar interface{}
	switch doc.MergeType {
	case document.MergeTypeOrders:
		mergeVar, err = mergeutils.FetchOrdersList(
			ctx,
			cbID,
			doc.StartAt,
			doc.EndAt,
		)
		if err != nil {
			return nil, err
		}
	case document.MergeTypePackingSlip:
		testColli, err := cli.Colli.Query().
			First(ctx)
		if err != nil && !ent.IsNotFound(err) {
			return nil, err
		}

		if ent.IsNotFound(err) {
			// Just go on with an empty when system just init
			mergeVar = mergeutils.NewPackingSlipTest(ctx)
			break
		}

		mergeVar, err = mergeutils.PackingSlipMergeData(
			ctx,
			testColli.ID,
		)
		if err != nil {
			return nil, err
		}
	}

	opts, err := mergeutils.Doc2PDFOptions(ctx, doc, mergeVar)
	if err != nil {
		return nil, err
	}
	opts = append(opts,
		mergeutils.PDFMarginBottom(1),
		mergeutils.PDFTurboMode(true),
	)

	output, err := mergeutils.HTML2PDF(
		ctx,
		opts...,
	)
	if err != nil {
		return nil, err
	}

	b64 := utils.String2Base64(output)

	err = cli.Document.Update().
		Where(document.ID(doc.ID)).
		SetNillableLastBase64Pdf(&b64).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return &models.DocumentDownload{
		Base64pdf: b64,
	}, nil
}
