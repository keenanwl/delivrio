package gengql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	b64 "encoding/base64"
	"fmt"
	"time"

	"delivrio.io/go/ent"
	"delivrio.io/go/ent/printer"
	"delivrio.io/go/ent/user"
	"delivrio.io/go/ent/workstation"
	"delivrio.io/go/gengql/generated/models"
	"delivrio.io/go/schema/mixins"
	"delivrio.io/go/utils"
	"delivrio.io/go/viewer"
	"delivrio.io/shared-utils/pulid"
	"github.com/skip2/go-qrcode"
)

// CreateWorkstation is the resolver for the createWorkstation field.
func (r *mutationResolver) CreateWorkstation(ctx context.Context, input ent.CreateWorkstationInput) (*models.CreateWorkstationSuccess, error) {
	view := viewer.FromContext(ctx)
	tx := ent.FromContext(ctx)

	var userID *pulid.ID
	if *input.DeviceType == workstation.DeviceTypeApp {
		id := view.MyId()
		userID = &id
	}

	token := utils.RandomX(64)
	hashedToken := utils.HashPasswordX(token)
	ws, err := tx.Workstation.Create().
		SetInput(input).
		SetNillableUserID(userID).
		SetWorkstationID("").
		SetTenantID(view.TenantID()).
		SetRegistrationCode(hashedToken).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	regID := b64.StdEncoding.EncodeToString([]byte(fmt.Sprintf("%s:%s:%s", token, ws.ID, ws.TenantID)))

	png, err := qrcode.Encode(regID, qrcode.Medium, 256)
	if err != nil {
		return nil, err
	}

	base64PNG := b64.StdEncoding.EncodeToString(png)

	return &models.CreateWorkstationSuccess{
		ID: ws.ID,
		// Add TenantID so we know which account to lookup
		RegistrationToken:    regID,
		RegistrationTokenImg: base64PNG,
	}, nil
}

// UpdateWorkstation is the resolver for the updateWorkstation field.
func (r *mutationResolver) UpdateWorkstation(ctx context.Context, id pulid.ID, input ent.UpdateWorkstationInput) (*ent.Workstation, error) {
	tx := ent.FromContext(ctx)

	err := tx.Workstation.Update().
		SetInput(input).
		Where(workstation.ID(id)).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return tx.Workstation.Query().
		Where(workstation.ID(id)).
		Only(ctx)
}

// SaveSelectedWorkstation is the resolver for the saveSelectedWorkstation field.
func (r *mutationResolver) SaveSelectedWorkstation(ctx context.Context, id pulid.ID, pickupDay user.PickupDay) (bool, error) {
	tx := ent.FromContext(ctx)
	view := viewer.FromContext(ctx)

	update := tx.User.Update().
		ClearSelectedWorkstation().
		Where(user.ID(view.MyId()))

	if len(id) > 0 {
		err := tx.Workstation.Update().
			ClearSelectedUser().
			Where(workstation.ID(id)).
			Exec(ctx)
		if err != nil {
			return false, err
		}

		update = update.SetSelectedWorkstationID(id)
	}

	err := update.Exec(ctx)
	if err != nil {
		return false, err
	}

	err = tx.User.Update().
		Where(user.ID(view.MyId())).
		SetPickupDay(pickupDay).
		SetPickupDayLastChanged(time.Now()).
		Exec(ctx)
	if err != nil {
		return false, err
	}

	return true, err
}

// ArchiveWorkstation is the resolver for the archiveWorkstation field.
func (r *mutationResolver) ArchiveWorkstation(ctx context.Context, id pulid.ID) (bool, error) {
	tx := ent.TxFromContext(ctx)

	err := tx.Workstation.Update().
		Where(workstation.ID(id)).
		SetArchivedAt(time.Now()).
		SetStatus(workstation.StatusDisabled).
		Exec(ctx)
	if err != nil {
		return false, err
	}

	return true, nil
}

// Workstation is the resolver for the workstation field.
func (r *queryResolver) Workstation(ctx context.Context, id pulid.ID) (*ent.Workstation, error) {
	return r.client.Workstation.Query().
		Where(
			workstation.ID(id),
		).Only(ctx)
}

// FilteredWorkstations is the resolver for the filteredWorkstations field.
func (r *queryResolver) FilteredWorkstations(ctx context.Context, showArchived bool) ([]*ent.Workstation, error) {
	cli := ent.FromContext(ctx)

	if !showArchived {
		ctx = mixins.ExcludeArchived(ctx)
	}

	return cli.Workstation.Query().
		All(ctx)
}

// UpdatePrinters is the resolver for the updatePrinters field.
func (r *updateWorkstationInputResolver) UpdatePrinters(ctx context.Context, obj *ent.UpdateWorkstationInput, data []*models.UpdatePrinterWithIDInput) error {
	tx := ent.FromContext(ctx)

	for _, p := range data {
		err := tx.Printer.Update().
			SetInput(*p.UpdatePrinters).
			Where(printer.ID(p.ID)).
			Exec(ctx)
		if err != nil {
			return err
		}
	}
	return nil
}
