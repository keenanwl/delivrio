package gengql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"
	"runtime/debug"

	"delivrio.io/go/appconfig"
	"delivrio.io/go/ent"
	address2 "delivrio.io/go/ent/address"
	"delivrio.io/go/ent/contact"
	"delivrio.io/go/ent/printer"
	"delivrio.io/go/ent/printjob"
	"delivrio.io/go/ent/seatgroup"
	"delivrio.io/go/ent/signupoptions"
	"delivrio.io/go/ent/tenant"
	"delivrio.io/go/ent/user"
	"delivrio.io/go/ent/workstation"
	"delivrio.io/go/gengql/generated/models"
	"delivrio.io/go/utils"
	"delivrio.io/go/viewer"
	"delivrio.io/shared-utils/pulid"
	"entgo.io/ent/dialect/sql"
)

// UpdateUser is the resolver for the updateUser field.
func (r *mutationResolver) UpdateUser(ctx context.Context, input ent.UpdateUserInput, newTenantID *pulid.ID) (*ent.User, error) {
	view := viewer.FromContext(ctx)
	tx := ent.TxFromContext(ctx)
	err := tx.User.Update().
		SetInput(input).
		Where(user.ID(view.MyId())).
		Exec(ctx)
	if err != nil {
		return nil, fmt.Errorf("update user: %w", err)
	}

	u, err := tx.User.Query().
		WithTenant().
		Where(user.ID(view.MyId())).
		Only(ctx)
	if err != nil {
		return nil, fmt.Errorf("query user: %w", err)
	}

	if u.IsGlobalAdmin && newTenantID != nil {
		backgroundCtx := viewer.NewBackgroundContext(ctx)
		err = tx.User.Update().
			Where(user.ID(view.MyId())).
			SetTenantID(*newTenantID).
			Exec(backgroundCtx)
		if err != nil {
			return nil, fmt.Errorf("update user tenant: %w", err)
		}
		return tx.User.Query().
			Where(user.ID(view.MyId())).
			Only(backgroundCtx)
	}

	return tx.User.Query().
		Where(user.ID(view.MyId())).
		Only(ctx)
}

// UpdateCompanyInfo is the resolver for the updateCompanyInfo field.
func (r *mutationResolver) UpdateCompanyInfo(ctx context.Context, input ent.UpdateTenantInput, defaultLanguage pulid.ID, adminContact ent.CreateContactInput, billingContact ent.CreateContactInput, address ent.CreateAddressInput) (*ent.Tenant, error) {
	view := viewer.FromContext(ctx)
	tx := ent.FromContext(ctx)

	_, err := tx.Address.Delete().
		Where(address2.HasCompanyAddressWith(tenant.ID(view.TenantID()))).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	_, err = tx.Contact.Delete().
		Where(contact.Or(
			contact.HasBillingContactWith(tenant.ID(view.TenantID())),
			contact.HasAdminContactWith(tenant.ID(view.TenantID())),
		)).Exec(ctx)
	if err != nil {
		return nil, err
	}

	billing, err := tx.Contact.Create().
		SetInput(billingContact).
		SetTenantID(view.TenantID()).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	admin, err := tx.Contact.Create().
		SetInput(adminContact).
		SetTenantID(view.TenantID()).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	savedAddress, err := tx.Address.Create().
		// Copy this over from the general company input,
		// so we don't have to duplicate the UI fields
		SetCompany(*input.Name).
		SetInput(address).
		SetTenantID(view.TenantID()).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	err = tx.Tenant.Update().
		SetInput(input).
		ClearAdminContact().
		ClearBillingContact().
		ClearCompanyAddress().
		SetDefaultLanguageID(defaultLanguage).
		SetBillingContact(billing).
		SetAdminContact(admin).
		SetCompanyAddress(savedAddress).
		Where(tenant.ID(view.TenantID())).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return tx.Tenant.Query().
		Where(tenant.ID(view.TenantID())).
		Only(ctx)
}

// UpdatePlan is the resolver for the updatePlan field.
func (r *mutationResolver) UpdatePlan(ctx context.Context, planID pulid.ID) (*ent.Tenant, error) {
	view := viewer.FromContext(ctx)
	tx := ent.FromContext(ctx)
	err := tx.Tenant.Update().SetPlanID(planID).Where(tenant.ID(view.TenantID())).Exec(ctx)
	if err != nil {
		return nil, err
	}

	return tx.Tenant.Query().Where(tenant.ID(view.TenantID())).Only(ctx)
}

// CreateUserSeat is the resolver for the createUserSeat field.
func (r *mutationResolver) CreateUserSeat(ctx context.Context, input ent.CreateUserInput) (*ent.User, error) {
	view := viewer.FromContext(ctx)
	tx := ent.FromContext(ctx)
	return tx.User.Create().
		SetInput(input).
		SetPassword("unused").
		SetHash(utils.HashPasswordX(utils.RandomX(20))).
		SetTenantID(view.TenantID()).
		Save(ctx)
}

// UpdateUserSeat is the resolver for the updateUserSeat field.
func (r *mutationResolver) UpdateUserSeat(ctx context.Context, id pulid.ID, input ent.UpdateUserInput) (*ent.User, error) {
	tx := ent.FromContext(ctx)
	_, err := tx.User.Update().
		SetInput(input).
		Where(user.ID(id)).
		Save(ctx)

	if err != nil {
		return nil, err
	}

	return tx.User.Query().Where(user.ID(id)).Only(ctx)
}

// UpdateUserPassword is the resolver for the updateUserPassword field.
func (r *mutationResolver) UpdateUserPassword(ctx context.Context, id pulid.ID, input string) (*ent.User, error) {
	cli := ent.FromContext(ctx)
	view := viewer.FromContext(ctx)

	u, err := cli.User.Query().
		Where(user.ID(view.MyId())).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	if !u.IsGlobalAdmin && !u.IsAccountOwner {
		return nil, fmt.Errorf("you must be a global admin or account owner to reset passwords")
	}

	err = cli.User.Update().
		Where(user.ID(id)).
		SetPassword(input).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return cli.User.Query().
		Where(user.ID(id)).
		Only(ctx)
}

// CreateSeatGroup is the resolver for the createSeatGroup field.
func (r *mutationResolver) CreateSeatGroup(ctx context.Context, input ent.CreateSeatGroupInput, accessRights []*ent.CreateSeatGroupAccessRightInput) (*ent.SeatGroup, error) {
	view := viewer.FromContext(ctx)
	tx := ent.FromContext(ctx)

	sg, err := tx.SeatGroup.Create().
		SetInput(input).
		SetTenantID(view.TenantID()).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	for _, ar := range accessRights {
		_, err = tx.SeatGroupAccessRight.Create().
			SetInput(*ar).
			SetSeatGroup(sg).
			SetTenantID(view.TenantID()).Save(ctx)
		if err != nil {
			return nil, err
		}
	}

	return sg.Unwrap(), nil
}

// ReplaceSeatGroup is the resolver for the replaceSeatGroup field.
func (r *mutationResolver) ReplaceSeatGroup(ctx context.Context, id pulid.ID, input ent.UpdateSeatGroupInput, accessRights []*ent.CreateSeatGroupAccessRightInput) (*ent.SeatGroup, error) {
	view := viewer.FromContext(ctx)
	tx := ent.FromContext(ctx)

	_, err := tx.SeatGroup.Update().
		SetInput(input).
		ClearAssignedAccessRight().
		SetTenantID(view.TenantID()).
		Where(seatgroup.ID(id)).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	for _, ar := range accessRights {
		_, err = tx.SeatGroupAccessRight.Create().
			SetInput(*ar).
			SetSeatGroupID(id).
			SetTenantID(view.TenantID()).
			Save(ctx)
		if err != nil {
			return nil, err
		}
	}

	return tx.SeatGroup.Query().
		Where(seatgroup.ID(id)).
		Only(ctx)
}

// ReplaceSignupOptions is the resolver for the replaceSignupOptions field.
func (r *mutationResolver) ReplaceSignupOptions(ctx context.Context, userID pulid.ID, input ent.CreateSignupOptionsInput) (*ent.SignupOptions, error) {
	tx := ent.FromContext(ctx)

	_, err := tx.SignupOptions.Delete().Where(signupoptions.HasUsersWith(user.ID(userID))).Exec(ctx)
	if err != nil {
		return nil, err
	}

	signupOptions, err := tx.SignupOptions.Create().SetInput(input).SetUsersID(userID).Save(ctx)
	if err != nil {
		return nil, err
	}

	singupOptionsID := signupOptions.ID

	return tx.SignupOptions.Get(ctx, singupOptionsID)
}

// ReplaceInterestedCarriersPlatforms is the resolver for the replaceInterestedCarriersPlatforms field.
func (r *mutationResolver) ReplaceInterestedCarriersPlatforms(ctx context.Context, userID pulid.ID, inputCarriers []pulid.ID, inputPlatforms []pulid.ID) (*ent.User, error) {
	tx := ent.FromContext(ctx)
	view := viewer.FromContext(ctx)
	_, err := tx.Tenant.Update().
		ClearConnectOptionPlatforms().
		ClearConnectOptionCarriers().
		AddConnectOptionCarrierIDs(inputCarriers...).
		AddConnectOptionPlatformIDs(inputPlatforms...).
		Where(tenant.ID(view.TenantID())).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	return tx.User.Query().Where(user.ID(userID)).Only(ctx)
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id *pulid.ID) (*ent.User, error) {
	view := viewer.FromContext(ctx)
	searchID := view.MyId()
	if id != nil {
		searchID = *id
	}
	return r.client.User.Query().
		Where(
			user.ID(searchID),
		).Only(ctx)
}

// SeatGroup is the resolver for the seatGroup field.
func (r *queryResolver) SeatGroup(ctx context.Context, id pulid.ID) (*ent.SeatGroup, error) {
	return r.client.SeatGroup.Query().
		Where(
			seatgroup.ID(id),
		).Only(ctx)
}

// Tenant is the resolver for the tenant field.
func (r *queryResolver) Tenant(ctx context.Context, id *pulid.ID) (*ent.Tenant, error) {
	return r.client.Tenant.Query().
		Where(
			tenant.ID(*id),
		).Only(ctx)
}

// SelectedWorkstation is the resolver for the selectedWorkstation field.
func (r *queryResolver) SelectedWorkstation(ctx context.Context) (*models.SelectedWorkstation, error) {
	view := viewer.FromContext(ctx)
	ws, err := r.client.User.Query().
		Where(user.ID(view.MyId())).
		QuerySelectedWorkstation().
		Only(ctx)
	if err != nil && !ent.IsNotFound(err) {
		return nil, err
	} else if ent.IsNotFound(err) {
		return &models.SelectedWorkstation{
			Workstation:   nil,
			Jobs:          nil,
			LimitExceeded: false,
		}, nil
	}

	printJobs, err := r.client.PrintJob.Query().
		Where(printjob.And(
			printjob.HasPrinterWith(printer.HasWorkstationWith(workstation.ID(ws.ID))),
			printjob.StatusIn(printjob.StatusPending, printjob.StatusAtPrinter, printjob.StatusCanceled, printjob.StatusSuccess),
		)).
		Order(printjob.ByID(sql.OrderDesc())).
		Limit(15).
		All(ctx)
	if err != nil {
		return nil, err
	}

	return &models.SelectedWorkstation{
		Workstation:   ws,
		Jobs:          printJobs,
		LimitExceeded: len(printJobs) >= 10,
	}, nil
}

// BuildInfo is the resolver for the buildInfo field.
func (r *queryResolver) BuildInfo(ctx context.Context) (*models.BuildInfo, error) {
	bi, ok := debug.ReadBuildInfo()
	if !ok {
		return nil, fmt.Errorf("build info: fetching build info failed")
	}

	output := &models.BuildInfo{
		LimitedSystem: conf.LimitedSystem,
		Time:          appconfig.BuildTime,
	}

	for _, kv := range bi.Settings {
		if kv.Key == "vcs.revision" {
			output.Hash = fmt.Sprintf("%v - %v", appconfig.AppVersion, kv.Value)
		}
	}

	return output, nil
}

// AvailableTenants is the resolver for the availableTenants field.
func (r *queryResolver) AvailableTenants(ctx context.Context) ([]*ent.Tenant, error) {
	view := viewer.FromContext(ctx)
	cli := ent.FromContext(ctx)
	u, err := cli.User.Query().
		WithTenant().
		Where(user.ID(view.MyId())).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	if !u.IsGlobalAdmin {
		return []*ent.Tenant{u.Edges.Tenant}, nil
	}

	backgroundCtx := viewer.NewBackgroundContext(ctx)
	return cli.Tenant.Query().
		All(backgroundCtx)
}
