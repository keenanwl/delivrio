package gengql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"
	"time"

	"delivrio.io/go/ent"
	"delivrio.io/go/ent/product"
	"delivrio.io/go/ent/returncolli"
	"delivrio.io/go/gengql/generated/models"
)

// DashboardTiles is the resolver for the dashboardTiles field.
func (r *queryResolver) DashboardTiles(ctx context.Context) ([]*models.DashboardTile, error) {
	output := make([]*models.DashboardTile, 0)

	portalCount, err := r.client.ReturnPortal.Query().
		Count(ctx)
	if portalCount == 0 {
		return output, nil
	}

	pendingCount, err := r.client.ReturnColli.Query().
		Where(
			returncolli.StatusIn(
				returncolli.StatusPending,
			),
		).
		Count(ctx)
	if err != nil {
		return nil, err
	}

	output = append(output, &models.DashboardTile{
		ID:    "",
		Title: fmt.Sprintf("Returns: pending"),
		Value: fmt.Sprintf("%v", pendingCount),
	})

	now := time.Now()
	todayMidnight := time.Date(now.Year(), now.Month(), now.Day()+1, 0, 0, 0, 0, now.Location())
	tomorrowMidnight := time.Date(now.Year(), now.Month(), now.Day()+2, 0, 0, 0, 0, now.Location())

	inboundToday, err := r.client.ReturnColli.Query().
		Where(
			returncolli.And(
				returncolli.StatusIn(
					returncolli.StatusInbound,
				),
				returncolli.ExpectedAtLTE(todayMidnight),
			),
		).
		Count(ctx)
	if err != nil {
		return nil, err
	}

	output = append(output, &models.DashboardTile{
		ID:    "",
		Title: fmt.Sprintf("Returns: arriving today"),
		Value: fmt.Sprintf("%v", inboundToday),
	})

	inboundTomorrow, err := r.client.ReturnColli.Query().
		Where(
			returncolli.And(
				returncolli.StatusIn(
					returncolli.StatusInbound,
				),
				returncolli.ExpectedAtLTE(tomorrowMidnight),
			),
		).
		Count(ctx)
	if err != nil {
		return nil, err
	}

	output = append(output, &models.DashboardTile{
		ID:    "",
		Title: fmt.Sprintf("Returns: arriving tomorrow"),
		Value: fmt.Sprintf("%v", inboundTomorrow),
	})

	inboundReceived, err := r.client.ReturnColli.Query().
		Where(
			returncolli.And(
				returncolli.StatusIn(
					returncolli.StatusReceived,
				),
			),
		).
		Count(ctx)
	if err != nil {
		return nil, err
	}

	output = append(output, &models.DashboardTile{
		ID:    "",
		Title: fmt.Sprintf("Returns: at warehouse"),
		Value: fmt.Sprintf("%v", inboundReceived),
	})

	return output, nil
}

// TrailingProductUpdates is the resolver for the trailingProductUpdates field.
func (r *queryResolver) TrailingProductUpdates(ctx context.Context) ([]int, error) {
	cli := ent.FromContext(ctx)

	// Define the start of the range (7 days ago)
	rangeStart := time.Now().Add(-time.Hour * 24 * 7)

	// Query products updated in the last 7 days
	products, err := cli.Product.Query().
		Where(product.UpdatedAtGTE(rangeStart)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	// Initialize an array to hold counts for the last 7 days
	dayCounts := make([]int, 7)

	// Iterate over the products and group them by the day they were updated
	for _, p := range products {
		daysAgo := int(time.Since(p.UpdatedAt).Hours() / 24)
		if daysAgo < 7 {
			dayCounts[6-daysAgo]++
		}
	}

	return dayCounts, nil
}

// RateRequests is the resolver for the rateRequests field.
func (r *queryResolver) RateRequests(ctx context.Context) (*models.RateRequests, error) {
	cli := ent.FromContext(ctx)

	lookups, err := cli.ConnectionLookup.Query().
		All(ctx)
	if err != nil {
		return nil, err
	}

	output := make([]*models.RateRequest, 0)
	outputErrors := make([]*models.RateRequest, 0)

	for _, lookup := range lookups {

		if len(lookup.Error) == 0 {
			output = append(output, &models.RateRequest{
				Date:        lookup.CreatedAt.Format(time.RFC3339),
				OptionCount: lookup.OptionsOutputCount,
				Req:         &lookup.Payload,
			})
		} else {
			outputErrors = append(output, &models.RateRequest{
				Date:        lookup.CreatedAt.Format(time.RFC3339),
				OptionCount: lookup.OptionsOutputCount,
				Error:       &lookup.Error,
				Req:         &lookup.Payload,
			})
		}
	}

	return &models.RateRequests{
		Requests:      output,
		RequestsError: outputErrors,
	}, nil
}
