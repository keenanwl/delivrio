package gengql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"errors"
	"fmt"

	"delivrio.io/go/carrierapis/bringapis"
	"delivrio.io/go/carrierapis/daoapis"
	"delivrio.io/go/deliveryoptions"
	"delivrio.io/go/deliverypoints"
	"delivrio.io/go/deliverypoints/glsdeliverypoints"
	"delivrio.io/go/deliverypoints/postnorddeliverypoints"
	"delivrio.io/go/ent"
	"delivrio.io/go/ent/address"
	"delivrio.io/go/ent/carrieradditionalservicegls"
	"delivrio.io/go/ent/carrieradditionalservicepostnord"
	"delivrio.io/go/ent/carrierbrand"
	"delivrio.io/go/ent/changehistory"
	"delivrio.io/go/ent/colli"
	"delivrio.io/go/ent/connection"
	country2 "delivrio.io/go/ent/country"
	"delivrio.io/go/ent/deliveryoption"
	"delivrio.io/go/ent/documentfile"
	"delivrio.io/go/ent/location"
	"delivrio.io/go/ent/order"
	"delivrio.io/go/ent/orderhistory"
	"delivrio.io/go/ent/orderline"
	"delivrio.io/go/ent/returncolli"
	"delivrio.io/go/ent/returncollihistory"
	"delivrio.io/go/gengql/generated/models"
	"delivrio.io/go/mergeutils"
	"delivrio.io/go/schema/hooks"
	"delivrio.io/go/schema/hooks/history"
	"delivrio.io/go/utils"
	"delivrio.io/go/viewer"
	"delivrio.io/shared-utils/pulid"
	"github.com/99designs/gqlgen/graphql"
)

// DuplicateColli is the resolver for the duplicateColli field.
func (r *mutationResolver) DuplicateColli(ctx context.Context, fromColliID pulid.ID) (*ent.Order, error) {
	tx := ent.TxFromContext(ctx)

	_, err := utils.DuplicateColli(
		history.NewConfig(ctx).
			SetDescription("Add colli").
			SetOrigin(changehistory.OriginWebClient).
			Ctx(),
		fromColliID,
	)
	if err != nil {
		return nil, err
	}

	return tx.Order.Query().
		Where(order.HasColliWith(colli.ID(fromColliID))).
		Only(ctx)
}

// DeleteColli is the resolver for the deleteColli field.
func (r *mutationResolver) DeleteColli(ctx context.Context, colliID pulid.ID) (*ent.Order, error) {
	tx := ent.FromContext(ctx)

	// Hook to prevent delete with order lines
	c, err := tx.Colli.Query().
		WithOrder().
		Where(colli.ID(colliID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}
	orderID := c.Edges.Order.ID

	err = tx.Colli.DeleteOneID(colliID).
		Exec(history.NewConfig(ctx).
			SetDescription("Delete colli").
			SetOrigin(changehistory.OriginWebClient).
			Ctx())
	if err != nil {
		var fieldErrors *hooks.ValidationError
		if errors.As(err, &fieldErrors) {
			ctxColli := graphql.WithPathContext(ctx, graphql.NewPathWithField("colli"))
			for _, e := range fieldErrors.InvalidFields(ctxColli) {
				graphql.AddError(ctxColli, e)
			}
		} else {
			return nil, err
		}
	}

	_, err = tx.Address.Delete().
		Where(address.Or(
			address.HasRecipientColliWith(colli.ID(colliID)),
			address.HasSenderColliWith(colli.ID(colliID)),
		)).Exec(ctx)
	if err != nil {
		return nil, err
	}

	return tx.Order.Query().Where(order.ID(orderID)).Only(ctx)
}

// MoveOrderLine is the resolver for the moveOrderLine field.
func (r *mutationResolver) MoveOrderLine(ctx context.Context, orderLineID pulid.ID, colliID pulid.ID) ([]*ent.Colli, error) {
	tx := ent.FromContext(ctx)

	err := tx.OrderLine.UpdateOneID(orderLineID).SetColliID(colliID).Exec(ctx)
	if err != nil {
		return nil, err
	}

	// Roundabout way of getting all order collis
	return tx.Colli.Query().Where(colli.HasOrderWith(order.HasColliWith(colli.ID(colliID)))).All(ctx)
}

// CreateColli is the resolver for the createColli field.
func (r *mutationResolver) CreateColli(ctx context.Context, orderID pulid.ID, input ent.CreateColliInput, deliveryOptionID *pulid.ID, deliveryPointID *pulid.ID, ccLocationID *pulid.ID, packagingID *pulid.ID, recipientAddress ent.CreateAddressInput, senderAddress ent.CreateAddressInput, products []*utils.ProductVariantQuantity) (*ent.Order, error) {
	tx := ent.TxFromContext(ctx)

	_, err := utils.CreateColli(
		ctx,
		orderID,
		input,
		deliveryOptionID,
		deliveryPointID,
		ccLocationID,
		packagingID,
		tx.Address.Create().SetInput(recipientAddress),
		tx.Address.Create().SetInput(senderAddress),
		products,
	)
	if err != nil {
		return nil, err
	}

	return tx.Order.Query().
		Where(order.ID(orderID)).
		Only(ctx)
}

// UpdateColli is the resolver for the updateColli field.
func (r *mutationResolver) UpdateColli(ctx context.Context, id pulid.ID, input ent.UpdateColliInput, deliveryOptionID *pulid.ID, deliveryPointID *pulid.ID, ccLocationID *pulid.ID, packagingID *pulid.ID, recipientAddressID pulid.ID, recipientAddress ent.UpdateAddressInput, senderAddressID pulid.ID, senderAddress ent.UpdateAddressInput, updateExistingRecipient *bool, products []*utils.ProductVariantQuantity, removeProducts []pulid.ID) (*ent.Colli, error) {
	v := viewer.FromContext(ctx)
	tx := ent.FromContext(ctx)

	_, err := tx.Address.Update().
		SetInput(recipientAddress).
		Where(address.ID(recipientAddressID)).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	_, err = tx.Address.Update().
		SetInput(senderAddress).
		Where(address.ID(senderAddressID)).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	// Account for getting empty string from frontend
	if packagingID != nil && *packagingID == "" {
		packagingID = nil
	}

	col, err := tx.Colli.Query().
		Where(colli.ID(id)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	err = col.Update().
		SetInput(input).
		SetTenantID(v.TenantID()).
		ClearPackaging().
		SetNillableParcelShopID(deliveryPointID).
		SetNillableDeliveryOptionID(deliveryOptionID).
		SetNillableClickCollectLocationID(ccLocationID).
		SetNillablePackagingID(packagingID).
		RemoveOrderLines().
		Exec(
			history.NewConfig(ctx).
				SetDescription("Update colli details").
				SetOrigin(changehistory.OriginWebClient).
				Ctx(),
		)
	if err != nil {
		return nil, err
	}

	lines, err := tx.OrderLine.Query().
		Where(orderline.HasColliWith(colli.ID(id))).
		All(ctx)
	if err != nil {
		return nil, err
	}

	linesLookup := make(map[pulid.ID]*ent.OrderLine)
	for _, l := range lines {
		linesLookup[l.ID] = l
	}

	// Change this when we allow currency selection on front end
	shopCurrency, err := col.QueryOrder().
		QueryConnection().
		QueryCurrency().
		Only(ctx)
	if err != nil {
		return nil, err
	}

	for _, line := range products {

		val := linesLookup[line.OrderLineID]
		if val != nil {
			err := tx.OrderLine.UpdateOneID(val.ID).
				SetUnits(line.Units).
				SetUnitPrice(line.Price).
				SetDiscountAllocationAmount(line.Discount).
				SetCurrency(shopCurrency).
				Exec(ctx)
			if err != nil {
				return nil, err
			}
		} else {
			_, err := tx.OrderLine.Create().
				SetTenantID(v.TenantID()).
				SetColliID(id).
				SetProductVariantID(line.VariantID).
				SetUnits(line.Units).
				SetUnitPrice(line.Price).
				SetDiscountAllocationAmount(line.Discount).
				SetCurrency(shopCurrency).
				Save(ctx)
			if err != nil {
				return nil, err
			}
		}
	}

	_, err = tx.OrderLine.Delete().
		Where(orderline.IDIn(removeProducts...)).
		Exec(ctx)
	if err != nil {
		var fieldErrors *hooks.ValidationError
		if errors.As(err, &fieldErrors) {
			ctxProducts := graphql.WithPathContext(ctx, graphql.NewPathWithField("products"))
			for _, e := range fieldErrors.InvalidFields(ctxProducts) {
				graphql.AddError(ctxProducts, e)
			}
		} else {
			return nil, err
		}
	}

	return tx.Colli.Query().
		Where(colli.ID(id)).
		Only(ctx)
}

// CreateEmptyOrder is the resolver for the createEmptyOrder field.
func (r *mutationResolver) CreateEmptyOrder(ctx context.Context, input ent.CreateOrderInput) (*ent.Order, error) {
	tx := ent.FromContext(ctx)
	v := viewer.FromContext(ctx)

	// Default to company country in future
	country, err := tx.Country.Query().
		Where(country2.Alpha2EqualFold("US")).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	recipientAddress, err := tx.Address.Create().
		SetInput(ent.CreateAddressInput{
			FirstName:         "",
			LastName:          "",
			Email:             "",
			PhoneNumber:       "",
			Company:           nil,
			AddressOne:        "",
			AddressTwo:        "",
			City:              "",
			State:             nil,
			Zip:               "",
			RecipientColliIDs: nil,
			CompanyAddresIDs:  nil,
			LocationIDs:       nil,
			SenderColliIDs:    nil,
			CountryID:         "",
		}).
		SetCountry(country).
		SetTenantID(v.TenantID()).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	senderTemplate, err := tx.Connection.Query().
		Where(connection.ID(input.ConnectionID)).
		QuerySenderLocation().
		WithAddress().
		Only(ctx)
	if err != nil {
		return nil, err
	}

	senderCountry, err := senderTemplate.Edges.Address.Country(ctx)
	if err != nil {
		return nil, err
	}

	senderAddress, err := tx.Address.Create().
		SetInput(ent.CreateAddressInput{
			FirstName:         senderTemplate.Edges.Address.FirstName,
			LastName:          senderTemplate.Edges.Address.LastName,
			Email:             senderTemplate.Edges.Address.Email,
			PhoneNumber:       senderTemplate.Edges.Address.PhoneNumber,
			VatNumber:         &senderTemplate.Edges.Address.VatNumber,
			Company:           &senderTemplate.Edges.Address.Company,
			AddressOne:        senderTemplate.Edges.Address.AddressOne,
			AddressTwo:        senderTemplate.Edges.Address.AddressTwo,
			City:              senderTemplate.Edges.Address.City,
			State:             &senderTemplate.Edges.Address.State,
			Zip:               senderTemplate.Edges.Address.Zip,
			RecipientColliIDs: nil,
			CompanyAddresIDs:  nil,
			LocationIDs:       nil,
			SenderColliIDs:    nil,
			CountryID:         senderCountry.ID,
		}).
		SetTenantID(v.TenantID()).
		Save(ctx)
	if err != nil {
		return nil, err
	}

	o, err := tx.Order.Create().
		SetInput(input).
		SetStatus(order.StatusPending).
		SetTenantID(v.TenantID()).
		Save(history.NewConfig(ctx).
			SetDescription("Add order").
			SetOrigin(changehistory.OriginWebClient).
			Ctx())
	if err != nil {
		return nil, err
	}

	_, err = tx.Colli.Create().
		SetOrderID(o.ID).
		SetStatus(colli.StatusPending).
		SetRecipient(recipientAddress).
		SetSender(senderAddress).
		SetTenantID(v.TenantID()).
		Save(history.NewConfig(ctx).
			SetDescription("Add colli").
			SetOrigin(changehistory.OriginWebClient).
			Ctx())
	if err != nil {
		return nil, err
	}

	return o, nil
}

// UpdateOrder is the resolver for the updateOrder field.
func (r *mutationResolver) UpdateOrder(ctx context.Context, id pulid.ID, input ent.UpdateOrderInput) (*ent.Order, error) {
	tx := ent.FromContext(ctx)

	_, err := tx.Order.Update().
		SetInput(input).
		Where(order.ID(id)).
		Save(history.NewConfig(ctx).
			SetDescription("Update order details").
			SetOrigin(changehistory.OriginWebClient).
			Ctx())
	if err != nil {
		return nil, err
	}

	return tx.Order.Query().Where(order.ID(id)).Only(ctx)
}

// BulkUpdatePackaging is the resolver for the bulkUpdatePackaging field.
func (r *mutationResolver) BulkUpdatePackaging(ctx context.Context, orderIDs []pulid.ID, packagingID *pulid.ID) (*models.BulkUpdateMessage, error) {
	tx := ent.TxFromContext(ctx)

	updateCount, err := tx.Colli.Update().
		ClearPackaging().
		SetNillablePackagingID(packagingID).
		Where(colli.And(
			colli.HasOrderWith(order.IDIn(orderIDs...)),
			colli.StatusNotIn(colli.StatusDispatched, colli.StatusCancelled),
		)).Save(history.NewConfig(ctx).
		SetDescription("Bulk update packaging").
		SetOrigin(changehistory.OriginWebClient).
		Ctx())
	if err != nil {
		return &models.BulkUpdateMessage{
			Success: false,
			Msg:     fmt.Sprintf("Failed to update the packaging"),
		}, err
	}

	return &models.BulkUpdateMessage{
		Success: true,
		Msg:     fmt.Sprintf("Successfully updated packaging for %v collis", updateCount),
	}, nil
}

// Order is the resolver for the order field.
func (r *queryResolver) Order(ctx context.Context, id *pulid.ID) (*ent.Order, error) {
	return r.client.Order.Query().
		Where(
			order.ID(*id),
		).Only(ctx)
}

// OrderShipments is the resolver for the orderShipments field.
func (r *queryResolver) OrderShipments(ctx context.Context, orderID pulid.ID) (*models.OrderShipmentStatus, error) {
	parcels, err := r.client.Order.Query().
		Where(order.ID(orderID)).
		QueryColli().
		All(ctx)
	if err != nil {
		return nil, err
	}

	allStatuses := make([]*models.ParcelStatuses, 0)

	for _, p := range parcels {
		shipParcel, err := p.QueryShipmentParcel().
			WithShipment().
			Only(ctx)
		if ent.IsNotFound(err) {
			allStatuses = append(allStatuses, &models.ParcelStatuses{
				ColliID:    p.ID,
				ShipmentID: nil,
			})
			continue
		} else if err != nil {
			return nil, err
		}
		allStatuses = append(allStatuses, &models.ParcelStatuses{
			ColliID:      p.ID,
			ShipmentID:   &shipParcel.Edges.Shipment.ID,
			CcSignatures: shipParcel.CcPickupSignatureUrls,
		})
	}

	return &models.OrderShipmentStatus{
		ShipmentStatuses: allStatuses,
		MayShipRemaining: true,
	}, nil
}

// Colli is the resolver for the colli field.
func (r *queryResolver) Colli(ctx context.Context, id *pulid.ID) (*ent.Colli, error) {
	return r.client.Colli.Query().
		Where(colli.ID(*id)).
		Only(ctx)
}

// OrderTimeline is the resolver for the orderTimeline field.
func (r *queryResolver) OrderTimeline(ctx context.Context, orderID pulid.ID) ([]*ent.ChangeHistory, error) {
	return r.client.ChangeHistory.Query().
		Where(
			changehistory.Or(
				changehistory.HasOrderHistoryWith(
					orderhistory.HasOrderWith(
						order.ID(orderID),
					)),
				changehistory.HasReturnColliHistoryWith(
					returncollihistory.HasReturnColliWith(
						returncolli.HasOrderWith(
							order.ID(orderID),
						),
					)),
			),
		).
		Order(ent.Desc(changehistory.FieldCreatedAt)).
		Limit(3).
		All(ctx)
}

// DeliveryOptionsList is the resolver for the deliveryOptionsList field.
func (r *queryResolver) DeliveryOptionsList(ctx context.Context, orderInfo deliveryoptions.DeliveryOptionSeedInput) ([]*deliveryoptions.DeliveryOptionBrandName, error) {
	return deliveryoptions.ByOrder(ctx, orderInfo, false)
}

// DeliveryPoint is the resolver for the deliveryPoint field.
func (r *queryResolver) DeliveryPoint(ctx context.Context, colliID pulid.ID) (*models.DeliveryPoint, error) {
	do, err := r.client.Colli.Query().
		Where(colli.ID(colliID)).
		QueryDeliveryOption().
		Only(ctx)
	if err != nil {
		return nil, err
	}
	cb, err := do.QueryCarrier().
		QueryCarrierBrand().
		Only(ctx)
	if err != nil {
		return nil, err
	}

	switch cb.InternalID {
	case carrierbrand.InternalIDPostNord:
		servicePointServiceCount, err := do.QueryCarrierService().
			QueryCarrierServicePostNord().
			QueryCarrierAddServPostNord().
			// Don't enforce mandatory here since it could be optionally added
			Where(carrieradditionalservicepostnord.And(
				carrieradditionalservicepostnord.InternalIDEQ("optional_service_point"),
			)).
			Count(ctx)
		if err != nil {
			return nil, err
		}

		servicePointRequired := servicePointServiceCount > 0
		if !servicePointRequired {
			return nil, nil
		}

		ps, err := r.client.Colli.Query().
			Where(colli.ID(colliID)).
			QueryParcelShop().
			Only(ctx)
		if err != nil {
			return nil, err
		}
		visiting, err := ps.
			QueryAddress().
			Only(ctx)
		if err != nil && !ent.IsNotFound(err) {
			return nil, err
		}

		return &models.DeliveryPoint{
			ID:      ps.ID,
			Name:    ps.Name,
			Address: visiting,
		}, nil
	case carrierbrand.InternalIDGLS:
		servicePointServiceCount, err := do.QueryCarrierService().
			QueryCarrierServiceGLS().
			QueryCarrierAdditionalServiceGLS().
			// Don't enforce mandatory here since it could be optionally added
			Where(carrieradditionalservicegls.And(
				carrieradditionalservicegls.InternalIDEQ("service_point"),
			)).
			Count(ctx)
		if err != nil {
			return nil, err
		}

		servicePointRequired := servicePointServiceCount > 0
		if !servicePointRequired {
			return nil, nil
		}

		ps, err := r.client.Colli.Query().
			Where(colli.ID(colliID)).
			QueryParcelShop().
			Only(ctx)
		if err != nil {
			return nil, err
		}
		visiting, err := ps.
			QueryAddress().
			Only(ctx)
		if err != nil && !ent.IsNotFound(err) {
			return nil, err
		}

		return &models.DeliveryPoint{
			ID:      ps.ID,
			Name:    ps.Name,
			Address: visiting,
		}, nil
	case carrierbrand.InternalIDBring:
		carrierService, err := do.CarrierService(ctx)
		if err != nil {
			return nil, err
		}

		if !carrierService.DeliveryPointRequired {
			return nil, nil
		}

		ps, err := r.client.Colli.Query().
			Where(colli.ID(colliID)).
			QueryParcelShop().
			Only(ctx)
		if err != nil {
			return nil, err
		}
		visiting, err := ps.
			QueryAddress().
			Only(ctx)
		if err != nil && !ent.IsNotFound(err) {
			return nil, err
		}

		return &models.DeliveryPoint{
			ID:      ps.ID,
			Name:    ps.Name,
			Address: visiting,
		}, nil
	}

	return nil, fmt.Errorf("unsupported carrier: %v", cb.InternalID)
}

// AvailableDeliveryPoints is the resolver for the availableDeliveryPoints field.
func (r *queryResolver) AvailableDeliveryPoints(ctx context.Context, deliveryOptionID *pulid.ID, address *ent.CreateAddressInput) ([]*models.DeliveryPoint, error) {
	ctx, span := tracer.Start(ctx, "AvailableDeliveryPoints")
	defer span.End()

	if deliveryOptionID == nil {
		return nil, fmt.Errorf("delivery option must be selected to search for delivery points")
	}

	if address == nil || len(address.Zip) <= 0 {
		return nil, fmt.Errorf("postal code and country must be available to search for delivery points")
	}

	coun, err := r.client.Country.Query().
		Where(country2.ID(address.CountryID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	do, err := r.client.DeliveryOption.Query().
		Where(deliveryoption.ID(*deliveryOptionID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	cb, err := do.
		QueryCarrier().
		QueryCarrierBrand().
		Only(ctx)
	if err != nil {
		return nil, err
	}

	nearestToAddress := deliverypoints.DropPointLookupAddress{
		Address1: address.AddressOne,
		Zip:      address.Zip,
		Country:  coun,
	}

	points := make([]*ent.ParcelShop, 0)
	switch cb.InternalID {
	case carrierbrand.InternalIDBring:
		points, err = bringapis.DeliveryPoints(ctx, nearestToAddress, do.ClickOptionDisplayCount)
		if err != nil {
			span.RecordError(err)
			return nil, err
		}
		break
	case carrierbrand.InternalIDDAO:
		points, err = daoapis.DeliveryPoints(daoapis.WithDeliveryOptionID(ctx, do.ID), nearestToAddress, do.ClickOptionDisplayCount)
		if err != nil {
			span.RecordError(err)
			return nil, err
		}
		break
	case carrierbrand.InternalIDPostNord:
		points, err = postnorddeliverypoints.DeliveryPoints(ctx, nearestToAddress, do.ClickOptionDisplayCount)
		if err != nil {
			span.RecordError(err)
			return nil, err
		}
		break

	case carrierbrand.InternalIDGLS:
		points, err = glsdeliverypoints.DeliveryPoints(ctx, nearestToAddress, do.ClickOptionDisplayCount)
		if err != nil {
			span.RecordError(err)
			return nil, err
		}
		break
	default:
		return nil, fmt.Errorf("unsupported carrier: %v", cb.InternalID)
	}

	output := make([]*models.DeliveryPoint, 0)
	for _, p := range points {
		adr, err := p.Address(ctx)
		if err != nil {
			return nil, err
		}
		output = append(output, &models.DeliveryPoint{
			ID:      p.ID,
			Name:    p.Name,
			Address: adr,
		})
	}

	return output, nil
}

// ClickCollectLocation is the resolver for the clickCollectLocation field.
func (r *queryResolver) ClickCollectLocation(ctx context.Context, colliID pulid.ID) (*ent.Location, error) {
	cli := ent.FromContext(ctx)
	return cli.Location.Query().
		Where(location.HasColliWith(colli.ID(colliID))).
		Only(ctx)
}

// PackingSlips is the resolver for the packingSlips field.
func (r *queryResolver) PackingSlips(ctx context.Context, colliIDs []pulid.ID) (*models.PackingSlipsOutput, error) {
	allCollis, err := r.client.Colli.Query().
		Where(colli.IDIn(colliIDs...)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	outputPDFs := make([]string, 0)
	for _, c := range allCollis {

		pdfB64, err := mergeutils.QueryOrFetchPackingSlip(ctx, c)
		if err != nil {
			return nil, err
		}

		outputPDFs = append(outputPDFs, pdfB64...)
	}

	allPDFs, err := utils.JoinPDFs(outputPDFs...)
	if err != nil {
		return nil, err
	}

	return &models.PackingSlipsOutput{
		PackingSlips:    outputPDFs,
		AllPackingSlips: allPDFs,
	}, nil
}

// PackingSlipsByOrder is the resolver for the packingSlipsByOrder field.
func (r *queryResolver) PackingSlipsByOrder(ctx context.Context, orderIDs []pulid.ID) (*models.PackingSlipsOutput, error) {
	allCollis, err := r.client.Colli.Query().
		Where(colli.HasOrderWith(order.IDIn(orderIDs...))).
		All(ctx)
	if err != nil {
		return nil, err
	}

	outputPDFs := make([]string, 0)
	for _, c := range allCollis {

		pdfB64, err := mergeutils.QueryOrFetchPackingSlip(ctx, c)
		if err != nil {
			return nil, err
		}

		outputPDFs = append(outputPDFs, pdfB64...)
	}

	allPDFs, err := utils.JoinPDFs(outputPDFs...)
	if err != nil {
		return nil, err
	}

	return &models.PackingSlipsOutput{
		PackingSlips:    outputPDFs,
		AllPackingSlips: allPDFs,
	}, nil
}

// PackingSlipsClearCache is the resolver for the packingSlipsClearCache field.
func (r *queryResolver) PackingSlipsClearCache(ctx context.Context, orderIDs []pulid.ID) (bool, error) {
	slipsToDelete, err := r.client.Order.Query().
		Where(order.IDIn(orderIDs...)).
		QueryColli().
		Where(colli.HasDocumentFileWith(documentfile.DocTypeIn(documentfile.DocTypePackingSlip))).
		QueryDocumentFile().
		All(ctx)
	if err != nil {
		return false, err
	}

	for _, s := range slipsToDelete {
		err := utils.DeleteDocument(ctx, s)
		if err != nil {
			return false, err
		}
	}

	return true, nil
}
