package gengql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"

	"delivrio.io/go/carrierapis/common"
	"delivrio.io/go/carrierapis/glsapis"
	"delivrio.io/go/carrierapis/postnordapis"
	"delivrio.io/go/deliveryoptions"
	"delivrio.io/go/ent"
	"delivrio.io/go/ent/carrierbrand"
	"delivrio.io/go/ent/changehistory"
	"delivrio.io/go/ent/deliveryoption"
	"delivrio.io/go/ent/order"
	"delivrio.io/go/ent/returncolli"
	"delivrio.io/go/ent/returnportal"
	"delivrio.io/go/ent/returnportalclaim"
	"delivrio.io/go/gengql/generated/models"
	"delivrio.io/go/returns"
	"delivrio.io/go/schema/hooks/history"
	"delivrio.io/go/viewer"
	"delivrio.io/shared-utils/pulid"
)

// CreateReturnPortal is the resolver for the createReturnPortal field.
func (r *mutationResolver) CreateReturnPortal(ctx context.Context, name string, connection pulid.ID) (pulid.ID, error) {
	tx := ent.TxFromContext(ctx)
	view := viewer.FromContext(ctx)

	rp, err := tx.ReturnPortal.Create().
		SetName(name).
		SetConnectionID(connection).
		SetTenantID(view.TenantID()).
		Save(ctx)
	if err != nil {
		return "", err
	}
	return rp.ID, nil
}

// UpdateReturnPortal is the resolver for the updateReturnPortal field.
func (r *mutationResolver) UpdateReturnPortal(ctx context.Context, id pulid.ID, input ent.UpdateReturnPortalInput, inputClaims []*models.MutateReturnPortalClaim) (*ent.ReturnPortal, error) {
	tx := ent.TxFromContext(ctx)
	view := viewer.FromContext(ctx)

	currentClaims, err := tx.ReturnPortalClaim.Query().
		Where(returnportalclaim.HasReturnPortalWith(
			returnportal.ID(id),
		)).All(ctx)
	if err != nil {
		return nil, err
	}
	currentClaimMap := make(map[pulid.ID]*ent.ReturnPortalClaim)
	for _, c := range currentClaims {
		currentClaimMap[c.ID] = c
	}

	claimsNotArchived := make(map[pulid.ID]bool)

	for _, c := range inputClaims {
		if val, ok := currentClaimMap[c.ID]; ok {
			err = val.Update().SetInput(ent.UpdateReturnPortalClaimInput{
				Name:        &c.Input.Name,
				Description: &c.Input.Description,
				Restockable: &c.Input.Restockable,
			}).Exec(ctx)
			if err != nil {
				return nil, err
			}
			claimsNotArchived[val.ID] = true
		} else {
			err = tx.ReturnPortalClaim.Create().
				SetInput(*c.Input).
				SetArchived(false).
				SetReturnPortalID(id).
				SetTenantID(view.TenantID()).
				Exec(ctx)
			if err != nil {
				return nil, err
			}
		}
	}

	for _, c := range currentClaims {
		if _, ok := claimsNotArchived[c.ID]; !ok {
			count, err := c.QueryReturnOrderLine().Count(ctx)
			if err != nil {
				return nil, err
			}

			if count > 0 {
				err = c.Update().SetArchived(true).Exec(ctx)
				if err != nil {
					return nil, err
				}
			} else {
				err = tx.ReturnPortalClaim.DeleteOneID(c.ID).Exec(ctx)
				if err != nil {
					return nil, err
				}
			}
		}
	}

	err = tx.ReturnPortal.Update().
		SetInput(input).
		Where(returnportal.ID(id)).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return tx.ReturnPortal.Query().Where(returnportal.ID(id)).Only(ctx)
}

// CreateReturnOrder is the resolver for the createReturnOrder field.
func (r *mutationResolver) CreateReturnOrder(ctx context.Context, orderID pulid.ID, portalID pulid.ID, orderLines []*models.MutateReturnItems) ([]pulid.ID, error) {
	allOrderLineIDs := make([]pulid.ID, 0)
	units := make(map[pulid.ID]returns.ReturnLineItem, 0)
	for _, o := range orderLines {
		allOrderLineIDs = append(allOrderLineIDs, o.OrderLineID)
		units[o.OrderLineID] = returns.ReturnLineItem{
			Units:   o.Units,
			ClaimID: o.ClaimID,
		}
	}

	return returns.CreateReturn(ctx, orderID, portalID, units, "")
}

// UpdateReturnColliStatus is the resolver for the updateReturnColliStatus field.
func (r *mutationResolver) UpdateReturnColliStatus(ctx context.Context, returnColliID pulid.ID, status returncolli.Status) (*models.ReturnColliEdit, error) {
	if status != returncolli.StatusAccepted && status != returncolli.StatusDeclined {
		return nil, fmt.Errorf("return colli: update status: only Accepted and Declined supported")
	}

	tx := ent.TxFromContext(ctx)

	returnColli, err := tx.ReturnColli.Query().
		Where(returncolli.ID(returnColliID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	if returnColli.Status == status {
		return nil, fmt.Errorf("Return colli already has status: %s", status)
	}

	err = tx.ReturnColli.Update().
		SetStatus(status).
		Where(returncolli.ID(returnColliID)).
		Exec(history.NewConfig(ctx).
			SetOrigin(changehistory.OriginWebClient).
			SetDescription(fmt.Sprintf("Marked status as: %s", status)).
			Ctx())
	if err != nil {
		return nil, err
	}

	ord, err := tx.ReturnColli.Query().
		Where(returncolli.ID(returnColliID)).
		QueryOrder().
		WithReturnColli(func(q *ent.ReturnColliQuery) {
			q.Order(ent.Desc(returncolli.FieldID))
		}).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	output := make([]*models.ReturnColliTimeline, 0)
	for _, rc := range ord.Edges.ReturnColli {

		timeline, err := returns.ReturnColliTimeline(ctx, tx.Client(), rc.ID)
		if err != nil {
			return nil, err
		}

		output = append(output, &models.ReturnColliTimeline{
			Colli:    rc,
			Timeline: timeline,
		})
	}

	return &models.ReturnColliEdit{
		Order:  ord,
		Collis: output,
	}, nil
}

// MarkColliDeleted is the resolver for the markColliDeleted field.
func (r *mutationResolver) MarkColliDeleted(ctx context.Context, returnColliID pulid.ID) (bool, error) {
	tx := ent.TxFromContext(ctx)

	err := tx.ReturnColli.Update().
		SetStatus(returncolli.StatusDeleted).
		Where(returncolli.ID(returnColliID)).
		Exec(ctx)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ReturnPortal is the resolver for the returnPortal field.
func (r *queryResolver) ReturnPortal(ctx context.Context, id pulid.ID) (*ent.ReturnPortal, error) {
	return r.client.ReturnPortal.Query().
		Where(returnportal.ID(id)).
		Only(ctx)
}

// ReturnClaimsByOrder is the resolver for the returnClaimsByOrder field.
func (r *queryResolver) ReturnClaimsByOrder(ctx context.Context, orderID pulid.ID) ([]*ent.ReturnPortalClaim, error) {
	return r.client.Order.Query().Where(order.ID(orderID)).
		QueryConnection().
		QueryReturnPortal().
		QueryReturnPortalClaim().
		All(ctx)
}

// ReturnColli is the resolver for the returnColli field.
func (r *queryResolver) ReturnColli(ctx context.Context, orderID pulid.ID) (*models.ReturnColliEdit, error) {
	ord, err := r.client.Order.Query().
		Where(order.ID(orderID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	returnCollis, err := ord.QueryReturnColli().
		Order(ent.Desc(returncolli.FieldID)).
		All(ctx)
	if err != nil {
		return nil, err
	}

	output := make([]*models.ReturnColliTimeline, 0)
	for _, rc := range returnCollis {

		timeline, err := returns.ReturnColliTimeline(ctx, r.client, rc.ID)
		if err != nil {
			return nil, err
		}

		output = append(output, &models.ReturnColliTimeline{
			Colli:    rc,
			Timeline: timeline,
		})
	}

	return &models.ReturnColliEdit{
		Order:  ord,
		Collis: output,
	}, nil
}

// ReturnDeliveryOptions is the resolver for the returnDeliveryOptions field.
func (r *queryResolver) ReturnDeliveryOptions(ctx context.Context, returnColliIDs []pulid.ID) ([][]*deliveryoptions.DeliveryOptionBrandName, error) {
	output := make([][]*deliveryoptions.DeliveryOptionBrandName, 0)

	for _, c := range returnColliIDs {
		res, err := deliveryoptions.FromReturnColliID(ctx, c)
		if err != nil {
			return nil, err
		}
		output = append(output, res)
	}

	return output, nil
}

// AddReturnDeliveryOption is the resolver for the addReturnDeliveryOption field.
func (r *queryResolver) AddReturnDeliveryOption(ctx context.Context, deliveryOptions []*models.MutateReturnDeliveryOption) (pulid.ID, error) {
	cli := ent.FromContext(ctx)

	var returnColliID pulid.ID

	for _, r := range deliveryOptions {
		returnColliID = r.ReturnColliID

		err := cli.ReturnColli.Update().
			SetStatus(returncolli.StatusPending).
			SetDeliveryOptionID(r.DeliveryOptionID).
			Where(returncolli.ID(r.ReturnColliID)).
			Exec(ctx)
		if err != nil {
			return "", err
		}

		colli, err := cli.ReturnColli.Query().
			WithSender().
			WithRecipient().
			Where(returncolli.ID(r.ReturnColliID)).
			Only(ctx)
		if err != nil {
			return "", err
		}

		cb, err := cli.DeliveryOption.Query().
			Where(deliveryoption.ID(r.DeliveryOptionID)).
			QueryCarrier().
			QueryCarrierBrand().
			Only(ctx)
		if err != nil {
			return "", err
		}

		returnColliUpdate := cli.ReturnColli.Update()

		switch cb.InternalID {
		case carrierbrand.InternalIDPostNord:
			responseCheck, err := postnordapis.FetchReturnLabels(ctx, r.DeliveryOptionID, []*ent.ReturnColli{colli})
			if err != nil {
				return "", err
			}

			if len(responseCheck) == 0 {
				return "", fmt.Errorf("expected label responsePDF")
			}
			returnColliUpdate.SetLabelPdf(responseCheck[0].LabelPDF)
			returnColliUpdate.SetQrCodePng(responseCheck[0].QRCodePNG)
			break
		case carrierbrand.InternalIDGLS:
			responsePDF, err := glsapis.FetchSingleLabelGLS(ctx, common.ReturnOrderDeliveryOptionsColliIDs{
				ReturnColliID:    r.ReturnColliID,
				DeliveryOptionID: r.DeliveryOptionID,
			})
			if err != nil {
				return "", fmt.Errorf("expected label responsePDF")
			}
			returnColliUpdate.SetLabelPdf(responsePDF)
			break
		default:
			return "", fmt.Errorf("carrier brand %v not supported", cb.InternalID)
		}

		err = returnColliUpdate.
			Where(returncolli.ID(r.ReturnColliID)).
			Exec(ctx)
		if err != nil {
			return "", err
		}

	}

	return cli.ReturnColli.Query().
		Where(returncolli.ID(returnColliID)).
		QueryOrder().
		OnlyID(ctx)
}
