package gengql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"

	"delivrio.io/go/carrierapis/labels"
	"delivrio.io/go/ent"
	"delivrio.io/go/ent/address"
	"delivrio.io/go/ent/consolidation"
	"delivrio.io/go/ent/pallet"
	"delivrio.io/go/ent/shipment"
	"delivrio.io/go/gengql/generated/models"
	"delivrio.io/go/viewer"
	"delivrio.io/shared-utils/pulid"
)

// CreateConsolidation is the resolver for the createConsolidation field.
func (r *mutationResolver) CreateConsolidation(ctx context.Context, publicID string, description string) (*ent.Consolidation, error) {
	tx := ent.TxFromContext(ctx)
	view := viewer.FromContext(ctx)

	return tx.Consolidation.Create().
		SetTenantID(view.TenantID()).
		SetPublicID(publicID).
		SetDescription(description).
		Save(ctx)
}

// UpdateConsolidation is the resolver for the updateConsolidation field.
func (r *mutationResolver) UpdateConsolidation(ctx context.Context, id pulid.ID, input ent.UpdateConsolidationInput, sender *ent.CreateAddressInput, recipient *ent.CreateAddressInput, inputPallets []*models.CreateOrUpdatePallet) (*ent.Consolidation, error) {
	tx := ent.TxFromContext(ctx)
	view := viewer.FromContext(ctx)

	con, err := tx.Consolidation.Query().
		Where(consolidation.ID(id)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	err = con.Update().
		SetInput(input).
		Where(consolidation.ID(id)).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	if recipient != nil {
		_, err = tx.Address.Delete().
			Where(
				address.HasRecipientConsolidationWith(consolidation.ID(id)),
			).
			Exec(ctx)
		if err != nil {
			return nil, err
		}

		err = tx.Address.Create().
			SetInput(*recipient).
			SetRecipientConsolidation(con).
			SetTenantID(view.TenantID()).
			Exec(ctx)
		if err != nil {
			return nil, err
		}
	}

	if sender != nil {
		_, err = tx.Address.Delete().
			Where(
				address.HasSenderConsolidationWith(consolidation.ID(id)),
			).
			Exec(ctx)
		if err != nil {
			return nil, err
		}

		err = tx.Address.Create().
			SetInput(*sender).
			SetSenderConsolidation(con).
			SetTenantID(view.TenantID()).
			Exec(ctx)
		if err != nil {
			return nil, err
		}
	}

	palletIDsToKeep := make([]pulid.ID, 0)
	for _, ip := range inputPallets {
		if len(ip.ID) > 0 {
			err = tx.Pallet.Update().
				ClearOrders().
				ClearPackaging().
				SetDescription(ip.Create.Description).
				SetPublicID(ip.Create.PublicID).
				SetNillablePackagingID(ip.Create.PackagingID).
				AddOrderIDs(ip.Create.OrderIDs...).
				SetConsolidationID(id).
				Where(pallet.ID(ip.ID)).
				Exec(ctx)
			if err != nil {
				return nil, err
			}
			palletIDsToKeep = append(palletIDsToKeep, ip.ID)
		} else {
			p, err := tx.Pallet.Create().
				SetInput(*ip.Create).
				SetConsolidationID(id).
				SetTenantID(view.TenantID()).
				Save(ctx)
			if err != nil {
				return nil, err
			}
			palletIDsToKeep = append(palletIDsToKeep, p.ID)
		}
	}

	_, err = tx.Pallet.Delete().
		Where(pallet.And(
			pallet.HasConsolidationWith(consolidation.ID(id)),
			pallet.IDNotIn(palletIDsToKeep...),
		)).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return tx.Consolidation.Query().
		Where(consolidation.ID(id)).
		Only(ctx)
}

// Consolidation is the resolver for the consolidation field.
func (r *queryResolver) Consolidation(ctx context.Context, id pulid.ID) (*ent.Consolidation, error) {
	return r.client.Consolidation.Query().
		Where(consolidation.ID(id)).
		Only(ctx)
}

// ConsolidationShipments is the resolver for the consolidationShipments field.
func (r *queryResolver) ConsolidationShipments(ctx context.Context, consolidationID pulid.ID) (*models.ConsolidationShipmentStatus, error) {
	cli := ent.FromContext(ctx)

	ship, err := cli.Consolidation.Query().
		Where(consolidation.ID(consolidationID)).
		QueryShipment().
		Only(ctx)
	if err != nil && !ent.IsNotFound(err) {
		return nil, err
	}

	mayBook := true
	mayPrebook := true
	if ship != nil {
		switch ship.Status {
		case shipment.StatusBooked:
			mayBook = false
			mayPrebook = false
			break
		}
	}

	return &models.ConsolidationShipmentStatus{
		MayBook:    mayBook,
		MayPrebook: mayPrebook,
		Shipment:   ship,
	}, nil
}

// CreateConsolidationShipment is the resolver for the createConsolidationShipment field.
func (r *queryResolver) CreateConsolidationShipment(ctx context.Context, consolidationID pulid.ID, prebook bool) (*models.CreateShipmentConsolidationResponse, error) {
	cli := ent.FromContext(ctx)

	con, err := cli.Consolidation.Query().
		Where(consolidation.ID(consolidationID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	saved, err := labels.RequestAndSaveConsolidation(ctx, prebook, con)
	if err != nil {
		return nil, err
	}

	ship, err := cli.Shipment.Query().
		Where(shipment.ID(saved.ShipmentID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	return &models.CreateShipmentConsolidationResponse{
		Shipment:  ship,
		LabelsPDF: saved.LabelsPDF,
		AllLabels: saved.AllLabels,
	}, nil
}
