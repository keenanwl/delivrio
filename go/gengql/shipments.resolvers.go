package gengql

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.48

import (
	"context"
	"fmt"
	"time"

	"delivrio.io/go/carrierapis/labels"
	"delivrio.io/go/ent"
	"delivrio.io/go/ent/colli"
	"delivrio.io/go/ent/emailtemplate"
	"delivrio.io/go/ent/order"
	"delivrio.io/go/ent/shipment"
	"delivrio.io/go/ent/shipmentparcel"
	"delivrio.io/go/gengql/generated/models"
	"delivrio.io/go/mergeutils"
	"delivrio.io/go/utils"
	"delivrio.io/shared-utils/pulid"
	"entgo.io/contrib/entgql"
)

// CancelShipment is the resolver for the cancelShipment field.
func (r *mutationResolver) CancelShipment(ctx context.Context, shipmentID pulid.ID) (*ent.Shipment, error) {
	tx := ent.TxFromContext(ctx)
	err := tx.Shipment.Update().
		Where(shipment.ID(shipmentID)).
		SetStatus(shipment.StatusDeleted).
		Exec(ctx)
	if err != nil {
		return nil, err
	}

	return tx.Shipment.Query().
		Where(shipment.ID(shipmentID)).
		Only(ctx)
}

// CancelShipmentByColliIDs is the resolver for the cancelShipmentByColliIDs field.
func (r *mutationResolver) CancelShipmentByColliIDs(ctx context.Context, colliIDs []pulid.ID) (bool, error) {
	tx := ent.TxFromContext(ctx)

	shipmentToCancel, err := tx.Colli.Query().
		Where(colli.IDIn(colliIDs...)).
		QueryShipmentParcel().
		QueryShipment().
		All(ctx)
	if err != nil {
		return false, err
	}

	for _, s := range shipmentToCancel {
		err = s.Update().
			SetStatus(shipment.StatusDeleted).
			Exec(ctx)
		if err != nil {
			return false, err
		}
	}

	return true, nil
}

// DebugUpdateLabelIDs is the resolver for the debugUpdateLabelIDs field.
func (r *mutationResolver) DebugUpdateLabelIDs(ctx context.Context, parcelID pulid.ID, itemID string) (bool, error) {
	tx := ent.TxFromContext(ctx)

	err := tx.ShipmentParcel.Update().
		SetItemID(itemID).
		Where(shipmentparcel.ID(parcelID)).
		Exec(ctx)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CancelFulfillmentSync is the resolver for the cancelFulfillmentSync field.
func (r *mutationResolver) CancelFulfillmentSync(ctx context.Context, shipmentParcelID pulid.ID) (bool, error) {
	tx := ent.TxFromContext(ctx)

	err := tx.ShipmentParcel.Update().
		SetFulfillmentSyncedAt(time.Unix(0, 0)).
		Where(shipmentparcel.ID(shipmentParcelID)).
		Exec(ctx)
	if err != nil {
		return false, err
	}

	return true, nil
}

// CancelCancelSync is the resolver for the cancelCancelSync field.
func (r *mutationResolver) CancelCancelSync(ctx context.Context, shipmentParcelID pulid.ID) (bool, error) {
	tx := ent.TxFromContext(ctx)

	err := tx.ShipmentParcel.Update().
		SetCancelSyncedAt(time.Unix(0, 0)).
		Where(shipmentparcel.ID(shipmentParcelID)).
		Exec(ctx)
	if err != nil {
		return false, err
	}

	return true, nil
}

// ShipmentsList is the resolver for the shipmentsList field.
func (r *queryResolver) ShipmentsList(ctx context.Context, after *entgql.Cursor[pulid.ID], first *int, before *entgql.Cursor[pulid.ID], last *int, where *ent.ShipmentWhereInput) ([]*models.ShipmentListItem, error) {
	shipments, err := r.client.Shipment.Query().
		WithShipmentParcel().
		Where(where.Predicates...).
		All(ctx)

	if err != nil {
		return nil, err
	}

	output := make([]*models.ShipmentListItem, 0)

	for _, s := range shipments {

		orderID := ""
		for _, parcel := range s.Edges.ShipmentParcel {
			ord, err := parcel.QueryColli().QueryOrder().Only(ctx)
			if err != nil {
				return nil, err
			}
			orderID = ord.OrderPublicID
			// Bail since it should always be 1:1 until refactor
			break
		}

		output = append(output, &models.ShipmentListItem{
			ID:             s.ID,
			OrderIDDisplay: []string{orderID},
			Shipment:       s,
		})
	}

	return output, nil
}

// Shipment is the resolver for the shipment field.
func (r *queryResolver) Shipment(ctx context.Context, id pulid.ID) (*ent.Shipment, error) {
	return r.client.Shipment.Query().Where(shipment.ID(id)).Only(ctx)
}

// ShipmentLabels is the resolver for the shipmentLabels field.
func (r *queryResolver) ShipmentLabels(ctx context.Context, colliIDs []pulid.ID) (*models.ShipmentLabelsResponse, error) {
	allShipmentParcelsDocuments, err := r.client.Colli.Query().
		Where(colli.IDIn(colliIDs...)).
		QueryShipmentParcel().
		QueryDocumentFile().
		All(ctx)
	if err != nil {
		return nil, fmt.Errorf("fetch docs: %w", err)
	}

	labelList := make([]string, 0)
	for _, p := range allShipmentParcelsDocuments {
		pdfFiles, err := mergeutils.PDFDocFromFile(ctx, []*ent.DocumentFile{p})
		if err != nil {
			return nil, fmt.Errorf("pdf from doc: %w", err)
		} else if len(pdfFiles) == 0 {
			return nil, fmt.Errorf("pdf from doc: no document files")
		}
		labelList = append(labelList, pdfFiles[0])
	}

	allLabels, err := utils.JoinPDFs(labelList...)
	if err != nil {
		return nil, fmt.Errorf("join pdfs: %w", err)
	}

	return &models.ShipmentLabelsResponse{
		LabelsPDF: labelList,
		AllLabels: allLabels,
	}, nil
}

// SendOverviewEmail is the resolver for the sendOverviewEmail field.
func (r *queryResolver) SendOverviewEmail(ctx context.Context, to string, emailTpl pulid.ID, where ent.ShipmentWhereInput) (bool, error) {
	cli := ent.FromContext(ctx)

	email, err := cli.EmailTemplate.Query().
		Where(emailtemplate.ID(emailTpl)).
		Only(ctx)
	if err != nil {
		return false, err
	}

	/*todayStarts := emailutils.FutureMidnight(0)

	parcels, err := cli.Shipment.Query().
		// TODO: add more precision to Now()
		Where(where.Predicates...).
		//Where(shipment.ExpectedAtGTE(todayStarts)).
		//WithColli().
		All(ctx)
	if err != nil {
		return false, err
	}*/

	todayCount := 0
	tomorrowCount := 0

	// Technically, midnight is the first part of the day?
	/*todayMidnight := emailutils.FutureMidnight(1)
	tomorrowMidnight := emailutils.FutureMidnight(2)*/

	row := make([]mergeutils.FilteredShipmentsEmailRow, 0)
	/*for _, item := range parcels {
		recip, err := item.Edges.Colli.QueryRecipient().
			WithCountry().
			Only(ctx)
		if err != nil {
			return false, err
		}

		recipCountry, err := recip.Edges.CountryOrErr()
		if err != nil {
			return false, err
		}

		ord, err := item.Edges.Colli.Order(ctx)
		if err != nil {
			return false, err
		}
		do, err := item.Edges.Colli.DeliveryOption(ctx)
		if err != nil {
			return false, err
		}

		if item.ExpectedAt.Before(todayMidnight) {
			todayCount += 1
		} else if item.ExpectedAt.Before(tomorrowMidnight) {
			tomorrowCount += 1
		}

		row = append(row, emailutils.FilteredShipmentsEmailRow{
			PublicID:        ord.OrderPublicID,
			BarcodeLabel:    item.ItemID,
			DeliveryOption:  do.Name,
			ExpectedArrival: item.ExpectedAt.Format(time.DateOnly),

			CustomerAddress: emailutils.CustomerAddress{
				CustomerFirstName: recip.FirstName,
				CustomerLastName:  recip.LastName,
				CustomerCompany:   "",
				CustomerEmail:     recip.Email,
				CustomerAddress1:  recip.AddressOne,
				CustomerAddress2:  recip.AddressTwo,
				CustomerZip:       recip.Zip,
				CustomerCity:      recip.City,
				CustomerState:     recip.State,
				CustomerCountry:   recipCountry.Alpha2,
			},
		})
	}*/

	return mergeutils.SendTransactionalEmail(
		email.HTMLTemplate,
		email.Subject,
		to,
		mergeutils.FilteredShipmentsEmail{
			ArrivingToday:    todayCount,
			ArrivingTomorrow: tomorrowCount,
			Orders:           row,
		},
	)
}

// CreateShipments is the resolver for the createShipments field.
func (r *queryResolver) CreateShipments(ctx context.Context, orderID pulid.ID, packageIDs []pulid.ID) (*models.CreateShipmentsResponse, error) {
	cli := ent.FromContext(ctx)

	sorted, err := labels.SortCollis(ctx, packageIDs)
	if err != nil {
		return nil, err
	}

	// Tx is created here to prevent blocking while requesting labels
	createdShipments, err := labels.RequestAndSave(ctx, sorted)
	if err != nil {
		return nil, err
	}

	labelList := make([]string, 0)
	allCreateShipments := make([]*models.ShipmentLabelsResponse, 0)
	for _, s := range createdShipments {
		allCreateShipments = append(allCreateShipments, &models.ShipmentLabelsResponse{
			LabelsPDF: s.LabelsPDF,
			AllLabels: s.AllLabels,
		})
		labelList = append(labelList, s.LabelsPDF...)
	}

	or, err := cli.Order.Query().
		Where(order.ID(orderID)).
		Only(ctx)
	if err != nil {
		return nil, err
	}

	allLabels, err := utils.JoinPDFs(labelList...)
	if err != nil {
		return nil, fmt.Errorf("createshipments: joinPDFs: %w", err)
	}

	return &models.CreateShipmentsResponse{
		Order:     or,
		Shipments: allCreateShipments,
		LabelsPDF: labelList,
		AllLabels: allLabels,
	}, nil
}
