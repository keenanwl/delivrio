// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"delivrio.io/go/ent/accessright"
	"delivrio.io/go/ent/address"
	"delivrio.io/go/ent/addressglobal"
	"delivrio.io/go/ent/apitoken"
	"delivrio.io/go/ent/businesshoursperiod"
	"delivrio.io/go/ent/carrier"
	"delivrio.io/go/ent/carrieradditionalservicebring"
	"delivrio.io/go/ent/carrieradditionalservicedao"
	"delivrio.io/go/ent/carrieradditionalservicedf"
	"delivrio.io/go/ent/carrieradditionalservicedsv"
	"delivrio.io/go/ent/carrieradditionalserviceeasypost"
	"delivrio.io/go/ent/carrieradditionalservicegls"
	"delivrio.io/go/ent/carrieradditionalservicepostnord"
	"delivrio.io/go/ent/carrieradditionalserviceusps"
	"delivrio.io/go/ent/carrierbrand"
	"delivrio.io/go/ent/carrierbring"
	"delivrio.io/go/ent/carrierdao"
	"delivrio.io/go/ent/carrierdf"
	"delivrio.io/go/ent/carrierdsv"
	"delivrio.io/go/ent/carriereasypost"
	"delivrio.io/go/ent/carriergls"
	"delivrio.io/go/ent/carrierpostnord"
	"delivrio.io/go/ent/carrierservice"
	"delivrio.io/go/ent/carrierservicebring"
	"delivrio.io/go/ent/carrierservicedao"
	"delivrio.io/go/ent/carrierservicedf"
	"delivrio.io/go/ent/carrierservicedsv"
	"delivrio.io/go/ent/carrierserviceeasypost"
	"delivrio.io/go/ent/carrierservicegls"
	"delivrio.io/go/ent/carrierservicepostnord"
	"delivrio.io/go/ent/carrierserviceusps"
	"delivrio.io/go/ent/carrierusps"
	"delivrio.io/go/ent/changehistory"
	"delivrio.io/go/ent/colli"
	"delivrio.io/go/ent/connection"
	"delivrio.io/go/ent/connectionbrand"
	"delivrio.io/go/ent/connectionlookup"
	"delivrio.io/go/ent/connectionshopify"
	"delivrio.io/go/ent/connectoptioncarrier"
	"delivrio.io/go/ent/connectoptionplatform"
	"delivrio.io/go/ent/consolidation"
	"delivrio.io/go/ent/contact"
	"delivrio.io/go/ent/country"
	"delivrio.io/go/ent/countryharmonizedcode"
	"delivrio.io/go/ent/currency"
	"delivrio.io/go/ent/deliveryoption"
	"delivrio.io/go/ent/deliveryoptionbring"
	"delivrio.io/go/ent/deliveryoptiondao"
	"delivrio.io/go/ent/deliveryoptiondf"
	"delivrio.io/go/ent/deliveryoptiondsv"
	"delivrio.io/go/ent/deliveryoptioneasypost"
	"delivrio.io/go/ent/deliveryoptiongls"
	"delivrio.io/go/ent/deliveryoptionpostnord"
	"delivrio.io/go/ent/deliveryoptionusps"
	"delivrio.io/go/ent/deliveryrule"
	"delivrio.io/go/ent/deliveryruleconstraint"
	"delivrio.io/go/ent/deliveryruleconstraintgroup"
	"delivrio.io/go/ent/document"
	"delivrio.io/go/ent/documentfile"
	"delivrio.io/go/ent/emailtemplate"
	"delivrio.io/go/ent/hypothesistest"
	"delivrio.io/go/ent/hypothesistestdeliveryoption"
	"delivrio.io/go/ent/hypothesistestdeliveryoptionlookup"
	"delivrio.io/go/ent/hypothesistestdeliveryoptionrequest"
	"delivrio.io/go/ent/inventoryitem"
	"delivrio.io/go/ent/language"
	"delivrio.io/go/ent/location"
	"delivrio.io/go/ent/locationtag"
	"delivrio.io/go/ent/notification"
	"delivrio.io/go/ent/order"
	"delivrio.io/go/ent/orderhistory"
	"delivrio.io/go/ent/orderline"
	"delivrio.io/go/ent/ordersender"
	"delivrio.io/go/ent/otkrequests"
	"delivrio.io/go/ent/packaging"
	"delivrio.io/go/ent/packagingdf"
	"delivrio.io/go/ent/packagingusps"
	"delivrio.io/go/ent/packaginguspsprocessingcategory"
	"delivrio.io/go/ent/packaginguspsrateindicator"
	"delivrio.io/go/ent/pallet"
	"delivrio.io/go/ent/parcelshop"
	"delivrio.io/go/ent/parcelshopbring"
	"delivrio.io/go/ent/parcelshopdao"
	"delivrio.io/go/ent/parcelshopgls"
	"delivrio.io/go/ent/parcelshoppostnord"
	"delivrio.io/go/ent/plan"
	"delivrio.io/go/ent/planhistory"
	"delivrio.io/go/ent/predicate"
	"delivrio.io/go/ent/printer"
	"delivrio.io/go/ent/printjob"
	"delivrio.io/go/ent/product"
	"delivrio.io/go/ent/productimage"
	"delivrio.io/go/ent/producttag"
	"delivrio.io/go/ent/productvariant"
	"delivrio.io/go/ent/returncolli"
	"delivrio.io/go/ent/returncollihistory"
	"delivrio.io/go/ent/returnorderline"
	"delivrio.io/go/ent/returnportal"
	"delivrio.io/go/ent/returnportalclaim"
	"delivrio.io/go/ent/seatgroup"
	"delivrio.io/go/ent/seatgroupaccessright"
	"delivrio.io/go/ent/shipment"
	"delivrio.io/go/ent/shipmentbring"
	"delivrio.io/go/ent/shipmentdao"
	"delivrio.io/go/ent/shipmentdf"
	"delivrio.io/go/ent/shipmentdsv"
	"delivrio.io/go/ent/shipmenteasypost"
	"delivrio.io/go/ent/shipmentgls"
	"delivrio.io/go/ent/shipmenthistory"
	"delivrio.io/go/ent/shipmentpallet"
	"delivrio.io/go/ent/shipmentparcel"
	"delivrio.io/go/ent/shipmentpostnord"
	"delivrio.io/go/ent/shipmentusps"
	"delivrio.io/go/ent/signupoptions"
	"delivrio.io/go/ent/systemevents"
	"delivrio.io/go/ent/tenant"
	"delivrio.io/go/ent/user"
	"delivrio.io/go/ent/userseat"
	"delivrio.io/go/ent/workspacerecentscan"
	"delivrio.io/go/ent/workstation"
	"delivrio.io/go/schema/fieldjson"
	"delivrio.io/shared-utils/pulid"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAPIToken                            = "APIToken"
	TypeAccessRight                         = "AccessRight"
	TypeAddress                             = "Address"
	TypeAddressGlobal                       = "AddressGlobal"
	TypeBusinessHoursPeriod                 = "BusinessHoursPeriod"
	TypeCarrier                             = "Carrier"
	TypeCarrierAdditionalServiceBring       = "CarrierAdditionalServiceBring"
	TypeCarrierAdditionalServiceDAO         = "CarrierAdditionalServiceDAO"
	TypeCarrierAdditionalServiceDF          = "CarrierAdditionalServiceDF"
	TypeCarrierAdditionalServiceDSV         = "CarrierAdditionalServiceDSV"
	TypeCarrierAdditionalServiceEasyPost    = "CarrierAdditionalServiceEasyPost"
	TypeCarrierAdditionalServiceGLS         = "CarrierAdditionalServiceGLS"
	TypeCarrierAdditionalServicePostNord    = "CarrierAdditionalServicePostNord"
	TypeCarrierAdditionalServiceUSPS        = "CarrierAdditionalServiceUSPS"
	TypeCarrierBrand                        = "CarrierBrand"
	TypeCarrierBring                        = "CarrierBring"
	TypeCarrierDAO                          = "CarrierDAO"
	TypeCarrierDF                           = "CarrierDF"
	TypeCarrierDSV                          = "CarrierDSV"
	TypeCarrierEasyPost                     = "CarrierEasyPost"
	TypeCarrierGLS                          = "CarrierGLS"
	TypeCarrierPostNord                     = "CarrierPostNord"
	TypeCarrierService                      = "CarrierService"
	TypeCarrierServiceBring                 = "CarrierServiceBring"
	TypeCarrierServiceDAO                   = "CarrierServiceDAO"
	TypeCarrierServiceDF                    = "CarrierServiceDF"
	TypeCarrierServiceDSV                   = "CarrierServiceDSV"
	TypeCarrierServiceEasyPost              = "CarrierServiceEasyPost"
	TypeCarrierServiceGLS                   = "CarrierServiceGLS"
	TypeCarrierServicePostNord              = "CarrierServicePostNord"
	TypeCarrierServiceUSPS                  = "CarrierServiceUSPS"
	TypeCarrierUSPS                         = "CarrierUSPS"
	TypeChangeHistory                       = "ChangeHistory"
	TypeColli                               = "Colli"
	TypeConnectOptionCarrier                = "ConnectOptionCarrier"
	TypeConnectOptionPlatform               = "ConnectOptionPlatform"
	TypeConnection                          = "Connection"
	TypeConnectionBrand                     = "ConnectionBrand"
	TypeConnectionLookup                    = "ConnectionLookup"
	TypeConnectionShopify                   = "ConnectionShopify"
	TypeConsolidation                       = "Consolidation"
	TypeContact                             = "Contact"
	TypeCountry                             = "Country"
	TypeCountryHarmonizedCode               = "CountryHarmonizedCode"
	TypeCurrency                            = "Currency"
	TypeDeliveryOption                      = "DeliveryOption"
	TypeDeliveryOptionBring                 = "DeliveryOptionBring"
	TypeDeliveryOptionDAO                   = "DeliveryOptionDAO"
	TypeDeliveryOptionDF                    = "DeliveryOptionDF"
	TypeDeliveryOptionDSV                   = "DeliveryOptionDSV"
	TypeDeliveryOptionEasyPost              = "DeliveryOptionEasyPost"
	TypeDeliveryOptionGLS                   = "DeliveryOptionGLS"
	TypeDeliveryOptionPostNord              = "DeliveryOptionPostNord"
	TypeDeliveryOptionUSPS                  = "DeliveryOptionUSPS"
	TypeDeliveryRule                        = "DeliveryRule"
	TypeDeliveryRuleConstraint              = "DeliveryRuleConstraint"
	TypeDeliveryRuleConstraintGroup         = "DeliveryRuleConstraintGroup"
	TypeDocument                            = "Document"
	TypeDocumentFile                        = "DocumentFile"
	TypeEmailTemplate                       = "EmailTemplate"
	TypeHypothesisTest                      = "HypothesisTest"
	TypeHypothesisTestDeliveryOption        = "HypothesisTestDeliveryOption"
	TypeHypothesisTestDeliveryOptionLookup  = "HypothesisTestDeliveryOptionLookup"
	TypeHypothesisTestDeliveryOptionRequest = "HypothesisTestDeliveryOptionRequest"
	TypeInventoryItem                       = "InventoryItem"
	TypeLanguage                            = "Language"
	TypeLocation                            = "Location"
	TypeLocationTag                         = "LocationTag"
	TypeNotification                        = "Notification"
	TypeOTKRequests                         = "OTKRequests"
	TypeOrder                               = "Order"
	TypeOrderHistory                        = "OrderHistory"
	TypeOrderLine                           = "OrderLine"
	TypeOrderSender                         = "OrderSender"
	TypePackaging                           = "Packaging"
	TypePackagingDF                         = "PackagingDF"
	TypePackagingUSPS                       = "PackagingUSPS"
	TypePackagingUSPSProcessingCategory     = "PackagingUSPSProcessingCategory"
	TypePackagingUSPSRateIndicator          = "PackagingUSPSRateIndicator"
	TypePallet                              = "Pallet"
	TypeParcelShop                          = "ParcelShop"
	TypeParcelShopBring                     = "ParcelShopBring"
	TypeParcelShopDAO                       = "ParcelShopDAO"
	TypeParcelShopGLS                       = "ParcelShopGLS"
	TypeParcelShopPostNord                  = "ParcelShopPostNord"
	TypePlan                                = "Plan"
	TypePlanHistory                         = "PlanHistory"
	TypePrintJob                            = "PrintJob"
	TypePrinter                             = "Printer"
	TypeProduct                             = "Product"
	TypeProductImage                        = "ProductImage"
	TypeProductTag                          = "ProductTag"
	TypeProductVariant                      = "ProductVariant"
	TypeReturnColli                         = "ReturnColli"
	TypeReturnColliHistory                  = "ReturnColliHistory"
	TypeReturnOrderLine                     = "ReturnOrderLine"
	TypeReturnPortal                        = "ReturnPortal"
	TypeReturnPortalClaim                   = "ReturnPortalClaim"
	TypeSeatGroup                           = "SeatGroup"
	TypeSeatGroupAccessRight                = "SeatGroupAccessRight"
	TypeShipment                            = "Shipment"
	TypeShipmentBring                       = "ShipmentBring"
	TypeShipmentDAO                         = "ShipmentDAO"
	TypeShipmentDF                          = "ShipmentDF"
	TypeShipmentDSV                         = "ShipmentDSV"
	TypeShipmentEasyPost                    = "ShipmentEasyPost"
	TypeShipmentGLS                         = "ShipmentGLS"
	TypeShipmentHistory                     = "ShipmentHistory"
	TypeShipmentPallet                      = "ShipmentPallet"
	TypeShipmentParcel                      = "ShipmentParcel"
	TypeShipmentPostNord                    = "ShipmentPostNord"
	TypeShipmentUSPS                        = "ShipmentUSPS"
	TypeSignupOptions                       = "SignupOptions"
	TypeSystemEvents                        = "SystemEvents"
	TypeTenant                              = "Tenant"
	TypeUser                                = "User"
	TypeUserSeat                            = "UserSeat"
	TypeWorkspaceRecentScan                 = "WorkspaceRecentScan"
	TypeWorkstation                         = "Workstation"
)

// APITokenMutation represents an operation that mutates the APIToken nodes in the graph.
type APITokenMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.ID
	name          *string
	hashed_token  *string
	created_at    *time.Time
	last_used     *time.Time
	clearedFields map[string]struct{}
	tenant        *pulid.ID
	clearedtenant bool
	user          *pulid.ID
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*APIToken, error)
	predicates    []predicate.APIToken
}

var _ ent.Mutation = (*APITokenMutation)(nil)

// apitokenOption allows management of the mutation configuration using functional options.
type apitokenOption func(*APITokenMutation)

// newAPITokenMutation creates new mutation for the APIToken entity.
func newAPITokenMutation(c config, op Op, opts ...apitokenOption) *APITokenMutation {
	m := &APITokenMutation{
		config:        c,
		op:            op,
		typ:           TypeAPIToken,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAPITokenID sets the ID field of the mutation.
func withAPITokenID(id pulid.ID) apitokenOption {
	return func(m *APITokenMutation) {
		var (
			err   error
			once  sync.Once
			value *APIToken
		)
		m.oldValue = func(ctx context.Context) (*APIToken, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().APIToken.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAPIToken sets the old APIToken of the mutation.
func withAPIToken(node *APIToken) apitokenOption {
	return func(m *APITokenMutation) {
		m.oldValue = func(context.Context) (*APIToken, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m APITokenMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m APITokenMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of APIToken entities.
func (m *APITokenMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *APITokenMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *APITokenMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().APIToken.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *APITokenMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *APITokenMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *APITokenMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *APITokenMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *APITokenMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *APITokenMutation) ResetName() {
	m.name = nil
}

// SetHashedToken sets the "hashed_token" field.
func (m *APITokenMutation) SetHashedToken(s string) {
	m.hashed_token = &s
}

// HashedToken returns the value of the "hashed_token" field in the mutation.
func (m *APITokenMutation) HashedToken() (r string, exists bool) {
	v := m.hashed_token
	if v == nil {
		return
	}
	return *v, true
}

// OldHashedToken returns the old "hashed_token" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldHashedToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHashedToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHashedToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHashedToken: %w", err)
	}
	return oldValue.HashedToken, nil
}

// ResetHashedToken resets all changes to the "hashed_token" field.
func (m *APITokenMutation) ResetHashedToken() {
	m.hashed_token = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *APITokenMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *APITokenMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *APITokenMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[apitoken.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *APITokenMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *APITokenMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, apitoken.FieldCreatedAt)
}

// SetLastUsed sets the "last_used" field.
func (m *APITokenMutation) SetLastUsed(t time.Time) {
	m.last_used = &t
}

// LastUsed returns the value of the "last_used" field in the mutation.
func (m *APITokenMutation) LastUsed() (r time.Time, exists bool) {
	v := m.last_used
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUsed returns the old "last_used" field's value of the APIToken entity.
// If the APIToken object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *APITokenMutation) OldLastUsed(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUsed: %w", err)
	}
	return oldValue.LastUsed, nil
}

// ClearLastUsed clears the value of the "last_used" field.
func (m *APITokenMutation) ClearLastUsed() {
	m.last_used = nil
	m.clearedFields[apitoken.FieldLastUsed] = struct{}{}
}

// LastUsedCleared returns if the "last_used" field was cleared in this mutation.
func (m *APITokenMutation) LastUsedCleared() bool {
	_, ok := m.clearedFields[apitoken.FieldLastUsed]
	return ok
}

// ResetLastUsed resets all changes to the "last_used" field.
func (m *APITokenMutation) ResetLastUsed() {
	m.last_used = nil
	delete(m.clearedFields, apitoken.FieldLastUsed)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *APITokenMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[apitoken.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *APITokenMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *APITokenMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *APITokenMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *APITokenMutation) SetUserID(id pulid.ID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *APITokenMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *APITokenMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *APITokenMutation) UserID() (id pulid.ID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *APITokenMutation) UserIDs() (ids []pulid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *APITokenMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the APITokenMutation builder.
func (m *APITokenMutation) Where(ps ...predicate.APIToken) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the APITokenMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *APITokenMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.APIToken, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *APITokenMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *APITokenMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (APIToken).
func (m *APITokenMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *APITokenMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, apitoken.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, apitoken.FieldName)
	}
	if m.hashed_token != nil {
		fields = append(fields, apitoken.FieldHashedToken)
	}
	if m.created_at != nil {
		fields = append(fields, apitoken.FieldCreatedAt)
	}
	if m.last_used != nil {
		fields = append(fields, apitoken.FieldLastUsed)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *APITokenMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case apitoken.FieldTenantID:
		return m.TenantID()
	case apitoken.FieldName:
		return m.Name()
	case apitoken.FieldHashedToken:
		return m.HashedToken()
	case apitoken.FieldCreatedAt:
		return m.CreatedAt()
	case apitoken.FieldLastUsed:
		return m.LastUsed()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *APITokenMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case apitoken.FieldTenantID:
		return m.OldTenantID(ctx)
	case apitoken.FieldName:
		return m.OldName(ctx)
	case apitoken.FieldHashedToken:
		return m.OldHashedToken(ctx)
	case apitoken.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case apitoken.FieldLastUsed:
		return m.OldLastUsed(ctx)
	}
	return nil, fmt.Errorf("unknown APIToken field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APITokenMutation) SetField(name string, value ent.Value) error {
	switch name {
	case apitoken.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case apitoken.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case apitoken.FieldHashedToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHashedToken(v)
		return nil
	case apitoken.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case apitoken.FieldLastUsed:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUsed(v)
		return nil
	}
	return fmt.Errorf("unknown APIToken field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *APITokenMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *APITokenMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *APITokenMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown APIToken numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *APITokenMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(apitoken.FieldCreatedAt) {
		fields = append(fields, apitoken.FieldCreatedAt)
	}
	if m.FieldCleared(apitoken.FieldLastUsed) {
		fields = append(fields, apitoken.FieldLastUsed)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *APITokenMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *APITokenMutation) ClearField(name string) error {
	switch name {
	case apitoken.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case apitoken.FieldLastUsed:
		m.ClearLastUsed()
		return nil
	}
	return fmt.Errorf("unknown APIToken nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *APITokenMutation) ResetField(name string) error {
	switch name {
	case apitoken.FieldTenantID:
		m.ResetTenantID()
		return nil
	case apitoken.FieldName:
		m.ResetName()
		return nil
	case apitoken.FieldHashedToken:
		m.ResetHashedToken()
		return nil
	case apitoken.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case apitoken.FieldLastUsed:
		m.ResetLastUsed()
		return nil
	}
	return fmt.Errorf("unknown APIToken field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *APITokenMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, apitoken.EdgeTenant)
	}
	if m.user != nil {
		edges = append(edges, apitoken.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *APITokenMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case apitoken.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case apitoken.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *APITokenMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *APITokenMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *APITokenMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, apitoken.EdgeTenant)
	}
	if m.cleareduser {
		edges = append(edges, apitoken.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *APITokenMutation) EdgeCleared(name string) bool {
	switch name {
	case apitoken.EdgeTenant:
		return m.clearedtenant
	case apitoken.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *APITokenMutation) ClearEdge(name string) error {
	switch name {
	case apitoken.EdgeTenant:
		m.ClearTenant()
		return nil
	case apitoken.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown APIToken unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *APITokenMutation) ResetEdge(name string) error {
	switch name {
	case apitoken.EdgeTenant:
		m.ResetTenant()
		return nil
	case apitoken.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown APIToken edge %s", name)
}

// AccessRightMutation represents an operation that mutates the AccessRight nodes in the graph.
type AccessRightMutation struct {
	config
	op                             Op
	typ                            string
	id                             *pulid.ID
	label                          *string
	internal_id                    *string
	clearedFields                  map[string]struct{}
	assigned_access_right          map[pulid.ID]struct{}
	removedassigned_access_right   map[pulid.ID]struct{}
	clearedassigned_access_right   bool
	seat_group_access_right        map[pulid.ID]struct{}
	removedseat_group_access_right map[pulid.ID]struct{}
	clearedseat_group_access_right bool
	done                           bool
	oldValue                       func(context.Context) (*AccessRight, error)
	predicates                     []predicate.AccessRight
}

var _ ent.Mutation = (*AccessRightMutation)(nil)

// accessrightOption allows management of the mutation configuration using functional options.
type accessrightOption func(*AccessRightMutation)

// newAccessRightMutation creates new mutation for the AccessRight entity.
func newAccessRightMutation(c config, op Op, opts ...accessrightOption) *AccessRightMutation {
	m := &AccessRightMutation{
		config:        c,
		op:            op,
		typ:           TypeAccessRight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccessRightID sets the ID field of the mutation.
func withAccessRightID(id pulid.ID) accessrightOption {
	return func(m *AccessRightMutation) {
		var (
			err   error
			once  sync.Once
			value *AccessRight
		)
		m.oldValue = func(ctx context.Context) (*AccessRight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AccessRight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccessRight sets the old AccessRight of the mutation.
func withAccessRight(node *AccessRight) accessrightOption {
	return func(m *AccessRightMutation) {
		m.oldValue = func(context.Context) (*AccessRight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccessRightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccessRightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AccessRight entities.
func (m *AccessRightMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccessRightMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccessRightMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AccessRight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *AccessRightMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *AccessRightMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the AccessRight entity.
// If the AccessRight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessRightMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *AccessRightMutation) ResetLabel() {
	m.label = nil
}

// SetInternalID sets the "internal_id" field.
func (m *AccessRightMutation) SetInternalID(s string) {
	m.internal_id = &s
}

// InternalID returns the value of the "internal_id" field in the mutation.
func (m *AccessRightMutation) InternalID() (r string, exists bool) {
	v := m.internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalID returns the old "internal_id" field's value of the AccessRight entity.
// If the AccessRight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccessRightMutation) OldInternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalID: %w", err)
	}
	return oldValue.InternalID, nil
}

// ResetInternalID resets all changes to the "internal_id" field.
func (m *AccessRightMutation) ResetInternalID() {
	m.internal_id = nil
}

// AddAssignedAccessRightIDs adds the "assigned_access_right" edge to the SeatGroup entity by ids.
func (m *AccessRightMutation) AddAssignedAccessRightIDs(ids ...pulid.ID) {
	if m.assigned_access_right == nil {
		m.assigned_access_right = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.assigned_access_right[ids[i]] = struct{}{}
	}
}

// ClearAssignedAccessRight clears the "assigned_access_right" edge to the SeatGroup entity.
func (m *AccessRightMutation) ClearAssignedAccessRight() {
	m.clearedassigned_access_right = true
}

// AssignedAccessRightCleared reports if the "assigned_access_right" edge to the SeatGroup entity was cleared.
func (m *AccessRightMutation) AssignedAccessRightCleared() bool {
	return m.clearedassigned_access_right
}

// RemoveAssignedAccessRightIDs removes the "assigned_access_right" edge to the SeatGroup entity by IDs.
func (m *AccessRightMutation) RemoveAssignedAccessRightIDs(ids ...pulid.ID) {
	if m.removedassigned_access_right == nil {
		m.removedassigned_access_right = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.assigned_access_right, ids[i])
		m.removedassigned_access_right[ids[i]] = struct{}{}
	}
}

// RemovedAssignedAccessRight returns the removed IDs of the "assigned_access_right" edge to the SeatGroup entity.
func (m *AccessRightMutation) RemovedAssignedAccessRightIDs() (ids []pulid.ID) {
	for id := range m.removedassigned_access_right {
		ids = append(ids, id)
	}
	return
}

// AssignedAccessRightIDs returns the "assigned_access_right" edge IDs in the mutation.
func (m *AccessRightMutation) AssignedAccessRightIDs() (ids []pulid.ID) {
	for id := range m.assigned_access_right {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedAccessRight resets all changes to the "assigned_access_right" edge.
func (m *AccessRightMutation) ResetAssignedAccessRight() {
	m.assigned_access_right = nil
	m.clearedassigned_access_right = false
	m.removedassigned_access_right = nil
}

// AddSeatGroupAccessRightIDs adds the "seat_group_access_right" edge to the SeatGroupAccessRight entity by ids.
func (m *AccessRightMutation) AddSeatGroupAccessRightIDs(ids ...pulid.ID) {
	if m.seat_group_access_right == nil {
		m.seat_group_access_right = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.seat_group_access_right[ids[i]] = struct{}{}
	}
}

// ClearSeatGroupAccessRight clears the "seat_group_access_right" edge to the SeatGroupAccessRight entity.
func (m *AccessRightMutation) ClearSeatGroupAccessRight() {
	m.clearedseat_group_access_right = true
}

// SeatGroupAccessRightCleared reports if the "seat_group_access_right" edge to the SeatGroupAccessRight entity was cleared.
func (m *AccessRightMutation) SeatGroupAccessRightCleared() bool {
	return m.clearedseat_group_access_right
}

// RemoveSeatGroupAccessRightIDs removes the "seat_group_access_right" edge to the SeatGroupAccessRight entity by IDs.
func (m *AccessRightMutation) RemoveSeatGroupAccessRightIDs(ids ...pulid.ID) {
	if m.removedseat_group_access_right == nil {
		m.removedseat_group_access_right = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.seat_group_access_right, ids[i])
		m.removedseat_group_access_right[ids[i]] = struct{}{}
	}
}

// RemovedSeatGroupAccessRight returns the removed IDs of the "seat_group_access_right" edge to the SeatGroupAccessRight entity.
func (m *AccessRightMutation) RemovedSeatGroupAccessRightIDs() (ids []pulid.ID) {
	for id := range m.removedseat_group_access_right {
		ids = append(ids, id)
	}
	return
}

// SeatGroupAccessRightIDs returns the "seat_group_access_right" edge IDs in the mutation.
func (m *AccessRightMutation) SeatGroupAccessRightIDs() (ids []pulid.ID) {
	for id := range m.seat_group_access_right {
		ids = append(ids, id)
	}
	return
}

// ResetSeatGroupAccessRight resets all changes to the "seat_group_access_right" edge.
func (m *AccessRightMutation) ResetSeatGroupAccessRight() {
	m.seat_group_access_right = nil
	m.clearedseat_group_access_right = false
	m.removedseat_group_access_right = nil
}

// Where appends a list predicates to the AccessRightMutation builder.
func (m *AccessRightMutation) Where(ps ...predicate.AccessRight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccessRightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccessRightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AccessRight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccessRightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccessRightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AccessRight).
func (m *AccessRightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccessRightMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.label != nil {
		fields = append(fields, accessright.FieldLabel)
	}
	if m.internal_id != nil {
		fields = append(fields, accessright.FieldInternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccessRightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case accessright.FieldLabel:
		return m.Label()
	case accessright.FieldInternalID:
		return m.InternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccessRightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case accessright.FieldLabel:
		return m.OldLabel(ctx)
	case accessright.FieldInternalID:
		return m.OldInternalID(ctx)
	}
	return nil, fmt.Errorf("unknown AccessRight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessRightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case accessright.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case accessright.FieldInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalID(v)
		return nil
	}
	return fmt.Errorf("unknown AccessRight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccessRightMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccessRightMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccessRightMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AccessRight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccessRightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccessRightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccessRightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown AccessRight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccessRightMutation) ResetField(name string) error {
	switch name {
	case accessright.FieldLabel:
		m.ResetLabel()
		return nil
	case accessright.FieldInternalID:
		m.ResetInternalID()
		return nil
	}
	return fmt.Errorf("unknown AccessRight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccessRightMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.assigned_access_right != nil {
		edges = append(edges, accessright.EdgeAssignedAccessRight)
	}
	if m.seat_group_access_right != nil {
		edges = append(edges, accessright.EdgeSeatGroupAccessRight)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccessRightMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case accessright.EdgeAssignedAccessRight:
		ids := make([]ent.Value, 0, len(m.assigned_access_right))
		for id := range m.assigned_access_right {
			ids = append(ids, id)
		}
		return ids
	case accessright.EdgeSeatGroupAccessRight:
		ids := make([]ent.Value, 0, len(m.seat_group_access_right))
		for id := range m.seat_group_access_right {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccessRightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedassigned_access_right != nil {
		edges = append(edges, accessright.EdgeAssignedAccessRight)
	}
	if m.removedseat_group_access_right != nil {
		edges = append(edges, accessright.EdgeSeatGroupAccessRight)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccessRightMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case accessright.EdgeAssignedAccessRight:
		ids := make([]ent.Value, 0, len(m.removedassigned_access_right))
		for id := range m.removedassigned_access_right {
			ids = append(ids, id)
		}
		return ids
	case accessright.EdgeSeatGroupAccessRight:
		ids := make([]ent.Value, 0, len(m.removedseat_group_access_right))
		for id := range m.removedseat_group_access_right {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccessRightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedassigned_access_right {
		edges = append(edges, accessright.EdgeAssignedAccessRight)
	}
	if m.clearedseat_group_access_right {
		edges = append(edges, accessright.EdgeSeatGroupAccessRight)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccessRightMutation) EdgeCleared(name string) bool {
	switch name {
	case accessright.EdgeAssignedAccessRight:
		return m.clearedassigned_access_right
	case accessright.EdgeSeatGroupAccessRight:
		return m.clearedseat_group_access_right
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccessRightMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AccessRight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccessRightMutation) ResetEdge(name string) error {
	switch name {
	case accessright.EdgeAssignedAccessRight:
		m.ResetAssignedAccessRight()
		return nil
	case accessright.EdgeSeatGroupAccessRight:
		m.ResetSeatGroupAccessRight()
		return nil
	}
	return fmt.Errorf("unknown AccessRight edge %s", name)
}

// AddressMutation represents an operation that mutates the Address nodes in the graph.
type AddressMutation struct {
	config
	op                             Op
	typ                            string
	id                             *pulid.ID
	uniqueness_id                  *string
	first_name                     *string
	last_name                      *string
	email                          *string
	phone_number                   *string
	phone_number_2                 *string
	vat_number                     *string
	company                        *string
	address_one                    *string
	address_two                    *string
	city                           *string
	state                          *string
	zip                            *string
	clearedFields                  map[string]struct{}
	tenant                         *pulid.ID
	clearedtenant                  bool
	recipient_colli                map[pulid.ID]struct{}
	removedrecipient_colli         map[pulid.ID]struct{}
	clearedrecipient_colli         bool
	recipient_consolidation        *pulid.ID
	clearedrecipient_consolidation bool
	company_address                map[pulid.ID]struct{}
	removedcompany_address         map[pulid.ID]struct{}
	clearedcompany_address         bool
	location                       map[pulid.ID]struct{}
	removedlocation                map[pulid.ID]struct{}
	clearedlocation                bool
	sender_colli                   map[pulid.ID]struct{}
	removedsender_colli            map[pulid.ID]struct{}
	clearedsender_colli            bool
	sender_consolidation           *pulid.ID
	clearedsender_consolidation    bool
	return_sender_colli            map[pulid.ID]struct{}
	removedreturn_sender_colli     map[pulid.ID]struct{}
	clearedreturn_sender_colli     bool
	return_recipient_colli         map[pulid.ID]struct{}
	removedreturn_recipient_colli  map[pulid.ID]struct{}
	clearedreturn_recipient_colli  bool
	country                        *pulid.ID
	clearedcountry                 bool
	done                           bool
	oldValue                       func(context.Context) (*Address, error)
	predicates                     []predicate.Address
}

var _ ent.Mutation = (*AddressMutation)(nil)

// addressOption allows management of the mutation configuration using functional options.
type addressOption func(*AddressMutation)

// newAddressMutation creates new mutation for the Address entity.
func newAddressMutation(c config, op Op, opts ...addressOption) *AddressMutation {
	m := &AddressMutation{
		config:        c,
		op:            op,
		typ:           TypeAddress,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressID sets the ID field of the mutation.
func withAddressID(id pulid.ID) addressOption {
	return func(m *AddressMutation) {
		var (
			err   error
			once  sync.Once
			value *Address
		)
		m.oldValue = func(ctx context.Context) (*Address, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Address.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddress sets the old Address of the mutation.
func withAddress(node *Address) addressOption {
	return func(m *AddressMutation) {
		m.oldValue = func(context.Context) (*Address, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Address entities.
func (m *AddressMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Address.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *AddressMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *AddressMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *AddressMutation) ResetTenantID() {
	m.tenant = nil
}

// SetUniquenessID sets the "uniqueness_id" field.
func (m *AddressMutation) SetUniquenessID(s string) {
	m.uniqueness_id = &s
}

// UniquenessID returns the value of the "uniqueness_id" field in the mutation.
func (m *AddressMutation) UniquenessID() (r string, exists bool) {
	v := m.uniqueness_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUniquenessID returns the old "uniqueness_id" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldUniquenessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniquenessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniquenessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniquenessID: %w", err)
	}
	return oldValue.UniquenessID, nil
}

// ClearUniquenessID clears the value of the "uniqueness_id" field.
func (m *AddressMutation) ClearUniquenessID() {
	m.uniqueness_id = nil
	m.clearedFields[address.FieldUniquenessID] = struct{}{}
}

// UniquenessIDCleared returns if the "uniqueness_id" field was cleared in this mutation.
func (m *AddressMutation) UniquenessIDCleared() bool {
	_, ok := m.clearedFields[address.FieldUniquenessID]
	return ok
}

// ResetUniquenessID resets all changes to the "uniqueness_id" field.
func (m *AddressMutation) ResetUniquenessID() {
	m.uniqueness_id = nil
	delete(m.clearedFields, address.FieldUniquenessID)
}

// SetFirstName sets the "first_name" field.
func (m *AddressMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *AddressMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *AddressMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *AddressMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AddressMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AddressMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *AddressMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AddressMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AddressMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *AddressMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *AddressMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *AddressMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetPhoneNumber2 sets the "phone_number_2" field.
func (m *AddressMutation) SetPhoneNumber2(s string) {
	m.phone_number_2 = &s
}

// PhoneNumber2 returns the value of the "phone_number_2" field in the mutation.
func (m *AddressMutation) PhoneNumber2() (r string, exists bool) {
	v := m.phone_number_2
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber2 returns the old "phone_number_2" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldPhoneNumber2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber2: %w", err)
	}
	return oldValue.PhoneNumber2, nil
}

// ClearPhoneNumber2 clears the value of the "phone_number_2" field.
func (m *AddressMutation) ClearPhoneNumber2() {
	m.phone_number_2 = nil
	m.clearedFields[address.FieldPhoneNumber2] = struct{}{}
}

// PhoneNumber2Cleared returns if the "phone_number_2" field was cleared in this mutation.
func (m *AddressMutation) PhoneNumber2Cleared() bool {
	_, ok := m.clearedFields[address.FieldPhoneNumber2]
	return ok
}

// ResetPhoneNumber2 resets all changes to the "phone_number_2" field.
func (m *AddressMutation) ResetPhoneNumber2() {
	m.phone_number_2 = nil
	delete(m.clearedFields, address.FieldPhoneNumber2)
}

// SetVatNumber sets the "vat_number" field.
func (m *AddressMutation) SetVatNumber(s string) {
	m.vat_number = &s
}

// VatNumber returns the value of the "vat_number" field in the mutation.
func (m *AddressMutation) VatNumber() (r string, exists bool) {
	v := m.vat_number
	if v == nil {
		return
	}
	return *v, true
}

// OldVatNumber returns the old "vat_number" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldVatNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVatNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVatNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatNumber: %w", err)
	}
	return oldValue.VatNumber, nil
}

// ClearVatNumber clears the value of the "vat_number" field.
func (m *AddressMutation) ClearVatNumber() {
	m.vat_number = nil
	m.clearedFields[address.FieldVatNumber] = struct{}{}
}

// VatNumberCleared returns if the "vat_number" field was cleared in this mutation.
func (m *AddressMutation) VatNumberCleared() bool {
	_, ok := m.clearedFields[address.FieldVatNumber]
	return ok
}

// ResetVatNumber resets all changes to the "vat_number" field.
func (m *AddressMutation) ResetVatNumber() {
	m.vat_number = nil
	delete(m.clearedFields, address.FieldVatNumber)
}

// SetCompany sets the "company" field.
func (m *AddressMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *AddressMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *AddressMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[address.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *AddressMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[address.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *AddressMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, address.FieldCompany)
}

// SetAddressOne sets the "address_one" field.
func (m *AddressMutation) SetAddressOne(s string) {
	m.address_one = &s
}

// AddressOne returns the value of the "address_one" field in the mutation.
func (m *AddressMutation) AddressOne() (r string, exists bool) {
	v := m.address_one
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressOne returns the old "address_one" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddressOne(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressOne is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressOne requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressOne: %w", err)
	}
	return oldValue.AddressOne, nil
}

// ResetAddressOne resets all changes to the "address_one" field.
func (m *AddressMutation) ResetAddressOne() {
	m.address_one = nil
}

// SetAddressTwo sets the "address_two" field.
func (m *AddressMutation) SetAddressTwo(s string) {
	m.address_two = &s
}

// AddressTwo returns the value of the "address_two" field in the mutation.
func (m *AddressMutation) AddressTwo() (r string, exists bool) {
	v := m.address_two
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressTwo returns the old "address_two" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldAddressTwo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressTwo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressTwo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressTwo: %w", err)
	}
	return oldValue.AddressTwo, nil
}

// ResetAddressTwo resets all changes to the "address_two" field.
func (m *AddressMutation) ResetAddressTwo() {
	m.address_two = nil
}

// SetCity sets the "city" field.
func (m *AddressMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AddressMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AddressMutation) ResetCity() {
	m.city = nil
}

// SetState sets the "state" field.
func (m *AddressMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AddressMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *AddressMutation) ClearState() {
	m.state = nil
	m.clearedFields[address.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *AddressMutation) StateCleared() bool {
	_, ok := m.clearedFields[address.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *AddressMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, address.FieldState)
}

// SetZip sets the "zip" field.
func (m *AddressMutation) SetZip(s string) {
	m.zip = &s
}

// Zip returns the value of the "zip" field in the mutation.
func (m *AddressMutation) Zip() (r string, exists bool) {
	v := m.zip
	if v == nil {
		return
	}
	return *v, true
}

// OldZip returns the old "zip" field's value of the Address entity.
// If the Address object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressMutation) OldZip(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZip: %w", err)
	}
	return oldValue.Zip, nil
}

// ResetZip resets all changes to the "zip" field.
func (m *AddressMutation) ResetZip() {
	m.zip = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *AddressMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[address.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *AddressMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *AddressMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddRecipientColliIDs adds the "recipient_colli" edge to the Colli entity by ids.
func (m *AddressMutation) AddRecipientColliIDs(ids ...pulid.ID) {
	if m.recipient_colli == nil {
		m.recipient_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.recipient_colli[ids[i]] = struct{}{}
	}
}

// ClearRecipientColli clears the "recipient_colli" edge to the Colli entity.
func (m *AddressMutation) ClearRecipientColli() {
	m.clearedrecipient_colli = true
}

// RecipientColliCleared reports if the "recipient_colli" edge to the Colli entity was cleared.
func (m *AddressMutation) RecipientColliCleared() bool {
	return m.clearedrecipient_colli
}

// RemoveRecipientColliIDs removes the "recipient_colli" edge to the Colli entity by IDs.
func (m *AddressMutation) RemoveRecipientColliIDs(ids ...pulid.ID) {
	if m.removedrecipient_colli == nil {
		m.removedrecipient_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.recipient_colli, ids[i])
		m.removedrecipient_colli[ids[i]] = struct{}{}
	}
}

// RemovedRecipientColli returns the removed IDs of the "recipient_colli" edge to the Colli entity.
func (m *AddressMutation) RemovedRecipientColliIDs() (ids []pulid.ID) {
	for id := range m.removedrecipient_colli {
		ids = append(ids, id)
	}
	return
}

// RecipientColliIDs returns the "recipient_colli" edge IDs in the mutation.
func (m *AddressMutation) RecipientColliIDs() (ids []pulid.ID) {
	for id := range m.recipient_colli {
		ids = append(ids, id)
	}
	return
}

// ResetRecipientColli resets all changes to the "recipient_colli" edge.
func (m *AddressMutation) ResetRecipientColli() {
	m.recipient_colli = nil
	m.clearedrecipient_colli = false
	m.removedrecipient_colli = nil
}

// SetRecipientConsolidationID sets the "recipient_consolidation" edge to the Consolidation entity by id.
func (m *AddressMutation) SetRecipientConsolidationID(id pulid.ID) {
	m.recipient_consolidation = &id
}

// ClearRecipientConsolidation clears the "recipient_consolidation" edge to the Consolidation entity.
func (m *AddressMutation) ClearRecipientConsolidation() {
	m.clearedrecipient_consolidation = true
}

// RecipientConsolidationCleared reports if the "recipient_consolidation" edge to the Consolidation entity was cleared.
func (m *AddressMutation) RecipientConsolidationCleared() bool {
	return m.clearedrecipient_consolidation
}

// RecipientConsolidationID returns the "recipient_consolidation" edge ID in the mutation.
func (m *AddressMutation) RecipientConsolidationID() (id pulid.ID, exists bool) {
	if m.recipient_consolidation != nil {
		return *m.recipient_consolidation, true
	}
	return
}

// RecipientConsolidationIDs returns the "recipient_consolidation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecipientConsolidationID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) RecipientConsolidationIDs() (ids []pulid.ID) {
	if id := m.recipient_consolidation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecipientConsolidation resets all changes to the "recipient_consolidation" edge.
func (m *AddressMutation) ResetRecipientConsolidation() {
	m.recipient_consolidation = nil
	m.clearedrecipient_consolidation = false
}

// AddCompanyAddresIDs adds the "company_address" edge to the Tenant entity by ids.
func (m *AddressMutation) AddCompanyAddresIDs(ids ...pulid.ID) {
	if m.company_address == nil {
		m.company_address = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.company_address[ids[i]] = struct{}{}
	}
}

// ClearCompanyAddress clears the "company_address" edge to the Tenant entity.
func (m *AddressMutation) ClearCompanyAddress() {
	m.clearedcompany_address = true
}

// CompanyAddressCleared reports if the "company_address" edge to the Tenant entity was cleared.
func (m *AddressMutation) CompanyAddressCleared() bool {
	return m.clearedcompany_address
}

// RemoveCompanyAddresIDs removes the "company_address" edge to the Tenant entity by IDs.
func (m *AddressMutation) RemoveCompanyAddresIDs(ids ...pulid.ID) {
	if m.removedcompany_address == nil {
		m.removedcompany_address = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.company_address, ids[i])
		m.removedcompany_address[ids[i]] = struct{}{}
	}
}

// RemovedCompanyAddress returns the removed IDs of the "company_address" edge to the Tenant entity.
func (m *AddressMutation) RemovedCompanyAddressIDs() (ids []pulid.ID) {
	for id := range m.removedcompany_address {
		ids = append(ids, id)
	}
	return
}

// CompanyAddressIDs returns the "company_address" edge IDs in the mutation.
func (m *AddressMutation) CompanyAddressIDs() (ids []pulid.ID) {
	for id := range m.company_address {
		ids = append(ids, id)
	}
	return
}

// ResetCompanyAddress resets all changes to the "company_address" edge.
func (m *AddressMutation) ResetCompanyAddress() {
	m.company_address = nil
	m.clearedcompany_address = false
	m.removedcompany_address = nil
}

// AddLocationIDs adds the "location" edge to the Location entity by ids.
func (m *AddressMutation) AddLocationIDs(ids ...pulid.ID) {
	if m.location == nil {
		m.location = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.location[ids[i]] = struct{}{}
	}
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *AddressMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *AddressMutation) LocationCleared() bool {
	return m.clearedlocation
}

// RemoveLocationIDs removes the "location" edge to the Location entity by IDs.
func (m *AddressMutation) RemoveLocationIDs(ids ...pulid.ID) {
	if m.removedlocation == nil {
		m.removedlocation = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.location, ids[i])
		m.removedlocation[ids[i]] = struct{}{}
	}
}

// RemovedLocation returns the removed IDs of the "location" edge to the Location entity.
func (m *AddressMutation) RemovedLocationIDs() (ids []pulid.ID) {
	for id := range m.removedlocation {
		ids = append(ids, id)
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
func (m *AddressMutation) LocationIDs() (ids []pulid.ID) {
	for id := range m.location {
		ids = append(ids, id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *AddressMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
	m.removedlocation = nil
}

// AddSenderColliIDs adds the "sender_colli" edge to the Colli entity by ids.
func (m *AddressMutation) AddSenderColliIDs(ids ...pulid.ID) {
	if m.sender_colli == nil {
		m.sender_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.sender_colli[ids[i]] = struct{}{}
	}
}

// ClearSenderColli clears the "sender_colli" edge to the Colli entity.
func (m *AddressMutation) ClearSenderColli() {
	m.clearedsender_colli = true
}

// SenderColliCleared reports if the "sender_colli" edge to the Colli entity was cleared.
func (m *AddressMutation) SenderColliCleared() bool {
	return m.clearedsender_colli
}

// RemoveSenderColliIDs removes the "sender_colli" edge to the Colli entity by IDs.
func (m *AddressMutation) RemoveSenderColliIDs(ids ...pulid.ID) {
	if m.removedsender_colli == nil {
		m.removedsender_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.sender_colli, ids[i])
		m.removedsender_colli[ids[i]] = struct{}{}
	}
}

// RemovedSenderColli returns the removed IDs of the "sender_colli" edge to the Colli entity.
func (m *AddressMutation) RemovedSenderColliIDs() (ids []pulid.ID) {
	for id := range m.removedsender_colli {
		ids = append(ids, id)
	}
	return
}

// SenderColliIDs returns the "sender_colli" edge IDs in the mutation.
func (m *AddressMutation) SenderColliIDs() (ids []pulid.ID) {
	for id := range m.sender_colli {
		ids = append(ids, id)
	}
	return
}

// ResetSenderColli resets all changes to the "sender_colli" edge.
func (m *AddressMutation) ResetSenderColli() {
	m.sender_colli = nil
	m.clearedsender_colli = false
	m.removedsender_colli = nil
}

// SetSenderConsolidationID sets the "sender_consolidation" edge to the Consolidation entity by id.
func (m *AddressMutation) SetSenderConsolidationID(id pulid.ID) {
	m.sender_consolidation = &id
}

// ClearSenderConsolidation clears the "sender_consolidation" edge to the Consolidation entity.
func (m *AddressMutation) ClearSenderConsolidation() {
	m.clearedsender_consolidation = true
}

// SenderConsolidationCleared reports if the "sender_consolidation" edge to the Consolidation entity was cleared.
func (m *AddressMutation) SenderConsolidationCleared() bool {
	return m.clearedsender_consolidation
}

// SenderConsolidationID returns the "sender_consolidation" edge ID in the mutation.
func (m *AddressMutation) SenderConsolidationID() (id pulid.ID, exists bool) {
	if m.sender_consolidation != nil {
		return *m.sender_consolidation, true
	}
	return
}

// SenderConsolidationIDs returns the "sender_consolidation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderConsolidationID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) SenderConsolidationIDs() (ids []pulid.ID) {
	if id := m.sender_consolidation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSenderConsolidation resets all changes to the "sender_consolidation" edge.
func (m *AddressMutation) ResetSenderConsolidation() {
	m.sender_consolidation = nil
	m.clearedsender_consolidation = false
}

// AddReturnSenderColliIDs adds the "return_sender_colli" edge to the ReturnColli entity by ids.
func (m *AddressMutation) AddReturnSenderColliIDs(ids ...pulid.ID) {
	if m.return_sender_colli == nil {
		m.return_sender_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_sender_colli[ids[i]] = struct{}{}
	}
}

// ClearReturnSenderColli clears the "return_sender_colli" edge to the ReturnColli entity.
func (m *AddressMutation) ClearReturnSenderColli() {
	m.clearedreturn_sender_colli = true
}

// ReturnSenderColliCleared reports if the "return_sender_colli" edge to the ReturnColli entity was cleared.
func (m *AddressMutation) ReturnSenderColliCleared() bool {
	return m.clearedreturn_sender_colli
}

// RemoveReturnSenderColliIDs removes the "return_sender_colli" edge to the ReturnColli entity by IDs.
func (m *AddressMutation) RemoveReturnSenderColliIDs(ids ...pulid.ID) {
	if m.removedreturn_sender_colli == nil {
		m.removedreturn_sender_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_sender_colli, ids[i])
		m.removedreturn_sender_colli[ids[i]] = struct{}{}
	}
}

// RemovedReturnSenderColli returns the removed IDs of the "return_sender_colli" edge to the ReturnColli entity.
func (m *AddressMutation) RemovedReturnSenderColliIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_sender_colli {
		ids = append(ids, id)
	}
	return
}

// ReturnSenderColliIDs returns the "return_sender_colli" edge IDs in the mutation.
func (m *AddressMutation) ReturnSenderColliIDs() (ids []pulid.ID) {
	for id := range m.return_sender_colli {
		ids = append(ids, id)
	}
	return
}

// ResetReturnSenderColli resets all changes to the "return_sender_colli" edge.
func (m *AddressMutation) ResetReturnSenderColli() {
	m.return_sender_colli = nil
	m.clearedreturn_sender_colli = false
	m.removedreturn_sender_colli = nil
}

// AddReturnRecipientColliIDs adds the "return_recipient_colli" edge to the ReturnColli entity by ids.
func (m *AddressMutation) AddReturnRecipientColliIDs(ids ...pulid.ID) {
	if m.return_recipient_colli == nil {
		m.return_recipient_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_recipient_colli[ids[i]] = struct{}{}
	}
}

// ClearReturnRecipientColli clears the "return_recipient_colli" edge to the ReturnColli entity.
func (m *AddressMutation) ClearReturnRecipientColli() {
	m.clearedreturn_recipient_colli = true
}

// ReturnRecipientColliCleared reports if the "return_recipient_colli" edge to the ReturnColli entity was cleared.
func (m *AddressMutation) ReturnRecipientColliCleared() bool {
	return m.clearedreturn_recipient_colli
}

// RemoveReturnRecipientColliIDs removes the "return_recipient_colli" edge to the ReturnColli entity by IDs.
func (m *AddressMutation) RemoveReturnRecipientColliIDs(ids ...pulid.ID) {
	if m.removedreturn_recipient_colli == nil {
		m.removedreturn_recipient_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_recipient_colli, ids[i])
		m.removedreturn_recipient_colli[ids[i]] = struct{}{}
	}
}

// RemovedReturnRecipientColli returns the removed IDs of the "return_recipient_colli" edge to the ReturnColli entity.
func (m *AddressMutation) RemovedReturnRecipientColliIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_recipient_colli {
		ids = append(ids, id)
	}
	return
}

// ReturnRecipientColliIDs returns the "return_recipient_colli" edge IDs in the mutation.
func (m *AddressMutation) ReturnRecipientColliIDs() (ids []pulid.ID) {
	for id := range m.return_recipient_colli {
		ids = append(ids, id)
	}
	return
}

// ResetReturnRecipientColli resets all changes to the "return_recipient_colli" edge.
func (m *AddressMutation) ResetReturnRecipientColli() {
	m.return_recipient_colli = nil
	m.clearedreturn_recipient_colli = false
	m.removedreturn_recipient_colli = nil
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *AddressMutation) SetCountryID(id pulid.ID) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *AddressMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *AddressMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *AddressMutation) CountryID() (id pulid.ID, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *AddressMutation) CountryIDs() (ids []pulid.ID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *AddressMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the AddressMutation builder.
func (m *AddressMutation) Where(ps ...predicate.Address) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddressMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddressMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Address, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddressMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddressMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Address).
func (m *AddressMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.tenant != nil {
		fields = append(fields, address.FieldTenantID)
	}
	if m.uniqueness_id != nil {
		fields = append(fields, address.FieldUniquenessID)
	}
	if m.first_name != nil {
		fields = append(fields, address.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, address.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, address.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, address.FieldPhoneNumber)
	}
	if m.phone_number_2 != nil {
		fields = append(fields, address.FieldPhoneNumber2)
	}
	if m.vat_number != nil {
		fields = append(fields, address.FieldVatNumber)
	}
	if m.company != nil {
		fields = append(fields, address.FieldCompany)
	}
	if m.address_one != nil {
		fields = append(fields, address.FieldAddressOne)
	}
	if m.address_two != nil {
		fields = append(fields, address.FieldAddressTwo)
	}
	if m.city != nil {
		fields = append(fields, address.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, address.FieldState)
	}
	if m.zip != nil {
		fields = append(fields, address.FieldZip)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case address.FieldTenantID:
		return m.TenantID()
	case address.FieldUniquenessID:
		return m.UniquenessID()
	case address.FieldFirstName:
		return m.FirstName()
	case address.FieldLastName:
		return m.LastName()
	case address.FieldEmail:
		return m.Email()
	case address.FieldPhoneNumber:
		return m.PhoneNumber()
	case address.FieldPhoneNumber2:
		return m.PhoneNumber2()
	case address.FieldVatNumber:
		return m.VatNumber()
	case address.FieldCompany:
		return m.Company()
	case address.FieldAddressOne:
		return m.AddressOne()
	case address.FieldAddressTwo:
		return m.AddressTwo()
	case address.FieldCity:
		return m.City()
	case address.FieldState:
		return m.State()
	case address.FieldZip:
		return m.Zip()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case address.FieldTenantID:
		return m.OldTenantID(ctx)
	case address.FieldUniquenessID:
		return m.OldUniquenessID(ctx)
	case address.FieldFirstName:
		return m.OldFirstName(ctx)
	case address.FieldLastName:
		return m.OldLastName(ctx)
	case address.FieldEmail:
		return m.OldEmail(ctx)
	case address.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case address.FieldPhoneNumber2:
		return m.OldPhoneNumber2(ctx)
	case address.FieldVatNumber:
		return m.OldVatNumber(ctx)
	case address.FieldCompany:
		return m.OldCompany(ctx)
	case address.FieldAddressOne:
		return m.OldAddressOne(ctx)
	case address.FieldAddressTwo:
		return m.OldAddressTwo(ctx)
	case address.FieldCity:
		return m.OldCity(ctx)
	case address.FieldState:
		return m.OldState(ctx)
	case address.FieldZip:
		return m.OldZip(ctx)
	}
	return nil, fmt.Errorf("unknown Address field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) SetField(name string, value ent.Value) error {
	switch name {
	case address.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case address.FieldUniquenessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniquenessID(v)
		return nil
	case address.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case address.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case address.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case address.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case address.FieldPhoneNumber2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber2(v)
		return nil
	case address.FieldVatNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatNumber(v)
		return nil
	case address.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case address.FieldAddressOne:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressOne(v)
		return nil
	case address.FieldAddressTwo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressTwo(v)
		return nil
	case address.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case address.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case address.FieldZip:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZip(v)
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Address numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(address.FieldUniquenessID) {
		fields = append(fields, address.FieldUniquenessID)
	}
	if m.FieldCleared(address.FieldPhoneNumber2) {
		fields = append(fields, address.FieldPhoneNumber2)
	}
	if m.FieldCleared(address.FieldVatNumber) {
		fields = append(fields, address.FieldVatNumber)
	}
	if m.FieldCleared(address.FieldCompany) {
		fields = append(fields, address.FieldCompany)
	}
	if m.FieldCleared(address.FieldState) {
		fields = append(fields, address.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressMutation) ClearField(name string) error {
	switch name {
	case address.FieldUniquenessID:
		m.ClearUniquenessID()
		return nil
	case address.FieldPhoneNumber2:
		m.ClearPhoneNumber2()
		return nil
	case address.FieldVatNumber:
		m.ClearVatNumber()
		return nil
	case address.FieldCompany:
		m.ClearCompany()
		return nil
	case address.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown Address nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressMutation) ResetField(name string) error {
	switch name {
	case address.FieldTenantID:
		m.ResetTenantID()
		return nil
	case address.FieldUniquenessID:
		m.ResetUniquenessID()
		return nil
	case address.FieldFirstName:
		m.ResetFirstName()
		return nil
	case address.FieldLastName:
		m.ResetLastName()
		return nil
	case address.FieldEmail:
		m.ResetEmail()
		return nil
	case address.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case address.FieldPhoneNumber2:
		m.ResetPhoneNumber2()
		return nil
	case address.FieldVatNumber:
		m.ResetVatNumber()
		return nil
	case address.FieldCompany:
		m.ResetCompany()
		return nil
	case address.FieldAddressOne:
		m.ResetAddressOne()
		return nil
	case address.FieldAddressTwo:
		m.ResetAddressTwo()
		return nil
	case address.FieldCity:
		m.ResetCity()
		return nil
	case address.FieldState:
		m.ResetState()
		return nil
	case address.FieldZip:
		m.ResetZip()
		return nil
	}
	return fmt.Errorf("unknown Address field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.tenant != nil {
		edges = append(edges, address.EdgeTenant)
	}
	if m.recipient_colli != nil {
		edges = append(edges, address.EdgeRecipientColli)
	}
	if m.recipient_consolidation != nil {
		edges = append(edges, address.EdgeRecipientConsolidation)
	}
	if m.company_address != nil {
		edges = append(edges, address.EdgeCompanyAddress)
	}
	if m.location != nil {
		edges = append(edges, address.EdgeLocation)
	}
	if m.sender_colli != nil {
		edges = append(edges, address.EdgeSenderColli)
	}
	if m.sender_consolidation != nil {
		edges = append(edges, address.EdgeSenderConsolidation)
	}
	if m.return_sender_colli != nil {
		edges = append(edges, address.EdgeReturnSenderColli)
	}
	if m.return_recipient_colli != nil {
		edges = append(edges, address.EdgeReturnRecipientColli)
	}
	if m.country != nil {
		edges = append(edges, address.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeRecipientColli:
		ids := make([]ent.Value, 0, len(m.recipient_colli))
		for id := range m.recipient_colli {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeRecipientConsolidation:
		if id := m.recipient_consolidation; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeCompanyAddress:
		ids := make([]ent.Value, 0, len(m.company_address))
		for id := range m.company_address {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeLocation:
		ids := make([]ent.Value, 0, len(m.location))
		for id := range m.location {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeSenderColli:
		ids := make([]ent.Value, 0, len(m.sender_colli))
		for id := range m.sender_colli {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeSenderConsolidation:
		if id := m.sender_consolidation; id != nil {
			return []ent.Value{*id}
		}
	case address.EdgeReturnSenderColli:
		ids := make([]ent.Value, 0, len(m.return_sender_colli))
		for id := range m.return_sender_colli {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeReturnRecipientColli:
		ids := make([]ent.Value, 0, len(m.return_recipient_colli))
		for id := range m.return_recipient_colli {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedrecipient_colli != nil {
		edges = append(edges, address.EdgeRecipientColli)
	}
	if m.removedcompany_address != nil {
		edges = append(edges, address.EdgeCompanyAddress)
	}
	if m.removedlocation != nil {
		edges = append(edges, address.EdgeLocation)
	}
	if m.removedsender_colli != nil {
		edges = append(edges, address.EdgeSenderColli)
	}
	if m.removedreturn_sender_colli != nil {
		edges = append(edges, address.EdgeReturnSenderColli)
	}
	if m.removedreturn_recipient_colli != nil {
		edges = append(edges, address.EdgeReturnRecipientColli)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case address.EdgeRecipientColli:
		ids := make([]ent.Value, 0, len(m.removedrecipient_colli))
		for id := range m.removedrecipient_colli {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeCompanyAddress:
		ids := make([]ent.Value, 0, len(m.removedcompany_address))
		for id := range m.removedcompany_address {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeLocation:
		ids := make([]ent.Value, 0, len(m.removedlocation))
		for id := range m.removedlocation {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeSenderColli:
		ids := make([]ent.Value, 0, len(m.removedsender_colli))
		for id := range m.removedsender_colli {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeReturnSenderColli:
		ids := make([]ent.Value, 0, len(m.removedreturn_sender_colli))
		for id := range m.removedreturn_sender_colli {
			ids = append(ids, id)
		}
		return ids
	case address.EdgeReturnRecipientColli:
		ids := make([]ent.Value, 0, len(m.removedreturn_recipient_colli))
		for id := range m.removedreturn_recipient_colli {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedtenant {
		edges = append(edges, address.EdgeTenant)
	}
	if m.clearedrecipient_colli {
		edges = append(edges, address.EdgeRecipientColli)
	}
	if m.clearedrecipient_consolidation {
		edges = append(edges, address.EdgeRecipientConsolidation)
	}
	if m.clearedcompany_address {
		edges = append(edges, address.EdgeCompanyAddress)
	}
	if m.clearedlocation {
		edges = append(edges, address.EdgeLocation)
	}
	if m.clearedsender_colli {
		edges = append(edges, address.EdgeSenderColli)
	}
	if m.clearedsender_consolidation {
		edges = append(edges, address.EdgeSenderConsolidation)
	}
	if m.clearedreturn_sender_colli {
		edges = append(edges, address.EdgeReturnSenderColli)
	}
	if m.clearedreturn_recipient_colli {
		edges = append(edges, address.EdgeReturnRecipientColli)
	}
	if m.clearedcountry {
		edges = append(edges, address.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressMutation) EdgeCleared(name string) bool {
	switch name {
	case address.EdgeTenant:
		return m.clearedtenant
	case address.EdgeRecipientColli:
		return m.clearedrecipient_colli
	case address.EdgeRecipientConsolidation:
		return m.clearedrecipient_consolidation
	case address.EdgeCompanyAddress:
		return m.clearedcompany_address
	case address.EdgeLocation:
		return m.clearedlocation
	case address.EdgeSenderColli:
		return m.clearedsender_colli
	case address.EdgeSenderConsolidation:
		return m.clearedsender_consolidation
	case address.EdgeReturnSenderColli:
		return m.clearedreturn_sender_colli
	case address.EdgeReturnRecipientColli:
		return m.clearedreturn_recipient_colli
	case address.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressMutation) ClearEdge(name string) error {
	switch name {
	case address.EdgeTenant:
		m.ClearTenant()
		return nil
	case address.EdgeRecipientConsolidation:
		m.ClearRecipientConsolidation()
		return nil
	case address.EdgeSenderConsolidation:
		m.ClearSenderConsolidation()
		return nil
	case address.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown Address unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressMutation) ResetEdge(name string) error {
	switch name {
	case address.EdgeTenant:
		m.ResetTenant()
		return nil
	case address.EdgeRecipientColli:
		m.ResetRecipientColli()
		return nil
	case address.EdgeRecipientConsolidation:
		m.ResetRecipientConsolidation()
		return nil
	case address.EdgeCompanyAddress:
		m.ResetCompanyAddress()
		return nil
	case address.EdgeLocation:
		m.ResetLocation()
		return nil
	case address.EdgeSenderColli:
		m.ResetSenderColli()
		return nil
	case address.EdgeSenderConsolidation:
		m.ResetSenderConsolidation()
		return nil
	case address.EdgeReturnSenderColli:
		m.ResetReturnSenderColli()
		return nil
	case address.EdgeReturnRecipientColli:
		m.ResetReturnRecipientColli()
		return nil
	case address.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown Address edge %s", name)
}

// AddressGlobalMutation represents an operation that mutates the AddressGlobal nodes in the graph.
type AddressGlobalMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *pulid.ID
	uniqueness_id                         *string
	company                               *string
	address_one                           *string
	address_two                           *string
	city                                  *string
	state                                 *string
	zip                                   *string
	latitude                              *float64
	addlatitude                           *float64
	longitude                             *float64
	addlongitude                          *float64
	clearedFields                         map[string]struct{}
	parcel_shop_post_nord_delivery        *pulid.ID
	clearedparcel_shop_post_nord_delivery bool
	parcel_shop_bring_delivery            *pulid.ID
	clearedparcel_shop_bring_delivery     bool
	parcel_shop                           *pulid.ID
	clearedparcel_shop                    bool
	country                               *pulid.ID
	clearedcountry                        bool
	done                                  bool
	oldValue                              func(context.Context) (*AddressGlobal, error)
	predicates                            []predicate.AddressGlobal
}

var _ ent.Mutation = (*AddressGlobalMutation)(nil)

// addressglobalOption allows management of the mutation configuration using functional options.
type addressglobalOption func(*AddressGlobalMutation)

// newAddressGlobalMutation creates new mutation for the AddressGlobal entity.
func newAddressGlobalMutation(c config, op Op, opts ...addressglobalOption) *AddressGlobalMutation {
	m := &AddressGlobalMutation{
		config:        c,
		op:            op,
		typ:           TypeAddressGlobal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAddressGlobalID sets the ID field of the mutation.
func withAddressGlobalID(id pulid.ID) addressglobalOption {
	return func(m *AddressGlobalMutation) {
		var (
			err   error
			once  sync.Once
			value *AddressGlobal
		)
		m.oldValue = func(ctx context.Context) (*AddressGlobal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AddressGlobal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAddressGlobal sets the old AddressGlobal of the mutation.
func withAddressGlobal(node *AddressGlobal) addressglobalOption {
	return func(m *AddressGlobalMutation) {
		m.oldValue = func(context.Context) (*AddressGlobal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AddressGlobalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AddressGlobalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AddressGlobal entities.
func (m *AddressGlobalMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AddressGlobalMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AddressGlobalMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AddressGlobal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetUniquenessID sets the "uniqueness_id" field.
func (m *AddressGlobalMutation) SetUniquenessID(s string) {
	m.uniqueness_id = &s
}

// UniquenessID returns the value of the "uniqueness_id" field in the mutation.
func (m *AddressGlobalMutation) UniquenessID() (r string, exists bool) {
	v := m.uniqueness_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUniquenessID returns the old "uniqueness_id" field's value of the AddressGlobal entity.
// If the AddressGlobal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressGlobalMutation) OldUniquenessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniquenessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniquenessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniquenessID: %w", err)
	}
	return oldValue.UniquenessID, nil
}

// ClearUniquenessID clears the value of the "uniqueness_id" field.
func (m *AddressGlobalMutation) ClearUniquenessID() {
	m.uniqueness_id = nil
	m.clearedFields[addressglobal.FieldUniquenessID] = struct{}{}
}

// UniquenessIDCleared returns if the "uniqueness_id" field was cleared in this mutation.
func (m *AddressGlobalMutation) UniquenessIDCleared() bool {
	_, ok := m.clearedFields[addressglobal.FieldUniquenessID]
	return ok
}

// ResetUniquenessID resets all changes to the "uniqueness_id" field.
func (m *AddressGlobalMutation) ResetUniquenessID() {
	m.uniqueness_id = nil
	delete(m.clearedFields, addressglobal.FieldUniquenessID)
}

// SetCompany sets the "company" field.
func (m *AddressGlobalMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *AddressGlobalMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the AddressGlobal entity.
// If the AddressGlobal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressGlobalMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *AddressGlobalMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[addressglobal.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *AddressGlobalMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[addressglobal.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *AddressGlobalMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, addressglobal.FieldCompany)
}

// SetAddressOne sets the "address_one" field.
func (m *AddressGlobalMutation) SetAddressOne(s string) {
	m.address_one = &s
}

// AddressOne returns the value of the "address_one" field in the mutation.
func (m *AddressGlobalMutation) AddressOne() (r string, exists bool) {
	v := m.address_one
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressOne returns the old "address_one" field's value of the AddressGlobal entity.
// If the AddressGlobal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressGlobalMutation) OldAddressOne(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressOne is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressOne requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressOne: %w", err)
	}
	return oldValue.AddressOne, nil
}

// ResetAddressOne resets all changes to the "address_one" field.
func (m *AddressGlobalMutation) ResetAddressOne() {
	m.address_one = nil
}

// SetAddressTwo sets the "address_two" field.
func (m *AddressGlobalMutation) SetAddressTwo(s string) {
	m.address_two = &s
}

// AddressTwo returns the value of the "address_two" field in the mutation.
func (m *AddressGlobalMutation) AddressTwo() (r string, exists bool) {
	v := m.address_two
	if v == nil {
		return
	}
	return *v, true
}

// OldAddressTwo returns the old "address_two" field's value of the AddressGlobal entity.
// If the AddressGlobal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressGlobalMutation) OldAddressTwo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddressTwo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddressTwo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddressTwo: %w", err)
	}
	return oldValue.AddressTwo, nil
}

// ClearAddressTwo clears the value of the "address_two" field.
func (m *AddressGlobalMutation) ClearAddressTwo() {
	m.address_two = nil
	m.clearedFields[addressglobal.FieldAddressTwo] = struct{}{}
}

// AddressTwoCleared returns if the "address_two" field was cleared in this mutation.
func (m *AddressGlobalMutation) AddressTwoCleared() bool {
	_, ok := m.clearedFields[addressglobal.FieldAddressTwo]
	return ok
}

// ResetAddressTwo resets all changes to the "address_two" field.
func (m *AddressGlobalMutation) ResetAddressTwo() {
	m.address_two = nil
	delete(m.clearedFields, addressglobal.FieldAddressTwo)
}

// SetCity sets the "city" field.
func (m *AddressGlobalMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *AddressGlobalMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the AddressGlobal entity.
// If the AddressGlobal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressGlobalMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *AddressGlobalMutation) ResetCity() {
	m.city = nil
}

// SetState sets the "state" field.
func (m *AddressGlobalMutation) SetState(s string) {
	m.state = &s
}

// State returns the value of the "state" field in the mutation.
func (m *AddressGlobalMutation) State() (r string, exists bool) {
	v := m.state
	if v == nil {
		return
	}
	return *v, true
}

// OldState returns the old "state" field's value of the AddressGlobal entity.
// If the AddressGlobal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressGlobalMutation) OldState(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldState is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldState requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldState: %w", err)
	}
	return oldValue.State, nil
}

// ClearState clears the value of the "state" field.
func (m *AddressGlobalMutation) ClearState() {
	m.state = nil
	m.clearedFields[addressglobal.FieldState] = struct{}{}
}

// StateCleared returns if the "state" field was cleared in this mutation.
func (m *AddressGlobalMutation) StateCleared() bool {
	_, ok := m.clearedFields[addressglobal.FieldState]
	return ok
}

// ResetState resets all changes to the "state" field.
func (m *AddressGlobalMutation) ResetState() {
	m.state = nil
	delete(m.clearedFields, addressglobal.FieldState)
}

// SetZip sets the "zip" field.
func (m *AddressGlobalMutation) SetZip(s string) {
	m.zip = &s
}

// Zip returns the value of the "zip" field in the mutation.
func (m *AddressGlobalMutation) Zip() (r string, exists bool) {
	v := m.zip
	if v == nil {
		return
	}
	return *v, true
}

// OldZip returns the old "zip" field's value of the AddressGlobal entity.
// If the AddressGlobal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressGlobalMutation) OldZip(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldZip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldZip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldZip: %w", err)
	}
	return oldValue.Zip, nil
}

// ResetZip resets all changes to the "zip" field.
func (m *AddressGlobalMutation) ResetZip() {
	m.zip = nil
}

// SetLatitude sets the "latitude" field.
func (m *AddressGlobalMutation) SetLatitude(f float64) {
	m.latitude = &f
	m.addlatitude = nil
}

// Latitude returns the value of the "latitude" field in the mutation.
func (m *AddressGlobalMutation) Latitude() (r float64, exists bool) {
	v := m.latitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLatitude returns the old "latitude" field's value of the AddressGlobal entity.
// If the AddressGlobal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressGlobalMutation) OldLatitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLatitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLatitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLatitude: %w", err)
	}
	return oldValue.Latitude, nil
}

// AddLatitude adds f to the "latitude" field.
func (m *AddressGlobalMutation) AddLatitude(f float64) {
	if m.addlatitude != nil {
		*m.addlatitude += f
	} else {
		m.addlatitude = &f
	}
}

// AddedLatitude returns the value that was added to the "latitude" field in this mutation.
func (m *AddressGlobalMutation) AddedLatitude() (r float64, exists bool) {
	v := m.addlatitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLatitude resets all changes to the "latitude" field.
func (m *AddressGlobalMutation) ResetLatitude() {
	m.latitude = nil
	m.addlatitude = nil
}

// SetLongitude sets the "longitude" field.
func (m *AddressGlobalMutation) SetLongitude(f float64) {
	m.longitude = &f
	m.addlongitude = nil
}

// Longitude returns the value of the "longitude" field in the mutation.
func (m *AddressGlobalMutation) Longitude() (r float64, exists bool) {
	v := m.longitude
	if v == nil {
		return
	}
	return *v, true
}

// OldLongitude returns the old "longitude" field's value of the AddressGlobal entity.
// If the AddressGlobal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AddressGlobalMutation) OldLongitude(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLongitude is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLongitude requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLongitude: %w", err)
	}
	return oldValue.Longitude, nil
}

// AddLongitude adds f to the "longitude" field.
func (m *AddressGlobalMutation) AddLongitude(f float64) {
	if m.addlongitude != nil {
		*m.addlongitude += f
	} else {
		m.addlongitude = &f
	}
}

// AddedLongitude returns the value that was added to the "longitude" field in this mutation.
func (m *AddressGlobalMutation) AddedLongitude() (r float64, exists bool) {
	v := m.addlongitude
	if v == nil {
		return
	}
	return *v, true
}

// ResetLongitude resets all changes to the "longitude" field.
func (m *AddressGlobalMutation) ResetLongitude() {
	m.longitude = nil
	m.addlongitude = nil
}

// SetParcelShopPostNordDeliveryID sets the "parcel_shop_post_nord_delivery" edge to the ParcelShopPostNord entity by id.
func (m *AddressGlobalMutation) SetParcelShopPostNordDeliveryID(id pulid.ID) {
	m.parcel_shop_post_nord_delivery = &id
}

// ClearParcelShopPostNordDelivery clears the "parcel_shop_post_nord_delivery" edge to the ParcelShopPostNord entity.
func (m *AddressGlobalMutation) ClearParcelShopPostNordDelivery() {
	m.clearedparcel_shop_post_nord_delivery = true
}

// ParcelShopPostNordDeliveryCleared reports if the "parcel_shop_post_nord_delivery" edge to the ParcelShopPostNord entity was cleared.
func (m *AddressGlobalMutation) ParcelShopPostNordDeliveryCleared() bool {
	return m.clearedparcel_shop_post_nord_delivery
}

// ParcelShopPostNordDeliveryID returns the "parcel_shop_post_nord_delivery" edge ID in the mutation.
func (m *AddressGlobalMutation) ParcelShopPostNordDeliveryID() (id pulid.ID, exists bool) {
	if m.parcel_shop_post_nord_delivery != nil {
		return *m.parcel_shop_post_nord_delivery, true
	}
	return
}

// ParcelShopPostNordDeliveryIDs returns the "parcel_shop_post_nord_delivery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopPostNordDeliveryID instead. It exists only for internal usage by the builders.
func (m *AddressGlobalMutation) ParcelShopPostNordDeliveryIDs() (ids []pulid.ID) {
	if id := m.parcel_shop_post_nord_delivery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShopPostNordDelivery resets all changes to the "parcel_shop_post_nord_delivery" edge.
func (m *AddressGlobalMutation) ResetParcelShopPostNordDelivery() {
	m.parcel_shop_post_nord_delivery = nil
	m.clearedparcel_shop_post_nord_delivery = false
}

// SetParcelShopBringDeliveryID sets the "parcel_shop_bring_delivery" edge to the ParcelShopBring entity by id.
func (m *AddressGlobalMutation) SetParcelShopBringDeliveryID(id pulid.ID) {
	m.parcel_shop_bring_delivery = &id
}

// ClearParcelShopBringDelivery clears the "parcel_shop_bring_delivery" edge to the ParcelShopBring entity.
func (m *AddressGlobalMutation) ClearParcelShopBringDelivery() {
	m.clearedparcel_shop_bring_delivery = true
}

// ParcelShopBringDeliveryCleared reports if the "parcel_shop_bring_delivery" edge to the ParcelShopBring entity was cleared.
func (m *AddressGlobalMutation) ParcelShopBringDeliveryCleared() bool {
	return m.clearedparcel_shop_bring_delivery
}

// ParcelShopBringDeliveryID returns the "parcel_shop_bring_delivery" edge ID in the mutation.
func (m *AddressGlobalMutation) ParcelShopBringDeliveryID() (id pulid.ID, exists bool) {
	if m.parcel_shop_bring_delivery != nil {
		return *m.parcel_shop_bring_delivery, true
	}
	return
}

// ParcelShopBringDeliveryIDs returns the "parcel_shop_bring_delivery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopBringDeliveryID instead. It exists only for internal usage by the builders.
func (m *AddressGlobalMutation) ParcelShopBringDeliveryIDs() (ids []pulid.ID) {
	if id := m.parcel_shop_bring_delivery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShopBringDelivery resets all changes to the "parcel_shop_bring_delivery" edge.
func (m *AddressGlobalMutation) ResetParcelShopBringDelivery() {
	m.parcel_shop_bring_delivery = nil
	m.clearedparcel_shop_bring_delivery = false
}

// SetParcelShopID sets the "parcel_shop" edge to the ParcelShop entity by id.
func (m *AddressGlobalMutation) SetParcelShopID(id pulid.ID) {
	m.parcel_shop = &id
}

// ClearParcelShop clears the "parcel_shop" edge to the ParcelShop entity.
func (m *AddressGlobalMutation) ClearParcelShop() {
	m.clearedparcel_shop = true
}

// ParcelShopCleared reports if the "parcel_shop" edge to the ParcelShop entity was cleared.
func (m *AddressGlobalMutation) ParcelShopCleared() bool {
	return m.clearedparcel_shop
}

// ParcelShopID returns the "parcel_shop" edge ID in the mutation.
func (m *AddressGlobalMutation) ParcelShopID() (id pulid.ID, exists bool) {
	if m.parcel_shop != nil {
		return *m.parcel_shop, true
	}
	return
}

// ParcelShopIDs returns the "parcel_shop" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopID instead. It exists only for internal usage by the builders.
func (m *AddressGlobalMutation) ParcelShopIDs() (ids []pulid.ID) {
	if id := m.parcel_shop; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShop resets all changes to the "parcel_shop" edge.
func (m *AddressGlobalMutation) ResetParcelShop() {
	m.parcel_shop = nil
	m.clearedparcel_shop = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *AddressGlobalMutation) SetCountryID(id pulid.ID) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *AddressGlobalMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *AddressGlobalMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *AddressGlobalMutation) CountryID() (id pulid.ID, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *AddressGlobalMutation) CountryIDs() (ids []pulid.ID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *AddressGlobalMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the AddressGlobalMutation builder.
func (m *AddressGlobalMutation) Where(ps ...predicate.AddressGlobal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AddressGlobalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AddressGlobalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AddressGlobal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AddressGlobalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AddressGlobalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AddressGlobal).
func (m *AddressGlobalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AddressGlobalMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.uniqueness_id != nil {
		fields = append(fields, addressglobal.FieldUniquenessID)
	}
	if m.company != nil {
		fields = append(fields, addressglobal.FieldCompany)
	}
	if m.address_one != nil {
		fields = append(fields, addressglobal.FieldAddressOne)
	}
	if m.address_two != nil {
		fields = append(fields, addressglobal.FieldAddressTwo)
	}
	if m.city != nil {
		fields = append(fields, addressglobal.FieldCity)
	}
	if m.state != nil {
		fields = append(fields, addressglobal.FieldState)
	}
	if m.zip != nil {
		fields = append(fields, addressglobal.FieldZip)
	}
	if m.latitude != nil {
		fields = append(fields, addressglobal.FieldLatitude)
	}
	if m.longitude != nil {
		fields = append(fields, addressglobal.FieldLongitude)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AddressGlobalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case addressglobal.FieldUniquenessID:
		return m.UniquenessID()
	case addressglobal.FieldCompany:
		return m.Company()
	case addressglobal.FieldAddressOne:
		return m.AddressOne()
	case addressglobal.FieldAddressTwo:
		return m.AddressTwo()
	case addressglobal.FieldCity:
		return m.City()
	case addressglobal.FieldState:
		return m.State()
	case addressglobal.FieldZip:
		return m.Zip()
	case addressglobal.FieldLatitude:
		return m.Latitude()
	case addressglobal.FieldLongitude:
		return m.Longitude()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AddressGlobalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case addressglobal.FieldUniquenessID:
		return m.OldUniquenessID(ctx)
	case addressglobal.FieldCompany:
		return m.OldCompany(ctx)
	case addressglobal.FieldAddressOne:
		return m.OldAddressOne(ctx)
	case addressglobal.FieldAddressTwo:
		return m.OldAddressTwo(ctx)
	case addressglobal.FieldCity:
		return m.OldCity(ctx)
	case addressglobal.FieldState:
		return m.OldState(ctx)
	case addressglobal.FieldZip:
		return m.OldZip(ctx)
	case addressglobal.FieldLatitude:
		return m.OldLatitude(ctx)
	case addressglobal.FieldLongitude:
		return m.OldLongitude(ctx)
	}
	return nil, fmt.Errorf("unknown AddressGlobal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressGlobalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case addressglobal.FieldUniquenessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniquenessID(v)
		return nil
	case addressglobal.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case addressglobal.FieldAddressOne:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressOne(v)
		return nil
	case addressglobal.FieldAddressTwo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddressTwo(v)
		return nil
	case addressglobal.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case addressglobal.FieldState:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetState(v)
		return nil
	case addressglobal.FieldZip:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetZip(v)
		return nil
	case addressglobal.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLatitude(v)
		return nil
	case addressglobal.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown AddressGlobal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AddressGlobalMutation) AddedFields() []string {
	var fields []string
	if m.addlatitude != nil {
		fields = append(fields, addressglobal.FieldLatitude)
	}
	if m.addlongitude != nil {
		fields = append(fields, addressglobal.FieldLongitude)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AddressGlobalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case addressglobal.FieldLatitude:
		return m.AddedLatitude()
	case addressglobal.FieldLongitude:
		return m.AddedLongitude()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AddressGlobalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case addressglobal.FieldLatitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLatitude(v)
		return nil
	case addressglobal.FieldLongitude:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLongitude(v)
		return nil
	}
	return fmt.Errorf("unknown AddressGlobal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AddressGlobalMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(addressglobal.FieldUniquenessID) {
		fields = append(fields, addressglobal.FieldUniquenessID)
	}
	if m.FieldCleared(addressglobal.FieldCompany) {
		fields = append(fields, addressglobal.FieldCompany)
	}
	if m.FieldCleared(addressglobal.FieldAddressTwo) {
		fields = append(fields, addressglobal.FieldAddressTwo)
	}
	if m.FieldCleared(addressglobal.FieldState) {
		fields = append(fields, addressglobal.FieldState)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AddressGlobalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AddressGlobalMutation) ClearField(name string) error {
	switch name {
	case addressglobal.FieldUniquenessID:
		m.ClearUniquenessID()
		return nil
	case addressglobal.FieldCompany:
		m.ClearCompany()
		return nil
	case addressglobal.FieldAddressTwo:
		m.ClearAddressTwo()
		return nil
	case addressglobal.FieldState:
		m.ClearState()
		return nil
	}
	return fmt.Errorf("unknown AddressGlobal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AddressGlobalMutation) ResetField(name string) error {
	switch name {
	case addressglobal.FieldUniquenessID:
		m.ResetUniquenessID()
		return nil
	case addressglobal.FieldCompany:
		m.ResetCompany()
		return nil
	case addressglobal.FieldAddressOne:
		m.ResetAddressOne()
		return nil
	case addressglobal.FieldAddressTwo:
		m.ResetAddressTwo()
		return nil
	case addressglobal.FieldCity:
		m.ResetCity()
		return nil
	case addressglobal.FieldState:
		m.ResetState()
		return nil
	case addressglobal.FieldZip:
		m.ResetZip()
		return nil
	case addressglobal.FieldLatitude:
		m.ResetLatitude()
		return nil
	case addressglobal.FieldLongitude:
		m.ResetLongitude()
		return nil
	}
	return fmt.Errorf("unknown AddressGlobal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AddressGlobalMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parcel_shop_post_nord_delivery != nil {
		edges = append(edges, addressglobal.EdgeParcelShopPostNordDelivery)
	}
	if m.parcel_shop_bring_delivery != nil {
		edges = append(edges, addressglobal.EdgeParcelShopBringDelivery)
	}
	if m.parcel_shop != nil {
		edges = append(edges, addressglobal.EdgeParcelShop)
	}
	if m.country != nil {
		edges = append(edges, addressglobal.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AddressGlobalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case addressglobal.EdgeParcelShopPostNordDelivery:
		if id := m.parcel_shop_post_nord_delivery; id != nil {
			return []ent.Value{*id}
		}
	case addressglobal.EdgeParcelShopBringDelivery:
		if id := m.parcel_shop_bring_delivery; id != nil {
			return []ent.Value{*id}
		}
	case addressglobal.EdgeParcelShop:
		if id := m.parcel_shop; id != nil {
			return []ent.Value{*id}
		}
	case addressglobal.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AddressGlobalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AddressGlobalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AddressGlobalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparcel_shop_post_nord_delivery {
		edges = append(edges, addressglobal.EdgeParcelShopPostNordDelivery)
	}
	if m.clearedparcel_shop_bring_delivery {
		edges = append(edges, addressglobal.EdgeParcelShopBringDelivery)
	}
	if m.clearedparcel_shop {
		edges = append(edges, addressglobal.EdgeParcelShop)
	}
	if m.clearedcountry {
		edges = append(edges, addressglobal.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AddressGlobalMutation) EdgeCleared(name string) bool {
	switch name {
	case addressglobal.EdgeParcelShopPostNordDelivery:
		return m.clearedparcel_shop_post_nord_delivery
	case addressglobal.EdgeParcelShopBringDelivery:
		return m.clearedparcel_shop_bring_delivery
	case addressglobal.EdgeParcelShop:
		return m.clearedparcel_shop
	case addressglobal.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AddressGlobalMutation) ClearEdge(name string) error {
	switch name {
	case addressglobal.EdgeParcelShopPostNordDelivery:
		m.ClearParcelShopPostNordDelivery()
		return nil
	case addressglobal.EdgeParcelShopBringDelivery:
		m.ClearParcelShopBringDelivery()
		return nil
	case addressglobal.EdgeParcelShop:
		m.ClearParcelShop()
		return nil
	case addressglobal.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown AddressGlobal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AddressGlobalMutation) ResetEdge(name string) error {
	switch name {
	case addressglobal.EdgeParcelShopPostNordDelivery:
		m.ResetParcelShopPostNordDelivery()
		return nil
	case addressglobal.EdgeParcelShopBringDelivery:
		m.ResetParcelShopBringDelivery()
		return nil
	case addressglobal.EdgeParcelShop:
		m.ResetParcelShop()
		return nil
	case addressglobal.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown AddressGlobal edge %s", name)
}

// BusinessHoursPeriodMutation represents an operation that mutates the BusinessHoursPeriod nodes in the graph.
type BusinessHoursPeriodMutation struct {
	config
	op                 Op
	typ                string
	id                 *pulid.ID
	day_of_week        *businesshoursperiod.DayOfWeek
	opening            *time.Time
	closing            *time.Time
	clearedFields      map[string]struct{}
	parcel_shop        *pulid.ID
	clearedparcel_shop bool
	done               bool
	oldValue           func(context.Context) (*BusinessHoursPeriod, error)
	predicates         []predicate.BusinessHoursPeriod
}

var _ ent.Mutation = (*BusinessHoursPeriodMutation)(nil)

// businesshoursperiodOption allows management of the mutation configuration using functional options.
type businesshoursperiodOption func(*BusinessHoursPeriodMutation)

// newBusinessHoursPeriodMutation creates new mutation for the BusinessHoursPeriod entity.
func newBusinessHoursPeriodMutation(c config, op Op, opts ...businesshoursperiodOption) *BusinessHoursPeriodMutation {
	m := &BusinessHoursPeriodMutation{
		config:        c,
		op:            op,
		typ:           TypeBusinessHoursPeriod,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBusinessHoursPeriodID sets the ID field of the mutation.
func withBusinessHoursPeriodID(id pulid.ID) businesshoursperiodOption {
	return func(m *BusinessHoursPeriodMutation) {
		var (
			err   error
			once  sync.Once
			value *BusinessHoursPeriod
		)
		m.oldValue = func(ctx context.Context) (*BusinessHoursPeriod, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().BusinessHoursPeriod.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBusinessHoursPeriod sets the old BusinessHoursPeriod of the mutation.
func withBusinessHoursPeriod(node *BusinessHoursPeriod) businesshoursperiodOption {
	return func(m *BusinessHoursPeriodMutation) {
		m.oldValue = func(context.Context) (*BusinessHoursPeriod, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BusinessHoursPeriodMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BusinessHoursPeriodMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of BusinessHoursPeriod entities.
func (m *BusinessHoursPeriodMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *BusinessHoursPeriodMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *BusinessHoursPeriodMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().BusinessHoursPeriod.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDayOfWeek sets the "day_of_week" field.
func (m *BusinessHoursPeriodMutation) SetDayOfWeek(bow businesshoursperiod.DayOfWeek) {
	m.day_of_week = &bow
}

// DayOfWeek returns the value of the "day_of_week" field in the mutation.
func (m *BusinessHoursPeriodMutation) DayOfWeek() (r businesshoursperiod.DayOfWeek, exists bool) {
	v := m.day_of_week
	if v == nil {
		return
	}
	return *v, true
}

// OldDayOfWeek returns the old "day_of_week" field's value of the BusinessHoursPeriod entity.
// If the BusinessHoursPeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessHoursPeriodMutation) OldDayOfWeek(ctx context.Context) (v businesshoursperiod.DayOfWeek, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDayOfWeek is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDayOfWeek requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDayOfWeek: %w", err)
	}
	return oldValue.DayOfWeek, nil
}

// ResetDayOfWeek resets all changes to the "day_of_week" field.
func (m *BusinessHoursPeriodMutation) ResetDayOfWeek() {
	m.day_of_week = nil
}

// SetOpening sets the "opening" field.
func (m *BusinessHoursPeriodMutation) SetOpening(t time.Time) {
	m.opening = &t
}

// Opening returns the value of the "opening" field in the mutation.
func (m *BusinessHoursPeriodMutation) Opening() (r time.Time, exists bool) {
	v := m.opening
	if v == nil {
		return
	}
	return *v, true
}

// OldOpening returns the old "opening" field's value of the BusinessHoursPeriod entity.
// If the BusinessHoursPeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessHoursPeriodMutation) OldOpening(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOpening is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOpening requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOpening: %w", err)
	}
	return oldValue.Opening, nil
}

// ResetOpening resets all changes to the "opening" field.
func (m *BusinessHoursPeriodMutation) ResetOpening() {
	m.opening = nil
}

// SetClosing sets the "closing" field.
func (m *BusinessHoursPeriodMutation) SetClosing(t time.Time) {
	m.closing = &t
}

// Closing returns the value of the "closing" field in the mutation.
func (m *BusinessHoursPeriodMutation) Closing() (r time.Time, exists bool) {
	v := m.closing
	if v == nil {
		return
	}
	return *v, true
}

// OldClosing returns the old "closing" field's value of the BusinessHoursPeriod entity.
// If the BusinessHoursPeriod object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *BusinessHoursPeriodMutation) OldClosing(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClosing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClosing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClosing: %w", err)
	}
	return oldValue.Closing, nil
}

// ResetClosing resets all changes to the "closing" field.
func (m *BusinessHoursPeriodMutation) ResetClosing() {
	m.closing = nil
}

// SetParcelShopID sets the "parcel_shop" edge to the ParcelShop entity by id.
func (m *BusinessHoursPeriodMutation) SetParcelShopID(id pulid.ID) {
	m.parcel_shop = &id
}

// ClearParcelShop clears the "parcel_shop" edge to the ParcelShop entity.
func (m *BusinessHoursPeriodMutation) ClearParcelShop() {
	m.clearedparcel_shop = true
}

// ParcelShopCleared reports if the "parcel_shop" edge to the ParcelShop entity was cleared.
func (m *BusinessHoursPeriodMutation) ParcelShopCleared() bool {
	return m.clearedparcel_shop
}

// ParcelShopID returns the "parcel_shop" edge ID in the mutation.
func (m *BusinessHoursPeriodMutation) ParcelShopID() (id pulid.ID, exists bool) {
	if m.parcel_shop != nil {
		return *m.parcel_shop, true
	}
	return
}

// ParcelShopIDs returns the "parcel_shop" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopID instead. It exists only for internal usage by the builders.
func (m *BusinessHoursPeriodMutation) ParcelShopIDs() (ids []pulid.ID) {
	if id := m.parcel_shop; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShop resets all changes to the "parcel_shop" edge.
func (m *BusinessHoursPeriodMutation) ResetParcelShop() {
	m.parcel_shop = nil
	m.clearedparcel_shop = false
}

// Where appends a list predicates to the BusinessHoursPeriodMutation builder.
func (m *BusinessHoursPeriodMutation) Where(ps ...predicate.BusinessHoursPeriod) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the BusinessHoursPeriodMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *BusinessHoursPeriodMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.BusinessHoursPeriod, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *BusinessHoursPeriodMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *BusinessHoursPeriodMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (BusinessHoursPeriod).
func (m *BusinessHoursPeriodMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *BusinessHoursPeriodMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.day_of_week != nil {
		fields = append(fields, businesshoursperiod.FieldDayOfWeek)
	}
	if m.opening != nil {
		fields = append(fields, businesshoursperiod.FieldOpening)
	}
	if m.closing != nil {
		fields = append(fields, businesshoursperiod.FieldClosing)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *BusinessHoursPeriodMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case businesshoursperiod.FieldDayOfWeek:
		return m.DayOfWeek()
	case businesshoursperiod.FieldOpening:
		return m.Opening()
	case businesshoursperiod.FieldClosing:
		return m.Closing()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *BusinessHoursPeriodMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case businesshoursperiod.FieldDayOfWeek:
		return m.OldDayOfWeek(ctx)
	case businesshoursperiod.FieldOpening:
		return m.OldOpening(ctx)
	case businesshoursperiod.FieldClosing:
		return m.OldClosing(ctx)
	}
	return nil, fmt.Errorf("unknown BusinessHoursPeriod field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessHoursPeriodMutation) SetField(name string, value ent.Value) error {
	switch name {
	case businesshoursperiod.FieldDayOfWeek:
		v, ok := value.(businesshoursperiod.DayOfWeek)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDayOfWeek(v)
		return nil
	case businesshoursperiod.FieldOpening:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOpening(v)
		return nil
	case businesshoursperiod.FieldClosing:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClosing(v)
		return nil
	}
	return fmt.Errorf("unknown BusinessHoursPeriod field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *BusinessHoursPeriodMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *BusinessHoursPeriodMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *BusinessHoursPeriodMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown BusinessHoursPeriod numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *BusinessHoursPeriodMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *BusinessHoursPeriodMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *BusinessHoursPeriodMutation) ClearField(name string) error {
	return fmt.Errorf("unknown BusinessHoursPeriod nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *BusinessHoursPeriodMutation) ResetField(name string) error {
	switch name {
	case businesshoursperiod.FieldDayOfWeek:
		m.ResetDayOfWeek()
		return nil
	case businesshoursperiod.FieldOpening:
		m.ResetOpening()
		return nil
	case businesshoursperiod.FieldClosing:
		m.ResetClosing()
		return nil
	}
	return fmt.Errorf("unknown BusinessHoursPeriod field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *BusinessHoursPeriodMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parcel_shop != nil {
		edges = append(edges, businesshoursperiod.EdgeParcelShop)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *BusinessHoursPeriodMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case businesshoursperiod.EdgeParcelShop:
		if id := m.parcel_shop; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *BusinessHoursPeriodMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *BusinessHoursPeriodMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *BusinessHoursPeriodMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparcel_shop {
		edges = append(edges, businesshoursperiod.EdgeParcelShop)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *BusinessHoursPeriodMutation) EdgeCleared(name string) bool {
	switch name {
	case businesshoursperiod.EdgeParcelShop:
		return m.clearedparcel_shop
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *BusinessHoursPeriodMutation) ClearEdge(name string) error {
	switch name {
	case businesshoursperiod.EdgeParcelShop:
		m.ClearParcelShop()
		return nil
	}
	return fmt.Errorf("unknown BusinessHoursPeriod unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *BusinessHoursPeriodMutation) ResetEdge(name string) error {
	switch name {
	case businesshoursperiod.EdgeParcelShop:
		m.ResetParcelShop()
		return nil
	}
	return fmt.Errorf("unknown BusinessHoursPeriod edge %s", name)
}

// CarrierMutation represents an operation that mutates the Carrier nodes in the graph.
type CarrierMutation struct {
	config
	op                       Op
	typ                      string
	id                       *pulid.ID
	name                     *string
	sync_cancelation         *bool
	clearedFields            map[string]struct{}
	tenant                   *pulid.ID
	clearedtenant            bool
	carrier_brand            *pulid.ID
	clearedcarrier_brand     bool
	carrier_dao              *pulid.ID
	clearedcarrier_dao       bool
	carrier_df               *pulid.ID
	clearedcarrier_df        bool
	carrier_dsv              *pulid.ID
	clearedcarrier_dsv       bool
	carrier_easy_post        *pulid.ID
	clearedcarrier_easy_post bool
	carrier_gls              *pulid.ID
	clearedcarrier_gls       bool
	carrier_post_nord        *pulid.ID
	clearedcarrier_post_nord bool
	carrier_usps             *pulid.ID
	clearedcarrier_usps      bool
	carrier_bring            *pulid.ID
	clearedcarrier_bring     bool
	delivery_option          map[pulid.ID]struct{}
	removeddelivery_option   map[pulid.ID]struct{}
	cleareddelivery_option   bool
	shipment                 map[pulid.ID]struct{}
	removedshipment          map[pulid.ID]struct{}
	clearedshipment          bool
	done                     bool
	oldValue                 func(context.Context) (*Carrier, error)
	predicates               []predicate.Carrier
}

var _ ent.Mutation = (*CarrierMutation)(nil)

// carrierOption allows management of the mutation configuration using functional options.
type carrierOption func(*CarrierMutation)

// newCarrierMutation creates new mutation for the Carrier entity.
func newCarrierMutation(c config, op Op, opts ...carrierOption) *CarrierMutation {
	m := &CarrierMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierID sets the ID field of the mutation.
func withCarrierID(id pulid.ID) carrierOption {
	return func(m *CarrierMutation) {
		var (
			err   error
			once  sync.Once
			value *Carrier
		)
		m.oldValue = func(ctx context.Context) (*Carrier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Carrier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrier sets the old Carrier of the mutation.
func withCarrier(node *Carrier) carrierOption {
	return func(m *CarrierMutation) {
		m.oldValue = func(context.Context) (*Carrier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Carrier entities.
func (m *CarrierMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Carrier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CarrierMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarrierMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Carrier entity.
// If the Carrier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarrierMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *CarrierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CarrierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Carrier entity.
// If the Carrier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CarrierMutation) ResetName() {
	m.name = nil
}

// SetSyncCancelation sets the "sync_cancelation" field.
func (m *CarrierMutation) SetSyncCancelation(b bool) {
	m.sync_cancelation = &b
}

// SyncCancelation returns the value of the "sync_cancelation" field in the mutation.
func (m *CarrierMutation) SyncCancelation() (r bool, exists bool) {
	v := m.sync_cancelation
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncCancelation returns the old "sync_cancelation" field's value of the Carrier entity.
// If the Carrier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierMutation) OldSyncCancelation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncCancelation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncCancelation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncCancelation: %w", err)
	}
	return oldValue.SyncCancelation, nil
}

// ResetSyncCancelation resets all changes to the "sync_cancelation" field.
func (m *CarrierMutation) ResetSyncCancelation() {
	m.sync_cancelation = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarrierMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[carrier.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarrierMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarrierMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarrierMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierBrandID sets the "carrier_brand" edge to the CarrierBrand entity by id.
func (m *CarrierMutation) SetCarrierBrandID(id pulid.ID) {
	m.carrier_brand = &id
}

// ClearCarrierBrand clears the "carrier_brand" edge to the CarrierBrand entity.
func (m *CarrierMutation) ClearCarrierBrand() {
	m.clearedcarrier_brand = true
}

// CarrierBrandCleared reports if the "carrier_brand" edge to the CarrierBrand entity was cleared.
func (m *CarrierMutation) CarrierBrandCleared() bool {
	return m.clearedcarrier_brand
}

// CarrierBrandID returns the "carrier_brand" edge ID in the mutation.
func (m *CarrierMutation) CarrierBrandID() (id pulid.ID, exists bool) {
	if m.carrier_brand != nil {
		return *m.carrier_brand, true
	}
	return
}

// CarrierBrandIDs returns the "carrier_brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierBrandID instead. It exists only for internal usage by the builders.
func (m *CarrierMutation) CarrierBrandIDs() (ids []pulid.ID) {
	if id := m.carrier_brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierBrand resets all changes to the "carrier_brand" edge.
func (m *CarrierMutation) ResetCarrierBrand() {
	m.carrier_brand = nil
	m.clearedcarrier_brand = false
}

// SetCarrierDAOID sets the "carrier_dao" edge to the CarrierDAO entity by id.
func (m *CarrierMutation) SetCarrierDAOID(id pulid.ID) {
	m.carrier_dao = &id
}

// ClearCarrierDAO clears the "carrier_dao" edge to the CarrierDAO entity.
func (m *CarrierMutation) ClearCarrierDAO() {
	m.clearedcarrier_dao = true
}

// CarrierDAOCleared reports if the "carrier_dao" edge to the CarrierDAO entity was cleared.
func (m *CarrierMutation) CarrierDAOCleared() bool {
	return m.clearedcarrier_dao
}

// CarrierDAOID returns the "carrier_dao" edge ID in the mutation.
func (m *CarrierMutation) CarrierDAOID() (id pulid.ID, exists bool) {
	if m.carrier_dao != nil {
		return *m.carrier_dao, true
	}
	return
}

// CarrierDAOIDs returns the "carrier_dao" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierDAOID instead. It exists only for internal usage by the builders.
func (m *CarrierMutation) CarrierDAOIDs() (ids []pulid.ID) {
	if id := m.carrier_dao; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierDAO resets all changes to the "carrier_dao" edge.
func (m *CarrierMutation) ResetCarrierDAO() {
	m.carrier_dao = nil
	m.clearedcarrier_dao = false
}

// SetCarrierDFID sets the "carrier_df" edge to the CarrierDF entity by id.
func (m *CarrierMutation) SetCarrierDFID(id pulid.ID) {
	m.carrier_df = &id
}

// ClearCarrierDF clears the "carrier_df" edge to the CarrierDF entity.
func (m *CarrierMutation) ClearCarrierDF() {
	m.clearedcarrier_df = true
}

// CarrierDFCleared reports if the "carrier_df" edge to the CarrierDF entity was cleared.
func (m *CarrierMutation) CarrierDFCleared() bool {
	return m.clearedcarrier_df
}

// CarrierDFID returns the "carrier_df" edge ID in the mutation.
func (m *CarrierMutation) CarrierDFID() (id pulid.ID, exists bool) {
	if m.carrier_df != nil {
		return *m.carrier_df, true
	}
	return
}

// CarrierDFIDs returns the "carrier_df" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierDFID instead. It exists only for internal usage by the builders.
func (m *CarrierMutation) CarrierDFIDs() (ids []pulid.ID) {
	if id := m.carrier_df; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierDF resets all changes to the "carrier_df" edge.
func (m *CarrierMutation) ResetCarrierDF() {
	m.carrier_df = nil
	m.clearedcarrier_df = false
}

// SetCarrierDSVID sets the "carrier_dsv" edge to the CarrierDSV entity by id.
func (m *CarrierMutation) SetCarrierDSVID(id pulid.ID) {
	m.carrier_dsv = &id
}

// ClearCarrierDSV clears the "carrier_dsv" edge to the CarrierDSV entity.
func (m *CarrierMutation) ClearCarrierDSV() {
	m.clearedcarrier_dsv = true
}

// CarrierDSVCleared reports if the "carrier_dsv" edge to the CarrierDSV entity was cleared.
func (m *CarrierMutation) CarrierDSVCleared() bool {
	return m.clearedcarrier_dsv
}

// CarrierDSVID returns the "carrier_dsv" edge ID in the mutation.
func (m *CarrierMutation) CarrierDSVID() (id pulid.ID, exists bool) {
	if m.carrier_dsv != nil {
		return *m.carrier_dsv, true
	}
	return
}

// CarrierDSVIDs returns the "carrier_dsv" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierDSVID instead. It exists only for internal usage by the builders.
func (m *CarrierMutation) CarrierDSVIDs() (ids []pulid.ID) {
	if id := m.carrier_dsv; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierDSV resets all changes to the "carrier_dsv" edge.
func (m *CarrierMutation) ResetCarrierDSV() {
	m.carrier_dsv = nil
	m.clearedcarrier_dsv = false
}

// SetCarrierEasyPostID sets the "carrier_easy_post" edge to the CarrierEasyPost entity by id.
func (m *CarrierMutation) SetCarrierEasyPostID(id pulid.ID) {
	m.carrier_easy_post = &id
}

// ClearCarrierEasyPost clears the "carrier_easy_post" edge to the CarrierEasyPost entity.
func (m *CarrierMutation) ClearCarrierEasyPost() {
	m.clearedcarrier_easy_post = true
}

// CarrierEasyPostCleared reports if the "carrier_easy_post" edge to the CarrierEasyPost entity was cleared.
func (m *CarrierMutation) CarrierEasyPostCleared() bool {
	return m.clearedcarrier_easy_post
}

// CarrierEasyPostID returns the "carrier_easy_post" edge ID in the mutation.
func (m *CarrierMutation) CarrierEasyPostID() (id pulid.ID, exists bool) {
	if m.carrier_easy_post != nil {
		return *m.carrier_easy_post, true
	}
	return
}

// CarrierEasyPostIDs returns the "carrier_easy_post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierEasyPostID instead. It exists only for internal usage by the builders.
func (m *CarrierMutation) CarrierEasyPostIDs() (ids []pulid.ID) {
	if id := m.carrier_easy_post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierEasyPost resets all changes to the "carrier_easy_post" edge.
func (m *CarrierMutation) ResetCarrierEasyPost() {
	m.carrier_easy_post = nil
	m.clearedcarrier_easy_post = false
}

// SetCarrierGLSID sets the "carrier_gls" edge to the CarrierGLS entity by id.
func (m *CarrierMutation) SetCarrierGLSID(id pulid.ID) {
	m.carrier_gls = &id
}

// ClearCarrierGLS clears the "carrier_gls" edge to the CarrierGLS entity.
func (m *CarrierMutation) ClearCarrierGLS() {
	m.clearedcarrier_gls = true
}

// CarrierGLSCleared reports if the "carrier_gls" edge to the CarrierGLS entity was cleared.
func (m *CarrierMutation) CarrierGLSCleared() bool {
	return m.clearedcarrier_gls
}

// CarrierGLSID returns the "carrier_gls" edge ID in the mutation.
func (m *CarrierMutation) CarrierGLSID() (id pulid.ID, exists bool) {
	if m.carrier_gls != nil {
		return *m.carrier_gls, true
	}
	return
}

// CarrierGLSIDs returns the "carrier_gls" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierGLSID instead. It exists only for internal usage by the builders.
func (m *CarrierMutation) CarrierGLSIDs() (ids []pulid.ID) {
	if id := m.carrier_gls; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierGLS resets all changes to the "carrier_gls" edge.
func (m *CarrierMutation) ResetCarrierGLS() {
	m.carrier_gls = nil
	m.clearedcarrier_gls = false
}

// SetCarrierPostNordID sets the "carrier_post_nord" edge to the CarrierPostNord entity by id.
func (m *CarrierMutation) SetCarrierPostNordID(id pulid.ID) {
	m.carrier_post_nord = &id
}

// ClearCarrierPostNord clears the "carrier_post_nord" edge to the CarrierPostNord entity.
func (m *CarrierMutation) ClearCarrierPostNord() {
	m.clearedcarrier_post_nord = true
}

// CarrierPostNordCleared reports if the "carrier_post_nord" edge to the CarrierPostNord entity was cleared.
func (m *CarrierMutation) CarrierPostNordCleared() bool {
	return m.clearedcarrier_post_nord
}

// CarrierPostNordID returns the "carrier_post_nord" edge ID in the mutation.
func (m *CarrierMutation) CarrierPostNordID() (id pulid.ID, exists bool) {
	if m.carrier_post_nord != nil {
		return *m.carrier_post_nord, true
	}
	return
}

// CarrierPostNordIDs returns the "carrier_post_nord" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierPostNordID instead. It exists only for internal usage by the builders.
func (m *CarrierMutation) CarrierPostNordIDs() (ids []pulid.ID) {
	if id := m.carrier_post_nord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierPostNord resets all changes to the "carrier_post_nord" edge.
func (m *CarrierMutation) ResetCarrierPostNord() {
	m.carrier_post_nord = nil
	m.clearedcarrier_post_nord = false
}

// SetCarrierUSPSID sets the "carrier_usps" edge to the CarrierUSPS entity by id.
func (m *CarrierMutation) SetCarrierUSPSID(id pulid.ID) {
	m.carrier_usps = &id
}

// ClearCarrierUSPS clears the "carrier_usps" edge to the CarrierUSPS entity.
func (m *CarrierMutation) ClearCarrierUSPS() {
	m.clearedcarrier_usps = true
}

// CarrierUSPSCleared reports if the "carrier_usps" edge to the CarrierUSPS entity was cleared.
func (m *CarrierMutation) CarrierUSPSCleared() bool {
	return m.clearedcarrier_usps
}

// CarrierUSPSID returns the "carrier_usps" edge ID in the mutation.
func (m *CarrierMutation) CarrierUSPSID() (id pulid.ID, exists bool) {
	if m.carrier_usps != nil {
		return *m.carrier_usps, true
	}
	return
}

// CarrierUSPSIDs returns the "carrier_usps" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierUSPSID instead. It exists only for internal usage by the builders.
func (m *CarrierMutation) CarrierUSPSIDs() (ids []pulid.ID) {
	if id := m.carrier_usps; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierUSPS resets all changes to the "carrier_usps" edge.
func (m *CarrierMutation) ResetCarrierUSPS() {
	m.carrier_usps = nil
	m.clearedcarrier_usps = false
}

// SetCarrierBringID sets the "carrier_bring" edge to the CarrierBring entity by id.
func (m *CarrierMutation) SetCarrierBringID(id pulid.ID) {
	m.carrier_bring = &id
}

// ClearCarrierBring clears the "carrier_bring" edge to the CarrierBring entity.
func (m *CarrierMutation) ClearCarrierBring() {
	m.clearedcarrier_bring = true
}

// CarrierBringCleared reports if the "carrier_bring" edge to the CarrierBring entity was cleared.
func (m *CarrierMutation) CarrierBringCleared() bool {
	return m.clearedcarrier_bring
}

// CarrierBringID returns the "carrier_bring" edge ID in the mutation.
func (m *CarrierMutation) CarrierBringID() (id pulid.ID, exists bool) {
	if m.carrier_bring != nil {
		return *m.carrier_bring, true
	}
	return
}

// CarrierBringIDs returns the "carrier_bring" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierBringID instead. It exists only for internal usage by the builders.
func (m *CarrierMutation) CarrierBringIDs() (ids []pulid.ID) {
	if id := m.carrier_bring; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierBring resets all changes to the "carrier_bring" edge.
func (m *CarrierMutation) ResetCarrierBring() {
	m.carrier_bring = nil
	m.clearedcarrier_bring = false
}

// AddDeliveryOptionIDs adds the "delivery_option" edge to the DeliveryOption entity by ids.
func (m *CarrierMutation) AddDeliveryOptionIDs(ids ...pulid.ID) {
	if m.delivery_option == nil {
		m.delivery_option = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *CarrierMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *CarrierMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// RemoveDeliveryOptionIDs removes the "delivery_option" edge to the DeliveryOption entity by IDs.
func (m *CarrierMutation) RemoveDeliveryOptionIDs(ids ...pulid.ID) {
	if m.removeddelivery_option == nil {
		m.removeddelivery_option = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option, ids[i])
		m.removeddelivery_option[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOption returns the removed IDs of the "delivery_option" edge to the DeliveryOption entity.
func (m *CarrierMutation) RemovedDeliveryOptionIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
func (m *CarrierMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	for id := range m.delivery_option {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *CarrierMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
	m.removeddelivery_option = nil
}

// AddShipmentIDs adds the "shipment" edge to the Shipment entity by ids.
func (m *CarrierMutation) AddShipmentIDs(ids ...pulid.ID) {
	if m.shipment == nil {
		m.shipment = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.shipment[ids[i]] = struct{}{}
	}
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *CarrierMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *CarrierMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// RemoveShipmentIDs removes the "shipment" edge to the Shipment entity by IDs.
func (m *CarrierMutation) RemoveShipmentIDs(ids ...pulid.ID) {
	if m.removedshipment == nil {
		m.removedshipment = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.shipment, ids[i])
		m.removedshipment[ids[i]] = struct{}{}
	}
}

// RemovedShipment returns the removed IDs of the "shipment" edge to the Shipment entity.
func (m *CarrierMutation) RemovedShipmentIDs() (ids []pulid.ID) {
	for id := range m.removedshipment {
		ids = append(ids, id)
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
func (m *CarrierMutation) ShipmentIDs() (ids []pulid.ID) {
	for id := range m.shipment {
		ids = append(ids, id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *CarrierMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
	m.removedshipment = nil
}

// Where appends a list predicates to the CarrierMutation builder.
func (m *CarrierMutation) Where(ps ...predicate.Carrier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Carrier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Carrier).
func (m *CarrierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, carrier.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, carrier.FieldName)
	}
	if m.sync_cancelation != nil {
		fields = append(fields, carrier.FieldSyncCancelation)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrier.FieldTenantID:
		return m.TenantID()
	case carrier.FieldName:
		return m.Name()
	case carrier.FieldSyncCancelation:
		return m.SyncCancelation()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrier.FieldTenantID:
		return m.OldTenantID(ctx)
	case carrier.FieldName:
		return m.OldName(ctx)
	case carrier.FieldSyncCancelation:
		return m.OldSyncCancelation(ctx)
	}
	return nil, fmt.Errorf("unknown Carrier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrier.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case carrier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case carrier.FieldSyncCancelation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncCancelation(v)
		return nil
	}
	return fmt.Errorf("unknown Carrier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Carrier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Carrier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierMutation) ResetField(name string) error {
	switch name {
	case carrier.FieldTenantID:
		m.ResetTenantID()
		return nil
	case carrier.FieldName:
		m.ResetName()
		return nil
	case carrier.FieldSyncCancelation:
		m.ResetSyncCancelation()
		return nil
	}
	return fmt.Errorf("unknown Carrier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.tenant != nil {
		edges = append(edges, carrier.EdgeTenant)
	}
	if m.carrier_brand != nil {
		edges = append(edges, carrier.EdgeCarrierBrand)
	}
	if m.carrier_dao != nil {
		edges = append(edges, carrier.EdgeCarrierDAO)
	}
	if m.carrier_df != nil {
		edges = append(edges, carrier.EdgeCarrierDF)
	}
	if m.carrier_dsv != nil {
		edges = append(edges, carrier.EdgeCarrierDSV)
	}
	if m.carrier_easy_post != nil {
		edges = append(edges, carrier.EdgeCarrierEasyPost)
	}
	if m.carrier_gls != nil {
		edges = append(edges, carrier.EdgeCarrierGLS)
	}
	if m.carrier_post_nord != nil {
		edges = append(edges, carrier.EdgeCarrierPostNord)
	}
	if m.carrier_usps != nil {
		edges = append(edges, carrier.EdgeCarrierUSPS)
	}
	if m.carrier_bring != nil {
		edges = append(edges, carrier.EdgeCarrierBring)
	}
	if m.delivery_option != nil {
		edges = append(edges, carrier.EdgeDeliveryOption)
	}
	if m.shipment != nil {
		edges = append(edges, carrier.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrier.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case carrier.EdgeCarrierBrand:
		if id := m.carrier_brand; id != nil {
			return []ent.Value{*id}
		}
	case carrier.EdgeCarrierDAO:
		if id := m.carrier_dao; id != nil {
			return []ent.Value{*id}
		}
	case carrier.EdgeCarrierDF:
		if id := m.carrier_df; id != nil {
			return []ent.Value{*id}
		}
	case carrier.EdgeCarrierDSV:
		if id := m.carrier_dsv; id != nil {
			return []ent.Value{*id}
		}
	case carrier.EdgeCarrierEasyPost:
		if id := m.carrier_easy_post; id != nil {
			return []ent.Value{*id}
		}
	case carrier.EdgeCarrierGLS:
		if id := m.carrier_gls; id != nil {
			return []ent.Value{*id}
		}
	case carrier.EdgeCarrierPostNord:
		if id := m.carrier_post_nord; id != nil {
			return []ent.Value{*id}
		}
	case carrier.EdgeCarrierUSPS:
		if id := m.carrier_usps; id != nil {
			return []ent.Value{*id}
		}
	case carrier.EdgeCarrierBring:
		if id := m.carrier_bring; id != nil {
			return []ent.Value{*id}
		}
	case carrier.EdgeDeliveryOption:
		ids := make([]ent.Value, 0, len(m.delivery_option))
		for id := range m.delivery_option {
			ids = append(ids, id)
		}
		return ids
	case carrier.EdgeShipment:
		ids := make([]ent.Value, 0, len(m.shipment))
		for id := range m.shipment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removeddelivery_option != nil {
		edges = append(edges, carrier.EdgeDeliveryOption)
	}
	if m.removedshipment != nil {
		edges = append(edges, carrier.EdgeShipment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrier.EdgeDeliveryOption:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option))
		for id := range m.removeddelivery_option {
			ids = append(ids, id)
		}
		return ids
	case carrier.EdgeShipment:
		ids := make([]ent.Value, 0, len(m.removedshipment))
		for id := range m.removedshipment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.clearedtenant {
		edges = append(edges, carrier.EdgeTenant)
	}
	if m.clearedcarrier_brand {
		edges = append(edges, carrier.EdgeCarrierBrand)
	}
	if m.clearedcarrier_dao {
		edges = append(edges, carrier.EdgeCarrierDAO)
	}
	if m.clearedcarrier_df {
		edges = append(edges, carrier.EdgeCarrierDF)
	}
	if m.clearedcarrier_dsv {
		edges = append(edges, carrier.EdgeCarrierDSV)
	}
	if m.clearedcarrier_easy_post {
		edges = append(edges, carrier.EdgeCarrierEasyPost)
	}
	if m.clearedcarrier_gls {
		edges = append(edges, carrier.EdgeCarrierGLS)
	}
	if m.clearedcarrier_post_nord {
		edges = append(edges, carrier.EdgeCarrierPostNord)
	}
	if m.clearedcarrier_usps {
		edges = append(edges, carrier.EdgeCarrierUSPS)
	}
	if m.clearedcarrier_bring {
		edges = append(edges, carrier.EdgeCarrierBring)
	}
	if m.cleareddelivery_option {
		edges = append(edges, carrier.EdgeDeliveryOption)
	}
	if m.clearedshipment {
		edges = append(edges, carrier.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierMutation) EdgeCleared(name string) bool {
	switch name {
	case carrier.EdgeTenant:
		return m.clearedtenant
	case carrier.EdgeCarrierBrand:
		return m.clearedcarrier_brand
	case carrier.EdgeCarrierDAO:
		return m.clearedcarrier_dao
	case carrier.EdgeCarrierDF:
		return m.clearedcarrier_df
	case carrier.EdgeCarrierDSV:
		return m.clearedcarrier_dsv
	case carrier.EdgeCarrierEasyPost:
		return m.clearedcarrier_easy_post
	case carrier.EdgeCarrierGLS:
		return m.clearedcarrier_gls
	case carrier.EdgeCarrierPostNord:
		return m.clearedcarrier_post_nord
	case carrier.EdgeCarrierUSPS:
		return m.clearedcarrier_usps
	case carrier.EdgeCarrierBring:
		return m.clearedcarrier_bring
	case carrier.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case carrier.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierMutation) ClearEdge(name string) error {
	switch name {
	case carrier.EdgeTenant:
		m.ClearTenant()
		return nil
	case carrier.EdgeCarrierBrand:
		m.ClearCarrierBrand()
		return nil
	case carrier.EdgeCarrierDAO:
		m.ClearCarrierDAO()
		return nil
	case carrier.EdgeCarrierDF:
		m.ClearCarrierDF()
		return nil
	case carrier.EdgeCarrierDSV:
		m.ClearCarrierDSV()
		return nil
	case carrier.EdgeCarrierEasyPost:
		m.ClearCarrierEasyPost()
		return nil
	case carrier.EdgeCarrierGLS:
		m.ClearCarrierGLS()
		return nil
	case carrier.EdgeCarrierPostNord:
		m.ClearCarrierPostNord()
		return nil
	case carrier.EdgeCarrierUSPS:
		m.ClearCarrierUSPS()
		return nil
	case carrier.EdgeCarrierBring:
		m.ClearCarrierBring()
		return nil
	}
	return fmt.Errorf("unknown Carrier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierMutation) ResetEdge(name string) error {
	switch name {
	case carrier.EdgeTenant:
		m.ResetTenant()
		return nil
	case carrier.EdgeCarrierBrand:
		m.ResetCarrierBrand()
		return nil
	case carrier.EdgeCarrierDAO:
		m.ResetCarrierDAO()
		return nil
	case carrier.EdgeCarrierDF:
		m.ResetCarrierDF()
		return nil
	case carrier.EdgeCarrierDSV:
		m.ResetCarrierDSV()
		return nil
	case carrier.EdgeCarrierEasyPost:
		m.ResetCarrierEasyPost()
		return nil
	case carrier.EdgeCarrierGLS:
		m.ResetCarrierGLS()
		return nil
	case carrier.EdgeCarrierPostNord:
		m.ResetCarrierPostNord()
		return nil
	case carrier.EdgeCarrierUSPS:
		m.ResetCarrierUSPS()
		return nil
	case carrier.EdgeCarrierBring:
		m.ResetCarrierBring()
		return nil
	case carrier.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case carrier.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown Carrier edge %s", name)
}

// CarrierAdditionalServiceBringMutation represents an operation that mutates the CarrierAdditionalServiceBring nodes in the graph.
type CarrierAdditionalServiceBringMutation struct {
	config
	op                           Op
	typ                          string
	id                           *pulid.ID
	label                        *string
	api_code_booking             *string
	clearedFields                map[string]struct{}
	carrier_service_bring        *pulid.ID
	clearedcarrier_service_bring bool
	delivery_option_bring        map[pulid.ID]struct{}
	removeddelivery_option_bring map[pulid.ID]struct{}
	cleareddelivery_option_bring bool
	done                         bool
	oldValue                     func(context.Context) (*CarrierAdditionalServiceBring, error)
	predicates                   []predicate.CarrierAdditionalServiceBring
}

var _ ent.Mutation = (*CarrierAdditionalServiceBringMutation)(nil)

// carrieradditionalservicebringOption allows management of the mutation configuration using functional options.
type carrieradditionalservicebringOption func(*CarrierAdditionalServiceBringMutation)

// newCarrierAdditionalServiceBringMutation creates new mutation for the CarrierAdditionalServiceBring entity.
func newCarrierAdditionalServiceBringMutation(c config, op Op, opts ...carrieradditionalservicebringOption) *CarrierAdditionalServiceBringMutation {
	m := &CarrierAdditionalServiceBringMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierAdditionalServiceBring,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierAdditionalServiceBringID sets the ID field of the mutation.
func withCarrierAdditionalServiceBringID(id pulid.ID) carrieradditionalservicebringOption {
	return func(m *CarrierAdditionalServiceBringMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierAdditionalServiceBring
		)
		m.oldValue = func(ctx context.Context) (*CarrierAdditionalServiceBring, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierAdditionalServiceBring.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierAdditionalServiceBring sets the old CarrierAdditionalServiceBring of the mutation.
func withCarrierAdditionalServiceBring(node *CarrierAdditionalServiceBring) carrieradditionalservicebringOption {
	return func(m *CarrierAdditionalServiceBringMutation) {
		m.oldValue = func(context.Context) (*CarrierAdditionalServiceBring, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierAdditionalServiceBringMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierAdditionalServiceBringMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierAdditionalServiceBring entities.
func (m *CarrierAdditionalServiceBringMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierAdditionalServiceBringMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierAdditionalServiceBringMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierAdditionalServiceBring.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierAdditionalServiceBringMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierAdditionalServiceBringMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierAdditionalServiceBring entity.
// If the CarrierAdditionalServiceBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceBringMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierAdditionalServiceBringMutation) ResetLabel() {
	m.label = nil
}

// SetAPICodeBooking sets the "api_code_booking" field.
func (m *CarrierAdditionalServiceBringMutation) SetAPICodeBooking(s string) {
	m.api_code_booking = &s
}

// APICodeBooking returns the value of the "api_code_booking" field in the mutation.
func (m *CarrierAdditionalServiceBringMutation) APICodeBooking() (r string, exists bool) {
	v := m.api_code_booking
	if v == nil {
		return
	}
	return *v, true
}

// OldAPICodeBooking returns the old "api_code_booking" field's value of the CarrierAdditionalServiceBring entity.
// If the CarrierAdditionalServiceBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceBringMutation) OldAPICodeBooking(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPICodeBooking is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPICodeBooking requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPICodeBooking: %w", err)
	}
	return oldValue.APICodeBooking, nil
}

// ResetAPICodeBooking resets all changes to the "api_code_booking" field.
func (m *CarrierAdditionalServiceBringMutation) ResetAPICodeBooking() {
	m.api_code_booking = nil
}

// SetCarrierServiceBringID sets the "carrier_service_bring" edge to the CarrierServiceBring entity by id.
func (m *CarrierAdditionalServiceBringMutation) SetCarrierServiceBringID(id pulid.ID) {
	m.carrier_service_bring = &id
}

// ClearCarrierServiceBring clears the "carrier_service_bring" edge to the CarrierServiceBring entity.
func (m *CarrierAdditionalServiceBringMutation) ClearCarrierServiceBring() {
	m.clearedcarrier_service_bring = true
}

// CarrierServiceBringCleared reports if the "carrier_service_bring" edge to the CarrierServiceBring entity was cleared.
func (m *CarrierAdditionalServiceBringMutation) CarrierServiceBringCleared() bool {
	return m.clearedcarrier_service_bring
}

// CarrierServiceBringID returns the "carrier_service_bring" edge ID in the mutation.
func (m *CarrierAdditionalServiceBringMutation) CarrierServiceBringID() (id pulid.ID, exists bool) {
	if m.carrier_service_bring != nil {
		return *m.carrier_service_bring, true
	}
	return
}

// CarrierServiceBringIDs returns the "carrier_service_bring" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceBringID instead. It exists only for internal usage by the builders.
func (m *CarrierAdditionalServiceBringMutation) CarrierServiceBringIDs() (ids []pulid.ID) {
	if id := m.carrier_service_bring; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServiceBring resets all changes to the "carrier_service_bring" edge.
func (m *CarrierAdditionalServiceBringMutation) ResetCarrierServiceBring() {
	m.carrier_service_bring = nil
	m.clearedcarrier_service_bring = false
}

// AddDeliveryOptionBringIDs adds the "delivery_option_bring" edge to the DeliveryOptionBring entity by ids.
func (m *CarrierAdditionalServiceBringMutation) AddDeliveryOptionBringIDs(ids ...pulid.ID) {
	if m.delivery_option_bring == nil {
		m.delivery_option_bring = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_bring[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionBring clears the "delivery_option_bring" edge to the DeliveryOptionBring entity.
func (m *CarrierAdditionalServiceBringMutation) ClearDeliveryOptionBring() {
	m.cleareddelivery_option_bring = true
}

// DeliveryOptionBringCleared reports if the "delivery_option_bring" edge to the DeliveryOptionBring entity was cleared.
func (m *CarrierAdditionalServiceBringMutation) DeliveryOptionBringCleared() bool {
	return m.cleareddelivery_option_bring
}

// RemoveDeliveryOptionBringIDs removes the "delivery_option_bring" edge to the DeliveryOptionBring entity by IDs.
func (m *CarrierAdditionalServiceBringMutation) RemoveDeliveryOptionBringIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_bring == nil {
		m.removeddelivery_option_bring = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_bring, ids[i])
		m.removeddelivery_option_bring[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionBring returns the removed IDs of the "delivery_option_bring" edge to the DeliveryOptionBring entity.
func (m *CarrierAdditionalServiceBringMutation) RemovedDeliveryOptionBringIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_bring {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionBringIDs returns the "delivery_option_bring" edge IDs in the mutation.
func (m *CarrierAdditionalServiceBringMutation) DeliveryOptionBringIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_bring {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionBring resets all changes to the "delivery_option_bring" edge.
func (m *CarrierAdditionalServiceBringMutation) ResetDeliveryOptionBring() {
	m.delivery_option_bring = nil
	m.cleareddelivery_option_bring = false
	m.removeddelivery_option_bring = nil
}

// Where appends a list predicates to the CarrierAdditionalServiceBringMutation builder.
func (m *CarrierAdditionalServiceBringMutation) Where(ps ...predicate.CarrierAdditionalServiceBring) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierAdditionalServiceBringMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierAdditionalServiceBringMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierAdditionalServiceBring, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierAdditionalServiceBringMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierAdditionalServiceBringMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierAdditionalServiceBring).
func (m *CarrierAdditionalServiceBringMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierAdditionalServiceBringMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.label != nil {
		fields = append(fields, carrieradditionalservicebring.FieldLabel)
	}
	if m.api_code_booking != nil {
		fields = append(fields, carrieradditionalservicebring.FieldAPICodeBooking)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierAdditionalServiceBringMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrieradditionalservicebring.FieldLabel:
		return m.Label()
	case carrieradditionalservicebring.FieldAPICodeBooking:
		return m.APICodeBooking()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierAdditionalServiceBringMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrieradditionalservicebring.FieldLabel:
		return m.OldLabel(ctx)
	case carrieradditionalservicebring.FieldAPICodeBooking:
		return m.OldAPICodeBooking(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierAdditionalServiceBring field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceBringMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrieradditionalservicebring.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrieradditionalservicebring.FieldAPICodeBooking:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPICodeBooking(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceBring field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierAdditionalServiceBringMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierAdditionalServiceBringMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceBringMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceBring numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierAdditionalServiceBringMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierAdditionalServiceBringMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceBringMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierAdditionalServiceBring nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceBringMutation) ResetField(name string) error {
	switch name {
	case carrieradditionalservicebring.FieldLabel:
		m.ResetLabel()
		return nil
	case carrieradditionalservicebring.FieldAPICodeBooking:
		m.ResetAPICodeBooking()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceBring field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierAdditionalServiceBringMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service_bring != nil {
		edges = append(edges, carrieradditionalservicebring.EdgeCarrierServiceBring)
	}
	if m.delivery_option_bring != nil {
		edges = append(edges, carrieradditionalservicebring.EdgeDeliveryOptionBring)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierAdditionalServiceBringMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicebring.EdgeCarrierServiceBring:
		if id := m.carrier_service_bring; id != nil {
			return []ent.Value{*id}
		}
	case carrieradditionalservicebring.EdgeDeliveryOptionBring:
		ids := make([]ent.Value, 0, len(m.delivery_option_bring))
		for id := range m.delivery_option_bring {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierAdditionalServiceBringMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddelivery_option_bring != nil {
		edges = append(edges, carrieradditionalservicebring.EdgeDeliveryOptionBring)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierAdditionalServiceBringMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicebring.EdgeDeliveryOptionBring:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_bring))
		for id := range m.removeddelivery_option_bring {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierAdditionalServiceBringMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service_bring {
		edges = append(edges, carrieradditionalservicebring.EdgeCarrierServiceBring)
	}
	if m.cleareddelivery_option_bring {
		edges = append(edges, carrieradditionalservicebring.EdgeDeliveryOptionBring)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierAdditionalServiceBringMutation) EdgeCleared(name string) bool {
	switch name {
	case carrieradditionalservicebring.EdgeCarrierServiceBring:
		return m.clearedcarrier_service_bring
	case carrieradditionalservicebring.EdgeDeliveryOptionBring:
		return m.cleareddelivery_option_bring
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierAdditionalServiceBringMutation) ClearEdge(name string) error {
	switch name {
	case carrieradditionalservicebring.EdgeCarrierServiceBring:
		m.ClearCarrierServiceBring()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceBring unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierAdditionalServiceBringMutation) ResetEdge(name string) error {
	switch name {
	case carrieradditionalservicebring.EdgeCarrierServiceBring:
		m.ResetCarrierServiceBring()
		return nil
	case carrieradditionalservicebring.EdgeDeliveryOptionBring:
		m.ResetDeliveryOptionBring()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceBring edge %s", name)
}

// CarrierAdditionalServiceDAOMutation represents an operation that mutates the CarrierAdditionalServiceDAO nodes in the graph.
type CarrierAdditionalServiceDAOMutation struct {
	config
	op                         Op
	typ                        string
	id                         *pulid.ID
	label                      *string
	api_code                   *string
	clearedFields              map[string]struct{}
	carrier_service_dao        map[pulid.ID]struct{}
	removedcarrier_service_dao map[pulid.ID]struct{}
	clearedcarrier_service_dao bool
	delivery_option_dao        map[pulid.ID]struct{}
	removeddelivery_option_dao map[pulid.ID]struct{}
	cleareddelivery_option_dao bool
	done                       bool
	oldValue                   func(context.Context) (*CarrierAdditionalServiceDAO, error)
	predicates                 []predicate.CarrierAdditionalServiceDAO
}

var _ ent.Mutation = (*CarrierAdditionalServiceDAOMutation)(nil)

// carrieradditionalservicedaoOption allows management of the mutation configuration using functional options.
type carrieradditionalservicedaoOption func(*CarrierAdditionalServiceDAOMutation)

// newCarrierAdditionalServiceDAOMutation creates new mutation for the CarrierAdditionalServiceDAO entity.
func newCarrierAdditionalServiceDAOMutation(c config, op Op, opts ...carrieradditionalservicedaoOption) *CarrierAdditionalServiceDAOMutation {
	m := &CarrierAdditionalServiceDAOMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierAdditionalServiceDAO,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierAdditionalServiceDAOID sets the ID field of the mutation.
func withCarrierAdditionalServiceDAOID(id pulid.ID) carrieradditionalservicedaoOption {
	return func(m *CarrierAdditionalServiceDAOMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierAdditionalServiceDAO
		)
		m.oldValue = func(ctx context.Context) (*CarrierAdditionalServiceDAO, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierAdditionalServiceDAO.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierAdditionalServiceDAO sets the old CarrierAdditionalServiceDAO of the mutation.
func withCarrierAdditionalServiceDAO(node *CarrierAdditionalServiceDAO) carrieradditionalservicedaoOption {
	return func(m *CarrierAdditionalServiceDAOMutation) {
		m.oldValue = func(context.Context) (*CarrierAdditionalServiceDAO, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierAdditionalServiceDAOMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierAdditionalServiceDAOMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierAdditionalServiceDAO entities.
func (m *CarrierAdditionalServiceDAOMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierAdditionalServiceDAOMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierAdditionalServiceDAOMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierAdditionalServiceDAO.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierAdditionalServiceDAOMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierAdditionalServiceDAOMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierAdditionalServiceDAO entity.
// If the CarrierAdditionalServiceDAO object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceDAOMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierAdditionalServiceDAOMutation) ResetLabel() {
	m.label = nil
}

// SetAPICode sets the "api_code" field.
func (m *CarrierAdditionalServiceDAOMutation) SetAPICode(s string) {
	m.api_code = &s
}

// APICode returns the value of the "api_code" field in the mutation.
func (m *CarrierAdditionalServiceDAOMutation) APICode() (r string, exists bool) {
	v := m.api_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAPICode returns the old "api_code" field's value of the CarrierAdditionalServiceDAO entity.
// If the CarrierAdditionalServiceDAO object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceDAOMutation) OldAPICode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPICode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPICode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPICode: %w", err)
	}
	return oldValue.APICode, nil
}

// ResetAPICode resets all changes to the "api_code" field.
func (m *CarrierAdditionalServiceDAOMutation) ResetAPICode() {
	m.api_code = nil
}

// AddCarrierServiceDAOIDs adds the "carrier_service_dao" edge to the CarrierServiceDAO entity by ids.
func (m *CarrierAdditionalServiceDAOMutation) AddCarrierServiceDAOIDs(ids ...pulid.ID) {
	if m.carrier_service_dao == nil {
		m.carrier_service_dao = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_service_dao[ids[i]] = struct{}{}
	}
}

// ClearCarrierServiceDAO clears the "carrier_service_dao" edge to the CarrierServiceDAO entity.
func (m *CarrierAdditionalServiceDAOMutation) ClearCarrierServiceDAO() {
	m.clearedcarrier_service_dao = true
}

// CarrierServiceDAOCleared reports if the "carrier_service_dao" edge to the CarrierServiceDAO entity was cleared.
func (m *CarrierAdditionalServiceDAOMutation) CarrierServiceDAOCleared() bool {
	return m.clearedcarrier_service_dao
}

// RemoveCarrierServiceDAOIDs removes the "carrier_service_dao" edge to the CarrierServiceDAO entity by IDs.
func (m *CarrierAdditionalServiceDAOMutation) RemoveCarrierServiceDAOIDs(ids ...pulid.ID) {
	if m.removedcarrier_service_dao == nil {
		m.removedcarrier_service_dao = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_service_dao, ids[i])
		m.removedcarrier_service_dao[ids[i]] = struct{}{}
	}
}

// RemovedCarrierServiceDAO returns the removed IDs of the "carrier_service_dao" edge to the CarrierServiceDAO entity.
func (m *CarrierAdditionalServiceDAOMutation) RemovedCarrierServiceDAOIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_service_dao {
		ids = append(ids, id)
	}
	return
}

// CarrierServiceDAOIDs returns the "carrier_service_dao" edge IDs in the mutation.
func (m *CarrierAdditionalServiceDAOMutation) CarrierServiceDAOIDs() (ids []pulid.ID) {
	for id := range m.carrier_service_dao {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierServiceDAO resets all changes to the "carrier_service_dao" edge.
func (m *CarrierAdditionalServiceDAOMutation) ResetCarrierServiceDAO() {
	m.carrier_service_dao = nil
	m.clearedcarrier_service_dao = false
	m.removedcarrier_service_dao = nil
}

// AddDeliveryOptionDAOIDs adds the "delivery_option_dao" edge to the DeliveryOptionDAO entity by ids.
func (m *CarrierAdditionalServiceDAOMutation) AddDeliveryOptionDAOIDs(ids ...pulid.ID) {
	if m.delivery_option_dao == nil {
		m.delivery_option_dao = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_dao[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionDAO clears the "delivery_option_dao" edge to the DeliveryOptionDAO entity.
func (m *CarrierAdditionalServiceDAOMutation) ClearDeliveryOptionDAO() {
	m.cleareddelivery_option_dao = true
}

// DeliveryOptionDAOCleared reports if the "delivery_option_dao" edge to the DeliveryOptionDAO entity was cleared.
func (m *CarrierAdditionalServiceDAOMutation) DeliveryOptionDAOCleared() bool {
	return m.cleareddelivery_option_dao
}

// RemoveDeliveryOptionDAOIDs removes the "delivery_option_dao" edge to the DeliveryOptionDAO entity by IDs.
func (m *CarrierAdditionalServiceDAOMutation) RemoveDeliveryOptionDAOIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_dao == nil {
		m.removeddelivery_option_dao = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_dao, ids[i])
		m.removeddelivery_option_dao[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionDAO returns the removed IDs of the "delivery_option_dao" edge to the DeliveryOptionDAO entity.
func (m *CarrierAdditionalServiceDAOMutation) RemovedDeliveryOptionDAOIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_dao {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionDAOIDs returns the "delivery_option_dao" edge IDs in the mutation.
func (m *CarrierAdditionalServiceDAOMutation) DeliveryOptionDAOIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_dao {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionDAO resets all changes to the "delivery_option_dao" edge.
func (m *CarrierAdditionalServiceDAOMutation) ResetDeliveryOptionDAO() {
	m.delivery_option_dao = nil
	m.cleareddelivery_option_dao = false
	m.removeddelivery_option_dao = nil
}

// Where appends a list predicates to the CarrierAdditionalServiceDAOMutation builder.
func (m *CarrierAdditionalServiceDAOMutation) Where(ps ...predicate.CarrierAdditionalServiceDAO) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierAdditionalServiceDAOMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierAdditionalServiceDAOMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierAdditionalServiceDAO, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierAdditionalServiceDAOMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierAdditionalServiceDAOMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierAdditionalServiceDAO).
func (m *CarrierAdditionalServiceDAOMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierAdditionalServiceDAOMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.label != nil {
		fields = append(fields, carrieradditionalservicedao.FieldLabel)
	}
	if m.api_code != nil {
		fields = append(fields, carrieradditionalservicedao.FieldAPICode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierAdditionalServiceDAOMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrieradditionalservicedao.FieldLabel:
		return m.Label()
	case carrieradditionalservicedao.FieldAPICode:
		return m.APICode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierAdditionalServiceDAOMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrieradditionalservicedao.FieldLabel:
		return m.OldLabel(ctx)
	case carrieradditionalservicedao.FieldAPICode:
		return m.OldAPICode(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierAdditionalServiceDAO field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceDAOMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrieradditionalservicedao.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrieradditionalservicedao.FieldAPICode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPICode(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDAO field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierAdditionalServiceDAOMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierAdditionalServiceDAOMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceDAOMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDAO numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierAdditionalServiceDAOMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierAdditionalServiceDAOMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceDAOMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierAdditionalServiceDAO nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceDAOMutation) ResetField(name string) error {
	switch name {
	case carrieradditionalservicedao.FieldLabel:
		m.ResetLabel()
		return nil
	case carrieradditionalservicedao.FieldAPICode:
		m.ResetAPICode()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDAO field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierAdditionalServiceDAOMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service_dao != nil {
		edges = append(edges, carrieradditionalservicedao.EdgeCarrierServiceDAO)
	}
	if m.delivery_option_dao != nil {
		edges = append(edges, carrieradditionalservicedao.EdgeDeliveryOptionDAO)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierAdditionalServiceDAOMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicedao.EdgeCarrierServiceDAO:
		ids := make([]ent.Value, 0, len(m.carrier_service_dao))
		for id := range m.carrier_service_dao {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicedao.EdgeDeliveryOptionDAO:
		ids := make([]ent.Value, 0, len(m.delivery_option_dao))
		for id := range m.delivery_option_dao {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierAdditionalServiceDAOMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_service_dao != nil {
		edges = append(edges, carrieradditionalservicedao.EdgeCarrierServiceDAO)
	}
	if m.removeddelivery_option_dao != nil {
		edges = append(edges, carrieradditionalservicedao.EdgeDeliveryOptionDAO)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierAdditionalServiceDAOMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicedao.EdgeCarrierServiceDAO:
		ids := make([]ent.Value, 0, len(m.removedcarrier_service_dao))
		for id := range m.removedcarrier_service_dao {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicedao.EdgeDeliveryOptionDAO:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_dao))
		for id := range m.removeddelivery_option_dao {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierAdditionalServiceDAOMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service_dao {
		edges = append(edges, carrieradditionalservicedao.EdgeCarrierServiceDAO)
	}
	if m.cleareddelivery_option_dao {
		edges = append(edges, carrieradditionalservicedao.EdgeDeliveryOptionDAO)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierAdditionalServiceDAOMutation) EdgeCleared(name string) bool {
	switch name {
	case carrieradditionalservicedao.EdgeCarrierServiceDAO:
		return m.clearedcarrier_service_dao
	case carrieradditionalservicedao.EdgeDeliveryOptionDAO:
		return m.cleareddelivery_option_dao
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierAdditionalServiceDAOMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDAO unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierAdditionalServiceDAOMutation) ResetEdge(name string) error {
	switch name {
	case carrieradditionalservicedao.EdgeCarrierServiceDAO:
		m.ResetCarrierServiceDAO()
		return nil
	case carrieradditionalservicedao.EdgeDeliveryOptionDAO:
		m.ResetDeliveryOptionDAO()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDAO edge %s", name)
}

// CarrierAdditionalServiceDFMutation represents an operation that mutates the CarrierAdditionalServiceDF nodes in the graph.
type CarrierAdditionalServiceDFMutation struct {
	config
	op                        Op
	typ                       string
	id                        *pulid.ID
	label                     *string
	api_code                  *string
	clearedFields             map[string]struct{}
	carrier_service_df        map[pulid.ID]struct{}
	removedcarrier_service_df map[pulid.ID]struct{}
	clearedcarrier_service_df bool
	delivery_option_df        map[pulid.ID]struct{}
	removeddelivery_option_df map[pulid.ID]struct{}
	cleareddelivery_option_df bool
	done                      bool
	oldValue                  func(context.Context) (*CarrierAdditionalServiceDF, error)
	predicates                []predicate.CarrierAdditionalServiceDF
}

var _ ent.Mutation = (*CarrierAdditionalServiceDFMutation)(nil)

// carrieradditionalservicedfOption allows management of the mutation configuration using functional options.
type carrieradditionalservicedfOption func(*CarrierAdditionalServiceDFMutation)

// newCarrierAdditionalServiceDFMutation creates new mutation for the CarrierAdditionalServiceDF entity.
func newCarrierAdditionalServiceDFMutation(c config, op Op, opts ...carrieradditionalservicedfOption) *CarrierAdditionalServiceDFMutation {
	m := &CarrierAdditionalServiceDFMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierAdditionalServiceDF,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierAdditionalServiceDFID sets the ID field of the mutation.
func withCarrierAdditionalServiceDFID(id pulid.ID) carrieradditionalservicedfOption {
	return func(m *CarrierAdditionalServiceDFMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierAdditionalServiceDF
		)
		m.oldValue = func(ctx context.Context) (*CarrierAdditionalServiceDF, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierAdditionalServiceDF.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierAdditionalServiceDF sets the old CarrierAdditionalServiceDF of the mutation.
func withCarrierAdditionalServiceDF(node *CarrierAdditionalServiceDF) carrieradditionalservicedfOption {
	return func(m *CarrierAdditionalServiceDFMutation) {
		m.oldValue = func(context.Context) (*CarrierAdditionalServiceDF, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierAdditionalServiceDFMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierAdditionalServiceDFMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierAdditionalServiceDF entities.
func (m *CarrierAdditionalServiceDFMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierAdditionalServiceDFMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierAdditionalServiceDFMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierAdditionalServiceDF.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierAdditionalServiceDFMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierAdditionalServiceDFMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierAdditionalServiceDF entity.
// If the CarrierAdditionalServiceDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceDFMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierAdditionalServiceDFMutation) ResetLabel() {
	m.label = nil
}

// SetAPICode sets the "api_code" field.
func (m *CarrierAdditionalServiceDFMutation) SetAPICode(s string) {
	m.api_code = &s
}

// APICode returns the value of the "api_code" field in the mutation.
func (m *CarrierAdditionalServiceDFMutation) APICode() (r string, exists bool) {
	v := m.api_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAPICode returns the old "api_code" field's value of the CarrierAdditionalServiceDF entity.
// If the CarrierAdditionalServiceDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceDFMutation) OldAPICode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPICode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPICode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPICode: %w", err)
	}
	return oldValue.APICode, nil
}

// ResetAPICode resets all changes to the "api_code" field.
func (m *CarrierAdditionalServiceDFMutation) ResetAPICode() {
	m.api_code = nil
}

// AddCarrierServiceDFIDs adds the "carrier_service_df" edge to the CarrierServiceDF entity by ids.
func (m *CarrierAdditionalServiceDFMutation) AddCarrierServiceDFIDs(ids ...pulid.ID) {
	if m.carrier_service_df == nil {
		m.carrier_service_df = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_service_df[ids[i]] = struct{}{}
	}
}

// ClearCarrierServiceDF clears the "carrier_service_df" edge to the CarrierServiceDF entity.
func (m *CarrierAdditionalServiceDFMutation) ClearCarrierServiceDF() {
	m.clearedcarrier_service_df = true
}

// CarrierServiceDFCleared reports if the "carrier_service_df" edge to the CarrierServiceDF entity was cleared.
func (m *CarrierAdditionalServiceDFMutation) CarrierServiceDFCleared() bool {
	return m.clearedcarrier_service_df
}

// RemoveCarrierServiceDFIDs removes the "carrier_service_df" edge to the CarrierServiceDF entity by IDs.
func (m *CarrierAdditionalServiceDFMutation) RemoveCarrierServiceDFIDs(ids ...pulid.ID) {
	if m.removedcarrier_service_df == nil {
		m.removedcarrier_service_df = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_service_df, ids[i])
		m.removedcarrier_service_df[ids[i]] = struct{}{}
	}
}

// RemovedCarrierServiceDF returns the removed IDs of the "carrier_service_df" edge to the CarrierServiceDF entity.
func (m *CarrierAdditionalServiceDFMutation) RemovedCarrierServiceDFIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_service_df {
		ids = append(ids, id)
	}
	return
}

// CarrierServiceDFIDs returns the "carrier_service_df" edge IDs in the mutation.
func (m *CarrierAdditionalServiceDFMutation) CarrierServiceDFIDs() (ids []pulid.ID) {
	for id := range m.carrier_service_df {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierServiceDF resets all changes to the "carrier_service_df" edge.
func (m *CarrierAdditionalServiceDFMutation) ResetCarrierServiceDF() {
	m.carrier_service_df = nil
	m.clearedcarrier_service_df = false
	m.removedcarrier_service_df = nil
}

// AddDeliveryOptionDFIDs adds the "delivery_option_df" edge to the DeliveryOptionDF entity by ids.
func (m *CarrierAdditionalServiceDFMutation) AddDeliveryOptionDFIDs(ids ...pulid.ID) {
	if m.delivery_option_df == nil {
		m.delivery_option_df = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_df[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionDF clears the "delivery_option_df" edge to the DeliveryOptionDF entity.
func (m *CarrierAdditionalServiceDFMutation) ClearDeliveryOptionDF() {
	m.cleareddelivery_option_df = true
}

// DeliveryOptionDFCleared reports if the "delivery_option_df" edge to the DeliveryOptionDF entity was cleared.
func (m *CarrierAdditionalServiceDFMutation) DeliveryOptionDFCleared() bool {
	return m.cleareddelivery_option_df
}

// RemoveDeliveryOptionDFIDs removes the "delivery_option_df" edge to the DeliveryOptionDF entity by IDs.
func (m *CarrierAdditionalServiceDFMutation) RemoveDeliveryOptionDFIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_df == nil {
		m.removeddelivery_option_df = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_df, ids[i])
		m.removeddelivery_option_df[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionDF returns the removed IDs of the "delivery_option_df" edge to the DeliveryOptionDF entity.
func (m *CarrierAdditionalServiceDFMutation) RemovedDeliveryOptionDFIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_df {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionDFIDs returns the "delivery_option_df" edge IDs in the mutation.
func (m *CarrierAdditionalServiceDFMutation) DeliveryOptionDFIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_df {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionDF resets all changes to the "delivery_option_df" edge.
func (m *CarrierAdditionalServiceDFMutation) ResetDeliveryOptionDF() {
	m.delivery_option_df = nil
	m.cleareddelivery_option_df = false
	m.removeddelivery_option_df = nil
}

// Where appends a list predicates to the CarrierAdditionalServiceDFMutation builder.
func (m *CarrierAdditionalServiceDFMutation) Where(ps ...predicate.CarrierAdditionalServiceDF) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierAdditionalServiceDFMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierAdditionalServiceDFMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierAdditionalServiceDF, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierAdditionalServiceDFMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierAdditionalServiceDFMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierAdditionalServiceDF).
func (m *CarrierAdditionalServiceDFMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierAdditionalServiceDFMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.label != nil {
		fields = append(fields, carrieradditionalservicedf.FieldLabel)
	}
	if m.api_code != nil {
		fields = append(fields, carrieradditionalservicedf.FieldAPICode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierAdditionalServiceDFMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrieradditionalservicedf.FieldLabel:
		return m.Label()
	case carrieradditionalservicedf.FieldAPICode:
		return m.APICode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierAdditionalServiceDFMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrieradditionalservicedf.FieldLabel:
		return m.OldLabel(ctx)
	case carrieradditionalservicedf.FieldAPICode:
		return m.OldAPICode(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierAdditionalServiceDF field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceDFMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrieradditionalservicedf.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrieradditionalservicedf.FieldAPICode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPICode(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDF field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierAdditionalServiceDFMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierAdditionalServiceDFMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceDFMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDF numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierAdditionalServiceDFMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierAdditionalServiceDFMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceDFMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierAdditionalServiceDF nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceDFMutation) ResetField(name string) error {
	switch name {
	case carrieradditionalservicedf.FieldLabel:
		m.ResetLabel()
		return nil
	case carrieradditionalservicedf.FieldAPICode:
		m.ResetAPICode()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDF field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierAdditionalServiceDFMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service_df != nil {
		edges = append(edges, carrieradditionalservicedf.EdgeCarrierServiceDF)
	}
	if m.delivery_option_df != nil {
		edges = append(edges, carrieradditionalservicedf.EdgeDeliveryOptionDF)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierAdditionalServiceDFMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicedf.EdgeCarrierServiceDF:
		ids := make([]ent.Value, 0, len(m.carrier_service_df))
		for id := range m.carrier_service_df {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicedf.EdgeDeliveryOptionDF:
		ids := make([]ent.Value, 0, len(m.delivery_option_df))
		for id := range m.delivery_option_df {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierAdditionalServiceDFMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_service_df != nil {
		edges = append(edges, carrieradditionalservicedf.EdgeCarrierServiceDF)
	}
	if m.removeddelivery_option_df != nil {
		edges = append(edges, carrieradditionalservicedf.EdgeDeliveryOptionDF)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierAdditionalServiceDFMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicedf.EdgeCarrierServiceDF:
		ids := make([]ent.Value, 0, len(m.removedcarrier_service_df))
		for id := range m.removedcarrier_service_df {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicedf.EdgeDeliveryOptionDF:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_df))
		for id := range m.removeddelivery_option_df {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierAdditionalServiceDFMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service_df {
		edges = append(edges, carrieradditionalservicedf.EdgeCarrierServiceDF)
	}
	if m.cleareddelivery_option_df {
		edges = append(edges, carrieradditionalservicedf.EdgeDeliveryOptionDF)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierAdditionalServiceDFMutation) EdgeCleared(name string) bool {
	switch name {
	case carrieradditionalservicedf.EdgeCarrierServiceDF:
		return m.clearedcarrier_service_df
	case carrieradditionalservicedf.EdgeDeliveryOptionDF:
		return m.cleareddelivery_option_df
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierAdditionalServiceDFMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDF unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierAdditionalServiceDFMutation) ResetEdge(name string) error {
	switch name {
	case carrieradditionalservicedf.EdgeCarrierServiceDF:
		m.ResetCarrierServiceDF()
		return nil
	case carrieradditionalservicedf.EdgeDeliveryOptionDF:
		m.ResetDeliveryOptionDF()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDF edge %s", name)
}

// CarrierAdditionalServiceDSVMutation represents an operation that mutates the CarrierAdditionalServiceDSV nodes in the graph.
type CarrierAdditionalServiceDSVMutation struct {
	config
	op                         Op
	typ                        string
	id                         *pulid.ID
	label                      *string
	api_code                   *string
	clearedFields              map[string]struct{}
	carrier_service_dsv        map[pulid.ID]struct{}
	removedcarrier_service_dsv map[pulid.ID]struct{}
	clearedcarrier_service_dsv bool
	delivery_option_dsv        map[pulid.ID]struct{}
	removeddelivery_option_dsv map[pulid.ID]struct{}
	cleareddelivery_option_dsv bool
	done                       bool
	oldValue                   func(context.Context) (*CarrierAdditionalServiceDSV, error)
	predicates                 []predicate.CarrierAdditionalServiceDSV
}

var _ ent.Mutation = (*CarrierAdditionalServiceDSVMutation)(nil)

// carrieradditionalservicedsvOption allows management of the mutation configuration using functional options.
type carrieradditionalservicedsvOption func(*CarrierAdditionalServiceDSVMutation)

// newCarrierAdditionalServiceDSVMutation creates new mutation for the CarrierAdditionalServiceDSV entity.
func newCarrierAdditionalServiceDSVMutation(c config, op Op, opts ...carrieradditionalservicedsvOption) *CarrierAdditionalServiceDSVMutation {
	m := &CarrierAdditionalServiceDSVMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierAdditionalServiceDSV,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierAdditionalServiceDSVID sets the ID field of the mutation.
func withCarrierAdditionalServiceDSVID(id pulid.ID) carrieradditionalservicedsvOption {
	return func(m *CarrierAdditionalServiceDSVMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierAdditionalServiceDSV
		)
		m.oldValue = func(ctx context.Context) (*CarrierAdditionalServiceDSV, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierAdditionalServiceDSV.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierAdditionalServiceDSV sets the old CarrierAdditionalServiceDSV of the mutation.
func withCarrierAdditionalServiceDSV(node *CarrierAdditionalServiceDSV) carrieradditionalservicedsvOption {
	return func(m *CarrierAdditionalServiceDSVMutation) {
		m.oldValue = func(context.Context) (*CarrierAdditionalServiceDSV, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierAdditionalServiceDSVMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierAdditionalServiceDSVMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierAdditionalServiceDSV entities.
func (m *CarrierAdditionalServiceDSVMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierAdditionalServiceDSVMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierAdditionalServiceDSVMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierAdditionalServiceDSV.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierAdditionalServiceDSVMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierAdditionalServiceDSVMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierAdditionalServiceDSV entity.
// If the CarrierAdditionalServiceDSV object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceDSVMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierAdditionalServiceDSVMutation) ResetLabel() {
	m.label = nil
}

// SetAPICode sets the "api_code" field.
func (m *CarrierAdditionalServiceDSVMutation) SetAPICode(s string) {
	m.api_code = &s
}

// APICode returns the value of the "api_code" field in the mutation.
func (m *CarrierAdditionalServiceDSVMutation) APICode() (r string, exists bool) {
	v := m.api_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAPICode returns the old "api_code" field's value of the CarrierAdditionalServiceDSV entity.
// If the CarrierAdditionalServiceDSV object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceDSVMutation) OldAPICode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPICode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPICode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPICode: %w", err)
	}
	return oldValue.APICode, nil
}

// ResetAPICode resets all changes to the "api_code" field.
func (m *CarrierAdditionalServiceDSVMutation) ResetAPICode() {
	m.api_code = nil
}

// AddCarrierServiceDSVIDs adds the "carrier_service_dsv" edge to the CarrierServiceDSV entity by ids.
func (m *CarrierAdditionalServiceDSVMutation) AddCarrierServiceDSVIDs(ids ...pulid.ID) {
	if m.carrier_service_dsv == nil {
		m.carrier_service_dsv = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_service_dsv[ids[i]] = struct{}{}
	}
}

// ClearCarrierServiceDSV clears the "carrier_service_dsv" edge to the CarrierServiceDSV entity.
func (m *CarrierAdditionalServiceDSVMutation) ClearCarrierServiceDSV() {
	m.clearedcarrier_service_dsv = true
}

// CarrierServiceDSVCleared reports if the "carrier_service_dsv" edge to the CarrierServiceDSV entity was cleared.
func (m *CarrierAdditionalServiceDSVMutation) CarrierServiceDSVCleared() bool {
	return m.clearedcarrier_service_dsv
}

// RemoveCarrierServiceDSVIDs removes the "carrier_service_dsv" edge to the CarrierServiceDSV entity by IDs.
func (m *CarrierAdditionalServiceDSVMutation) RemoveCarrierServiceDSVIDs(ids ...pulid.ID) {
	if m.removedcarrier_service_dsv == nil {
		m.removedcarrier_service_dsv = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_service_dsv, ids[i])
		m.removedcarrier_service_dsv[ids[i]] = struct{}{}
	}
}

// RemovedCarrierServiceDSV returns the removed IDs of the "carrier_service_dsv" edge to the CarrierServiceDSV entity.
func (m *CarrierAdditionalServiceDSVMutation) RemovedCarrierServiceDSVIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_service_dsv {
		ids = append(ids, id)
	}
	return
}

// CarrierServiceDSVIDs returns the "carrier_service_dsv" edge IDs in the mutation.
func (m *CarrierAdditionalServiceDSVMutation) CarrierServiceDSVIDs() (ids []pulid.ID) {
	for id := range m.carrier_service_dsv {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierServiceDSV resets all changes to the "carrier_service_dsv" edge.
func (m *CarrierAdditionalServiceDSVMutation) ResetCarrierServiceDSV() {
	m.carrier_service_dsv = nil
	m.clearedcarrier_service_dsv = false
	m.removedcarrier_service_dsv = nil
}

// AddDeliveryOptionDSVIDs adds the "delivery_option_dsv" edge to the DeliveryOptionDSV entity by ids.
func (m *CarrierAdditionalServiceDSVMutation) AddDeliveryOptionDSVIDs(ids ...pulid.ID) {
	if m.delivery_option_dsv == nil {
		m.delivery_option_dsv = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_dsv[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionDSV clears the "delivery_option_dsv" edge to the DeliveryOptionDSV entity.
func (m *CarrierAdditionalServiceDSVMutation) ClearDeliveryOptionDSV() {
	m.cleareddelivery_option_dsv = true
}

// DeliveryOptionDSVCleared reports if the "delivery_option_dsv" edge to the DeliveryOptionDSV entity was cleared.
func (m *CarrierAdditionalServiceDSVMutation) DeliveryOptionDSVCleared() bool {
	return m.cleareddelivery_option_dsv
}

// RemoveDeliveryOptionDSVIDs removes the "delivery_option_dsv" edge to the DeliveryOptionDSV entity by IDs.
func (m *CarrierAdditionalServiceDSVMutation) RemoveDeliveryOptionDSVIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_dsv == nil {
		m.removeddelivery_option_dsv = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_dsv, ids[i])
		m.removeddelivery_option_dsv[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionDSV returns the removed IDs of the "delivery_option_dsv" edge to the DeliveryOptionDSV entity.
func (m *CarrierAdditionalServiceDSVMutation) RemovedDeliveryOptionDSVIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_dsv {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionDSVIDs returns the "delivery_option_dsv" edge IDs in the mutation.
func (m *CarrierAdditionalServiceDSVMutation) DeliveryOptionDSVIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_dsv {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionDSV resets all changes to the "delivery_option_dsv" edge.
func (m *CarrierAdditionalServiceDSVMutation) ResetDeliveryOptionDSV() {
	m.delivery_option_dsv = nil
	m.cleareddelivery_option_dsv = false
	m.removeddelivery_option_dsv = nil
}

// Where appends a list predicates to the CarrierAdditionalServiceDSVMutation builder.
func (m *CarrierAdditionalServiceDSVMutation) Where(ps ...predicate.CarrierAdditionalServiceDSV) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierAdditionalServiceDSVMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierAdditionalServiceDSVMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierAdditionalServiceDSV, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierAdditionalServiceDSVMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierAdditionalServiceDSVMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierAdditionalServiceDSV).
func (m *CarrierAdditionalServiceDSVMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierAdditionalServiceDSVMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.label != nil {
		fields = append(fields, carrieradditionalservicedsv.FieldLabel)
	}
	if m.api_code != nil {
		fields = append(fields, carrieradditionalservicedsv.FieldAPICode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierAdditionalServiceDSVMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrieradditionalservicedsv.FieldLabel:
		return m.Label()
	case carrieradditionalservicedsv.FieldAPICode:
		return m.APICode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierAdditionalServiceDSVMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrieradditionalservicedsv.FieldLabel:
		return m.OldLabel(ctx)
	case carrieradditionalservicedsv.FieldAPICode:
		return m.OldAPICode(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierAdditionalServiceDSV field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceDSVMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrieradditionalservicedsv.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrieradditionalservicedsv.FieldAPICode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPICode(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDSV field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierAdditionalServiceDSVMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierAdditionalServiceDSVMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceDSVMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDSV numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierAdditionalServiceDSVMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierAdditionalServiceDSVMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceDSVMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierAdditionalServiceDSV nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceDSVMutation) ResetField(name string) error {
	switch name {
	case carrieradditionalservicedsv.FieldLabel:
		m.ResetLabel()
		return nil
	case carrieradditionalservicedsv.FieldAPICode:
		m.ResetAPICode()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDSV field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierAdditionalServiceDSVMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service_dsv != nil {
		edges = append(edges, carrieradditionalservicedsv.EdgeCarrierServiceDSV)
	}
	if m.delivery_option_dsv != nil {
		edges = append(edges, carrieradditionalservicedsv.EdgeDeliveryOptionDSV)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierAdditionalServiceDSVMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicedsv.EdgeCarrierServiceDSV:
		ids := make([]ent.Value, 0, len(m.carrier_service_dsv))
		for id := range m.carrier_service_dsv {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicedsv.EdgeDeliveryOptionDSV:
		ids := make([]ent.Value, 0, len(m.delivery_option_dsv))
		for id := range m.delivery_option_dsv {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierAdditionalServiceDSVMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_service_dsv != nil {
		edges = append(edges, carrieradditionalservicedsv.EdgeCarrierServiceDSV)
	}
	if m.removeddelivery_option_dsv != nil {
		edges = append(edges, carrieradditionalservicedsv.EdgeDeliveryOptionDSV)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierAdditionalServiceDSVMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicedsv.EdgeCarrierServiceDSV:
		ids := make([]ent.Value, 0, len(m.removedcarrier_service_dsv))
		for id := range m.removedcarrier_service_dsv {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicedsv.EdgeDeliveryOptionDSV:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_dsv))
		for id := range m.removeddelivery_option_dsv {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierAdditionalServiceDSVMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service_dsv {
		edges = append(edges, carrieradditionalservicedsv.EdgeCarrierServiceDSV)
	}
	if m.cleareddelivery_option_dsv {
		edges = append(edges, carrieradditionalservicedsv.EdgeDeliveryOptionDSV)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierAdditionalServiceDSVMutation) EdgeCleared(name string) bool {
	switch name {
	case carrieradditionalservicedsv.EdgeCarrierServiceDSV:
		return m.clearedcarrier_service_dsv
	case carrieradditionalservicedsv.EdgeDeliveryOptionDSV:
		return m.cleareddelivery_option_dsv
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierAdditionalServiceDSVMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDSV unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierAdditionalServiceDSVMutation) ResetEdge(name string) error {
	switch name {
	case carrieradditionalservicedsv.EdgeCarrierServiceDSV:
		m.ResetCarrierServiceDSV()
		return nil
	case carrieradditionalservicedsv.EdgeDeliveryOptionDSV:
		m.ResetDeliveryOptionDSV()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceDSV edge %s", name)
}

// CarrierAdditionalServiceEasyPostMutation represents an operation that mutates the CarrierAdditionalServiceEasyPost nodes in the graph.
type CarrierAdditionalServiceEasyPostMutation struct {
	config
	op                               Op
	typ                              string
	id                               *pulid.ID
	label                            *string
	api_key                          *string
	api_value                        *string
	clearedFields                    map[string]struct{}
	carrier_service_easy_post        map[pulid.ID]struct{}
	removedcarrier_service_easy_post map[pulid.ID]struct{}
	clearedcarrier_service_easy_post bool
	delivery_option_easy_post        map[pulid.ID]struct{}
	removeddelivery_option_easy_post map[pulid.ID]struct{}
	cleareddelivery_option_easy_post bool
	done                             bool
	oldValue                         func(context.Context) (*CarrierAdditionalServiceEasyPost, error)
	predicates                       []predicate.CarrierAdditionalServiceEasyPost
}

var _ ent.Mutation = (*CarrierAdditionalServiceEasyPostMutation)(nil)

// carrieradditionalserviceeasypostOption allows management of the mutation configuration using functional options.
type carrieradditionalserviceeasypostOption func(*CarrierAdditionalServiceEasyPostMutation)

// newCarrierAdditionalServiceEasyPostMutation creates new mutation for the CarrierAdditionalServiceEasyPost entity.
func newCarrierAdditionalServiceEasyPostMutation(c config, op Op, opts ...carrieradditionalserviceeasypostOption) *CarrierAdditionalServiceEasyPostMutation {
	m := &CarrierAdditionalServiceEasyPostMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierAdditionalServiceEasyPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierAdditionalServiceEasyPostID sets the ID field of the mutation.
func withCarrierAdditionalServiceEasyPostID(id pulid.ID) carrieradditionalserviceeasypostOption {
	return func(m *CarrierAdditionalServiceEasyPostMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierAdditionalServiceEasyPost
		)
		m.oldValue = func(ctx context.Context) (*CarrierAdditionalServiceEasyPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierAdditionalServiceEasyPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierAdditionalServiceEasyPost sets the old CarrierAdditionalServiceEasyPost of the mutation.
func withCarrierAdditionalServiceEasyPost(node *CarrierAdditionalServiceEasyPost) carrieradditionalserviceeasypostOption {
	return func(m *CarrierAdditionalServiceEasyPostMutation) {
		m.oldValue = func(context.Context) (*CarrierAdditionalServiceEasyPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierAdditionalServiceEasyPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierAdditionalServiceEasyPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierAdditionalServiceEasyPost entities.
func (m *CarrierAdditionalServiceEasyPostMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierAdditionalServiceEasyPostMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierAdditionalServiceEasyPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierAdditionalServiceEasyPostMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierAdditionalServiceEasyPost entity.
// If the CarrierAdditionalServiceEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceEasyPostMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierAdditionalServiceEasyPostMutation) ResetLabel() {
	m.label = nil
}

// SetAPIKey sets the "api_key" field.
func (m *CarrierAdditionalServiceEasyPostMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the CarrierAdditionalServiceEasyPost entity.
// If the CarrierAdditionalServiceEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceEasyPostMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *CarrierAdditionalServiceEasyPostMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetAPIValue sets the "api_value" field.
func (m *CarrierAdditionalServiceEasyPostMutation) SetAPIValue(s string) {
	m.api_value = &s
}

// APIValue returns the value of the "api_value" field in the mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) APIValue() (r string, exists bool) {
	v := m.api_value
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIValue returns the old "api_value" field's value of the CarrierAdditionalServiceEasyPost entity.
// If the CarrierAdditionalServiceEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceEasyPostMutation) OldAPIValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIValue: %w", err)
	}
	return oldValue.APIValue, nil
}

// ResetAPIValue resets all changes to the "api_value" field.
func (m *CarrierAdditionalServiceEasyPostMutation) ResetAPIValue() {
	m.api_value = nil
}

// AddCarrierServiceEasyPostIDs adds the "carrier_service_easy_post" edge to the CarrierServiceEasyPost entity by ids.
func (m *CarrierAdditionalServiceEasyPostMutation) AddCarrierServiceEasyPostIDs(ids ...pulid.ID) {
	if m.carrier_service_easy_post == nil {
		m.carrier_service_easy_post = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_service_easy_post[ids[i]] = struct{}{}
	}
}

// ClearCarrierServiceEasyPost clears the "carrier_service_easy_post" edge to the CarrierServiceEasyPost entity.
func (m *CarrierAdditionalServiceEasyPostMutation) ClearCarrierServiceEasyPost() {
	m.clearedcarrier_service_easy_post = true
}

// CarrierServiceEasyPostCleared reports if the "carrier_service_easy_post" edge to the CarrierServiceEasyPost entity was cleared.
func (m *CarrierAdditionalServiceEasyPostMutation) CarrierServiceEasyPostCleared() bool {
	return m.clearedcarrier_service_easy_post
}

// RemoveCarrierServiceEasyPostIDs removes the "carrier_service_easy_post" edge to the CarrierServiceEasyPost entity by IDs.
func (m *CarrierAdditionalServiceEasyPostMutation) RemoveCarrierServiceEasyPostIDs(ids ...pulid.ID) {
	if m.removedcarrier_service_easy_post == nil {
		m.removedcarrier_service_easy_post = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_service_easy_post, ids[i])
		m.removedcarrier_service_easy_post[ids[i]] = struct{}{}
	}
}

// RemovedCarrierServiceEasyPost returns the removed IDs of the "carrier_service_easy_post" edge to the CarrierServiceEasyPost entity.
func (m *CarrierAdditionalServiceEasyPostMutation) RemovedCarrierServiceEasyPostIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_service_easy_post {
		ids = append(ids, id)
	}
	return
}

// CarrierServiceEasyPostIDs returns the "carrier_service_easy_post" edge IDs in the mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) CarrierServiceEasyPostIDs() (ids []pulid.ID) {
	for id := range m.carrier_service_easy_post {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierServiceEasyPost resets all changes to the "carrier_service_easy_post" edge.
func (m *CarrierAdditionalServiceEasyPostMutation) ResetCarrierServiceEasyPost() {
	m.carrier_service_easy_post = nil
	m.clearedcarrier_service_easy_post = false
	m.removedcarrier_service_easy_post = nil
}

// AddDeliveryOptionEasyPostIDs adds the "delivery_option_easy_post" edge to the DeliveryOptionEasyPost entity by ids.
func (m *CarrierAdditionalServiceEasyPostMutation) AddDeliveryOptionEasyPostIDs(ids ...pulid.ID) {
	if m.delivery_option_easy_post == nil {
		m.delivery_option_easy_post = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_easy_post[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionEasyPost clears the "delivery_option_easy_post" edge to the DeliveryOptionEasyPost entity.
func (m *CarrierAdditionalServiceEasyPostMutation) ClearDeliveryOptionEasyPost() {
	m.cleareddelivery_option_easy_post = true
}

// DeliveryOptionEasyPostCleared reports if the "delivery_option_easy_post" edge to the DeliveryOptionEasyPost entity was cleared.
func (m *CarrierAdditionalServiceEasyPostMutation) DeliveryOptionEasyPostCleared() bool {
	return m.cleareddelivery_option_easy_post
}

// RemoveDeliveryOptionEasyPostIDs removes the "delivery_option_easy_post" edge to the DeliveryOptionEasyPost entity by IDs.
func (m *CarrierAdditionalServiceEasyPostMutation) RemoveDeliveryOptionEasyPostIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_easy_post == nil {
		m.removeddelivery_option_easy_post = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_easy_post, ids[i])
		m.removeddelivery_option_easy_post[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionEasyPost returns the removed IDs of the "delivery_option_easy_post" edge to the DeliveryOptionEasyPost entity.
func (m *CarrierAdditionalServiceEasyPostMutation) RemovedDeliveryOptionEasyPostIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_easy_post {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionEasyPostIDs returns the "delivery_option_easy_post" edge IDs in the mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) DeliveryOptionEasyPostIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_easy_post {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionEasyPost resets all changes to the "delivery_option_easy_post" edge.
func (m *CarrierAdditionalServiceEasyPostMutation) ResetDeliveryOptionEasyPost() {
	m.delivery_option_easy_post = nil
	m.cleareddelivery_option_easy_post = false
	m.removeddelivery_option_easy_post = nil
}

// Where appends a list predicates to the CarrierAdditionalServiceEasyPostMutation builder.
func (m *CarrierAdditionalServiceEasyPostMutation) Where(ps ...predicate.CarrierAdditionalServiceEasyPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierAdditionalServiceEasyPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierAdditionalServiceEasyPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierAdditionalServiceEasyPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierAdditionalServiceEasyPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierAdditionalServiceEasyPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierAdditionalServiceEasyPost).
func (m *CarrierAdditionalServiceEasyPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierAdditionalServiceEasyPostMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.label != nil {
		fields = append(fields, carrieradditionalserviceeasypost.FieldLabel)
	}
	if m.api_key != nil {
		fields = append(fields, carrieradditionalserviceeasypost.FieldAPIKey)
	}
	if m.api_value != nil {
		fields = append(fields, carrieradditionalserviceeasypost.FieldAPIValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierAdditionalServiceEasyPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrieradditionalserviceeasypost.FieldLabel:
		return m.Label()
	case carrieradditionalserviceeasypost.FieldAPIKey:
		return m.APIKey()
	case carrieradditionalserviceeasypost.FieldAPIValue:
		return m.APIValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierAdditionalServiceEasyPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrieradditionalserviceeasypost.FieldLabel:
		return m.OldLabel(ctx)
	case carrieradditionalserviceeasypost.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case carrieradditionalserviceeasypost.FieldAPIValue:
		return m.OldAPIValue(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierAdditionalServiceEasyPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceEasyPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrieradditionalserviceeasypost.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrieradditionalserviceeasypost.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case carrieradditionalserviceeasypost.FieldAPIValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIValue(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceEasyPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierAdditionalServiceEasyPostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceEasyPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceEasyPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceEasyPostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierAdditionalServiceEasyPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceEasyPostMutation) ResetField(name string) error {
	switch name {
	case carrieradditionalserviceeasypost.FieldLabel:
		m.ResetLabel()
		return nil
	case carrieradditionalserviceeasypost.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case carrieradditionalserviceeasypost.FieldAPIValue:
		m.ResetAPIValue()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceEasyPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service_easy_post != nil {
		edges = append(edges, carrieradditionalserviceeasypost.EdgeCarrierServiceEasyPost)
	}
	if m.delivery_option_easy_post != nil {
		edges = append(edges, carrieradditionalserviceeasypost.EdgeDeliveryOptionEasyPost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalserviceeasypost.EdgeCarrierServiceEasyPost:
		ids := make([]ent.Value, 0, len(m.carrier_service_easy_post))
		for id := range m.carrier_service_easy_post {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalserviceeasypost.EdgeDeliveryOptionEasyPost:
		ids := make([]ent.Value, 0, len(m.delivery_option_easy_post))
		for id := range m.delivery_option_easy_post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_service_easy_post != nil {
		edges = append(edges, carrieradditionalserviceeasypost.EdgeCarrierServiceEasyPost)
	}
	if m.removeddelivery_option_easy_post != nil {
		edges = append(edges, carrieradditionalserviceeasypost.EdgeDeliveryOptionEasyPost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalserviceeasypost.EdgeCarrierServiceEasyPost:
		ids := make([]ent.Value, 0, len(m.removedcarrier_service_easy_post))
		for id := range m.removedcarrier_service_easy_post {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalserviceeasypost.EdgeDeliveryOptionEasyPost:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_easy_post))
		for id := range m.removeddelivery_option_easy_post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service_easy_post {
		edges = append(edges, carrieradditionalserviceeasypost.EdgeCarrierServiceEasyPost)
	}
	if m.cleareddelivery_option_easy_post {
		edges = append(edges, carrieradditionalserviceeasypost.EdgeDeliveryOptionEasyPost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierAdditionalServiceEasyPostMutation) EdgeCleared(name string) bool {
	switch name {
	case carrieradditionalserviceeasypost.EdgeCarrierServiceEasyPost:
		return m.clearedcarrier_service_easy_post
	case carrieradditionalserviceeasypost.EdgeDeliveryOptionEasyPost:
		return m.cleareddelivery_option_easy_post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierAdditionalServiceEasyPostMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceEasyPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierAdditionalServiceEasyPostMutation) ResetEdge(name string) error {
	switch name {
	case carrieradditionalserviceeasypost.EdgeCarrierServiceEasyPost:
		m.ResetCarrierServiceEasyPost()
		return nil
	case carrieradditionalserviceeasypost.EdgeDeliveryOptionEasyPost:
		m.ResetDeliveryOptionEasyPost()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceEasyPost edge %s", name)
}

// CarrierAdditionalServiceGLSMutation represents an operation that mutates the CarrierAdditionalServiceGLS nodes in the graph.
type CarrierAdditionalServiceGLSMutation struct {
	config
	op                         Op
	typ                        string
	id                         *pulid.ID
	label                      *string
	mandatory                  *bool
	all_countries_consignor    *bool
	all_countries_consignee    *bool
	internal_id                *string
	clearedFields              map[string]struct{}
	carrier_service_gls        *pulid.ID
	clearedcarrier_service_gls bool
	delivery_option_gls        map[pulid.ID]struct{}
	removeddelivery_option_gls map[pulid.ID]struct{}
	cleareddelivery_option_gls bool
	countries_consignee        map[pulid.ID]struct{}
	removedcountries_consignee map[pulid.ID]struct{}
	clearedcountries_consignee bool
	countries_consignor        map[pulid.ID]struct{}
	removedcountries_consignor map[pulid.ID]struct{}
	clearedcountries_consignor bool
	done                       bool
	oldValue                   func(context.Context) (*CarrierAdditionalServiceGLS, error)
	predicates                 []predicate.CarrierAdditionalServiceGLS
}

var _ ent.Mutation = (*CarrierAdditionalServiceGLSMutation)(nil)

// carrieradditionalserviceglsOption allows management of the mutation configuration using functional options.
type carrieradditionalserviceglsOption func(*CarrierAdditionalServiceGLSMutation)

// newCarrierAdditionalServiceGLSMutation creates new mutation for the CarrierAdditionalServiceGLS entity.
func newCarrierAdditionalServiceGLSMutation(c config, op Op, opts ...carrieradditionalserviceglsOption) *CarrierAdditionalServiceGLSMutation {
	m := &CarrierAdditionalServiceGLSMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierAdditionalServiceGLS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierAdditionalServiceGLSID sets the ID field of the mutation.
func withCarrierAdditionalServiceGLSID(id pulid.ID) carrieradditionalserviceglsOption {
	return func(m *CarrierAdditionalServiceGLSMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierAdditionalServiceGLS
		)
		m.oldValue = func(ctx context.Context) (*CarrierAdditionalServiceGLS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierAdditionalServiceGLS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierAdditionalServiceGLS sets the old CarrierAdditionalServiceGLS of the mutation.
func withCarrierAdditionalServiceGLS(node *CarrierAdditionalServiceGLS) carrieradditionalserviceglsOption {
	return func(m *CarrierAdditionalServiceGLSMutation) {
		m.oldValue = func(context.Context) (*CarrierAdditionalServiceGLS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierAdditionalServiceGLSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierAdditionalServiceGLSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierAdditionalServiceGLS entities.
func (m *CarrierAdditionalServiceGLSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierAdditionalServiceGLSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierAdditionalServiceGLSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierAdditionalServiceGLS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierAdditionalServiceGLSMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierAdditionalServiceGLSMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierAdditionalServiceGLS entity.
// If the CarrierAdditionalServiceGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceGLSMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierAdditionalServiceGLSMutation) ResetLabel() {
	m.label = nil
}

// SetMandatory sets the "mandatory" field.
func (m *CarrierAdditionalServiceGLSMutation) SetMandatory(b bool) {
	m.mandatory = &b
}

// Mandatory returns the value of the "mandatory" field in the mutation.
func (m *CarrierAdditionalServiceGLSMutation) Mandatory() (r bool, exists bool) {
	v := m.mandatory
	if v == nil {
		return
	}
	return *v, true
}

// OldMandatory returns the old "mandatory" field's value of the CarrierAdditionalServiceGLS entity.
// If the CarrierAdditionalServiceGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceGLSMutation) OldMandatory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMandatory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMandatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMandatory: %w", err)
	}
	return oldValue.Mandatory, nil
}

// ResetMandatory resets all changes to the "mandatory" field.
func (m *CarrierAdditionalServiceGLSMutation) ResetMandatory() {
	m.mandatory = nil
}

// SetAllCountriesConsignor sets the "all_countries_consignor" field.
func (m *CarrierAdditionalServiceGLSMutation) SetAllCountriesConsignor(b bool) {
	m.all_countries_consignor = &b
}

// AllCountriesConsignor returns the value of the "all_countries_consignor" field in the mutation.
func (m *CarrierAdditionalServiceGLSMutation) AllCountriesConsignor() (r bool, exists bool) {
	v := m.all_countries_consignor
	if v == nil {
		return
	}
	return *v, true
}

// OldAllCountriesConsignor returns the old "all_countries_consignor" field's value of the CarrierAdditionalServiceGLS entity.
// If the CarrierAdditionalServiceGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceGLSMutation) OldAllCountriesConsignor(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllCountriesConsignor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllCountriesConsignor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllCountriesConsignor: %w", err)
	}
	return oldValue.AllCountriesConsignor, nil
}

// ResetAllCountriesConsignor resets all changes to the "all_countries_consignor" field.
func (m *CarrierAdditionalServiceGLSMutation) ResetAllCountriesConsignor() {
	m.all_countries_consignor = nil
}

// SetAllCountriesConsignee sets the "all_countries_consignee" field.
func (m *CarrierAdditionalServiceGLSMutation) SetAllCountriesConsignee(b bool) {
	m.all_countries_consignee = &b
}

// AllCountriesConsignee returns the value of the "all_countries_consignee" field in the mutation.
func (m *CarrierAdditionalServiceGLSMutation) AllCountriesConsignee() (r bool, exists bool) {
	v := m.all_countries_consignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAllCountriesConsignee returns the old "all_countries_consignee" field's value of the CarrierAdditionalServiceGLS entity.
// If the CarrierAdditionalServiceGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceGLSMutation) OldAllCountriesConsignee(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllCountriesConsignee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllCountriesConsignee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllCountriesConsignee: %w", err)
	}
	return oldValue.AllCountriesConsignee, nil
}

// ResetAllCountriesConsignee resets all changes to the "all_countries_consignee" field.
func (m *CarrierAdditionalServiceGLSMutation) ResetAllCountriesConsignee() {
	m.all_countries_consignee = nil
}

// SetInternalID sets the "internal_id" field.
func (m *CarrierAdditionalServiceGLSMutation) SetInternalID(s string) {
	m.internal_id = &s
}

// InternalID returns the value of the "internal_id" field in the mutation.
func (m *CarrierAdditionalServiceGLSMutation) InternalID() (r string, exists bool) {
	v := m.internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalID returns the old "internal_id" field's value of the CarrierAdditionalServiceGLS entity.
// If the CarrierAdditionalServiceGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceGLSMutation) OldInternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalID: %w", err)
	}
	return oldValue.InternalID, nil
}

// ResetInternalID resets all changes to the "internal_id" field.
func (m *CarrierAdditionalServiceGLSMutation) ResetInternalID() {
	m.internal_id = nil
}

// SetCarrierServiceGLSID sets the "carrier_service_gls" edge to the CarrierServiceGLS entity by id.
func (m *CarrierAdditionalServiceGLSMutation) SetCarrierServiceGLSID(id pulid.ID) {
	m.carrier_service_gls = &id
}

// ClearCarrierServiceGLS clears the "carrier_service_gls" edge to the CarrierServiceGLS entity.
func (m *CarrierAdditionalServiceGLSMutation) ClearCarrierServiceGLS() {
	m.clearedcarrier_service_gls = true
}

// CarrierServiceGLSCleared reports if the "carrier_service_gls" edge to the CarrierServiceGLS entity was cleared.
func (m *CarrierAdditionalServiceGLSMutation) CarrierServiceGLSCleared() bool {
	return m.clearedcarrier_service_gls
}

// CarrierServiceGLSID returns the "carrier_service_gls" edge ID in the mutation.
func (m *CarrierAdditionalServiceGLSMutation) CarrierServiceGLSID() (id pulid.ID, exists bool) {
	if m.carrier_service_gls != nil {
		return *m.carrier_service_gls, true
	}
	return
}

// CarrierServiceGLSIDs returns the "carrier_service_gls" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceGLSID instead. It exists only for internal usage by the builders.
func (m *CarrierAdditionalServiceGLSMutation) CarrierServiceGLSIDs() (ids []pulid.ID) {
	if id := m.carrier_service_gls; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServiceGLS resets all changes to the "carrier_service_gls" edge.
func (m *CarrierAdditionalServiceGLSMutation) ResetCarrierServiceGLS() {
	m.carrier_service_gls = nil
	m.clearedcarrier_service_gls = false
}

// AddDeliveryOptionGlIDs adds the "delivery_option_gls" edge to the DeliveryOptionGLS entity by ids.
func (m *CarrierAdditionalServiceGLSMutation) AddDeliveryOptionGlIDs(ids ...pulid.ID) {
	if m.delivery_option_gls == nil {
		m.delivery_option_gls = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_gls[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionGLS clears the "delivery_option_gls" edge to the DeliveryOptionGLS entity.
func (m *CarrierAdditionalServiceGLSMutation) ClearDeliveryOptionGLS() {
	m.cleareddelivery_option_gls = true
}

// DeliveryOptionGLSCleared reports if the "delivery_option_gls" edge to the DeliveryOptionGLS entity was cleared.
func (m *CarrierAdditionalServiceGLSMutation) DeliveryOptionGLSCleared() bool {
	return m.cleareddelivery_option_gls
}

// RemoveDeliveryOptionGlIDs removes the "delivery_option_gls" edge to the DeliveryOptionGLS entity by IDs.
func (m *CarrierAdditionalServiceGLSMutation) RemoveDeliveryOptionGlIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_gls == nil {
		m.removeddelivery_option_gls = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_gls, ids[i])
		m.removeddelivery_option_gls[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionGLS returns the removed IDs of the "delivery_option_gls" edge to the DeliveryOptionGLS entity.
func (m *CarrierAdditionalServiceGLSMutation) RemovedDeliveryOptionGLSIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_gls {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionGLSIDs returns the "delivery_option_gls" edge IDs in the mutation.
func (m *CarrierAdditionalServiceGLSMutation) DeliveryOptionGLSIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_gls {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionGLS resets all changes to the "delivery_option_gls" edge.
func (m *CarrierAdditionalServiceGLSMutation) ResetDeliveryOptionGLS() {
	m.delivery_option_gls = nil
	m.cleareddelivery_option_gls = false
	m.removeddelivery_option_gls = nil
}

// AddCountriesConsigneeIDs adds the "countries_consignee" edge to the Country entity by ids.
func (m *CarrierAdditionalServiceGLSMutation) AddCountriesConsigneeIDs(ids ...pulid.ID) {
	if m.countries_consignee == nil {
		m.countries_consignee = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.countries_consignee[ids[i]] = struct{}{}
	}
}

// ClearCountriesConsignee clears the "countries_consignee" edge to the Country entity.
func (m *CarrierAdditionalServiceGLSMutation) ClearCountriesConsignee() {
	m.clearedcountries_consignee = true
}

// CountriesConsigneeCleared reports if the "countries_consignee" edge to the Country entity was cleared.
func (m *CarrierAdditionalServiceGLSMutation) CountriesConsigneeCleared() bool {
	return m.clearedcountries_consignee
}

// RemoveCountriesConsigneeIDs removes the "countries_consignee" edge to the Country entity by IDs.
func (m *CarrierAdditionalServiceGLSMutation) RemoveCountriesConsigneeIDs(ids ...pulid.ID) {
	if m.removedcountries_consignee == nil {
		m.removedcountries_consignee = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.countries_consignee, ids[i])
		m.removedcountries_consignee[ids[i]] = struct{}{}
	}
}

// RemovedCountriesConsignee returns the removed IDs of the "countries_consignee" edge to the Country entity.
func (m *CarrierAdditionalServiceGLSMutation) RemovedCountriesConsigneeIDs() (ids []pulid.ID) {
	for id := range m.removedcountries_consignee {
		ids = append(ids, id)
	}
	return
}

// CountriesConsigneeIDs returns the "countries_consignee" edge IDs in the mutation.
func (m *CarrierAdditionalServiceGLSMutation) CountriesConsigneeIDs() (ids []pulid.ID) {
	for id := range m.countries_consignee {
		ids = append(ids, id)
	}
	return
}

// ResetCountriesConsignee resets all changes to the "countries_consignee" edge.
func (m *CarrierAdditionalServiceGLSMutation) ResetCountriesConsignee() {
	m.countries_consignee = nil
	m.clearedcountries_consignee = false
	m.removedcountries_consignee = nil
}

// AddCountriesConsignorIDs adds the "countries_consignor" edge to the Country entity by ids.
func (m *CarrierAdditionalServiceGLSMutation) AddCountriesConsignorIDs(ids ...pulid.ID) {
	if m.countries_consignor == nil {
		m.countries_consignor = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.countries_consignor[ids[i]] = struct{}{}
	}
}

// ClearCountriesConsignor clears the "countries_consignor" edge to the Country entity.
func (m *CarrierAdditionalServiceGLSMutation) ClearCountriesConsignor() {
	m.clearedcountries_consignor = true
}

// CountriesConsignorCleared reports if the "countries_consignor" edge to the Country entity was cleared.
func (m *CarrierAdditionalServiceGLSMutation) CountriesConsignorCleared() bool {
	return m.clearedcountries_consignor
}

// RemoveCountriesConsignorIDs removes the "countries_consignor" edge to the Country entity by IDs.
func (m *CarrierAdditionalServiceGLSMutation) RemoveCountriesConsignorIDs(ids ...pulid.ID) {
	if m.removedcountries_consignor == nil {
		m.removedcountries_consignor = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.countries_consignor, ids[i])
		m.removedcountries_consignor[ids[i]] = struct{}{}
	}
}

// RemovedCountriesConsignor returns the removed IDs of the "countries_consignor" edge to the Country entity.
func (m *CarrierAdditionalServiceGLSMutation) RemovedCountriesConsignorIDs() (ids []pulid.ID) {
	for id := range m.removedcountries_consignor {
		ids = append(ids, id)
	}
	return
}

// CountriesConsignorIDs returns the "countries_consignor" edge IDs in the mutation.
func (m *CarrierAdditionalServiceGLSMutation) CountriesConsignorIDs() (ids []pulid.ID) {
	for id := range m.countries_consignor {
		ids = append(ids, id)
	}
	return
}

// ResetCountriesConsignor resets all changes to the "countries_consignor" edge.
func (m *CarrierAdditionalServiceGLSMutation) ResetCountriesConsignor() {
	m.countries_consignor = nil
	m.clearedcountries_consignor = false
	m.removedcountries_consignor = nil
}

// Where appends a list predicates to the CarrierAdditionalServiceGLSMutation builder.
func (m *CarrierAdditionalServiceGLSMutation) Where(ps ...predicate.CarrierAdditionalServiceGLS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierAdditionalServiceGLSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierAdditionalServiceGLSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierAdditionalServiceGLS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierAdditionalServiceGLSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierAdditionalServiceGLSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierAdditionalServiceGLS).
func (m *CarrierAdditionalServiceGLSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierAdditionalServiceGLSMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.label != nil {
		fields = append(fields, carrieradditionalservicegls.FieldLabel)
	}
	if m.mandatory != nil {
		fields = append(fields, carrieradditionalservicegls.FieldMandatory)
	}
	if m.all_countries_consignor != nil {
		fields = append(fields, carrieradditionalservicegls.FieldAllCountriesConsignor)
	}
	if m.all_countries_consignee != nil {
		fields = append(fields, carrieradditionalservicegls.FieldAllCountriesConsignee)
	}
	if m.internal_id != nil {
		fields = append(fields, carrieradditionalservicegls.FieldInternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierAdditionalServiceGLSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrieradditionalservicegls.FieldLabel:
		return m.Label()
	case carrieradditionalservicegls.FieldMandatory:
		return m.Mandatory()
	case carrieradditionalservicegls.FieldAllCountriesConsignor:
		return m.AllCountriesConsignor()
	case carrieradditionalservicegls.FieldAllCountriesConsignee:
		return m.AllCountriesConsignee()
	case carrieradditionalservicegls.FieldInternalID:
		return m.InternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierAdditionalServiceGLSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrieradditionalservicegls.FieldLabel:
		return m.OldLabel(ctx)
	case carrieradditionalservicegls.FieldMandatory:
		return m.OldMandatory(ctx)
	case carrieradditionalservicegls.FieldAllCountriesConsignor:
		return m.OldAllCountriesConsignor(ctx)
	case carrieradditionalservicegls.FieldAllCountriesConsignee:
		return m.OldAllCountriesConsignee(ctx)
	case carrieradditionalservicegls.FieldInternalID:
		return m.OldInternalID(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierAdditionalServiceGLS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceGLSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrieradditionalservicegls.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrieradditionalservicegls.FieldMandatory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMandatory(v)
		return nil
	case carrieradditionalservicegls.FieldAllCountriesConsignor:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllCountriesConsignor(v)
		return nil
	case carrieradditionalservicegls.FieldAllCountriesConsignee:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllCountriesConsignee(v)
		return nil
	case carrieradditionalservicegls.FieldInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalID(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceGLS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierAdditionalServiceGLSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierAdditionalServiceGLSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceGLSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceGLS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierAdditionalServiceGLSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierAdditionalServiceGLSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceGLSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierAdditionalServiceGLS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceGLSMutation) ResetField(name string) error {
	switch name {
	case carrieradditionalservicegls.FieldLabel:
		m.ResetLabel()
		return nil
	case carrieradditionalservicegls.FieldMandatory:
		m.ResetMandatory()
		return nil
	case carrieradditionalservicegls.FieldAllCountriesConsignor:
		m.ResetAllCountriesConsignor()
		return nil
	case carrieradditionalservicegls.FieldAllCountriesConsignee:
		m.ResetAllCountriesConsignee()
		return nil
	case carrieradditionalservicegls.FieldInternalID:
		m.ResetInternalID()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceGLS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierAdditionalServiceGLSMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.carrier_service_gls != nil {
		edges = append(edges, carrieradditionalservicegls.EdgeCarrierServiceGLS)
	}
	if m.delivery_option_gls != nil {
		edges = append(edges, carrieradditionalservicegls.EdgeDeliveryOptionGLS)
	}
	if m.countries_consignee != nil {
		edges = append(edges, carrieradditionalservicegls.EdgeCountriesConsignee)
	}
	if m.countries_consignor != nil {
		edges = append(edges, carrieradditionalservicegls.EdgeCountriesConsignor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierAdditionalServiceGLSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicegls.EdgeCarrierServiceGLS:
		if id := m.carrier_service_gls; id != nil {
			return []ent.Value{*id}
		}
	case carrieradditionalservicegls.EdgeDeliveryOptionGLS:
		ids := make([]ent.Value, 0, len(m.delivery_option_gls))
		for id := range m.delivery_option_gls {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicegls.EdgeCountriesConsignee:
		ids := make([]ent.Value, 0, len(m.countries_consignee))
		for id := range m.countries_consignee {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicegls.EdgeCountriesConsignor:
		ids := make([]ent.Value, 0, len(m.countries_consignor))
		for id := range m.countries_consignor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierAdditionalServiceGLSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddelivery_option_gls != nil {
		edges = append(edges, carrieradditionalservicegls.EdgeDeliveryOptionGLS)
	}
	if m.removedcountries_consignee != nil {
		edges = append(edges, carrieradditionalservicegls.EdgeCountriesConsignee)
	}
	if m.removedcountries_consignor != nil {
		edges = append(edges, carrieradditionalservicegls.EdgeCountriesConsignor)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierAdditionalServiceGLSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicegls.EdgeDeliveryOptionGLS:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_gls))
		for id := range m.removeddelivery_option_gls {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicegls.EdgeCountriesConsignee:
		ids := make([]ent.Value, 0, len(m.removedcountries_consignee))
		for id := range m.removedcountries_consignee {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicegls.EdgeCountriesConsignor:
		ids := make([]ent.Value, 0, len(m.removedcountries_consignor))
		for id := range m.removedcountries_consignor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierAdditionalServiceGLSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcarrier_service_gls {
		edges = append(edges, carrieradditionalservicegls.EdgeCarrierServiceGLS)
	}
	if m.cleareddelivery_option_gls {
		edges = append(edges, carrieradditionalservicegls.EdgeDeliveryOptionGLS)
	}
	if m.clearedcountries_consignee {
		edges = append(edges, carrieradditionalservicegls.EdgeCountriesConsignee)
	}
	if m.clearedcountries_consignor {
		edges = append(edges, carrieradditionalservicegls.EdgeCountriesConsignor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierAdditionalServiceGLSMutation) EdgeCleared(name string) bool {
	switch name {
	case carrieradditionalservicegls.EdgeCarrierServiceGLS:
		return m.clearedcarrier_service_gls
	case carrieradditionalservicegls.EdgeDeliveryOptionGLS:
		return m.cleareddelivery_option_gls
	case carrieradditionalservicegls.EdgeCountriesConsignee:
		return m.clearedcountries_consignee
	case carrieradditionalservicegls.EdgeCountriesConsignor:
		return m.clearedcountries_consignor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierAdditionalServiceGLSMutation) ClearEdge(name string) error {
	switch name {
	case carrieradditionalservicegls.EdgeCarrierServiceGLS:
		m.ClearCarrierServiceGLS()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceGLS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierAdditionalServiceGLSMutation) ResetEdge(name string) error {
	switch name {
	case carrieradditionalservicegls.EdgeCarrierServiceGLS:
		m.ResetCarrierServiceGLS()
		return nil
	case carrieradditionalservicegls.EdgeDeliveryOptionGLS:
		m.ResetDeliveryOptionGLS()
		return nil
	case carrieradditionalservicegls.EdgeCountriesConsignee:
		m.ResetCountriesConsignee()
		return nil
	case carrieradditionalservicegls.EdgeCountriesConsignor:
		m.ResetCountriesConsignor()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceGLS edge %s", name)
}

// CarrierAdditionalServicePostNordMutation represents an operation that mutates the CarrierAdditionalServicePostNord nodes in the graph.
type CarrierAdditionalServicePostNordMutation struct {
	config
	op                               Op
	typ                              string
	id                               *pulid.ID
	label                            *string
	mandatory                        *bool
	all_countries_consignor          *bool
	all_countries_consignee          *bool
	internal_id                      *string
	api_code                         *string
	clearedFields                    map[string]struct{}
	carrier_service_post_nord        *pulid.ID
	clearedcarrier_service_post_nord bool
	delivery_option_post_nord        map[pulid.ID]struct{}
	removeddelivery_option_post_nord map[pulid.ID]struct{}
	cleareddelivery_option_post_nord bool
	countries_consignee              map[pulid.ID]struct{}
	removedcountries_consignee       map[pulid.ID]struct{}
	clearedcountries_consignee       bool
	countries_consignor              map[pulid.ID]struct{}
	removedcountries_consignor       map[pulid.ID]struct{}
	clearedcountries_consignor       bool
	done                             bool
	oldValue                         func(context.Context) (*CarrierAdditionalServicePostNord, error)
	predicates                       []predicate.CarrierAdditionalServicePostNord
}

var _ ent.Mutation = (*CarrierAdditionalServicePostNordMutation)(nil)

// carrieradditionalservicepostnordOption allows management of the mutation configuration using functional options.
type carrieradditionalservicepostnordOption func(*CarrierAdditionalServicePostNordMutation)

// newCarrierAdditionalServicePostNordMutation creates new mutation for the CarrierAdditionalServicePostNord entity.
func newCarrierAdditionalServicePostNordMutation(c config, op Op, opts ...carrieradditionalservicepostnordOption) *CarrierAdditionalServicePostNordMutation {
	m := &CarrierAdditionalServicePostNordMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierAdditionalServicePostNord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierAdditionalServicePostNordID sets the ID field of the mutation.
func withCarrierAdditionalServicePostNordID(id pulid.ID) carrieradditionalservicepostnordOption {
	return func(m *CarrierAdditionalServicePostNordMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierAdditionalServicePostNord
		)
		m.oldValue = func(ctx context.Context) (*CarrierAdditionalServicePostNord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierAdditionalServicePostNord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierAdditionalServicePostNord sets the old CarrierAdditionalServicePostNord of the mutation.
func withCarrierAdditionalServicePostNord(node *CarrierAdditionalServicePostNord) carrieradditionalservicepostnordOption {
	return func(m *CarrierAdditionalServicePostNordMutation) {
		m.oldValue = func(context.Context) (*CarrierAdditionalServicePostNord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierAdditionalServicePostNordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierAdditionalServicePostNordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierAdditionalServicePostNord entities.
func (m *CarrierAdditionalServicePostNordMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierAdditionalServicePostNordMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierAdditionalServicePostNordMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierAdditionalServicePostNord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierAdditionalServicePostNordMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierAdditionalServicePostNordMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierAdditionalServicePostNord entity.
// If the CarrierAdditionalServicePostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServicePostNordMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierAdditionalServicePostNordMutation) ResetLabel() {
	m.label = nil
}

// SetMandatory sets the "mandatory" field.
func (m *CarrierAdditionalServicePostNordMutation) SetMandatory(b bool) {
	m.mandatory = &b
}

// Mandatory returns the value of the "mandatory" field in the mutation.
func (m *CarrierAdditionalServicePostNordMutation) Mandatory() (r bool, exists bool) {
	v := m.mandatory
	if v == nil {
		return
	}
	return *v, true
}

// OldMandatory returns the old "mandatory" field's value of the CarrierAdditionalServicePostNord entity.
// If the CarrierAdditionalServicePostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServicePostNordMutation) OldMandatory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMandatory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMandatory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMandatory: %w", err)
	}
	return oldValue.Mandatory, nil
}

// ResetMandatory resets all changes to the "mandatory" field.
func (m *CarrierAdditionalServicePostNordMutation) ResetMandatory() {
	m.mandatory = nil
}

// SetAllCountriesConsignor sets the "all_countries_consignor" field.
func (m *CarrierAdditionalServicePostNordMutation) SetAllCountriesConsignor(b bool) {
	m.all_countries_consignor = &b
}

// AllCountriesConsignor returns the value of the "all_countries_consignor" field in the mutation.
func (m *CarrierAdditionalServicePostNordMutation) AllCountriesConsignor() (r bool, exists bool) {
	v := m.all_countries_consignor
	if v == nil {
		return
	}
	return *v, true
}

// OldAllCountriesConsignor returns the old "all_countries_consignor" field's value of the CarrierAdditionalServicePostNord entity.
// If the CarrierAdditionalServicePostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServicePostNordMutation) OldAllCountriesConsignor(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllCountriesConsignor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllCountriesConsignor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllCountriesConsignor: %w", err)
	}
	return oldValue.AllCountriesConsignor, nil
}

// ResetAllCountriesConsignor resets all changes to the "all_countries_consignor" field.
func (m *CarrierAdditionalServicePostNordMutation) ResetAllCountriesConsignor() {
	m.all_countries_consignor = nil
}

// SetAllCountriesConsignee sets the "all_countries_consignee" field.
func (m *CarrierAdditionalServicePostNordMutation) SetAllCountriesConsignee(b bool) {
	m.all_countries_consignee = &b
}

// AllCountriesConsignee returns the value of the "all_countries_consignee" field in the mutation.
func (m *CarrierAdditionalServicePostNordMutation) AllCountriesConsignee() (r bool, exists bool) {
	v := m.all_countries_consignee
	if v == nil {
		return
	}
	return *v, true
}

// OldAllCountriesConsignee returns the old "all_countries_consignee" field's value of the CarrierAdditionalServicePostNord entity.
// If the CarrierAdditionalServicePostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServicePostNordMutation) OldAllCountriesConsignee(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAllCountriesConsignee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAllCountriesConsignee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAllCountriesConsignee: %w", err)
	}
	return oldValue.AllCountriesConsignee, nil
}

// ResetAllCountriesConsignee resets all changes to the "all_countries_consignee" field.
func (m *CarrierAdditionalServicePostNordMutation) ResetAllCountriesConsignee() {
	m.all_countries_consignee = nil
}

// SetInternalID sets the "internal_id" field.
func (m *CarrierAdditionalServicePostNordMutation) SetInternalID(s string) {
	m.internal_id = &s
}

// InternalID returns the value of the "internal_id" field in the mutation.
func (m *CarrierAdditionalServicePostNordMutation) InternalID() (r string, exists bool) {
	v := m.internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalID returns the old "internal_id" field's value of the CarrierAdditionalServicePostNord entity.
// If the CarrierAdditionalServicePostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServicePostNordMutation) OldInternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalID: %w", err)
	}
	return oldValue.InternalID, nil
}

// ResetInternalID resets all changes to the "internal_id" field.
func (m *CarrierAdditionalServicePostNordMutation) ResetInternalID() {
	m.internal_id = nil
}

// SetAPICode sets the "api_code" field.
func (m *CarrierAdditionalServicePostNordMutation) SetAPICode(s string) {
	m.api_code = &s
}

// APICode returns the value of the "api_code" field in the mutation.
func (m *CarrierAdditionalServicePostNordMutation) APICode() (r string, exists bool) {
	v := m.api_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAPICode returns the old "api_code" field's value of the CarrierAdditionalServicePostNord entity.
// If the CarrierAdditionalServicePostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServicePostNordMutation) OldAPICode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPICode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPICode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPICode: %w", err)
	}
	return oldValue.APICode, nil
}

// ResetAPICode resets all changes to the "api_code" field.
func (m *CarrierAdditionalServicePostNordMutation) ResetAPICode() {
	m.api_code = nil
}

// SetCarrierServicePostNordID sets the "carrier_service_post_nord" edge to the CarrierServicePostNord entity by id.
func (m *CarrierAdditionalServicePostNordMutation) SetCarrierServicePostNordID(id pulid.ID) {
	m.carrier_service_post_nord = &id
}

// ClearCarrierServicePostNord clears the "carrier_service_post_nord" edge to the CarrierServicePostNord entity.
func (m *CarrierAdditionalServicePostNordMutation) ClearCarrierServicePostNord() {
	m.clearedcarrier_service_post_nord = true
}

// CarrierServicePostNordCleared reports if the "carrier_service_post_nord" edge to the CarrierServicePostNord entity was cleared.
func (m *CarrierAdditionalServicePostNordMutation) CarrierServicePostNordCleared() bool {
	return m.clearedcarrier_service_post_nord
}

// CarrierServicePostNordID returns the "carrier_service_post_nord" edge ID in the mutation.
func (m *CarrierAdditionalServicePostNordMutation) CarrierServicePostNordID() (id pulid.ID, exists bool) {
	if m.carrier_service_post_nord != nil {
		return *m.carrier_service_post_nord, true
	}
	return
}

// CarrierServicePostNordIDs returns the "carrier_service_post_nord" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServicePostNordID instead. It exists only for internal usage by the builders.
func (m *CarrierAdditionalServicePostNordMutation) CarrierServicePostNordIDs() (ids []pulid.ID) {
	if id := m.carrier_service_post_nord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServicePostNord resets all changes to the "carrier_service_post_nord" edge.
func (m *CarrierAdditionalServicePostNordMutation) ResetCarrierServicePostNord() {
	m.carrier_service_post_nord = nil
	m.clearedcarrier_service_post_nord = false
}

// AddDeliveryOptionPostNordIDs adds the "delivery_option_post_nord" edge to the DeliveryOptionPostNord entity by ids.
func (m *CarrierAdditionalServicePostNordMutation) AddDeliveryOptionPostNordIDs(ids ...pulid.ID) {
	if m.delivery_option_post_nord == nil {
		m.delivery_option_post_nord = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_post_nord[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionPostNord clears the "delivery_option_post_nord" edge to the DeliveryOptionPostNord entity.
func (m *CarrierAdditionalServicePostNordMutation) ClearDeliveryOptionPostNord() {
	m.cleareddelivery_option_post_nord = true
}

// DeliveryOptionPostNordCleared reports if the "delivery_option_post_nord" edge to the DeliveryOptionPostNord entity was cleared.
func (m *CarrierAdditionalServicePostNordMutation) DeliveryOptionPostNordCleared() bool {
	return m.cleareddelivery_option_post_nord
}

// RemoveDeliveryOptionPostNordIDs removes the "delivery_option_post_nord" edge to the DeliveryOptionPostNord entity by IDs.
func (m *CarrierAdditionalServicePostNordMutation) RemoveDeliveryOptionPostNordIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_post_nord == nil {
		m.removeddelivery_option_post_nord = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_post_nord, ids[i])
		m.removeddelivery_option_post_nord[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionPostNord returns the removed IDs of the "delivery_option_post_nord" edge to the DeliveryOptionPostNord entity.
func (m *CarrierAdditionalServicePostNordMutation) RemovedDeliveryOptionPostNordIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_post_nord {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionPostNordIDs returns the "delivery_option_post_nord" edge IDs in the mutation.
func (m *CarrierAdditionalServicePostNordMutation) DeliveryOptionPostNordIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_post_nord {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionPostNord resets all changes to the "delivery_option_post_nord" edge.
func (m *CarrierAdditionalServicePostNordMutation) ResetDeliveryOptionPostNord() {
	m.delivery_option_post_nord = nil
	m.cleareddelivery_option_post_nord = false
	m.removeddelivery_option_post_nord = nil
}

// AddCountriesConsigneeIDs adds the "countries_consignee" edge to the Country entity by ids.
func (m *CarrierAdditionalServicePostNordMutation) AddCountriesConsigneeIDs(ids ...pulid.ID) {
	if m.countries_consignee == nil {
		m.countries_consignee = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.countries_consignee[ids[i]] = struct{}{}
	}
}

// ClearCountriesConsignee clears the "countries_consignee" edge to the Country entity.
func (m *CarrierAdditionalServicePostNordMutation) ClearCountriesConsignee() {
	m.clearedcountries_consignee = true
}

// CountriesConsigneeCleared reports if the "countries_consignee" edge to the Country entity was cleared.
func (m *CarrierAdditionalServicePostNordMutation) CountriesConsigneeCleared() bool {
	return m.clearedcountries_consignee
}

// RemoveCountriesConsigneeIDs removes the "countries_consignee" edge to the Country entity by IDs.
func (m *CarrierAdditionalServicePostNordMutation) RemoveCountriesConsigneeIDs(ids ...pulid.ID) {
	if m.removedcountries_consignee == nil {
		m.removedcountries_consignee = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.countries_consignee, ids[i])
		m.removedcountries_consignee[ids[i]] = struct{}{}
	}
}

// RemovedCountriesConsignee returns the removed IDs of the "countries_consignee" edge to the Country entity.
func (m *CarrierAdditionalServicePostNordMutation) RemovedCountriesConsigneeIDs() (ids []pulid.ID) {
	for id := range m.removedcountries_consignee {
		ids = append(ids, id)
	}
	return
}

// CountriesConsigneeIDs returns the "countries_consignee" edge IDs in the mutation.
func (m *CarrierAdditionalServicePostNordMutation) CountriesConsigneeIDs() (ids []pulid.ID) {
	for id := range m.countries_consignee {
		ids = append(ids, id)
	}
	return
}

// ResetCountriesConsignee resets all changes to the "countries_consignee" edge.
func (m *CarrierAdditionalServicePostNordMutation) ResetCountriesConsignee() {
	m.countries_consignee = nil
	m.clearedcountries_consignee = false
	m.removedcountries_consignee = nil
}

// AddCountriesConsignorIDs adds the "countries_consignor" edge to the Country entity by ids.
func (m *CarrierAdditionalServicePostNordMutation) AddCountriesConsignorIDs(ids ...pulid.ID) {
	if m.countries_consignor == nil {
		m.countries_consignor = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.countries_consignor[ids[i]] = struct{}{}
	}
}

// ClearCountriesConsignor clears the "countries_consignor" edge to the Country entity.
func (m *CarrierAdditionalServicePostNordMutation) ClearCountriesConsignor() {
	m.clearedcountries_consignor = true
}

// CountriesConsignorCleared reports if the "countries_consignor" edge to the Country entity was cleared.
func (m *CarrierAdditionalServicePostNordMutation) CountriesConsignorCleared() bool {
	return m.clearedcountries_consignor
}

// RemoveCountriesConsignorIDs removes the "countries_consignor" edge to the Country entity by IDs.
func (m *CarrierAdditionalServicePostNordMutation) RemoveCountriesConsignorIDs(ids ...pulid.ID) {
	if m.removedcountries_consignor == nil {
		m.removedcountries_consignor = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.countries_consignor, ids[i])
		m.removedcountries_consignor[ids[i]] = struct{}{}
	}
}

// RemovedCountriesConsignor returns the removed IDs of the "countries_consignor" edge to the Country entity.
func (m *CarrierAdditionalServicePostNordMutation) RemovedCountriesConsignorIDs() (ids []pulid.ID) {
	for id := range m.removedcountries_consignor {
		ids = append(ids, id)
	}
	return
}

// CountriesConsignorIDs returns the "countries_consignor" edge IDs in the mutation.
func (m *CarrierAdditionalServicePostNordMutation) CountriesConsignorIDs() (ids []pulid.ID) {
	for id := range m.countries_consignor {
		ids = append(ids, id)
	}
	return
}

// ResetCountriesConsignor resets all changes to the "countries_consignor" edge.
func (m *CarrierAdditionalServicePostNordMutation) ResetCountriesConsignor() {
	m.countries_consignor = nil
	m.clearedcountries_consignor = false
	m.removedcountries_consignor = nil
}

// Where appends a list predicates to the CarrierAdditionalServicePostNordMutation builder.
func (m *CarrierAdditionalServicePostNordMutation) Where(ps ...predicate.CarrierAdditionalServicePostNord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierAdditionalServicePostNordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierAdditionalServicePostNordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierAdditionalServicePostNord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierAdditionalServicePostNordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierAdditionalServicePostNordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierAdditionalServicePostNord).
func (m *CarrierAdditionalServicePostNordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierAdditionalServicePostNordMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.label != nil {
		fields = append(fields, carrieradditionalservicepostnord.FieldLabel)
	}
	if m.mandatory != nil {
		fields = append(fields, carrieradditionalservicepostnord.FieldMandatory)
	}
	if m.all_countries_consignor != nil {
		fields = append(fields, carrieradditionalservicepostnord.FieldAllCountriesConsignor)
	}
	if m.all_countries_consignee != nil {
		fields = append(fields, carrieradditionalservicepostnord.FieldAllCountriesConsignee)
	}
	if m.internal_id != nil {
		fields = append(fields, carrieradditionalservicepostnord.FieldInternalID)
	}
	if m.api_code != nil {
		fields = append(fields, carrieradditionalservicepostnord.FieldAPICode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierAdditionalServicePostNordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrieradditionalservicepostnord.FieldLabel:
		return m.Label()
	case carrieradditionalservicepostnord.FieldMandatory:
		return m.Mandatory()
	case carrieradditionalservicepostnord.FieldAllCountriesConsignor:
		return m.AllCountriesConsignor()
	case carrieradditionalservicepostnord.FieldAllCountriesConsignee:
		return m.AllCountriesConsignee()
	case carrieradditionalservicepostnord.FieldInternalID:
		return m.InternalID()
	case carrieradditionalservicepostnord.FieldAPICode:
		return m.APICode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierAdditionalServicePostNordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrieradditionalservicepostnord.FieldLabel:
		return m.OldLabel(ctx)
	case carrieradditionalservicepostnord.FieldMandatory:
		return m.OldMandatory(ctx)
	case carrieradditionalservicepostnord.FieldAllCountriesConsignor:
		return m.OldAllCountriesConsignor(ctx)
	case carrieradditionalservicepostnord.FieldAllCountriesConsignee:
		return m.OldAllCountriesConsignee(ctx)
	case carrieradditionalservicepostnord.FieldInternalID:
		return m.OldInternalID(ctx)
	case carrieradditionalservicepostnord.FieldAPICode:
		return m.OldAPICode(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierAdditionalServicePostNord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServicePostNordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrieradditionalservicepostnord.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrieradditionalservicepostnord.FieldMandatory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMandatory(v)
		return nil
	case carrieradditionalservicepostnord.FieldAllCountriesConsignor:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllCountriesConsignor(v)
		return nil
	case carrieradditionalservicepostnord.FieldAllCountriesConsignee:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAllCountriesConsignee(v)
		return nil
	case carrieradditionalservicepostnord.FieldInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalID(v)
		return nil
	case carrieradditionalservicepostnord.FieldAPICode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPICode(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServicePostNord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierAdditionalServicePostNordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierAdditionalServicePostNordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServicePostNordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServicePostNord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierAdditionalServicePostNordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierAdditionalServicePostNordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierAdditionalServicePostNordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierAdditionalServicePostNord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierAdditionalServicePostNordMutation) ResetField(name string) error {
	switch name {
	case carrieradditionalservicepostnord.FieldLabel:
		m.ResetLabel()
		return nil
	case carrieradditionalservicepostnord.FieldMandatory:
		m.ResetMandatory()
		return nil
	case carrieradditionalservicepostnord.FieldAllCountriesConsignor:
		m.ResetAllCountriesConsignor()
		return nil
	case carrieradditionalservicepostnord.FieldAllCountriesConsignee:
		m.ResetAllCountriesConsignee()
		return nil
	case carrieradditionalservicepostnord.FieldInternalID:
		m.ResetInternalID()
		return nil
	case carrieradditionalservicepostnord.FieldAPICode:
		m.ResetAPICode()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServicePostNord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierAdditionalServicePostNordMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.carrier_service_post_nord != nil {
		edges = append(edges, carrieradditionalservicepostnord.EdgeCarrierServicePostNord)
	}
	if m.delivery_option_post_nord != nil {
		edges = append(edges, carrieradditionalservicepostnord.EdgeDeliveryOptionPostNord)
	}
	if m.countries_consignee != nil {
		edges = append(edges, carrieradditionalservicepostnord.EdgeCountriesConsignee)
	}
	if m.countries_consignor != nil {
		edges = append(edges, carrieradditionalservicepostnord.EdgeCountriesConsignor)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierAdditionalServicePostNordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicepostnord.EdgeCarrierServicePostNord:
		if id := m.carrier_service_post_nord; id != nil {
			return []ent.Value{*id}
		}
	case carrieradditionalservicepostnord.EdgeDeliveryOptionPostNord:
		ids := make([]ent.Value, 0, len(m.delivery_option_post_nord))
		for id := range m.delivery_option_post_nord {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicepostnord.EdgeCountriesConsignee:
		ids := make([]ent.Value, 0, len(m.countries_consignee))
		for id := range m.countries_consignee {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicepostnord.EdgeCountriesConsignor:
		ids := make([]ent.Value, 0, len(m.countries_consignor))
		for id := range m.countries_consignor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierAdditionalServicePostNordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeddelivery_option_post_nord != nil {
		edges = append(edges, carrieradditionalservicepostnord.EdgeDeliveryOptionPostNord)
	}
	if m.removedcountries_consignee != nil {
		edges = append(edges, carrieradditionalservicepostnord.EdgeCountriesConsignee)
	}
	if m.removedcountries_consignor != nil {
		edges = append(edges, carrieradditionalservicepostnord.EdgeCountriesConsignor)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierAdditionalServicePostNordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalservicepostnord.EdgeDeliveryOptionPostNord:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_post_nord))
		for id := range m.removeddelivery_option_post_nord {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicepostnord.EdgeCountriesConsignee:
		ids := make([]ent.Value, 0, len(m.removedcountries_consignee))
		for id := range m.removedcountries_consignee {
			ids = append(ids, id)
		}
		return ids
	case carrieradditionalservicepostnord.EdgeCountriesConsignor:
		ids := make([]ent.Value, 0, len(m.removedcountries_consignor))
		for id := range m.removedcountries_consignor {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierAdditionalServicePostNordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcarrier_service_post_nord {
		edges = append(edges, carrieradditionalservicepostnord.EdgeCarrierServicePostNord)
	}
	if m.cleareddelivery_option_post_nord {
		edges = append(edges, carrieradditionalservicepostnord.EdgeDeliveryOptionPostNord)
	}
	if m.clearedcountries_consignee {
		edges = append(edges, carrieradditionalservicepostnord.EdgeCountriesConsignee)
	}
	if m.clearedcountries_consignor {
		edges = append(edges, carrieradditionalservicepostnord.EdgeCountriesConsignor)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierAdditionalServicePostNordMutation) EdgeCleared(name string) bool {
	switch name {
	case carrieradditionalservicepostnord.EdgeCarrierServicePostNord:
		return m.clearedcarrier_service_post_nord
	case carrieradditionalservicepostnord.EdgeDeliveryOptionPostNord:
		return m.cleareddelivery_option_post_nord
	case carrieradditionalservicepostnord.EdgeCountriesConsignee:
		return m.clearedcountries_consignee
	case carrieradditionalservicepostnord.EdgeCountriesConsignor:
		return m.clearedcountries_consignor
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierAdditionalServicePostNordMutation) ClearEdge(name string) error {
	switch name {
	case carrieradditionalservicepostnord.EdgeCarrierServicePostNord:
		m.ClearCarrierServicePostNord()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServicePostNord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierAdditionalServicePostNordMutation) ResetEdge(name string) error {
	switch name {
	case carrieradditionalservicepostnord.EdgeCarrierServicePostNord:
		m.ResetCarrierServicePostNord()
		return nil
	case carrieradditionalservicepostnord.EdgeDeliveryOptionPostNord:
		m.ResetDeliveryOptionPostNord()
		return nil
	case carrieradditionalservicepostnord.EdgeCountriesConsignee:
		m.ResetCountriesConsignee()
		return nil
	case carrieradditionalservicepostnord.EdgeCountriesConsignor:
		m.ResetCountriesConsignor()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServicePostNord edge %s", name)
}

// CarrierAdditionalServiceUSPSMutation represents an operation that mutates the CarrierAdditionalServiceUSPS nodes in the graph.
type CarrierAdditionalServiceUSPSMutation struct {
	config
	op                          Op
	typ                         string
	id                          *pulid.ID
	label                       *string
	commonly_used               *bool
	internal_id                 *carrieradditionalserviceusps.InternalID
	api_code                    *string
	clearedFields               map[string]struct{}
	carrier_service_usps        *pulid.ID
	clearedcarrier_service_usps bool
	delivery_option_usps        map[pulid.ID]struct{}
	removeddelivery_option_usps map[pulid.ID]struct{}
	cleareddelivery_option_usps bool
	done                        bool
	oldValue                    func(context.Context) (*CarrierAdditionalServiceUSPS, error)
	predicates                  []predicate.CarrierAdditionalServiceUSPS
}

var _ ent.Mutation = (*CarrierAdditionalServiceUSPSMutation)(nil)

// carrieradditionalserviceuspsOption allows management of the mutation configuration using functional options.
type carrieradditionalserviceuspsOption func(*CarrierAdditionalServiceUSPSMutation)

// newCarrierAdditionalServiceUSPSMutation creates new mutation for the CarrierAdditionalServiceUSPS entity.
func newCarrierAdditionalServiceUSPSMutation(c config, op Op, opts ...carrieradditionalserviceuspsOption) *CarrierAdditionalServiceUSPSMutation {
	m := &CarrierAdditionalServiceUSPSMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierAdditionalServiceUSPS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierAdditionalServiceUSPSID sets the ID field of the mutation.
func withCarrierAdditionalServiceUSPSID(id pulid.ID) carrieradditionalserviceuspsOption {
	return func(m *CarrierAdditionalServiceUSPSMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierAdditionalServiceUSPS
		)
		m.oldValue = func(ctx context.Context) (*CarrierAdditionalServiceUSPS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierAdditionalServiceUSPS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierAdditionalServiceUSPS sets the old CarrierAdditionalServiceUSPS of the mutation.
func withCarrierAdditionalServiceUSPS(node *CarrierAdditionalServiceUSPS) carrieradditionalserviceuspsOption {
	return func(m *CarrierAdditionalServiceUSPSMutation) {
		m.oldValue = func(context.Context) (*CarrierAdditionalServiceUSPS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierAdditionalServiceUSPSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierAdditionalServiceUSPSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierAdditionalServiceUSPS entities.
func (m *CarrierAdditionalServiceUSPSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierAdditionalServiceUSPSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierAdditionalServiceUSPSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierAdditionalServiceUSPS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierAdditionalServiceUSPSMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierAdditionalServiceUSPSMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierAdditionalServiceUSPS entity.
// If the CarrierAdditionalServiceUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceUSPSMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierAdditionalServiceUSPSMutation) ResetLabel() {
	m.label = nil
}

// SetCommonlyUsed sets the "commonly_used" field.
func (m *CarrierAdditionalServiceUSPSMutation) SetCommonlyUsed(b bool) {
	m.commonly_used = &b
}

// CommonlyUsed returns the value of the "commonly_used" field in the mutation.
func (m *CarrierAdditionalServiceUSPSMutation) CommonlyUsed() (r bool, exists bool) {
	v := m.commonly_used
	if v == nil {
		return
	}
	return *v, true
}

// OldCommonlyUsed returns the old "commonly_used" field's value of the CarrierAdditionalServiceUSPS entity.
// If the CarrierAdditionalServiceUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceUSPSMutation) OldCommonlyUsed(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommonlyUsed is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommonlyUsed requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommonlyUsed: %w", err)
	}
	return oldValue.CommonlyUsed, nil
}

// ResetCommonlyUsed resets all changes to the "commonly_used" field.
func (m *CarrierAdditionalServiceUSPSMutation) ResetCommonlyUsed() {
	m.commonly_used = nil
}

// SetInternalID sets the "internal_id" field.
func (m *CarrierAdditionalServiceUSPSMutation) SetInternalID(ci carrieradditionalserviceusps.InternalID) {
	m.internal_id = &ci
}

// InternalID returns the value of the "internal_id" field in the mutation.
func (m *CarrierAdditionalServiceUSPSMutation) InternalID() (r carrieradditionalserviceusps.InternalID, exists bool) {
	v := m.internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalID returns the old "internal_id" field's value of the CarrierAdditionalServiceUSPS entity.
// If the CarrierAdditionalServiceUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceUSPSMutation) OldInternalID(ctx context.Context) (v carrieradditionalserviceusps.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalID: %w", err)
	}
	return oldValue.InternalID, nil
}

// ResetInternalID resets all changes to the "internal_id" field.
func (m *CarrierAdditionalServiceUSPSMutation) ResetInternalID() {
	m.internal_id = nil
}

// SetAPICode sets the "api_code" field.
func (m *CarrierAdditionalServiceUSPSMutation) SetAPICode(s string) {
	m.api_code = &s
}

// APICode returns the value of the "api_code" field in the mutation.
func (m *CarrierAdditionalServiceUSPSMutation) APICode() (r string, exists bool) {
	v := m.api_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAPICode returns the old "api_code" field's value of the CarrierAdditionalServiceUSPS entity.
// If the CarrierAdditionalServiceUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierAdditionalServiceUSPSMutation) OldAPICode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPICode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPICode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPICode: %w", err)
	}
	return oldValue.APICode, nil
}

// ResetAPICode resets all changes to the "api_code" field.
func (m *CarrierAdditionalServiceUSPSMutation) ResetAPICode() {
	m.api_code = nil
}

// SetCarrierServiceUSPSID sets the "carrier_service_usps" edge to the CarrierServiceUSPS entity by id.
func (m *CarrierAdditionalServiceUSPSMutation) SetCarrierServiceUSPSID(id pulid.ID) {
	m.carrier_service_usps = &id
}

// ClearCarrierServiceUSPS clears the "carrier_service_usps" edge to the CarrierServiceUSPS entity.
func (m *CarrierAdditionalServiceUSPSMutation) ClearCarrierServiceUSPS() {
	m.clearedcarrier_service_usps = true
}

// CarrierServiceUSPSCleared reports if the "carrier_service_usps" edge to the CarrierServiceUSPS entity was cleared.
func (m *CarrierAdditionalServiceUSPSMutation) CarrierServiceUSPSCleared() bool {
	return m.clearedcarrier_service_usps
}

// CarrierServiceUSPSID returns the "carrier_service_usps" edge ID in the mutation.
func (m *CarrierAdditionalServiceUSPSMutation) CarrierServiceUSPSID() (id pulid.ID, exists bool) {
	if m.carrier_service_usps != nil {
		return *m.carrier_service_usps, true
	}
	return
}

// CarrierServiceUSPSIDs returns the "carrier_service_usps" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceUSPSID instead. It exists only for internal usage by the builders.
func (m *CarrierAdditionalServiceUSPSMutation) CarrierServiceUSPSIDs() (ids []pulid.ID) {
	if id := m.carrier_service_usps; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServiceUSPS resets all changes to the "carrier_service_usps" edge.
func (m *CarrierAdditionalServiceUSPSMutation) ResetCarrierServiceUSPS() {
	m.carrier_service_usps = nil
	m.clearedcarrier_service_usps = false
}

// AddDeliveryOptionUspIDs adds the "delivery_option_usps" edge to the DeliveryOptionUSPS entity by ids.
func (m *CarrierAdditionalServiceUSPSMutation) AddDeliveryOptionUspIDs(ids ...pulid.ID) {
	if m.delivery_option_usps == nil {
		m.delivery_option_usps = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_usps[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionUSPS clears the "delivery_option_usps" edge to the DeliveryOptionUSPS entity.
func (m *CarrierAdditionalServiceUSPSMutation) ClearDeliveryOptionUSPS() {
	m.cleareddelivery_option_usps = true
}

// DeliveryOptionUSPSCleared reports if the "delivery_option_usps" edge to the DeliveryOptionUSPS entity was cleared.
func (m *CarrierAdditionalServiceUSPSMutation) DeliveryOptionUSPSCleared() bool {
	return m.cleareddelivery_option_usps
}

// RemoveDeliveryOptionUspIDs removes the "delivery_option_usps" edge to the DeliveryOptionUSPS entity by IDs.
func (m *CarrierAdditionalServiceUSPSMutation) RemoveDeliveryOptionUspIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_usps == nil {
		m.removeddelivery_option_usps = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_usps, ids[i])
		m.removeddelivery_option_usps[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionUSPS returns the removed IDs of the "delivery_option_usps" edge to the DeliveryOptionUSPS entity.
func (m *CarrierAdditionalServiceUSPSMutation) RemovedDeliveryOptionUSPSIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_usps {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionUSPSIDs returns the "delivery_option_usps" edge IDs in the mutation.
func (m *CarrierAdditionalServiceUSPSMutation) DeliveryOptionUSPSIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_usps {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionUSPS resets all changes to the "delivery_option_usps" edge.
func (m *CarrierAdditionalServiceUSPSMutation) ResetDeliveryOptionUSPS() {
	m.delivery_option_usps = nil
	m.cleareddelivery_option_usps = false
	m.removeddelivery_option_usps = nil
}

// Where appends a list predicates to the CarrierAdditionalServiceUSPSMutation builder.
func (m *CarrierAdditionalServiceUSPSMutation) Where(ps ...predicate.CarrierAdditionalServiceUSPS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierAdditionalServiceUSPSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierAdditionalServiceUSPSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierAdditionalServiceUSPS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierAdditionalServiceUSPSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierAdditionalServiceUSPSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierAdditionalServiceUSPS).
func (m *CarrierAdditionalServiceUSPSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierAdditionalServiceUSPSMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.label != nil {
		fields = append(fields, carrieradditionalserviceusps.FieldLabel)
	}
	if m.commonly_used != nil {
		fields = append(fields, carrieradditionalserviceusps.FieldCommonlyUsed)
	}
	if m.internal_id != nil {
		fields = append(fields, carrieradditionalserviceusps.FieldInternalID)
	}
	if m.api_code != nil {
		fields = append(fields, carrieradditionalserviceusps.FieldAPICode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierAdditionalServiceUSPSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrieradditionalserviceusps.FieldLabel:
		return m.Label()
	case carrieradditionalserviceusps.FieldCommonlyUsed:
		return m.CommonlyUsed()
	case carrieradditionalserviceusps.FieldInternalID:
		return m.InternalID()
	case carrieradditionalserviceusps.FieldAPICode:
		return m.APICode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierAdditionalServiceUSPSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrieradditionalserviceusps.FieldLabel:
		return m.OldLabel(ctx)
	case carrieradditionalserviceusps.FieldCommonlyUsed:
		return m.OldCommonlyUsed(ctx)
	case carrieradditionalserviceusps.FieldInternalID:
		return m.OldInternalID(ctx)
	case carrieradditionalserviceusps.FieldAPICode:
		return m.OldAPICode(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierAdditionalServiceUSPS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceUSPSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrieradditionalserviceusps.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrieradditionalserviceusps.FieldCommonlyUsed:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommonlyUsed(v)
		return nil
	case carrieradditionalserviceusps.FieldInternalID:
		v, ok := value.(carrieradditionalserviceusps.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalID(v)
		return nil
	case carrieradditionalserviceusps.FieldAPICode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPICode(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceUSPS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierAdditionalServiceUSPSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierAdditionalServiceUSPSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierAdditionalServiceUSPSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceUSPS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierAdditionalServiceUSPSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierAdditionalServiceUSPSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceUSPSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierAdditionalServiceUSPS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierAdditionalServiceUSPSMutation) ResetField(name string) error {
	switch name {
	case carrieradditionalserviceusps.FieldLabel:
		m.ResetLabel()
		return nil
	case carrieradditionalserviceusps.FieldCommonlyUsed:
		m.ResetCommonlyUsed()
		return nil
	case carrieradditionalserviceusps.FieldInternalID:
		m.ResetInternalID()
		return nil
	case carrieradditionalserviceusps.FieldAPICode:
		m.ResetAPICode()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceUSPS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierAdditionalServiceUSPSMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service_usps != nil {
		edges = append(edges, carrieradditionalserviceusps.EdgeCarrierServiceUSPS)
	}
	if m.delivery_option_usps != nil {
		edges = append(edges, carrieradditionalserviceusps.EdgeDeliveryOptionUSPS)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierAdditionalServiceUSPSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalserviceusps.EdgeCarrierServiceUSPS:
		if id := m.carrier_service_usps; id != nil {
			return []ent.Value{*id}
		}
	case carrieradditionalserviceusps.EdgeDeliveryOptionUSPS:
		ids := make([]ent.Value, 0, len(m.delivery_option_usps))
		for id := range m.delivery_option_usps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierAdditionalServiceUSPSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddelivery_option_usps != nil {
		edges = append(edges, carrieradditionalserviceusps.EdgeDeliveryOptionUSPS)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierAdditionalServiceUSPSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrieradditionalserviceusps.EdgeDeliveryOptionUSPS:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_usps))
		for id := range m.removeddelivery_option_usps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierAdditionalServiceUSPSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service_usps {
		edges = append(edges, carrieradditionalserviceusps.EdgeCarrierServiceUSPS)
	}
	if m.cleareddelivery_option_usps {
		edges = append(edges, carrieradditionalserviceusps.EdgeDeliveryOptionUSPS)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierAdditionalServiceUSPSMutation) EdgeCleared(name string) bool {
	switch name {
	case carrieradditionalserviceusps.EdgeCarrierServiceUSPS:
		return m.clearedcarrier_service_usps
	case carrieradditionalserviceusps.EdgeDeliveryOptionUSPS:
		return m.cleareddelivery_option_usps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierAdditionalServiceUSPSMutation) ClearEdge(name string) error {
	switch name {
	case carrieradditionalserviceusps.EdgeCarrierServiceUSPS:
		m.ClearCarrierServiceUSPS()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceUSPS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierAdditionalServiceUSPSMutation) ResetEdge(name string) error {
	switch name {
	case carrieradditionalserviceusps.EdgeCarrierServiceUSPS:
		m.ResetCarrierServiceUSPS()
		return nil
	case carrieradditionalserviceusps.EdgeDeliveryOptionUSPS:
		m.ResetDeliveryOptionUSPS()
		return nil
	}
	return fmt.Errorf("unknown CarrierAdditionalServiceUSPS edge %s", name)
}

// CarrierBrandMutation represents an operation that mutates the CarrierBrand nodes in the graph.
type CarrierBrandMutation struct {
	config
	op                     Op
	typ                    string
	id                     *pulid.ID
	label                  *string
	label_short            *string
	internal_id            *carrierbrand.InternalID
	logo_url               *string
	text_color             *string
	background_color       *string
	clearedFields          map[string]struct{}
	carrier_service        map[pulid.ID]struct{}
	removedcarrier_service map[pulid.ID]struct{}
	clearedcarrier_service bool
	carrier                map[pulid.ID]struct{}
	removedcarrier         map[pulid.ID]struct{}
	clearedcarrier         bool
	parcel_shop            map[pulid.ID]struct{}
	removedparcel_shop     map[pulid.ID]struct{}
	clearedparcel_shop     bool
	packaging              map[pulid.ID]struct{}
	removedpackaging       map[pulid.ID]struct{}
	clearedpackaging       bool
	document               map[pulid.ID]struct{}
	removeddocument        map[pulid.ID]struct{}
	cleareddocument        bool
	done                   bool
	oldValue               func(context.Context) (*CarrierBrand, error)
	predicates             []predicate.CarrierBrand
}

var _ ent.Mutation = (*CarrierBrandMutation)(nil)

// carrierbrandOption allows management of the mutation configuration using functional options.
type carrierbrandOption func(*CarrierBrandMutation)

// newCarrierBrandMutation creates new mutation for the CarrierBrand entity.
func newCarrierBrandMutation(c config, op Op, opts ...carrierbrandOption) *CarrierBrandMutation {
	m := &CarrierBrandMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierBrandID sets the ID field of the mutation.
func withCarrierBrandID(id pulid.ID) carrierbrandOption {
	return func(m *CarrierBrandMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierBrand
		)
		m.oldValue = func(ctx context.Context) (*CarrierBrand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierBrand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierBrand sets the old CarrierBrand of the mutation.
func withCarrierBrand(node *CarrierBrand) carrierbrandOption {
	return func(m *CarrierBrandMutation) {
		m.oldValue = func(context.Context) (*CarrierBrand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierBrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierBrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierBrand entities.
func (m *CarrierBrandMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierBrandMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierBrandMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierBrand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierBrandMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierBrandMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierBrand entity.
// If the CarrierBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierBrandMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierBrandMutation) ResetLabel() {
	m.label = nil
}

// SetLabelShort sets the "label_short" field.
func (m *CarrierBrandMutation) SetLabelShort(s string) {
	m.label_short = &s
}

// LabelShort returns the value of the "label_short" field in the mutation.
func (m *CarrierBrandMutation) LabelShort() (r string, exists bool) {
	v := m.label_short
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelShort returns the old "label_short" field's value of the CarrierBrand entity.
// If the CarrierBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierBrandMutation) OldLabelShort(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelShort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelShort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelShort: %w", err)
	}
	return oldValue.LabelShort, nil
}

// ResetLabelShort resets all changes to the "label_short" field.
func (m *CarrierBrandMutation) ResetLabelShort() {
	m.label_short = nil
}

// SetInternalID sets the "internal_id" field.
func (m *CarrierBrandMutation) SetInternalID(ci carrierbrand.InternalID) {
	m.internal_id = &ci
}

// InternalID returns the value of the "internal_id" field in the mutation.
func (m *CarrierBrandMutation) InternalID() (r carrierbrand.InternalID, exists bool) {
	v := m.internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalID returns the old "internal_id" field's value of the CarrierBrand entity.
// If the CarrierBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierBrandMutation) OldInternalID(ctx context.Context) (v carrierbrand.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalID: %w", err)
	}
	return oldValue.InternalID, nil
}

// ResetInternalID resets all changes to the "internal_id" field.
func (m *CarrierBrandMutation) ResetInternalID() {
	m.internal_id = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *CarrierBrandMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *CarrierBrandMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the CarrierBrand entity.
// If the CarrierBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierBrandMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *CarrierBrandMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[carrierbrand.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *CarrierBrandMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[carrierbrand.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *CarrierBrandMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, carrierbrand.FieldLogoURL)
}

// SetTextColor sets the "text_color" field.
func (m *CarrierBrandMutation) SetTextColor(s string) {
	m.text_color = &s
}

// TextColor returns the value of the "text_color" field in the mutation.
func (m *CarrierBrandMutation) TextColor() (r string, exists bool) {
	v := m.text_color
	if v == nil {
		return
	}
	return *v, true
}

// OldTextColor returns the old "text_color" field's value of the CarrierBrand entity.
// If the CarrierBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierBrandMutation) OldTextColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextColor: %w", err)
	}
	return oldValue.TextColor, nil
}

// ClearTextColor clears the value of the "text_color" field.
func (m *CarrierBrandMutation) ClearTextColor() {
	m.text_color = nil
	m.clearedFields[carrierbrand.FieldTextColor] = struct{}{}
}

// TextColorCleared returns if the "text_color" field was cleared in this mutation.
func (m *CarrierBrandMutation) TextColorCleared() bool {
	_, ok := m.clearedFields[carrierbrand.FieldTextColor]
	return ok
}

// ResetTextColor resets all changes to the "text_color" field.
func (m *CarrierBrandMutation) ResetTextColor() {
	m.text_color = nil
	delete(m.clearedFields, carrierbrand.FieldTextColor)
}

// SetBackgroundColor sets the "background_color" field.
func (m *CarrierBrandMutation) SetBackgroundColor(s string) {
	m.background_color = &s
}

// BackgroundColor returns the value of the "background_color" field in the mutation.
func (m *CarrierBrandMutation) BackgroundColor() (r string, exists bool) {
	v := m.background_color
	if v == nil {
		return
	}
	return *v, true
}

// OldBackgroundColor returns the old "background_color" field's value of the CarrierBrand entity.
// If the CarrierBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierBrandMutation) OldBackgroundColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBackgroundColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBackgroundColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBackgroundColor: %w", err)
	}
	return oldValue.BackgroundColor, nil
}

// ClearBackgroundColor clears the value of the "background_color" field.
func (m *CarrierBrandMutation) ClearBackgroundColor() {
	m.background_color = nil
	m.clearedFields[carrierbrand.FieldBackgroundColor] = struct{}{}
}

// BackgroundColorCleared returns if the "background_color" field was cleared in this mutation.
func (m *CarrierBrandMutation) BackgroundColorCleared() bool {
	_, ok := m.clearedFields[carrierbrand.FieldBackgroundColor]
	return ok
}

// ResetBackgroundColor resets all changes to the "background_color" field.
func (m *CarrierBrandMutation) ResetBackgroundColor() {
	m.background_color = nil
	delete(m.clearedFields, carrierbrand.FieldBackgroundColor)
}

// AddCarrierServiceIDs adds the "carrier_service" edge to the CarrierService entity by ids.
func (m *CarrierBrandMutation) AddCarrierServiceIDs(ids ...pulid.ID) {
	if m.carrier_service == nil {
		m.carrier_service = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_service[ids[i]] = struct{}{}
	}
}

// ClearCarrierService clears the "carrier_service" edge to the CarrierService entity.
func (m *CarrierBrandMutation) ClearCarrierService() {
	m.clearedcarrier_service = true
}

// CarrierServiceCleared reports if the "carrier_service" edge to the CarrierService entity was cleared.
func (m *CarrierBrandMutation) CarrierServiceCleared() bool {
	return m.clearedcarrier_service
}

// RemoveCarrierServiceIDs removes the "carrier_service" edge to the CarrierService entity by IDs.
func (m *CarrierBrandMutation) RemoveCarrierServiceIDs(ids ...pulid.ID) {
	if m.removedcarrier_service == nil {
		m.removedcarrier_service = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_service, ids[i])
		m.removedcarrier_service[ids[i]] = struct{}{}
	}
}

// RemovedCarrierService returns the removed IDs of the "carrier_service" edge to the CarrierService entity.
func (m *CarrierBrandMutation) RemovedCarrierServiceIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_service {
		ids = append(ids, id)
	}
	return
}

// CarrierServiceIDs returns the "carrier_service" edge IDs in the mutation.
func (m *CarrierBrandMutation) CarrierServiceIDs() (ids []pulid.ID) {
	for id := range m.carrier_service {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierService resets all changes to the "carrier_service" edge.
func (m *CarrierBrandMutation) ResetCarrierService() {
	m.carrier_service = nil
	m.clearedcarrier_service = false
	m.removedcarrier_service = nil
}

// AddCarrierIDs adds the "carrier" edge to the Carrier entity by ids.
func (m *CarrierBrandMutation) AddCarrierIDs(ids ...pulid.ID) {
	if m.carrier == nil {
		m.carrier = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier[ids[i]] = struct{}{}
	}
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *CarrierBrandMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *CarrierBrandMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// RemoveCarrierIDs removes the "carrier" edge to the Carrier entity by IDs.
func (m *CarrierBrandMutation) RemoveCarrierIDs(ids ...pulid.ID) {
	if m.removedcarrier == nil {
		m.removedcarrier = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier, ids[i])
		m.removedcarrier[ids[i]] = struct{}{}
	}
}

// RemovedCarrier returns the removed IDs of the "carrier" edge to the Carrier entity.
func (m *CarrierBrandMutation) RemovedCarrierIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier {
		ids = append(ids, id)
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
func (m *CarrierBrandMutation) CarrierIDs() (ids []pulid.ID) {
	for id := range m.carrier {
		ids = append(ids, id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *CarrierBrandMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
	m.removedcarrier = nil
}

// AddParcelShopIDs adds the "parcel_shop" edge to the ParcelShop entity by ids.
func (m *CarrierBrandMutation) AddParcelShopIDs(ids ...pulid.ID) {
	if m.parcel_shop == nil {
		m.parcel_shop = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.parcel_shop[ids[i]] = struct{}{}
	}
}

// ClearParcelShop clears the "parcel_shop" edge to the ParcelShop entity.
func (m *CarrierBrandMutation) ClearParcelShop() {
	m.clearedparcel_shop = true
}

// ParcelShopCleared reports if the "parcel_shop" edge to the ParcelShop entity was cleared.
func (m *CarrierBrandMutation) ParcelShopCleared() bool {
	return m.clearedparcel_shop
}

// RemoveParcelShopIDs removes the "parcel_shop" edge to the ParcelShop entity by IDs.
func (m *CarrierBrandMutation) RemoveParcelShopIDs(ids ...pulid.ID) {
	if m.removedparcel_shop == nil {
		m.removedparcel_shop = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.parcel_shop, ids[i])
		m.removedparcel_shop[ids[i]] = struct{}{}
	}
}

// RemovedParcelShop returns the removed IDs of the "parcel_shop" edge to the ParcelShop entity.
func (m *CarrierBrandMutation) RemovedParcelShopIDs() (ids []pulid.ID) {
	for id := range m.removedparcel_shop {
		ids = append(ids, id)
	}
	return
}

// ParcelShopIDs returns the "parcel_shop" edge IDs in the mutation.
func (m *CarrierBrandMutation) ParcelShopIDs() (ids []pulid.ID) {
	for id := range m.parcel_shop {
		ids = append(ids, id)
	}
	return
}

// ResetParcelShop resets all changes to the "parcel_shop" edge.
func (m *CarrierBrandMutation) ResetParcelShop() {
	m.parcel_shop = nil
	m.clearedparcel_shop = false
	m.removedparcel_shop = nil
}

// AddPackagingIDs adds the "packaging" edge to the Packaging entity by ids.
func (m *CarrierBrandMutation) AddPackagingIDs(ids ...pulid.ID) {
	if m.packaging == nil {
		m.packaging = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.packaging[ids[i]] = struct{}{}
	}
}

// ClearPackaging clears the "packaging" edge to the Packaging entity.
func (m *CarrierBrandMutation) ClearPackaging() {
	m.clearedpackaging = true
}

// PackagingCleared reports if the "packaging" edge to the Packaging entity was cleared.
func (m *CarrierBrandMutation) PackagingCleared() bool {
	return m.clearedpackaging
}

// RemovePackagingIDs removes the "packaging" edge to the Packaging entity by IDs.
func (m *CarrierBrandMutation) RemovePackagingIDs(ids ...pulid.ID) {
	if m.removedpackaging == nil {
		m.removedpackaging = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.packaging, ids[i])
		m.removedpackaging[ids[i]] = struct{}{}
	}
}

// RemovedPackaging returns the removed IDs of the "packaging" edge to the Packaging entity.
func (m *CarrierBrandMutation) RemovedPackagingIDs() (ids []pulid.ID) {
	for id := range m.removedpackaging {
		ids = append(ids, id)
	}
	return
}

// PackagingIDs returns the "packaging" edge IDs in the mutation.
func (m *CarrierBrandMutation) PackagingIDs() (ids []pulid.ID) {
	for id := range m.packaging {
		ids = append(ids, id)
	}
	return
}

// ResetPackaging resets all changes to the "packaging" edge.
func (m *CarrierBrandMutation) ResetPackaging() {
	m.packaging = nil
	m.clearedpackaging = false
	m.removedpackaging = nil
}

// AddDocumentIDs adds the "document" edge to the Document entity by ids.
func (m *CarrierBrandMutation) AddDocumentIDs(ids ...pulid.ID) {
	if m.document == nil {
		m.document = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.document[ids[i]] = struct{}{}
	}
}

// ClearDocument clears the "document" edge to the Document entity.
func (m *CarrierBrandMutation) ClearDocument() {
	m.cleareddocument = true
}

// DocumentCleared reports if the "document" edge to the Document entity was cleared.
func (m *CarrierBrandMutation) DocumentCleared() bool {
	return m.cleareddocument
}

// RemoveDocumentIDs removes the "document" edge to the Document entity by IDs.
func (m *CarrierBrandMutation) RemoveDocumentIDs(ids ...pulid.ID) {
	if m.removeddocument == nil {
		m.removeddocument = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.document, ids[i])
		m.removeddocument[ids[i]] = struct{}{}
	}
}

// RemovedDocument returns the removed IDs of the "document" edge to the Document entity.
func (m *CarrierBrandMutation) RemovedDocumentIDs() (ids []pulid.ID) {
	for id := range m.removeddocument {
		ids = append(ids, id)
	}
	return
}

// DocumentIDs returns the "document" edge IDs in the mutation.
func (m *CarrierBrandMutation) DocumentIDs() (ids []pulid.ID) {
	for id := range m.document {
		ids = append(ids, id)
	}
	return
}

// ResetDocument resets all changes to the "document" edge.
func (m *CarrierBrandMutation) ResetDocument() {
	m.document = nil
	m.cleareddocument = false
	m.removeddocument = nil
}

// Where appends a list predicates to the CarrierBrandMutation builder.
func (m *CarrierBrandMutation) Where(ps ...predicate.CarrierBrand) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierBrandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierBrandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierBrand, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierBrandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierBrandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierBrand).
func (m *CarrierBrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierBrandMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.label != nil {
		fields = append(fields, carrierbrand.FieldLabel)
	}
	if m.label_short != nil {
		fields = append(fields, carrierbrand.FieldLabelShort)
	}
	if m.internal_id != nil {
		fields = append(fields, carrierbrand.FieldInternalID)
	}
	if m.logo_url != nil {
		fields = append(fields, carrierbrand.FieldLogoURL)
	}
	if m.text_color != nil {
		fields = append(fields, carrierbrand.FieldTextColor)
	}
	if m.background_color != nil {
		fields = append(fields, carrierbrand.FieldBackgroundColor)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierBrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierbrand.FieldLabel:
		return m.Label()
	case carrierbrand.FieldLabelShort:
		return m.LabelShort()
	case carrierbrand.FieldInternalID:
		return m.InternalID()
	case carrierbrand.FieldLogoURL:
		return m.LogoURL()
	case carrierbrand.FieldTextColor:
		return m.TextColor()
	case carrierbrand.FieldBackgroundColor:
		return m.BackgroundColor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierBrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierbrand.FieldLabel:
		return m.OldLabel(ctx)
	case carrierbrand.FieldLabelShort:
		return m.OldLabelShort(ctx)
	case carrierbrand.FieldInternalID:
		return m.OldInternalID(ctx)
	case carrierbrand.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case carrierbrand.FieldTextColor:
		return m.OldTextColor(ctx)
	case carrierbrand.FieldBackgroundColor:
		return m.OldBackgroundColor(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierBrand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierBrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierbrand.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrierbrand.FieldLabelShort:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelShort(v)
		return nil
	case carrierbrand.FieldInternalID:
		v, ok := value.(carrierbrand.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalID(v)
		return nil
	case carrierbrand.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case carrierbrand.FieldTextColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextColor(v)
		return nil
	case carrierbrand.FieldBackgroundColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBackgroundColor(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierBrand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierBrandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierBrandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierBrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierBrand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierBrandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carrierbrand.FieldLogoURL) {
		fields = append(fields, carrierbrand.FieldLogoURL)
	}
	if m.FieldCleared(carrierbrand.FieldTextColor) {
		fields = append(fields, carrierbrand.FieldTextColor)
	}
	if m.FieldCleared(carrierbrand.FieldBackgroundColor) {
		fields = append(fields, carrierbrand.FieldBackgroundColor)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierBrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierBrandMutation) ClearField(name string) error {
	switch name {
	case carrierbrand.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	case carrierbrand.FieldTextColor:
		m.ClearTextColor()
		return nil
	case carrierbrand.FieldBackgroundColor:
		m.ClearBackgroundColor()
		return nil
	}
	return fmt.Errorf("unknown CarrierBrand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierBrandMutation) ResetField(name string) error {
	switch name {
	case carrierbrand.FieldLabel:
		m.ResetLabel()
		return nil
	case carrierbrand.FieldLabelShort:
		m.ResetLabelShort()
		return nil
	case carrierbrand.FieldInternalID:
		m.ResetInternalID()
		return nil
	case carrierbrand.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case carrierbrand.FieldTextColor:
		m.ResetTextColor()
		return nil
	case carrierbrand.FieldBackgroundColor:
		m.ResetBackgroundColor()
		return nil
	}
	return fmt.Errorf("unknown CarrierBrand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierBrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.carrier_service != nil {
		edges = append(edges, carrierbrand.EdgeCarrierService)
	}
	if m.carrier != nil {
		edges = append(edges, carrierbrand.EdgeCarrier)
	}
	if m.parcel_shop != nil {
		edges = append(edges, carrierbrand.EdgeParcelShop)
	}
	if m.packaging != nil {
		edges = append(edges, carrierbrand.EdgePackaging)
	}
	if m.document != nil {
		edges = append(edges, carrierbrand.EdgeDocument)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierBrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierbrand.EdgeCarrierService:
		ids := make([]ent.Value, 0, len(m.carrier_service))
		for id := range m.carrier_service {
			ids = append(ids, id)
		}
		return ids
	case carrierbrand.EdgeCarrier:
		ids := make([]ent.Value, 0, len(m.carrier))
		for id := range m.carrier {
			ids = append(ids, id)
		}
		return ids
	case carrierbrand.EdgeParcelShop:
		ids := make([]ent.Value, 0, len(m.parcel_shop))
		for id := range m.parcel_shop {
			ids = append(ids, id)
		}
		return ids
	case carrierbrand.EdgePackaging:
		ids := make([]ent.Value, 0, len(m.packaging))
		for id := range m.packaging {
			ids = append(ids, id)
		}
		return ids
	case carrierbrand.EdgeDocument:
		ids := make([]ent.Value, 0, len(m.document))
		for id := range m.document {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierBrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedcarrier_service != nil {
		edges = append(edges, carrierbrand.EdgeCarrierService)
	}
	if m.removedcarrier != nil {
		edges = append(edges, carrierbrand.EdgeCarrier)
	}
	if m.removedparcel_shop != nil {
		edges = append(edges, carrierbrand.EdgeParcelShop)
	}
	if m.removedpackaging != nil {
		edges = append(edges, carrierbrand.EdgePackaging)
	}
	if m.removeddocument != nil {
		edges = append(edges, carrierbrand.EdgeDocument)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierBrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrierbrand.EdgeCarrierService:
		ids := make([]ent.Value, 0, len(m.removedcarrier_service))
		for id := range m.removedcarrier_service {
			ids = append(ids, id)
		}
		return ids
	case carrierbrand.EdgeCarrier:
		ids := make([]ent.Value, 0, len(m.removedcarrier))
		for id := range m.removedcarrier {
			ids = append(ids, id)
		}
		return ids
	case carrierbrand.EdgeParcelShop:
		ids := make([]ent.Value, 0, len(m.removedparcel_shop))
		for id := range m.removedparcel_shop {
			ids = append(ids, id)
		}
		return ids
	case carrierbrand.EdgePackaging:
		ids := make([]ent.Value, 0, len(m.removedpackaging))
		for id := range m.removedpackaging {
			ids = append(ids, id)
		}
		return ids
	case carrierbrand.EdgeDocument:
		ids := make([]ent.Value, 0, len(m.removeddocument))
		for id := range m.removeddocument {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierBrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcarrier_service {
		edges = append(edges, carrierbrand.EdgeCarrierService)
	}
	if m.clearedcarrier {
		edges = append(edges, carrierbrand.EdgeCarrier)
	}
	if m.clearedparcel_shop {
		edges = append(edges, carrierbrand.EdgeParcelShop)
	}
	if m.clearedpackaging {
		edges = append(edges, carrierbrand.EdgePackaging)
	}
	if m.cleareddocument {
		edges = append(edges, carrierbrand.EdgeDocument)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierBrandMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierbrand.EdgeCarrierService:
		return m.clearedcarrier_service
	case carrierbrand.EdgeCarrier:
		return m.clearedcarrier
	case carrierbrand.EdgeParcelShop:
		return m.clearedparcel_shop
	case carrierbrand.EdgePackaging:
		return m.clearedpackaging
	case carrierbrand.EdgeDocument:
		return m.cleareddocument
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierBrandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierBrand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierBrandMutation) ResetEdge(name string) error {
	switch name {
	case carrierbrand.EdgeCarrierService:
		m.ResetCarrierService()
		return nil
	case carrierbrand.EdgeCarrier:
		m.ResetCarrier()
		return nil
	case carrierbrand.EdgeParcelShop:
		m.ResetParcelShop()
		return nil
	case carrierbrand.EdgePackaging:
		m.ResetPackaging()
		return nil
	case carrierbrand.EdgeDocument:
		m.ResetDocument()
		return nil
	}
	return fmt.Errorf("unknown CarrierBrand edge %s", name)
}

// CarrierBringMutation represents an operation that mutates the CarrierBring nodes in the graph.
type CarrierBringMutation struct {
	config
	op              Op
	typ             string
	id              *pulid.ID
	api_key         *string
	customer_number *string
	test            *bool
	clearedFields   map[string]struct{}
	tenant          *pulid.ID
	clearedtenant   bool
	carrier         *pulid.ID
	clearedcarrier  bool
	done            bool
	oldValue        func(context.Context) (*CarrierBring, error)
	predicates      []predicate.CarrierBring
}

var _ ent.Mutation = (*CarrierBringMutation)(nil)

// carrierbringOption allows management of the mutation configuration using functional options.
type carrierbringOption func(*CarrierBringMutation)

// newCarrierBringMutation creates new mutation for the CarrierBring entity.
func newCarrierBringMutation(c config, op Op, opts ...carrierbringOption) *CarrierBringMutation {
	m := &CarrierBringMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierBring,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierBringID sets the ID field of the mutation.
func withCarrierBringID(id pulid.ID) carrierbringOption {
	return func(m *CarrierBringMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierBring
		)
		m.oldValue = func(ctx context.Context) (*CarrierBring, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierBring.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierBring sets the old CarrierBring of the mutation.
func withCarrierBring(node *CarrierBring) carrierbringOption {
	return func(m *CarrierBringMutation) {
		m.oldValue = func(context.Context) (*CarrierBring, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierBringMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierBringMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierBring entities.
func (m *CarrierBringMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierBringMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierBringMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierBring.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CarrierBringMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarrierBringMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CarrierBring entity.
// If the CarrierBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierBringMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarrierBringMutation) ResetTenantID() {
	m.tenant = nil
}

// SetAPIKey sets the "api_key" field.
func (m *CarrierBringMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *CarrierBringMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the CarrierBring entity.
// If the CarrierBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierBringMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ClearAPIKey clears the value of the "api_key" field.
func (m *CarrierBringMutation) ClearAPIKey() {
	m.api_key = nil
	m.clearedFields[carrierbring.FieldAPIKey] = struct{}{}
}

// APIKeyCleared returns if the "api_key" field was cleared in this mutation.
func (m *CarrierBringMutation) APIKeyCleared() bool {
	_, ok := m.clearedFields[carrierbring.FieldAPIKey]
	return ok
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *CarrierBringMutation) ResetAPIKey() {
	m.api_key = nil
	delete(m.clearedFields, carrierbring.FieldAPIKey)
}

// SetCustomerNumber sets the "customer_number" field.
func (m *CarrierBringMutation) SetCustomerNumber(s string) {
	m.customer_number = &s
}

// CustomerNumber returns the value of the "customer_number" field in the mutation.
func (m *CarrierBringMutation) CustomerNumber() (r string, exists bool) {
	v := m.customer_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerNumber returns the old "customer_number" field's value of the CarrierBring entity.
// If the CarrierBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierBringMutation) OldCustomerNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerNumber: %w", err)
	}
	return oldValue.CustomerNumber, nil
}

// ClearCustomerNumber clears the value of the "customer_number" field.
func (m *CarrierBringMutation) ClearCustomerNumber() {
	m.customer_number = nil
	m.clearedFields[carrierbring.FieldCustomerNumber] = struct{}{}
}

// CustomerNumberCleared returns if the "customer_number" field was cleared in this mutation.
func (m *CarrierBringMutation) CustomerNumberCleared() bool {
	_, ok := m.clearedFields[carrierbring.FieldCustomerNumber]
	return ok
}

// ResetCustomerNumber resets all changes to the "customer_number" field.
func (m *CarrierBringMutation) ResetCustomerNumber() {
	m.customer_number = nil
	delete(m.clearedFields, carrierbring.FieldCustomerNumber)
}

// SetTest sets the "test" field.
func (m *CarrierBringMutation) SetTest(b bool) {
	m.test = &b
}

// Test returns the value of the "test" field in the mutation.
func (m *CarrierBringMutation) Test() (r bool, exists bool) {
	v := m.test
	if v == nil {
		return
	}
	return *v, true
}

// OldTest returns the old "test" field's value of the CarrierBring entity.
// If the CarrierBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierBringMutation) OldTest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTest: %w", err)
	}
	return oldValue.Test, nil
}

// ResetTest resets all changes to the "test" field.
func (m *CarrierBringMutation) ResetTest() {
	m.test = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarrierBringMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[carrierbring.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarrierBringMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarrierBringMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarrierBringMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *CarrierBringMutation) SetCarrierID(id pulid.ID) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *CarrierBringMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *CarrierBringMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *CarrierBringMutation) CarrierID() (id pulid.ID, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *CarrierBringMutation) CarrierIDs() (ids []pulid.ID) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *CarrierBringMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// Where appends a list predicates to the CarrierBringMutation builder.
func (m *CarrierBringMutation) Where(ps ...predicate.CarrierBring) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierBringMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierBringMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierBring, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierBringMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierBringMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierBring).
func (m *CarrierBringMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierBringMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, carrierbring.FieldTenantID)
	}
	if m.api_key != nil {
		fields = append(fields, carrierbring.FieldAPIKey)
	}
	if m.customer_number != nil {
		fields = append(fields, carrierbring.FieldCustomerNumber)
	}
	if m.test != nil {
		fields = append(fields, carrierbring.FieldTest)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierBringMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierbring.FieldTenantID:
		return m.TenantID()
	case carrierbring.FieldAPIKey:
		return m.APIKey()
	case carrierbring.FieldCustomerNumber:
		return m.CustomerNumber()
	case carrierbring.FieldTest:
		return m.Test()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierBringMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierbring.FieldTenantID:
		return m.OldTenantID(ctx)
	case carrierbring.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case carrierbring.FieldCustomerNumber:
		return m.OldCustomerNumber(ctx)
	case carrierbring.FieldTest:
		return m.OldTest(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierBring field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierBringMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierbring.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case carrierbring.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case carrierbring.FieldCustomerNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerNumber(v)
		return nil
	case carrierbring.FieldTest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTest(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierBring field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierBringMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierBringMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierBringMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierBring numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierBringMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carrierbring.FieldAPIKey) {
		fields = append(fields, carrierbring.FieldAPIKey)
	}
	if m.FieldCleared(carrierbring.FieldCustomerNumber) {
		fields = append(fields, carrierbring.FieldCustomerNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierBringMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierBringMutation) ClearField(name string) error {
	switch name {
	case carrierbring.FieldAPIKey:
		m.ClearAPIKey()
		return nil
	case carrierbring.FieldCustomerNumber:
		m.ClearCustomerNumber()
		return nil
	}
	return fmt.Errorf("unknown CarrierBring nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierBringMutation) ResetField(name string) error {
	switch name {
	case carrierbring.FieldTenantID:
		m.ResetTenantID()
		return nil
	case carrierbring.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case carrierbring.FieldCustomerNumber:
		m.ResetCustomerNumber()
		return nil
	case carrierbring.FieldTest:
		m.ResetTest()
		return nil
	}
	return fmt.Errorf("unknown CarrierBring field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierBringMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, carrierbring.EdgeTenant)
	}
	if m.carrier != nil {
		edges = append(edges, carrierbring.EdgeCarrier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierBringMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierbring.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case carrierbring.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierBringMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierBringMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierBringMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, carrierbring.EdgeTenant)
	}
	if m.clearedcarrier {
		edges = append(edges, carrierbring.EdgeCarrier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierBringMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierbring.EdgeTenant:
		return m.clearedtenant
	case carrierbring.EdgeCarrier:
		return m.clearedcarrier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierBringMutation) ClearEdge(name string) error {
	switch name {
	case carrierbring.EdgeTenant:
		m.ClearTenant()
		return nil
	case carrierbring.EdgeCarrier:
		m.ClearCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierBring unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierBringMutation) ResetEdge(name string) error {
	switch name {
	case carrierbring.EdgeTenant:
		m.ResetTenant()
		return nil
	case carrierbring.EdgeCarrier:
		m.ResetCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierBring edge %s", name)
}

// CarrierDAOMutation represents an operation that mutates the CarrierDAO nodes in the graph.
type CarrierDAOMutation struct {
	config
	op             Op
	typ            string
	id             *pulid.ID
	customer_id    *string
	api_key        *string
	_Test          *bool
	clearedFields  map[string]struct{}
	tenant         *pulid.ID
	clearedtenant  bool
	carrier        *pulid.ID
	clearedcarrier bool
	done           bool
	oldValue       func(context.Context) (*CarrierDAO, error)
	predicates     []predicate.CarrierDAO
}

var _ ent.Mutation = (*CarrierDAOMutation)(nil)

// carrierdaoOption allows management of the mutation configuration using functional options.
type carrierdaoOption func(*CarrierDAOMutation)

// newCarrierDAOMutation creates new mutation for the CarrierDAO entity.
func newCarrierDAOMutation(c config, op Op, opts ...carrierdaoOption) *CarrierDAOMutation {
	m := &CarrierDAOMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierDAO,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierDAOID sets the ID field of the mutation.
func withCarrierDAOID(id pulid.ID) carrierdaoOption {
	return func(m *CarrierDAOMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierDAO
		)
		m.oldValue = func(ctx context.Context) (*CarrierDAO, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierDAO.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierDAO sets the old CarrierDAO of the mutation.
func withCarrierDAO(node *CarrierDAO) carrierdaoOption {
	return func(m *CarrierDAOMutation) {
		m.oldValue = func(context.Context) (*CarrierDAO, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierDAOMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierDAOMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierDAO entities.
func (m *CarrierDAOMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierDAOMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierDAOMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierDAO.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CarrierDAOMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarrierDAOMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CarrierDAO entity.
// If the CarrierDAO object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierDAOMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarrierDAOMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *CarrierDAOMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CarrierDAOMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CarrierDAO entity.
// If the CarrierDAO object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierDAOMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *CarrierDAOMutation) ClearCustomerID() {
	m.customer_id = nil
	m.clearedFields[carrierdao.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *CarrierDAOMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[carrierdao.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CarrierDAOMutation) ResetCustomerID() {
	m.customer_id = nil
	delete(m.clearedFields, carrierdao.FieldCustomerID)
}

// SetAPIKey sets the "api_key" field.
func (m *CarrierDAOMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *CarrierDAOMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the CarrierDAO entity.
// If the CarrierDAO object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierDAOMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ClearAPIKey clears the value of the "api_key" field.
func (m *CarrierDAOMutation) ClearAPIKey() {
	m.api_key = nil
	m.clearedFields[carrierdao.FieldAPIKey] = struct{}{}
}

// APIKeyCleared returns if the "api_key" field was cleared in this mutation.
func (m *CarrierDAOMutation) APIKeyCleared() bool {
	_, ok := m.clearedFields[carrierdao.FieldAPIKey]
	return ok
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *CarrierDAOMutation) ResetAPIKey() {
	m.api_key = nil
	delete(m.clearedFields, carrierdao.FieldAPIKey)
}

// SetTest sets the "Test" field.
func (m *CarrierDAOMutation) SetTest(b bool) {
	m._Test = &b
}

// Test returns the value of the "Test" field in the mutation.
func (m *CarrierDAOMutation) Test() (r bool, exists bool) {
	v := m._Test
	if v == nil {
		return
	}
	return *v, true
}

// OldTest returns the old "Test" field's value of the CarrierDAO entity.
// If the CarrierDAO object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierDAOMutation) OldTest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTest: %w", err)
	}
	return oldValue.Test, nil
}

// ResetTest resets all changes to the "Test" field.
func (m *CarrierDAOMutation) ResetTest() {
	m._Test = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarrierDAOMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[carrierdao.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarrierDAOMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarrierDAOMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarrierDAOMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *CarrierDAOMutation) SetCarrierID(id pulid.ID) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *CarrierDAOMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *CarrierDAOMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *CarrierDAOMutation) CarrierID() (id pulid.ID, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *CarrierDAOMutation) CarrierIDs() (ids []pulid.ID) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *CarrierDAOMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// Where appends a list predicates to the CarrierDAOMutation builder.
func (m *CarrierDAOMutation) Where(ps ...predicate.CarrierDAO) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierDAOMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierDAOMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierDAO, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierDAOMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierDAOMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierDAO).
func (m *CarrierDAOMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierDAOMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, carrierdao.FieldTenantID)
	}
	if m.customer_id != nil {
		fields = append(fields, carrierdao.FieldCustomerID)
	}
	if m.api_key != nil {
		fields = append(fields, carrierdao.FieldAPIKey)
	}
	if m._Test != nil {
		fields = append(fields, carrierdao.FieldTest)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierDAOMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierdao.FieldTenantID:
		return m.TenantID()
	case carrierdao.FieldCustomerID:
		return m.CustomerID()
	case carrierdao.FieldAPIKey:
		return m.APIKey()
	case carrierdao.FieldTest:
		return m.Test()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierDAOMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierdao.FieldTenantID:
		return m.OldTenantID(ctx)
	case carrierdao.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case carrierdao.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case carrierdao.FieldTest:
		return m.OldTest(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierDAO field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierDAOMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierdao.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case carrierdao.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case carrierdao.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case carrierdao.FieldTest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTest(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierDAO field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierDAOMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierDAOMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierDAOMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierDAO numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierDAOMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carrierdao.FieldCustomerID) {
		fields = append(fields, carrierdao.FieldCustomerID)
	}
	if m.FieldCleared(carrierdao.FieldAPIKey) {
		fields = append(fields, carrierdao.FieldAPIKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierDAOMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierDAOMutation) ClearField(name string) error {
	switch name {
	case carrierdao.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case carrierdao.FieldAPIKey:
		m.ClearAPIKey()
		return nil
	}
	return fmt.Errorf("unknown CarrierDAO nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierDAOMutation) ResetField(name string) error {
	switch name {
	case carrierdao.FieldTenantID:
		m.ResetTenantID()
		return nil
	case carrierdao.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case carrierdao.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case carrierdao.FieldTest:
		m.ResetTest()
		return nil
	}
	return fmt.Errorf("unknown CarrierDAO field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierDAOMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, carrierdao.EdgeTenant)
	}
	if m.carrier != nil {
		edges = append(edges, carrierdao.EdgeCarrier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierDAOMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierdao.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case carrierdao.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierDAOMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierDAOMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierDAOMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, carrierdao.EdgeTenant)
	}
	if m.clearedcarrier {
		edges = append(edges, carrierdao.EdgeCarrier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierDAOMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierdao.EdgeTenant:
		return m.clearedtenant
	case carrierdao.EdgeCarrier:
		return m.clearedcarrier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierDAOMutation) ClearEdge(name string) error {
	switch name {
	case carrierdao.EdgeTenant:
		m.ClearTenant()
		return nil
	case carrierdao.EdgeCarrier:
		m.ClearCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierDAO unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierDAOMutation) ResetEdge(name string) error {
	switch name {
	case carrierdao.EdgeTenant:
		m.ResetTenant()
		return nil
	case carrierdao.EdgeCarrier:
		m.ResetCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierDAO edge %s", name)
}

// CarrierDFMutation represents an operation that mutates the CarrierDF nodes in the graph.
type CarrierDFMutation struct {
	config
	op               Op
	typ              string
	id               *pulid.ID
	customer_id      *string
	agreement_number *string
	who_pays         *carrierdf.WhoPays
	test             *bool
	clearedFields    map[string]struct{}
	tenant           *pulid.ID
	clearedtenant    bool
	carrier          *pulid.ID
	clearedcarrier   bool
	done             bool
	oldValue         func(context.Context) (*CarrierDF, error)
	predicates       []predicate.CarrierDF
}

var _ ent.Mutation = (*CarrierDFMutation)(nil)

// carrierdfOption allows management of the mutation configuration using functional options.
type carrierdfOption func(*CarrierDFMutation)

// newCarrierDFMutation creates new mutation for the CarrierDF entity.
func newCarrierDFMutation(c config, op Op, opts ...carrierdfOption) *CarrierDFMutation {
	m := &CarrierDFMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierDF,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierDFID sets the ID field of the mutation.
func withCarrierDFID(id pulid.ID) carrierdfOption {
	return func(m *CarrierDFMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierDF
		)
		m.oldValue = func(ctx context.Context) (*CarrierDF, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierDF.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierDF sets the old CarrierDF of the mutation.
func withCarrierDF(node *CarrierDF) carrierdfOption {
	return func(m *CarrierDFMutation) {
		m.oldValue = func(context.Context) (*CarrierDF, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierDFMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierDFMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierDF entities.
func (m *CarrierDFMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierDFMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierDFMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierDF.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CarrierDFMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarrierDFMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CarrierDF entity.
// If the CarrierDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierDFMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarrierDFMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCustomerID sets the "customer_id" field.
func (m *CarrierDFMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CarrierDFMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CarrierDF entity.
// If the CarrierDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierDFMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CarrierDFMutation) ResetCustomerID() {
	m.customer_id = nil
}

// SetAgreementNumber sets the "agreement_number" field.
func (m *CarrierDFMutation) SetAgreementNumber(s string) {
	m.agreement_number = &s
}

// AgreementNumber returns the value of the "agreement_number" field in the mutation.
func (m *CarrierDFMutation) AgreementNumber() (r string, exists bool) {
	v := m.agreement_number
	if v == nil {
		return
	}
	return *v, true
}

// OldAgreementNumber returns the old "agreement_number" field's value of the CarrierDF entity.
// If the CarrierDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierDFMutation) OldAgreementNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAgreementNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAgreementNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAgreementNumber: %w", err)
	}
	return oldValue.AgreementNumber, nil
}

// ResetAgreementNumber resets all changes to the "agreement_number" field.
func (m *CarrierDFMutation) ResetAgreementNumber() {
	m.agreement_number = nil
}

// SetWhoPays sets the "who_pays" field.
func (m *CarrierDFMutation) SetWhoPays(cp carrierdf.WhoPays) {
	m.who_pays = &cp
}

// WhoPays returns the value of the "who_pays" field in the mutation.
func (m *CarrierDFMutation) WhoPays() (r carrierdf.WhoPays, exists bool) {
	v := m.who_pays
	if v == nil {
		return
	}
	return *v, true
}

// OldWhoPays returns the old "who_pays" field's value of the CarrierDF entity.
// If the CarrierDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierDFMutation) OldWhoPays(ctx context.Context) (v carrierdf.WhoPays, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWhoPays is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWhoPays requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWhoPays: %w", err)
	}
	return oldValue.WhoPays, nil
}

// ResetWhoPays resets all changes to the "who_pays" field.
func (m *CarrierDFMutation) ResetWhoPays() {
	m.who_pays = nil
}

// SetTest sets the "test" field.
func (m *CarrierDFMutation) SetTest(b bool) {
	m.test = &b
}

// Test returns the value of the "test" field in the mutation.
func (m *CarrierDFMutation) Test() (r bool, exists bool) {
	v := m.test
	if v == nil {
		return
	}
	return *v, true
}

// OldTest returns the old "test" field's value of the CarrierDF entity.
// If the CarrierDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierDFMutation) OldTest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTest: %w", err)
	}
	return oldValue.Test, nil
}

// ResetTest resets all changes to the "test" field.
func (m *CarrierDFMutation) ResetTest() {
	m.test = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarrierDFMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[carrierdf.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarrierDFMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarrierDFMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarrierDFMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *CarrierDFMutation) SetCarrierID(id pulid.ID) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *CarrierDFMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *CarrierDFMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *CarrierDFMutation) CarrierID() (id pulid.ID, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *CarrierDFMutation) CarrierIDs() (ids []pulid.ID) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *CarrierDFMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// Where appends a list predicates to the CarrierDFMutation builder.
func (m *CarrierDFMutation) Where(ps ...predicate.CarrierDF) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierDFMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierDFMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierDF, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierDFMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierDFMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierDF).
func (m *CarrierDFMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierDFMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, carrierdf.FieldTenantID)
	}
	if m.customer_id != nil {
		fields = append(fields, carrierdf.FieldCustomerID)
	}
	if m.agreement_number != nil {
		fields = append(fields, carrierdf.FieldAgreementNumber)
	}
	if m.who_pays != nil {
		fields = append(fields, carrierdf.FieldWhoPays)
	}
	if m.test != nil {
		fields = append(fields, carrierdf.FieldTest)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierDFMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierdf.FieldTenantID:
		return m.TenantID()
	case carrierdf.FieldCustomerID:
		return m.CustomerID()
	case carrierdf.FieldAgreementNumber:
		return m.AgreementNumber()
	case carrierdf.FieldWhoPays:
		return m.WhoPays()
	case carrierdf.FieldTest:
		return m.Test()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierDFMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierdf.FieldTenantID:
		return m.OldTenantID(ctx)
	case carrierdf.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case carrierdf.FieldAgreementNumber:
		return m.OldAgreementNumber(ctx)
	case carrierdf.FieldWhoPays:
		return m.OldWhoPays(ctx)
	case carrierdf.FieldTest:
		return m.OldTest(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierDF field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierDFMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierdf.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case carrierdf.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case carrierdf.FieldAgreementNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAgreementNumber(v)
		return nil
	case carrierdf.FieldWhoPays:
		v, ok := value.(carrierdf.WhoPays)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWhoPays(v)
		return nil
	case carrierdf.FieldTest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTest(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierDF field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierDFMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierDFMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierDFMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierDF numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierDFMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierDFMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierDFMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierDF nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierDFMutation) ResetField(name string) error {
	switch name {
	case carrierdf.FieldTenantID:
		m.ResetTenantID()
		return nil
	case carrierdf.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case carrierdf.FieldAgreementNumber:
		m.ResetAgreementNumber()
		return nil
	case carrierdf.FieldWhoPays:
		m.ResetWhoPays()
		return nil
	case carrierdf.FieldTest:
		m.ResetTest()
		return nil
	}
	return fmt.Errorf("unknown CarrierDF field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierDFMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, carrierdf.EdgeTenant)
	}
	if m.carrier != nil {
		edges = append(edges, carrierdf.EdgeCarrier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierDFMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierdf.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case carrierdf.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierDFMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierDFMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierDFMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, carrierdf.EdgeTenant)
	}
	if m.clearedcarrier {
		edges = append(edges, carrierdf.EdgeCarrier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierDFMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierdf.EdgeTenant:
		return m.clearedtenant
	case carrierdf.EdgeCarrier:
		return m.clearedcarrier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierDFMutation) ClearEdge(name string) error {
	switch name {
	case carrierdf.EdgeTenant:
		m.ClearTenant()
		return nil
	case carrierdf.EdgeCarrier:
		m.ClearCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierDF unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierDFMutation) ResetEdge(name string) error {
	switch name {
	case carrierdf.EdgeTenant:
		m.ResetTenant()
		return nil
	case carrierdf.EdgeCarrier:
		m.ResetCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierDF edge %s", name)
}

// CarrierDSVMutation represents an operation that mutates the CarrierDSV nodes in the graph.
type CarrierDSVMutation struct {
	config
	op             Op
	typ            string
	id             *pulid.ID
	clearedFields  map[string]struct{}
	tenant         *pulid.ID
	clearedtenant  bool
	carrier        *pulid.ID
	clearedcarrier bool
	done           bool
	oldValue       func(context.Context) (*CarrierDSV, error)
	predicates     []predicate.CarrierDSV
}

var _ ent.Mutation = (*CarrierDSVMutation)(nil)

// carrierdsvOption allows management of the mutation configuration using functional options.
type carrierdsvOption func(*CarrierDSVMutation)

// newCarrierDSVMutation creates new mutation for the CarrierDSV entity.
func newCarrierDSVMutation(c config, op Op, opts ...carrierdsvOption) *CarrierDSVMutation {
	m := &CarrierDSVMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierDSV,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierDSVID sets the ID field of the mutation.
func withCarrierDSVID(id pulid.ID) carrierdsvOption {
	return func(m *CarrierDSVMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierDSV
		)
		m.oldValue = func(ctx context.Context) (*CarrierDSV, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierDSV.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierDSV sets the old CarrierDSV of the mutation.
func withCarrierDSV(node *CarrierDSV) carrierdsvOption {
	return func(m *CarrierDSVMutation) {
		m.oldValue = func(context.Context) (*CarrierDSV, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierDSVMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierDSVMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierDSV entities.
func (m *CarrierDSVMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierDSVMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierDSVMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierDSV.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CarrierDSVMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarrierDSVMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CarrierDSV entity.
// If the CarrierDSV object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierDSVMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarrierDSVMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarrierDSVMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[carrierdsv.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarrierDSVMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarrierDSVMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarrierDSVMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *CarrierDSVMutation) SetCarrierID(id pulid.ID) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *CarrierDSVMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *CarrierDSVMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *CarrierDSVMutation) CarrierID() (id pulid.ID, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *CarrierDSVMutation) CarrierIDs() (ids []pulid.ID) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *CarrierDSVMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// Where appends a list predicates to the CarrierDSVMutation builder.
func (m *CarrierDSVMutation) Where(ps ...predicate.CarrierDSV) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierDSVMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierDSVMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierDSV, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierDSVMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierDSVMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierDSV).
func (m *CarrierDSVMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierDSVMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tenant != nil {
		fields = append(fields, carrierdsv.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierDSVMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierdsv.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierDSVMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierdsv.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierDSV field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierDSVMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierdsv.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierDSV field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierDSVMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierDSVMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierDSVMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierDSV numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierDSVMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierDSVMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierDSVMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierDSV nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierDSVMutation) ResetField(name string) error {
	switch name {
	case carrierdsv.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown CarrierDSV field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierDSVMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, carrierdsv.EdgeTenant)
	}
	if m.carrier != nil {
		edges = append(edges, carrierdsv.EdgeCarrier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierDSVMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierdsv.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case carrierdsv.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierDSVMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierDSVMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierDSVMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, carrierdsv.EdgeTenant)
	}
	if m.clearedcarrier {
		edges = append(edges, carrierdsv.EdgeCarrier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierDSVMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierdsv.EdgeTenant:
		return m.clearedtenant
	case carrierdsv.EdgeCarrier:
		return m.clearedcarrier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierDSVMutation) ClearEdge(name string) error {
	switch name {
	case carrierdsv.EdgeTenant:
		m.ClearTenant()
		return nil
	case carrierdsv.EdgeCarrier:
		m.ClearCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierDSV unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierDSVMutation) ResetEdge(name string) error {
	switch name {
	case carrierdsv.EdgeTenant:
		m.ResetTenant()
		return nil
	case carrierdsv.EdgeCarrier:
		m.ResetCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierDSV edge %s", name)
}

// CarrierEasyPostMutation represents an operation that mutates the CarrierEasyPost nodes in the graph.
type CarrierEasyPostMutation struct {
	config
	op                     Op
	typ                    string
	id                     *pulid.ID
	api_key                *string
	test                   *bool
	carrier_accounts       *[]string
	appendcarrier_accounts []string
	clearedFields          map[string]struct{}
	tenant                 *pulid.ID
	clearedtenant          bool
	carrier                *pulid.ID
	clearedcarrier         bool
	done                   bool
	oldValue               func(context.Context) (*CarrierEasyPost, error)
	predicates             []predicate.CarrierEasyPost
}

var _ ent.Mutation = (*CarrierEasyPostMutation)(nil)

// carriereasypostOption allows management of the mutation configuration using functional options.
type carriereasypostOption func(*CarrierEasyPostMutation)

// newCarrierEasyPostMutation creates new mutation for the CarrierEasyPost entity.
func newCarrierEasyPostMutation(c config, op Op, opts ...carriereasypostOption) *CarrierEasyPostMutation {
	m := &CarrierEasyPostMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierEasyPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierEasyPostID sets the ID field of the mutation.
func withCarrierEasyPostID(id pulid.ID) carriereasypostOption {
	return func(m *CarrierEasyPostMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierEasyPost
		)
		m.oldValue = func(ctx context.Context) (*CarrierEasyPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierEasyPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierEasyPost sets the old CarrierEasyPost of the mutation.
func withCarrierEasyPost(node *CarrierEasyPost) carriereasypostOption {
	return func(m *CarrierEasyPostMutation) {
		m.oldValue = func(context.Context) (*CarrierEasyPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierEasyPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierEasyPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierEasyPost entities.
func (m *CarrierEasyPostMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierEasyPostMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierEasyPostMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierEasyPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CarrierEasyPostMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarrierEasyPostMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CarrierEasyPost entity.
// If the CarrierEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierEasyPostMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarrierEasyPostMutation) ResetTenantID() {
	m.tenant = nil
}

// SetAPIKey sets the "api_key" field.
func (m *CarrierEasyPostMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *CarrierEasyPostMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the CarrierEasyPost entity.
// If the CarrierEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierEasyPostMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *CarrierEasyPostMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetTest sets the "test" field.
func (m *CarrierEasyPostMutation) SetTest(b bool) {
	m.test = &b
}

// Test returns the value of the "test" field in the mutation.
func (m *CarrierEasyPostMutation) Test() (r bool, exists bool) {
	v := m.test
	if v == nil {
		return
	}
	return *v, true
}

// OldTest returns the old "test" field's value of the CarrierEasyPost entity.
// If the CarrierEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierEasyPostMutation) OldTest(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTest: %w", err)
	}
	return oldValue.Test, nil
}

// ResetTest resets all changes to the "test" field.
func (m *CarrierEasyPostMutation) ResetTest() {
	m.test = nil
}

// SetCarrierAccounts sets the "carrier_accounts" field.
func (m *CarrierEasyPostMutation) SetCarrierAccounts(s []string) {
	m.carrier_accounts = &s
	m.appendcarrier_accounts = nil
}

// CarrierAccounts returns the value of the "carrier_accounts" field in the mutation.
func (m *CarrierEasyPostMutation) CarrierAccounts() (r []string, exists bool) {
	v := m.carrier_accounts
	if v == nil {
		return
	}
	return *v, true
}

// OldCarrierAccounts returns the old "carrier_accounts" field's value of the CarrierEasyPost entity.
// If the CarrierEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierEasyPostMutation) OldCarrierAccounts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarrierAccounts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarrierAccounts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarrierAccounts: %w", err)
	}
	return oldValue.CarrierAccounts, nil
}

// AppendCarrierAccounts adds s to the "carrier_accounts" field.
func (m *CarrierEasyPostMutation) AppendCarrierAccounts(s []string) {
	m.appendcarrier_accounts = append(m.appendcarrier_accounts, s...)
}

// AppendedCarrierAccounts returns the list of values that were appended to the "carrier_accounts" field in this mutation.
func (m *CarrierEasyPostMutation) AppendedCarrierAccounts() ([]string, bool) {
	if len(m.appendcarrier_accounts) == 0 {
		return nil, false
	}
	return m.appendcarrier_accounts, true
}

// ResetCarrierAccounts resets all changes to the "carrier_accounts" field.
func (m *CarrierEasyPostMutation) ResetCarrierAccounts() {
	m.carrier_accounts = nil
	m.appendcarrier_accounts = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarrierEasyPostMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[carriereasypost.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarrierEasyPostMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarrierEasyPostMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarrierEasyPostMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *CarrierEasyPostMutation) SetCarrierID(id pulid.ID) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *CarrierEasyPostMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *CarrierEasyPostMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *CarrierEasyPostMutation) CarrierID() (id pulid.ID, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *CarrierEasyPostMutation) CarrierIDs() (ids []pulid.ID) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *CarrierEasyPostMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// Where appends a list predicates to the CarrierEasyPostMutation builder.
func (m *CarrierEasyPostMutation) Where(ps ...predicate.CarrierEasyPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierEasyPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierEasyPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierEasyPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierEasyPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierEasyPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierEasyPost).
func (m *CarrierEasyPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierEasyPostMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, carriereasypost.FieldTenantID)
	}
	if m.api_key != nil {
		fields = append(fields, carriereasypost.FieldAPIKey)
	}
	if m.test != nil {
		fields = append(fields, carriereasypost.FieldTest)
	}
	if m.carrier_accounts != nil {
		fields = append(fields, carriereasypost.FieldCarrierAccounts)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierEasyPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carriereasypost.FieldTenantID:
		return m.TenantID()
	case carriereasypost.FieldAPIKey:
		return m.APIKey()
	case carriereasypost.FieldTest:
		return m.Test()
	case carriereasypost.FieldCarrierAccounts:
		return m.CarrierAccounts()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierEasyPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carriereasypost.FieldTenantID:
		return m.OldTenantID(ctx)
	case carriereasypost.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case carriereasypost.FieldTest:
		return m.OldTest(ctx)
	case carriereasypost.FieldCarrierAccounts:
		return m.OldCarrierAccounts(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierEasyPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierEasyPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carriereasypost.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case carriereasypost.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case carriereasypost.FieldTest:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTest(v)
		return nil
	case carriereasypost.FieldCarrierAccounts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarrierAccounts(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierEasyPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierEasyPostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierEasyPostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierEasyPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierEasyPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierEasyPostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierEasyPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierEasyPostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierEasyPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierEasyPostMutation) ResetField(name string) error {
	switch name {
	case carriereasypost.FieldTenantID:
		m.ResetTenantID()
		return nil
	case carriereasypost.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case carriereasypost.FieldTest:
		m.ResetTest()
		return nil
	case carriereasypost.FieldCarrierAccounts:
		m.ResetCarrierAccounts()
		return nil
	}
	return fmt.Errorf("unknown CarrierEasyPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierEasyPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, carriereasypost.EdgeTenant)
	}
	if m.carrier != nil {
		edges = append(edges, carriereasypost.EdgeCarrier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierEasyPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carriereasypost.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case carriereasypost.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierEasyPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierEasyPostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierEasyPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, carriereasypost.EdgeTenant)
	}
	if m.clearedcarrier {
		edges = append(edges, carriereasypost.EdgeCarrier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierEasyPostMutation) EdgeCleared(name string) bool {
	switch name {
	case carriereasypost.EdgeTenant:
		return m.clearedtenant
	case carriereasypost.EdgeCarrier:
		return m.clearedcarrier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierEasyPostMutation) ClearEdge(name string) error {
	switch name {
	case carriereasypost.EdgeTenant:
		m.ClearTenant()
		return nil
	case carriereasypost.EdgeCarrier:
		m.ClearCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierEasyPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierEasyPostMutation) ResetEdge(name string) error {
	switch name {
	case carriereasypost.EdgeTenant:
		m.ResetTenant()
		return nil
	case carriereasypost.EdgeCarrier:
		m.ResetCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierEasyPost edge %s", name)
}

// CarrierGLSMutation represents an operation that mutates the CarrierGLS nodes in the graph.
type CarrierGLSMutation struct {
	config
	op                         Op
	typ                        string
	id                         *pulid.ID
	contact_id                 *string
	gls_username               *string
	gls_password               *string
	customer_id                *string
	gls_country_code           *string
	sync_shipment_cancellation *bool
	print_error_on_label       *bool
	clearedFields              map[string]struct{}
	tenant                     *pulid.ID
	clearedtenant              bool
	carrier                    *pulid.ID
	clearedcarrier             bool
	done                       bool
	oldValue                   func(context.Context) (*CarrierGLS, error)
	predicates                 []predicate.CarrierGLS
}

var _ ent.Mutation = (*CarrierGLSMutation)(nil)

// carrierglsOption allows management of the mutation configuration using functional options.
type carrierglsOption func(*CarrierGLSMutation)

// newCarrierGLSMutation creates new mutation for the CarrierGLS entity.
func newCarrierGLSMutation(c config, op Op, opts ...carrierglsOption) *CarrierGLSMutation {
	m := &CarrierGLSMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierGLS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierGLSID sets the ID field of the mutation.
func withCarrierGLSID(id pulid.ID) carrierglsOption {
	return func(m *CarrierGLSMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierGLS
		)
		m.oldValue = func(ctx context.Context) (*CarrierGLS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierGLS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierGLS sets the old CarrierGLS of the mutation.
func withCarrierGLS(node *CarrierGLS) carrierglsOption {
	return func(m *CarrierGLSMutation) {
		m.oldValue = func(context.Context) (*CarrierGLS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierGLSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierGLSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierGLS entities.
func (m *CarrierGLSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierGLSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierGLSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierGLS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CarrierGLSMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarrierGLSMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CarrierGLS entity.
// If the CarrierGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierGLSMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarrierGLSMutation) ResetTenantID() {
	m.tenant = nil
}

// SetContactID sets the "contact_id" field.
func (m *CarrierGLSMutation) SetContactID(s string) {
	m.contact_id = &s
}

// ContactID returns the value of the "contact_id" field in the mutation.
func (m *CarrierGLSMutation) ContactID() (r string, exists bool) {
	v := m.contact_id
	if v == nil {
		return
	}
	return *v, true
}

// OldContactID returns the old "contact_id" field's value of the CarrierGLS entity.
// If the CarrierGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierGLSMutation) OldContactID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContactID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContactID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContactID: %w", err)
	}
	return oldValue.ContactID, nil
}

// ClearContactID clears the value of the "contact_id" field.
func (m *CarrierGLSMutation) ClearContactID() {
	m.contact_id = nil
	m.clearedFields[carriergls.FieldContactID] = struct{}{}
}

// ContactIDCleared returns if the "contact_id" field was cleared in this mutation.
func (m *CarrierGLSMutation) ContactIDCleared() bool {
	_, ok := m.clearedFields[carriergls.FieldContactID]
	return ok
}

// ResetContactID resets all changes to the "contact_id" field.
func (m *CarrierGLSMutation) ResetContactID() {
	m.contact_id = nil
	delete(m.clearedFields, carriergls.FieldContactID)
}

// SetGLSUsername sets the "gls_username" field.
func (m *CarrierGLSMutation) SetGLSUsername(s string) {
	m.gls_username = &s
}

// GLSUsername returns the value of the "gls_username" field in the mutation.
func (m *CarrierGLSMutation) GLSUsername() (r string, exists bool) {
	v := m.gls_username
	if v == nil {
		return
	}
	return *v, true
}

// OldGLSUsername returns the old "gls_username" field's value of the CarrierGLS entity.
// If the CarrierGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierGLSMutation) OldGLSUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGLSUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGLSUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGLSUsername: %w", err)
	}
	return oldValue.GLSUsername, nil
}

// ClearGLSUsername clears the value of the "gls_username" field.
func (m *CarrierGLSMutation) ClearGLSUsername() {
	m.gls_username = nil
	m.clearedFields[carriergls.FieldGLSUsername] = struct{}{}
}

// GLSUsernameCleared returns if the "gls_username" field was cleared in this mutation.
func (m *CarrierGLSMutation) GLSUsernameCleared() bool {
	_, ok := m.clearedFields[carriergls.FieldGLSUsername]
	return ok
}

// ResetGLSUsername resets all changes to the "gls_username" field.
func (m *CarrierGLSMutation) ResetGLSUsername() {
	m.gls_username = nil
	delete(m.clearedFields, carriergls.FieldGLSUsername)
}

// SetGLSPassword sets the "gls_password" field.
func (m *CarrierGLSMutation) SetGLSPassword(s string) {
	m.gls_password = &s
}

// GLSPassword returns the value of the "gls_password" field in the mutation.
func (m *CarrierGLSMutation) GLSPassword() (r string, exists bool) {
	v := m.gls_password
	if v == nil {
		return
	}
	return *v, true
}

// OldGLSPassword returns the old "gls_password" field's value of the CarrierGLS entity.
// If the CarrierGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierGLSMutation) OldGLSPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGLSPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGLSPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGLSPassword: %w", err)
	}
	return oldValue.GLSPassword, nil
}

// ClearGLSPassword clears the value of the "gls_password" field.
func (m *CarrierGLSMutation) ClearGLSPassword() {
	m.gls_password = nil
	m.clearedFields[carriergls.FieldGLSPassword] = struct{}{}
}

// GLSPasswordCleared returns if the "gls_password" field was cleared in this mutation.
func (m *CarrierGLSMutation) GLSPasswordCleared() bool {
	_, ok := m.clearedFields[carriergls.FieldGLSPassword]
	return ok
}

// ResetGLSPassword resets all changes to the "gls_password" field.
func (m *CarrierGLSMutation) ResetGLSPassword() {
	m.gls_password = nil
	delete(m.clearedFields, carriergls.FieldGLSPassword)
}

// SetCustomerID sets the "customer_id" field.
func (m *CarrierGLSMutation) SetCustomerID(s string) {
	m.customer_id = &s
}

// CustomerID returns the value of the "customer_id" field in the mutation.
func (m *CarrierGLSMutation) CustomerID() (r string, exists bool) {
	v := m.customer_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerID returns the old "customer_id" field's value of the CarrierGLS entity.
// If the CarrierGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierGLSMutation) OldCustomerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerID: %w", err)
	}
	return oldValue.CustomerID, nil
}

// ClearCustomerID clears the value of the "customer_id" field.
func (m *CarrierGLSMutation) ClearCustomerID() {
	m.customer_id = nil
	m.clearedFields[carriergls.FieldCustomerID] = struct{}{}
}

// CustomerIDCleared returns if the "customer_id" field was cleared in this mutation.
func (m *CarrierGLSMutation) CustomerIDCleared() bool {
	_, ok := m.clearedFields[carriergls.FieldCustomerID]
	return ok
}

// ResetCustomerID resets all changes to the "customer_id" field.
func (m *CarrierGLSMutation) ResetCustomerID() {
	m.customer_id = nil
	delete(m.clearedFields, carriergls.FieldCustomerID)
}

// SetGLSCountryCode sets the "gls_country_code" field.
func (m *CarrierGLSMutation) SetGLSCountryCode(s string) {
	m.gls_country_code = &s
}

// GLSCountryCode returns the value of the "gls_country_code" field in the mutation.
func (m *CarrierGLSMutation) GLSCountryCode() (r string, exists bool) {
	v := m.gls_country_code
	if v == nil {
		return
	}
	return *v, true
}

// OldGLSCountryCode returns the old "gls_country_code" field's value of the CarrierGLS entity.
// If the CarrierGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierGLSMutation) OldGLSCountryCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGLSCountryCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGLSCountryCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGLSCountryCode: %w", err)
	}
	return oldValue.GLSCountryCode, nil
}

// ClearGLSCountryCode clears the value of the "gls_country_code" field.
func (m *CarrierGLSMutation) ClearGLSCountryCode() {
	m.gls_country_code = nil
	m.clearedFields[carriergls.FieldGLSCountryCode] = struct{}{}
}

// GLSCountryCodeCleared returns if the "gls_country_code" field was cleared in this mutation.
func (m *CarrierGLSMutation) GLSCountryCodeCleared() bool {
	_, ok := m.clearedFields[carriergls.FieldGLSCountryCode]
	return ok
}

// ResetGLSCountryCode resets all changes to the "gls_country_code" field.
func (m *CarrierGLSMutation) ResetGLSCountryCode() {
	m.gls_country_code = nil
	delete(m.clearedFields, carriergls.FieldGLSCountryCode)
}

// SetSyncShipmentCancellation sets the "sync_shipment_cancellation" field.
func (m *CarrierGLSMutation) SetSyncShipmentCancellation(b bool) {
	m.sync_shipment_cancellation = &b
}

// SyncShipmentCancellation returns the value of the "sync_shipment_cancellation" field in the mutation.
func (m *CarrierGLSMutation) SyncShipmentCancellation() (r bool, exists bool) {
	v := m.sync_shipment_cancellation
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncShipmentCancellation returns the old "sync_shipment_cancellation" field's value of the CarrierGLS entity.
// If the CarrierGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierGLSMutation) OldSyncShipmentCancellation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncShipmentCancellation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncShipmentCancellation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncShipmentCancellation: %w", err)
	}
	return oldValue.SyncShipmentCancellation, nil
}

// ClearSyncShipmentCancellation clears the value of the "sync_shipment_cancellation" field.
func (m *CarrierGLSMutation) ClearSyncShipmentCancellation() {
	m.sync_shipment_cancellation = nil
	m.clearedFields[carriergls.FieldSyncShipmentCancellation] = struct{}{}
}

// SyncShipmentCancellationCleared returns if the "sync_shipment_cancellation" field was cleared in this mutation.
func (m *CarrierGLSMutation) SyncShipmentCancellationCleared() bool {
	_, ok := m.clearedFields[carriergls.FieldSyncShipmentCancellation]
	return ok
}

// ResetSyncShipmentCancellation resets all changes to the "sync_shipment_cancellation" field.
func (m *CarrierGLSMutation) ResetSyncShipmentCancellation() {
	m.sync_shipment_cancellation = nil
	delete(m.clearedFields, carriergls.FieldSyncShipmentCancellation)
}

// SetPrintErrorOnLabel sets the "print_error_on_label" field.
func (m *CarrierGLSMutation) SetPrintErrorOnLabel(b bool) {
	m.print_error_on_label = &b
}

// PrintErrorOnLabel returns the value of the "print_error_on_label" field in the mutation.
func (m *CarrierGLSMutation) PrintErrorOnLabel() (r bool, exists bool) {
	v := m.print_error_on_label
	if v == nil {
		return
	}
	return *v, true
}

// OldPrintErrorOnLabel returns the old "print_error_on_label" field's value of the CarrierGLS entity.
// If the CarrierGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierGLSMutation) OldPrintErrorOnLabel(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrintErrorOnLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrintErrorOnLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrintErrorOnLabel: %w", err)
	}
	return oldValue.PrintErrorOnLabel, nil
}

// ClearPrintErrorOnLabel clears the value of the "print_error_on_label" field.
func (m *CarrierGLSMutation) ClearPrintErrorOnLabel() {
	m.print_error_on_label = nil
	m.clearedFields[carriergls.FieldPrintErrorOnLabel] = struct{}{}
}

// PrintErrorOnLabelCleared returns if the "print_error_on_label" field was cleared in this mutation.
func (m *CarrierGLSMutation) PrintErrorOnLabelCleared() bool {
	_, ok := m.clearedFields[carriergls.FieldPrintErrorOnLabel]
	return ok
}

// ResetPrintErrorOnLabel resets all changes to the "print_error_on_label" field.
func (m *CarrierGLSMutation) ResetPrintErrorOnLabel() {
	m.print_error_on_label = nil
	delete(m.clearedFields, carriergls.FieldPrintErrorOnLabel)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarrierGLSMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[carriergls.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarrierGLSMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarrierGLSMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarrierGLSMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *CarrierGLSMutation) SetCarrierID(id pulid.ID) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *CarrierGLSMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *CarrierGLSMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *CarrierGLSMutation) CarrierID() (id pulid.ID, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *CarrierGLSMutation) CarrierIDs() (ids []pulid.ID) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *CarrierGLSMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// Where appends a list predicates to the CarrierGLSMutation builder.
func (m *CarrierGLSMutation) Where(ps ...predicate.CarrierGLS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierGLSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierGLSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierGLS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierGLSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierGLSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierGLS).
func (m *CarrierGLSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierGLSMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant != nil {
		fields = append(fields, carriergls.FieldTenantID)
	}
	if m.contact_id != nil {
		fields = append(fields, carriergls.FieldContactID)
	}
	if m.gls_username != nil {
		fields = append(fields, carriergls.FieldGLSUsername)
	}
	if m.gls_password != nil {
		fields = append(fields, carriergls.FieldGLSPassword)
	}
	if m.customer_id != nil {
		fields = append(fields, carriergls.FieldCustomerID)
	}
	if m.gls_country_code != nil {
		fields = append(fields, carriergls.FieldGLSCountryCode)
	}
	if m.sync_shipment_cancellation != nil {
		fields = append(fields, carriergls.FieldSyncShipmentCancellation)
	}
	if m.print_error_on_label != nil {
		fields = append(fields, carriergls.FieldPrintErrorOnLabel)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierGLSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carriergls.FieldTenantID:
		return m.TenantID()
	case carriergls.FieldContactID:
		return m.ContactID()
	case carriergls.FieldGLSUsername:
		return m.GLSUsername()
	case carriergls.FieldGLSPassword:
		return m.GLSPassword()
	case carriergls.FieldCustomerID:
		return m.CustomerID()
	case carriergls.FieldGLSCountryCode:
		return m.GLSCountryCode()
	case carriergls.FieldSyncShipmentCancellation:
		return m.SyncShipmentCancellation()
	case carriergls.FieldPrintErrorOnLabel:
		return m.PrintErrorOnLabel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierGLSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carriergls.FieldTenantID:
		return m.OldTenantID(ctx)
	case carriergls.FieldContactID:
		return m.OldContactID(ctx)
	case carriergls.FieldGLSUsername:
		return m.OldGLSUsername(ctx)
	case carriergls.FieldGLSPassword:
		return m.OldGLSPassword(ctx)
	case carriergls.FieldCustomerID:
		return m.OldCustomerID(ctx)
	case carriergls.FieldGLSCountryCode:
		return m.OldGLSCountryCode(ctx)
	case carriergls.FieldSyncShipmentCancellation:
		return m.OldSyncShipmentCancellation(ctx)
	case carriergls.FieldPrintErrorOnLabel:
		return m.OldPrintErrorOnLabel(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierGLS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierGLSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carriergls.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case carriergls.FieldContactID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContactID(v)
		return nil
	case carriergls.FieldGLSUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGLSUsername(v)
		return nil
	case carriergls.FieldGLSPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGLSPassword(v)
		return nil
	case carriergls.FieldCustomerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerID(v)
		return nil
	case carriergls.FieldGLSCountryCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGLSCountryCode(v)
		return nil
	case carriergls.FieldSyncShipmentCancellation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncShipmentCancellation(v)
		return nil
	case carriergls.FieldPrintErrorOnLabel:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrintErrorOnLabel(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierGLS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierGLSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierGLSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierGLSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierGLS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierGLSMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carriergls.FieldContactID) {
		fields = append(fields, carriergls.FieldContactID)
	}
	if m.FieldCleared(carriergls.FieldGLSUsername) {
		fields = append(fields, carriergls.FieldGLSUsername)
	}
	if m.FieldCleared(carriergls.FieldGLSPassword) {
		fields = append(fields, carriergls.FieldGLSPassword)
	}
	if m.FieldCleared(carriergls.FieldCustomerID) {
		fields = append(fields, carriergls.FieldCustomerID)
	}
	if m.FieldCleared(carriergls.FieldGLSCountryCode) {
		fields = append(fields, carriergls.FieldGLSCountryCode)
	}
	if m.FieldCleared(carriergls.FieldSyncShipmentCancellation) {
		fields = append(fields, carriergls.FieldSyncShipmentCancellation)
	}
	if m.FieldCleared(carriergls.FieldPrintErrorOnLabel) {
		fields = append(fields, carriergls.FieldPrintErrorOnLabel)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierGLSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierGLSMutation) ClearField(name string) error {
	switch name {
	case carriergls.FieldContactID:
		m.ClearContactID()
		return nil
	case carriergls.FieldGLSUsername:
		m.ClearGLSUsername()
		return nil
	case carriergls.FieldGLSPassword:
		m.ClearGLSPassword()
		return nil
	case carriergls.FieldCustomerID:
		m.ClearCustomerID()
		return nil
	case carriergls.FieldGLSCountryCode:
		m.ClearGLSCountryCode()
		return nil
	case carriergls.FieldSyncShipmentCancellation:
		m.ClearSyncShipmentCancellation()
		return nil
	case carriergls.FieldPrintErrorOnLabel:
		m.ClearPrintErrorOnLabel()
		return nil
	}
	return fmt.Errorf("unknown CarrierGLS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierGLSMutation) ResetField(name string) error {
	switch name {
	case carriergls.FieldTenantID:
		m.ResetTenantID()
		return nil
	case carriergls.FieldContactID:
		m.ResetContactID()
		return nil
	case carriergls.FieldGLSUsername:
		m.ResetGLSUsername()
		return nil
	case carriergls.FieldGLSPassword:
		m.ResetGLSPassword()
		return nil
	case carriergls.FieldCustomerID:
		m.ResetCustomerID()
		return nil
	case carriergls.FieldGLSCountryCode:
		m.ResetGLSCountryCode()
		return nil
	case carriergls.FieldSyncShipmentCancellation:
		m.ResetSyncShipmentCancellation()
		return nil
	case carriergls.FieldPrintErrorOnLabel:
		m.ResetPrintErrorOnLabel()
		return nil
	}
	return fmt.Errorf("unknown CarrierGLS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierGLSMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, carriergls.EdgeTenant)
	}
	if m.carrier != nil {
		edges = append(edges, carriergls.EdgeCarrier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierGLSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carriergls.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case carriergls.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierGLSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierGLSMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierGLSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, carriergls.EdgeTenant)
	}
	if m.clearedcarrier {
		edges = append(edges, carriergls.EdgeCarrier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierGLSMutation) EdgeCleared(name string) bool {
	switch name {
	case carriergls.EdgeTenant:
		return m.clearedtenant
	case carriergls.EdgeCarrier:
		return m.clearedcarrier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierGLSMutation) ClearEdge(name string) error {
	switch name {
	case carriergls.EdgeTenant:
		m.ClearTenant()
		return nil
	case carriergls.EdgeCarrier:
		m.ClearCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierGLS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierGLSMutation) ResetEdge(name string) error {
	switch name {
	case carriergls.EdgeTenant:
		m.ResetTenant()
		return nil
	case carriergls.EdgeCarrier:
		m.ResetCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierGLS edge %s", name)
}

// CarrierPostNordMutation represents an operation that mutates the CarrierPostNord nodes in the graph.
type CarrierPostNordMutation struct {
	config
	op              Op
	typ             string
	id              *pulid.ID
	customer_number *string
	clearedFields   map[string]struct{}
	tenant          *pulid.ID
	clearedtenant   bool
	carrier         *pulid.ID
	clearedcarrier  bool
	done            bool
	oldValue        func(context.Context) (*CarrierPostNord, error)
	predicates      []predicate.CarrierPostNord
}

var _ ent.Mutation = (*CarrierPostNordMutation)(nil)

// carrierpostnordOption allows management of the mutation configuration using functional options.
type carrierpostnordOption func(*CarrierPostNordMutation)

// newCarrierPostNordMutation creates new mutation for the CarrierPostNord entity.
func newCarrierPostNordMutation(c config, op Op, opts ...carrierpostnordOption) *CarrierPostNordMutation {
	m := &CarrierPostNordMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierPostNord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierPostNordID sets the ID field of the mutation.
func withCarrierPostNordID(id pulid.ID) carrierpostnordOption {
	return func(m *CarrierPostNordMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierPostNord
		)
		m.oldValue = func(ctx context.Context) (*CarrierPostNord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierPostNord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierPostNord sets the old CarrierPostNord of the mutation.
func withCarrierPostNord(node *CarrierPostNord) carrierpostnordOption {
	return func(m *CarrierPostNordMutation) {
		m.oldValue = func(context.Context) (*CarrierPostNord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierPostNordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierPostNordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierPostNord entities.
func (m *CarrierPostNordMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierPostNordMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierPostNordMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierPostNord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CarrierPostNordMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarrierPostNordMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CarrierPostNord entity.
// If the CarrierPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierPostNordMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarrierPostNordMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCustomerNumber sets the "customer_number" field.
func (m *CarrierPostNordMutation) SetCustomerNumber(s string) {
	m.customer_number = &s
}

// CustomerNumber returns the value of the "customer_number" field in the mutation.
func (m *CarrierPostNordMutation) CustomerNumber() (r string, exists bool) {
	v := m.customer_number
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomerNumber returns the old "customer_number" field's value of the CarrierPostNord entity.
// If the CarrierPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierPostNordMutation) OldCustomerNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomerNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomerNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomerNumber: %w", err)
	}
	return oldValue.CustomerNumber, nil
}

// ResetCustomerNumber resets all changes to the "customer_number" field.
func (m *CarrierPostNordMutation) ResetCustomerNumber() {
	m.customer_number = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarrierPostNordMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[carrierpostnord.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarrierPostNordMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarrierPostNordMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarrierPostNordMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *CarrierPostNordMutation) SetCarrierID(id pulid.ID) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *CarrierPostNordMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *CarrierPostNordMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *CarrierPostNordMutation) CarrierID() (id pulid.ID, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *CarrierPostNordMutation) CarrierIDs() (ids []pulid.ID) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *CarrierPostNordMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// Where appends a list predicates to the CarrierPostNordMutation builder.
func (m *CarrierPostNordMutation) Where(ps ...predicate.CarrierPostNord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierPostNordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierPostNordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierPostNord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierPostNordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierPostNordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierPostNord).
func (m *CarrierPostNordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierPostNordMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, carrierpostnord.FieldTenantID)
	}
	if m.customer_number != nil {
		fields = append(fields, carrierpostnord.FieldCustomerNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierPostNordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierpostnord.FieldTenantID:
		return m.TenantID()
	case carrierpostnord.FieldCustomerNumber:
		return m.CustomerNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierPostNordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierpostnord.FieldTenantID:
		return m.OldTenantID(ctx)
	case carrierpostnord.FieldCustomerNumber:
		return m.OldCustomerNumber(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierPostNord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierPostNordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierpostnord.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case carrierpostnord.FieldCustomerNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomerNumber(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierPostNord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierPostNordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierPostNordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierPostNordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierPostNord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierPostNordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierPostNordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierPostNordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierPostNord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierPostNordMutation) ResetField(name string) error {
	switch name {
	case carrierpostnord.FieldTenantID:
		m.ResetTenantID()
		return nil
	case carrierpostnord.FieldCustomerNumber:
		m.ResetCustomerNumber()
		return nil
	}
	return fmt.Errorf("unknown CarrierPostNord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierPostNordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, carrierpostnord.EdgeTenant)
	}
	if m.carrier != nil {
		edges = append(edges, carrierpostnord.EdgeCarrier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierPostNordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierpostnord.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case carrierpostnord.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierPostNordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierPostNordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierPostNordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, carrierpostnord.EdgeTenant)
	}
	if m.clearedcarrier {
		edges = append(edges, carrierpostnord.EdgeCarrier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierPostNordMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierpostnord.EdgeTenant:
		return m.clearedtenant
	case carrierpostnord.EdgeCarrier:
		return m.clearedcarrier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierPostNordMutation) ClearEdge(name string) error {
	switch name {
	case carrierpostnord.EdgeTenant:
		m.ClearTenant()
		return nil
	case carrierpostnord.EdgeCarrier:
		m.ClearCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierPostNord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierPostNordMutation) ResetEdge(name string) error {
	switch name {
	case carrierpostnord.EdgeTenant:
		m.ResetTenant()
		return nil
	case carrierpostnord.EdgeCarrier:
		m.ResetCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierPostNord edge %s", name)
}

// CarrierServiceMutation represents an operation that mutates the CarrierService nodes in the graph.
type CarrierServiceMutation struct {
	config
	op                               Op
	typ                              string
	id                               *pulid.ID
	label                            *string
	internal_id                      *string
	_return                          *bool
	consolidation                    *bool
	delivery_point_optional          *bool
	delivery_point_required          *bool
	clearedFields                    map[string]struct{}
	carrier_service_post_nord        *pulid.ID
	clearedcarrier_service_post_nord bool
	carrier_service_dao              *pulid.ID
	clearedcarrier_service_dao       bool
	carrier_service_df               *pulid.ID
	clearedcarrier_service_df        bool
	carrier_service_dsv              *pulid.ID
	clearedcarrier_service_dsv       bool
	carrier_serv_easy_post           *pulid.ID
	clearedcarrier_serv_easy_post    bool
	carrier_service_gls              *pulid.ID
	clearedcarrier_service_gls       bool
	carrier_service_usps             *pulid.ID
	clearedcarrier_service_usps      bool
	carrier_service_bring            *pulid.ID
	clearedcarrier_service_bring     bool
	carrier_brand                    *pulid.ID
	clearedcarrier_brand             bool
	delivery_option                  map[pulid.ID]struct{}
	removeddelivery_option           map[pulid.ID]struct{}
	cleareddelivery_option           bool
	done                             bool
	oldValue                         func(context.Context) (*CarrierService, error)
	predicates                       []predicate.CarrierService
}

var _ ent.Mutation = (*CarrierServiceMutation)(nil)

// carrierserviceOption allows management of the mutation configuration using functional options.
type carrierserviceOption func(*CarrierServiceMutation)

// newCarrierServiceMutation creates new mutation for the CarrierService entity.
func newCarrierServiceMutation(c config, op Op, opts ...carrierserviceOption) *CarrierServiceMutation {
	m := &CarrierServiceMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierService,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierServiceID sets the ID field of the mutation.
func withCarrierServiceID(id pulid.ID) carrierserviceOption {
	return func(m *CarrierServiceMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierService
		)
		m.oldValue = func(ctx context.Context) (*CarrierService, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierService.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierService sets the old CarrierService of the mutation.
func withCarrierService(node *CarrierService) carrierserviceOption {
	return func(m *CarrierServiceMutation) {
		m.oldValue = func(context.Context) (*CarrierService, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierServiceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierServiceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierService entities.
func (m *CarrierServiceMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierServiceMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierServiceMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierService.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierServiceMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierServiceMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierService entity.
// If the CarrierService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierServiceMutation) ResetLabel() {
	m.label = nil
}

// SetInternalID sets the "internal_id" field.
func (m *CarrierServiceMutation) SetInternalID(s string) {
	m.internal_id = &s
}

// InternalID returns the value of the "internal_id" field in the mutation.
func (m *CarrierServiceMutation) InternalID() (r string, exists bool) {
	v := m.internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalID returns the old "internal_id" field's value of the CarrierService entity.
// If the CarrierService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceMutation) OldInternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalID: %w", err)
	}
	return oldValue.InternalID, nil
}

// ResetInternalID resets all changes to the "internal_id" field.
func (m *CarrierServiceMutation) ResetInternalID() {
	m.internal_id = nil
}

// SetReturn sets the "return" field.
func (m *CarrierServiceMutation) SetReturn(b bool) {
	m._return = &b
}

// Return returns the value of the "return" field in the mutation.
func (m *CarrierServiceMutation) Return() (r bool, exists bool) {
	v := m._return
	if v == nil {
		return
	}
	return *v, true
}

// OldReturn returns the old "return" field's value of the CarrierService entity.
// If the CarrierService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceMutation) OldReturn(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReturn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReturn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReturn: %w", err)
	}
	return oldValue.Return, nil
}

// ResetReturn resets all changes to the "return" field.
func (m *CarrierServiceMutation) ResetReturn() {
	m._return = nil
}

// SetConsolidation sets the "consolidation" field.
func (m *CarrierServiceMutation) SetConsolidation(b bool) {
	m.consolidation = &b
}

// Consolidation returns the value of the "consolidation" field in the mutation.
func (m *CarrierServiceMutation) Consolidation() (r bool, exists bool) {
	v := m.consolidation
	if v == nil {
		return
	}
	return *v, true
}

// OldConsolidation returns the old "consolidation" field's value of the CarrierService entity.
// If the CarrierService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceMutation) OldConsolidation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsolidation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsolidation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsolidation: %w", err)
	}
	return oldValue.Consolidation, nil
}

// ResetConsolidation resets all changes to the "consolidation" field.
func (m *CarrierServiceMutation) ResetConsolidation() {
	m.consolidation = nil
}

// SetDeliveryPointOptional sets the "delivery_point_optional" field.
func (m *CarrierServiceMutation) SetDeliveryPointOptional(b bool) {
	m.delivery_point_optional = &b
}

// DeliveryPointOptional returns the value of the "delivery_point_optional" field in the mutation.
func (m *CarrierServiceMutation) DeliveryPointOptional() (r bool, exists bool) {
	v := m.delivery_point_optional
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryPointOptional returns the old "delivery_point_optional" field's value of the CarrierService entity.
// If the CarrierService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceMutation) OldDeliveryPointOptional(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryPointOptional is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryPointOptional requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryPointOptional: %w", err)
	}
	return oldValue.DeliveryPointOptional, nil
}

// ResetDeliveryPointOptional resets all changes to the "delivery_point_optional" field.
func (m *CarrierServiceMutation) ResetDeliveryPointOptional() {
	m.delivery_point_optional = nil
}

// SetDeliveryPointRequired sets the "delivery_point_required" field.
func (m *CarrierServiceMutation) SetDeliveryPointRequired(b bool) {
	m.delivery_point_required = &b
}

// DeliveryPointRequired returns the value of the "delivery_point_required" field in the mutation.
func (m *CarrierServiceMutation) DeliveryPointRequired() (r bool, exists bool) {
	v := m.delivery_point_required
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryPointRequired returns the old "delivery_point_required" field's value of the CarrierService entity.
// If the CarrierService object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceMutation) OldDeliveryPointRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryPointRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryPointRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryPointRequired: %w", err)
	}
	return oldValue.DeliveryPointRequired, nil
}

// ResetDeliveryPointRequired resets all changes to the "delivery_point_required" field.
func (m *CarrierServiceMutation) ResetDeliveryPointRequired() {
	m.delivery_point_required = nil
}

// SetCarrierServicePostNordID sets the "carrier_service_post_nord" edge to the CarrierServicePostNord entity by id.
func (m *CarrierServiceMutation) SetCarrierServicePostNordID(id pulid.ID) {
	m.carrier_service_post_nord = &id
}

// ClearCarrierServicePostNord clears the "carrier_service_post_nord" edge to the CarrierServicePostNord entity.
func (m *CarrierServiceMutation) ClearCarrierServicePostNord() {
	m.clearedcarrier_service_post_nord = true
}

// CarrierServicePostNordCleared reports if the "carrier_service_post_nord" edge to the CarrierServicePostNord entity was cleared.
func (m *CarrierServiceMutation) CarrierServicePostNordCleared() bool {
	return m.clearedcarrier_service_post_nord
}

// CarrierServicePostNordID returns the "carrier_service_post_nord" edge ID in the mutation.
func (m *CarrierServiceMutation) CarrierServicePostNordID() (id pulid.ID, exists bool) {
	if m.carrier_service_post_nord != nil {
		return *m.carrier_service_post_nord, true
	}
	return
}

// CarrierServicePostNordIDs returns the "carrier_service_post_nord" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServicePostNordID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceMutation) CarrierServicePostNordIDs() (ids []pulid.ID) {
	if id := m.carrier_service_post_nord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServicePostNord resets all changes to the "carrier_service_post_nord" edge.
func (m *CarrierServiceMutation) ResetCarrierServicePostNord() {
	m.carrier_service_post_nord = nil
	m.clearedcarrier_service_post_nord = false
}

// SetCarrierServiceDAOID sets the "carrier_service_dao" edge to the CarrierServiceDAO entity by id.
func (m *CarrierServiceMutation) SetCarrierServiceDAOID(id pulid.ID) {
	m.carrier_service_dao = &id
}

// ClearCarrierServiceDAO clears the "carrier_service_dao" edge to the CarrierServiceDAO entity.
func (m *CarrierServiceMutation) ClearCarrierServiceDAO() {
	m.clearedcarrier_service_dao = true
}

// CarrierServiceDAOCleared reports if the "carrier_service_dao" edge to the CarrierServiceDAO entity was cleared.
func (m *CarrierServiceMutation) CarrierServiceDAOCleared() bool {
	return m.clearedcarrier_service_dao
}

// CarrierServiceDAOID returns the "carrier_service_dao" edge ID in the mutation.
func (m *CarrierServiceMutation) CarrierServiceDAOID() (id pulid.ID, exists bool) {
	if m.carrier_service_dao != nil {
		return *m.carrier_service_dao, true
	}
	return
}

// CarrierServiceDAOIDs returns the "carrier_service_dao" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceDAOID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceMutation) CarrierServiceDAOIDs() (ids []pulid.ID) {
	if id := m.carrier_service_dao; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServiceDAO resets all changes to the "carrier_service_dao" edge.
func (m *CarrierServiceMutation) ResetCarrierServiceDAO() {
	m.carrier_service_dao = nil
	m.clearedcarrier_service_dao = false
}

// SetCarrierServiceDFID sets the "carrier_service_df" edge to the CarrierServiceDF entity by id.
func (m *CarrierServiceMutation) SetCarrierServiceDFID(id pulid.ID) {
	m.carrier_service_df = &id
}

// ClearCarrierServiceDF clears the "carrier_service_df" edge to the CarrierServiceDF entity.
func (m *CarrierServiceMutation) ClearCarrierServiceDF() {
	m.clearedcarrier_service_df = true
}

// CarrierServiceDFCleared reports if the "carrier_service_df" edge to the CarrierServiceDF entity was cleared.
func (m *CarrierServiceMutation) CarrierServiceDFCleared() bool {
	return m.clearedcarrier_service_df
}

// CarrierServiceDFID returns the "carrier_service_df" edge ID in the mutation.
func (m *CarrierServiceMutation) CarrierServiceDFID() (id pulid.ID, exists bool) {
	if m.carrier_service_df != nil {
		return *m.carrier_service_df, true
	}
	return
}

// CarrierServiceDFIDs returns the "carrier_service_df" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceDFID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceMutation) CarrierServiceDFIDs() (ids []pulid.ID) {
	if id := m.carrier_service_df; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServiceDF resets all changes to the "carrier_service_df" edge.
func (m *CarrierServiceMutation) ResetCarrierServiceDF() {
	m.carrier_service_df = nil
	m.clearedcarrier_service_df = false
}

// SetCarrierServiceDSVID sets the "carrier_service_dsv" edge to the CarrierServiceDSV entity by id.
func (m *CarrierServiceMutation) SetCarrierServiceDSVID(id pulid.ID) {
	m.carrier_service_dsv = &id
}

// ClearCarrierServiceDSV clears the "carrier_service_dsv" edge to the CarrierServiceDSV entity.
func (m *CarrierServiceMutation) ClearCarrierServiceDSV() {
	m.clearedcarrier_service_dsv = true
}

// CarrierServiceDSVCleared reports if the "carrier_service_dsv" edge to the CarrierServiceDSV entity was cleared.
func (m *CarrierServiceMutation) CarrierServiceDSVCleared() bool {
	return m.clearedcarrier_service_dsv
}

// CarrierServiceDSVID returns the "carrier_service_dsv" edge ID in the mutation.
func (m *CarrierServiceMutation) CarrierServiceDSVID() (id pulid.ID, exists bool) {
	if m.carrier_service_dsv != nil {
		return *m.carrier_service_dsv, true
	}
	return
}

// CarrierServiceDSVIDs returns the "carrier_service_dsv" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceDSVID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceMutation) CarrierServiceDSVIDs() (ids []pulid.ID) {
	if id := m.carrier_service_dsv; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServiceDSV resets all changes to the "carrier_service_dsv" edge.
func (m *CarrierServiceMutation) ResetCarrierServiceDSV() {
	m.carrier_service_dsv = nil
	m.clearedcarrier_service_dsv = false
}

// SetCarrierServEasyPostID sets the "carrier_serv_easy_post" edge to the CarrierServiceEasyPost entity by id.
func (m *CarrierServiceMutation) SetCarrierServEasyPostID(id pulid.ID) {
	m.carrier_serv_easy_post = &id
}

// ClearCarrierServEasyPost clears the "carrier_serv_easy_post" edge to the CarrierServiceEasyPost entity.
func (m *CarrierServiceMutation) ClearCarrierServEasyPost() {
	m.clearedcarrier_serv_easy_post = true
}

// CarrierServEasyPostCleared reports if the "carrier_serv_easy_post" edge to the CarrierServiceEasyPost entity was cleared.
func (m *CarrierServiceMutation) CarrierServEasyPostCleared() bool {
	return m.clearedcarrier_serv_easy_post
}

// CarrierServEasyPostID returns the "carrier_serv_easy_post" edge ID in the mutation.
func (m *CarrierServiceMutation) CarrierServEasyPostID() (id pulid.ID, exists bool) {
	if m.carrier_serv_easy_post != nil {
		return *m.carrier_serv_easy_post, true
	}
	return
}

// CarrierServEasyPostIDs returns the "carrier_serv_easy_post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServEasyPostID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceMutation) CarrierServEasyPostIDs() (ids []pulid.ID) {
	if id := m.carrier_serv_easy_post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServEasyPost resets all changes to the "carrier_serv_easy_post" edge.
func (m *CarrierServiceMutation) ResetCarrierServEasyPost() {
	m.carrier_serv_easy_post = nil
	m.clearedcarrier_serv_easy_post = false
}

// SetCarrierServiceGLSID sets the "carrier_service_gls" edge to the CarrierServiceGLS entity by id.
func (m *CarrierServiceMutation) SetCarrierServiceGLSID(id pulid.ID) {
	m.carrier_service_gls = &id
}

// ClearCarrierServiceGLS clears the "carrier_service_gls" edge to the CarrierServiceGLS entity.
func (m *CarrierServiceMutation) ClearCarrierServiceGLS() {
	m.clearedcarrier_service_gls = true
}

// CarrierServiceGLSCleared reports if the "carrier_service_gls" edge to the CarrierServiceGLS entity was cleared.
func (m *CarrierServiceMutation) CarrierServiceGLSCleared() bool {
	return m.clearedcarrier_service_gls
}

// CarrierServiceGLSID returns the "carrier_service_gls" edge ID in the mutation.
func (m *CarrierServiceMutation) CarrierServiceGLSID() (id pulid.ID, exists bool) {
	if m.carrier_service_gls != nil {
		return *m.carrier_service_gls, true
	}
	return
}

// CarrierServiceGLSIDs returns the "carrier_service_gls" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceGLSID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceMutation) CarrierServiceGLSIDs() (ids []pulid.ID) {
	if id := m.carrier_service_gls; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServiceGLS resets all changes to the "carrier_service_gls" edge.
func (m *CarrierServiceMutation) ResetCarrierServiceGLS() {
	m.carrier_service_gls = nil
	m.clearedcarrier_service_gls = false
}

// SetCarrierServiceUSPSID sets the "carrier_service_usps" edge to the CarrierServiceUSPS entity by id.
func (m *CarrierServiceMutation) SetCarrierServiceUSPSID(id pulid.ID) {
	m.carrier_service_usps = &id
}

// ClearCarrierServiceUSPS clears the "carrier_service_usps" edge to the CarrierServiceUSPS entity.
func (m *CarrierServiceMutation) ClearCarrierServiceUSPS() {
	m.clearedcarrier_service_usps = true
}

// CarrierServiceUSPSCleared reports if the "carrier_service_usps" edge to the CarrierServiceUSPS entity was cleared.
func (m *CarrierServiceMutation) CarrierServiceUSPSCleared() bool {
	return m.clearedcarrier_service_usps
}

// CarrierServiceUSPSID returns the "carrier_service_usps" edge ID in the mutation.
func (m *CarrierServiceMutation) CarrierServiceUSPSID() (id pulid.ID, exists bool) {
	if m.carrier_service_usps != nil {
		return *m.carrier_service_usps, true
	}
	return
}

// CarrierServiceUSPSIDs returns the "carrier_service_usps" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceUSPSID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceMutation) CarrierServiceUSPSIDs() (ids []pulid.ID) {
	if id := m.carrier_service_usps; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServiceUSPS resets all changes to the "carrier_service_usps" edge.
func (m *CarrierServiceMutation) ResetCarrierServiceUSPS() {
	m.carrier_service_usps = nil
	m.clearedcarrier_service_usps = false
}

// SetCarrierServiceBringID sets the "carrier_service_bring" edge to the CarrierServiceBring entity by id.
func (m *CarrierServiceMutation) SetCarrierServiceBringID(id pulid.ID) {
	m.carrier_service_bring = &id
}

// ClearCarrierServiceBring clears the "carrier_service_bring" edge to the CarrierServiceBring entity.
func (m *CarrierServiceMutation) ClearCarrierServiceBring() {
	m.clearedcarrier_service_bring = true
}

// CarrierServiceBringCleared reports if the "carrier_service_bring" edge to the CarrierServiceBring entity was cleared.
func (m *CarrierServiceMutation) CarrierServiceBringCleared() bool {
	return m.clearedcarrier_service_bring
}

// CarrierServiceBringID returns the "carrier_service_bring" edge ID in the mutation.
func (m *CarrierServiceMutation) CarrierServiceBringID() (id pulid.ID, exists bool) {
	if m.carrier_service_bring != nil {
		return *m.carrier_service_bring, true
	}
	return
}

// CarrierServiceBringIDs returns the "carrier_service_bring" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceBringID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceMutation) CarrierServiceBringIDs() (ids []pulid.ID) {
	if id := m.carrier_service_bring; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierServiceBring resets all changes to the "carrier_service_bring" edge.
func (m *CarrierServiceMutation) ResetCarrierServiceBring() {
	m.carrier_service_bring = nil
	m.clearedcarrier_service_bring = false
}

// SetCarrierBrandID sets the "carrier_brand" edge to the CarrierBrand entity by id.
func (m *CarrierServiceMutation) SetCarrierBrandID(id pulid.ID) {
	m.carrier_brand = &id
}

// ClearCarrierBrand clears the "carrier_brand" edge to the CarrierBrand entity.
func (m *CarrierServiceMutation) ClearCarrierBrand() {
	m.clearedcarrier_brand = true
}

// CarrierBrandCleared reports if the "carrier_brand" edge to the CarrierBrand entity was cleared.
func (m *CarrierServiceMutation) CarrierBrandCleared() bool {
	return m.clearedcarrier_brand
}

// CarrierBrandID returns the "carrier_brand" edge ID in the mutation.
func (m *CarrierServiceMutation) CarrierBrandID() (id pulid.ID, exists bool) {
	if m.carrier_brand != nil {
		return *m.carrier_brand, true
	}
	return
}

// CarrierBrandIDs returns the "carrier_brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierBrandID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceMutation) CarrierBrandIDs() (ids []pulid.ID) {
	if id := m.carrier_brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierBrand resets all changes to the "carrier_brand" edge.
func (m *CarrierServiceMutation) ResetCarrierBrand() {
	m.carrier_brand = nil
	m.clearedcarrier_brand = false
}

// AddDeliveryOptionIDs adds the "delivery_option" edge to the DeliveryOption entity by ids.
func (m *CarrierServiceMutation) AddDeliveryOptionIDs(ids ...pulid.ID) {
	if m.delivery_option == nil {
		m.delivery_option = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *CarrierServiceMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *CarrierServiceMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// RemoveDeliveryOptionIDs removes the "delivery_option" edge to the DeliveryOption entity by IDs.
func (m *CarrierServiceMutation) RemoveDeliveryOptionIDs(ids ...pulid.ID) {
	if m.removeddelivery_option == nil {
		m.removeddelivery_option = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option, ids[i])
		m.removeddelivery_option[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOption returns the removed IDs of the "delivery_option" edge to the DeliveryOption entity.
func (m *CarrierServiceMutation) RemovedDeliveryOptionIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
func (m *CarrierServiceMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	for id := range m.delivery_option {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *CarrierServiceMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
	m.removeddelivery_option = nil
}

// Where appends a list predicates to the CarrierServiceMutation builder.
func (m *CarrierServiceMutation) Where(ps ...predicate.CarrierService) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierServiceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierServiceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierService, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierServiceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierServiceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierService).
func (m *CarrierServiceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierServiceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.label != nil {
		fields = append(fields, carrierservice.FieldLabel)
	}
	if m.internal_id != nil {
		fields = append(fields, carrierservice.FieldInternalID)
	}
	if m._return != nil {
		fields = append(fields, carrierservice.FieldReturn)
	}
	if m.consolidation != nil {
		fields = append(fields, carrierservice.FieldConsolidation)
	}
	if m.delivery_point_optional != nil {
		fields = append(fields, carrierservice.FieldDeliveryPointOptional)
	}
	if m.delivery_point_required != nil {
		fields = append(fields, carrierservice.FieldDeliveryPointRequired)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierServiceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierservice.FieldLabel:
		return m.Label()
	case carrierservice.FieldInternalID:
		return m.InternalID()
	case carrierservice.FieldReturn:
		return m.Return()
	case carrierservice.FieldConsolidation:
		return m.Consolidation()
	case carrierservice.FieldDeliveryPointOptional:
		return m.DeliveryPointOptional()
	case carrierservice.FieldDeliveryPointRequired:
		return m.DeliveryPointRequired()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierServiceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierservice.FieldLabel:
		return m.OldLabel(ctx)
	case carrierservice.FieldInternalID:
		return m.OldInternalID(ctx)
	case carrierservice.FieldReturn:
		return m.OldReturn(ctx)
	case carrierservice.FieldConsolidation:
		return m.OldConsolidation(ctx)
	case carrierservice.FieldDeliveryPointOptional:
		return m.OldDeliveryPointOptional(ctx)
	case carrierservice.FieldDeliveryPointRequired:
		return m.OldDeliveryPointRequired(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierService field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierservice.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrierservice.FieldInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalID(v)
		return nil
	case carrierservice.FieldReturn:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReturn(v)
		return nil
	case carrierservice.FieldConsolidation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsolidation(v)
		return nil
	case carrierservice.FieldDeliveryPointOptional:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryPointOptional(v)
		return nil
	case carrierservice.FieldDeliveryPointRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryPointRequired(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierService field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierServiceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierServiceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierService numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierServiceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierServiceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierServiceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierService nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierServiceMutation) ResetField(name string) error {
	switch name {
	case carrierservice.FieldLabel:
		m.ResetLabel()
		return nil
	case carrierservice.FieldInternalID:
		m.ResetInternalID()
		return nil
	case carrierservice.FieldReturn:
		m.ResetReturn()
		return nil
	case carrierservice.FieldConsolidation:
		m.ResetConsolidation()
		return nil
	case carrierservice.FieldDeliveryPointOptional:
		m.ResetDeliveryPointOptional()
		return nil
	case carrierservice.FieldDeliveryPointRequired:
		m.ResetDeliveryPointRequired()
		return nil
	}
	return fmt.Errorf("unknown CarrierService field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierServiceMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.carrier_service_post_nord != nil {
		edges = append(edges, carrierservice.EdgeCarrierServicePostNord)
	}
	if m.carrier_service_dao != nil {
		edges = append(edges, carrierservice.EdgeCarrierServiceDAO)
	}
	if m.carrier_service_df != nil {
		edges = append(edges, carrierservice.EdgeCarrierServiceDF)
	}
	if m.carrier_service_dsv != nil {
		edges = append(edges, carrierservice.EdgeCarrierServiceDSV)
	}
	if m.carrier_serv_easy_post != nil {
		edges = append(edges, carrierservice.EdgeCarrierServEasyPost)
	}
	if m.carrier_service_gls != nil {
		edges = append(edges, carrierservice.EdgeCarrierServiceGLS)
	}
	if m.carrier_service_usps != nil {
		edges = append(edges, carrierservice.EdgeCarrierServiceUSPS)
	}
	if m.carrier_service_bring != nil {
		edges = append(edges, carrierservice.EdgeCarrierServiceBring)
	}
	if m.carrier_brand != nil {
		edges = append(edges, carrierservice.EdgeCarrierBrand)
	}
	if m.delivery_option != nil {
		edges = append(edges, carrierservice.EdgeDeliveryOption)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierServiceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierservice.EdgeCarrierServicePostNord:
		if id := m.carrier_service_post_nord; id != nil {
			return []ent.Value{*id}
		}
	case carrierservice.EdgeCarrierServiceDAO:
		if id := m.carrier_service_dao; id != nil {
			return []ent.Value{*id}
		}
	case carrierservice.EdgeCarrierServiceDF:
		if id := m.carrier_service_df; id != nil {
			return []ent.Value{*id}
		}
	case carrierservice.EdgeCarrierServiceDSV:
		if id := m.carrier_service_dsv; id != nil {
			return []ent.Value{*id}
		}
	case carrierservice.EdgeCarrierServEasyPost:
		if id := m.carrier_serv_easy_post; id != nil {
			return []ent.Value{*id}
		}
	case carrierservice.EdgeCarrierServiceGLS:
		if id := m.carrier_service_gls; id != nil {
			return []ent.Value{*id}
		}
	case carrierservice.EdgeCarrierServiceUSPS:
		if id := m.carrier_service_usps; id != nil {
			return []ent.Value{*id}
		}
	case carrierservice.EdgeCarrierServiceBring:
		if id := m.carrier_service_bring; id != nil {
			return []ent.Value{*id}
		}
	case carrierservice.EdgeCarrierBrand:
		if id := m.carrier_brand; id != nil {
			return []ent.Value{*id}
		}
	case carrierservice.EdgeDeliveryOption:
		ids := make([]ent.Value, 0, len(m.delivery_option))
		for id := range m.delivery_option {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierServiceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removeddelivery_option != nil {
		edges = append(edges, carrierservice.EdgeDeliveryOption)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierServiceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrierservice.EdgeDeliveryOption:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option))
		for id := range m.removeddelivery_option {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierServiceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedcarrier_service_post_nord {
		edges = append(edges, carrierservice.EdgeCarrierServicePostNord)
	}
	if m.clearedcarrier_service_dao {
		edges = append(edges, carrierservice.EdgeCarrierServiceDAO)
	}
	if m.clearedcarrier_service_df {
		edges = append(edges, carrierservice.EdgeCarrierServiceDF)
	}
	if m.clearedcarrier_service_dsv {
		edges = append(edges, carrierservice.EdgeCarrierServiceDSV)
	}
	if m.clearedcarrier_serv_easy_post {
		edges = append(edges, carrierservice.EdgeCarrierServEasyPost)
	}
	if m.clearedcarrier_service_gls {
		edges = append(edges, carrierservice.EdgeCarrierServiceGLS)
	}
	if m.clearedcarrier_service_usps {
		edges = append(edges, carrierservice.EdgeCarrierServiceUSPS)
	}
	if m.clearedcarrier_service_bring {
		edges = append(edges, carrierservice.EdgeCarrierServiceBring)
	}
	if m.clearedcarrier_brand {
		edges = append(edges, carrierservice.EdgeCarrierBrand)
	}
	if m.cleareddelivery_option {
		edges = append(edges, carrierservice.EdgeDeliveryOption)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierServiceMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierservice.EdgeCarrierServicePostNord:
		return m.clearedcarrier_service_post_nord
	case carrierservice.EdgeCarrierServiceDAO:
		return m.clearedcarrier_service_dao
	case carrierservice.EdgeCarrierServiceDF:
		return m.clearedcarrier_service_df
	case carrierservice.EdgeCarrierServiceDSV:
		return m.clearedcarrier_service_dsv
	case carrierservice.EdgeCarrierServEasyPost:
		return m.clearedcarrier_serv_easy_post
	case carrierservice.EdgeCarrierServiceGLS:
		return m.clearedcarrier_service_gls
	case carrierservice.EdgeCarrierServiceUSPS:
		return m.clearedcarrier_service_usps
	case carrierservice.EdgeCarrierServiceBring:
		return m.clearedcarrier_service_bring
	case carrierservice.EdgeCarrierBrand:
		return m.clearedcarrier_brand
	case carrierservice.EdgeDeliveryOption:
		return m.cleareddelivery_option
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierServiceMutation) ClearEdge(name string) error {
	switch name {
	case carrierservice.EdgeCarrierServicePostNord:
		m.ClearCarrierServicePostNord()
		return nil
	case carrierservice.EdgeCarrierServiceDAO:
		m.ClearCarrierServiceDAO()
		return nil
	case carrierservice.EdgeCarrierServiceDF:
		m.ClearCarrierServiceDF()
		return nil
	case carrierservice.EdgeCarrierServiceDSV:
		m.ClearCarrierServiceDSV()
		return nil
	case carrierservice.EdgeCarrierServEasyPost:
		m.ClearCarrierServEasyPost()
		return nil
	case carrierservice.EdgeCarrierServiceGLS:
		m.ClearCarrierServiceGLS()
		return nil
	case carrierservice.EdgeCarrierServiceUSPS:
		m.ClearCarrierServiceUSPS()
		return nil
	case carrierservice.EdgeCarrierServiceBring:
		m.ClearCarrierServiceBring()
		return nil
	case carrierservice.EdgeCarrierBrand:
		m.ClearCarrierBrand()
		return nil
	}
	return fmt.Errorf("unknown CarrierService unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierServiceMutation) ResetEdge(name string) error {
	switch name {
	case carrierservice.EdgeCarrierServicePostNord:
		m.ResetCarrierServicePostNord()
		return nil
	case carrierservice.EdgeCarrierServiceDAO:
		m.ResetCarrierServiceDAO()
		return nil
	case carrierservice.EdgeCarrierServiceDF:
		m.ResetCarrierServiceDF()
		return nil
	case carrierservice.EdgeCarrierServiceDSV:
		m.ResetCarrierServiceDSV()
		return nil
	case carrierservice.EdgeCarrierServEasyPost:
		m.ResetCarrierServEasyPost()
		return nil
	case carrierservice.EdgeCarrierServiceGLS:
		m.ResetCarrierServiceGLS()
		return nil
	case carrierservice.EdgeCarrierServiceUSPS:
		m.ResetCarrierServiceUSPS()
		return nil
	case carrierservice.EdgeCarrierServiceBring:
		m.ResetCarrierServiceBring()
		return nil
	case carrierservice.EdgeCarrierBrand:
		m.ResetCarrierBrand()
		return nil
	case carrierservice.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	}
	return fmt.Errorf("unknown CarrierService edge %s", name)
}

// CarrierServiceBringMutation represents an operation that mutates the CarrierServiceBring nodes in the graph.
type CarrierServiceBringMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *pulid.ID
	api_service_code                        *string
	api_request                             *string
	clearedFields                           map[string]struct{}
	carrier_service                         *pulid.ID
	clearedcarrier_service                  bool
	carrier_additional_service_bring        map[pulid.ID]struct{}
	removedcarrier_additional_service_bring map[pulid.ID]struct{}
	clearedcarrier_additional_service_bring bool
	done                                    bool
	oldValue                                func(context.Context) (*CarrierServiceBring, error)
	predicates                              []predicate.CarrierServiceBring
}

var _ ent.Mutation = (*CarrierServiceBringMutation)(nil)

// carrierservicebringOption allows management of the mutation configuration using functional options.
type carrierservicebringOption func(*CarrierServiceBringMutation)

// newCarrierServiceBringMutation creates new mutation for the CarrierServiceBring entity.
func newCarrierServiceBringMutation(c config, op Op, opts ...carrierservicebringOption) *CarrierServiceBringMutation {
	m := &CarrierServiceBringMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierServiceBring,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierServiceBringID sets the ID field of the mutation.
func withCarrierServiceBringID(id pulid.ID) carrierservicebringOption {
	return func(m *CarrierServiceBringMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierServiceBring
		)
		m.oldValue = func(ctx context.Context) (*CarrierServiceBring, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierServiceBring.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierServiceBring sets the old CarrierServiceBring of the mutation.
func withCarrierServiceBring(node *CarrierServiceBring) carrierservicebringOption {
	return func(m *CarrierServiceBringMutation) {
		m.oldValue = func(context.Context) (*CarrierServiceBring, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierServiceBringMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierServiceBringMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierServiceBring entities.
func (m *CarrierServiceBringMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierServiceBringMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierServiceBringMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierServiceBring.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAPIServiceCode sets the "api_service_code" field.
func (m *CarrierServiceBringMutation) SetAPIServiceCode(s string) {
	m.api_service_code = &s
}

// APIServiceCode returns the value of the "api_service_code" field in the mutation.
func (m *CarrierServiceBringMutation) APIServiceCode() (r string, exists bool) {
	v := m.api_service_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIServiceCode returns the old "api_service_code" field's value of the CarrierServiceBring entity.
// If the CarrierServiceBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceBringMutation) OldAPIServiceCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIServiceCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIServiceCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIServiceCode: %w", err)
	}
	return oldValue.APIServiceCode, nil
}

// ResetAPIServiceCode resets all changes to the "api_service_code" field.
func (m *CarrierServiceBringMutation) ResetAPIServiceCode() {
	m.api_service_code = nil
}

// SetAPIRequest sets the "api_request" field.
func (m *CarrierServiceBringMutation) SetAPIRequest(s string) {
	m.api_request = &s
}

// APIRequest returns the value of the "api_request" field in the mutation.
func (m *CarrierServiceBringMutation) APIRequest() (r string, exists bool) {
	v := m.api_request
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIRequest returns the old "api_request" field's value of the CarrierServiceBring entity.
// If the CarrierServiceBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceBringMutation) OldAPIRequest(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIRequest is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIRequest requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIRequest: %w", err)
	}
	return oldValue.APIRequest, nil
}

// ResetAPIRequest resets all changes to the "api_request" field.
func (m *CarrierServiceBringMutation) ResetAPIRequest() {
	m.api_request = nil
}

// SetCarrierServiceID sets the "carrier_service" edge to the CarrierService entity by id.
func (m *CarrierServiceBringMutation) SetCarrierServiceID(id pulid.ID) {
	m.carrier_service = &id
}

// ClearCarrierService clears the "carrier_service" edge to the CarrierService entity.
func (m *CarrierServiceBringMutation) ClearCarrierService() {
	m.clearedcarrier_service = true
}

// CarrierServiceCleared reports if the "carrier_service" edge to the CarrierService entity was cleared.
func (m *CarrierServiceBringMutation) CarrierServiceCleared() bool {
	return m.clearedcarrier_service
}

// CarrierServiceID returns the "carrier_service" edge ID in the mutation.
func (m *CarrierServiceBringMutation) CarrierServiceID() (id pulid.ID, exists bool) {
	if m.carrier_service != nil {
		return *m.carrier_service, true
	}
	return
}

// CarrierServiceIDs returns the "carrier_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceBringMutation) CarrierServiceIDs() (ids []pulid.ID) {
	if id := m.carrier_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierService resets all changes to the "carrier_service" edge.
func (m *CarrierServiceBringMutation) ResetCarrierService() {
	m.carrier_service = nil
	m.clearedcarrier_service = false
}

// AddCarrierAdditionalServiceBringIDs adds the "carrier_additional_service_bring" edge to the CarrierAdditionalServiceBring entity by ids.
func (m *CarrierServiceBringMutation) AddCarrierAdditionalServiceBringIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_bring == nil {
		m.carrier_additional_service_bring = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_bring[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceBring clears the "carrier_additional_service_bring" edge to the CarrierAdditionalServiceBring entity.
func (m *CarrierServiceBringMutation) ClearCarrierAdditionalServiceBring() {
	m.clearedcarrier_additional_service_bring = true
}

// CarrierAdditionalServiceBringCleared reports if the "carrier_additional_service_bring" edge to the CarrierAdditionalServiceBring entity was cleared.
func (m *CarrierServiceBringMutation) CarrierAdditionalServiceBringCleared() bool {
	return m.clearedcarrier_additional_service_bring
}

// RemoveCarrierAdditionalServiceBringIDs removes the "carrier_additional_service_bring" edge to the CarrierAdditionalServiceBring entity by IDs.
func (m *CarrierServiceBringMutation) RemoveCarrierAdditionalServiceBringIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_bring == nil {
		m.removedcarrier_additional_service_bring = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_bring, ids[i])
		m.removedcarrier_additional_service_bring[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceBring returns the removed IDs of the "carrier_additional_service_bring" edge to the CarrierAdditionalServiceBring entity.
func (m *CarrierServiceBringMutation) RemovedCarrierAdditionalServiceBringIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_bring {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceBringIDs returns the "carrier_additional_service_bring" edge IDs in the mutation.
func (m *CarrierServiceBringMutation) CarrierAdditionalServiceBringIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_bring {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceBring resets all changes to the "carrier_additional_service_bring" edge.
func (m *CarrierServiceBringMutation) ResetCarrierAdditionalServiceBring() {
	m.carrier_additional_service_bring = nil
	m.clearedcarrier_additional_service_bring = false
	m.removedcarrier_additional_service_bring = nil
}

// Where appends a list predicates to the CarrierServiceBringMutation builder.
func (m *CarrierServiceBringMutation) Where(ps ...predicate.CarrierServiceBring) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierServiceBringMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierServiceBringMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierServiceBring, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierServiceBringMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierServiceBringMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierServiceBring).
func (m *CarrierServiceBringMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierServiceBringMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.api_service_code != nil {
		fields = append(fields, carrierservicebring.FieldAPIServiceCode)
	}
	if m.api_request != nil {
		fields = append(fields, carrierservicebring.FieldAPIRequest)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierServiceBringMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierservicebring.FieldAPIServiceCode:
		return m.APIServiceCode()
	case carrierservicebring.FieldAPIRequest:
		return m.APIRequest()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierServiceBringMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierservicebring.FieldAPIServiceCode:
		return m.OldAPIServiceCode(ctx)
	case carrierservicebring.FieldAPIRequest:
		return m.OldAPIRequest(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierServiceBring field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceBringMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierservicebring.FieldAPIServiceCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIServiceCode(v)
		return nil
	case carrierservicebring.FieldAPIRequest:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIRequest(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceBring field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierServiceBringMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierServiceBringMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceBringMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierServiceBring numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierServiceBringMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierServiceBringMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierServiceBringMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierServiceBring nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierServiceBringMutation) ResetField(name string) error {
	switch name {
	case carrierservicebring.FieldAPIServiceCode:
		m.ResetAPIServiceCode()
		return nil
	case carrierservicebring.FieldAPIRequest:
		m.ResetAPIRequest()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceBring field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierServiceBringMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service != nil {
		edges = append(edges, carrierservicebring.EdgeCarrierService)
	}
	if m.carrier_additional_service_bring != nil {
		edges = append(edges, carrierservicebring.EdgeCarrierAdditionalServiceBring)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierServiceBringMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierservicebring.EdgeCarrierService:
		if id := m.carrier_service; id != nil {
			return []ent.Value{*id}
		}
	case carrierservicebring.EdgeCarrierAdditionalServiceBring:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_bring))
		for id := range m.carrier_additional_service_bring {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierServiceBringMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_additional_service_bring != nil {
		edges = append(edges, carrierservicebring.EdgeCarrierAdditionalServiceBring)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierServiceBringMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrierservicebring.EdgeCarrierAdditionalServiceBring:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_bring))
		for id := range m.removedcarrier_additional_service_bring {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierServiceBringMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service {
		edges = append(edges, carrierservicebring.EdgeCarrierService)
	}
	if m.clearedcarrier_additional_service_bring {
		edges = append(edges, carrierservicebring.EdgeCarrierAdditionalServiceBring)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierServiceBringMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierservicebring.EdgeCarrierService:
		return m.clearedcarrier_service
	case carrierservicebring.EdgeCarrierAdditionalServiceBring:
		return m.clearedcarrier_additional_service_bring
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierServiceBringMutation) ClearEdge(name string) error {
	switch name {
	case carrierservicebring.EdgeCarrierService:
		m.ClearCarrierService()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceBring unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierServiceBringMutation) ResetEdge(name string) error {
	switch name {
	case carrierservicebring.EdgeCarrierService:
		m.ResetCarrierService()
		return nil
	case carrierservicebring.EdgeCarrierAdditionalServiceBring:
		m.ResetCarrierAdditionalServiceBring()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceBring edge %s", name)
}

// CarrierServiceDAOMutation represents an operation that mutates the CarrierServiceDAO nodes in the graph.
type CarrierServiceDAOMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *pulid.ID
	clearedFields                         map[string]struct{}
	carrier_service                       *pulid.ID
	clearedcarrier_service                bool
	carrier_additional_service_dao        map[pulid.ID]struct{}
	removedcarrier_additional_service_dao map[pulid.ID]struct{}
	clearedcarrier_additional_service_dao bool
	done                                  bool
	oldValue                              func(context.Context) (*CarrierServiceDAO, error)
	predicates                            []predicate.CarrierServiceDAO
}

var _ ent.Mutation = (*CarrierServiceDAOMutation)(nil)

// carrierservicedaoOption allows management of the mutation configuration using functional options.
type carrierservicedaoOption func(*CarrierServiceDAOMutation)

// newCarrierServiceDAOMutation creates new mutation for the CarrierServiceDAO entity.
func newCarrierServiceDAOMutation(c config, op Op, opts ...carrierservicedaoOption) *CarrierServiceDAOMutation {
	m := &CarrierServiceDAOMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierServiceDAO,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierServiceDAOID sets the ID field of the mutation.
func withCarrierServiceDAOID(id pulid.ID) carrierservicedaoOption {
	return func(m *CarrierServiceDAOMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierServiceDAO
		)
		m.oldValue = func(ctx context.Context) (*CarrierServiceDAO, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierServiceDAO.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierServiceDAO sets the old CarrierServiceDAO of the mutation.
func withCarrierServiceDAO(node *CarrierServiceDAO) carrierservicedaoOption {
	return func(m *CarrierServiceDAOMutation) {
		m.oldValue = func(context.Context) (*CarrierServiceDAO, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierServiceDAOMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierServiceDAOMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierServiceDAO entities.
func (m *CarrierServiceDAOMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierServiceDAOMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierServiceDAOMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierServiceDAO.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCarrierServiceID sets the "carrier_service" edge to the CarrierService entity by id.
func (m *CarrierServiceDAOMutation) SetCarrierServiceID(id pulid.ID) {
	m.carrier_service = &id
}

// ClearCarrierService clears the "carrier_service" edge to the CarrierService entity.
func (m *CarrierServiceDAOMutation) ClearCarrierService() {
	m.clearedcarrier_service = true
}

// CarrierServiceCleared reports if the "carrier_service" edge to the CarrierService entity was cleared.
func (m *CarrierServiceDAOMutation) CarrierServiceCleared() bool {
	return m.clearedcarrier_service
}

// CarrierServiceID returns the "carrier_service" edge ID in the mutation.
func (m *CarrierServiceDAOMutation) CarrierServiceID() (id pulid.ID, exists bool) {
	if m.carrier_service != nil {
		return *m.carrier_service, true
	}
	return
}

// CarrierServiceIDs returns the "carrier_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceDAOMutation) CarrierServiceIDs() (ids []pulid.ID) {
	if id := m.carrier_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierService resets all changes to the "carrier_service" edge.
func (m *CarrierServiceDAOMutation) ResetCarrierService() {
	m.carrier_service = nil
	m.clearedcarrier_service = false
}

// AddCarrierAdditionalServiceDAOIDs adds the "carrier_additional_service_dao" edge to the CarrierAdditionalServiceDAO entity by ids.
func (m *CarrierServiceDAOMutation) AddCarrierAdditionalServiceDAOIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_dao == nil {
		m.carrier_additional_service_dao = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_dao[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceDAO clears the "carrier_additional_service_dao" edge to the CarrierAdditionalServiceDAO entity.
func (m *CarrierServiceDAOMutation) ClearCarrierAdditionalServiceDAO() {
	m.clearedcarrier_additional_service_dao = true
}

// CarrierAdditionalServiceDAOCleared reports if the "carrier_additional_service_dao" edge to the CarrierAdditionalServiceDAO entity was cleared.
func (m *CarrierServiceDAOMutation) CarrierAdditionalServiceDAOCleared() bool {
	return m.clearedcarrier_additional_service_dao
}

// RemoveCarrierAdditionalServiceDAOIDs removes the "carrier_additional_service_dao" edge to the CarrierAdditionalServiceDAO entity by IDs.
func (m *CarrierServiceDAOMutation) RemoveCarrierAdditionalServiceDAOIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_dao == nil {
		m.removedcarrier_additional_service_dao = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_dao, ids[i])
		m.removedcarrier_additional_service_dao[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceDAO returns the removed IDs of the "carrier_additional_service_dao" edge to the CarrierAdditionalServiceDAO entity.
func (m *CarrierServiceDAOMutation) RemovedCarrierAdditionalServiceDAOIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_dao {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceDAOIDs returns the "carrier_additional_service_dao" edge IDs in the mutation.
func (m *CarrierServiceDAOMutation) CarrierAdditionalServiceDAOIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_dao {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceDAO resets all changes to the "carrier_additional_service_dao" edge.
func (m *CarrierServiceDAOMutation) ResetCarrierAdditionalServiceDAO() {
	m.carrier_additional_service_dao = nil
	m.clearedcarrier_additional_service_dao = false
	m.removedcarrier_additional_service_dao = nil
}

// Where appends a list predicates to the CarrierServiceDAOMutation builder.
func (m *CarrierServiceDAOMutation) Where(ps ...predicate.CarrierServiceDAO) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierServiceDAOMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierServiceDAOMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierServiceDAO, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierServiceDAOMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierServiceDAOMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierServiceDAO).
func (m *CarrierServiceDAOMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierServiceDAOMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierServiceDAOMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierServiceDAOMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown CarrierServiceDAO field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceDAOMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierServiceDAO field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierServiceDAOMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierServiceDAOMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceDAOMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown CarrierServiceDAO numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierServiceDAOMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierServiceDAOMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierServiceDAOMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierServiceDAO nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierServiceDAOMutation) ResetField(name string) error {
	return fmt.Errorf("unknown CarrierServiceDAO field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierServiceDAOMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service != nil {
		edges = append(edges, carrierservicedao.EdgeCarrierService)
	}
	if m.carrier_additional_service_dao != nil {
		edges = append(edges, carrierservicedao.EdgeCarrierAdditionalServiceDAO)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierServiceDAOMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierservicedao.EdgeCarrierService:
		if id := m.carrier_service; id != nil {
			return []ent.Value{*id}
		}
	case carrierservicedao.EdgeCarrierAdditionalServiceDAO:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_dao))
		for id := range m.carrier_additional_service_dao {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierServiceDAOMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_additional_service_dao != nil {
		edges = append(edges, carrierservicedao.EdgeCarrierAdditionalServiceDAO)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierServiceDAOMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrierservicedao.EdgeCarrierAdditionalServiceDAO:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_dao))
		for id := range m.removedcarrier_additional_service_dao {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierServiceDAOMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service {
		edges = append(edges, carrierservicedao.EdgeCarrierService)
	}
	if m.clearedcarrier_additional_service_dao {
		edges = append(edges, carrierservicedao.EdgeCarrierAdditionalServiceDAO)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierServiceDAOMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierservicedao.EdgeCarrierService:
		return m.clearedcarrier_service
	case carrierservicedao.EdgeCarrierAdditionalServiceDAO:
		return m.clearedcarrier_additional_service_dao
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierServiceDAOMutation) ClearEdge(name string) error {
	switch name {
	case carrierservicedao.EdgeCarrierService:
		m.ClearCarrierService()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceDAO unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierServiceDAOMutation) ResetEdge(name string) error {
	switch name {
	case carrierservicedao.EdgeCarrierService:
		m.ResetCarrierService()
		return nil
	case carrierservicedao.EdgeCarrierAdditionalServiceDAO:
		m.ResetCarrierAdditionalServiceDAO()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceDAO edge %s", name)
}

// CarrierServiceDFMutation represents an operation that mutates the CarrierServiceDF nodes in the graph.
type CarrierServiceDFMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *pulid.ID
	clearedFields                        map[string]struct{}
	carrier_service                      *pulid.ID
	clearedcarrier_service               bool
	carrier_additional_service_df        map[pulid.ID]struct{}
	removedcarrier_additional_service_df map[pulid.ID]struct{}
	clearedcarrier_additional_service_df bool
	done                                 bool
	oldValue                             func(context.Context) (*CarrierServiceDF, error)
	predicates                           []predicate.CarrierServiceDF
}

var _ ent.Mutation = (*CarrierServiceDFMutation)(nil)

// carrierservicedfOption allows management of the mutation configuration using functional options.
type carrierservicedfOption func(*CarrierServiceDFMutation)

// newCarrierServiceDFMutation creates new mutation for the CarrierServiceDF entity.
func newCarrierServiceDFMutation(c config, op Op, opts ...carrierservicedfOption) *CarrierServiceDFMutation {
	m := &CarrierServiceDFMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierServiceDF,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierServiceDFID sets the ID field of the mutation.
func withCarrierServiceDFID(id pulid.ID) carrierservicedfOption {
	return func(m *CarrierServiceDFMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierServiceDF
		)
		m.oldValue = func(ctx context.Context) (*CarrierServiceDF, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierServiceDF.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierServiceDF sets the old CarrierServiceDF of the mutation.
func withCarrierServiceDF(node *CarrierServiceDF) carrierservicedfOption {
	return func(m *CarrierServiceDFMutation) {
		m.oldValue = func(context.Context) (*CarrierServiceDF, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierServiceDFMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierServiceDFMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierServiceDF entities.
func (m *CarrierServiceDFMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierServiceDFMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierServiceDFMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierServiceDF.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCarrierServiceID sets the "carrier_service" edge to the CarrierService entity by id.
func (m *CarrierServiceDFMutation) SetCarrierServiceID(id pulid.ID) {
	m.carrier_service = &id
}

// ClearCarrierService clears the "carrier_service" edge to the CarrierService entity.
func (m *CarrierServiceDFMutation) ClearCarrierService() {
	m.clearedcarrier_service = true
}

// CarrierServiceCleared reports if the "carrier_service" edge to the CarrierService entity was cleared.
func (m *CarrierServiceDFMutation) CarrierServiceCleared() bool {
	return m.clearedcarrier_service
}

// CarrierServiceID returns the "carrier_service" edge ID in the mutation.
func (m *CarrierServiceDFMutation) CarrierServiceID() (id pulid.ID, exists bool) {
	if m.carrier_service != nil {
		return *m.carrier_service, true
	}
	return
}

// CarrierServiceIDs returns the "carrier_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceDFMutation) CarrierServiceIDs() (ids []pulid.ID) {
	if id := m.carrier_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierService resets all changes to the "carrier_service" edge.
func (m *CarrierServiceDFMutation) ResetCarrierService() {
	m.carrier_service = nil
	m.clearedcarrier_service = false
}

// AddCarrierAdditionalServiceDFIDs adds the "carrier_additional_service_df" edge to the CarrierAdditionalServiceDF entity by ids.
func (m *CarrierServiceDFMutation) AddCarrierAdditionalServiceDFIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_df == nil {
		m.carrier_additional_service_df = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_df[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceDF clears the "carrier_additional_service_df" edge to the CarrierAdditionalServiceDF entity.
func (m *CarrierServiceDFMutation) ClearCarrierAdditionalServiceDF() {
	m.clearedcarrier_additional_service_df = true
}

// CarrierAdditionalServiceDFCleared reports if the "carrier_additional_service_df" edge to the CarrierAdditionalServiceDF entity was cleared.
func (m *CarrierServiceDFMutation) CarrierAdditionalServiceDFCleared() bool {
	return m.clearedcarrier_additional_service_df
}

// RemoveCarrierAdditionalServiceDFIDs removes the "carrier_additional_service_df" edge to the CarrierAdditionalServiceDF entity by IDs.
func (m *CarrierServiceDFMutation) RemoveCarrierAdditionalServiceDFIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_df == nil {
		m.removedcarrier_additional_service_df = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_df, ids[i])
		m.removedcarrier_additional_service_df[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceDF returns the removed IDs of the "carrier_additional_service_df" edge to the CarrierAdditionalServiceDF entity.
func (m *CarrierServiceDFMutation) RemovedCarrierAdditionalServiceDFIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_df {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceDFIDs returns the "carrier_additional_service_df" edge IDs in the mutation.
func (m *CarrierServiceDFMutation) CarrierAdditionalServiceDFIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_df {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceDF resets all changes to the "carrier_additional_service_df" edge.
func (m *CarrierServiceDFMutation) ResetCarrierAdditionalServiceDF() {
	m.carrier_additional_service_df = nil
	m.clearedcarrier_additional_service_df = false
	m.removedcarrier_additional_service_df = nil
}

// Where appends a list predicates to the CarrierServiceDFMutation builder.
func (m *CarrierServiceDFMutation) Where(ps ...predicate.CarrierServiceDF) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierServiceDFMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierServiceDFMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierServiceDF, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierServiceDFMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierServiceDFMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierServiceDF).
func (m *CarrierServiceDFMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierServiceDFMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierServiceDFMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierServiceDFMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown CarrierServiceDF field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceDFMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierServiceDF field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierServiceDFMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierServiceDFMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceDFMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown CarrierServiceDF numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierServiceDFMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierServiceDFMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierServiceDFMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierServiceDF nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierServiceDFMutation) ResetField(name string) error {
	return fmt.Errorf("unknown CarrierServiceDF field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierServiceDFMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service != nil {
		edges = append(edges, carrierservicedf.EdgeCarrierService)
	}
	if m.carrier_additional_service_df != nil {
		edges = append(edges, carrierservicedf.EdgeCarrierAdditionalServiceDF)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierServiceDFMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierservicedf.EdgeCarrierService:
		if id := m.carrier_service; id != nil {
			return []ent.Value{*id}
		}
	case carrierservicedf.EdgeCarrierAdditionalServiceDF:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_df))
		for id := range m.carrier_additional_service_df {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierServiceDFMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_additional_service_df != nil {
		edges = append(edges, carrierservicedf.EdgeCarrierAdditionalServiceDF)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierServiceDFMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrierservicedf.EdgeCarrierAdditionalServiceDF:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_df))
		for id := range m.removedcarrier_additional_service_df {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierServiceDFMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service {
		edges = append(edges, carrierservicedf.EdgeCarrierService)
	}
	if m.clearedcarrier_additional_service_df {
		edges = append(edges, carrierservicedf.EdgeCarrierAdditionalServiceDF)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierServiceDFMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierservicedf.EdgeCarrierService:
		return m.clearedcarrier_service
	case carrierservicedf.EdgeCarrierAdditionalServiceDF:
		return m.clearedcarrier_additional_service_df
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierServiceDFMutation) ClearEdge(name string) error {
	switch name {
	case carrierservicedf.EdgeCarrierService:
		m.ClearCarrierService()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceDF unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierServiceDFMutation) ResetEdge(name string) error {
	switch name {
	case carrierservicedf.EdgeCarrierService:
		m.ResetCarrierService()
		return nil
	case carrierservicedf.EdgeCarrierAdditionalServiceDF:
		m.ResetCarrierAdditionalServiceDF()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceDF edge %s", name)
}

// CarrierServiceDSVMutation represents an operation that mutates the CarrierServiceDSV nodes in the graph.
type CarrierServiceDSVMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *pulid.ID
	clearedFields                         map[string]struct{}
	carrier_service                       *pulid.ID
	clearedcarrier_service                bool
	carrier_additional_service_dsv        map[pulid.ID]struct{}
	removedcarrier_additional_service_dsv map[pulid.ID]struct{}
	clearedcarrier_additional_service_dsv bool
	done                                  bool
	oldValue                              func(context.Context) (*CarrierServiceDSV, error)
	predicates                            []predicate.CarrierServiceDSV
}

var _ ent.Mutation = (*CarrierServiceDSVMutation)(nil)

// carrierservicedsvOption allows management of the mutation configuration using functional options.
type carrierservicedsvOption func(*CarrierServiceDSVMutation)

// newCarrierServiceDSVMutation creates new mutation for the CarrierServiceDSV entity.
func newCarrierServiceDSVMutation(c config, op Op, opts ...carrierservicedsvOption) *CarrierServiceDSVMutation {
	m := &CarrierServiceDSVMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierServiceDSV,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierServiceDSVID sets the ID field of the mutation.
func withCarrierServiceDSVID(id pulid.ID) carrierservicedsvOption {
	return func(m *CarrierServiceDSVMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierServiceDSV
		)
		m.oldValue = func(ctx context.Context) (*CarrierServiceDSV, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierServiceDSV.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierServiceDSV sets the old CarrierServiceDSV of the mutation.
func withCarrierServiceDSV(node *CarrierServiceDSV) carrierservicedsvOption {
	return func(m *CarrierServiceDSVMutation) {
		m.oldValue = func(context.Context) (*CarrierServiceDSV, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierServiceDSVMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierServiceDSVMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierServiceDSV entities.
func (m *CarrierServiceDSVMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierServiceDSVMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierServiceDSVMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierServiceDSV.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCarrierServiceID sets the "carrier_service" edge to the CarrierService entity by id.
func (m *CarrierServiceDSVMutation) SetCarrierServiceID(id pulid.ID) {
	m.carrier_service = &id
}

// ClearCarrierService clears the "carrier_service" edge to the CarrierService entity.
func (m *CarrierServiceDSVMutation) ClearCarrierService() {
	m.clearedcarrier_service = true
}

// CarrierServiceCleared reports if the "carrier_service" edge to the CarrierService entity was cleared.
func (m *CarrierServiceDSVMutation) CarrierServiceCleared() bool {
	return m.clearedcarrier_service
}

// CarrierServiceID returns the "carrier_service" edge ID in the mutation.
func (m *CarrierServiceDSVMutation) CarrierServiceID() (id pulid.ID, exists bool) {
	if m.carrier_service != nil {
		return *m.carrier_service, true
	}
	return
}

// CarrierServiceIDs returns the "carrier_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceDSVMutation) CarrierServiceIDs() (ids []pulid.ID) {
	if id := m.carrier_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierService resets all changes to the "carrier_service" edge.
func (m *CarrierServiceDSVMutation) ResetCarrierService() {
	m.carrier_service = nil
	m.clearedcarrier_service = false
}

// AddCarrierAdditionalServiceDSVIDs adds the "carrier_additional_service_dsv" edge to the CarrierAdditionalServiceDSV entity by ids.
func (m *CarrierServiceDSVMutation) AddCarrierAdditionalServiceDSVIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_dsv == nil {
		m.carrier_additional_service_dsv = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_dsv[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceDSV clears the "carrier_additional_service_dsv" edge to the CarrierAdditionalServiceDSV entity.
func (m *CarrierServiceDSVMutation) ClearCarrierAdditionalServiceDSV() {
	m.clearedcarrier_additional_service_dsv = true
}

// CarrierAdditionalServiceDSVCleared reports if the "carrier_additional_service_dsv" edge to the CarrierAdditionalServiceDSV entity was cleared.
func (m *CarrierServiceDSVMutation) CarrierAdditionalServiceDSVCleared() bool {
	return m.clearedcarrier_additional_service_dsv
}

// RemoveCarrierAdditionalServiceDSVIDs removes the "carrier_additional_service_dsv" edge to the CarrierAdditionalServiceDSV entity by IDs.
func (m *CarrierServiceDSVMutation) RemoveCarrierAdditionalServiceDSVIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_dsv == nil {
		m.removedcarrier_additional_service_dsv = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_dsv, ids[i])
		m.removedcarrier_additional_service_dsv[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceDSV returns the removed IDs of the "carrier_additional_service_dsv" edge to the CarrierAdditionalServiceDSV entity.
func (m *CarrierServiceDSVMutation) RemovedCarrierAdditionalServiceDSVIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_dsv {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceDSVIDs returns the "carrier_additional_service_dsv" edge IDs in the mutation.
func (m *CarrierServiceDSVMutation) CarrierAdditionalServiceDSVIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_dsv {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceDSV resets all changes to the "carrier_additional_service_dsv" edge.
func (m *CarrierServiceDSVMutation) ResetCarrierAdditionalServiceDSV() {
	m.carrier_additional_service_dsv = nil
	m.clearedcarrier_additional_service_dsv = false
	m.removedcarrier_additional_service_dsv = nil
}

// Where appends a list predicates to the CarrierServiceDSVMutation builder.
func (m *CarrierServiceDSVMutation) Where(ps ...predicate.CarrierServiceDSV) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierServiceDSVMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierServiceDSVMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierServiceDSV, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierServiceDSVMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierServiceDSVMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierServiceDSV).
func (m *CarrierServiceDSVMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierServiceDSVMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierServiceDSVMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierServiceDSVMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown CarrierServiceDSV field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceDSVMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierServiceDSV field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierServiceDSVMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierServiceDSVMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceDSVMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown CarrierServiceDSV numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierServiceDSVMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierServiceDSVMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierServiceDSVMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierServiceDSV nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierServiceDSVMutation) ResetField(name string) error {
	return fmt.Errorf("unknown CarrierServiceDSV field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierServiceDSVMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service != nil {
		edges = append(edges, carrierservicedsv.EdgeCarrierService)
	}
	if m.carrier_additional_service_dsv != nil {
		edges = append(edges, carrierservicedsv.EdgeCarrierAdditionalServiceDSV)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierServiceDSVMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierservicedsv.EdgeCarrierService:
		if id := m.carrier_service; id != nil {
			return []ent.Value{*id}
		}
	case carrierservicedsv.EdgeCarrierAdditionalServiceDSV:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_dsv))
		for id := range m.carrier_additional_service_dsv {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierServiceDSVMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_additional_service_dsv != nil {
		edges = append(edges, carrierservicedsv.EdgeCarrierAdditionalServiceDSV)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierServiceDSVMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrierservicedsv.EdgeCarrierAdditionalServiceDSV:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_dsv))
		for id := range m.removedcarrier_additional_service_dsv {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierServiceDSVMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service {
		edges = append(edges, carrierservicedsv.EdgeCarrierService)
	}
	if m.clearedcarrier_additional_service_dsv {
		edges = append(edges, carrierservicedsv.EdgeCarrierAdditionalServiceDSV)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierServiceDSVMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierservicedsv.EdgeCarrierService:
		return m.clearedcarrier_service
	case carrierservicedsv.EdgeCarrierAdditionalServiceDSV:
		return m.clearedcarrier_additional_service_dsv
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierServiceDSVMutation) ClearEdge(name string) error {
	switch name {
	case carrierservicedsv.EdgeCarrierService:
		m.ClearCarrierService()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceDSV unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierServiceDSVMutation) ResetEdge(name string) error {
	switch name {
	case carrierservicedsv.EdgeCarrierService:
		m.ResetCarrierService()
		return nil
	case carrierservicedsv.EdgeCarrierAdditionalServiceDSV:
		m.ResetCarrierAdditionalServiceDSV()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceDSV edge %s", name)
}

// CarrierServiceEasyPostMutation represents an operation that mutates the CarrierServiceEasyPost nodes in the graph.
type CarrierServiceEasyPostMutation struct {
	config
	op                                Op
	typ                               string
	id                                *pulid.ID
	api_key                           *carrierserviceeasypost.APIKey
	clearedFields                     map[string]struct{}
	carrier_service                   *pulid.ID
	clearedcarrier_service            bool
	carrier_add_serv_easy_post        map[pulid.ID]struct{}
	removedcarrier_add_serv_easy_post map[pulid.ID]struct{}
	clearedcarrier_add_serv_easy_post bool
	done                              bool
	oldValue                          func(context.Context) (*CarrierServiceEasyPost, error)
	predicates                        []predicate.CarrierServiceEasyPost
}

var _ ent.Mutation = (*CarrierServiceEasyPostMutation)(nil)

// carrierserviceeasypostOption allows management of the mutation configuration using functional options.
type carrierserviceeasypostOption func(*CarrierServiceEasyPostMutation)

// newCarrierServiceEasyPostMutation creates new mutation for the CarrierServiceEasyPost entity.
func newCarrierServiceEasyPostMutation(c config, op Op, opts ...carrierserviceeasypostOption) *CarrierServiceEasyPostMutation {
	m := &CarrierServiceEasyPostMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierServiceEasyPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierServiceEasyPostID sets the ID field of the mutation.
func withCarrierServiceEasyPostID(id pulid.ID) carrierserviceeasypostOption {
	return func(m *CarrierServiceEasyPostMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierServiceEasyPost
		)
		m.oldValue = func(ctx context.Context) (*CarrierServiceEasyPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierServiceEasyPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierServiceEasyPost sets the old CarrierServiceEasyPost of the mutation.
func withCarrierServiceEasyPost(node *CarrierServiceEasyPost) carrierserviceeasypostOption {
	return func(m *CarrierServiceEasyPostMutation) {
		m.oldValue = func(context.Context) (*CarrierServiceEasyPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierServiceEasyPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierServiceEasyPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierServiceEasyPost entities.
func (m *CarrierServiceEasyPostMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierServiceEasyPostMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierServiceEasyPostMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierServiceEasyPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAPIKey sets the "api_key" field.
func (m *CarrierServiceEasyPostMutation) SetAPIKey(ck carrierserviceeasypost.APIKey) {
	m.api_key = &ck
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *CarrierServiceEasyPostMutation) APIKey() (r carrierserviceeasypost.APIKey, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the CarrierServiceEasyPost entity.
// If the CarrierServiceEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceEasyPostMutation) OldAPIKey(ctx context.Context) (v carrierserviceeasypost.APIKey, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *CarrierServiceEasyPostMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetCarrierServiceID sets the "carrier_service" edge to the CarrierService entity by id.
func (m *CarrierServiceEasyPostMutation) SetCarrierServiceID(id pulid.ID) {
	m.carrier_service = &id
}

// ClearCarrierService clears the "carrier_service" edge to the CarrierService entity.
func (m *CarrierServiceEasyPostMutation) ClearCarrierService() {
	m.clearedcarrier_service = true
}

// CarrierServiceCleared reports if the "carrier_service" edge to the CarrierService entity was cleared.
func (m *CarrierServiceEasyPostMutation) CarrierServiceCleared() bool {
	return m.clearedcarrier_service
}

// CarrierServiceID returns the "carrier_service" edge ID in the mutation.
func (m *CarrierServiceEasyPostMutation) CarrierServiceID() (id pulid.ID, exists bool) {
	if m.carrier_service != nil {
		return *m.carrier_service, true
	}
	return
}

// CarrierServiceIDs returns the "carrier_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceEasyPostMutation) CarrierServiceIDs() (ids []pulid.ID) {
	if id := m.carrier_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierService resets all changes to the "carrier_service" edge.
func (m *CarrierServiceEasyPostMutation) ResetCarrierService() {
	m.carrier_service = nil
	m.clearedcarrier_service = false
}

// AddCarrierAddServEasyPostIDs adds the "carrier_add_serv_easy_post" edge to the CarrierAdditionalServiceEasyPost entity by ids.
func (m *CarrierServiceEasyPostMutation) AddCarrierAddServEasyPostIDs(ids ...pulid.ID) {
	if m.carrier_add_serv_easy_post == nil {
		m.carrier_add_serv_easy_post = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_add_serv_easy_post[ids[i]] = struct{}{}
	}
}

// ClearCarrierAddServEasyPost clears the "carrier_add_serv_easy_post" edge to the CarrierAdditionalServiceEasyPost entity.
func (m *CarrierServiceEasyPostMutation) ClearCarrierAddServEasyPost() {
	m.clearedcarrier_add_serv_easy_post = true
}

// CarrierAddServEasyPostCleared reports if the "carrier_add_serv_easy_post" edge to the CarrierAdditionalServiceEasyPost entity was cleared.
func (m *CarrierServiceEasyPostMutation) CarrierAddServEasyPostCleared() bool {
	return m.clearedcarrier_add_serv_easy_post
}

// RemoveCarrierAddServEasyPostIDs removes the "carrier_add_serv_easy_post" edge to the CarrierAdditionalServiceEasyPost entity by IDs.
func (m *CarrierServiceEasyPostMutation) RemoveCarrierAddServEasyPostIDs(ids ...pulid.ID) {
	if m.removedcarrier_add_serv_easy_post == nil {
		m.removedcarrier_add_serv_easy_post = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_add_serv_easy_post, ids[i])
		m.removedcarrier_add_serv_easy_post[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAddServEasyPost returns the removed IDs of the "carrier_add_serv_easy_post" edge to the CarrierAdditionalServiceEasyPost entity.
func (m *CarrierServiceEasyPostMutation) RemovedCarrierAddServEasyPostIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_add_serv_easy_post {
		ids = append(ids, id)
	}
	return
}

// CarrierAddServEasyPostIDs returns the "carrier_add_serv_easy_post" edge IDs in the mutation.
func (m *CarrierServiceEasyPostMutation) CarrierAddServEasyPostIDs() (ids []pulid.ID) {
	for id := range m.carrier_add_serv_easy_post {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAddServEasyPost resets all changes to the "carrier_add_serv_easy_post" edge.
func (m *CarrierServiceEasyPostMutation) ResetCarrierAddServEasyPost() {
	m.carrier_add_serv_easy_post = nil
	m.clearedcarrier_add_serv_easy_post = false
	m.removedcarrier_add_serv_easy_post = nil
}

// Where appends a list predicates to the CarrierServiceEasyPostMutation builder.
func (m *CarrierServiceEasyPostMutation) Where(ps ...predicate.CarrierServiceEasyPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierServiceEasyPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierServiceEasyPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierServiceEasyPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierServiceEasyPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierServiceEasyPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierServiceEasyPost).
func (m *CarrierServiceEasyPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierServiceEasyPostMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.api_key != nil {
		fields = append(fields, carrierserviceeasypost.FieldAPIKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierServiceEasyPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierserviceeasypost.FieldAPIKey:
		return m.APIKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierServiceEasyPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierserviceeasypost.FieldAPIKey:
		return m.OldAPIKey(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierServiceEasyPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceEasyPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierserviceeasypost.FieldAPIKey:
		v, ok := value.(carrierserviceeasypost.APIKey)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceEasyPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierServiceEasyPostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierServiceEasyPostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceEasyPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierServiceEasyPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierServiceEasyPostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierServiceEasyPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierServiceEasyPostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierServiceEasyPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierServiceEasyPostMutation) ResetField(name string) error {
	switch name {
	case carrierserviceeasypost.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceEasyPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierServiceEasyPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service != nil {
		edges = append(edges, carrierserviceeasypost.EdgeCarrierService)
	}
	if m.carrier_add_serv_easy_post != nil {
		edges = append(edges, carrierserviceeasypost.EdgeCarrierAddServEasyPost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierServiceEasyPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierserviceeasypost.EdgeCarrierService:
		if id := m.carrier_service; id != nil {
			return []ent.Value{*id}
		}
	case carrierserviceeasypost.EdgeCarrierAddServEasyPost:
		ids := make([]ent.Value, 0, len(m.carrier_add_serv_easy_post))
		for id := range m.carrier_add_serv_easy_post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierServiceEasyPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_add_serv_easy_post != nil {
		edges = append(edges, carrierserviceeasypost.EdgeCarrierAddServEasyPost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierServiceEasyPostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrierserviceeasypost.EdgeCarrierAddServEasyPost:
		ids := make([]ent.Value, 0, len(m.removedcarrier_add_serv_easy_post))
		for id := range m.removedcarrier_add_serv_easy_post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierServiceEasyPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service {
		edges = append(edges, carrierserviceeasypost.EdgeCarrierService)
	}
	if m.clearedcarrier_add_serv_easy_post {
		edges = append(edges, carrierserviceeasypost.EdgeCarrierAddServEasyPost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierServiceEasyPostMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierserviceeasypost.EdgeCarrierService:
		return m.clearedcarrier_service
	case carrierserviceeasypost.EdgeCarrierAddServEasyPost:
		return m.clearedcarrier_add_serv_easy_post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierServiceEasyPostMutation) ClearEdge(name string) error {
	switch name {
	case carrierserviceeasypost.EdgeCarrierService:
		m.ClearCarrierService()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceEasyPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierServiceEasyPostMutation) ResetEdge(name string) error {
	switch name {
	case carrierserviceeasypost.EdgeCarrierService:
		m.ResetCarrierService()
		return nil
	case carrierserviceeasypost.EdgeCarrierAddServEasyPost:
		m.ResetCarrierAddServEasyPost()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceEasyPost edge %s", name)
}

// CarrierServiceGLSMutation represents an operation that mutates the CarrierServiceGLS nodes in the graph.
type CarrierServiceGLSMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *pulid.ID
	api_key                               *string
	api_value                             *carrierservicegls.APIValue
	clearedFields                         map[string]struct{}
	carrier_service                       *pulid.ID
	clearedcarrier_service                bool
	carrier_additional_service_gls        map[pulid.ID]struct{}
	removedcarrier_additional_service_gls map[pulid.ID]struct{}
	clearedcarrier_additional_service_gls bool
	done                                  bool
	oldValue                              func(context.Context) (*CarrierServiceGLS, error)
	predicates                            []predicate.CarrierServiceGLS
}

var _ ent.Mutation = (*CarrierServiceGLSMutation)(nil)

// carrierserviceglsOption allows management of the mutation configuration using functional options.
type carrierserviceglsOption func(*CarrierServiceGLSMutation)

// newCarrierServiceGLSMutation creates new mutation for the CarrierServiceGLS entity.
func newCarrierServiceGLSMutation(c config, op Op, opts ...carrierserviceglsOption) *CarrierServiceGLSMutation {
	m := &CarrierServiceGLSMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierServiceGLS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierServiceGLSID sets the ID field of the mutation.
func withCarrierServiceGLSID(id pulid.ID) carrierserviceglsOption {
	return func(m *CarrierServiceGLSMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierServiceGLS
		)
		m.oldValue = func(ctx context.Context) (*CarrierServiceGLS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierServiceGLS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierServiceGLS sets the old CarrierServiceGLS of the mutation.
func withCarrierServiceGLS(node *CarrierServiceGLS) carrierserviceglsOption {
	return func(m *CarrierServiceGLSMutation) {
		m.oldValue = func(context.Context) (*CarrierServiceGLS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierServiceGLSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierServiceGLSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierServiceGLS entities.
func (m *CarrierServiceGLSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierServiceGLSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierServiceGLSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierServiceGLS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAPIKey sets the "api_key" field.
func (m *CarrierServiceGLSMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *CarrierServiceGLSMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the CarrierServiceGLS entity.
// If the CarrierServiceGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceGLSMutation) OldAPIKey(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ClearAPIKey clears the value of the "api_key" field.
func (m *CarrierServiceGLSMutation) ClearAPIKey() {
	m.api_key = nil
	m.clearedFields[carrierservicegls.FieldAPIKey] = struct{}{}
}

// APIKeyCleared returns if the "api_key" field was cleared in this mutation.
func (m *CarrierServiceGLSMutation) APIKeyCleared() bool {
	_, ok := m.clearedFields[carrierservicegls.FieldAPIKey]
	return ok
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *CarrierServiceGLSMutation) ResetAPIKey() {
	m.api_key = nil
	delete(m.clearedFields, carrierservicegls.FieldAPIKey)
}

// SetAPIValue sets the "api_value" field.
func (m *CarrierServiceGLSMutation) SetAPIValue(cv carrierservicegls.APIValue) {
	m.api_value = &cv
}

// APIValue returns the value of the "api_value" field in the mutation.
func (m *CarrierServiceGLSMutation) APIValue() (r carrierservicegls.APIValue, exists bool) {
	v := m.api_value
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIValue returns the old "api_value" field's value of the CarrierServiceGLS entity.
// If the CarrierServiceGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceGLSMutation) OldAPIValue(ctx context.Context) (v carrierservicegls.APIValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIValue: %w", err)
	}
	return oldValue.APIValue, nil
}

// ResetAPIValue resets all changes to the "api_value" field.
func (m *CarrierServiceGLSMutation) ResetAPIValue() {
	m.api_value = nil
}

// SetCarrierServiceID sets the "carrier_service" edge to the CarrierService entity by id.
func (m *CarrierServiceGLSMutation) SetCarrierServiceID(id pulid.ID) {
	m.carrier_service = &id
}

// ClearCarrierService clears the "carrier_service" edge to the CarrierService entity.
func (m *CarrierServiceGLSMutation) ClearCarrierService() {
	m.clearedcarrier_service = true
}

// CarrierServiceCleared reports if the "carrier_service" edge to the CarrierService entity was cleared.
func (m *CarrierServiceGLSMutation) CarrierServiceCleared() bool {
	return m.clearedcarrier_service
}

// CarrierServiceID returns the "carrier_service" edge ID in the mutation.
func (m *CarrierServiceGLSMutation) CarrierServiceID() (id pulid.ID, exists bool) {
	if m.carrier_service != nil {
		return *m.carrier_service, true
	}
	return
}

// CarrierServiceIDs returns the "carrier_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceGLSMutation) CarrierServiceIDs() (ids []pulid.ID) {
	if id := m.carrier_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierService resets all changes to the "carrier_service" edge.
func (m *CarrierServiceGLSMutation) ResetCarrierService() {
	m.carrier_service = nil
	m.clearedcarrier_service = false
}

// AddCarrierAdditionalServiceGlIDs adds the "carrier_additional_service_gls" edge to the CarrierAdditionalServiceGLS entity by ids.
func (m *CarrierServiceGLSMutation) AddCarrierAdditionalServiceGlIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_gls == nil {
		m.carrier_additional_service_gls = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_gls[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceGLS clears the "carrier_additional_service_gls" edge to the CarrierAdditionalServiceGLS entity.
func (m *CarrierServiceGLSMutation) ClearCarrierAdditionalServiceGLS() {
	m.clearedcarrier_additional_service_gls = true
}

// CarrierAdditionalServiceGLSCleared reports if the "carrier_additional_service_gls" edge to the CarrierAdditionalServiceGLS entity was cleared.
func (m *CarrierServiceGLSMutation) CarrierAdditionalServiceGLSCleared() bool {
	return m.clearedcarrier_additional_service_gls
}

// RemoveCarrierAdditionalServiceGlIDs removes the "carrier_additional_service_gls" edge to the CarrierAdditionalServiceGLS entity by IDs.
func (m *CarrierServiceGLSMutation) RemoveCarrierAdditionalServiceGlIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_gls == nil {
		m.removedcarrier_additional_service_gls = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_gls, ids[i])
		m.removedcarrier_additional_service_gls[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceGLS returns the removed IDs of the "carrier_additional_service_gls" edge to the CarrierAdditionalServiceGLS entity.
func (m *CarrierServiceGLSMutation) RemovedCarrierAdditionalServiceGLSIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_gls {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceGLSIDs returns the "carrier_additional_service_gls" edge IDs in the mutation.
func (m *CarrierServiceGLSMutation) CarrierAdditionalServiceGLSIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_gls {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceGLS resets all changes to the "carrier_additional_service_gls" edge.
func (m *CarrierServiceGLSMutation) ResetCarrierAdditionalServiceGLS() {
	m.carrier_additional_service_gls = nil
	m.clearedcarrier_additional_service_gls = false
	m.removedcarrier_additional_service_gls = nil
}

// Where appends a list predicates to the CarrierServiceGLSMutation builder.
func (m *CarrierServiceGLSMutation) Where(ps ...predicate.CarrierServiceGLS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierServiceGLSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierServiceGLSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierServiceGLS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierServiceGLSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierServiceGLSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierServiceGLS).
func (m *CarrierServiceGLSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierServiceGLSMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.api_key != nil {
		fields = append(fields, carrierservicegls.FieldAPIKey)
	}
	if m.api_value != nil {
		fields = append(fields, carrierservicegls.FieldAPIValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierServiceGLSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierservicegls.FieldAPIKey:
		return m.APIKey()
	case carrierservicegls.FieldAPIValue:
		return m.APIValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierServiceGLSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierservicegls.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case carrierservicegls.FieldAPIValue:
		return m.OldAPIValue(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierServiceGLS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceGLSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierservicegls.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case carrierservicegls.FieldAPIValue:
		v, ok := value.(carrierservicegls.APIValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIValue(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceGLS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierServiceGLSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierServiceGLSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceGLSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierServiceGLS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierServiceGLSMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carrierservicegls.FieldAPIKey) {
		fields = append(fields, carrierservicegls.FieldAPIKey)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierServiceGLSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierServiceGLSMutation) ClearField(name string) error {
	switch name {
	case carrierservicegls.FieldAPIKey:
		m.ClearAPIKey()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceGLS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierServiceGLSMutation) ResetField(name string) error {
	switch name {
	case carrierservicegls.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case carrierservicegls.FieldAPIValue:
		m.ResetAPIValue()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceGLS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierServiceGLSMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service != nil {
		edges = append(edges, carrierservicegls.EdgeCarrierService)
	}
	if m.carrier_additional_service_gls != nil {
		edges = append(edges, carrierservicegls.EdgeCarrierAdditionalServiceGLS)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierServiceGLSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierservicegls.EdgeCarrierService:
		if id := m.carrier_service; id != nil {
			return []ent.Value{*id}
		}
	case carrierservicegls.EdgeCarrierAdditionalServiceGLS:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_gls))
		for id := range m.carrier_additional_service_gls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierServiceGLSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_additional_service_gls != nil {
		edges = append(edges, carrierservicegls.EdgeCarrierAdditionalServiceGLS)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierServiceGLSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrierservicegls.EdgeCarrierAdditionalServiceGLS:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_gls))
		for id := range m.removedcarrier_additional_service_gls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierServiceGLSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service {
		edges = append(edges, carrierservicegls.EdgeCarrierService)
	}
	if m.clearedcarrier_additional_service_gls {
		edges = append(edges, carrierservicegls.EdgeCarrierAdditionalServiceGLS)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierServiceGLSMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierservicegls.EdgeCarrierService:
		return m.clearedcarrier_service
	case carrierservicegls.EdgeCarrierAdditionalServiceGLS:
		return m.clearedcarrier_additional_service_gls
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierServiceGLSMutation) ClearEdge(name string) error {
	switch name {
	case carrierservicegls.EdgeCarrierService:
		m.ClearCarrierService()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceGLS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierServiceGLSMutation) ResetEdge(name string) error {
	switch name {
	case carrierservicegls.EdgeCarrierService:
		m.ResetCarrierService()
		return nil
	case carrierservicegls.EdgeCarrierAdditionalServiceGLS:
		m.ResetCarrierAdditionalServiceGLS()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceGLS edge %s", name)
}

// CarrierServicePostNordMutation represents an operation that mutates the CarrierServicePostNord nodes in the graph.
type CarrierServicePostNordMutation struct {
	config
	op                                Op
	typ                               string
	id                                *pulid.ID
	label                             *string
	internal_id                       *string
	api_code                          *string
	clearedFields                     map[string]struct{}
	carrier_service                   *pulid.ID
	clearedcarrier_service            bool
	carrier_add_serv_post_nord        map[pulid.ID]struct{}
	removedcarrier_add_serv_post_nord map[pulid.ID]struct{}
	clearedcarrier_add_serv_post_nord bool
	done                              bool
	oldValue                          func(context.Context) (*CarrierServicePostNord, error)
	predicates                        []predicate.CarrierServicePostNord
}

var _ ent.Mutation = (*CarrierServicePostNordMutation)(nil)

// carrierservicepostnordOption allows management of the mutation configuration using functional options.
type carrierservicepostnordOption func(*CarrierServicePostNordMutation)

// newCarrierServicePostNordMutation creates new mutation for the CarrierServicePostNord entity.
func newCarrierServicePostNordMutation(c config, op Op, opts ...carrierservicepostnordOption) *CarrierServicePostNordMutation {
	m := &CarrierServicePostNordMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierServicePostNord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierServicePostNordID sets the ID field of the mutation.
func withCarrierServicePostNordID(id pulid.ID) carrierservicepostnordOption {
	return func(m *CarrierServicePostNordMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierServicePostNord
		)
		m.oldValue = func(ctx context.Context) (*CarrierServicePostNord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierServicePostNord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierServicePostNord sets the old CarrierServicePostNord of the mutation.
func withCarrierServicePostNord(node *CarrierServicePostNord) carrierservicepostnordOption {
	return func(m *CarrierServicePostNordMutation) {
		m.oldValue = func(context.Context) (*CarrierServicePostNord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierServicePostNordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierServicePostNordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierServicePostNord entities.
func (m *CarrierServicePostNordMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierServicePostNordMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierServicePostNordMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierServicePostNord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CarrierServicePostNordMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CarrierServicePostNordMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the CarrierServicePostNord entity.
// If the CarrierServicePostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServicePostNordMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CarrierServicePostNordMutation) ResetLabel() {
	m.label = nil
}

// SetInternalID sets the "internal_id" field.
func (m *CarrierServicePostNordMutation) SetInternalID(s string) {
	m.internal_id = &s
}

// InternalID returns the value of the "internal_id" field in the mutation.
func (m *CarrierServicePostNordMutation) InternalID() (r string, exists bool) {
	v := m.internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalID returns the old "internal_id" field's value of the CarrierServicePostNord entity.
// If the CarrierServicePostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServicePostNordMutation) OldInternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalID: %w", err)
	}
	return oldValue.InternalID, nil
}

// ResetInternalID resets all changes to the "internal_id" field.
func (m *CarrierServicePostNordMutation) ResetInternalID() {
	m.internal_id = nil
}

// SetAPICode sets the "api_code" field.
func (m *CarrierServicePostNordMutation) SetAPICode(s string) {
	m.api_code = &s
}

// APICode returns the value of the "api_code" field in the mutation.
func (m *CarrierServicePostNordMutation) APICode() (r string, exists bool) {
	v := m.api_code
	if v == nil {
		return
	}
	return *v, true
}

// OldAPICode returns the old "api_code" field's value of the CarrierServicePostNord entity.
// If the CarrierServicePostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServicePostNordMutation) OldAPICode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPICode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPICode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPICode: %w", err)
	}
	return oldValue.APICode, nil
}

// ResetAPICode resets all changes to the "api_code" field.
func (m *CarrierServicePostNordMutation) ResetAPICode() {
	m.api_code = nil
}

// SetCarrierServiceID sets the "carrier_service" edge to the CarrierService entity by id.
func (m *CarrierServicePostNordMutation) SetCarrierServiceID(id pulid.ID) {
	m.carrier_service = &id
}

// ClearCarrierService clears the "carrier_service" edge to the CarrierService entity.
func (m *CarrierServicePostNordMutation) ClearCarrierService() {
	m.clearedcarrier_service = true
}

// CarrierServiceCleared reports if the "carrier_service" edge to the CarrierService entity was cleared.
func (m *CarrierServicePostNordMutation) CarrierServiceCleared() bool {
	return m.clearedcarrier_service
}

// CarrierServiceID returns the "carrier_service" edge ID in the mutation.
func (m *CarrierServicePostNordMutation) CarrierServiceID() (id pulid.ID, exists bool) {
	if m.carrier_service != nil {
		return *m.carrier_service, true
	}
	return
}

// CarrierServiceIDs returns the "carrier_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceID instead. It exists only for internal usage by the builders.
func (m *CarrierServicePostNordMutation) CarrierServiceIDs() (ids []pulid.ID) {
	if id := m.carrier_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierService resets all changes to the "carrier_service" edge.
func (m *CarrierServicePostNordMutation) ResetCarrierService() {
	m.carrier_service = nil
	m.clearedcarrier_service = false
}

// AddCarrierAddServPostNordIDs adds the "carrier_add_serv_post_nord" edge to the CarrierAdditionalServicePostNord entity by ids.
func (m *CarrierServicePostNordMutation) AddCarrierAddServPostNordIDs(ids ...pulid.ID) {
	if m.carrier_add_serv_post_nord == nil {
		m.carrier_add_serv_post_nord = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_add_serv_post_nord[ids[i]] = struct{}{}
	}
}

// ClearCarrierAddServPostNord clears the "carrier_add_serv_post_nord" edge to the CarrierAdditionalServicePostNord entity.
func (m *CarrierServicePostNordMutation) ClearCarrierAddServPostNord() {
	m.clearedcarrier_add_serv_post_nord = true
}

// CarrierAddServPostNordCleared reports if the "carrier_add_serv_post_nord" edge to the CarrierAdditionalServicePostNord entity was cleared.
func (m *CarrierServicePostNordMutation) CarrierAddServPostNordCleared() bool {
	return m.clearedcarrier_add_serv_post_nord
}

// RemoveCarrierAddServPostNordIDs removes the "carrier_add_serv_post_nord" edge to the CarrierAdditionalServicePostNord entity by IDs.
func (m *CarrierServicePostNordMutation) RemoveCarrierAddServPostNordIDs(ids ...pulid.ID) {
	if m.removedcarrier_add_serv_post_nord == nil {
		m.removedcarrier_add_serv_post_nord = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_add_serv_post_nord, ids[i])
		m.removedcarrier_add_serv_post_nord[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAddServPostNord returns the removed IDs of the "carrier_add_serv_post_nord" edge to the CarrierAdditionalServicePostNord entity.
func (m *CarrierServicePostNordMutation) RemovedCarrierAddServPostNordIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_add_serv_post_nord {
		ids = append(ids, id)
	}
	return
}

// CarrierAddServPostNordIDs returns the "carrier_add_serv_post_nord" edge IDs in the mutation.
func (m *CarrierServicePostNordMutation) CarrierAddServPostNordIDs() (ids []pulid.ID) {
	for id := range m.carrier_add_serv_post_nord {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAddServPostNord resets all changes to the "carrier_add_serv_post_nord" edge.
func (m *CarrierServicePostNordMutation) ResetCarrierAddServPostNord() {
	m.carrier_add_serv_post_nord = nil
	m.clearedcarrier_add_serv_post_nord = false
	m.removedcarrier_add_serv_post_nord = nil
}

// Where appends a list predicates to the CarrierServicePostNordMutation builder.
func (m *CarrierServicePostNordMutation) Where(ps ...predicate.CarrierServicePostNord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierServicePostNordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierServicePostNordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierServicePostNord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierServicePostNordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierServicePostNordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierServicePostNord).
func (m *CarrierServicePostNordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierServicePostNordMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.label != nil {
		fields = append(fields, carrierservicepostnord.FieldLabel)
	}
	if m.internal_id != nil {
		fields = append(fields, carrierservicepostnord.FieldInternalID)
	}
	if m.api_code != nil {
		fields = append(fields, carrierservicepostnord.FieldAPICode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierServicePostNordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierservicepostnord.FieldLabel:
		return m.Label()
	case carrierservicepostnord.FieldInternalID:
		return m.InternalID()
	case carrierservicepostnord.FieldAPICode:
		return m.APICode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierServicePostNordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierservicepostnord.FieldLabel:
		return m.OldLabel(ctx)
	case carrierservicepostnord.FieldInternalID:
		return m.OldInternalID(ctx)
	case carrierservicepostnord.FieldAPICode:
		return m.OldAPICode(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierServicePostNord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServicePostNordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierservicepostnord.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case carrierservicepostnord.FieldInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalID(v)
		return nil
	case carrierservicepostnord.FieldAPICode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPICode(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierServicePostNord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierServicePostNordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierServicePostNordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServicePostNordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierServicePostNord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierServicePostNordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierServicePostNordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierServicePostNordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierServicePostNord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierServicePostNordMutation) ResetField(name string) error {
	switch name {
	case carrierservicepostnord.FieldLabel:
		m.ResetLabel()
		return nil
	case carrierservicepostnord.FieldInternalID:
		m.ResetInternalID()
		return nil
	case carrierservicepostnord.FieldAPICode:
		m.ResetAPICode()
		return nil
	}
	return fmt.Errorf("unknown CarrierServicePostNord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierServicePostNordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service != nil {
		edges = append(edges, carrierservicepostnord.EdgeCarrierService)
	}
	if m.carrier_add_serv_post_nord != nil {
		edges = append(edges, carrierservicepostnord.EdgeCarrierAddServPostNord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierServicePostNordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierservicepostnord.EdgeCarrierService:
		if id := m.carrier_service; id != nil {
			return []ent.Value{*id}
		}
	case carrierservicepostnord.EdgeCarrierAddServPostNord:
		ids := make([]ent.Value, 0, len(m.carrier_add_serv_post_nord))
		for id := range m.carrier_add_serv_post_nord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierServicePostNordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_add_serv_post_nord != nil {
		edges = append(edges, carrierservicepostnord.EdgeCarrierAddServPostNord)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierServicePostNordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrierservicepostnord.EdgeCarrierAddServPostNord:
		ids := make([]ent.Value, 0, len(m.removedcarrier_add_serv_post_nord))
		for id := range m.removedcarrier_add_serv_post_nord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierServicePostNordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service {
		edges = append(edges, carrierservicepostnord.EdgeCarrierService)
	}
	if m.clearedcarrier_add_serv_post_nord {
		edges = append(edges, carrierservicepostnord.EdgeCarrierAddServPostNord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierServicePostNordMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierservicepostnord.EdgeCarrierService:
		return m.clearedcarrier_service
	case carrierservicepostnord.EdgeCarrierAddServPostNord:
		return m.clearedcarrier_add_serv_post_nord
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierServicePostNordMutation) ClearEdge(name string) error {
	switch name {
	case carrierservicepostnord.EdgeCarrierService:
		m.ClearCarrierService()
		return nil
	}
	return fmt.Errorf("unknown CarrierServicePostNord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierServicePostNordMutation) ResetEdge(name string) error {
	switch name {
	case carrierservicepostnord.EdgeCarrierService:
		m.ResetCarrierService()
		return nil
	case carrierservicepostnord.EdgeCarrierAddServPostNord:
		m.ResetCarrierAddServPostNord()
		return nil
	}
	return fmt.Errorf("unknown CarrierServicePostNord edge %s", name)
}

// CarrierServiceUSPSMutation represents an operation that mutates the CarrierServiceUSPS nodes in the graph.
type CarrierServiceUSPSMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *pulid.ID
	api_key                                *carrierserviceusps.APIKey
	clearedFields                          map[string]struct{}
	carrier_service                        *pulid.ID
	clearedcarrier_service                 bool
	carrier_additional_service_usps        map[pulid.ID]struct{}
	removedcarrier_additional_service_usps map[pulid.ID]struct{}
	clearedcarrier_additional_service_usps bool
	done                                   bool
	oldValue                               func(context.Context) (*CarrierServiceUSPS, error)
	predicates                             []predicate.CarrierServiceUSPS
}

var _ ent.Mutation = (*CarrierServiceUSPSMutation)(nil)

// carrierserviceuspsOption allows management of the mutation configuration using functional options.
type carrierserviceuspsOption func(*CarrierServiceUSPSMutation)

// newCarrierServiceUSPSMutation creates new mutation for the CarrierServiceUSPS entity.
func newCarrierServiceUSPSMutation(c config, op Op, opts ...carrierserviceuspsOption) *CarrierServiceUSPSMutation {
	m := &CarrierServiceUSPSMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierServiceUSPS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierServiceUSPSID sets the ID field of the mutation.
func withCarrierServiceUSPSID(id pulid.ID) carrierserviceuspsOption {
	return func(m *CarrierServiceUSPSMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierServiceUSPS
		)
		m.oldValue = func(ctx context.Context) (*CarrierServiceUSPS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierServiceUSPS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierServiceUSPS sets the old CarrierServiceUSPS of the mutation.
func withCarrierServiceUSPS(node *CarrierServiceUSPS) carrierserviceuspsOption {
	return func(m *CarrierServiceUSPSMutation) {
		m.oldValue = func(context.Context) (*CarrierServiceUSPS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierServiceUSPSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierServiceUSPSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierServiceUSPS entities.
func (m *CarrierServiceUSPSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierServiceUSPSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierServiceUSPSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierServiceUSPS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAPIKey sets the "api_key" field.
func (m *CarrierServiceUSPSMutation) SetAPIKey(ck carrierserviceusps.APIKey) {
	m.api_key = &ck
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *CarrierServiceUSPSMutation) APIKey() (r carrierserviceusps.APIKey, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the CarrierServiceUSPS entity.
// If the CarrierServiceUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierServiceUSPSMutation) OldAPIKey(ctx context.Context) (v carrierserviceusps.APIKey, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *CarrierServiceUSPSMutation) ResetAPIKey() {
	m.api_key = nil
}

// SetCarrierServiceID sets the "carrier_service" edge to the CarrierService entity by id.
func (m *CarrierServiceUSPSMutation) SetCarrierServiceID(id pulid.ID) {
	m.carrier_service = &id
}

// ClearCarrierService clears the "carrier_service" edge to the CarrierService entity.
func (m *CarrierServiceUSPSMutation) ClearCarrierService() {
	m.clearedcarrier_service = true
}

// CarrierServiceCleared reports if the "carrier_service" edge to the CarrierService entity was cleared.
func (m *CarrierServiceUSPSMutation) CarrierServiceCleared() bool {
	return m.clearedcarrier_service
}

// CarrierServiceID returns the "carrier_service" edge ID in the mutation.
func (m *CarrierServiceUSPSMutation) CarrierServiceID() (id pulid.ID, exists bool) {
	if m.carrier_service != nil {
		return *m.carrier_service, true
	}
	return
}

// CarrierServiceIDs returns the "carrier_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceID instead. It exists only for internal usage by the builders.
func (m *CarrierServiceUSPSMutation) CarrierServiceIDs() (ids []pulid.ID) {
	if id := m.carrier_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierService resets all changes to the "carrier_service" edge.
func (m *CarrierServiceUSPSMutation) ResetCarrierService() {
	m.carrier_service = nil
	m.clearedcarrier_service = false
}

// AddCarrierAdditionalServiceUspIDs adds the "carrier_additional_service_usps" edge to the CarrierAdditionalServiceUSPS entity by ids.
func (m *CarrierServiceUSPSMutation) AddCarrierAdditionalServiceUspIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_usps == nil {
		m.carrier_additional_service_usps = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_usps[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceUSPS clears the "carrier_additional_service_usps" edge to the CarrierAdditionalServiceUSPS entity.
func (m *CarrierServiceUSPSMutation) ClearCarrierAdditionalServiceUSPS() {
	m.clearedcarrier_additional_service_usps = true
}

// CarrierAdditionalServiceUSPSCleared reports if the "carrier_additional_service_usps" edge to the CarrierAdditionalServiceUSPS entity was cleared.
func (m *CarrierServiceUSPSMutation) CarrierAdditionalServiceUSPSCleared() bool {
	return m.clearedcarrier_additional_service_usps
}

// RemoveCarrierAdditionalServiceUspIDs removes the "carrier_additional_service_usps" edge to the CarrierAdditionalServiceUSPS entity by IDs.
func (m *CarrierServiceUSPSMutation) RemoveCarrierAdditionalServiceUspIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_usps == nil {
		m.removedcarrier_additional_service_usps = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_usps, ids[i])
		m.removedcarrier_additional_service_usps[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceUSPS returns the removed IDs of the "carrier_additional_service_usps" edge to the CarrierAdditionalServiceUSPS entity.
func (m *CarrierServiceUSPSMutation) RemovedCarrierAdditionalServiceUSPSIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_usps {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceUSPSIDs returns the "carrier_additional_service_usps" edge IDs in the mutation.
func (m *CarrierServiceUSPSMutation) CarrierAdditionalServiceUSPSIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_usps {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceUSPS resets all changes to the "carrier_additional_service_usps" edge.
func (m *CarrierServiceUSPSMutation) ResetCarrierAdditionalServiceUSPS() {
	m.carrier_additional_service_usps = nil
	m.clearedcarrier_additional_service_usps = false
	m.removedcarrier_additional_service_usps = nil
}

// Where appends a list predicates to the CarrierServiceUSPSMutation builder.
func (m *CarrierServiceUSPSMutation) Where(ps ...predicate.CarrierServiceUSPS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierServiceUSPSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierServiceUSPSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierServiceUSPS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierServiceUSPSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierServiceUSPSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierServiceUSPS).
func (m *CarrierServiceUSPSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierServiceUSPSMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.api_key != nil {
		fields = append(fields, carrierserviceusps.FieldAPIKey)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierServiceUSPSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierserviceusps.FieldAPIKey:
		return m.APIKey()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierServiceUSPSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierserviceusps.FieldAPIKey:
		return m.OldAPIKey(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierServiceUSPS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceUSPSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierserviceusps.FieldAPIKey:
		v, ok := value.(carrierserviceusps.APIKey)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceUSPS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierServiceUSPSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierServiceUSPSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierServiceUSPSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierServiceUSPS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierServiceUSPSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierServiceUSPSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierServiceUSPSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CarrierServiceUSPS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierServiceUSPSMutation) ResetField(name string) error {
	switch name {
	case carrierserviceusps.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceUSPS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierServiceUSPSMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.carrier_service != nil {
		edges = append(edges, carrierserviceusps.EdgeCarrierService)
	}
	if m.carrier_additional_service_usps != nil {
		edges = append(edges, carrierserviceusps.EdgeCarrierAdditionalServiceUSPS)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierServiceUSPSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierserviceusps.EdgeCarrierService:
		if id := m.carrier_service; id != nil {
			return []ent.Value{*id}
		}
	case carrierserviceusps.EdgeCarrierAdditionalServiceUSPS:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_usps))
		for id := range m.carrier_additional_service_usps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierServiceUSPSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedcarrier_additional_service_usps != nil {
		edges = append(edges, carrierserviceusps.EdgeCarrierAdditionalServiceUSPS)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierServiceUSPSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case carrierserviceusps.EdgeCarrierAdditionalServiceUSPS:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_usps))
		for id := range m.removedcarrier_additional_service_usps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierServiceUSPSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcarrier_service {
		edges = append(edges, carrierserviceusps.EdgeCarrierService)
	}
	if m.clearedcarrier_additional_service_usps {
		edges = append(edges, carrierserviceusps.EdgeCarrierAdditionalServiceUSPS)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierServiceUSPSMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierserviceusps.EdgeCarrierService:
		return m.clearedcarrier_service
	case carrierserviceusps.EdgeCarrierAdditionalServiceUSPS:
		return m.clearedcarrier_additional_service_usps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierServiceUSPSMutation) ClearEdge(name string) error {
	switch name {
	case carrierserviceusps.EdgeCarrierService:
		m.ClearCarrierService()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceUSPS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierServiceUSPSMutation) ResetEdge(name string) error {
	switch name {
	case carrierserviceusps.EdgeCarrierService:
		m.ResetCarrierService()
		return nil
	case carrierserviceusps.EdgeCarrierAdditionalServiceUSPS:
		m.ResetCarrierAdditionalServiceUSPS()
		return nil
	}
	return fmt.Errorf("unknown CarrierServiceUSPS edge %s", name)
}

// CarrierUSPSMutation represents an operation that mutates the CarrierUSPS nodes in the graph.
type CarrierUSPSMutation struct {
	config
	op                 Op
	typ                string
	id                 *pulid.ID
	is_test_api        *bool
	consumer_key       *string
	consumer_secret    *string
	mid                *string
	manifest_mid       *string
	crid               *string
	eps_account_number *string
	clearedFields      map[string]struct{}
	tenant             *pulid.ID
	clearedtenant      bool
	carrier            *pulid.ID
	clearedcarrier     bool
	done               bool
	oldValue           func(context.Context) (*CarrierUSPS, error)
	predicates         []predicate.CarrierUSPS
}

var _ ent.Mutation = (*CarrierUSPSMutation)(nil)

// carrieruspsOption allows management of the mutation configuration using functional options.
type carrieruspsOption func(*CarrierUSPSMutation)

// newCarrierUSPSMutation creates new mutation for the CarrierUSPS entity.
func newCarrierUSPSMutation(c config, op Op, opts ...carrieruspsOption) *CarrierUSPSMutation {
	m := &CarrierUSPSMutation{
		config:        c,
		op:            op,
		typ:           TypeCarrierUSPS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCarrierUSPSID sets the ID field of the mutation.
func withCarrierUSPSID(id pulid.ID) carrieruspsOption {
	return func(m *CarrierUSPSMutation) {
		var (
			err   error
			once  sync.Once
			value *CarrierUSPS
		)
		m.oldValue = func(ctx context.Context) (*CarrierUSPS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CarrierUSPS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCarrierUSPS sets the old CarrierUSPS of the mutation.
func withCarrierUSPS(node *CarrierUSPS) carrieruspsOption {
	return func(m *CarrierUSPSMutation) {
		m.oldValue = func(context.Context) (*CarrierUSPS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CarrierUSPSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CarrierUSPSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CarrierUSPS entities.
func (m *CarrierUSPSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CarrierUSPSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CarrierUSPSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CarrierUSPS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CarrierUSPSMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CarrierUSPSMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CarrierUSPS entity.
// If the CarrierUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierUSPSMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CarrierUSPSMutation) ResetTenantID() {
	m.tenant = nil
}

// SetIsTestAPI sets the "is_test_api" field.
func (m *CarrierUSPSMutation) SetIsTestAPI(b bool) {
	m.is_test_api = &b
}

// IsTestAPI returns the value of the "is_test_api" field in the mutation.
func (m *CarrierUSPSMutation) IsTestAPI() (r bool, exists bool) {
	v := m.is_test_api
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTestAPI returns the old "is_test_api" field's value of the CarrierUSPS entity.
// If the CarrierUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierUSPSMutation) OldIsTestAPI(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTestAPI is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTestAPI requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTestAPI: %w", err)
	}
	return oldValue.IsTestAPI, nil
}

// ResetIsTestAPI resets all changes to the "is_test_api" field.
func (m *CarrierUSPSMutation) ResetIsTestAPI() {
	m.is_test_api = nil
}

// SetConsumerKey sets the "consumer_key" field.
func (m *CarrierUSPSMutation) SetConsumerKey(s string) {
	m.consumer_key = &s
}

// ConsumerKey returns the value of the "consumer_key" field in the mutation.
func (m *CarrierUSPSMutation) ConsumerKey() (r string, exists bool) {
	v := m.consumer_key
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumerKey returns the old "consumer_key" field's value of the CarrierUSPS entity.
// If the CarrierUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierUSPSMutation) OldConsumerKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumerKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumerKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumerKey: %w", err)
	}
	return oldValue.ConsumerKey, nil
}

// ClearConsumerKey clears the value of the "consumer_key" field.
func (m *CarrierUSPSMutation) ClearConsumerKey() {
	m.consumer_key = nil
	m.clearedFields[carrierusps.FieldConsumerKey] = struct{}{}
}

// ConsumerKeyCleared returns if the "consumer_key" field was cleared in this mutation.
func (m *CarrierUSPSMutation) ConsumerKeyCleared() bool {
	_, ok := m.clearedFields[carrierusps.FieldConsumerKey]
	return ok
}

// ResetConsumerKey resets all changes to the "consumer_key" field.
func (m *CarrierUSPSMutation) ResetConsumerKey() {
	m.consumer_key = nil
	delete(m.clearedFields, carrierusps.FieldConsumerKey)
}

// SetConsumerSecret sets the "consumer_secret" field.
func (m *CarrierUSPSMutation) SetConsumerSecret(s string) {
	m.consumer_secret = &s
}

// ConsumerSecret returns the value of the "consumer_secret" field in the mutation.
func (m *CarrierUSPSMutation) ConsumerSecret() (r string, exists bool) {
	v := m.consumer_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldConsumerSecret returns the old "consumer_secret" field's value of the CarrierUSPS entity.
// If the CarrierUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierUSPSMutation) OldConsumerSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsumerSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsumerSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsumerSecret: %w", err)
	}
	return oldValue.ConsumerSecret, nil
}

// ClearConsumerSecret clears the value of the "consumer_secret" field.
func (m *CarrierUSPSMutation) ClearConsumerSecret() {
	m.consumer_secret = nil
	m.clearedFields[carrierusps.FieldConsumerSecret] = struct{}{}
}

// ConsumerSecretCleared returns if the "consumer_secret" field was cleared in this mutation.
func (m *CarrierUSPSMutation) ConsumerSecretCleared() bool {
	_, ok := m.clearedFields[carrierusps.FieldConsumerSecret]
	return ok
}

// ResetConsumerSecret resets all changes to the "consumer_secret" field.
func (m *CarrierUSPSMutation) ResetConsumerSecret() {
	m.consumer_secret = nil
	delete(m.clearedFields, carrierusps.FieldConsumerSecret)
}

// SetMid sets the "mid" field.
func (m *CarrierUSPSMutation) SetMid(s string) {
	m.mid = &s
}

// Mid returns the value of the "mid" field in the mutation.
func (m *CarrierUSPSMutation) Mid() (r string, exists bool) {
	v := m.mid
	if v == nil {
		return
	}
	return *v, true
}

// OldMid returns the old "mid" field's value of the CarrierUSPS entity.
// If the CarrierUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierUSPSMutation) OldMid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMid: %w", err)
	}
	return oldValue.Mid, nil
}

// ClearMid clears the value of the "mid" field.
func (m *CarrierUSPSMutation) ClearMid() {
	m.mid = nil
	m.clearedFields[carrierusps.FieldMid] = struct{}{}
}

// MidCleared returns if the "mid" field was cleared in this mutation.
func (m *CarrierUSPSMutation) MidCleared() bool {
	_, ok := m.clearedFields[carrierusps.FieldMid]
	return ok
}

// ResetMid resets all changes to the "mid" field.
func (m *CarrierUSPSMutation) ResetMid() {
	m.mid = nil
	delete(m.clearedFields, carrierusps.FieldMid)
}

// SetManifestMid sets the "manifest_mid" field.
func (m *CarrierUSPSMutation) SetManifestMid(s string) {
	m.manifest_mid = &s
}

// ManifestMid returns the value of the "manifest_mid" field in the mutation.
func (m *CarrierUSPSMutation) ManifestMid() (r string, exists bool) {
	v := m.manifest_mid
	if v == nil {
		return
	}
	return *v, true
}

// OldManifestMid returns the old "manifest_mid" field's value of the CarrierUSPS entity.
// If the CarrierUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierUSPSMutation) OldManifestMid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldManifestMid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldManifestMid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldManifestMid: %w", err)
	}
	return oldValue.ManifestMid, nil
}

// ClearManifestMid clears the value of the "manifest_mid" field.
func (m *CarrierUSPSMutation) ClearManifestMid() {
	m.manifest_mid = nil
	m.clearedFields[carrierusps.FieldManifestMid] = struct{}{}
}

// ManifestMidCleared returns if the "manifest_mid" field was cleared in this mutation.
func (m *CarrierUSPSMutation) ManifestMidCleared() bool {
	_, ok := m.clearedFields[carrierusps.FieldManifestMid]
	return ok
}

// ResetManifestMid resets all changes to the "manifest_mid" field.
func (m *CarrierUSPSMutation) ResetManifestMid() {
	m.manifest_mid = nil
	delete(m.clearedFields, carrierusps.FieldManifestMid)
}

// SetCrid sets the "crid" field.
func (m *CarrierUSPSMutation) SetCrid(s string) {
	m.crid = &s
}

// Crid returns the value of the "crid" field in the mutation.
func (m *CarrierUSPSMutation) Crid() (r string, exists bool) {
	v := m.crid
	if v == nil {
		return
	}
	return *v, true
}

// OldCrid returns the old "crid" field's value of the CarrierUSPS entity.
// If the CarrierUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierUSPSMutation) OldCrid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCrid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCrid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCrid: %w", err)
	}
	return oldValue.Crid, nil
}

// ClearCrid clears the value of the "crid" field.
func (m *CarrierUSPSMutation) ClearCrid() {
	m.crid = nil
	m.clearedFields[carrierusps.FieldCrid] = struct{}{}
}

// CridCleared returns if the "crid" field was cleared in this mutation.
func (m *CarrierUSPSMutation) CridCleared() bool {
	_, ok := m.clearedFields[carrierusps.FieldCrid]
	return ok
}

// ResetCrid resets all changes to the "crid" field.
func (m *CarrierUSPSMutation) ResetCrid() {
	m.crid = nil
	delete(m.clearedFields, carrierusps.FieldCrid)
}

// SetEpsAccountNumber sets the "eps_account_number" field.
func (m *CarrierUSPSMutation) SetEpsAccountNumber(s string) {
	m.eps_account_number = &s
}

// EpsAccountNumber returns the value of the "eps_account_number" field in the mutation.
func (m *CarrierUSPSMutation) EpsAccountNumber() (r string, exists bool) {
	v := m.eps_account_number
	if v == nil {
		return
	}
	return *v, true
}

// OldEpsAccountNumber returns the old "eps_account_number" field's value of the CarrierUSPS entity.
// If the CarrierUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CarrierUSPSMutation) OldEpsAccountNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpsAccountNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpsAccountNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpsAccountNumber: %w", err)
	}
	return oldValue.EpsAccountNumber, nil
}

// ClearEpsAccountNumber clears the value of the "eps_account_number" field.
func (m *CarrierUSPSMutation) ClearEpsAccountNumber() {
	m.eps_account_number = nil
	m.clearedFields[carrierusps.FieldEpsAccountNumber] = struct{}{}
}

// EpsAccountNumberCleared returns if the "eps_account_number" field was cleared in this mutation.
func (m *CarrierUSPSMutation) EpsAccountNumberCleared() bool {
	_, ok := m.clearedFields[carrierusps.FieldEpsAccountNumber]
	return ok
}

// ResetEpsAccountNumber resets all changes to the "eps_account_number" field.
func (m *CarrierUSPSMutation) ResetEpsAccountNumber() {
	m.eps_account_number = nil
	delete(m.clearedFields, carrierusps.FieldEpsAccountNumber)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CarrierUSPSMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[carrierusps.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CarrierUSPSMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CarrierUSPSMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CarrierUSPSMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *CarrierUSPSMutation) SetCarrierID(id pulid.ID) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *CarrierUSPSMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *CarrierUSPSMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *CarrierUSPSMutation) CarrierID() (id pulid.ID, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *CarrierUSPSMutation) CarrierIDs() (ids []pulid.ID) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *CarrierUSPSMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// Where appends a list predicates to the CarrierUSPSMutation builder.
func (m *CarrierUSPSMutation) Where(ps ...predicate.CarrierUSPS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CarrierUSPSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CarrierUSPSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CarrierUSPS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CarrierUSPSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CarrierUSPSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CarrierUSPS).
func (m *CarrierUSPSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CarrierUSPSMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant != nil {
		fields = append(fields, carrierusps.FieldTenantID)
	}
	if m.is_test_api != nil {
		fields = append(fields, carrierusps.FieldIsTestAPI)
	}
	if m.consumer_key != nil {
		fields = append(fields, carrierusps.FieldConsumerKey)
	}
	if m.consumer_secret != nil {
		fields = append(fields, carrierusps.FieldConsumerSecret)
	}
	if m.mid != nil {
		fields = append(fields, carrierusps.FieldMid)
	}
	if m.manifest_mid != nil {
		fields = append(fields, carrierusps.FieldManifestMid)
	}
	if m.crid != nil {
		fields = append(fields, carrierusps.FieldCrid)
	}
	if m.eps_account_number != nil {
		fields = append(fields, carrierusps.FieldEpsAccountNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CarrierUSPSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case carrierusps.FieldTenantID:
		return m.TenantID()
	case carrierusps.FieldIsTestAPI:
		return m.IsTestAPI()
	case carrierusps.FieldConsumerKey:
		return m.ConsumerKey()
	case carrierusps.FieldConsumerSecret:
		return m.ConsumerSecret()
	case carrierusps.FieldMid:
		return m.Mid()
	case carrierusps.FieldManifestMid:
		return m.ManifestMid()
	case carrierusps.FieldCrid:
		return m.Crid()
	case carrierusps.FieldEpsAccountNumber:
		return m.EpsAccountNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CarrierUSPSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case carrierusps.FieldTenantID:
		return m.OldTenantID(ctx)
	case carrierusps.FieldIsTestAPI:
		return m.OldIsTestAPI(ctx)
	case carrierusps.FieldConsumerKey:
		return m.OldConsumerKey(ctx)
	case carrierusps.FieldConsumerSecret:
		return m.OldConsumerSecret(ctx)
	case carrierusps.FieldMid:
		return m.OldMid(ctx)
	case carrierusps.FieldManifestMid:
		return m.OldManifestMid(ctx)
	case carrierusps.FieldCrid:
		return m.OldCrid(ctx)
	case carrierusps.FieldEpsAccountNumber:
		return m.OldEpsAccountNumber(ctx)
	}
	return nil, fmt.Errorf("unknown CarrierUSPS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierUSPSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case carrierusps.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case carrierusps.FieldIsTestAPI:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTestAPI(v)
		return nil
	case carrierusps.FieldConsumerKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumerKey(v)
		return nil
	case carrierusps.FieldConsumerSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsumerSecret(v)
		return nil
	case carrierusps.FieldMid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMid(v)
		return nil
	case carrierusps.FieldManifestMid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetManifestMid(v)
		return nil
	case carrierusps.FieldCrid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCrid(v)
		return nil
	case carrierusps.FieldEpsAccountNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpsAccountNumber(v)
		return nil
	}
	return fmt.Errorf("unknown CarrierUSPS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CarrierUSPSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CarrierUSPSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CarrierUSPSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CarrierUSPS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CarrierUSPSMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(carrierusps.FieldConsumerKey) {
		fields = append(fields, carrierusps.FieldConsumerKey)
	}
	if m.FieldCleared(carrierusps.FieldConsumerSecret) {
		fields = append(fields, carrierusps.FieldConsumerSecret)
	}
	if m.FieldCleared(carrierusps.FieldMid) {
		fields = append(fields, carrierusps.FieldMid)
	}
	if m.FieldCleared(carrierusps.FieldManifestMid) {
		fields = append(fields, carrierusps.FieldManifestMid)
	}
	if m.FieldCleared(carrierusps.FieldCrid) {
		fields = append(fields, carrierusps.FieldCrid)
	}
	if m.FieldCleared(carrierusps.FieldEpsAccountNumber) {
		fields = append(fields, carrierusps.FieldEpsAccountNumber)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CarrierUSPSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CarrierUSPSMutation) ClearField(name string) error {
	switch name {
	case carrierusps.FieldConsumerKey:
		m.ClearConsumerKey()
		return nil
	case carrierusps.FieldConsumerSecret:
		m.ClearConsumerSecret()
		return nil
	case carrierusps.FieldMid:
		m.ClearMid()
		return nil
	case carrierusps.FieldManifestMid:
		m.ClearManifestMid()
		return nil
	case carrierusps.FieldCrid:
		m.ClearCrid()
		return nil
	case carrierusps.FieldEpsAccountNumber:
		m.ClearEpsAccountNumber()
		return nil
	}
	return fmt.Errorf("unknown CarrierUSPS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CarrierUSPSMutation) ResetField(name string) error {
	switch name {
	case carrierusps.FieldTenantID:
		m.ResetTenantID()
		return nil
	case carrierusps.FieldIsTestAPI:
		m.ResetIsTestAPI()
		return nil
	case carrierusps.FieldConsumerKey:
		m.ResetConsumerKey()
		return nil
	case carrierusps.FieldConsumerSecret:
		m.ResetConsumerSecret()
		return nil
	case carrierusps.FieldMid:
		m.ResetMid()
		return nil
	case carrierusps.FieldManifestMid:
		m.ResetManifestMid()
		return nil
	case carrierusps.FieldCrid:
		m.ResetCrid()
		return nil
	case carrierusps.FieldEpsAccountNumber:
		m.ResetEpsAccountNumber()
		return nil
	}
	return fmt.Errorf("unknown CarrierUSPS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CarrierUSPSMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, carrierusps.EdgeTenant)
	}
	if m.carrier != nil {
		edges = append(edges, carrierusps.EdgeCarrier)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CarrierUSPSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case carrierusps.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case carrierusps.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CarrierUSPSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CarrierUSPSMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CarrierUSPSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, carrierusps.EdgeTenant)
	}
	if m.clearedcarrier {
		edges = append(edges, carrierusps.EdgeCarrier)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CarrierUSPSMutation) EdgeCleared(name string) bool {
	switch name {
	case carrierusps.EdgeTenant:
		return m.clearedtenant
	case carrierusps.EdgeCarrier:
		return m.clearedcarrier
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CarrierUSPSMutation) ClearEdge(name string) error {
	switch name {
	case carrierusps.EdgeTenant:
		m.ClearTenant()
		return nil
	case carrierusps.EdgeCarrier:
		m.ClearCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierUSPS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CarrierUSPSMutation) ResetEdge(name string) error {
	switch name {
	case carrierusps.EdgeTenant:
		m.ResetTenant()
		return nil
	case carrierusps.EdgeCarrier:
		m.ResetCarrier()
		return nil
	}
	return fmt.Errorf("unknown CarrierUSPS edge %s", name)
}

// ChangeHistoryMutation represents an operation that mutates the ChangeHistory nodes in the graph.
type ChangeHistoryMutation struct {
	config
	op                          Op
	typ                         string
	id                          *pulid.ID
	created_at                  *time.Time
	origin                      *changehistory.Origin
	clearedFields               map[string]struct{}
	tenant                      *pulid.ID
	clearedtenant               bool
	plan_history                map[pulid.ID]struct{}
	removedplan_history         map[pulid.ID]struct{}
	clearedplan_history         bool
	user                        *pulid.ID
	cleareduser                 bool
	order_history               map[pulid.ID]struct{}
	removedorder_history        map[pulid.ID]struct{}
	clearedorder_history        bool
	shipment_history            map[pulid.ID]struct{}
	removedshipment_history     map[pulid.ID]struct{}
	clearedshipment_history     bool
	return_colli_history        map[pulid.ID]struct{}
	removedreturn_colli_history map[pulid.ID]struct{}
	clearedreturn_colli_history bool
	done                        bool
	oldValue                    func(context.Context) (*ChangeHistory, error)
	predicates                  []predicate.ChangeHistory
}

var _ ent.Mutation = (*ChangeHistoryMutation)(nil)

// changehistoryOption allows management of the mutation configuration using functional options.
type changehistoryOption func(*ChangeHistoryMutation)

// newChangeHistoryMutation creates new mutation for the ChangeHistory entity.
func newChangeHistoryMutation(c config, op Op, opts ...changehistoryOption) *ChangeHistoryMutation {
	m := &ChangeHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeChangeHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withChangeHistoryID sets the ID field of the mutation.
func withChangeHistoryID(id pulid.ID) changehistoryOption {
	return func(m *ChangeHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ChangeHistory
		)
		m.oldValue = func(ctx context.Context) (*ChangeHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ChangeHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withChangeHistory sets the old ChangeHistory of the mutation.
func withChangeHistory(node *ChangeHistory) changehistoryOption {
	return func(m *ChangeHistoryMutation) {
		m.oldValue = func(context.Context) (*ChangeHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ChangeHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ChangeHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ChangeHistory entities.
func (m *ChangeHistoryMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ChangeHistoryMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ChangeHistoryMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ChangeHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ChangeHistoryMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ChangeHistoryMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ChangeHistory entity.
// If the ChangeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeHistoryMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ChangeHistoryMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ChangeHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ChangeHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ChangeHistory entity.
// If the ChangeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ChangeHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetOrigin sets the "origin" field.
func (m *ChangeHistoryMutation) SetOrigin(c changehistory.Origin) {
	m.origin = &c
}

// Origin returns the value of the "origin" field in the mutation.
func (m *ChangeHistoryMutation) Origin() (r changehistory.Origin, exists bool) {
	v := m.origin
	if v == nil {
		return
	}
	return *v, true
}

// OldOrigin returns the old "origin" field's value of the ChangeHistory entity.
// If the ChangeHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ChangeHistoryMutation) OldOrigin(ctx context.Context) (v changehistory.Origin, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrigin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrigin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrigin: %w", err)
	}
	return oldValue.Origin, nil
}

// ResetOrigin resets all changes to the "origin" field.
func (m *ChangeHistoryMutation) ResetOrigin() {
	m.origin = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ChangeHistoryMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[changehistory.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ChangeHistoryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ChangeHistoryMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ChangeHistoryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddPlanHistoryIDs adds the "plan_history" edge to the PlanHistory entity by ids.
func (m *ChangeHistoryMutation) AddPlanHistoryIDs(ids ...pulid.ID) {
	if m.plan_history == nil {
		m.plan_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.plan_history[ids[i]] = struct{}{}
	}
}

// ClearPlanHistory clears the "plan_history" edge to the PlanHistory entity.
func (m *ChangeHistoryMutation) ClearPlanHistory() {
	m.clearedplan_history = true
}

// PlanHistoryCleared reports if the "plan_history" edge to the PlanHistory entity was cleared.
func (m *ChangeHistoryMutation) PlanHistoryCleared() bool {
	return m.clearedplan_history
}

// RemovePlanHistoryIDs removes the "plan_history" edge to the PlanHistory entity by IDs.
func (m *ChangeHistoryMutation) RemovePlanHistoryIDs(ids ...pulid.ID) {
	if m.removedplan_history == nil {
		m.removedplan_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.plan_history, ids[i])
		m.removedplan_history[ids[i]] = struct{}{}
	}
}

// RemovedPlanHistory returns the removed IDs of the "plan_history" edge to the PlanHistory entity.
func (m *ChangeHistoryMutation) RemovedPlanHistoryIDs() (ids []pulid.ID) {
	for id := range m.removedplan_history {
		ids = append(ids, id)
	}
	return
}

// PlanHistoryIDs returns the "plan_history" edge IDs in the mutation.
func (m *ChangeHistoryMutation) PlanHistoryIDs() (ids []pulid.ID) {
	for id := range m.plan_history {
		ids = append(ids, id)
	}
	return
}

// ResetPlanHistory resets all changes to the "plan_history" edge.
func (m *ChangeHistoryMutation) ResetPlanHistory() {
	m.plan_history = nil
	m.clearedplan_history = false
	m.removedplan_history = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *ChangeHistoryMutation) SetUserID(id pulid.ID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *ChangeHistoryMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *ChangeHistoryMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *ChangeHistoryMutation) UserID() (id pulid.ID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *ChangeHistoryMutation) UserIDs() (ids []pulid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *ChangeHistoryMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddOrderHistoryIDs adds the "order_history" edge to the OrderHistory entity by ids.
func (m *ChangeHistoryMutation) AddOrderHistoryIDs(ids ...pulid.ID) {
	if m.order_history == nil {
		m.order_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.order_history[ids[i]] = struct{}{}
	}
}

// ClearOrderHistory clears the "order_history" edge to the OrderHistory entity.
func (m *ChangeHistoryMutation) ClearOrderHistory() {
	m.clearedorder_history = true
}

// OrderHistoryCleared reports if the "order_history" edge to the OrderHistory entity was cleared.
func (m *ChangeHistoryMutation) OrderHistoryCleared() bool {
	return m.clearedorder_history
}

// RemoveOrderHistoryIDs removes the "order_history" edge to the OrderHistory entity by IDs.
func (m *ChangeHistoryMutation) RemoveOrderHistoryIDs(ids ...pulid.ID) {
	if m.removedorder_history == nil {
		m.removedorder_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.order_history, ids[i])
		m.removedorder_history[ids[i]] = struct{}{}
	}
}

// RemovedOrderHistory returns the removed IDs of the "order_history" edge to the OrderHistory entity.
func (m *ChangeHistoryMutation) RemovedOrderHistoryIDs() (ids []pulid.ID) {
	for id := range m.removedorder_history {
		ids = append(ids, id)
	}
	return
}

// OrderHistoryIDs returns the "order_history" edge IDs in the mutation.
func (m *ChangeHistoryMutation) OrderHistoryIDs() (ids []pulid.ID) {
	for id := range m.order_history {
		ids = append(ids, id)
	}
	return
}

// ResetOrderHistory resets all changes to the "order_history" edge.
func (m *ChangeHistoryMutation) ResetOrderHistory() {
	m.order_history = nil
	m.clearedorder_history = false
	m.removedorder_history = nil
}

// AddShipmentHistoryIDs adds the "shipment_history" edge to the ShipmentHistory entity by ids.
func (m *ChangeHistoryMutation) AddShipmentHistoryIDs(ids ...pulid.ID) {
	if m.shipment_history == nil {
		m.shipment_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.shipment_history[ids[i]] = struct{}{}
	}
}

// ClearShipmentHistory clears the "shipment_history" edge to the ShipmentHistory entity.
func (m *ChangeHistoryMutation) ClearShipmentHistory() {
	m.clearedshipment_history = true
}

// ShipmentHistoryCleared reports if the "shipment_history" edge to the ShipmentHistory entity was cleared.
func (m *ChangeHistoryMutation) ShipmentHistoryCleared() bool {
	return m.clearedshipment_history
}

// RemoveShipmentHistoryIDs removes the "shipment_history" edge to the ShipmentHistory entity by IDs.
func (m *ChangeHistoryMutation) RemoveShipmentHistoryIDs(ids ...pulid.ID) {
	if m.removedshipment_history == nil {
		m.removedshipment_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.shipment_history, ids[i])
		m.removedshipment_history[ids[i]] = struct{}{}
	}
}

// RemovedShipmentHistory returns the removed IDs of the "shipment_history" edge to the ShipmentHistory entity.
func (m *ChangeHistoryMutation) RemovedShipmentHistoryIDs() (ids []pulid.ID) {
	for id := range m.removedshipment_history {
		ids = append(ids, id)
	}
	return
}

// ShipmentHistoryIDs returns the "shipment_history" edge IDs in the mutation.
func (m *ChangeHistoryMutation) ShipmentHistoryIDs() (ids []pulid.ID) {
	for id := range m.shipment_history {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentHistory resets all changes to the "shipment_history" edge.
func (m *ChangeHistoryMutation) ResetShipmentHistory() {
	m.shipment_history = nil
	m.clearedshipment_history = false
	m.removedshipment_history = nil
}

// AddReturnColliHistoryIDs adds the "return_colli_history" edge to the ReturnColliHistory entity by ids.
func (m *ChangeHistoryMutation) AddReturnColliHistoryIDs(ids ...pulid.ID) {
	if m.return_colli_history == nil {
		m.return_colli_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_colli_history[ids[i]] = struct{}{}
	}
}

// ClearReturnColliHistory clears the "return_colli_history" edge to the ReturnColliHistory entity.
func (m *ChangeHistoryMutation) ClearReturnColliHistory() {
	m.clearedreturn_colli_history = true
}

// ReturnColliHistoryCleared reports if the "return_colli_history" edge to the ReturnColliHistory entity was cleared.
func (m *ChangeHistoryMutation) ReturnColliHistoryCleared() bool {
	return m.clearedreturn_colli_history
}

// RemoveReturnColliHistoryIDs removes the "return_colli_history" edge to the ReturnColliHistory entity by IDs.
func (m *ChangeHistoryMutation) RemoveReturnColliHistoryIDs(ids ...pulid.ID) {
	if m.removedreturn_colli_history == nil {
		m.removedreturn_colli_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_colli_history, ids[i])
		m.removedreturn_colli_history[ids[i]] = struct{}{}
	}
}

// RemovedReturnColliHistory returns the removed IDs of the "return_colli_history" edge to the ReturnColliHistory entity.
func (m *ChangeHistoryMutation) RemovedReturnColliHistoryIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_colli_history {
		ids = append(ids, id)
	}
	return
}

// ReturnColliHistoryIDs returns the "return_colli_history" edge IDs in the mutation.
func (m *ChangeHistoryMutation) ReturnColliHistoryIDs() (ids []pulid.ID) {
	for id := range m.return_colli_history {
		ids = append(ids, id)
	}
	return
}

// ResetReturnColliHistory resets all changes to the "return_colli_history" edge.
func (m *ChangeHistoryMutation) ResetReturnColliHistory() {
	m.return_colli_history = nil
	m.clearedreturn_colli_history = false
	m.removedreturn_colli_history = nil
}

// Where appends a list predicates to the ChangeHistoryMutation builder.
func (m *ChangeHistoryMutation) Where(ps ...predicate.ChangeHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ChangeHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ChangeHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ChangeHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ChangeHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ChangeHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ChangeHistory).
func (m *ChangeHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ChangeHistoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, changehistory.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, changehistory.FieldCreatedAt)
	}
	if m.origin != nil {
		fields = append(fields, changehistory.FieldOrigin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ChangeHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case changehistory.FieldTenantID:
		return m.TenantID()
	case changehistory.FieldCreatedAt:
		return m.CreatedAt()
	case changehistory.FieldOrigin:
		return m.Origin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ChangeHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case changehistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case changehistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case changehistory.FieldOrigin:
		return m.OldOrigin(ctx)
	}
	return nil, fmt.Errorf("unknown ChangeHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangeHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case changehistory.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case changehistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case changehistory.FieldOrigin:
		v, ok := value.(changehistory.Origin)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrigin(v)
		return nil
	}
	return fmt.Errorf("unknown ChangeHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ChangeHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ChangeHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ChangeHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ChangeHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ChangeHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ChangeHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ChangeHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ChangeHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ChangeHistoryMutation) ResetField(name string) error {
	switch name {
	case changehistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case changehistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case changehistory.FieldOrigin:
		m.ResetOrigin()
		return nil
	}
	return fmt.Errorf("unknown ChangeHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ChangeHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.tenant != nil {
		edges = append(edges, changehistory.EdgeTenant)
	}
	if m.plan_history != nil {
		edges = append(edges, changehistory.EdgePlanHistory)
	}
	if m.user != nil {
		edges = append(edges, changehistory.EdgeUser)
	}
	if m.order_history != nil {
		edges = append(edges, changehistory.EdgeOrderHistory)
	}
	if m.shipment_history != nil {
		edges = append(edges, changehistory.EdgeShipmentHistory)
	}
	if m.return_colli_history != nil {
		edges = append(edges, changehistory.EdgeReturnColliHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ChangeHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case changehistory.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case changehistory.EdgePlanHistory:
		ids := make([]ent.Value, 0, len(m.plan_history))
		for id := range m.plan_history {
			ids = append(ids, id)
		}
		return ids
	case changehistory.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case changehistory.EdgeOrderHistory:
		ids := make([]ent.Value, 0, len(m.order_history))
		for id := range m.order_history {
			ids = append(ids, id)
		}
		return ids
	case changehistory.EdgeShipmentHistory:
		ids := make([]ent.Value, 0, len(m.shipment_history))
		for id := range m.shipment_history {
			ids = append(ids, id)
		}
		return ids
	case changehistory.EdgeReturnColliHistory:
		ids := make([]ent.Value, 0, len(m.return_colli_history))
		for id := range m.return_colli_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ChangeHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedplan_history != nil {
		edges = append(edges, changehistory.EdgePlanHistory)
	}
	if m.removedorder_history != nil {
		edges = append(edges, changehistory.EdgeOrderHistory)
	}
	if m.removedshipment_history != nil {
		edges = append(edges, changehistory.EdgeShipmentHistory)
	}
	if m.removedreturn_colli_history != nil {
		edges = append(edges, changehistory.EdgeReturnColliHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ChangeHistoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case changehistory.EdgePlanHistory:
		ids := make([]ent.Value, 0, len(m.removedplan_history))
		for id := range m.removedplan_history {
			ids = append(ids, id)
		}
		return ids
	case changehistory.EdgeOrderHistory:
		ids := make([]ent.Value, 0, len(m.removedorder_history))
		for id := range m.removedorder_history {
			ids = append(ids, id)
		}
		return ids
	case changehistory.EdgeShipmentHistory:
		ids := make([]ent.Value, 0, len(m.removedshipment_history))
		for id := range m.removedshipment_history {
			ids = append(ids, id)
		}
		return ids
	case changehistory.EdgeReturnColliHistory:
		ids := make([]ent.Value, 0, len(m.removedreturn_colli_history))
		for id := range m.removedreturn_colli_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ChangeHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtenant {
		edges = append(edges, changehistory.EdgeTenant)
	}
	if m.clearedplan_history {
		edges = append(edges, changehistory.EdgePlanHistory)
	}
	if m.cleareduser {
		edges = append(edges, changehistory.EdgeUser)
	}
	if m.clearedorder_history {
		edges = append(edges, changehistory.EdgeOrderHistory)
	}
	if m.clearedshipment_history {
		edges = append(edges, changehistory.EdgeShipmentHistory)
	}
	if m.clearedreturn_colli_history {
		edges = append(edges, changehistory.EdgeReturnColliHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ChangeHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case changehistory.EdgeTenant:
		return m.clearedtenant
	case changehistory.EdgePlanHistory:
		return m.clearedplan_history
	case changehistory.EdgeUser:
		return m.cleareduser
	case changehistory.EdgeOrderHistory:
		return m.clearedorder_history
	case changehistory.EdgeShipmentHistory:
		return m.clearedshipment_history
	case changehistory.EdgeReturnColliHistory:
		return m.clearedreturn_colli_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ChangeHistoryMutation) ClearEdge(name string) error {
	switch name {
	case changehistory.EdgeTenant:
		m.ClearTenant()
		return nil
	case changehistory.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown ChangeHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ChangeHistoryMutation) ResetEdge(name string) error {
	switch name {
	case changehistory.EdgeTenant:
		m.ResetTenant()
		return nil
	case changehistory.EdgePlanHistory:
		m.ResetPlanHistory()
		return nil
	case changehistory.EdgeUser:
		m.ResetUser()
		return nil
	case changehistory.EdgeOrderHistory:
		m.ResetOrderHistory()
		return nil
	case changehistory.EdgeShipmentHistory:
		m.ResetShipmentHistory()
		return nil
	case changehistory.EdgeReturnColliHistory:
		m.ResetReturnColliHistory()
		return nil
	}
	return fmt.Errorf("unknown ChangeHistory edge %s", name)
}

// ColliMutation represents an operation that mutates the Colli nodes in the graph.
type ColliMutation struct {
	config
	op                               Op
	typ                              string
	id                               *pulid.ID
	internal_barcode                 *int64
	addinternal_barcode              *int64
	status                           *colli.Status
	slip_print_status                *colli.SlipPrintStatus
	created_at                       *time.Time
	email_packing_slip_printed_at    *time.Time
	email_label_printed_at           *time.Time
	clearedFields                    map[string]struct{}
	tenant                           *pulid.ID
	clearedtenant                    bool
	recipient                        *pulid.ID
	clearedrecipient                 bool
	sender                           *pulid.ID
	clearedsender                    bool
	parcel_shop                      *pulid.ID
	clearedparcel_shop               bool
	click_collect_location           *pulid.ID
	clearedclick_collect_location    bool
	order_lines                      map[pulid.ID]struct{}
	removedorder_lines               map[pulid.ID]struct{}
	clearedorder_lines               bool
	delivery_option                  *pulid.ID
	cleareddelivery_option           bool
	document_file                    map[pulid.ID]struct{}
	removeddocument_file             map[pulid.ID]struct{}
	cleareddocument_file             bool
	shipment_parcel                  *pulid.ID
	clearedshipment_parcel           bool
	cancelled_shipment_parcel        map[pulid.ID]struct{}
	removedcancelled_shipment_parcel map[pulid.ID]struct{}
	clearedcancelled_shipment_parcel bool
	_order                           *pulid.ID
	cleared_order                    bool
	packaging                        *pulid.ID
	clearedpackaging                 bool
	print_job                        map[pulid.ID]struct{}
	removedprint_job                 map[pulid.ID]struct{}
	clearedprint_job                 bool
	done                             bool
	oldValue                         func(context.Context) (*Colli, error)
	predicates                       []predicate.Colli
}

var _ ent.Mutation = (*ColliMutation)(nil)

// colliOption allows management of the mutation configuration using functional options.
type colliOption func(*ColliMutation)

// newColliMutation creates new mutation for the Colli entity.
func newColliMutation(c config, op Op, opts ...colliOption) *ColliMutation {
	m := &ColliMutation{
		config:        c,
		op:            op,
		typ:           TypeColli,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withColliID sets the ID field of the mutation.
func withColliID(id pulid.ID) colliOption {
	return func(m *ColliMutation) {
		var (
			err   error
			once  sync.Once
			value *Colli
		)
		m.oldValue = func(ctx context.Context) (*Colli, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Colli.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withColli sets the old Colli of the mutation.
func withColli(node *Colli) colliOption {
	return func(m *ColliMutation) {
		m.oldValue = func(context.Context) (*Colli, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ColliMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ColliMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Colli entities.
func (m *ColliMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ColliMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ColliMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Colli.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ColliMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ColliMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Colli entity.
// If the Colli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColliMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ColliMutation) ResetTenantID() {
	m.tenant = nil
}

// SetInternalBarcode sets the "internal_barcode" field.
func (m *ColliMutation) SetInternalBarcode(i int64) {
	m.internal_barcode = &i
	m.addinternal_barcode = nil
}

// InternalBarcode returns the value of the "internal_barcode" field in the mutation.
func (m *ColliMutation) InternalBarcode() (r int64, exists bool) {
	v := m.internal_barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalBarcode returns the old "internal_barcode" field's value of the Colli entity.
// If the Colli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColliMutation) OldInternalBarcode(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalBarcode: %w", err)
	}
	return oldValue.InternalBarcode, nil
}

// AddInternalBarcode adds i to the "internal_barcode" field.
func (m *ColliMutation) AddInternalBarcode(i int64) {
	if m.addinternal_barcode != nil {
		*m.addinternal_barcode += i
	} else {
		m.addinternal_barcode = &i
	}
}

// AddedInternalBarcode returns the value that was added to the "internal_barcode" field in this mutation.
func (m *ColliMutation) AddedInternalBarcode() (r int64, exists bool) {
	v := m.addinternal_barcode
	if v == nil {
		return
	}
	return *v, true
}

// ClearInternalBarcode clears the value of the "internal_barcode" field.
func (m *ColliMutation) ClearInternalBarcode() {
	m.internal_barcode = nil
	m.addinternal_barcode = nil
	m.clearedFields[colli.FieldInternalBarcode] = struct{}{}
}

// InternalBarcodeCleared returns if the "internal_barcode" field was cleared in this mutation.
func (m *ColliMutation) InternalBarcodeCleared() bool {
	_, ok := m.clearedFields[colli.FieldInternalBarcode]
	return ok
}

// ResetInternalBarcode resets all changes to the "internal_barcode" field.
func (m *ColliMutation) ResetInternalBarcode() {
	m.internal_barcode = nil
	m.addinternal_barcode = nil
	delete(m.clearedFields, colli.FieldInternalBarcode)
}

// SetStatus sets the "status" field.
func (m *ColliMutation) SetStatus(c colli.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ColliMutation) Status() (r colli.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Colli entity.
// If the Colli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColliMutation) OldStatus(ctx context.Context) (v colli.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ColliMutation) ResetStatus() {
	m.status = nil
}

// SetSlipPrintStatus sets the "slip_print_status" field.
func (m *ColliMutation) SetSlipPrintStatus(cps colli.SlipPrintStatus) {
	m.slip_print_status = &cps
}

// SlipPrintStatus returns the value of the "slip_print_status" field in the mutation.
func (m *ColliMutation) SlipPrintStatus() (r colli.SlipPrintStatus, exists bool) {
	v := m.slip_print_status
	if v == nil {
		return
	}
	return *v, true
}

// OldSlipPrintStatus returns the old "slip_print_status" field's value of the Colli entity.
// If the Colli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColliMutation) OldSlipPrintStatus(ctx context.Context) (v colli.SlipPrintStatus, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlipPrintStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlipPrintStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlipPrintStatus: %w", err)
	}
	return oldValue.SlipPrintStatus, nil
}

// ResetSlipPrintStatus resets all changes to the "slip_print_status" field.
func (m *ColliMutation) ResetSlipPrintStatus() {
	m.slip_print_status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ColliMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ColliMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Colli entity.
// If the Colli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColliMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ColliMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEmailPackingSlipPrintedAt sets the "email_packing_slip_printed_at" field.
func (m *ColliMutation) SetEmailPackingSlipPrintedAt(t time.Time) {
	m.email_packing_slip_printed_at = &t
}

// EmailPackingSlipPrintedAt returns the value of the "email_packing_slip_printed_at" field in the mutation.
func (m *ColliMutation) EmailPackingSlipPrintedAt() (r time.Time, exists bool) {
	v := m.email_packing_slip_printed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailPackingSlipPrintedAt returns the old "email_packing_slip_printed_at" field's value of the Colli entity.
// If the Colli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColliMutation) OldEmailPackingSlipPrintedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailPackingSlipPrintedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailPackingSlipPrintedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailPackingSlipPrintedAt: %w", err)
	}
	return oldValue.EmailPackingSlipPrintedAt, nil
}

// ClearEmailPackingSlipPrintedAt clears the value of the "email_packing_slip_printed_at" field.
func (m *ColliMutation) ClearEmailPackingSlipPrintedAt() {
	m.email_packing_slip_printed_at = nil
	m.clearedFields[colli.FieldEmailPackingSlipPrintedAt] = struct{}{}
}

// EmailPackingSlipPrintedAtCleared returns if the "email_packing_slip_printed_at" field was cleared in this mutation.
func (m *ColliMutation) EmailPackingSlipPrintedAtCleared() bool {
	_, ok := m.clearedFields[colli.FieldEmailPackingSlipPrintedAt]
	return ok
}

// ResetEmailPackingSlipPrintedAt resets all changes to the "email_packing_slip_printed_at" field.
func (m *ColliMutation) ResetEmailPackingSlipPrintedAt() {
	m.email_packing_slip_printed_at = nil
	delete(m.clearedFields, colli.FieldEmailPackingSlipPrintedAt)
}

// SetEmailLabelPrintedAt sets the "email_label_printed_at" field.
func (m *ColliMutation) SetEmailLabelPrintedAt(t time.Time) {
	m.email_label_printed_at = &t
}

// EmailLabelPrintedAt returns the value of the "email_label_printed_at" field in the mutation.
func (m *ColliMutation) EmailLabelPrintedAt() (r time.Time, exists bool) {
	v := m.email_label_printed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailLabelPrintedAt returns the old "email_label_printed_at" field's value of the Colli entity.
// If the Colli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ColliMutation) OldEmailLabelPrintedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailLabelPrintedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailLabelPrintedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailLabelPrintedAt: %w", err)
	}
	return oldValue.EmailLabelPrintedAt, nil
}

// ClearEmailLabelPrintedAt clears the value of the "email_label_printed_at" field.
func (m *ColliMutation) ClearEmailLabelPrintedAt() {
	m.email_label_printed_at = nil
	m.clearedFields[colli.FieldEmailLabelPrintedAt] = struct{}{}
}

// EmailLabelPrintedAtCleared returns if the "email_label_printed_at" field was cleared in this mutation.
func (m *ColliMutation) EmailLabelPrintedAtCleared() bool {
	_, ok := m.clearedFields[colli.FieldEmailLabelPrintedAt]
	return ok
}

// ResetEmailLabelPrintedAt resets all changes to the "email_label_printed_at" field.
func (m *ColliMutation) ResetEmailLabelPrintedAt() {
	m.email_label_printed_at = nil
	delete(m.clearedFields, colli.FieldEmailLabelPrintedAt)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ColliMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[colli.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ColliMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ColliMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ColliMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetRecipientID sets the "recipient" edge to the Address entity by id.
func (m *ColliMutation) SetRecipientID(id pulid.ID) {
	m.recipient = &id
}

// ClearRecipient clears the "recipient" edge to the Address entity.
func (m *ColliMutation) ClearRecipient() {
	m.clearedrecipient = true
}

// RecipientCleared reports if the "recipient" edge to the Address entity was cleared.
func (m *ColliMutation) RecipientCleared() bool {
	return m.clearedrecipient
}

// RecipientID returns the "recipient" edge ID in the mutation.
func (m *ColliMutation) RecipientID() (id pulid.ID, exists bool) {
	if m.recipient != nil {
		return *m.recipient, true
	}
	return
}

// RecipientIDs returns the "recipient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecipientID instead. It exists only for internal usage by the builders.
func (m *ColliMutation) RecipientIDs() (ids []pulid.ID) {
	if id := m.recipient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecipient resets all changes to the "recipient" edge.
func (m *ColliMutation) ResetRecipient() {
	m.recipient = nil
	m.clearedrecipient = false
}

// SetSenderID sets the "sender" edge to the Address entity by id.
func (m *ColliMutation) SetSenderID(id pulid.ID) {
	m.sender = &id
}

// ClearSender clears the "sender" edge to the Address entity.
func (m *ColliMutation) ClearSender() {
	m.clearedsender = true
}

// SenderCleared reports if the "sender" edge to the Address entity was cleared.
func (m *ColliMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderID returns the "sender" edge ID in the mutation.
func (m *ColliMutation) SenderID() (id pulid.ID, exists bool) {
	if m.sender != nil {
		return *m.sender, true
	}
	return
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *ColliMutation) SenderIDs() (ids []pulid.ID) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *ColliMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// SetParcelShopID sets the "parcel_shop" edge to the ParcelShop entity by id.
func (m *ColliMutation) SetParcelShopID(id pulid.ID) {
	m.parcel_shop = &id
}

// ClearParcelShop clears the "parcel_shop" edge to the ParcelShop entity.
func (m *ColliMutation) ClearParcelShop() {
	m.clearedparcel_shop = true
}

// ParcelShopCleared reports if the "parcel_shop" edge to the ParcelShop entity was cleared.
func (m *ColliMutation) ParcelShopCleared() bool {
	return m.clearedparcel_shop
}

// ParcelShopID returns the "parcel_shop" edge ID in the mutation.
func (m *ColliMutation) ParcelShopID() (id pulid.ID, exists bool) {
	if m.parcel_shop != nil {
		return *m.parcel_shop, true
	}
	return
}

// ParcelShopIDs returns the "parcel_shop" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopID instead. It exists only for internal usage by the builders.
func (m *ColliMutation) ParcelShopIDs() (ids []pulid.ID) {
	if id := m.parcel_shop; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShop resets all changes to the "parcel_shop" edge.
func (m *ColliMutation) ResetParcelShop() {
	m.parcel_shop = nil
	m.clearedparcel_shop = false
}

// SetClickCollectLocationID sets the "click_collect_location" edge to the Location entity by id.
func (m *ColliMutation) SetClickCollectLocationID(id pulid.ID) {
	m.click_collect_location = &id
}

// ClearClickCollectLocation clears the "click_collect_location" edge to the Location entity.
func (m *ColliMutation) ClearClickCollectLocation() {
	m.clearedclick_collect_location = true
}

// ClickCollectLocationCleared reports if the "click_collect_location" edge to the Location entity was cleared.
func (m *ColliMutation) ClickCollectLocationCleared() bool {
	return m.clearedclick_collect_location
}

// ClickCollectLocationID returns the "click_collect_location" edge ID in the mutation.
func (m *ColliMutation) ClickCollectLocationID() (id pulid.ID, exists bool) {
	if m.click_collect_location != nil {
		return *m.click_collect_location, true
	}
	return
}

// ClickCollectLocationIDs returns the "click_collect_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClickCollectLocationID instead. It exists only for internal usage by the builders.
func (m *ColliMutation) ClickCollectLocationIDs() (ids []pulid.ID) {
	if id := m.click_collect_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClickCollectLocation resets all changes to the "click_collect_location" edge.
func (m *ColliMutation) ResetClickCollectLocation() {
	m.click_collect_location = nil
	m.clearedclick_collect_location = false
}

// AddOrderLineIDs adds the "order_lines" edge to the OrderLine entity by ids.
func (m *ColliMutation) AddOrderLineIDs(ids ...pulid.ID) {
	if m.order_lines == nil {
		m.order_lines = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.order_lines[ids[i]] = struct{}{}
	}
}

// ClearOrderLines clears the "order_lines" edge to the OrderLine entity.
func (m *ColliMutation) ClearOrderLines() {
	m.clearedorder_lines = true
}

// OrderLinesCleared reports if the "order_lines" edge to the OrderLine entity was cleared.
func (m *ColliMutation) OrderLinesCleared() bool {
	return m.clearedorder_lines
}

// RemoveOrderLineIDs removes the "order_lines" edge to the OrderLine entity by IDs.
func (m *ColliMutation) RemoveOrderLineIDs(ids ...pulid.ID) {
	if m.removedorder_lines == nil {
		m.removedorder_lines = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.order_lines, ids[i])
		m.removedorder_lines[ids[i]] = struct{}{}
	}
}

// RemovedOrderLines returns the removed IDs of the "order_lines" edge to the OrderLine entity.
func (m *ColliMutation) RemovedOrderLinesIDs() (ids []pulid.ID) {
	for id := range m.removedorder_lines {
		ids = append(ids, id)
	}
	return
}

// OrderLinesIDs returns the "order_lines" edge IDs in the mutation.
func (m *ColliMutation) OrderLinesIDs() (ids []pulid.ID) {
	for id := range m.order_lines {
		ids = append(ids, id)
	}
	return
}

// ResetOrderLines resets all changes to the "order_lines" edge.
func (m *ColliMutation) ResetOrderLines() {
	m.order_lines = nil
	m.clearedorder_lines = false
	m.removedorder_lines = nil
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *ColliMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *ColliMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *ColliMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *ColliMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *ColliMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *ColliMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// AddDocumentFileIDs adds the "document_file" edge to the DocumentFile entity by ids.
func (m *ColliMutation) AddDocumentFileIDs(ids ...pulid.ID) {
	if m.document_file == nil {
		m.document_file = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.document_file[ids[i]] = struct{}{}
	}
}

// ClearDocumentFile clears the "document_file" edge to the DocumentFile entity.
func (m *ColliMutation) ClearDocumentFile() {
	m.cleareddocument_file = true
}

// DocumentFileCleared reports if the "document_file" edge to the DocumentFile entity was cleared.
func (m *ColliMutation) DocumentFileCleared() bool {
	return m.cleareddocument_file
}

// RemoveDocumentFileIDs removes the "document_file" edge to the DocumentFile entity by IDs.
func (m *ColliMutation) RemoveDocumentFileIDs(ids ...pulid.ID) {
	if m.removeddocument_file == nil {
		m.removeddocument_file = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.document_file, ids[i])
		m.removeddocument_file[ids[i]] = struct{}{}
	}
}

// RemovedDocumentFile returns the removed IDs of the "document_file" edge to the DocumentFile entity.
func (m *ColliMutation) RemovedDocumentFileIDs() (ids []pulid.ID) {
	for id := range m.removeddocument_file {
		ids = append(ids, id)
	}
	return
}

// DocumentFileIDs returns the "document_file" edge IDs in the mutation.
func (m *ColliMutation) DocumentFileIDs() (ids []pulid.ID) {
	for id := range m.document_file {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentFile resets all changes to the "document_file" edge.
func (m *ColliMutation) ResetDocumentFile() {
	m.document_file = nil
	m.cleareddocument_file = false
	m.removeddocument_file = nil
}

// SetShipmentParcelID sets the "shipment_parcel" edge to the ShipmentParcel entity by id.
func (m *ColliMutation) SetShipmentParcelID(id pulid.ID) {
	m.shipment_parcel = &id
}

// ClearShipmentParcel clears the "shipment_parcel" edge to the ShipmentParcel entity.
func (m *ColliMutation) ClearShipmentParcel() {
	m.clearedshipment_parcel = true
}

// ShipmentParcelCleared reports if the "shipment_parcel" edge to the ShipmentParcel entity was cleared.
func (m *ColliMutation) ShipmentParcelCleared() bool {
	return m.clearedshipment_parcel
}

// ShipmentParcelID returns the "shipment_parcel" edge ID in the mutation.
func (m *ColliMutation) ShipmentParcelID() (id pulid.ID, exists bool) {
	if m.shipment_parcel != nil {
		return *m.shipment_parcel, true
	}
	return
}

// ShipmentParcelIDs returns the "shipment_parcel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentParcelID instead. It exists only for internal usage by the builders.
func (m *ColliMutation) ShipmentParcelIDs() (ids []pulid.ID) {
	if id := m.shipment_parcel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentParcel resets all changes to the "shipment_parcel" edge.
func (m *ColliMutation) ResetShipmentParcel() {
	m.shipment_parcel = nil
	m.clearedshipment_parcel = false
}

// AddCancelledShipmentParcelIDs adds the "cancelled_shipment_parcel" edge to the ShipmentParcel entity by ids.
func (m *ColliMutation) AddCancelledShipmentParcelIDs(ids ...pulid.ID) {
	if m.cancelled_shipment_parcel == nil {
		m.cancelled_shipment_parcel = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.cancelled_shipment_parcel[ids[i]] = struct{}{}
	}
}

// ClearCancelledShipmentParcel clears the "cancelled_shipment_parcel" edge to the ShipmentParcel entity.
func (m *ColliMutation) ClearCancelledShipmentParcel() {
	m.clearedcancelled_shipment_parcel = true
}

// CancelledShipmentParcelCleared reports if the "cancelled_shipment_parcel" edge to the ShipmentParcel entity was cleared.
func (m *ColliMutation) CancelledShipmentParcelCleared() bool {
	return m.clearedcancelled_shipment_parcel
}

// RemoveCancelledShipmentParcelIDs removes the "cancelled_shipment_parcel" edge to the ShipmentParcel entity by IDs.
func (m *ColliMutation) RemoveCancelledShipmentParcelIDs(ids ...pulid.ID) {
	if m.removedcancelled_shipment_parcel == nil {
		m.removedcancelled_shipment_parcel = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.cancelled_shipment_parcel, ids[i])
		m.removedcancelled_shipment_parcel[ids[i]] = struct{}{}
	}
}

// RemovedCancelledShipmentParcel returns the removed IDs of the "cancelled_shipment_parcel" edge to the ShipmentParcel entity.
func (m *ColliMutation) RemovedCancelledShipmentParcelIDs() (ids []pulid.ID) {
	for id := range m.removedcancelled_shipment_parcel {
		ids = append(ids, id)
	}
	return
}

// CancelledShipmentParcelIDs returns the "cancelled_shipment_parcel" edge IDs in the mutation.
func (m *ColliMutation) CancelledShipmentParcelIDs() (ids []pulid.ID) {
	for id := range m.cancelled_shipment_parcel {
		ids = append(ids, id)
	}
	return
}

// ResetCancelledShipmentParcel resets all changes to the "cancelled_shipment_parcel" edge.
func (m *ColliMutation) ResetCancelledShipmentParcel() {
	m.cancelled_shipment_parcel = nil
	m.clearedcancelled_shipment_parcel = false
	m.removedcancelled_shipment_parcel = nil
}

// SetOrderID sets the "order" edge to the Order entity by id.
func (m *ColliMutation) SetOrderID(id pulid.ID) {
	m._order = &id
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *ColliMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *ColliMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderID returns the "order" edge ID in the mutation.
func (m *ColliMutation) OrderID() (id pulid.ID, exists bool) {
	if m._order != nil {
		return *m._order, true
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *ColliMutation) OrderIDs() (ids []pulid.ID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *ColliMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// SetPackagingID sets the "packaging" edge to the Packaging entity by id.
func (m *ColliMutation) SetPackagingID(id pulid.ID) {
	m.packaging = &id
}

// ClearPackaging clears the "packaging" edge to the Packaging entity.
func (m *ColliMutation) ClearPackaging() {
	m.clearedpackaging = true
}

// PackagingCleared reports if the "packaging" edge to the Packaging entity was cleared.
func (m *ColliMutation) PackagingCleared() bool {
	return m.clearedpackaging
}

// PackagingID returns the "packaging" edge ID in the mutation.
func (m *ColliMutation) PackagingID() (id pulid.ID, exists bool) {
	if m.packaging != nil {
		return *m.packaging, true
	}
	return
}

// PackagingIDs returns the "packaging" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackagingID instead. It exists only for internal usage by the builders.
func (m *ColliMutation) PackagingIDs() (ids []pulid.ID) {
	if id := m.packaging; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackaging resets all changes to the "packaging" edge.
func (m *ColliMutation) ResetPackaging() {
	m.packaging = nil
	m.clearedpackaging = false
}

// AddPrintJobIDs adds the "print_job" edge to the PrintJob entity by ids.
func (m *ColliMutation) AddPrintJobIDs(ids ...pulid.ID) {
	if m.print_job == nil {
		m.print_job = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.print_job[ids[i]] = struct{}{}
	}
}

// ClearPrintJob clears the "print_job" edge to the PrintJob entity.
func (m *ColliMutation) ClearPrintJob() {
	m.clearedprint_job = true
}

// PrintJobCleared reports if the "print_job" edge to the PrintJob entity was cleared.
func (m *ColliMutation) PrintJobCleared() bool {
	return m.clearedprint_job
}

// RemovePrintJobIDs removes the "print_job" edge to the PrintJob entity by IDs.
func (m *ColliMutation) RemovePrintJobIDs(ids ...pulid.ID) {
	if m.removedprint_job == nil {
		m.removedprint_job = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.print_job, ids[i])
		m.removedprint_job[ids[i]] = struct{}{}
	}
}

// RemovedPrintJob returns the removed IDs of the "print_job" edge to the PrintJob entity.
func (m *ColliMutation) RemovedPrintJobIDs() (ids []pulid.ID) {
	for id := range m.removedprint_job {
		ids = append(ids, id)
	}
	return
}

// PrintJobIDs returns the "print_job" edge IDs in the mutation.
func (m *ColliMutation) PrintJobIDs() (ids []pulid.ID) {
	for id := range m.print_job {
		ids = append(ids, id)
	}
	return
}

// ResetPrintJob resets all changes to the "print_job" edge.
func (m *ColliMutation) ResetPrintJob() {
	m.print_job = nil
	m.clearedprint_job = false
	m.removedprint_job = nil
}

// Where appends a list predicates to the ColliMutation builder.
func (m *ColliMutation) Where(ps ...predicate.Colli) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ColliMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ColliMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Colli, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ColliMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ColliMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Colli).
func (m *ColliMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ColliMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, colli.FieldTenantID)
	}
	if m.internal_barcode != nil {
		fields = append(fields, colli.FieldInternalBarcode)
	}
	if m.status != nil {
		fields = append(fields, colli.FieldStatus)
	}
	if m.slip_print_status != nil {
		fields = append(fields, colli.FieldSlipPrintStatus)
	}
	if m.created_at != nil {
		fields = append(fields, colli.FieldCreatedAt)
	}
	if m.email_packing_slip_printed_at != nil {
		fields = append(fields, colli.FieldEmailPackingSlipPrintedAt)
	}
	if m.email_label_printed_at != nil {
		fields = append(fields, colli.FieldEmailLabelPrintedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ColliMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case colli.FieldTenantID:
		return m.TenantID()
	case colli.FieldInternalBarcode:
		return m.InternalBarcode()
	case colli.FieldStatus:
		return m.Status()
	case colli.FieldSlipPrintStatus:
		return m.SlipPrintStatus()
	case colli.FieldCreatedAt:
		return m.CreatedAt()
	case colli.FieldEmailPackingSlipPrintedAt:
		return m.EmailPackingSlipPrintedAt()
	case colli.FieldEmailLabelPrintedAt:
		return m.EmailLabelPrintedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ColliMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case colli.FieldTenantID:
		return m.OldTenantID(ctx)
	case colli.FieldInternalBarcode:
		return m.OldInternalBarcode(ctx)
	case colli.FieldStatus:
		return m.OldStatus(ctx)
	case colli.FieldSlipPrintStatus:
		return m.OldSlipPrintStatus(ctx)
	case colli.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case colli.FieldEmailPackingSlipPrintedAt:
		return m.OldEmailPackingSlipPrintedAt(ctx)
	case colli.FieldEmailLabelPrintedAt:
		return m.OldEmailLabelPrintedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Colli field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ColliMutation) SetField(name string, value ent.Value) error {
	switch name {
	case colli.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case colli.FieldInternalBarcode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalBarcode(v)
		return nil
	case colli.FieldStatus:
		v, ok := value.(colli.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case colli.FieldSlipPrintStatus:
		v, ok := value.(colli.SlipPrintStatus)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlipPrintStatus(v)
		return nil
	case colli.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case colli.FieldEmailPackingSlipPrintedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailPackingSlipPrintedAt(v)
		return nil
	case colli.FieldEmailLabelPrintedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailLabelPrintedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Colli field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ColliMutation) AddedFields() []string {
	var fields []string
	if m.addinternal_barcode != nil {
		fields = append(fields, colli.FieldInternalBarcode)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ColliMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case colli.FieldInternalBarcode:
		return m.AddedInternalBarcode()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ColliMutation) AddField(name string, value ent.Value) error {
	switch name {
	case colli.FieldInternalBarcode:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddInternalBarcode(v)
		return nil
	}
	return fmt.Errorf("unknown Colli numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ColliMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(colli.FieldInternalBarcode) {
		fields = append(fields, colli.FieldInternalBarcode)
	}
	if m.FieldCleared(colli.FieldEmailPackingSlipPrintedAt) {
		fields = append(fields, colli.FieldEmailPackingSlipPrintedAt)
	}
	if m.FieldCleared(colli.FieldEmailLabelPrintedAt) {
		fields = append(fields, colli.FieldEmailLabelPrintedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ColliMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ColliMutation) ClearField(name string) error {
	switch name {
	case colli.FieldInternalBarcode:
		m.ClearInternalBarcode()
		return nil
	case colli.FieldEmailPackingSlipPrintedAt:
		m.ClearEmailPackingSlipPrintedAt()
		return nil
	case colli.FieldEmailLabelPrintedAt:
		m.ClearEmailLabelPrintedAt()
		return nil
	}
	return fmt.Errorf("unknown Colli nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ColliMutation) ResetField(name string) error {
	switch name {
	case colli.FieldTenantID:
		m.ResetTenantID()
		return nil
	case colli.FieldInternalBarcode:
		m.ResetInternalBarcode()
		return nil
	case colli.FieldStatus:
		m.ResetStatus()
		return nil
	case colli.FieldSlipPrintStatus:
		m.ResetSlipPrintStatus()
		return nil
	case colli.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case colli.FieldEmailPackingSlipPrintedAt:
		m.ResetEmailPackingSlipPrintedAt()
		return nil
	case colli.FieldEmailLabelPrintedAt:
		m.ResetEmailLabelPrintedAt()
		return nil
	}
	return fmt.Errorf("unknown Colli field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ColliMutation) AddedEdges() []string {
	edges := make([]string, 0, 13)
	if m.tenant != nil {
		edges = append(edges, colli.EdgeTenant)
	}
	if m.recipient != nil {
		edges = append(edges, colli.EdgeRecipient)
	}
	if m.sender != nil {
		edges = append(edges, colli.EdgeSender)
	}
	if m.parcel_shop != nil {
		edges = append(edges, colli.EdgeParcelShop)
	}
	if m.click_collect_location != nil {
		edges = append(edges, colli.EdgeClickCollectLocation)
	}
	if m.order_lines != nil {
		edges = append(edges, colli.EdgeOrderLines)
	}
	if m.delivery_option != nil {
		edges = append(edges, colli.EdgeDeliveryOption)
	}
	if m.document_file != nil {
		edges = append(edges, colli.EdgeDocumentFile)
	}
	if m.shipment_parcel != nil {
		edges = append(edges, colli.EdgeShipmentParcel)
	}
	if m.cancelled_shipment_parcel != nil {
		edges = append(edges, colli.EdgeCancelledShipmentParcel)
	}
	if m._order != nil {
		edges = append(edges, colli.EdgeOrder)
	}
	if m.packaging != nil {
		edges = append(edges, colli.EdgePackaging)
	}
	if m.print_job != nil {
		edges = append(edges, colli.EdgePrintJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ColliMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case colli.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case colli.EdgeRecipient:
		if id := m.recipient; id != nil {
			return []ent.Value{*id}
		}
	case colli.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	case colli.EdgeParcelShop:
		if id := m.parcel_shop; id != nil {
			return []ent.Value{*id}
		}
	case colli.EdgeClickCollectLocation:
		if id := m.click_collect_location; id != nil {
			return []ent.Value{*id}
		}
	case colli.EdgeOrderLines:
		ids := make([]ent.Value, 0, len(m.order_lines))
		for id := range m.order_lines {
			ids = append(ids, id)
		}
		return ids
	case colli.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case colli.EdgeDocumentFile:
		ids := make([]ent.Value, 0, len(m.document_file))
		for id := range m.document_file {
			ids = append(ids, id)
		}
		return ids
	case colli.EdgeShipmentParcel:
		if id := m.shipment_parcel; id != nil {
			return []ent.Value{*id}
		}
	case colli.EdgeCancelledShipmentParcel:
		ids := make([]ent.Value, 0, len(m.cancelled_shipment_parcel))
		for id := range m.cancelled_shipment_parcel {
			ids = append(ids, id)
		}
		return ids
	case colli.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case colli.EdgePackaging:
		if id := m.packaging; id != nil {
			return []ent.Value{*id}
		}
	case colli.EdgePrintJob:
		ids := make([]ent.Value, 0, len(m.print_job))
		for id := range m.print_job {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ColliMutation) RemovedEdges() []string {
	edges := make([]string, 0, 13)
	if m.removedorder_lines != nil {
		edges = append(edges, colli.EdgeOrderLines)
	}
	if m.removeddocument_file != nil {
		edges = append(edges, colli.EdgeDocumentFile)
	}
	if m.removedcancelled_shipment_parcel != nil {
		edges = append(edges, colli.EdgeCancelledShipmentParcel)
	}
	if m.removedprint_job != nil {
		edges = append(edges, colli.EdgePrintJob)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ColliMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case colli.EdgeOrderLines:
		ids := make([]ent.Value, 0, len(m.removedorder_lines))
		for id := range m.removedorder_lines {
			ids = append(ids, id)
		}
		return ids
	case colli.EdgeDocumentFile:
		ids := make([]ent.Value, 0, len(m.removeddocument_file))
		for id := range m.removeddocument_file {
			ids = append(ids, id)
		}
		return ids
	case colli.EdgeCancelledShipmentParcel:
		ids := make([]ent.Value, 0, len(m.removedcancelled_shipment_parcel))
		for id := range m.removedcancelled_shipment_parcel {
			ids = append(ids, id)
		}
		return ids
	case colli.EdgePrintJob:
		ids := make([]ent.Value, 0, len(m.removedprint_job))
		for id := range m.removedprint_job {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ColliMutation) ClearedEdges() []string {
	edges := make([]string, 0, 13)
	if m.clearedtenant {
		edges = append(edges, colli.EdgeTenant)
	}
	if m.clearedrecipient {
		edges = append(edges, colli.EdgeRecipient)
	}
	if m.clearedsender {
		edges = append(edges, colli.EdgeSender)
	}
	if m.clearedparcel_shop {
		edges = append(edges, colli.EdgeParcelShop)
	}
	if m.clearedclick_collect_location {
		edges = append(edges, colli.EdgeClickCollectLocation)
	}
	if m.clearedorder_lines {
		edges = append(edges, colli.EdgeOrderLines)
	}
	if m.cleareddelivery_option {
		edges = append(edges, colli.EdgeDeliveryOption)
	}
	if m.cleareddocument_file {
		edges = append(edges, colli.EdgeDocumentFile)
	}
	if m.clearedshipment_parcel {
		edges = append(edges, colli.EdgeShipmentParcel)
	}
	if m.clearedcancelled_shipment_parcel {
		edges = append(edges, colli.EdgeCancelledShipmentParcel)
	}
	if m.cleared_order {
		edges = append(edges, colli.EdgeOrder)
	}
	if m.clearedpackaging {
		edges = append(edges, colli.EdgePackaging)
	}
	if m.clearedprint_job {
		edges = append(edges, colli.EdgePrintJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ColliMutation) EdgeCleared(name string) bool {
	switch name {
	case colli.EdgeTenant:
		return m.clearedtenant
	case colli.EdgeRecipient:
		return m.clearedrecipient
	case colli.EdgeSender:
		return m.clearedsender
	case colli.EdgeParcelShop:
		return m.clearedparcel_shop
	case colli.EdgeClickCollectLocation:
		return m.clearedclick_collect_location
	case colli.EdgeOrderLines:
		return m.clearedorder_lines
	case colli.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case colli.EdgeDocumentFile:
		return m.cleareddocument_file
	case colli.EdgeShipmentParcel:
		return m.clearedshipment_parcel
	case colli.EdgeCancelledShipmentParcel:
		return m.clearedcancelled_shipment_parcel
	case colli.EdgeOrder:
		return m.cleared_order
	case colli.EdgePackaging:
		return m.clearedpackaging
	case colli.EdgePrintJob:
		return m.clearedprint_job
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ColliMutation) ClearEdge(name string) error {
	switch name {
	case colli.EdgeTenant:
		m.ClearTenant()
		return nil
	case colli.EdgeRecipient:
		m.ClearRecipient()
		return nil
	case colli.EdgeSender:
		m.ClearSender()
		return nil
	case colli.EdgeParcelShop:
		m.ClearParcelShop()
		return nil
	case colli.EdgeClickCollectLocation:
		m.ClearClickCollectLocation()
		return nil
	case colli.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	case colli.EdgeShipmentParcel:
		m.ClearShipmentParcel()
		return nil
	case colli.EdgeOrder:
		m.ClearOrder()
		return nil
	case colli.EdgePackaging:
		m.ClearPackaging()
		return nil
	}
	return fmt.Errorf("unknown Colli unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ColliMutation) ResetEdge(name string) error {
	switch name {
	case colli.EdgeTenant:
		m.ResetTenant()
		return nil
	case colli.EdgeRecipient:
		m.ResetRecipient()
		return nil
	case colli.EdgeSender:
		m.ResetSender()
		return nil
	case colli.EdgeParcelShop:
		m.ResetParcelShop()
		return nil
	case colli.EdgeClickCollectLocation:
		m.ResetClickCollectLocation()
		return nil
	case colli.EdgeOrderLines:
		m.ResetOrderLines()
		return nil
	case colli.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case colli.EdgeDocumentFile:
		m.ResetDocumentFile()
		return nil
	case colli.EdgeShipmentParcel:
		m.ResetShipmentParcel()
		return nil
	case colli.EdgeCancelledShipmentParcel:
		m.ResetCancelledShipmentParcel()
		return nil
	case colli.EdgeOrder:
		m.ResetOrder()
		return nil
	case colli.EdgePackaging:
		m.ResetPackaging()
		return nil
	case colli.EdgePrintJob:
		m.ResetPrintJob()
		return nil
	}
	return fmt.Errorf("unknown Colli edge %s", name)
}

// ConnectOptionCarrierMutation represents an operation that mutates the ConnectOptionCarrier nodes in the graph.
type ConnectOptionCarrierMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.ID
	name          *string
	clearedFields map[string]struct{}
	tenant        map[pulid.ID]struct{}
	removedtenant map[pulid.ID]struct{}
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*ConnectOptionCarrier, error)
	predicates    []predicate.ConnectOptionCarrier
}

var _ ent.Mutation = (*ConnectOptionCarrierMutation)(nil)

// connectoptioncarrierOption allows management of the mutation configuration using functional options.
type connectoptioncarrierOption func(*ConnectOptionCarrierMutation)

// newConnectOptionCarrierMutation creates new mutation for the ConnectOptionCarrier entity.
func newConnectOptionCarrierMutation(c config, op Op, opts ...connectoptioncarrierOption) *ConnectOptionCarrierMutation {
	m := &ConnectOptionCarrierMutation{
		config:        c,
		op:            op,
		typ:           TypeConnectOptionCarrier,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectOptionCarrierID sets the ID field of the mutation.
func withConnectOptionCarrierID(id pulid.ID) connectoptioncarrierOption {
	return func(m *ConnectOptionCarrierMutation) {
		var (
			err   error
			once  sync.Once
			value *ConnectOptionCarrier
		)
		m.oldValue = func(ctx context.Context) (*ConnectOptionCarrier, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConnectOptionCarrier.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnectOptionCarrier sets the old ConnectOptionCarrier of the mutation.
func withConnectOptionCarrier(node *ConnectOptionCarrier) connectoptioncarrierOption {
	return func(m *ConnectOptionCarrierMutation) {
		m.oldValue = func(context.Context) (*ConnectOptionCarrier, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectOptionCarrierMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectOptionCarrierMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConnectOptionCarrier entities.
func (m *ConnectOptionCarrierMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectOptionCarrierMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectOptionCarrierMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConnectOptionCarrier.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConnectOptionCarrierMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConnectOptionCarrierMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ConnectOptionCarrier entity.
// If the ConnectOptionCarrier object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectOptionCarrierMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConnectOptionCarrierMutation) ResetName() {
	m.name = nil
}

// AddTenantIDs adds the "tenant" edge to the Tenant entity by ids.
func (m *ConnectOptionCarrierMutation) AddTenantIDs(ids ...pulid.ID) {
	if m.tenant == nil {
		m.tenant = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.tenant[ids[i]] = struct{}{}
	}
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ConnectOptionCarrierMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ConnectOptionCarrierMutation) TenantCleared() bool {
	return m.clearedtenant
}

// RemoveTenantIDs removes the "tenant" edge to the Tenant entity by IDs.
func (m *ConnectOptionCarrierMutation) RemoveTenantIDs(ids ...pulid.ID) {
	if m.removedtenant == nil {
		m.removedtenant = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenant, ids[i])
		m.removedtenant[ids[i]] = struct{}{}
	}
}

// RemovedTenant returns the removed IDs of the "tenant" edge to the Tenant entity.
func (m *ConnectOptionCarrierMutation) RemovedTenantIDs() (ids []pulid.ID) {
	for id := range m.removedtenant {
		ids = append(ids, id)
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
func (m *ConnectOptionCarrierMutation) TenantIDs() (ids []pulid.ID) {
	for id := range m.tenant {
		ids = append(ids, id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ConnectOptionCarrierMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
	m.removedtenant = nil
}

// Where appends a list predicates to the ConnectOptionCarrierMutation builder.
func (m *ConnectOptionCarrierMutation) Where(ps ...predicate.ConnectOptionCarrier) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectOptionCarrierMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectOptionCarrierMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConnectOptionCarrier, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectOptionCarrierMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectOptionCarrierMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConnectOptionCarrier).
func (m *ConnectOptionCarrierMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectOptionCarrierMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, connectoptioncarrier.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectOptionCarrierMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connectoptioncarrier.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectOptionCarrierMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connectoptioncarrier.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ConnectOptionCarrier field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectOptionCarrierMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connectoptioncarrier.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ConnectOptionCarrier field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectOptionCarrierMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectOptionCarrierMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectOptionCarrierMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConnectOptionCarrier numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectOptionCarrierMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectOptionCarrierMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectOptionCarrierMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ConnectOptionCarrier nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectOptionCarrierMutation) ResetField(name string) error {
	switch name {
	case connectoptioncarrier.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ConnectOptionCarrier field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectOptionCarrierMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, connectoptioncarrier.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectOptionCarrierMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connectoptioncarrier.EdgeTenant:
		ids := make([]ent.Value, 0, len(m.tenant))
		for id := range m.tenant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectOptionCarrierMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtenant != nil {
		edges = append(edges, connectoptioncarrier.EdgeTenant)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectOptionCarrierMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connectoptioncarrier.EdgeTenant:
		ids := make([]ent.Value, 0, len(m.removedtenant))
		for id := range m.removedtenant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectOptionCarrierMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, connectoptioncarrier.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectOptionCarrierMutation) EdgeCleared(name string) bool {
	switch name {
	case connectoptioncarrier.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectOptionCarrierMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ConnectOptionCarrier unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectOptionCarrierMutation) ResetEdge(name string) error {
	switch name {
	case connectoptioncarrier.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown ConnectOptionCarrier edge %s", name)
}

// ConnectOptionPlatformMutation represents an operation that mutates the ConnectOptionPlatform nodes in the graph.
type ConnectOptionPlatformMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.ID
	name          *string
	clearedFields map[string]struct{}
	tenant        map[pulid.ID]struct{}
	removedtenant map[pulid.ID]struct{}
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*ConnectOptionPlatform, error)
	predicates    []predicate.ConnectOptionPlatform
}

var _ ent.Mutation = (*ConnectOptionPlatformMutation)(nil)

// connectoptionplatformOption allows management of the mutation configuration using functional options.
type connectoptionplatformOption func(*ConnectOptionPlatformMutation)

// newConnectOptionPlatformMutation creates new mutation for the ConnectOptionPlatform entity.
func newConnectOptionPlatformMutation(c config, op Op, opts ...connectoptionplatformOption) *ConnectOptionPlatformMutation {
	m := &ConnectOptionPlatformMutation{
		config:        c,
		op:            op,
		typ:           TypeConnectOptionPlatform,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectOptionPlatformID sets the ID field of the mutation.
func withConnectOptionPlatformID(id pulid.ID) connectoptionplatformOption {
	return func(m *ConnectOptionPlatformMutation) {
		var (
			err   error
			once  sync.Once
			value *ConnectOptionPlatform
		)
		m.oldValue = func(ctx context.Context) (*ConnectOptionPlatform, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConnectOptionPlatform.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnectOptionPlatform sets the old ConnectOptionPlatform of the mutation.
func withConnectOptionPlatform(node *ConnectOptionPlatform) connectoptionplatformOption {
	return func(m *ConnectOptionPlatformMutation) {
		m.oldValue = func(context.Context) (*ConnectOptionPlatform, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectOptionPlatformMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectOptionPlatformMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConnectOptionPlatform entities.
func (m *ConnectOptionPlatformMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectOptionPlatformMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectOptionPlatformMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConnectOptionPlatform.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ConnectOptionPlatformMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConnectOptionPlatformMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ConnectOptionPlatform entity.
// If the ConnectOptionPlatform object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectOptionPlatformMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConnectOptionPlatformMutation) ResetName() {
	m.name = nil
}

// AddTenantIDs adds the "tenant" edge to the Tenant entity by ids.
func (m *ConnectOptionPlatformMutation) AddTenantIDs(ids ...pulid.ID) {
	if m.tenant == nil {
		m.tenant = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.tenant[ids[i]] = struct{}{}
	}
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ConnectOptionPlatformMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ConnectOptionPlatformMutation) TenantCleared() bool {
	return m.clearedtenant
}

// RemoveTenantIDs removes the "tenant" edge to the Tenant entity by IDs.
func (m *ConnectOptionPlatformMutation) RemoveTenantIDs(ids ...pulid.ID) {
	if m.removedtenant == nil {
		m.removedtenant = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenant, ids[i])
		m.removedtenant[ids[i]] = struct{}{}
	}
}

// RemovedTenant returns the removed IDs of the "tenant" edge to the Tenant entity.
func (m *ConnectOptionPlatformMutation) RemovedTenantIDs() (ids []pulid.ID) {
	for id := range m.removedtenant {
		ids = append(ids, id)
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
func (m *ConnectOptionPlatformMutation) TenantIDs() (ids []pulid.ID) {
	for id := range m.tenant {
		ids = append(ids, id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ConnectOptionPlatformMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
	m.removedtenant = nil
}

// Where appends a list predicates to the ConnectOptionPlatformMutation builder.
func (m *ConnectOptionPlatformMutation) Where(ps ...predicate.ConnectOptionPlatform) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectOptionPlatformMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectOptionPlatformMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConnectOptionPlatform, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectOptionPlatformMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectOptionPlatformMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConnectOptionPlatform).
func (m *ConnectOptionPlatformMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectOptionPlatformMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, connectoptionplatform.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectOptionPlatformMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connectoptionplatform.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectOptionPlatformMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connectoptionplatform.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ConnectOptionPlatform field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectOptionPlatformMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connectoptionplatform.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ConnectOptionPlatform field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectOptionPlatformMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectOptionPlatformMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectOptionPlatformMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConnectOptionPlatform numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectOptionPlatformMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectOptionPlatformMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectOptionPlatformMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ConnectOptionPlatform nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectOptionPlatformMutation) ResetField(name string) error {
	switch name {
	case connectoptionplatform.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ConnectOptionPlatform field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectOptionPlatformMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, connectoptionplatform.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectOptionPlatformMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connectoptionplatform.EdgeTenant:
		ids := make([]ent.Value, 0, len(m.tenant))
		for id := range m.tenant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectOptionPlatformMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedtenant != nil {
		edges = append(edges, connectoptionplatform.EdgeTenant)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectOptionPlatformMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connectoptionplatform.EdgeTenant:
		ids := make([]ent.Value, 0, len(m.removedtenant))
		for id := range m.removedtenant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectOptionPlatformMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, connectoptionplatform.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectOptionPlatformMutation) EdgeCleared(name string) bool {
	switch name {
	case connectoptionplatform.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectOptionPlatformMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ConnectOptionPlatform unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectOptionPlatformMutation) ResetEdge(name string) error {
	switch name {
	case connectoptionplatform.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown ConnectOptionPlatform edge %s", name)
}

// ConnectionMutation represents an operation that mutates the Connection nodes in the graph.
type ConnectionMutation struct {
	config
	op                             Op
	typ                            string
	id                             *pulid.ID
	name                           *string
	sync_orders                    *bool
	sync_products                  *bool
	fulfill_automatically          *bool
	dispatch_automatically         *bool
	convert_currency               *bool
	auto_print_parcel_slip         *bool
	clearedFields                  map[string]struct{}
	tenant                         *pulid.ID
	clearedtenant                  bool
	connection_brand               *pulid.ID
	clearedconnection_brand        bool
	connection_shopify             *pulid.ID
	clearedconnection_shopify      bool
	orders                         map[pulid.ID]struct{}
	removedorders                  map[pulid.ID]struct{}
	clearedorders                  bool
	sender_location                *pulid.ID
	clearedsender_location         bool
	pickup_location                *pulid.ID
	clearedpickup_location         bool
	return_location                *pulid.ID
	clearedreturn_location         bool
	seller_location                *pulid.ID
	clearedseller_location         bool
	delivery_option                map[pulid.ID]struct{}
	removeddelivery_option         map[pulid.ID]struct{}
	cleareddelivery_option         bool
	default_delivery_option        *pulid.ID
	cleareddefault_delivery_option bool
	return_portal                  *pulid.ID
	clearedreturn_portal           bool
	hypothesis_test                map[pulid.ID]struct{}
	removedhypothesis_test         map[pulid.ID]struct{}
	clearedhypothesis_test         bool
	notifications                  map[pulid.ID]struct{}
	removednotifications           map[pulid.ID]struct{}
	clearednotifications           bool
	currency                       *pulid.ID
	clearedcurrency                bool
	packing_slip_template          *pulid.ID
	clearedpacking_slip_template   bool
	connection_lookup              map[pulid.ID]struct{}
	removedconnection_lookup       map[pulid.ID]struct{}
	clearedconnection_lookup       bool
	done                           bool
	oldValue                       func(context.Context) (*Connection, error)
	predicates                     []predicate.Connection
}

var _ ent.Mutation = (*ConnectionMutation)(nil)

// connectionOption allows management of the mutation configuration using functional options.
type connectionOption func(*ConnectionMutation)

// newConnectionMutation creates new mutation for the Connection entity.
func newConnectionMutation(c config, op Op, opts ...connectionOption) *ConnectionMutation {
	m := &ConnectionMutation{
		config:        c,
		op:            op,
		typ:           TypeConnection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectionID sets the ID field of the mutation.
func withConnectionID(id pulid.ID) connectionOption {
	return func(m *ConnectionMutation) {
		var (
			err   error
			once  sync.Once
			value *Connection
		)
		m.oldValue = func(ctx context.Context) (*Connection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Connection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnection sets the old Connection of the mutation.
func withConnection(node *Connection) connectionOption {
	return func(m *ConnectionMutation) {
		m.oldValue = func(context.Context) (*Connection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Connection entities.
func (m *ConnectionMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectionMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectionMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Connection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ConnectionMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConnectionMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConnectionMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *ConnectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ConnectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ConnectionMutation) ResetName() {
	m.name = nil
}

// SetSyncOrders sets the "sync_orders" field.
func (m *ConnectionMutation) SetSyncOrders(b bool) {
	m.sync_orders = &b
}

// SyncOrders returns the value of the "sync_orders" field in the mutation.
func (m *ConnectionMutation) SyncOrders() (r bool, exists bool) {
	v := m.sync_orders
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncOrders returns the old "sync_orders" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldSyncOrders(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncOrders is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncOrders requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncOrders: %w", err)
	}
	return oldValue.SyncOrders, nil
}

// ResetSyncOrders resets all changes to the "sync_orders" field.
func (m *ConnectionMutation) ResetSyncOrders() {
	m.sync_orders = nil
}

// SetSyncProducts sets the "sync_products" field.
func (m *ConnectionMutation) SetSyncProducts(b bool) {
	m.sync_products = &b
}

// SyncProducts returns the value of the "sync_products" field in the mutation.
func (m *ConnectionMutation) SyncProducts() (r bool, exists bool) {
	v := m.sync_products
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncProducts returns the old "sync_products" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldSyncProducts(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncProducts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncProducts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncProducts: %w", err)
	}
	return oldValue.SyncProducts, nil
}

// ResetSyncProducts resets all changes to the "sync_products" field.
func (m *ConnectionMutation) ResetSyncProducts() {
	m.sync_products = nil
}

// SetFulfillAutomatically sets the "fulfill_automatically" field.
func (m *ConnectionMutation) SetFulfillAutomatically(b bool) {
	m.fulfill_automatically = &b
}

// FulfillAutomatically returns the value of the "fulfill_automatically" field in the mutation.
func (m *ConnectionMutation) FulfillAutomatically() (r bool, exists bool) {
	v := m.fulfill_automatically
	if v == nil {
		return
	}
	return *v, true
}

// OldFulfillAutomatically returns the old "fulfill_automatically" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldFulfillAutomatically(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFulfillAutomatically is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFulfillAutomatically requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFulfillAutomatically: %w", err)
	}
	return oldValue.FulfillAutomatically, nil
}

// ResetFulfillAutomatically resets all changes to the "fulfill_automatically" field.
func (m *ConnectionMutation) ResetFulfillAutomatically() {
	m.fulfill_automatically = nil
}

// SetDispatchAutomatically sets the "dispatch_automatically" field.
func (m *ConnectionMutation) SetDispatchAutomatically(b bool) {
	m.dispatch_automatically = &b
}

// DispatchAutomatically returns the value of the "dispatch_automatically" field in the mutation.
func (m *ConnectionMutation) DispatchAutomatically() (r bool, exists bool) {
	v := m.dispatch_automatically
	if v == nil {
		return
	}
	return *v, true
}

// OldDispatchAutomatically returns the old "dispatch_automatically" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldDispatchAutomatically(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDispatchAutomatically is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDispatchAutomatically requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDispatchAutomatically: %w", err)
	}
	return oldValue.DispatchAutomatically, nil
}

// ResetDispatchAutomatically resets all changes to the "dispatch_automatically" field.
func (m *ConnectionMutation) ResetDispatchAutomatically() {
	m.dispatch_automatically = nil
}

// SetConvertCurrency sets the "convert_currency" field.
func (m *ConnectionMutation) SetConvertCurrency(b bool) {
	m.convert_currency = &b
}

// ConvertCurrency returns the value of the "convert_currency" field in the mutation.
func (m *ConnectionMutation) ConvertCurrency() (r bool, exists bool) {
	v := m.convert_currency
	if v == nil {
		return
	}
	return *v, true
}

// OldConvertCurrency returns the old "convert_currency" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldConvertCurrency(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConvertCurrency is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConvertCurrency requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConvertCurrency: %w", err)
	}
	return oldValue.ConvertCurrency, nil
}

// ResetConvertCurrency resets all changes to the "convert_currency" field.
func (m *ConnectionMutation) ResetConvertCurrency() {
	m.convert_currency = nil
}

// SetAutoPrintParcelSlip sets the "auto_print_parcel_slip" field.
func (m *ConnectionMutation) SetAutoPrintParcelSlip(b bool) {
	m.auto_print_parcel_slip = &b
}

// AutoPrintParcelSlip returns the value of the "auto_print_parcel_slip" field in the mutation.
func (m *ConnectionMutation) AutoPrintParcelSlip() (r bool, exists bool) {
	v := m.auto_print_parcel_slip
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoPrintParcelSlip returns the old "auto_print_parcel_slip" field's value of the Connection entity.
// If the Connection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionMutation) OldAutoPrintParcelSlip(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoPrintParcelSlip is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoPrintParcelSlip requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoPrintParcelSlip: %w", err)
	}
	return oldValue.AutoPrintParcelSlip, nil
}

// ResetAutoPrintParcelSlip resets all changes to the "auto_print_parcel_slip" field.
func (m *ConnectionMutation) ResetAutoPrintParcelSlip() {
	m.auto_print_parcel_slip = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ConnectionMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[connection.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ConnectionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ConnectionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetConnectionBrandID sets the "connection_brand" edge to the ConnectionBrand entity by id.
func (m *ConnectionMutation) SetConnectionBrandID(id pulid.ID) {
	m.connection_brand = &id
}

// ClearConnectionBrand clears the "connection_brand" edge to the ConnectionBrand entity.
func (m *ConnectionMutation) ClearConnectionBrand() {
	m.clearedconnection_brand = true
}

// ConnectionBrandCleared reports if the "connection_brand" edge to the ConnectionBrand entity was cleared.
func (m *ConnectionMutation) ConnectionBrandCleared() bool {
	return m.clearedconnection_brand
}

// ConnectionBrandID returns the "connection_brand" edge ID in the mutation.
func (m *ConnectionMutation) ConnectionBrandID() (id pulid.ID, exists bool) {
	if m.connection_brand != nil {
		return *m.connection_brand, true
	}
	return
}

// ConnectionBrandIDs returns the "connection_brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionBrandID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) ConnectionBrandIDs() (ids []pulid.ID) {
	if id := m.connection_brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnectionBrand resets all changes to the "connection_brand" edge.
func (m *ConnectionMutation) ResetConnectionBrand() {
	m.connection_brand = nil
	m.clearedconnection_brand = false
}

// SetConnectionShopifyID sets the "connection_shopify" edge to the ConnectionShopify entity by id.
func (m *ConnectionMutation) SetConnectionShopifyID(id pulid.ID) {
	m.connection_shopify = &id
}

// ClearConnectionShopify clears the "connection_shopify" edge to the ConnectionShopify entity.
func (m *ConnectionMutation) ClearConnectionShopify() {
	m.clearedconnection_shopify = true
}

// ConnectionShopifyCleared reports if the "connection_shopify" edge to the ConnectionShopify entity was cleared.
func (m *ConnectionMutation) ConnectionShopifyCleared() bool {
	return m.clearedconnection_shopify
}

// ConnectionShopifyID returns the "connection_shopify" edge ID in the mutation.
func (m *ConnectionMutation) ConnectionShopifyID() (id pulid.ID, exists bool) {
	if m.connection_shopify != nil {
		return *m.connection_shopify, true
	}
	return
}

// ConnectionShopifyIDs returns the "connection_shopify" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionShopifyID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) ConnectionShopifyIDs() (ids []pulid.ID) {
	if id := m.connection_shopify; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnectionShopify resets all changes to the "connection_shopify" edge.
func (m *ConnectionMutation) ResetConnectionShopify() {
	m.connection_shopify = nil
	m.clearedconnection_shopify = false
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *ConnectionMutation) AddOrderIDs(ids ...pulid.ID) {
	if m.orders == nil {
		m.orders = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *ConnectionMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *ConnectionMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *ConnectionMutation) RemoveOrderIDs(ids ...pulid.ID) {
	if m.removedorders == nil {
		m.removedorders = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *ConnectionMutation) RemovedOrdersIDs() (ids []pulid.ID) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *ConnectionMutation) OrdersIDs() (ids []pulid.ID) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *ConnectionMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// SetSenderLocationID sets the "sender_location" edge to the Location entity by id.
func (m *ConnectionMutation) SetSenderLocationID(id pulid.ID) {
	m.sender_location = &id
}

// ClearSenderLocation clears the "sender_location" edge to the Location entity.
func (m *ConnectionMutation) ClearSenderLocation() {
	m.clearedsender_location = true
}

// SenderLocationCleared reports if the "sender_location" edge to the Location entity was cleared.
func (m *ConnectionMutation) SenderLocationCleared() bool {
	return m.clearedsender_location
}

// SenderLocationID returns the "sender_location" edge ID in the mutation.
func (m *ConnectionMutation) SenderLocationID() (id pulid.ID, exists bool) {
	if m.sender_location != nil {
		return *m.sender_location, true
	}
	return
}

// SenderLocationIDs returns the "sender_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderLocationID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) SenderLocationIDs() (ids []pulid.ID) {
	if id := m.sender_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSenderLocation resets all changes to the "sender_location" edge.
func (m *ConnectionMutation) ResetSenderLocation() {
	m.sender_location = nil
	m.clearedsender_location = false
}

// SetPickupLocationID sets the "pickup_location" edge to the Location entity by id.
func (m *ConnectionMutation) SetPickupLocationID(id pulid.ID) {
	m.pickup_location = &id
}

// ClearPickupLocation clears the "pickup_location" edge to the Location entity.
func (m *ConnectionMutation) ClearPickupLocation() {
	m.clearedpickup_location = true
}

// PickupLocationCleared reports if the "pickup_location" edge to the Location entity was cleared.
func (m *ConnectionMutation) PickupLocationCleared() bool {
	return m.clearedpickup_location
}

// PickupLocationID returns the "pickup_location" edge ID in the mutation.
func (m *ConnectionMutation) PickupLocationID() (id pulid.ID, exists bool) {
	if m.pickup_location != nil {
		return *m.pickup_location, true
	}
	return
}

// PickupLocationIDs returns the "pickup_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PickupLocationID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) PickupLocationIDs() (ids []pulid.ID) {
	if id := m.pickup_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPickupLocation resets all changes to the "pickup_location" edge.
func (m *ConnectionMutation) ResetPickupLocation() {
	m.pickup_location = nil
	m.clearedpickup_location = false
}

// SetReturnLocationID sets the "return_location" edge to the Location entity by id.
func (m *ConnectionMutation) SetReturnLocationID(id pulid.ID) {
	m.return_location = &id
}

// ClearReturnLocation clears the "return_location" edge to the Location entity.
func (m *ConnectionMutation) ClearReturnLocation() {
	m.clearedreturn_location = true
}

// ReturnLocationCleared reports if the "return_location" edge to the Location entity was cleared.
func (m *ConnectionMutation) ReturnLocationCleared() bool {
	return m.clearedreturn_location
}

// ReturnLocationID returns the "return_location" edge ID in the mutation.
func (m *ConnectionMutation) ReturnLocationID() (id pulid.ID, exists bool) {
	if m.return_location != nil {
		return *m.return_location, true
	}
	return
}

// ReturnLocationIDs returns the "return_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReturnLocationID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) ReturnLocationIDs() (ids []pulid.ID) {
	if id := m.return_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReturnLocation resets all changes to the "return_location" edge.
func (m *ConnectionMutation) ResetReturnLocation() {
	m.return_location = nil
	m.clearedreturn_location = false
}

// SetSellerLocationID sets the "seller_location" edge to the Location entity by id.
func (m *ConnectionMutation) SetSellerLocationID(id pulid.ID) {
	m.seller_location = &id
}

// ClearSellerLocation clears the "seller_location" edge to the Location entity.
func (m *ConnectionMutation) ClearSellerLocation() {
	m.clearedseller_location = true
}

// SellerLocationCleared reports if the "seller_location" edge to the Location entity was cleared.
func (m *ConnectionMutation) SellerLocationCleared() bool {
	return m.clearedseller_location
}

// SellerLocationID returns the "seller_location" edge ID in the mutation.
func (m *ConnectionMutation) SellerLocationID() (id pulid.ID, exists bool) {
	if m.seller_location != nil {
		return *m.seller_location, true
	}
	return
}

// SellerLocationIDs returns the "seller_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SellerLocationID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) SellerLocationIDs() (ids []pulid.ID) {
	if id := m.seller_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSellerLocation resets all changes to the "seller_location" edge.
func (m *ConnectionMutation) ResetSellerLocation() {
	m.seller_location = nil
	m.clearedseller_location = false
}

// AddDeliveryOptionIDs adds the "delivery_option" edge to the DeliveryOption entity by ids.
func (m *ConnectionMutation) AddDeliveryOptionIDs(ids ...pulid.ID) {
	if m.delivery_option == nil {
		m.delivery_option = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *ConnectionMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *ConnectionMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// RemoveDeliveryOptionIDs removes the "delivery_option" edge to the DeliveryOption entity by IDs.
func (m *ConnectionMutation) RemoveDeliveryOptionIDs(ids ...pulid.ID) {
	if m.removeddelivery_option == nil {
		m.removeddelivery_option = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option, ids[i])
		m.removeddelivery_option[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOption returns the removed IDs of the "delivery_option" edge to the DeliveryOption entity.
func (m *ConnectionMutation) RemovedDeliveryOptionIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
func (m *ConnectionMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	for id := range m.delivery_option {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *ConnectionMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
	m.removeddelivery_option = nil
}

// SetDefaultDeliveryOptionID sets the "default_delivery_option" edge to the DeliveryOption entity by id.
func (m *ConnectionMutation) SetDefaultDeliveryOptionID(id pulid.ID) {
	m.default_delivery_option = &id
}

// ClearDefaultDeliveryOption clears the "default_delivery_option" edge to the DeliveryOption entity.
func (m *ConnectionMutation) ClearDefaultDeliveryOption() {
	m.cleareddefault_delivery_option = true
}

// DefaultDeliveryOptionCleared reports if the "default_delivery_option" edge to the DeliveryOption entity was cleared.
func (m *ConnectionMutation) DefaultDeliveryOptionCleared() bool {
	return m.cleareddefault_delivery_option
}

// DefaultDeliveryOptionID returns the "default_delivery_option" edge ID in the mutation.
func (m *ConnectionMutation) DefaultDeliveryOptionID() (id pulid.ID, exists bool) {
	if m.default_delivery_option != nil {
		return *m.default_delivery_option, true
	}
	return
}

// DefaultDeliveryOptionIDs returns the "default_delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultDeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) DefaultDeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.default_delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultDeliveryOption resets all changes to the "default_delivery_option" edge.
func (m *ConnectionMutation) ResetDefaultDeliveryOption() {
	m.default_delivery_option = nil
	m.cleareddefault_delivery_option = false
}

// SetReturnPortalID sets the "return_portal" edge to the ReturnPortal entity by id.
func (m *ConnectionMutation) SetReturnPortalID(id pulid.ID) {
	m.return_portal = &id
}

// ClearReturnPortal clears the "return_portal" edge to the ReturnPortal entity.
func (m *ConnectionMutation) ClearReturnPortal() {
	m.clearedreturn_portal = true
}

// ReturnPortalCleared reports if the "return_portal" edge to the ReturnPortal entity was cleared.
func (m *ConnectionMutation) ReturnPortalCleared() bool {
	return m.clearedreturn_portal
}

// ReturnPortalID returns the "return_portal" edge ID in the mutation.
func (m *ConnectionMutation) ReturnPortalID() (id pulid.ID, exists bool) {
	if m.return_portal != nil {
		return *m.return_portal, true
	}
	return
}

// ReturnPortalIDs returns the "return_portal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReturnPortalID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) ReturnPortalIDs() (ids []pulid.ID) {
	if id := m.return_portal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReturnPortal resets all changes to the "return_portal" edge.
func (m *ConnectionMutation) ResetReturnPortal() {
	m.return_portal = nil
	m.clearedreturn_portal = false
}

// AddHypothesisTestIDs adds the "hypothesis_test" edge to the HypothesisTest entity by ids.
func (m *ConnectionMutation) AddHypothesisTestIDs(ids ...pulid.ID) {
	if m.hypothesis_test == nil {
		m.hypothesis_test = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.hypothesis_test[ids[i]] = struct{}{}
	}
}

// ClearHypothesisTest clears the "hypothesis_test" edge to the HypothesisTest entity.
func (m *ConnectionMutation) ClearHypothesisTest() {
	m.clearedhypothesis_test = true
}

// HypothesisTestCleared reports if the "hypothesis_test" edge to the HypothesisTest entity was cleared.
func (m *ConnectionMutation) HypothesisTestCleared() bool {
	return m.clearedhypothesis_test
}

// RemoveHypothesisTestIDs removes the "hypothesis_test" edge to the HypothesisTest entity by IDs.
func (m *ConnectionMutation) RemoveHypothesisTestIDs(ids ...pulid.ID) {
	if m.removedhypothesis_test == nil {
		m.removedhypothesis_test = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.hypothesis_test, ids[i])
		m.removedhypothesis_test[ids[i]] = struct{}{}
	}
}

// RemovedHypothesisTest returns the removed IDs of the "hypothesis_test" edge to the HypothesisTest entity.
func (m *ConnectionMutation) RemovedHypothesisTestIDs() (ids []pulid.ID) {
	for id := range m.removedhypothesis_test {
		ids = append(ids, id)
	}
	return
}

// HypothesisTestIDs returns the "hypothesis_test" edge IDs in the mutation.
func (m *ConnectionMutation) HypothesisTestIDs() (ids []pulid.ID) {
	for id := range m.hypothesis_test {
		ids = append(ids, id)
	}
	return
}

// ResetHypothesisTest resets all changes to the "hypothesis_test" edge.
func (m *ConnectionMutation) ResetHypothesisTest() {
	m.hypothesis_test = nil
	m.clearedhypothesis_test = false
	m.removedhypothesis_test = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *ConnectionMutation) AddNotificationIDs(ids ...pulid.ID) {
	if m.notifications == nil {
		m.notifications = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *ConnectionMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *ConnectionMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *ConnectionMutation) RemoveNotificationIDs(ids ...pulid.ID) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *ConnectionMutation) RemovedNotificationsIDs() (ids []pulid.ID) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *ConnectionMutation) NotificationsIDs() (ids []pulid.ID) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *ConnectionMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// SetCurrencyID sets the "currency" edge to the Currency entity by id.
func (m *ConnectionMutation) SetCurrencyID(id pulid.ID) {
	m.currency = &id
}

// ClearCurrency clears the "currency" edge to the Currency entity.
func (m *ConnectionMutation) ClearCurrency() {
	m.clearedcurrency = true
}

// CurrencyCleared reports if the "currency" edge to the Currency entity was cleared.
func (m *ConnectionMutation) CurrencyCleared() bool {
	return m.clearedcurrency
}

// CurrencyID returns the "currency" edge ID in the mutation.
func (m *ConnectionMutation) CurrencyID() (id pulid.ID, exists bool) {
	if m.currency != nil {
		return *m.currency, true
	}
	return
}

// CurrencyIDs returns the "currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) CurrencyIDs() (ids []pulid.ID) {
	if id := m.currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrency resets all changes to the "currency" edge.
func (m *ConnectionMutation) ResetCurrency() {
	m.currency = nil
	m.clearedcurrency = false
}

// SetPackingSlipTemplateID sets the "packing_slip_template" edge to the Document entity by id.
func (m *ConnectionMutation) SetPackingSlipTemplateID(id pulid.ID) {
	m.packing_slip_template = &id
}

// ClearPackingSlipTemplate clears the "packing_slip_template" edge to the Document entity.
func (m *ConnectionMutation) ClearPackingSlipTemplate() {
	m.clearedpacking_slip_template = true
}

// PackingSlipTemplateCleared reports if the "packing_slip_template" edge to the Document entity was cleared.
func (m *ConnectionMutation) PackingSlipTemplateCleared() bool {
	return m.clearedpacking_slip_template
}

// PackingSlipTemplateID returns the "packing_slip_template" edge ID in the mutation.
func (m *ConnectionMutation) PackingSlipTemplateID() (id pulid.ID, exists bool) {
	if m.packing_slip_template != nil {
		return *m.packing_slip_template, true
	}
	return
}

// PackingSlipTemplateIDs returns the "packing_slip_template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackingSlipTemplateID instead. It exists only for internal usage by the builders.
func (m *ConnectionMutation) PackingSlipTemplateIDs() (ids []pulid.ID) {
	if id := m.packing_slip_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackingSlipTemplate resets all changes to the "packing_slip_template" edge.
func (m *ConnectionMutation) ResetPackingSlipTemplate() {
	m.packing_slip_template = nil
	m.clearedpacking_slip_template = false
}

// AddConnectionLookupIDs adds the "connection_lookup" edge to the ConnectionLookup entity by ids.
func (m *ConnectionMutation) AddConnectionLookupIDs(ids ...pulid.ID) {
	if m.connection_lookup == nil {
		m.connection_lookup = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.connection_lookup[ids[i]] = struct{}{}
	}
}

// ClearConnectionLookup clears the "connection_lookup" edge to the ConnectionLookup entity.
func (m *ConnectionMutation) ClearConnectionLookup() {
	m.clearedconnection_lookup = true
}

// ConnectionLookupCleared reports if the "connection_lookup" edge to the ConnectionLookup entity was cleared.
func (m *ConnectionMutation) ConnectionLookupCleared() bool {
	return m.clearedconnection_lookup
}

// RemoveConnectionLookupIDs removes the "connection_lookup" edge to the ConnectionLookup entity by IDs.
func (m *ConnectionMutation) RemoveConnectionLookupIDs(ids ...pulid.ID) {
	if m.removedconnection_lookup == nil {
		m.removedconnection_lookup = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.connection_lookup, ids[i])
		m.removedconnection_lookup[ids[i]] = struct{}{}
	}
}

// RemovedConnectionLookup returns the removed IDs of the "connection_lookup" edge to the ConnectionLookup entity.
func (m *ConnectionMutation) RemovedConnectionLookupIDs() (ids []pulid.ID) {
	for id := range m.removedconnection_lookup {
		ids = append(ids, id)
	}
	return
}

// ConnectionLookupIDs returns the "connection_lookup" edge IDs in the mutation.
func (m *ConnectionMutation) ConnectionLookupIDs() (ids []pulid.ID) {
	for id := range m.connection_lookup {
		ids = append(ids, id)
	}
	return
}

// ResetConnectionLookup resets all changes to the "connection_lookup" edge.
func (m *ConnectionMutation) ResetConnectionLookup() {
	m.connection_lookup = nil
	m.clearedconnection_lookup = false
	m.removedconnection_lookup = nil
}

// Where appends a list predicates to the ConnectionMutation builder.
func (m *ConnectionMutation) Where(ps ...predicate.Connection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Connection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Connection).
func (m *ConnectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant != nil {
		fields = append(fields, connection.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, connection.FieldName)
	}
	if m.sync_orders != nil {
		fields = append(fields, connection.FieldSyncOrders)
	}
	if m.sync_products != nil {
		fields = append(fields, connection.FieldSyncProducts)
	}
	if m.fulfill_automatically != nil {
		fields = append(fields, connection.FieldFulfillAutomatically)
	}
	if m.dispatch_automatically != nil {
		fields = append(fields, connection.FieldDispatchAutomatically)
	}
	if m.convert_currency != nil {
		fields = append(fields, connection.FieldConvertCurrency)
	}
	if m.auto_print_parcel_slip != nil {
		fields = append(fields, connection.FieldAutoPrintParcelSlip)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connection.FieldTenantID:
		return m.TenantID()
	case connection.FieldName:
		return m.Name()
	case connection.FieldSyncOrders:
		return m.SyncOrders()
	case connection.FieldSyncProducts:
		return m.SyncProducts()
	case connection.FieldFulfillAutomatically:
		return m.FulfillAutomatically()
	case connection.FieldDispatchAutomatically:
		return m.DispatchAutomatically()
	case connection.FieldConvertCurrency:
		return m.ConvertCurrency()
	case connection.FieldAutoPrintParcelSlip:
		return m.AutoPrintParcelSlip()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connection.FieldTenantID:
		return m.OldTenantID(ctx)
	case connection.FieldName:
		return m.OldName(ctx)
	case connection.FieldSyncOrders:
		return m.OldSyncOrders(ctx)
	case connection.FieldSyncProducts:
		return m.OldSyncProducts(ctx)
	case connection.FieldFulfillAutomatically:
		return m.OldFulfillAutomatically(ctx)
	case connection.FieldDispatchAutomatically:
		return m.OldDispatchAutomatically(ctx)
	case connection.FieldConvertCurrency:
		return m.OldConvertCurrency(ctx)
	case connection.FieldAutoPrintParcelSlip:
		return m.OldAutoPrintParcelSlip(ctx)
	}
	return nil, fmt.Errorf("unknown Connection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connection.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case connection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case connection.FieldSyncOrders:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncOrders(v)
		return nil
	case connection.FieldSyncProducts:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncProducts(v)
		return nil
	case connection.FieldFulfillAutomatically:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFulfillAutomatically(v)
		return nil
	case connection.FieldDispatchAutomatically:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDispatchAutomatically(v)
		return nil
	case connection.FieldConvertCurrency:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConvertCurrency(v)
		return nil
	case connection.FieldAutoPrintParcelSlip:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoPrintParcelSlip(v)
		return nil
	}
	return fmt.Errorf("unknown Connection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Connection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Connection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectionMutation) ResetField(name string) error {
	switch name {
	case connection.FieldTenantID:
		m.ResetTenantID()
		return nil
	case connection.FieldName:
		m.ResetName()
		return nil
	case connection.FieldSyncOrders:
		m.ResetSyncOrders()
		return nil
	case connection.FieldSyncProducts:
		m.ResetSyncProducts()
		return nil
	case connection.FieldFulfillAutomatically:
		m.ResetFulfillAutomatically()
		return nil
	case connection.FieldDispatchAutomatically:
		m.ResetDispatchAutomatically()
		return nil
	case connection.FieldConvertCurrency:
		m.ResetConvertCurrency()
		return nil
	case connection.FieldAutoPrintParcelSlip:
		m.ResetAutoPrintParcelSlip()
		return nil
	}
	return fmt.Errorf("unknown Connection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 16)
	if m.tenant != nil {
		edges = append(edges, connection.EdgeTenant)
	}
	if m.connection_brand != nil {
		edges = append(edges, connection.EdgeConnectionBrand)
	}
	if m.connection_shopify != nil {
		edges = append(edges, connection.EdgeConnectionShopify)
	}
	if m.orders != nil {
		edges = append(edges, connection.EdgeOrders)
	}
	if m.sender_location != nil {
		edges = append(edges, connection.EdgeSenderLocation)
	}
	if m.pickup_location != nil {
		edges = append(edges, connection.EdgePickupLocation)
	}
	if m.return_location != nil {
		edges = append(edges, connection.EdgeReturnLocation)
	}
	if m.seller_location != nil {
		edges = append(edges, connection.EdgeSellerLocation)
	}
	if m.delivery_option != nil {
		edges = append(edges, connection.EdgeDeliveryOption)
	}
	if m.default_delivery_option != nil {
		edges = append(edges, connection.EdgeDefaultDeliveryOption)
	}
	if m.return_portal != nil {
		edges = append(edges, connection.EdgeReturnPortal)
	}
	if m.hypothesis_test != nil {
		edges = append(edges, connection.EdgeHypothesisTest)
	}
	if m.notifications != nil {
		edges = append(edges, connection.EdgeNotifications)
	}
	if m.currency != nil {
		edges = append(edges, connection.EdgeCurrency)
	}
	if m.packing_slip_template != nil {
		edges = append(edges, connection.EdgePackingSlipTemplate)
	}
	if m.connection_lookup != nil {
		edges = append(edges, connection.EdgeConnectionLookup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connection.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeConnectionBrand:
		if id := m.connection_brand; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeConnectionShopify:
		if id := m.connection_shopify; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case connection.EdgeSenderLocation:
		if id := m.sender_location; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgePickupLocation:
		if id := m.pickup_location; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeReturnLocation:
		if id := m.return_location; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeSellerLocation:
		if id := m.seller_location; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeDeliveryOption:
		ids := make([]ent.Value, 0, len(m.delivery_option))
		for id := range m.delivery_option {
			ids = append(ids, id)
		}
		return ids
	case connection.EdgeDefaultDeliveryOption:
		if id := m.default_delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeReturnPortal:
		if id := m.return_portal; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeHypothesisTest:
		ids := make([]ent.Value, 0, len(m.hypothesis_test))
		for id := range m.hypothesis_test {
			ids = append(ids, id)
		}
		return ids
	case connection.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	case connection.EdgeCurrency:
		if id := m.currency; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgePackingSlipTemplate:
		if id := m.packing_slip_template; id != nil {
			return []ent.Value{*id}
		}
	case connection.EdgeConnectionLookup:
		ids := make([]ent.Value, 0, len(m.connection_lookup))
		for id := range m.connection_lookup {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 16)
	if m.removedorders != nil {
		edges = append(edges, connection.EdgeOrders)
	}
	if m.removeddelivery_option != nil {
		edges = append(edges, connection.EdgeDeliveryOption)
	}
	if m.removedhypothesis_test != nil {
		edges = append(edges, connection.EdgeHypothesisTest)
	}
	if m.removednotifications != nil {
		edges = append(edges, connection.EdgeNotifications)
	}
	if m.removedconnection_lookup != nil {
		edges = append(edges, connection.EdgeConnectionLookup)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connection.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case connection.EdgeDeliveryOption:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option))
		for id := range m.removeddelivery_option {
			ids = append(ids, id)
		}
		return ids
	case connection.EdgeHypothesisTest:
		ids := make([]ent.Value, 0, len(m.removedhypothesis_test))
		for id := range m.removedhypothesis_test {
			ids = append(ids, id)
		}
		return ids
	case connection.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	case connection.EdgeConnectionLookup:
		ids := make([]ent.Value, 0, len(m.removedconnection_lookup))
		for id := range m.removedconnection_lookup {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 16)
	if m.clearedtenant {
		edges = append(edges, connection.EdgeTenant)
	}
	if m.clearedconnection_brand {
		edges = append(edges, connection.EdgeConnectionBrand)
	}
	if m.clearedconnection_shopify {
		edges = append(edges, connection.EdgeConnectionShopify)
	}
	if m.clearedorders {
		edges = append(edges, connection.EdgeOrders)
	}
	if m.clearedsender_location {
		edges = append(edges, connection.EdgeSenderLocation)
	}
	if m.clearedpickup_location {
		edges = append(edges, connection.EdgePickupLocation)
	}
	if m.clearedreturn_location {
		edges = append(edges, connection.EdgeReturnLocation)
	}
	if m.clearedseller_location {
		edges = append(edges, connection.EdgeSellerLocation)
	}
	if m.cleareddelivery_option {
		edges = append(edges, connection.EdgeDeliveryOption)
	}
	if m.cleareddefault_delivery_option {
		edges = append(edges, connection.EdgeDefaultDeliveryOption)
	}
	if m.clearedreturn_portal {
		edges = append(edges, connection.EdgeReturnPortal)
	}
	if m.clearedhypothesis_test {
		edges = append(edges, connection.EdgeHypothesisTest)
	}
	if m.clearednotifications {
		edges = append(edges, connection.EdgeNotifications)
	}
	if m.clearedcurrency {
		edges = append(edges, connection.EdgeCurrency)
	}
	if m.clearedpacking_slip_template {
		edges = append(edges, connection.EdgePackingSlipTemplate)
	}
	if m.clearedconnection_lookup {
		edges = append(edges, connection.EdgeConnectionLookup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectionMutation) EdgeCleared(name string) bool {
	switch name {
	case connection.EdgeTenant:
		return m.clearedtenant
	case connection.EdgeConnectionBrand:
		return m.clearedconnection_brand
	case connection.EdgeConnectionShopify:
		return m.clearedconnection_shopify
	case connection.EdgeOrders:
		return m.clearedorders
	case connection.EdgeSenderLocation:
		return m.clearedsender_location
	case connection.EdgePickupLocation:
		return m.clearedpickup_location
	case connection.EdgeReturnLocation:
		return m.clearedreturn_location
	case connection.EdgeSellerLocation:
		return m.clearedseller_location
	case connection.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case connection.EdgeDefaultDeliveryOption:
		return m.cleareddefault_delivery_option
	case connection.EdgeReturnPortal:
		return m.clearedreturn_portal
	case connection.EdgeHypothesisTest:
		return m.clearedhypothesis_test
	case connection.EdgeNotifications:
		return m.clearednotifications
	case connection.EdgeCurrency:
		return m.clearedcurrency
	case connection.EdgePackingSlipTemplate:
		return m.clearedpacking_slip_template
	case connection.EdgeConnectionLookup:
		return m.clearedconnection_lookup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectionMutation) ClearEdge(name string) error {
	switch name {
	case connection.EdgeTenant:
		m.ClearTenant()
		return nil
	case connection.EdgeConnectionBrand:
		m.ClearConnectionBrand()
		return nil
	case connection.EdgeConnectionShopify:
		m.ClearConnectionShopify()
		return nil
	case connection.EdgeSenderLocation:
		m.ClearSenderLocation()
		return nil
	case connection.EdgePickupLocation:
		m.ClearPickupLocation()
		return nil
	case connection.EdgeReturnLocation:
		m.ClearReturnLocation()
		return nil
	case connection.EdgeSellerLocation:
		m.ClearSellerLocation()
		return nil
	case connection.EdgeDefaultDeliveryOption:
		m.ClearDefaultDeliveryOption()
		return nil
	case connection.EdgeReturnPortal:
		m.ClearReturnPortal()
		return nil
	case connection.EdgeCurrency:
		m.ClearCurrency()
		return nil
	case connection.EdgePackingSlipTemplate:
		m.ClearPackingSlipTemplate()
		return nil
	}
	return fmt.Errorf("unknown Connection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectionMutation) ResetEdge(name string) error {
	switch name {
	case connection.EdgeTenant:
		m.ResetTenant()
		return nil
	case connection.EdgeConnectionBrand:
		m.ResetConnectionBrand()
		return nil
	case connection.EdgeConnectionShopify:
		m.ResetConnectionShopify()
		return nil
	case connection.EdgeOrders:
		m.ResetOrders()
		return nil
	case connection.EdgeSenderLocation:
		m.ResetSenderLocation()
		return nil
	case connection.EdgePickupLocation:
		m.ResetPickupLocation()
		return nil
	case connection.EdgeReturnLocation:
		m.ResetReturnLocation()
		return nil
	case connection.EdgeSellerLocation:
		m.ResetSellerLocation()
		return nil
	case connection.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case connection.EdgeDefaultDeliveryOption:
		m.ResetDefaultDeliveryOption()
		return nil
	case connection.EdgeReturnPortal:
		m.ResetReturnPortal()
		return nil
	case connection.EdgeHypothesisTest:
		m.ResetHypothesisTest()
		return nil
	case connection.EdgeNotifications:
		m.ResetNotifications()
		return nil
	case connection.EdgeCurrency:
		m.ResetCurrency()
		return nil
	case connection.EdgePackingSlipTemplate:
		m.ResetPackingSlipTemplate()
		return nil
	case connection.EdgeConnectionLookup:
		m.ResetConnectionLookup()
		return nil
	}
	return fmt.Errorf("unknown Connection edge %s", name)
}

// ConnectionBrandMutation represents an operation that mutates the ConnectionBrand nodes in the graph.
type ConnectionBrandMutation struct {
	config
	op                Op
	typ               string
	id                *pulid.ID
	label             *string
	internal_id       *connectionbrand.InternalID
	logo_url          *string
	clearedFields     map[string]struct{}
	connection        map[pulid.ID]struct{}
	removedconnection map[pulid.ID]struct{}
	clearedconnection bool
	done              bool
	oldValue          func(context.Context) (*ConnectionBrand, error)
	predicates        []predicate.ConnectionBrand
}

var _ ent.Mutation = (*ConnectionBrandMutation)(nil)

// connectionbrandOption allows management of the mutation configuration using functional options.
type connectionbrandOption func(*ConnectionBrandMutation)

// newConnectionBrandMutation creates new mutation for the ConnectionBrand entity.
func newConnectionBrandMutation(c config, op Op, opts ...connectionbrandOption) *ConnectionBrandMutation {
	m := &ConnectionBrandMutation{
		config:        c,
		op:            op,
		typ:           TypeConnectionBrand,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectionBrandID sets the ID field of the mutation.
func withConnectionBrandID(id pulid.ID) connectionbrandOption {
	return func(m *ConnectionBrandMutation) {
		var (
			err   error
			once  sync.Once
			value *ConnectionBrand
		)
		m.oldValue = func(ctx context.Context) (*ConnectionBrand, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConnectionBrand.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnectionBrand sets the old ConnectionBrand of the mutation.
func withConnectionBrand(node *ConnectionBrand) connectionbrandOption {
	return func(m *ConnectionBrandMutation) {
		m.oldValue = func(context.Context) (*ConnectionBrand, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectionBrandMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectionBrandMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConnectionBrand entities.
func (m *ConnectionBrandMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectionBrandMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectionBrandMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConnectionBrand.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *ConnectionBrandMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *ConnectionBrandMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the ConnectionBrand entity.
// If the ConnectionBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionBrandMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *ConnectionBrandMutation) ResetLabel() {
	m.label = nil
}

// SetInternalID sets the "internal_id" field.
func (m *ConnectionBrandMutation) SetInternalID(ci connectionbrand.InternalID) {
	m.internal_id = &ci
}

// InternalID returns the value of the "internal_id" field in the mutation.
func (m *ConnectionBrandMutation) InternalID() (r connectionbrand.InternalID, exists bool) {
	v := m.internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalID returns the old "internal_id" field's value of the ConnectionBrand entity.
// If the ConnectionBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionBrandMutation) OldInternalID(ctx context.Context) (v connectionbrand.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalID: %w", err)
	}
	return oldValue.InternalID, nil
}

// ResetInternalID resets all changes to the "internal_id" field.
func (m *ConnectionBrandMutation) ResetInternalID() {
	m.internal_id = nil
}

// SetLogoURL sets the "logo_url" field.
func (m *ConnectionBrandMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *ConnectionBrandMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the ConnectionBrand entity.
// If the ConnectionBrand object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionBrandMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *ConnectionBrandMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[connectionbrand.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *ConnectionBrandMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[connectionbrand.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *ConnectionBrandMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, connectionbrand.FieldLogoURL)
}

// AddConnectionIDs adds the "connection" edge to the Connection entity by ids.
func (m *ConnectionBrandMutation) AddConnectionIDs(ids ...pulid.ID) {
	if m.connection == nil {
		m.connection = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.connection[ids[i]] = struct{}{}
	}
}

// ClearConnection clears the "connection" edge to the Connection entity.
func (m *ConnectionBrandMutation) ClearConnection() {
	m.clearedconnection = true
}

// ConnectionCleared reports if the "connection" edge to the Connection entity was cleared.
func (m *ConnectionBrandMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// RemoveConnectionIDs removes the "connection" edge to the Connection entity by IDs.
func (m *ConnectionBrandMutation) RemoveConnectionIDs(ids ...pulid.ID) {
	if m.removedconnection == nil {
		m.removedconnection = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.connection, ids[i])
		m.removedconnection[ids[i]] = struct{}{}
	}
}

// RemovedConnection returns the removed IDs of the "connection" edge to the Connection entity.
func (m *ConnectionBrandMutation) RemovedConnectionIDs() (ids []pulid.ID) {
	for id := range m.removedconnection {
		ids = append(ids, id)
	}
	return
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
func (m *ConnectionBrandMutation) ConnectionIDs() (ids []pulid.ID) {
	for id := range m.connection {
		ids = append(ids, id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *ConnectionBrandMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
	m.removedconnection = nil
}

// Where appends a list predicates to the ConnectionBrandMutation builder.
func (m *ConnectionBrandMutation) Where(ps ...predicate.ConnectionBrand) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectionBrandMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectionBrandMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConnectionBrand, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectionBrandMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectionBrandMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConnectionBrand).
func (m *ConnectionBrandMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectionBrandMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.label != nil {
		fields = append(fields, connectionbrand.FieldLabel)
	}
	if m.internal_id != nil {
		fields = append(fields, connectionbrand.FieldInternalID)
	}
	if m.logo_url != nil {
		fields = append(fields, connectionbrand.FieldLogoURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectionBrandMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connectionbrand.FieldLabel:
		return m.Label()
	case connectionbrand.FieldInternalID:
		return m.InternalID()
	case connectionbrand.FieldLogoURL:
		return m.LogoURL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectionBrandMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connectionbrand.FieldLabel:
		return m.OldLabel(ctx)
	case connectionbrand.FieldInternalID:
		return m.OldInternalID(ctx)
	case connectionbrand.FieldLogoURL:
		return m.OldLogoURL(ctx)
	}
	return nil, fmt.Errorf("unknown ConnectionBrand field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionBrandMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connectionbrand.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case connectionbrand.FieldInternalID:
		v, ok := value.(connectionbrand.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalID(v)
		return nil
	case connectionbrand.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	}
	return fmt.Errorf("unknown ConnectionBrand field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectionBrandMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectionBrandMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionBrandMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConnectionBrand numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectionBrandMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(connectionbrand.FieldLogoURL) {
		fields = append(fields, connectionbrand.FieldLogoURL)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectionBrandMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectionBrandMutation) ClearField(name string) error {
	switch name {
	case connectionbrand.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	}
	return fmt.Errorf("unknown ConnectionBrand nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectionBrandMutation) ResetField(name string) error {
	switch name {
	case connectionbrand.FieldLabel:
		m.ResetLabel()
		return nil
	case connectionbrand.FieldInternalID:
		m.ResetInternalID()
		return nil
	case connectionbrand.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	}
	return fmt.Errorf("unknown ConnectionBrand field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectionBrandMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.connection != nil {
		edges = append(edges, connectionbrand.EdgeConnection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectionBrandMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connectionbrand.EdgeConnection:
		ids := make([]ent.Value, 0, len(m.connection))
		for id := range m.connection {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectionBrandMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedconnection != nil {
		edges = append(edges, connectionbrand.EdgeConnection)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectionBrandMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case connectionbrand.EdgeConnection:
		ids := make([]ent.Value, 0, len(m.removedconnection))
		for id := range m.removedconnection {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectionBrandMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedconnection {
		edges = append(edges, connectionbrand.EdgeConnection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectionBrandMutation) EdgeCleared(name string) bool {
	switch name {
	case connectionbrand.EdgeConnection:
		return m.clearedconnection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectionBrandMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown ConnectionBrand unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectionBrandMutation) ResetEdge(name string) error {
	switch name {
	case connectionbrand.EdgeConnection:
		m.ResetConnection()
		return nil
	}
	return fmt.Errorf("unknown ConnectionBrand edge %s", name)
}

// ConnectionLookupMutation represents an operation that mutates the ConnectionLookup nodes in the graph.
type ConnectionLookupMutation struct {
	config
	op                      Op
	typ                     string
	id                      *pulid.ID
	payload                 *string
	options_output_count    *int
	addoptions_output_count *int
	error                   *string
	created_at              *time.Time
	clearedFields           map[string]struct{}
	tenant                  *pulid.ID
	clearedtenant           bool
	connections             *pulid.ID
	clearedconnections      bool
	done                    bool
	oldValue                func(context.Context) (*ConnectionLookup, error)
	predicates              []predicate.ConnectionLookup
}

var _ ent.Mutation = (*ConnectionLookupMutation)(nil)

// connectionlookupOption allows management of the mutation configuration using functional options.
type connectionlookupOption func(*ConnectionLookupMutation)

// newConnectionLookupMutation creates new mutation for the ConnectionLookup entity.
func newConnectionLookupMutation(c config, op Op, opts ...connectionlookupOption) *ConnectionLookupMutation {
	m := &ConnectionLookupMutation{
		config:        c,
		op:            op,
		typ:           TypeConnectionLookup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectionLookupID sets the ID field of the mutation.
func withConnectionLookupID(id pulid.ID) connectionlookupOption {
	return func(m *ConnectionLookupMutation) {
		var (
			err   error
			once  sync.Once
			value *ConnectionLookup
		)
		m.oldValue = func(ctx context.Context) (*ConnectionLookup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConnectionLookup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnectionLookup sets the old ConnectionLookup of the mutation.
func withConnectionLookup(node *ConnectionLookup) connectionlookupOption {
	return func(m *ConnectionLookupMutation) {
		m.oldValue = func(context.Context) (*ConnectionLookup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectionLookupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectionLookupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConnectionLookup entities.
func (m *ConnectionLookupMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectionLookupMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectionLookupMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConnectionLookup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ConnectionLookupMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConnectionLookupMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ConnectionLookup entity.
// If the ConnectionLookup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionLookupMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConnectionLookupMutation) ResetTenantID() {
	m.tenant = nil
}

// SetPayload sets the "payload" field.
func (m *ConnectionLookupMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *ConnectionLookupMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the ConnectionLookup entity.
// If the ConnectionLookup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionLookupMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ResetPayload resets all changes to the "payload" field.
func (m *ConnectionLookupMutation) ResetPayload() {
	m.payload = nil
}

// SetOptionsOutputCount sets the "options_output_count" field.
func (m *ConnectionLookupMutation) SetOptionsOutputCount(i int) {
	m.options_output_count = &i
	m.addoptions_output_count = nil
}

// OptionsOutputCount returns the value of the "options_output_count" field in the mutation.
func (m *ConnectionLookupMutation) OptionsOutputCount() (r int, exists bool) {
	v := m.options_output_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOptionsOutputCount returns the old "options_output_count" field's value of the ConnectionLookup entity.
// If the ConnectionLookup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionLookupMutation) OldOptionsOutputCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOptionsOutputCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOptionsOutputCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOptionsOutputCount: %w", err)
	}
	return oldValue.OptionsOutputCount, nil
}

// AddOptionsOutputCount adds i to the "options_output_count" field.
func (m *ConnectionLookupMutation) AddOptionsOutputCount(i int) {
	if m.addoptions_output_count != nil {
		*m.addoptions_output_count += i
	} else {
		m.addoptions_output_count = &i
	}
}

// AddedOptionsOutputCount returns the value that was added to the "options_output_count" field in this mutation.
func (m *ConnectionLookupMutation) AddedOptionsOutputCount() (r int, exists bool) {
	v := m.addoptions_output_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOptionsOutputCount resets all changes to the "options_output_count" field.
func (m *ConnectionLookupMutation) ResetOptionsOutputCount() {
	m.options_output_count = nil
	m.addoptions_output_count = nil
}

// SetError sets the "error" field.
func (m *ConnectionLookupMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *ConnectionLookupMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the ConnectionLookup entity.
// If the ConnectionLookup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionLookupMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ClearError clears the value of the "error" field.
func (m *ConnectionLookupMutation) ClearError() {
	m.error = nil
	m.clearedFields[connectionlookup.FieldError] = struct{}{}
}

// ErrorCleared returns if the "error" field was cleared in this mutation.
func (m *ConnectionLookupMutation) ErrorCleared() bool {
	_, ok := m.clearedFields[connectionlookup.FieldError]
	return ok
}

// ResetError resets all changes to the "error" field.
func (m *ConnectionLookupMutation) ResetError() {
	m.error = nil
	delete(m.clearedFields, connectionlookup.FieldError)
}

// SetCreatedAt sets the "created_at" field.
func (m *ConnectionLookupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConnectionLookupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ConnectionLookup entity.
// If the ConnectionLookup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionLookupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConnectionLookupMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ConnectionLookupMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[connectionlookup.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ConnectionLookupMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ConnectionLookupMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ConnectionLookupMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetConnectionsID sets the "connections" edge to the Connection entity by id.
func (m *ConnectionLookupMutation) SetConnectionsID(id pulid.ID) {
	m.connections = &id
}

// ClearConnections clears the "connections" edge to the Connection entity.
func (m *ConnectionLookupMutation) ClearConnections() {
	m.clearedconnections = true
}

// ConnectionsCleared reports if the "connections" edge to the Connection entity was cleared.
func (m *ConnectionLookupMutation) ConnectionsCleared() bool {
	return m.clearedconnections
}

// ConnectionsID returns the "connections" edge ID in the mutation.
func (m *ConnectionLookupMutation) ConnectionsID() (id pulid.ID, exists bool) {
	if m.connections != nil {
		return *m.connections, true
	}
	return
}

// ConnectionsIDs returns the "connections" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionsID instead. It exists only for internal usage by the builders.
func (m *ConnectionLookupMutation) ConnectionsIDs() (ids []pulid.ID) {
	if id := m.connections; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnections resets all changes to the "connections" edge.
func (m *ConnectionLookupMutation) ResetConnections() {
	m.connections = nil
	m.clearedconnections = false
}

// Where appends a list predicates to the ConnectionLookupMutation builder.
func (m *ConnectionLookupMutation) Where(ps ...predicate.ConnectionLookup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectionLookupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectionLookupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConnectionLookup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectionLookupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectionLookupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConnectionLookup).
func (m *ConnectionLookupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectionLookupMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, connectionlookup.FieldTenantID)
	}
	if m.payload != nil {
		fields = append(fields, connectionlookup.FieldPayload)
	}
	if m.options_output_count != nil {
		fields = append(fields, connectionlookup.FieldOptionsOutputCount)
	}
	if m.error != nil {
		fields = append(fields, connectionlookup.FieldError)
	}
	if m.created_at != nil {
		fields = append(fields, connectionlookup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectionLookupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connectionlookup.FieldTenantID:
		return m.TenantID()
	case connectionlookup.FieldPayload:
		return m.Payload()
	case connectionlookup.FieldOptionsOutputCount:
		return m.OptionsOutputCount()
	case connectionlookup.FieldError:
		return m.Error()
	case connectionlookup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectionLookupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connectionlookup.FieldTenantID:
		return m.OldTenantID(ctx)
	case connectionlookup.FieldPayload:
		return m.OldPayload(ctx)
	case connectionlookup.FieldOptionsOutputCount:
		return m.OldOptionsOutputCount(ctx)
	case connectionlookup.FieldError:
		return m.OldError(ctx)
	case connectionlookup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ConnectionLookup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionLookupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connectionlookup.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case connectionlookup.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case connectionlookup.FieldOptionsOutputCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOptionsOutputCount(v)
		return nil
	case connectionlookup.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case connectionlookup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ConnectionLookup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectionLookupMutation) AddedFields() []string {
	var fields []string
	if m.addoptions_output_count != nil {
		fields = append(fields, connectionlookup.FieldOptionsOutputCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectionLookupMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case connectionlookup.FieldOptionsOutputCount:
		return m.AddedOptionsOutputCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionLookupMutation) AddField(name string, value ent.Value) error {
	switch name {
	case connectionlookup.FieldOptionsOutputCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOptionsOutputCount(v)
		return nil
	}
	return fmt.Errorf("unknown ConnectionLookup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectionLookupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(connectionlookup.FieldError) {
		fields = append(fields, connectionlookup.FieldError)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectionLookupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectionLookupMutation) ClearField(name string) error {
	switch name {
	case connectionlookup.FieldError:
		m.ClearError()
		return nil
	}
	return fmt.Errorf("unknown ConnectionLookup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectionLookupMutation) ResetField(name string) error {
	switch name {
	case connectionlookup.FieldTenantID:
		m.ResetTenantID()
		return nil
	case connectionlookup.FieldPayload:
		m.ResetPayload()
		return nil
	case connectionlookup.FieldOptionsOutputCount:
		m.ResetOptionsOutputCount()
		return nil
	case connectionlookup.FieldError:
		m.ResetError()
		return nil
	case connectionlookup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ConnectionLookup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectionLookupMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, connectionlookup.EdgeTenant)
	}
	if m.connections != nil {
		edges = append(edges, connectionlookup.EdgeConnections)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectionLookupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connectionlookup.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case connectionlookup.EdgeConnections:
		if id := m.connections; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectionLookupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectionLookupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectionLookupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, connectionlookup.EdgeTenant)
	}
	if m.clearedconnections {
		edges = append(edges, connectionlookup.EdgeConnections)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectionLookupMutation) EdgeCleared(name string) bool {
	switch name {
	case connectionlookup.EdgeTenant:
		return m.clearedtenant
	case connectionlookup.EdgeConnections:
		return m.clearedconnections
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectionLookupMutation) ClearEdge(name string) error {
	switch name {
	case connectionlookup.EdgeTenant:
		m.ClearTenant()
		return nil
	case connectionlookup.EdgeConnections:
		m.ClearConnections()
		return nil
	}
	return fmt.Errorf("unknown ConnectionLookup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectionLookupMutation) ResetEdge(name string) error {
	switch name {
	case connectionlookup.EdgeTenant:
		m.ResetTenant()
		return nil
	case connectionlookup.EdgeConnections:
		m.ResetConnections()
		return nil
	}
	return fmt.Errorf("unknown ConnectionLookup edge %s", name)
}

// ConnectionShopifyMutation represents an operation that mutates the ConnectionShopify nodes in the graph.
type ConnectionShopifyMutation struct {
	config
	op                Op
	typ               string
	id                *pulid.ID
	rate_integration  *bool
	store_url         *string
	api_key           *string
	lookup_key        *string
	sync_from         *time.Time
	filter_tags       *[]string
	appendfilter_tags []string
	clearedFields     map[string]struct{}
	tenant            *pulid.ID
	clearedtenant     bool
	connection        *pulid.ID
	clearedconnection bool
	done              bool
	oldValue          func(context.Context) (*ConnectionShopify, error)
	predicates        []predicate.ConnectionShopify
}

var _ ent.Mutation = (*ConnectionShopifyMutation)(nil)

// connectionshopifyOption allows management of the mutation configuration using functional options.
type connectionshopifyOption func(*ConnectionShopifyMutation)

// newConnectionShopifyMutation creates new mutation for the ConnectionShopify entity.
func newConnectionShopifyMutation(c config, op Op, opts ...connectionshopifyOption) *ConnectionShopifyMutation {
	m := &ConnectionShopifyMutation{
		config:        c,
		op:            op,
		typ:           TypeConnectionShopify,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConnectionShopifyID sets the ID field of the mutation.
func withConnectionShopifyID(id pulid.ID) connectionshopifyOption {
	return func(m *ConnectionShopifyMutation) {
		var (
			err   error
			once  sync.Once
			value *ConnectionShopify
		)
		m.oldValue = func(ctx context.Context) (*ConnectionShopify, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ConnectionShopify.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConnectionShopify sets the old ConnectionShopify of the mutation.
func withConnectionShopify(node *ConnectionShopify) connectionshopifyOption {
	return func(m *ConnectionShopifyMutation) {
		m.oldValue = func(context.Context) (*ConnectionShopify, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConnectionShopifyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConnectionShopifyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ConnectionShopify entities.
func (m *ConnectionShopifyMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConnectionShopifyMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConnectionShopifyMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ConnectionShopify.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ConnectionShopifyMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConnectionShopifyMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ConnectionShopify entity.
// If the ConnectionShopify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionShopifyMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConnectionShopifyMutation) ResetTenantID() {
	m.tenant = nil
}

// SetRateIntegration sets the "rate_integration" field.
func (m *ConnectionShopifyMutation) SetRateIntegration(b bool) {
	m.rate_integration = &b
}

// RateIntegration returns the value of the "rate_integration" field in the mutation.
func (m *ConnectionShopifyMutation) RateIntegration() (r bool, exists bool) {
	v := m.rate_integration
	if v == nil {
		return
	}
	return *v, true
}

// OldRateIntegration returns the old "rate_integration" field's value of the ConnectionShopify entity.
// If the ConnectionShopify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionShopifyMutation) OldRateIntegration(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRateIntegration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRateIntegration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRateIntegration: %w", err)
	}
	return oldValue.RateIntegration, nil
}

// ResetRateIntegration resets all changes to the "rate_integration" field.
func (m *ConnectionShopifyMutation) ResetRateIntegration() {
	m.rate_integration = nil
}

// SetStoreURL sets the "store_url" field.
func (m *ConnectionShopifyMutation) SetStoreURL(s string) {
	m.store_url = &s
}

// StoreURL returns the value of the "store_url" field in the mutation.
func (m *ConnectionShopifyMutation) StoreURL() (r string, exists bool) {
	v := m.store_url
	if v == nil {
		return
	}
	return *v, true
}

// OldStoreURL returns the old "store_url" field's value of the ConnectionShopify entity.
// If the ConnectionShopify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionShopifyMutation) OldStoreURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoreURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoreURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoreURL: %w", err)
	}
	return oldValue.StoreURL, nil
}

// ClearStoreURL clears the value of the "store_url" field.
func (m *ConnectionShopifyMutation) ClearStoreURL() {
	m.store_url = nil
	m.clearedFields[connectionshopify.FieldStoreURL] = struct{}{}
}

// StoreURLCleared returns if the "store_url" field was cleared in this mutation.
func (m *ConnectionShopifyMutation) StoreURLCleared() bool {
	_, ok := m.clearedFields[connectionshopify.FieldStoreURL]
	return ok
}

// ResetStoreURL resets all changes to the "store_url" field.
func (m *ConnectionShopifyMutation) ResetStoreURL() {
	m.store_url = nil
	delete(m.clearedFields, connectionshopify.FieldStoreURL)
}

// SetAPIKey sets the "api_key" field.
func (m *ConnectionShopifyMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *ConnectionShopifyMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the ConnectionShopify entity.
// If the ConnectionShopify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionShopifyMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ClearAPIKey clears the value of the "api_key" field.
func (m *ConnectionShopifyMutation) ClearAPIKey() {
	m.api_key = nil
	m.clearedFields[connectionshopify.FieldAPIKey] = struct{}{}
}

// APIKeyCleared returns if the "api_key" field was cleared in this mutation.
func (m *ConnectionShopifyMutation) APIKeyCleared() bool {
	_, ok := m.clearedFields[connectionshopify.FieldAPIKey]
	return ok
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *ConnectionShopifyMutation) ResetAPIKey() {
	m.api_key = nil
	delete(m.clearedFields, connectionshopify.FieldAPIKey)
}

// SetLookupKey sets the "lookup_key" field.
func (m *ConnectionShopifyMutation) SetLookupKey(s string) {
	m.lookup_key = &s
}

// LookupKey returns the value of the "lookup_key" field in the mutation.
func (m *ConnectionShopifyMutation) LookupKey() (r string, exists bool) {
	v := m.lookup_key
	if v == nil {
		return
	}
	return *v, true
}

// OldLookupKey returns the old "lookup_key" field's value of the ConnectionShopify entity.
// If the ConnectionShopify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionShopifyMutation) OldLookupKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLookupKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLookupKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLookupKey: %w", err)
	}
	return oldValue.LookupKey, nil
}

// ClearLookupKey clears the value of the "lookup_key" field.
func (m *ConnectionShopifyMutation) ClearLookupKey() {
	m.lookup_key = nil
	m.clearedFields[connectionshopify.FieldLookupKey] = struct{}{}
}

// LookupKeyCleared returns if the "lookup_key" field was cleared in this mutation.
func (m *ConnectionShopifyMutation) LookupKeyCleared() bool {
	_, ok := m.clearedFields[connectionshopify.FieldLookupKey]
	return ok
}

// ResetLookupKey resets all changes to the "lookup_key" field.
func (m *ConnectionShopifyMutation) ResetLookupKey() {
	m.lookup_key = nil
	delete(m.clearedFields, connectionshopify.FieldLookupKey)
}

// SetSyncFrom sets the "sync_from" field.
func (m *ConnectionShopifyMutation) SetSyncFrom(t time.Time) {
	m.sync_from = &t
}

// SyncFrom returns the value of the "sync_from" field in the mutation.
func (m *ConnectionShopifyMutation) SyncFrom() (r time.Time, exists bool) {
	v := m.sync_from
	if v == nil {
		return
	}
	return *v, true
}

// OldSyncFrom returns the old "sync_from" field's value of the ConnectionShopify entity.
// If the ConnectionShopify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionShopifyMutation) OldSyncFrom(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSyncFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSyncFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSyncFrom: %w", err)
	}
	return oldValue.SyncFrom, nil
}

// ClearSyncFrom clears the value of the "sync_from" field.
func (m *ConnectionShopifyMutation) ClearSyncFrom() {
	m.sync_from = nil
	m.clearedFields[connectionshopify.FieldSyncFrom] = struct{}{}
}

// SyncFromCleared returns if the "sync_from" field was cleared in this mutation.
func (m *ConnectionShopifyMutation) SyncFromCleared() bool {
	_, ok := m.clearedFields[connectionshopify.FieldSyncFrom]
	return ok
}

// ResetSyncFrom resets all changes to the "sync_from" field.
func (m *ConnectionShopifyMutation) ResetSyncFrom() {
	m.sync_from = nil
	delete(m.clearedFields, connectionshopify.FieldSyncFrom)
}

// SetFilterTags sets the "filter_tags" field.
func (m *ConnectionShopifyMutation) SetFilterTags(s []string) {
	m.filter_tags = &s
	m.appendfilter_tags = nil
}

// FilterTags returns the value of the "filter_tags" field in the mutation.
func (m *ConnectionShopifyMutation) FilterTags() (r []string, exists bool) {
	v := m.filter_tags
	if v == nil {
		return
	}
	return *v, true
}

// OldFilterTags returns the old "filter_tags" field's value of the ConnectionShopify entity.
// If the ConnectionShopify object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConnectionShopifyMutation) OldFilterTags(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilterTags is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilterTags requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilterTags: %w", err)
	}
	return oldValue.FilterTags, nil
}

// AppendFilterTags adds s to the "filter_tags" field.
func (m *ConnectionShopifyMutation) AppendFilterTags(s []string) {
	m.appendfilter_tags = append(m.appendfilter_tags, s...)
}

// AppendedFilterTags returns the list of values that were appended to the "filter_tags" field in this mutation.
func (m *ConnectionShopifyMutation) AppendedFilterTags() ([]string, bool) {
	if len(m.appendfilter_tags) == 0 {
		return nil, false
	}
	return m.appendfilter_tags, true
}

// ClearFilterTags clears the value of the "filter_tags" field.
func (m *ConnectionShopifyMutation) ClearFilterTags() {
	m.filter_tags = nil
	m.appendfilter_tags = nil
	m.clearedFields[connectionshopify.FieldFilterTags] = struct{}{}
}

// FilterTagsCleared returns if the "filter_tags" field was cleared in this mutation.
func (m *ConnectionShopifyMutation) FilterTagsCleared() bool {
	_, ok := m.clearedFields[connectionshopify.FieldFilterTags]
	return ok
}

// ResetFilterTags resets all changes to the "filter_tags" field.
func (m *ConnectionShopifyMutation) ResetFilterTags() {
	m.filter_tags = nil
	m.appendfilter_tags = nil
	delete(m.clearedFields, connectionshopify.FieldFilterTags)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ConnectionShopifyMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[connectionshopify.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ConnectionShopifyMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ConnectionShopifyMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ConnectionShopifyMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetConnectionID sets the "connection" edge to the Connection entity by id.
func (m *ConnectionShopifyMutation) SetConnectionID(id pulid.ID) {
	m.connection = &id
}

// ClearConnection clears the "connection" edge to the Connection entity.
func (m *ConnectionShopifyMutation) ClearConnection() {
	m.clearedconnection = true
}

// ConnectionCleared reports if the "connection" edge to the Connection entity was cleared.
func (m *ConnectionShopifyMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionID returns the "connection" edge ID in the mutation.
func (m *ConnectionShopifyMutation) ConnectionID() (id pulid.ID, exists bool) {
	if m.connection != nil {
		return *m.connection, true
	}
	return
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *ConnectionShopifyMutation) ConnectionIDs() (ids []pulid.ID) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *ConnectionShopifyMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// Where appends a list predicates to the ConnectionShopifyMutation builder.
func (m *ConnectionShopifyMutation) Where(ps ...predicate.ConnectionShopify) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConnectionShopifyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConnectionShopifyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ConnectionShopify, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConnectionShopifyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConnectionShopifyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ConnectionShopify).
func (m *ConnectionShopifyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConnectionShopifyMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, connectionshopify.FieldTenantID)
	}
	if m.rate_integration != nil {
		fields = append(fields, connectionshopify.FieldRateIntegration)
	}
	if m.store_url != nil {
		fields = append(fields, connectionshopify.FieldStoreURL)
	}
	if m.api_key != nil {
		fields = append(fields, connectionshopify.FieldAPIKey)
	}
	if m.lookup_key != nil {
		fields = append(fields, connectionshopify.FieldLookupKey)
	}
	if m.sync_from != nil {
		fields = append(fields, connectionshopify.FieldSyncFrom)
	}
	if m.filter_tags != nil {
		fields = append(fields, connectionshopify.FieldFilterTags)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConnectionShopifyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case connectionshopify.FieldTenantID:
		return m.TenantID()
	case connectionshopify.FieldRateIntegration:
		return m.RateIntegration()
	case connectionshopify.FieldStoreURL:
		return m.StoreURL()
	case connectionshopify.FieldAPIKey:
		return m.APIKey()
	case connectionshopify.FieldLookupKey:
		return m.LookupKey()
	case connectionshopify.FieldSyncFrom:
		return m.SyncFrom()
	case connectionshopify.FieldFilterTags:
		return m.FilterTags()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConnectionShopifyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case connectionshopify.FieldTenantID:
		return m.OldTenantID(ctx)
	case connectionshopify.FieldRateIntegration:
		return m.OldRateIntegration(ctx)
	case connectionshopify.FieldStoreURL:
		return m.OldStoreURL(ctx)
	case connectionshopify.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case connectionshopify.FieldLookupKey:
		return m.OldLookupKey(ctx)
	case connectionshopify.FieldSyncFrom:
		return m.OldSyncFrom(ctx)
	case connectionshopify.FieldFilterTags:
		return m.OldFilterTags(ctx)
	}
	return nil, fmt.Errorf("unknown ConnectionShopify field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionShopifyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case connectionshopify.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case connectionshopify.FieldRateIntegration:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRateIntegration(v)
		return nil
	case connectionshopify.FieldStoreURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoreURL(v)
		return nil
	case connectionshopify.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case connectionshopify.FieldLookupKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLookupKey(v)
		return nil
	case connectionshopify.FieldSyncFrom:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSyncFrom(v)
		return nil
	case connectionshopify.FieldFilterTags:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilterTags(v)
		return nil
	}
	return fmt.Errorf("unknown ConnectionShopify field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConnectionShopifyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConnectionShopifyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConnectionShopifyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ConnectionShopify numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConnectionShopifyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(connectionshopify.FieldStoreURL) {
		fields = append(fields, connectionshopify.FieldStoreURL)
	}
	if m.FieldCleared(connectionshopify.FieldAPIKey) {
		fields = append(fields, connectionshopify.FieldAPIKey)
	}
	if m.FieldCleared(connectionshopify.FieldLookupKey) {
		fields = append(fields, connectionshopify.FieldLookupKey)
	}
	if m.FieldCleared(connectionshopify.FieldSyncFrom) {
		fields = append(fields, connectionshopify.FieldSyncFrom)
	}
	if m.FieldCleared(connectionshopify.FieldFilterTags) {
		fields = append(fields, connectionshopify.FieldFilterTags)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConnectionShopifyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConnectionShopifyMutation) ClearField(name string) error {
	switch name {
	case connectionshopify.FieldStoreURL:
		m.ClearStoreURL()
		return nil
	case connectionshopify.FieldAPIKey:
		m.ClearAPIKey()
		return nil
	case connectionshopify.FieldLookupKey:
		m.ClearLookupKey()
		return nil
	case connectionshopify.FieldSyncFrom:
		m.ClearSyncFrom()
		return nil
	case connectionshopify.FieldFilterTags:
		m.ClearFilterTags()
		return nil
	}
	return fmt.Errorf("unknown ConnectionShopify nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConnectionShopifyMutation) ResetField(name string) error {
	switch name {
	case connectionshopify.FieldTenantID:
		m.ResetTenantID()
		return nil
	case connectionshopify.FieldRateIntegration:
		m.ResetRateIntegration()
		return nil
	case connectionshopify.FieldStoreURL:
		m.ResetStoreURL()
		return nil
	case connectionshopify.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case connectionshopify.FieldLookupKey:
		m.ResetLookupKey()
		return nil
	case connectionshopify.FieldSyncFrom:
		m.ResetSyncFrom()
		return nil
	case connectionshopify.FieldFilterTags:
		m.ResetFilterTags()
		return nil
	}
	return fmt.Errorf("unknown ConnectionShopify field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConnectionShopifyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, connectionshopify.EdgeTenant)
	}
	if m.connection != nil {
		edges = append(edges, connectionshopify.EdgeConnection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConnectionShopifyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case connectionshopify.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case connectionshopify.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConnectionShopifyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConnectionShopifyMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConnectionShopifyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, connectionshopify.EdgeTenant)
	}
	if m.clearedconnection {
		edges = append(edges, connectionshopify.EdgeConnection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConnectionShopifyMutation) EdgeCleared(name string) bool {
	switch name {
	case connectionshopify.EdgeTenant:
		return m.clearedtenant
	case connectionshopify.EdgeConnection:
		return m.clearedconnection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConnectionShopifyMutation) ClearEdge(name string) error {
	switch name {
	case connectionshopify.EdgeTenant:
		m.ClearTenant()
		return nil
	case connectionshopify.EdgeConnection:
		m.ClearConnection()
		return nil
	}
	return fmt.Errorf("unknown ConnectionShopify unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConnectionShopifyMutation) ResetEdge(name string) error {
	switch name {
	case connectionshopify.EdgeTenant:
		m.ResetTenant()
		return nil
	case connectionshopify.EdgeConnection:
		m.ResetConnection()
		return nil
	}
	return fmt.Errorf("unknown ConnectionShopify edge %s", name)
}

// ConsolidationMutation represents an operation that mutates the Consolidation nodes in the graph.
type ConsolidationMutation struct {
	config
	op                         Op
	typ                        string
	id                         *pulid.ID
	public_id                  *string
	description                *string
	status                     *consolidation.Status
	created_at                 *time.Time
	clearedFields              map[string]struct{}
	tenant                     *pulid.ID
	clearedtenant              bool
	pallets                    map[pulid.ID]struct{}
	removedpallets             map[pulid.ID]struct{}
	clearedpallets             bool
	orders                     map[pulid.ID]struct{}
	removedorders              map[pulid.ID]struct{}
	clearedorders              bool
	delivery_option            *pulid.ID
	cleareddelivery_option     bool
	recipient                  *pulid.ID
	clearedrecipient           bool
	sender                     *pulid.ID
	clearedsender              bool
	shipment                   *pulid.ID
	clearedshipment            bool
	cancelled_shipments        map[pulid.ID]struct{}
	removedcancelled_shipments map[pulid.ID]struct{}
	clearedcancelled_shipments bool
	done                       bool
	oldValue                   func(context.Context) (*Consolidation, error)
	predicates                 []predicate.Consolidation
}

var _ ent.Mutation = (*ConsolidationMutation)(nil)

// consolidationOption allows management of the mutation configuration using functional options.
type consolidationOption func(*ConsolidationMutation)

// newConsolidationMutation creates new mutation for the Consolidation entity.
func newConsolidationMutation(c config, op Op, opts ...consolidationOption) *ConsolidationMutation {
	m := &ConsolidationMutation{
		config:        c,
		op:            op,
		typ:           TypeConsolidation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withConsolidationID sets the ID field of the mutation.
func withConsolidationID(id pulid.ID) consolidationOption {
	return func(m *ConsolidationMutation) {
		var (
			err   error
			once  sync.Once
			value *Consolidation
		)
		m.oldValue = func(ctx context.Context) (*Consolidation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Consolidation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withConsolidation sets the old Consolidation of the mutation.
func withConsolidation(node *Consolidation) consolidationOption {
	return func(m *ConsolidationMutation) {
		m.oldValue = func(context.Context) (*Consolidation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ConsolidationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ConsolidationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Consolidation entities.
func (m *ConsolidationMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ConsolidationMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ConsolidationMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Consolidation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ConsolidationMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ConsolidationMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Consolidation entity.
// If the Consolidation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsolidationMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ConsolidationMutation) ResetTenantID() {
	m.tenant = nil
}

// SetPublicID sets the "public_id" field.
func (m *ConsolidationMutation) SetPublicID(s string) {
	m.public_id = &s
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *ConsolidationMutation) PublicID() (r string, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the Consolidation entity.
// If the Consolidation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsolidationMutation) OldPublicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *ConsolidationMutation) ResetPublicID() {
	m.public_id = nil
}

// SetDescription sets the "description" field.
func (m *ConsolidationMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ConsolidationMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Consolidation entity.
// If the Consolidation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsolidationMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ConsolidationMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[consolidation.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ConsolidationMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[consolidation.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ConsolidationMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, consolidation.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *ConsolidationMutation) SetStatus(c consolidation.Status) {
	m.status = &c
}

// Status returns the value of the "status" field in the mutation.
func (m *ConsolidationMutation) Status() (r consolidation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Consolidation entity.
// If the Consolidation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsolidationMutation) OldStatus(ctx context.Context) (v consolidation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ConsolidationMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ConsolidationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ConsolidationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Consolidation entity.
// If the Consolidation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ConsolidationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ConsolidationMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[consolidation.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ConsolidationMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[consolidation.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ConsolidationMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, consolidation.FieldCreatedAt)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ConsolidationMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[consolidation.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ConsolidationMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ConsolidationMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ConsolidationMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddPalletIDs adds the "pallets" edge to the Pallet entity by ids.
func (m *ConsolidationMutation) AddPalletIDs(ids ...pulid.ID) {
	if m.pallets == nil {
		m.pallets = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.pallets[ids[i]] = struct{}{}
	}
}

// ClearPallets clears the "pallets" edge to the Pallet entity.
func (m *ConsolidationMutation) ClearPallets() {
	m.clearedpallets = true
}

// PalletsCleared reports if the "pallets" edge to the Pallet entity was cleared.
func (m *ConsolidationMutation) PalletsCleared() bool {
	return m.clearedpallets
}

// RemovePalletIDs removes the "pallets" edge to the Pallet entity by IDs.
func (m *ConsolidationMutation) RemovePalletIDs(ids ...pulid.ID) {
	if m.removedpallets == nil {
		m.removedpallets = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.pallets, ids[i])
		m.removedpallets[ids[i]] = struct{}{}
	}
}

// RemovedPallets returns the removed IDs of the "pallets" edge to the Pallet entity.
func (m *ConsolidationMutation) RemovedPalletsIDs() (ids []pulid.ID) {
	for id := range m.removedpallets {
		ids = append(ids, id)
	}
	return
}

// PalletsIDs returns the "pallets" edge IDs in the mutation.
func (m *ConsolidationMutation) PalletsIDs() (ids []pulid.ID) {
	for id := range m.pallets {
		ids = append(ids, id)
	}
	return
}

// ResetPallets resets all changes to the "pallets" edge.
func (m *ConsolidationMutation) ResetPallets() {
	m.pallets = nil
	m.clearedpallets = false
	m.removedpallets = nil
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *ConsolidationMutation) AddOrderIDs(ids ...pulid.ID) {
	if m.orders == nil {
		m.orders = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *ConsolidationMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *ConsolidationMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *ConsolidationMutation) RemoveOrderIDs(ids ...pulid.ID) {
	if m.removedorders == nil {
		m.removedorders = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *ConsolidationMutation) RemovedOrdersIDs() (ids []pulid.ID) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *ConsolidationMutation) OrdersIDs() (ids []pulid.ID) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *ConsolidationMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *ConsolidationMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *ConsolidationMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *ConsolidationMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *ConsolidationMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *ConsolidationMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *ConsolidationMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// SetRecipientID sets the "recipient" edge to the Address entity by id.
func (m *ConsolidationMutation) SetRecipientID(id pulid.ID) {
	m.recipient = &id
}

// ClearRecipient clears the "recipient" edge to the Address entity.
func (m *ConsolidationMutation) ClearRecipient() {
	m.clearedrecipient = true
}

// RecipientCleared reports if the "recipient" edge to the Address entity was cleared.
func (m *ConsolidationMutation) RecipientCleared() bool {
	return m.clearedrecipient
}

// RecipientID returns the "recipient" edge ID in the mutation.
func (m *ConsolidationMutation) RecipientID() (id pulid.ID, exists bool) {
	if m.recipient != nil {
		return *m.recipient, true
	}
	return
}

// RecipientIDs returns the "recipient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecipientID instead. It exists only for internal usage by the builders.
func (m *ConsolidationMutation) RecipientIDs() (ids []pulid.ID) {
	if id := m.recipient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecipient resets all changes to the "recipient" edge.
func (m *ConsolidationMutation) ResetRecipient() {
	m.recipient = nil
	m.clearedrecipient = false
}

// SetSenderID sets the "sender" edge to the Address entity by id.
func (m *ConsolidationMutation) SetSenderID(id pulid.ID) {
	m.sender = &id
}

// ClearSender clears the "sender" edge to the Address entity.
func (m *ConsolidationMutation) ClearSender() {
	m.clearedsender = true
}

// SenderCleared reports if the "sender" edge to the Address entity was cleared.
func (m *ConsolidationMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderID returns the "sender" edge ID in the mutation.
func (m *ConsolidationMutation) SenderID() (id pulid.ID, exists bool) {
	if m.sender != nil {
		return *m.sender, true
	}
	return
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *ConsolidationMutation) SenderIDs() (ids []pulid.ID) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *ConsolidationMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ConsolidationMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ConsolidationMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ConsolidationMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ConsolidationMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ConsolidationMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ConsolidationMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// AddCancelledShipmentIDs adds the "cancelled_shipments" edge to the Shipment entity by ids.
func (m *ConsolidationMutation) AddCancelledShipmentIDs(ids ...pulid.ID) {
	if m.cancelled_shipments == nil {
		m.cancelled_shipments = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.cancelled_shipments[ids[i]] = struct{}{}
	}
}

// ClearCancelledShipments clears the "cancelled_shipments" edge to the Shipment entity.
func (m *ConsolidationMutation) ClearCancelledShipments() {
	m.clearedcancelled_shipments = true
}

// CancelledShipmentsCleared reports if the "cancelled_shipments" edge to the Shipment entity was cleared.
func (m *ConsolidationMutation) CancelledShipmentsCleared() bool {
	return m.clearedcancelled_shipments
}

// RemoveCancelledShipmentIDs removes the "cancelled_shipments" edge to the Shipment entity by IDs.
func (m *ConsolidationMutation) RemoveCancelledShipmentIDs(ids ...pulid.ID) {
	if m.removedcancelled_shipments == nil {
		m.removedcancelled_shipments = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.cancelled_shipments, ids[i])
		m.removedcancelled_shipments[ids[i]] = struct{}{}
	}
}

// RemovedCancelledShipments returns the removed IDs of the "cancelled_shipments" edge to the Shipment entity.
func (m *ConsolidationMutation) RemovedCancelledShipmentsIDs() (ids []pulid.ID) {
	for id := range m.removedcancelled_shipments {
		ids = append(ids, id)
	}
	return
}

// CancelledShipmentsIDs returns the "cancelled_shipments" edge IDs in the mutation.
func (m *ConsolidationMutation) CancelledShipmentsIDs() (ids []pulid.ID) {
	for id := range m.cancelled_shipments {
		ids = append(ids, id)
	}
	return
}

// ResetCancelledShipments resets all changes to the "cancelled_shipments" edge.
func (m *ConsolidationMutation) ResetCancelledShipments() {
	m.cancelled_shipments = nil
	m.clearedcancelled_shipments = false
	m.removedcancelled_shipments = nil
}

// Where appends a list predicates to the ConsolidationMutation builder.
func (m *ConsolidationMutation) Where(ps ...predicate.Consolidation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ConsolidationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ConsolidationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Consolidation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ConsolidationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ConsolidationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Consolidation).
func (m *ConsolidationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ConsolidationMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, consolidation.FieldTenantID)
	}
	if m.public_id != nil {
		fields = append(fields, consolidation.FieldPublicID)
	}
	if m.description != nil {
		fields = append(fields, consolidation.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, consolidation.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, consolidation.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ConsolidationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case consolidation.FieldTenantID:
		return m.TenantID()
	case consolidation.FieldPublicID:
		return m.PublicID()
	case consolidation.FieldDescription:
		return m.Description()
	case consolidation.FieldStatus:
		return m.Status()
	case consolidation.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ConsolidationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case consolidation.FieldTenantID:
		return m.OldTenantID(ctx)
	case consolidation.FieldPublicID:
		return m.OldPublicID(ctx)
	case consolidation.FieldDescription:
		return m.OldDescription(ctx)
	case consolidation.FieldStatus:
		return m.OldStatus(ctx)
	case consolidation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Consolidation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsolidationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case consolidation.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case consolidation.FieldPublicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case consolidation.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case consolidation.FieldStatus:
		v, ok := value.(consolidation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case consolidation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Consolidation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ConsolidationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ConsolidationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ConsolidationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Consolidation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ConsolidationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(consolidation.FieldDescription) {
		fields = append(fields, consolidation.FieldDescription)
	}
	if m.FieldCleared(consolidation.FieldCreatedAt) {
		fields = append(fields, consolidation.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ConsolidationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ConsolidationMutation) ClearField(name string) error {
	switch name {
	case consolidation.FieldDescription:
		m.ClearDescription()
		return nil
	case consolidation.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Consolidation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ConsolidationMutation) ResetField(name string) error {
	switch name {
	case consolidation.FieldTenantID:
		m.ResetTenantID()
		return nil
	case consolidation.FieldPublicID:
		m.ResetPublicID()
		return nil
	case consolidation.FieldDescription:
		m.ResetDescription()
		return nil
	case consolidation.FieldStatus:
		m.ResetStatus()
		return nil
	case consolidation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Consolidation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ConsolidationMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.tenant != nil {
		edges = append(edges, consolidation.EdgeTenant)
	}
	if m.pallets != nil {
		edges = append(edges, consolidation.EdgePallets)
	}
	if m.orders != nil {
		edges = append(edges, consolidation.EdgeOrders)
	}
	if m.delivery_option != nil {
		edges = append(edges, consolidation.EdgeDeliveryOption)
	}
	if m.recipient != nil {
		edges = append(edges, consolidation.EdgeRecipient)
	}
	if m.sender != nil {
		edges = append(edges, consolidation.EdgeSender)
	}
	if m.shipment != nil {
		edges = append(edges, consolidation.EdgeShipment)
	}
	if m.cancelled_shipments != nil {
		edges = append(edges, consolidation.EdgeCancelledShipments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ConsolidationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case consolidation.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case consolidation.EdgePallets:
		ids := make([]ent.Value, 0, len(m.pallets))
		for id := range m.pallets {
			ids = append(ids, id)
		}
		return ids
	case consolidation.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case consolidation.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case consolidation.EdgeRecipient:
		if id := m.recipient; id != nil {
			return []ent.Value{*id}
		}
	case consolidation.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	case consolidation.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	case consolidation.EdgeCancelledShipments:
		ids := make([]ent.Value, 0, len(m.cancelled_shipments))
		for id := range m.cancelled_shipments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ConsolidationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedpallets != nil {
		edges = append(edges, consolidation.EdgePallets)
	}
	if m.removedorders != nil {
		edges = append(edges, consolidation.EdgeOrders)
	}
	if m.removedcancelled_shipments != nil {
		edges = append(edges, consolidation.EdgeCancelledShipments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ConsolidationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case consolidation.EdgePallets:
		ids := make([]ent.Value, 0, len(m.removedpallets))
		for id := range m.removedpallets {
			ids = append(ids, id)
		}
		return ids
	case consolidation.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case consolidation.EdgeCancelledShipments:
		ids := make([]ent.Value, 0, len(m.removedcancelled_shipments))
		for id := range m.removedcancelled_shipments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ConsolidationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedtenant {
		edges = append(edges, consolidation.EdgeTenant)
	}
	if m.clearedpallets {
		edges = append(edges, consolidation.EdgePallets)
	}
	if m.clearedorders {
		edges = append(edges, consolidation.EdgeOrders)
	}
	if m.cleareddelivery_option {
		edges = append(edges, consolidation.EdgeDeliveryOption)
	}
	if m.clearedrecipient {
		edges = append(edges, consolidation.EdgeRecipient)
	}
	if m.clearedsender {
		edges = append(edges, consolidation.EdgeSender)
	}
	if m.clearedshipment {
		edges = append(edges, consolidation.EdgeShipment)
	}
	if m.clearedcancelled_shipments {
		edges = append(edges, consolidation.EdgeCancelledShipments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ConsolidationMutation) EdgeCleared(name string) bool {
	switch name {
	case consolidation.EdgeTenant:
		return m.clearedtenant
	case consolidation.EdgePallets:
		return m.clearedpallets
	case consolidation.EdgeOrders:
		return m.clearedorders
	case consolidation.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case consolidation.EdgeRecipient:
		return m.clearedrecipient
	case consolidation.EdgeSender:
		return m.clearedsender
	case consolidation.EdgeShipment:
		return m.clearedshipment
	case consolidation.EdgeCancelledShipments:
		return m.clearedcancelled_shipments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ConsolidationMutation) ClearEdge(name string) error {
	switch name {
	case consolidation.EdgeTenant:
		m.ClearTenant()
		return nil
	case consolidation.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	case consolidation.EdgeRecipient:
		m.ClearRecipient()
		return nil
	case consolidation.EdgeSender:
		m.ClearSender()
		return nil
	case consolidation.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown Consolidation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ConsolidationMutation) ResetEdge(name string) error {
	switch name {
	case consolidation.EdgeTenant:
		m.ResetTenant()
		return nil
	case consolidation.EdgePallets:
		m.ResetPallets()
		return nil
	case consolidation.EdgeOrders:
		m.ResetOrders()
		return nil
	case consolidation.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case consolidation.EdgeRecipient:
		m.ResetRecipient()
		return nil
	case consolidation.EdgeSender:
		m.ResetSender()
		return nil
	case consolidation.EdgeShipment:
		m.ResetShipment()
		return nil
	case consolidation.EdgeCancelledShipments:
		m.ResetCancelledShipments()
		return nil
	}
	return fmt.Errorf("unknown Consolidation edge %s", name)
}

// ContactMutation represents an operation that mutates the Contact nodes in the graph.
type ContactMutation struct {
	config
	op                     Op
	typ                    string
	id                     *pulid.ID
	name                   *string
	surname                *string
	email                  *string
	phone_number           *string
	clearedFields          map[string]struct{}
	tenant                 *pulid.ID
	clearedtenant          bool
	billing_contact        map[pulid.ID]struct{}
	removedbilling_contact map[pulid.ID]struct{}
	clearedbilling_contact bool
	admin_contact          map[pulid.ID]struct{}
	removedadmin_contact   map[pulid.ID]struct{}
	clearedadmin_contact   bool
	done                   bool
	oldValue               func(context.Context) (*Contact, error)
	predicates             []predicate.Contact
}

var _ ent.Mutation = (*ContactMutation)(nil)

// contactOption allows management of the mutation configuration using functional options.
type contactOption func(*ContactMutation)

// newContactMutation creates new mutation for the Contact entity.
func newContactMutation(c config, op Op, opts ...contactOption) *ContactMutation {
	m := &ContactMutation{
		config:        c,
		op:            op,
		typ:           TypeContact,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withContactID sets the ID field of the mutation.
func withContactID(id pulid.ID) contactOption {
	return func(m *ContactMutation) {
		var (
			err   error
			once  sync.Once
			value *Contact
		)
		m.oldValue = func(ctx context.Context) (*Contact, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Contact.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withContact sets the old Contact of the mutation.
func withContact(node *Contact) contactOption {
	return func(m *ContactMutation) {
		m.oldValue = func(context.Context) (*Contact, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ContactMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ContactMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Contact entities.
func (m *ContactMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ContactMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ContactMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Contact.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ContactMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ContactMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ContactMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *ContactMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ContactMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ContactMutation) ResetName() {
	m.name = nil
}

// SetSurname sets the "surname" field.
func (m *ContactMutation) SetSurname(s string) {
	m.surname = &s
}

// Surname returns the value of the "surname" field in the mutation.
func (m *ContactMutation) Surname() (r string, exists bool) {
	v := m.surname
	if v == nil {
		return
	}
	return *v, true
}

// OldSurname returns the old "surname" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldSurname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurname: %w", err)
	}
	return oldValue.Surname, nil
}

// ResetSurname resets all changes to the "surname" field.
func (m *ContactMutation) ResetSurname() {
	m.surname = nil
}

// SetEmail sets the "email" field.
func (m *ContactMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *ContactMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *ContactMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *ContactMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *ContactMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the Contact entity.
// If the Contact object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ContactMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *ContactMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ContactMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[contact.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ContactMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ContactMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ContactMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddBillingContactIDs adds the "billing_contact" edge to the Tenant entity by ids.
func (m *ContactMutation) AddBillingContactIDs(ids ...pulid.ID) {
	if m.billing_contact == nil {
		m.billing_contact = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.billing_contact[ids[i]] = struct{}{}
	}
}

// ClearBillingContact clears the "billing_contact" edge to the Tenant entity.
func (m *ContactMutation) ClearBillingContact() {
	m.clearedbilling_contact = true
}

// BillingContactCleared reports if the "billing_contact" edge to the Tenant entity was cleared.
func (m *ContactMutation) BillingContactCleared() bool {
	return m.clearedbilling_contact
}

// RemoveBillingContactIDs removes the "billing_contact" edge to the Tenant entity by IDs.
func (m *ContactMutation) RemoveBillingContactIDs(ids ...pulid.ID) {
	if m.removedbilling_contact == nil {
		m.removedbilling_contact = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.billing_contact, ids[i])
		m.removedbilling_contact[ids[i]] = struct{}{}
	}
}

// RemovedBillingContact returns the removed IDs of the "billing_contact" edge to the Tenant entity.
func (m *ContactMutation) RemovedBillingContactIDs() (ids []pulid.ID) {
	for id := range m.removedbilling_contact {
		ids = append(ids, id)
	}
	return
}

// BillingContactIDs returns the "billing_contact" edge IDs in the mutation.
func (m *ContactMutation) BillingContactIDs() (ids []pulid.ID) {
	for id := range m.billing_contact {
		ids = append(ids, id)
	}
	return
}

// ResetBillingContact resets all changes to the "billing_contact" edge.
func (m *ContactMutation) ResetBillingContact() {
	m.billing_contact = nil
	m.clearedbilling_contact = false
	m.removedbilling_contact = nil
}

// AddAdminContactIDs adds the "admin_contact" edge to the Tenant entity by ids.
func (m *ContactMutation) AddAdminContactIDs(ids ...pulid.ID) {
	if m.admin_contact == nil {
		m.admin_contact = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.admin_contact[ids[i]] = struct{}{}
	}
}

// ClearAdminContact clears the "admin_contact" edge to the Tenant entity.
func (m *ContactMutation) ClearAdminContact() {
	m.clearedadmin_contact = true
}

// AdminContactCleared reports if the "admin_contact" edge to the Tenant entity was cleared.
func (m *ContactMutation) AdminContactCleared() bool {
	return m.clearedadmin_contact
}

// RemoveAdminContactIDs removes the "admin_contact" edge to the Tenant entity by IDs.
func (m *ContactMutation) RemoveAdminContactIDs(ids ...pulid.ID) {
	if m.removedadmin_contact == nil {
		m.removedadmin_contact = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.admin_contact, ids[i])
		m.removedadmin_contact[ids[i]] = struct{}{}
	}
}

// RemovedAdminContact returns the removed IDs of the "admin_contact" edge to the Tenant entity.
func (m *ContactMutation) RemovedAdminContactIDs() (ids []pulid.ID) {
	for id := range m.removedadmin_contact {
		ids = append(ids, id)
	}
	return
}

// AdminContactIDs returns the "admin_contact" edge IDs in the mutation.
func (m *ContactMutation) AdminContactIDs() (ids []pulid.ID) {
	for id := range m.admin_contact {
		ids = append(ids, id)
	}
	return
}

// ResetAdminContact resets all changes to the "admin_contact" edge.
func (m *ContactMutation) ResetAdminContact() {
	m.admin_contact = nil
	m.clearedadmin_contact = false
	m.removedadmin_contact = nil
}

// Where appends a list predicates to the ContactMutation builder.
func (m *ContactMutation) Where(ps ...predicate.Contact) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ContactMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ContactMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Contact, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ContactMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ContactMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Contact).
func (m *ContactMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ContactMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, contact.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, contact.FieldName)
	}
	if m.surname != nil {
		fields = append(fields, contact.FieldSurname)
	}
	if m.email != nil {
		fields = append(fields, contact.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, contact.FieldPhoneNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ContactMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case contact.FieldTenantID:
		return m.TenantID()
	case contact.FieldName:
		return m.Name()
	case contact.FieldSurname:
		return m.Surname()
	case contact.FieldEmail:
		return m.Email()
	case contact.FieldPhoneNumber:
		return m.PhoneNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ContactMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case contact.FieldTenantID:
		return m.OldTenantID(ctx)
	case contact.FieldName:
		return m.OldName(ctx)
	case contact.FieldSurname:
		return m.OldSurname(ctx)
	case contact.FieldEmail:
		return m.OldEmail(ctx)
	case contact.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	}
	return nil, fmt.Errorf("unknown Contact field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) SetField(name string, value ent.Value) error {
	switch name {
	case contact.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case contact.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case contact.FieldSurname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurname(v)
		return nil
	case contact.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case contact.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ContactMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ContactMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ContactMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Contact numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ContactMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ContactMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ContactMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Contact nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ContactMutation) ResetField(name string) error {
	switch name {
	case contact.FieldTenantID:
		m.ResetTenantID()
		return nil
	case contact.FieldName:
		m.ResetName()
		return nil
	case contact.FieldSurname:
		m.ResetSurname()
		return nil
	case contact.FieldEmail:
		m.ResetEmail()
		return nil
	case contact.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	}
	return fmt.Errorf("unknown Contact field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ContactMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, contact.EdgeTenant)
	}
	if m.billing_contact != nil {
		edges = append(edges, contact.EdgeBillingContact)
	}
	if m.admin_contact != nil {
		edges = append(edges, contact.EdgeAdminContact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ContactMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case contact.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case contact.EdgeBillingContact:
		ids := make([]ent.Value, 0, len(m.billing_contact))
		for id := range m.billing_contact {
			ids = append(ids, id)
		}
		return ids
	case contact.EdgeAdminContact:
		ids := make([]ent.Value, 0, len(m.admin_contact))
		for id := range m.admin_contact {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ContactMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedbilling_contact != nil {
		edges = append(edges, contact.EdgeBillingContact)
	}
	if m.removedadmin_contact != nil {
		edges = append(edges, contact.EdgeAdminContact)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ContactMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case contact.EdgeBillingContact:
		ids := make([]ent.Value, 0, len(m.removedbilling_contact))
		for id := range m.removedbilling_contact {
			ids = append(ids, id)
		}
		return ids
	case contact.EdgeAdminContact:
		ids := make([]ent.Value, 0, len(m.removedadmin_contact))
		for id := range m.removedadmin_contact {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ContactMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, contact.EdgeTenant)
	}
	if m.clearedbilling_contact {
		edges = append(edges, contact.EdgeBillingContact)
	}
	if m.clearedadmin_contact {
		edges = append(edges, contact.EdgeAdminContact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ContactMutation) EdgeCleared(name string) bool {
	switch name {
	case contact.EdgeTenant:
		return m.clearedtenant
	case contact.EdgeBillingContact:
		return m.clearedbilling_contact
	case contact.EdgeAdminContact:
		return m.clearedadmin_contact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ContactMutation) ClearEdge(name string) error {
	switch name {
	case contact.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Contact unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ContactMutation) ResetEdge(name string) error {
	switch name {
	case contact.EdgeTenant:
		m.ResetTenant()
		return nil
	case contact.EdgeBillingContact:
		m.ResetBillingContact()
		return nil
	case contact.EdgeAdminContact:
		m.ResetAdminContact()
		return nil
	}
	return fmt.Errorf("unknown Contact edge %s", name)
}

// CountryMutation represents an operation that mutates the Country nodes in the graph.
type CountryMutation struct {
	config
	op                                                    Op
	typ                                                   string
	id                                                    *pulid.ID
	label                                                 *string
	alpha_2                                               *string
	alpha_3                                               *string
	code                                                  *string
	region                                                *country.Region
	clearedFields                                         map[string]struct{}
	delivery_rule                                         map[pulid.ID]struct{}
	removeddelivery_rule                                  map[pulid.ID]struct{}
	cleareddelivery_rule                                  bool
	address                                               map[pulid.ID]struct{}
	removedaddress                                        map[pulid.ID]struct{}
	clearedaddress                                        bool
	address_global                                        map[pulid.ID]struct{}
	removedaddress_global                                 map[pulid.ID]struct{}
	clearedaddress_global                                 bool
	carrier_additional_service_post_nord_consignee        map[pulid.ID]struct{}
	removedcarrier_additional_service_post_nord_consignee map[pulid.ID]struct{}
	clearedcarrier_additional_service_post_nord_consignee bool
	carrier_additional_service_post_nord_consignor        map[pulid.ID]struct{}
	removedcarrier_additional_service_post_nord_consignor map[pulid.ID]struct{}
	clearedcarrier_additional_service_post_nord_consignor bool
	carrier_additional_service_gls_consignee              map[pulid.ID]struct{}
	removedcarrier_additional_service_gls_consignee       map[pulid.ID]struct{}
	clearedcarrier_additional_service_gls_consignee       bool
	carrier_additional_service_gls_consignor              map[pulid.ID]struct{}
	removedcarrier_additional_service_gls_consignor       map[pulid.ID]struct{}
	clearedcarrier_additional_service_gls_consignor       bool
	country_harmonized_code                               map[pulid.ID]struct{}
	removedcountry_harmonized_code                        map[pulid.ID]struct{}
	clearedcountry_harmonized_code                        bool
	inventory_item                                        map[pulid.ID]struct{}
	removedinventory_item                                 map[pulid.ID]struct{}
	clearedinventory_item                                 bool
	done                                                  bool
	oldValue                                              func(context.Context) (*Country, error)
	predicates                                            []predicate.Country
}

var _ ent.Mutation = (*CountryMutation)(nil)

// countryOption allows management of the mutation configuration using functional options.
type countryOption func(*CountryMutation)

// newCountryMutation creates new mutation for the Country entity.
func newCountryMutation(c config, op Op, opts ...countryOption) *CountryMutation {
	m := &CountryMutation{
		config:        c,
		op:            op,
		typ:           TypeCountry,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryID sets the ID field of the mutation.
func withCountryID(id pulid.ID) countryOption {
	return func(m *CountryMutation) {
		var (
			err   error
			once  sync.Once
			value *Country
		)
		m.oldValue = func(ctx context.Context) (*Country, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Country.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountry sets the old Country of the mutation.
func withCountry(node *Country) countryOption {
	return func(m *CountryMutation) {
		m.oldValue = func(context.Context) (*Country, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Country entities.
func (m *CountryMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Country.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *CountryMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *CountryMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *CountryMutation) ResetLabel() {
	m.label = nil
}

// SetAlpha2 sets the "alpha_2" field.
func (m *CountryMutation) SetAlpha2(s string) {
	m.alpha_2 = &s
}

// Alpha2 returns the value of the "alpha_2" field in the mutation.
func (m *CountryMutation) Alpha2() (r string, exists bool) {
	v := m.alpha_2
	if v == nil {
		return
	}
	return *v, true
}

// OldAlpha2 returns the old "alpha_2" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldAlpha2(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlpha2 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlpha2 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlpha2: %w", err)
	}
	return oldValue.Alpha2, nil
}

// ResetAlpha2 resets all changes to the "alpha_2" field.
func (m *CountryMutation) ResetAlpha2() {
	m.alpha_2 = nil
}

// SetAlpha3 sets the "alpha_3" field.
func (m *CountryMutation) SetAlpha3(s string) {
	m.alpha_3 = &s
}

// Alpha3 returns the value of the "alpha_3" field in the mutation.
func (m *CountryMutation) Alpha3() (r string, exists bool) {
	v := m.alpha_3
	if v == nil {
		return
	}
	return *v, true
}

// OldAlpha3 returns the old "alpha_3" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldAlpha3(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlpha3 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlpha3 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlpha3: %w", err)
	}
	return oldValue.Alpha3, nil
}

// ResetAlpha3 resets all changes to the "alpha_3" field.
func (m *CountryMutation) ResetAlpha3() {
	m.alpha_3 = nil
}

// SetCode sets the "code" field.
func (m *CountryMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CountryMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CountryMutation) ResetCode() {
	m.code = nil
}

// SetRegion sets the "region" field.
func (m *CountryMutation) SetRegion(c country.Region) {
	m.region = &c
}

// Region returns the value of the "region" field in the mutation.
func (m *CountryMutation) Region() (r country.Region, exists bool) {
	v := m.region
	if v == nil {
		return
	}
	return *v, true
}

// OldRegion returns the old "region" field's value of the Country entity.
// If the Country object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryMutation) OldRegion(ctx context.Context) (v country.Region, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegion is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegion requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegion: %w", err)
	}
	return oldValue.Region, nil
}

// ResetRegion resets all changes to the "region" field.
func (m *CountryMutation) ResetRegion() {
	m.region = nil
}

// AddDeliveryRuleIDs adds the "delivery_rule" edge to the DeliveryRule entity by ids.
func (m *CountryMutation) AddDeliveryRuleIDs(ids ...pulid.ID) {
	if m.delivery_rule == nil {
		m.delivery_rule = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_rule[ids[i]] = struct{}{}
	}
}

// ClearDeliveryRule clears the "delivery_rule" edge to the DeliveryRule entity.
func (m *CountryMutation) ClearDeliveryRule() {
	m.cleareddelivery_rule = true
}

// DeliveryRuleCleared reports if the "delivery_rule" edge to the DeliveryRule entity was cleared.
func (m *CountryMutation) DeliveryRuleCleared() bool {
	return m.cleareddelivery_rule
}

// RemoveDeliveryRuleIDs removes the "delivery_rule" edge to the DeliveryRule entity by IDs.
func (m *CountryMutation) RemoveDeliveryRuleIDs(ids ...pulid.ID) {
	if m.removeddelivery_rule == nil {
		m.removeddelivery_rule = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_rule, ids[i])
		m.removeddelivery_rule[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryRule returns the removed IDs of the "delivery_rule" edge to the DeliveryRule entity.
func (m *CountryMutation) RemovedDeliveryRuleIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_rule {
		ids = append(ids, id)
	}
	return
}

// DeliveryRuleIDs returns the "delivery_rule" edge IDs in the mutation.
func (m *CountryMutation) DeliveryRuleIDs() (ids []pulid.ID) {
	for id := range m.delivery_rule {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryRule resets all changes to the "delivery_rule" edge.
func (m *CountryMutation) ResetDeliveryRule() {
	m.delivery_rule = nil
	m.cleareddelivery_rule = false
	m.removeddelivery_rule = nil
}

// AddAddresIDs adds the "address" edge to the Address entity by ids.
func (m *CountryMutation) AddAddresIDs(ids ...pulid.ID) {
	if m.address == nil {
		m.address = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.address[ids[i]] = struct{}{}
	}
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *CountryMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *CountryMutation) AddressCleared() bool {
	return m.clearedaddress
}

// RemoveAddresIDs removes the "address" edge to the Address entity by IDs.
func (m *CountryMutation) RemoveAddresIDs(ids ...pulid.ID) {
	if m.removedaddress == nil {
		m.removedaddress = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.address, ids[i])
		m.removedaddress[ids[i]] = struct{}{}
	}
}

// RemovedAddress returns the removed IDs of the "address" edge to the Address entity.
func (m *CountryMutation) RemovedAddressIDs() (ids []pulid.ID) {
	for id := range m.removedaddress {
		ids = append(ids, id)
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
func (m *CountryMutation) AddressIDs() (ids []pulid.ID) {
	for id := range m.address {
		ids = append(ids, id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *CountryMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
	m.removedaddress = nil
}

// AddAddressGlobalIDs adds the "address_global" edge to the AddressGlobal entity by ids.
func (m *CountryMutation) AddAddressGlobalIDs(ids ...pulid.ID) {
	if m.address_global == nil {
		m.address_global = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.address_global[ids[i]] = struct{}{}
	}
}

// ClearAddressGlobal clears the "address_global" edge to the AddressGlobal entity.
func (m *CountryMutation) ClearAddressGlobal() {
	m.clearedaddress_global = true
}

// AddressGlobalCleared reports if the "address_global" edge to the AddressGlobal entity was cleared.
func (m *CountryMutation) AddressGlobalCleared() bool {
	return m.clearedaddress_global
}

// RemoveAddressGlobalIDs removes the "address_global" edge to the AddressGlobal entity by IDs.
func (m *CountryMutation) RemoveAddressGlobalIDs(ids ...pulid.ID) {
	if m.removedaddress_global == nil {
		m.removedaddress_global = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.address_global, ids[i])
		m.removedaddress_global[ids[i]] = struct{}{}
	}
}

// RemovedAddressGlobal returns the removed IDs of the "address_global" edge to the AddressGlobal entity.
func (m *CountryMutation) RemovedAddressGlobalIDs() (ids []pulid.ID) {
	for id := range m.removedaddress_global {
		ids = append(ids, id)
	}
	return
}

// AddressGlobalIDs returns the "address_global" edge IDs in the mutation.
func (m *CountryMutation) AddressGlobalIDs() (ids []pulid.ID) {
	for id := range m.address_global {
		ids = append(ids, id)
	}
	return
}

// ResetAddressGlobal resets all changes to the "address_global" edge.
func (m *CountryMutation) ResetAddressGlobal() {
	m.address_global = nil
	m.clearedaddress_global = false
	m.removedaddress_global = nil
}

// AddCarrierAdditionalServicePostNordConsigneeIDs adds the "carrier_additional_service_post_nord_consignee" edge to the CarrierAdditionalServicePostNord entity by ids.
func (m *CountryMutation) AddCarrierAdditionalServicePostNordConsigneeIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_post_nord_consignee == nil {
		m.carrier_additional_service_post_nord_consignee = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_post_nord_consignee[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServicePostNordConsignee clears the "carrier_additional_service_post_nord_consignee" edge to the CarrierAdditionalServicePostNord entity.
func (m *CountryMutation) ClearCarrierAdditionalServicePostNordConsignee() {
	m.clearedcarrier_additional_service_post_nord_consignee = true
}

// CarrierAdditionalServicePostNordConsigneeCleared reports if the "carrier_additional_service_post_nord_consignee" edge to the CarrierAdditionalServicePostNord entity was cleared.
func (m *CountryMutation) CarrierAdditionalServicePostNordConsigneeCleared() bool {
	return m.clearedcarrier_additional_service_post_nord_consignee
}

// RemoveCarrierAdditionalServicePostNordConsigneeIDs removes the "carrier_additional_service_post_nord_consignee" edge to the CarrierAdditionalServicePostNord entity by IDs.
func (m *CountryMutation) RemoveCarrierAdditionalServicePostNordConsigneeIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_post_nord_consignee == nil {
		m.removedcarrier_additional_service_post_nord_consignee = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_post_nord_consignee, ids[i])
		m.removedcarrier_additional_service_post_nord_consignee[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServicePostNordConsignee returns the removed IDs of the "carrier_additional_service_post_nord_consignee" edge to the CarrierAdditionalServicePostNord entity.
func (m *CountryMutation) RemovedCarrierAdditionalServicePostNordConsigneeIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_post_nord_consignee {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServicePostNordConsigneeIDs returns the "carrier_additional_service_post_nord_consignee" edge IDs in the mutation.
func (m *CountryMutation) CarrierAdditionalServicePostNordConsigneeIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_post_nord_consignee {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServicePostNordConsignee resets all changes to the "carrier_additional_service_post_nord_consignee" edge.
func (m *CountryMutation) ResetCarrierAdditionalServicePostNordConsignee() {
	m.carrier_additional_service_post_nord_consignee = nil
	m.clearedcarrier_additional_service_post_nord_consignee = false
	m.removedcarrier_additional_service_post_nord_consignee = nil
}

// AddCarrierAdditionalServicePostNordConsignorIDs adds the "carrier_additional_service_post_nord_consignor" edge to the CarrierAdditionalServicePostNord entity by ids.
func (m *CountryMutation) AddCarrierAdditionalServicePostNordConsignorIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_post_nord_consignor == nil {
		m.carrier_additional_service_post_nord_consignor = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_post_nord_consignor[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServicePostNordConsignor clears the "carrier_additional_service_post_nord_consignor" edge to the CarrierAdditionalServicePostNord entity.
func (m *CountryMutation) ClearCarrierAdditionalServicePostNordConsignor() {
	m.clearedcarrier_additional_service_post_nord_consignor = true
}

// CarrierAdditionalServicePostNordConsignorCleared reports if the "carrier_additional_service_post_nord_consignor" edge to the CarrierAdditionalServicePostNord entity was cleared.
func (m *CountryMutation) CarrierAdditionalServicePostNordConsignorCleared() bool {
	return m.clearedcarrier_additional_service_post_nord_consignor
}

// RemoveCarrierAdditionalServicePostNordConsignorIDs removes the "carrier_additional_service_post_nord_consignor" edge to the CarrierAdditionalServicePostNord entity by IDs.
func (m *CountryMutation) RemoveCarrierAdditionalServicePostNordConsignorIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_post_nord_consignor == nil {
		m.removedcarrier_additional_service_post_nord_consignor = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_post_nord_consignor, ids[i])
		m.removedcarrier_additional_service_post_nord_consignor[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServicePostNordConsignor returns the removed IDs of the "carrier_additional_service_post_nord_consignor" edge to the CarrierAdditionalServicePostNord entity.
func (m *CountryMutation) RemovedCarrierAdditionalServicePostNordConsignorIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_post_nord_consignor {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServicePostNordConsignorIDs returns the "carrier_additional_service_post_nord_consignor" edge IDs in the mutation.
func (m *CountryMutation) CarrierAdditionalServicePostNordConsignorIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_post_nord_consignor {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServicePostNordConsignor resets all changes to the "carrier_additional_service_post_nord_consignor" edge.
func (m *CountryMutation) ResetCarrierAdditionalServicePostNordConsignor() {
	m.carrier_additional_service_post_nord_consignor = nil
	m.clearedcarrier_additional_service_post_nord_consignor = false
	m.removedcarrier_additional_service_post_nord_consignor = nil
}

// AddCarrierAdditionalServiceGLSConsigneeIDs adds the "carrier_additional_service_gls_consignee" edge to the CarrierAdditionalServiceGLS entity by ids.
func (m *CountryMutation) AddCarrierAdditionalServiceGLSConsigneeIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_gls_consignee == nil {
		m.carrier_additional_service_gls_consignee = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_gls_consignee[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceGLSConsignee clears the "carrier_additional_service_gls_consignee" edge to the CarrierAdditionalServiceGLS entity.
func (m *CountryMutation) ClearCarrierAdditionalServiceGLSConsignee() {
	m.clearedcarrier_additional_service_gls_consignee = true
}

// CarrierAdditionalServiceGLSConsigneeCleared reports if the "carrier_additional_service_gls_consignee" edge to the CarrierAdditionalServiceGLS entity was cleared.
func (m *CountryMutation) CarrierAdditionalServiceGLSConsigneeCleared() bool {
	return m.clearedcarrier_additional_service_gls_consignee
}

// RemoveCarrierAdditionalServiceGLSConsigneeIDs removes the "carrier_additional_service_gls_consignee" edge to the CarrierAdditionalServiceGLS entity by IDs.
func (m *CountryMutation) RemoveCarrierAdditionalServiceGLSConsigneeIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_gls_consignee == nil {
		m.removedcarrier_additional_service_gls_consignee = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_gls_consignee, ids[i])
		m.removedcarrier_additional_service_gls_consignee[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceGLSConsignee returns the removed IDs of the "carrier_additional_service_gls_consignee" edge to the CarrierAdditionalServiceGLS entity.
func (m *CountryMutation) RemovedCarrierAdditionalServiceGLSConsigneeIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_gls_consignee {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceGLSConsigneeIDs returns the "carrier_additional_service_gls_consignee" edge IDs in the mutation.
func (m *CountryMutation) CarrierAdditionalServiceGLSConsigneeIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_gls_consignee {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceGLSConsignee resets all changes to the "carrier_additional_service_gls_consignee" edge.
func (m *CountryMutation) ResetCarrierAdditionalServiceGLSConsignee() {
	m.carrier_additional_service_gls_consignee = nil
	m.clearedcarrier_additional_service_gls_consignee = false
	m.removedcarrier_additional_service_gls_consignee = nil
}

// AddCarrierAdditionalServiceGLSConsignorIDs adds the "carrier_additional_service_gls_consignor" edge to the CarrierAdditionalServiceGLS entity by ids.
func (m *CountryMutation) AddCarrierAdditionalServiceGLSConsignorIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_gls_consignor == nil {
		m.carrier_additional_service_gls_consignor = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_gls_consignor[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceGLSConsignor clears the "carrier_additional_service_gls_consignor" edge to the CarrierAdditionalServiceGLS entity.
func (m *CountryMutation) ClearCarrierAdditionalServiceGLSConsignor() {
	m.clearedcarrier_additional_service_gls_consignor = true
}

// CarrierAdditionalServiceGLSConsignorCleared reports if the "carrier_additional_service_gls_consignor" edge to the CarrierAdditionalServiceGLS entity was cleared.
func (m *CountryMutation) CarrierAdditionalServiceGLSConsignorCleared() bool {
	return m.clearedcarrier_additional_service_gls_consignor
}

// RemoveCarrierAdditionalServiceGLSConsignorIDs removes the "carrier_additional_service_gls_consignor" edge to the CarrierAdditionalServiceGLS entity by IDs.
func (m *CountryMutation) RemoveCarrierAdditionalServiceGLSConsignorIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_gls_consignor == nil {
		m.removedcarrier_additional_service_gls_consignor = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_gls_consignor, ids[i])
		m.removedcarrier_additional_service_gls_consignor[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceGLSConsignor returns the removed IDs of the "carrier_additional_service_gls_consignor" edge to the CarrierAdditionalServiceGLS entity.
func (m *CountryMutation) RemovedCarrierAdditionalServiceGLSConsignorIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_gls_consignor {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceGLSConsignorIDs returns the "carrier_additional_service_gls_consignor" edge IDs in the mutation.
func (m *CountryMutation) CarrierAdditionalServiceGLSConsignorIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_gls_consignor {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceGLSConsignor resets all changes to the "carrier_additional_service_gls_consignor" edge.
func (m *CountryMutation) ResetCarrierAdditionalServiceGLSConsignor() {
	m.carrier_additional_service_gls_consignor = nil
	m.clearedcarrier_additional_service_gls_consignor = false
	m.removedcarrier_additional_service_gls_consignor = nil
}

// AddCountryHarmonizedCodeIDs adds the "country_harmonized_code" edge to the CountryHarmonizedCode entity by ids.
func (m *CountryMutation) AddCountryHarmonizedCodeIDs(ids ...pulid.ID) {
	if m.country_harmonized_code == nil {
		m.country_harmonized_code = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.country_harmonized_code[ids[i]] = struct{}{}
	}
}

// ClearCountryHarmonizedCode clears the "country_harmonized_code" edge to the CountryHarmonizedCode entity.
func (m *CountryMutation) ClearCountryHarmonizedCode() {
	m.clearedcountry_harmonized_code = true
}

// CountryHarmonizedCodeCleared reports if the "country_harmonized_code" edge to the CountryHarmonizedCode entity was cleared.
func (m *CountryMutation) CountryHarmonizedCodeCleared() bool {
	return m.clearedcountry_harmonized_code
}

// RemoveCountryHarmonizedCodeIDs removes the "country_harmonized_code" edge to the CountryHarmonizedCode entity by IDs.
func (m *CountryMutation) RemoveCountryHarmonizedCodeIDs(ids ...pulid.ID) {
	if m.removedcountry_harmonized_code == nil {
		m.removedcountry_harmonized_code = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.country_harmonized_code, ids[i])
		m.removedcountry_harmonized_code[ids[i]] = struct{}{}
	}
}

// RemovedCountryHarmonizedCode returns the removed IDs of the "country_harmonized_code" edge to the CountryHarmonizedCode entity.
func (m *CountryMutation) RemovedCountryHarmonizedCodeIDs() (ids []pulid.ID) {
	for id := range m.removedcountry_harmonized_code {
		ids = append(ids, id)
	}
	return
}

// CountryHarmonizedCodeIDs returns the "country_harmonized_code" edge IDs in the mutation.
func (m *CountryMutation) CountryHarmonizedCodeIDs() (ids []pulid.ID) {
	for id := range m.country_harmonized_code {
		ids = append(ids, id)
	}
	return
}

// ResetCountryHarmonizedCode resets all changes to the "country_harmonized_code" edge.
func (m *CountryMutation) ResetCountryHarmonizedCode() {
	m.country_harmonized_code = nil
	m.clearedcountry_harmonized_code = false
	m.removedcountry_harmonized_code = nil
}

// AddInventoryItemIDs adds the "inventory_item" edge to the InventoryItem entity by ids.
func (m *CountryMutation) AddInventoryItemIDs(ids ...pulid.ID) {
	if m.inventory_item == nil {
		m.inventory_item = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.inventory_item[ids[i]] = struct{}{}
	}
}

// ClearInventoryItem clears the "inventory_item" edge to the InventoryItem entity.
func (m *CountryMutation) ClearInventoryItem() {
	m.clearedinventory_item = true
}

// InventoryItemCleared reports if the "inventory_item" edge to the InventoryItem entity was cleared.
func (m *CountryMutation) InventoryItemCleared() bool {
	return m.clearedinventory_item
}

// RemoveInventoryItemIDs removes the "inventory_item" edge to the InventoryItem entity by IDs.
func (m *CountryMutation) RemoveInventoryItemIDs(ids ...pulid.ID) {
	if m.removedinventory_item == nil {
		m.removedinventory_item = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.inventory_item, ids[i])
		m.removedinventory_item[ids[i]] = struct{}{}
	}
}

// RemovedInventoryItem returns the removed IDs of the "inventory_item" edge to the InventoryItem entity.
func (m *CountryMutation) RemovedInventoryItemIDs() (ids []pulid.ID) {
	for id := range m.removedinventory_item {
		ids = append(ids, id)
	}
	return
}

// InventoryItemIDs returns the "inventory_item" edge IDs in the mutation.
func (m *CountryMutation) InventoryItemIDs() (ids []pulid.ID) {
	for id := range m.inventory_item {
		ids = append(ids, id)
	}
	return
}

// ResetInventoryItem resets all changes to the "inventory_item" edge.
func (m *CountryMutation) ResetInventoryItem() {
	m.inventory_item = nil
	m.clearedinventory_item = false
	m.removedinventory_item = nil
}

// Where appends a list predicates to the CountryMutation builder.
func (m *CountryMutation) Where(ps ...predicate.Country) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Country, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Country).
func (m *CountryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.label != nil {
		fields = append(fields, country.FieldLabel)
	}
	if m.alpha_2 != nil {
		fields = append(fields, country.FieldAlpha2)
	}
	if m.alpha_3 != nil {
		fields = append(fields, country.FieldAlpha3)
	}
	if m.code != nil {
		fields = append(fields, country.FieldCode)
	}
	if m.region != nil {
		fields = append(fields, country.FieldRegion)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case country.FieldLabel:
		return m.Label()
	case country.FieldAlpha2:
		return m.Alpha2()
	case country.FieldAlpha3:
		return m.Alpha3()
	case country.FieldCode:
		return m.Code()
	case country.FieldRegion:
		return m.Region()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case country.FieldLabel:
		return m.OldLabel(ctx)
	case country.FieldAlpha2:
		return m.OldAlpha2(ctx)
	case country.FieldAlpha3:
		return m.OldAlpha3(ctx)
	case country.FieldCode:
		return m.OldCode(ctx)
	case country.FieldRegion:
		return m.OldRegion(ctx)
	}
	return nil, fmt.Errorf("unknown Country field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case country.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case country.FieldAlpha2:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlpha2(v)
		return nil
	case country.FieldAlpha3:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlpha3(v)
		return nil
	case country.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case country.FieldRegion:
		v, ok := value.(country.Region)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegion(v)
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Country numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Country nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryMutation) ResetField(name string) error {
	switch name {
	case country.FieldLabel:
		m.ResetLabel()
		return nil
	case country.FieldAlpha2:
		m.ResetAlpha2()
		return nil
	case country.FieldAlpha3:
		m.ResetAlpha3()
		return nil
	case country.FieldCode:
		m.ResetCode()
		return nil
	case country.FieldRegion:
		m.ResetRegion()
		return nil
	}
	return fmt.Errorf("unknown Country field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.delivery_rule != nil {
		edges = append(edges, country.EdgeDeliveryRule)
	}
	if m.address != nil {
		edges = append(edges, country.EdgeAddress)
	}
	if m.address_global != nil {
		edges = append(edges, country.EdgeAddressGlobal)
	}
	if m.carrier_additional_service_post_nord_consignee != nil {
		edges = append(edges, country.EdgeCarrierAdditionalServicePostNordConsignee)
	}
	if m.carrier_additional_service_post_nord_consignor != nil {
		edges = append(edges, country.EdgeCarrierAdditionalServicePostNordConsignor)
	}
	if m.carrier_additional_service_gls_consignee != nil {
		edges = append(edges, country.EdgeCarrierAdditionalServiceGLSConsignee)
	}
	if m.carrier_additional_service_gls_consignor != nil {
		edges = append(edges, country.EdgeCarrierAdditionalServiceGLSConsignor)
	}
	if m.country_harmonized_code != nil {
		edges = append(edges, country.EdgeCountryHarmonizedCode)
	}
	if m.inventory_item != nil {
		edges = append(edges, country.EdgeInventoryItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeDeliveryRule:
		ids := make([]ent.Value, 0, len(m.delivery_rule))
		for id := range m.delivery_rule {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.address))
		for id := range m.address {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeAddressGlobal:
		ids := make([]ent.Value, 0, len(m.address_global))
		for id := range m.address_global {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCarrierAdditionalServicePostNordConsignee:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_post_nord_consignee))
		for id := range m.carrier_additional_service_post_nord_consignee {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCarrierAdditionalServicePostNordConsignor:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_post_nord_consignor))
		for id := range m.carrier_additional_service_post_nord_consignor {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCarrierAdditionalServiceGLSConsignee:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_gls_consignee))
		for id := range m.carrier_additional_service_gls_consignee {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCarrierAdditionalServiceGLSConsignor:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_gls_consignor))
		for id := range m.carrier_additional_service_gls_consignor {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCountryHarmonizedCode:
		ids := make([]ent.Value, 0, len(m.country_harmonized_code))
		for id := range m.country_harmonized_code {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeInventoryItem:
		ids := make([]ent.Value, 0, len(m.inventory_item))
		for id := range m.inventory_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removeddelivery_rule != nil {
		edges = append(edges, country.EdgeDeliveryRule)
	}
	if m.removedaddress != nil {
		edges = append(edges, country.EdgeAddress)
	}
	if m.removedaddress_global != nil {
		edges = append(edges, country.EdgeAddressGlobal)
	}
	if m.removedcarrier_additional_service_post_nord_consignee != nil {
		edges = append(edges, country.EdgeCarrierAdditionalServicePostNordConsignee)
	}
	if m.removedcarrier_additional_service_post_nord_consignor != nil {
		edges = append(edges, country.EdgeCarrierAdditionalServicePostNordConsignor)
	}
	if m.removedcarrier_additional_service_gls_consignee != nil {
		edges = append(edges, country.EdgeCarrierAdditionalServiceGLSConsignee)
	}
	if m.removedcarrier_additional_service_gls_consignor != nil {
		edges = append(edges, country.EdgeCarrierAdditionalServiceGLSConsignor)
	}
	if m.removedcountry_harmonized_code != nil {
		edges = append(edges, country.EdgeCountryHarmonizedCode)
	}
	if m.removedinventory_item != nil {
		edges = append(edges, country.EdgeInventoryItem)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case country.EdgeDeliveryRule:
		ids := make([]ent.Value, 0, len(m.removeddelivery_rule))
		for id := range m.removeddelivery_rule {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeAddress:
		ids := make([]ent.Value, 0, len(m.removedaddress))
		for id := range m.removedaddress {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeAddressGlobal:
		ids := make([]ent.Value, 0, len(m.removedaddress_global))
		for id := range m.removedaddress_global {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCarrierAdditionalServicePostNordConsignee:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_post_nord_consignee))
		for id := range m.removedcarrier_additional_service_post_nord_consignee {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCarrierAdditionalServicePostNordConsignor:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_post_nord_consignor))
		for id := range m.removedcarrier_additional_service_post_nord_consignor {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCarrierAdditionalServiceGLSConsignee:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_gls_consignee))
		for id := range m.removedcarrier_additional_service_gls_consignee {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCarrierAdditionalServiceGLSConsignor:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_gls_consignor))
		for id := range m.removedcarrier_additional_service_gls_consignor {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeCountryHarmonizedCode:
		ids := make([]ent.Value, 0, len(m.removedcountry_harmonized_code))
		for id := range m.removedcountry_harmonized_code {
			ids = append(ids, id)
		}
		return ids
	case country.EdgeInventoryItem:
		ids := make([]ent.Value, 0, len(m.removedinventory_item))
		for id := range m.removedinventory_item {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.cleareddelivery_rule {
		edges = append(edges, country.EdgeDeliveryRule)
	}
	if m.clearedaddress {
		edges = append(edges, country.EdgeAddress)
	}
	if m.clearedaddress_global {
		edges = append(edges, country.EdgeAddressGlobal)
	}
	if m.clearedcarrier_additional_service_post_nord_consignee {
		edges = append(edges, country.EdgeCarrierAdditionalServicePostNordConsignee)
	}
	if m.clearedcarrier_additional_service_post_nord_consignor {
		edges = append(edges, country.EdgeCarrierAdditionalServicePostNordConsignor)
	}
	if m.clearedcarrier_additional_service_gls_consignee {
		edges = append(edges, country.EdgeCarrierAdditionalServiceGLSConsignee)
	}
	if m.clearedcarrier_additional_service_gls_consignor {
		edges = append(edges, country.EdgeCarrierAdditionalServiceGLSConsignor)
	}
	if m.clearedcountry_harmonized_code {
		edges = append(edges, country.EdgeCountryHarmonizedCode)
	}
	if m.clearedinventory_item {
		edges = append(edges, country.EdgeInventoryItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryMutation) EdgeCleared(name string) bool {
	switch name {
	case country.EdgeDeliveryRule:
		return m.cleareddelivery_rule
	case country.EdgeAddress:
		return m.clearedaddress
	case country.EdgeAddressGlobal:
		return m.clearedaddress_global
	case country.EdgeCarrierAdditionalServicePostNordConsignee:
		return m.clearedcarrier_additional_service_post_nord_consignee
	case country.EdgeCarrierAdditionalServicePostNordConsignor:
		return m.clearedcarrier_additional_service_post_nord_consignor
	case country.EdgeCarrierAdditionalServiceGLSConsignee:
		return m.clearedcarrier_additional_service_gls_consignee
	case country.EdgeCarrierAdditionalServiceGLSConsignor:
		return m.clearedcarrier_additional_service_gls_consignor
	case country.EdgeCountryHarmonizedCode:
		return m.clearedcountry_harmonized_code
	case country.EdgeInventoryItem:
		return m.clearedinventory_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Country unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryMutation) ResetEdge(name string) error {
	switch name {
	case country.EdgeDeliveryRule:
		m.ResetDeliveryRule()
		return nil
	case country.EdgeAddress:
		m.ResetAddress()
		return nil
	case country.EdgeAddressGlobal:
		m.ResetAddressGlobal()
		return nil
	case country.EdgeCarrierAdditionalServicePostNordConsignee:
		m.ResetCarrierAdditionalServicePostNordConsignee()
		return nil
	case country.EdgeCarrierAdditionalServicePostNordConsignor:
		m.ResetCarrierAdditionalServicePostNordConsignor()
		return nil
	case country.EdgeCarrierAdditionalServiceGLSConsignee:
		m.ResetCarrierAdditionalServiceGLSConsignee()
		return nil
	case country.EdgeCarrierAdditionalServiceGLSConsignor:
		m.ResetCarrierAdditionalServiceGLSConsignor()
		return nil
	case country.EdgeCountryHarmonizedCode:
		m.ResetCountryHarmonizedCode()
		return nil
	case country.EdgeInventoryItem:
		m.ResetInventoryItem()
		return nil
	}
	return fmt.Errorf("unknown Country edge %s", name)
}

// CountryHarmonizedCodeMutation represents an operation that mutates the CountryHarmonizedCode nodes in the graph.
type CountryHarmonizedCodeMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.ID
	code                  *string
	clearedFields         map[string]struct{}
	tenant                *pulid.ID
	clearedtenant         bool
	inventory_item        *pulid.ID
	clearedinventory_item bool
	country               *pulid.ID
	clearedcountry        bool
	done                  bool
	oldValue              func(context.Context) (*CountryHarmonizedCode, error)
	predicates            []predicate.CountryHarmonizedCode
}

var _ ent.Mutation = (*CountryHarmonizedCodeMutation)(nil)

// countryharmonizedcodeOption allows management of the mutation configuration using functional options.
type countryharmonizedcodeOption func(*CountryHarmonizedCodeMutation)

// newCountryHarmonizedCodeMutation creates new mutation for the CountryHarmonizedCode entity.
func newCountryHarmonizedCodeMutation(c config, op Op, opts ...countryharmonizedcodeOption) *CountryHarmonizedCodeMutation {
	m := &CountryHarmonizedCodeMutation{
		config:        c,
		op:            op,
		typ:           TypeCountryHarmonizedCode,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCountryHarmonizedCodeID sets the ID field of the mutation.
func withCountryHarmonizedCodeID(id pulid.ID) countryharmonizedcodeOption {
	return func(m *CountryHarmonizedCodeMutation) {
		var (
			err   error
			once  sync.Once
			value *CountryHarmonizedCode
		)
		m.oldValue = func(ctx context.Context) (*CountryHarmonizedCode, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CountryHarmonizedCode.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCountryHarmonizedCode sets the old CountryHarmonizedCode of the mutation.
func withCountryHarmonizedCode(node *CountryHarmonizedCode) countryharmonizedcodeOption {
	return func(m *CountryHarmonizedCodeMutation) {
		m.oldValue = func(context.Context) (*CountryHarmonizedCode, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CountryHarmonizedCodeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CountryHarmonizedCodeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of CountryHarmonizedCode entities.
func (m *CountryHarmonizedCodeMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CountryHarmonizedCodeMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CountryHarmonizedCodeMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().CountryHarmonizedCode.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *CountryHarmonizedCodeMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *CountryHarmonizedCodeMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the CountryHarmonizedCode entity.
// If the CountryHarmonizedCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryHarmonizedCodeMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *CountryHarmonizedCodeMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCode sets the "code" field.
func (m *CountryHarmonizedCodeMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *CountryHarmonizedCodeMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the CountryHarmonizedCode entity.
// If the CountryHarmonizedCode object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CountryHarmonizedCodeMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *CountryHarmonizedCodeMutation) ResetCode() {
	m.code = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *CountryHarmonizedCodeMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[countryharmonizedcode.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *CountryHarmonizedCodeMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *CountryHarmonizedCodeMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *CountryHarmonizedCodeMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetInventoryItemID sets the "inventory_item" edge to the InventoryItem entity by id.
func (m *CountryHarmonizedCodeMutation) SetInventoryItemID(id pulid.ID) {
	m.inventory_item = &id
}

// ClearInventoryItem clears the "inventory_item" edge to the InventoryItem entity.
func (m *CountryHarmonizedCodeMutation) ClearInventoryItem() {
	m.clearedinventory_item = true
}

// InventoryItemCleared reports if the "inventory_item" edge to the InventoryItem entity was cleared.
func (m *CountryHarmonizedCodeMutation) InventoryItemCleared() bool {
	return m.clearedinventory_item
}

// InventoryItemID returns the "inventory_item" edge ID in the mutation.
func (m *CountryHarmonizedCodeMutation) InventoryItemID() (id pulid.ID, exists bool) {
	if m.inventory_item != nil {
		return *m.inventory_item, true
	}
	return
}

// InventoryItemIDs returns the "inventory_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryItemID instead. It exists only for internal usage by the builders.
func (m *CountryHarmonizedCodeMutation) InventoryItemIDs() (ids []pulid.ID) {
	if id := m.inventory_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventoryItem resets all changes to the "inventory_item" edge.
func (m *CountryHarmonizedCodeMutation) ResetInventoryItem() {
	m.inventory_item = nil
	m.clearedinventory_item = false
}

// SetCountryID sets the "country" edge to the Country entity by id.
func (m *CountryHarmonizedCodeMutation) SetCountryID(id pulid.ID) {
	m.country = &id
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *CountryHarmonizedCodeMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *CountryHarmonizedCodeMutation) CountryCleared() bool {
	return m.clearedcountry
}

// CountryID returns the "country" edge ID in the mutation.
func (m *CountryHarmonizedCodeMutation) CountryID() (id pulid.ID, exists bool) {
	if m.country != nil {
		return *m.country, true
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryID instead. It exists only for internal usage by the builders.
func (m *CountryHarmonizedCodeMutation) CountryIDs() (ids []pulid.ID) {
	if id := m.country; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *CountryHarmonizedCodeMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
}

// Where appends a list predicates to the CountryHarmonizedCodeMutation builder.
func (m *CountryHarmonizedCodeMutation) Where(ps ...predicate.CountryHarmonizedCode) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CountryHarmonizedCodeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CountryHarmonizedCodeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.CountryHarmonizedCode, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CountryHarmonizedCodeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CountryHarmonizedCodeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (CountryHarmonizedCode).
func (m *CountryHarmonizedCodeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CountryHarmonizedCodeMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, countryharmonizedcode.FieldTenantID)
	}
	if m.code != nil {
		fields = append(fields, countryharmonizedcode.FieldCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CountryHarmonizedCodeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case countryharmonizedcode.FieldTenantID:
		return m.TenantID()
	case countryharmonizedcode.FieldCode:
		return m.Code()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CountryHarmonizedCodeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case countryharmonizedcode.FieldTenantID:
		return m.OldTenantID(ctx)
	case countryharmonizedcode.FieldCode:
		return m.OldCode(ctx)
	}
	return nil, fmt.Errorf("unknown CountryHarmonizedCode field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryHarmonizedCodeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case countryharmonizedcode.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case countryharmonizedcode.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	}
	return fmt.Errorf("unknown CountryHarmonizedCode field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CountryHarmonizedCodeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CountryHarmonizedCodeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CountryHarmonizedCodeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CountryHarmonizedCode numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CountryHarmonizedCodeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CountryHarmonizedCodeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CountryHarmonizedCodeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CountryHarmonizedCode nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CountryHarmonizedCodeMutation) ResetField(name string) error {
	switch name {
	case countryharmonizedcode.FieldTenantID:
		m.ResetTenantID()
		return nil
	case countryharmonizedcode.FieldCode:
		m.ResetCode()
		return nil
	}
	return fmt.Errorf("unknown CountryHarmonizedCode field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CountryHarmonizedCodeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, countryharmonizedcode.EdgeTenant)
	}
	if m.inventory_item != nil {
		edges = append(edges, countryharmonizedcode.EdgeInventoryItem)
	}
	if m.country != nil {
		edges = append(edges, countryharmonizedcode.EdgeCountry)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CountryHarmonizedCodeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case countryharmonizedcode.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case countryharmonizedcode.EdgeInventoryItem:
		if id := m.inventory_item; id != nil {
			return []ent.Value{*id}
		}
	case countryharmonizedcode.EdgeCountry:
		if id := m.country; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CountryHarmonizedCodeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CountryHarmonizedCodeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CountryHarmonizedCodeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, countryharmonizedcode.EdgeTenant)
	}
	if m.clearedinventory_item {
		edges = append(edges, countryharmonizedcode.EdgeInventoryItem)
	}
	if m.clearedcountry {
		edges = append(edges, countryharmonizedcode.EdgeCountry)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CountryHarmonizedCodeMutation) EdgeCleared(name string) bool {
	switch name {
	case countryharmonizedcode.EdgeTenant:
		return m.clearedtenant
	case countryharmonizedcode.EdgeInventoryItem:
		return m.clearedinventory_item
	case countryharmonizedcode.EdgeCountry:
		return m.clearedcountry
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CountryHarmonizedCodeMutation) ClearEdge(name string) error {
	switch name {
	case countryharmonizedcode.EdgeTenant:
		m.ClearTenant()
		return nil
	case countryharmonizedcode.EdgeInventoryItem:
		m.ClearInventoryItem()
		return nil
	case countryharmonizedcode.EdgeCountry:
		m.ClearCountry()
		return nil
	}
	return fmt.Errorf("unknown CountryHarmonizedCode unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CountryHarmonizedCodeMutation) ResetEdge(name string) error {
	switch name {
	case countryharmonizedcode.EdgeTenant:
		m.ResetTenant()
		return nil
	case countryharmonizedcode.EdgeInventoryItem:
		m.ResetInventoryItem()
		return nil
	case countryharmonizedcode.EdgeCountry:
		m.ResetCountry()
		return nil
	}
	return fmt.Errorf("unknown CountryHarmonizedCode edge %s", name)
}

// CurrencyMutation represents an operation that mutates the Currency nodes in the graph.
type CurrencyMutation struct {
	config
	op                   Op
	typ                  string
	id                   *pulid.ID
	display              *string
	currency_code        *currency.CurrencyCode
	clearedFields        map[string]struct{}
	order_line           map[pulid.ID]struct{}
	removedorder_line    map[pulid.ID]struct{}
	clearedorder_line    bool
	delivery_rule        map[pulid.ID]struct{}
	removeddelivery_rule map[pulid.ID]struct{}
	cleareddelivery_rule bool
	done                 bool
	oldValue             func(context.Context) (*Currency, error)
	predicates           []predicate.Currency
}

var _ ent.Mutation = (*CurrencyMutation)(nil)

// currencyOption allows management of the mutation configuration using functional options.
type currencyOption func(*CurrencyMutation)

// newCurrencyMutation creates new mutation for the Currency entity.
func newCurrencyMutation(c config, op Op, opts ...currencyOption) *CurrencyMutation {
	m := &CurrencyMutation{
		config:        c,
		op:            op,
		typ:           TypeCurrency,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCurrencyID sets the ID field of the mutation.
func withCurrencyID(id pulid.ID) currencyOption {
	return func(m *CurrencyMutation) {
		var (
			err   error
			once  sync.Once
			value *Currency
		)
		m.oldValue = func(ctx context.Context) (*Currency, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Currency.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCurrency sets the old Currency of the mutation.
func withCurrency(node *Currency) currencyOption {
	return func(m *CurrencyMutation) {
		m.oldValue = func(context.Context) (*Currency, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CurrencyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CurrencyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Currency entities.
func (m *CurrencyMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CurrencyMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *CurrencyMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Currency.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDisplay sets the "display" field.
func (m *CurrencyMutation) SetDisplay(s string) {
	m.display = &s
}

// Display returns the value of the "display" field in the mutation.
func (m *CurrencyMutation) Display() (r string, exists bool) {
	v := m.display
	if v == nil {
		return
	}
	return *v, true
}

// OldDisplay returns the old "display" field's value of the Currency entity.
// If the Currency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyMutation) OldDisplay(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisplay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisplay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisplay: %w", err)
	}
	return oldValue.Display, nil
}

// ResetDisplay resets all changes to the "display" field.
func (m *CurrencyMutation) ResetDisplay() {
	m.display = nil
}

// SetCurrencyCode sets the "currency_code" field.
func (m *CurrencyMutation) SetCurrencyCode(cc currency.CurrencyCode) {
	m.currency_code = &cc
}

// CurrencyCode returns the value of the "currency_code" field in the mutation.
func (m *CurrencyMutation) CurrencyCode() (r currency.CurrencyCode, exists bool) {
	v := m.currency_code
	if v == nil {
		return
	}
	return *v, true
}

// OldCurrencyCode returns the old "currency_code" field's value of the Currency entity.
// If the Currency object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CurrencyMutation) OldCurrencyCode(ctx context.Context) (v currency.CurrencyCode, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCurrencyCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCurrencyCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCurrencyCode: %w", err)
	}
	return oldValue.CurrencyCode, nil
}

// ResetCurrencyCode resets all changes to the "currency_code" field.
func (m *CurrencyMutation) ResetCurrencyCode() {
	m.currency_code = nil
}

// AddOrderLineIDs adds the "order_line" edge to the OrderLine entity by ids.
func (m *CurrencyMutation) AddOrderLineIDs(ids ...pulid.ID) {
	if m.order_line == nil {
		m.order_line = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.order_line[ids[i]] = struct{}{}
	}
}

// ClearOrderLine clears the "order_line" edge to the OrderLine entity.
func (m *CurrencyMutation) ClearOrderLine() {
	m.clearedorder_line = true
}

// OrderLineCleared reports if the "order_line" edge to the OrderLine entity was cleared.
func (m *CurrencyMutation) OrderLineCleared() bool {
	return m.clearedorder_line
}

// RemoveOrderLineIDs removes the "order_line" edge to the OrderLine entity by IDs.
func (m *CurrencyMutation) RemoveOrderLineIDs(ids ...pulid.ID) {
	if m.removedorder_line == nil {
		m.removedorder_line = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.order_line, ids[i])
		m.removedorder_line[ids[i]] = struct{}{}
	}
}

// RemovedOrderLine returns the removed IDs of the "order_line" edge to the OrderLine entity.
func (m *CurrencyMutation) RemovedOrderLineIDs() (ids []pulid.ID) {
	for id := range m.removedorder_line {
		ids = append(ids, id)
	}
	return
}

// OrderLineIDs returns the "order_line" edge IDs in the mutation.
func (m *CurrencyMutation) OrderLineIDs() (ids []pulid.ID) {
	for id := range m.order_line {
		ids = append(ids, id)
	}
	return
}

// ResetOrderLine resets all changes to the "order_line" edge.
func (m *CurrencyMutation) ResetOrderLine() {
	m.order_line = nil
	m.clearedorder_line = false
	m.removedorder_line = nil
}

// AddDeliveryRuleIDs adds the "delivery_rule" edge to the DeliveryRule entity by ids.
func (m *CurrencyMutation) AddDeliveryRuleIDs(ids ...pulid.ID) {
	if m.delivery_rule == nil {
		m.delivery_rule = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_rule[ids[i]] = struct{}{}
	}
}

// ClearDeliveryRule clears the "delivery_rule" edge to the DeliveryRule entity.
func (m *CurrencyMutation) ClearDeliveryRule() {
	m.cleareddelivery_rule = true
}

// DeliveryRuleCleared reports if the "delivery_rule" edge to the DeliveryRule entity was cleared.
func (m *CurrencyMutation) DeliveryRuleCleared() bool {
	return m.cleareddelivery_rule
}

// RemoveDeliveryRuleIDs removes the "delivery_rule" edge to the DeliveryRule entity by IDs.
func (m *CurrencyMutation) RemoveDeliveryRuleIDs(ids ...pulid.ID) {
	if m.removeddelivery_rule == nil {
		m.removeddelivery_rule = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_rule, ids[i])
		m.removeddelivery_rule[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryRule returns the removed IDs of the "delivery_rule" edge to the DeliveryRule entity.
func (m *CurrencyMutation) RemovedDeliveryRuleIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_rule {
		ids = append(ids, id)
	}
	return
}

// DeliveryRuleIDs returns the "delivery_rule" edge IDs in the mutation.
func (m *CurrencyMutation) DeliveryRuleIDs() (ids []pulid.ID) {
	for id := range m.delivery_rule {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryRule resets all changes to the "delivery_rule" edge.
func (m *CurrencyMutation) ResetDeliveryRule() {
	m.delivery_rule = nil
	m.cleareddelivery_rule = false
	m.removeddelivery_rule = nil
}

// Where appends a list predicates to the CurrencyMutation builder.
func (m *CurrencyMutation) Where(ps ...predicate.Currency) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the CurrencyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *CurrencyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Currency, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *CurrencyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *CurrencyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Currency).
func (m *CurrencyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CurrencyMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.display != nil {
		fields = append(fields, currency.FieldDisplay)
	}
	if m.currency_code != nil {
		fields = append(fields, currency.FieldCurrencyCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CurrencyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case currency.FieldDisplay:
		return m.Display()
	case currency.FieldCurrencyCode:
		return m.CurrencyCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CurrencyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case currency.FieldDisplay:
		return m.OldDisplay(ctx)
	case currency.FieldCurrencyCode:
		return m.OldCurrencyCode(ctx)
	}
	return nil, fmt.Errorf("unknown Currency field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case currency.FieldDisplay:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisplay(v)
		return nil
	case currency.FieldCurrencyCode:
		v, ok := value.(currency.CurrencyCode)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCurrencyCode(v)
		return nil
	}
	return fmt.Errorf("unknown Currency field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CurrencyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CurrencyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CurrencyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Currency numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CurrencyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CurrencyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CurrencyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Currency nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CurrencyMutation) ResetField(name string) error {
	switch name {
	case currency.FieldDisplay:
		m.ResetDisplay()
		return nil
	case currency.FieldCurrencyCode:
		m.ResetCurrencyCode()
		return nil
	}
	return fmt.Errorf("unknown Currency field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CurrencyMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.order_line != nil {
		edges = append(edges, currency.EdgeOrderLine)
	}
	if m.delivery_rule != nil {
		edges = append(edges, currency.EdgeDeliveryRule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CurrencyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case currency.EdgeOrderLine:
		ids := make([]ent.Value, 0, len(m.order_line))
		for id := range m.order_line {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeDeliveryRule:
		ids := make([]ent.Value, 0, len(m.delivery_rule))
		for id := range m.delivery_rule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CurrencyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedorder_line != nil {
		edges = append(edges, currency.EdgeOrderLine)
	}
	if m.removeddelivery_rule != nil {
		edges = append(edges, currency.EdgeDeliveryRule)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CurrencyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case currency.EdgeOrderLine:
		ids := make([]ent.Value, 0, len(m.removedorder_line))
		for id := range m.removedorder_line {
			ids = append(ids, id)
		}
		return ids
	case currency.EdgeDeliveryRule:
		ids := make([]ent.Value, 0, len(m.removeddelivery_rule))
		for id := range m.removeddelivery_rule {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CurrencyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedorder_line {
		edges = append(edges, currency.EdgeOrderLine)
	}
	if m.cleareddelivery_rule {
		edges = append(edges, currency.EdgeDeliveryRule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CurrencyMutation) EdgeCleared(name string) bool {
	switch name {
	case currency.EdgeOrderLine:
		return m.clearedorder_line
	case currency.EdgeDeliveryRule:
		return m.cleareddelivery_rule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CurrencyMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Currency unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CurrencyMutation) ResetEdge(name string) error {
	switch name {
	case currency.EdgeOrderLine:
		m.ResetOrderLine()
		return nil
	case currency.EdgeDeliveryRule:
		m.ResetDeliveryRule()
		return nil
	}
	return fmt.Errorf("unknown Currency edge %s", name)
}

// DeliveryOptionMutation represents an operation that mutates the DeliveryOption nodes in the graph.
type DeliveryOptionMutation struct {
	config
	op                                               Op
	typ                                              string
	id                                               *pulid.ID
	archived_at                                      *time.Time
	name                                             *string
	sort_order                                       *int
	addsort_order                                    *int
	click_option_display_count                       *int
	addclick_option_display_count                    *int
	description                                      *string
	click_collect                                    *bool
	override_sender_address                          *bool
	override_return_address                          *bool
	hide_delivery_option                             *bool
	delivery_estimate_from                           *int
	adddelivery_estimate_from                        *int
	delivery_estimate_to                             *int
	adddelivery_estimate_to                          *int
	webshipper_integration                           *bool
	webshipper_id                                    *int
	addwebshipper_id                                 *int
	shipmondo_integration                            *bool
	shipmondo_delivery_option                        *string
	customs_enabled                                  *bool
	customs_signer                                   *string
	hide_if_company_empty                            *bool
	clearedFields                                    map[string]struct{}
	tenant                                           *pulid.ID
	clearedtenant                                    bool
	carrier                                          *pulid.ID
	clearedcarrier                                   bool
	delivery_rule                                    map[pulid.ID]struct{}
	removeddelivery_rule                             map[pulid.ID]struct{}
	cleareddelivery_rule                             bool
	delivery_option_dao                              *pulid.ID
	cleareddelivery_option_dao                       bool
	delivery_option_df                               *pulid.ID
	cleareddelivery_option_df                        bool
	delivery_option_dsv                              *pulid.ID
	cleareddelivery_option_dsv                       bool
	delivery_option_easy_post                        *pulid.ID
	cleareddelivery_option_easy_post                 bool
	delivery_option_gls                              *pulid.ID
	cleareddelivery_option_gls                       bool
	delivery_option_post_nord                        *pulid.ID
	cleareddelivery_option_post_nord                 bool
	delivery_option_usps                             *pulid.ID
	cleareddelivery_option_usps                      bool
	delivery_option_bring                            *pulid.ID
	cleareddelivery_option_bring                     bool
	return_portals                                   map[pulid.ID]struct{}
	removedreturn_portals                            map[pulid.ID]struct{}
	clearedreturn_portals                            bool
	colli                                            map[pulid.ID]struct{}
	removedcolli                                     map[pulid.ID]struct{}
	clearedcolli                                     bool
	return_colli                                     map[pulid.ID]struct{}
	removedreturn_colli                              map[pulid.ID]struct{}
	clearedreturn_colli                              bool
	carrier_service                                  *pulid.ID
	clearedcarrier_service                           bool
	connection                                       *pulid.ID
	clearedconnection                                bool
	connection_default                               *pulid.ID
	clearedconnection_default                        bool
	hypothesis_test_delivery_option_group_one        map[pulid.ID]struct{}
	removedhypothesis_test_delivery_option_group_one map[pulid.ID]struct{}
	clearedhypothesis_test_delivery_option_group_one bool
	hypothesis_test_delivery_option_group_two        map[pulid.ID]struct{}
	removedhypothesis_test_delivery_option_group_two map[pulid.ID]struct{}
	clearedhypothesis_test_delivery_option_group_two bool
	hypothesis_test_delivery_option_lookup           map[pulid.ID]struct{}
	removedhypothesis_test_delivery_option_lookup    map[pulid.ID]struct{}
	clearedhypothesis_test_delivery_option_lookup    bool
	click_collect_location                           map[pulid.ID]struct{}
	removedclick_collect_location                    map[pulid.ID]struct{}
	clearedclick_collect_location                    bool
	email_click_collect_at_store                     *pulid.ID
	clearedemail_click_collect_at_store              bool
	consolidation                                    map[pulid.ID]struct{}
	removedconsolidation                             map[pulid.ID]struct{}
	clearedconsolidation                             bool
	default_packaging                                *pulid.ID
	cleareddefault_packaging                         bool
	done                                             bool
	oldValue                                         func(context.Context) (*DeliveryOption, error)
	predicates                                       []predicate.DeliveryOption
}

var _ ent.Mutation = (*DeliveryOptionMutation)(nil)

// deliveryoptionOption allows management of the mutation configuration using functional options.
type deliveryoptionOption func(*DeliveryOptionMutation)

// newDeliveryOptionMutation creates new mutation for the DeliveryOption entity.
func newDeliveryOptionMutation(c config, op Op, opts ...deliveryoptionOption) *DeliveryOptionMutation {
	m := &DeliveryOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryOptionID sets the ID field of the mutation.
func withDeliveryOptionID(id pulid.ID) deliveryoptionOption {
	return func(m *DeliveryOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryOption
		)
		m.oldValue = func(ctx context.Context) (*DeliveryOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryOption sets the old DeliveryOption of the mutation.
func withDeliveryOption(node *DeliveryOption) deliveryoptionOption {
	return func(m *DeliveryOptionMutation) {
		m.oldValue = func(context.Context) (*DeliveryOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryOption entities.
func (m *DeliveryOptionMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryOptionMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryOptionMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryOptionMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryOptionMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryOptionMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchivedAt sets the "archived_at" field.
func (m *DeliveryOptionMutation) SetArchivedAt(t time.Time) {
	m.archived_at = &t
}

// ArchivedAt returns the value of the "archived_at" field in the mutation.
func (m *DeliveryOptionMutation) ArchivedAt() (r time.Time, exists bool) {
	v := m.archived_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedAt returns the old "archived_at" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldArchivedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedAt: %w", err)
	}
	return oldValue.ArchivedAt, nil
}

// ClearArchivedAt clears the value of the "archived_at" field.
func (m *DeliveryOptionMutation) ClearArchivedAt() {
	m.archived_at = nil
	m.clearedFields[deliveryoption.FieldArchivedAt] = struct{}{}
}

// ArchivedAtCleared returns if the "archived_at" field was cleared in this mutation.
func (m *DeliveryOptionMutation) ArchivedAtCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldArchivedAt]
	return ok
}

// ResetArchivedAt resets all changes to the "archived_at" field.
func (m *DeliveryOptionMutation) ResetArchivedAt() {
	m.archived_at = nil
	delete(m.clearedFields, deliveryoption.FieldArchivedAt)
}

// SetName sets the "name" field.
func (m *DeliveryOptionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeliveryOptionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeliveryOptionMutation) ResetName() {
	m.name = nil
}

// SetSortOrder sets the "sort_order" field.
func (m *DeliveryOptionMutation) SetSortOrder(i int) {
	m.sort_order = &i
	m.addsort_order = nil
}

// SortOrder returns the value of the "sort_order" field in the mutation.
func (m *DeliveryOptionMutation) SortOrder() (r int, exists bool) {
	v := m.sort_order
	if v == nil {
		return
	}
	return *v, true
}

// OldSortOrder returns the old "sort_order" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldSortOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSortOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSortOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSortOrder: %w", err)
	}
	return oldValue.SortOrder, nil
}

// AddSortOrder adds i to the "sort_order" field.
func (m *DeliveryOptionMutation) AddSortOrder(i int) {
	if m.addsort_order != nil {
		*m.addsort_order += i
	} else {
		m.addsort_order = &i
	}
}

// AddedSortOrder returns the value that was added to the "sort_order" field in this mutation.
func (m *DeliveryOptionMutation) AddedSortOrder() (r int, exists bool) {
	v := m.addsort_order
	if v == nil {
		return
	}
	return *v, true
}

// ResetSortOrder resets all changes to the "sort_order" field.
func (m *DeliveryOptionMutation) ResetSortOrder() {
	m.sort_order = nil
	m.addsort_order = nil
}

// SetClickOptionDisplayCount sets the "click_option_display_count" field.
func (m *DeliveryOptionMutation) SetClickOptionDisplayCount(i int) {
	m.click_option_display_count = &i
	m.addclick_option_display_count = nil
}

// ClickOptionDisplayCount returns the value of the "click_option_display_count" field in the mutation.
func (m *DeliveryOptionMutation) ClickOptionDisplayCount() (r int, exists bool) {
	v := m.click_option_display_count
	if v == nil {
		return
	}
	return *v, true
}

// OldClickOptionDisplayCount returns the old "click_option_display_count" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldClickOptionDisplayCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClickOptionDisplayCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClickOptionDisplayCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickOptionDisplayCount: %w", err)
	}
	return oldValue.ClickOptionDisplayCount, nil
}

// AddClickOptionDisplayCount adds i to the "click_option_display_count" field.
func (m *DeliveryOptionMutation) AddClickOptionDisplayCount(i int) {
	if m.addclick_option_display_count != nil {
		*m.addclick_option_display_count += i
	} else {
		m.addclick_option_display_count = &i
	}
}

// AddedClickOptionDisplayCount returns the value that was added to the "click_option_display_count" field in this mutation.
func (m *DeliveryOptionMutation) AddedClickOptionDisplayCount() (r int, exists bool) {
	v := m.addclick_option_display_count
	if v == nil {
		return
	}
	return *v, true
}

// ClearClickOptionDisplayCount clears the value of the "click_option_display_count" field.
func (m *DeliveryOptionMutation) ClearClickOptionDisplayCount() {
	m.click_option_display_count = nil
	m.addclick_option_display_count = nil
	m.clearedFields[deliveryoption.FieldClickOptionDisplayCount] = struct{}{}
}

// ClickOptionDisplayCountCleared returns if the "click_option_display_count" field was cleared in this mutation.
func (m *DeliveryOptionMutation) ClickOptionDisplayCountCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldClickOptionDisplayCount]
	return ok
}

// ResetClickOptionDisplayCount resets all changes to the "click_option_display_count" field.
func (m *DeliveryOptionMutation) ResetClickOptionDisplayCount() {
	m.click_option_display_count = nil
	m.addclick_option_display_count = nil
	delete(m.clearedFields, deliveryoption.FieldClickOptionDisplayCount)
}

// SetDescription sets the "description" field.
func (m *DeliveryOptionMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *DeliveryOptionMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *DeliveryOptionMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[deliveryoption.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *DeliveryOptionMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *DeliveryOptionMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, deliveryoption.FieldDescription)
}

// SetClickCollect sets the "click_collect" field.
func (m *DeliveryOptionMutation) SetClickCollect(b bool) {
	m.click_collect = &b
}

// ClickCollect returns the value of the "click_collect" field in the mutation.
func (m *DeliveryOptionMutation) ClickCollect() (r bool, exists bool) {
	v := m.click_collect
	if v == nil {
		return
	}
	return *v, true
}

// OldClickCollect returns the old "click_collect" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldClickCollect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClickCollect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClickCollect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickCollect: %w", err)
	}
	return oldValue.ClickCollect, nil
}

// ClearClickCollect clears the value of the "click_collect" field.
func (m *DeliveryOptionMutation) ClearClickCollect() {
	m.click_collect = nil
	m.clearedFields[deliveryoption.FieldClickCollect] = struct{}{}
}

// ClickCollectCleared returns if the "click_collect" field was cleared in this mutation.
func (m *DeliveryOptionMutation) ClickCollectCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldClickCollect]
	return ok
}

// ResetClickCollect resets all changes to the "click_collect" field.
func (m *DeliveryOptionMutation) ResetClickCollect() {
	m.click_collect = nil
	delete(m.clearedFields, deliveryoption.FieldClickCollect)
}

// SetOverrideSenderAddress sets the "override_sender_address" field.
func (m *DeliveryOptionMutation) SetOverrideSenderAddress(b bool) {
	m.override_sender_address = &b
}

// OverrideSenderAddress returns the value of the "override_sender_address" field in the mutation.
func (m *DeliveryOptionMutation) OverrideSenderAddress() (r bool, exists bool) {
	v := m.override_sender_address
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideSenderAddress returns the old "override_sender_address" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldOverrideSenderAddress(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverrideSenderAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverrideSenderAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideSenderAddress: %w", err)
	}
	return oldValue.OverrideSenderAddress, nil
}

// ClearOverrideSenderAddress clears the value of the "override_sender_address" field.
func (m *DeliveryOptionMutation) ClearOverrideSenderAddress() {
	m.override_sender_address = nil
	m.clearedFields[deliveryoption.FieldOverrideSenderAddress] = struct{}{}
}

// OverrideSenderAddressCleared returns if the "override_sender_address" field was cleared in this mutation.
func (m *DeliveryOptionMutation) OverrideSenderAddressCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldOverrideSenderAddress]
	return ok
}

// ResetOverrideSenderAddress resets all changes to the "override_sender_address" field.
func (m *DeliveryOptionMutation) ResetOverrideSenderAddress() {
	m.override_sender_address = nil
	delete(m.clearedFields, deliveryoption.FieldOverrideSenderAddress)
}

// SetOverrideReturnAddress sets the "override_return_address" field.
func (m *DeliveryOptionMutation) SetOverrideReturnAddress(b bool) {
	m.override_return_address = &b
}

// OverrideReturnAddress returns the value of the "override_return_address" field in the mutation.
func (m *DeliveryOptionMutation) OverrideReturnAddress() (r bool, exists bool) {
	v := m.override_return_address
	if v == nil {
		return
	}
	return *v, true
}

// OldOverrideReturnAddress returns the old "override_return_address" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldOverrideReturnAddress(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOverrideReturnAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOverrideReturnAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOverrideReturnAddress: %w", err)
	}
	return oldValue.OverrideReturnAddress, nil
}

// ClearOverrideReturnAddress clears the value of the "override_return_address" field.
func (m *DeliveryOptionMutation) ClearOverrideReturnAddress() {
	m.override_return_address = nil
	m.clearedFields[deliveryoption.FieldOverrideReturnAddress] = struct{}{}
}

// OverrideReturnAddressCleared returns if the "override_return_address" field was cleared in this mutation.
func (m *DeliveryOptionMutation) OverrideReturnAddressCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldOverrideReturnAddress]
	return ok
}

// ResetOverrideReturnAddress resets all changes to the "override_return_address" field.
func (m *DeliveryOptionMutation) ResetOverrideReturnAddress() {
	m.override_return_address = nil
	delete(m.clearedFields, deliveryoption.FieldOverrideReturnAddress)
}

// SetHideDeliveryOption sets the "hide_delivery_option" field.
func (m *DeliveryOptionMutation) SetHideDeliveryOption(b bool) {
	m.hide_delivery_option = &b
}

// HideDeliveryOption returns the value of the "hide_delivery_option" field in the mutation.
func (m *DeliveryOptionMutation) HideDeliveryOption() (r bool, exists bool) {
	v := m.hide_delivery_option
	if v == nil {
		return
	}
	return *v, true
}

// OldHideDeliveryOption returns the old "hide_delivery_option" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldHideDeliveryOption(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideDeliveryOption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideDeliveryOption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideDeliveryOption: %w", err)
	}
	return oldValue.HideDeliveryOption, nil
}

// ClearHideDeliveryOption clears the value of the "hide_delivery_option" field.
func (m *DeliveryOptionMutation) ClearHideDeliveryOption() {
	m.hide_delivery_option = nil
	m.clearedFields[deliveryoption.FieldHideDeliveryOption] = struct{}{}
}

// HideDeliveryOptionCleared returns if the "hide_delivery_option" field was cleared in this mutation.
func (m *DeliveryOptionMutation) HideDeliveryOptionCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldHideDeliveryOption]
	return ok
}

// ResetHideDeliveryOption resets all changes to the "hide_delivery_option" field.
func (m *DeliveryOptionMutation) ResetHideDeliveryOption() {
	m.hide_delivery_option = nil
	delete(m.clearedFields, deliveryoption.FieldHideDeliveryOption)
}

// SetDeliveryEstimateFrom sets the "delivery_estimate_from" field.
func (m *DeliveryOptionMutation) SetDeliveryEstimateFrom(i int) {
	m.delivery_estimate_from = &i
	m.adddelivery_estimate_from = nil
}

// DeliveryEstimateFrom returns the value of the "delivery_estimate_from" field in the mutation.
func (m *DeliveryOptionMutation) DeliveryEstimateFrom() (r int, exists bool) {
	v := m.delivery_estimate_from
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryEstimateFrom returns the old "delivery_estimate_from" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldDeliveryEstimateFrom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryEstimateFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryEstimateFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryEstimateFrom: %w", err)
	}
	return oldValue.DeliveryEstimateFrom, nil
}

// AddDeliveryEstimateFrom adds i to the "delivery_estimate_from" field.
func (m *DeliveryOptionMutation) AddDeliveryEstimateFrom(i int) {
	if m.adddelivery_estimate_from != nil {
		*m.adddelivery_estimate_from += i
	} else {
		m.adddelivery_estimate_from = &i
	}
}

// AddedDeliveryEstimateFrom returns the value that was added to the "delivery_estimate_from" field in this mutation.
func (m *DeliveryOptionMutation) AddedDeliveryEstimateFrom() (r int, exists bool) {
	v := m.adddelivery_estimate_from
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryEstimateFrom clears the value of the "delivery_estimate_from" field.
func (m *DeliveryOptionMutation) ClearDeliveryEstimateFrom() {
	m.delivery_estimate_from = nil
	m.adddelivery_estimate_from = nil
	m.clearedFields[deliveryoption.FieldDeliveryEstimateFrom] = struct{}{}
}

// DeliveryEstimateFromCleared returns if the "delivery_estimate_from" field was cleared in this mutation.
func (m *DeliveryOptionMutation) DeliveryEstimateFromCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldDeliveryEstimateFrom]
	return ok
}

// ResetDeliveryEstimateFrom resets all changes to the "delivery_estimate_from" field.
func (m *DeliveryOptionMutation) ResetDeliveryEstimateFrom() {
	m.delivery_estimate_from = nil
	m.adddelivery_estimate_from = nil
	delete(m.clearedFields, deliveryoption.FieldDeliveryEstimateFrom)
}

// SetDeliveryEstimateTo sets the "delivery_estimate_to" field.
func (m *DeliveryOptionMutation) SetDeliveryEstimateTo(i int) {
	m.delivery_estimate_to = &i
	m.adddelivery_estimate_to = nil
}

// DeliveryEstimateTo returns the value of the "delivery_estimate_to" field in the mutation.
func (m *DeliveryOptionMutation) DeliveryEstimateTo() (r int, exists bool) {
	v := m.delivery_estimate_to
	if v == nil {
		return
	}
	return *v, true
}

// OldDeliveryEstimateTo returns the old "delivery_estimate_to" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldDeliveryEstimateTo(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeliveryEstimateTo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeliveryEstimateTo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeliveryEstimateTo: %w", err)
	}
	return oldValue.DeliveryEstimateTo, nil
}

// AddDeliveryEstimateTo adds i to the "delivery_estimate_to" field.
func (m *DeliveryOptionMutation) AddDeliveryEstimateTo(i int) {
	if m.adddelivery_estimate_to != nil {
		*m.adddelivery_estimate_to += i
	} else {
		m.adddelivery_estimate_to = &i
	}
}

// AddedDeliveryEstimateTo returns the value that was added to the "delivery_estimate_to" field in this mutation.
func (m *DeliveryOptionMutation) AddedDeliveryEstimateTo() (r int, exists bool) {
	v := m.adddelivery_estimate_to
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeliveryEstimateTo clears the value of the "delivery_estimate_to" field.
func (m *DeliveryOptionMutation) ClearDeliveryEstimateTo() {
	m.delivery_estimate_to = nil
	m.adddelivery_estimate_to = nil
	m.clearedFields[deliveryoption.FieldDeliveryEstimateTo] = struct{}{}
}

// DeliveryEstimateToCleared returns if the "delivery_estimate_to" field was cleared in this mutation.
func (m *DeliveryOptionMutation) DeliveryEstimateToCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldDeliveryEstimateTo]
	return ok
}

// ResetDeliveryEstimateTo resets all changes to the "delivery_estimate_to" field.
func (m *DeliveryOptionMutation) ResetDeliveryEstimateTo() {
	m.delivery_estimate_to = nil
	m.adddelivery_estimate_to = nil
	delete(m.clearedFields, deliveryoption.FieldDeliveryEstimateTo)
}

// SetWebshipperIntegration sets the "webshipper_integration" field.
func (m *DeliveryOptionMutation) SetWebshipperIntegration(b bool) {
	m.webshipper_integration = &b
}

// WebshipperIntegration returns the value of the "webshipper_integration" field in the mutation.
func (m *DeliveryOptionMutation) WebshipperIntegration() (r bool, exists bool) {
	v := m.webshipper_integration
	if v == nil {
		return
	}
	return *v, true
}

// OldWebshipperIntegration returns the old "webshipper_integration" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldWebshipperIntegration(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebshipperIntegration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebshipperIntegration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebshipperIntegration: %w", err)
	}
	return oldValue.WebshipperIntegration, nil
}

// ResetWebshipperIntegration resets all changes to the "webshipper_integration" field.
func (m *DeliveryOptionMutation) ResetWebshipperIntegration() {
	m.webshipper_integration = nil
}

// SetWebshipperID sets the "webshipper_id" field.
func (m *DeliveryOptionMutation) SetWebshipperID(i int) {
	m.webshipper_id = &i
	m.addwebshipper_id = nil
}

// WebshipperID returns the value of the "webshipper_id" field in the mutation.
func (m *DeliveryOptionMutation) WebshipperID() (r int, exists bool) {
	v := m.webshipper_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWebshipperID returns the old "webshipper_id" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldWebshipperID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWebshipperID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWebshipperID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWebshipperID: %w", err)
	}
	return oldValue.WebshipperID, nil
}

// AddWebshipperID adds i to the "webshipper_id" field.
func (m *DeliveryOptionMutation) AddWebshipperID(i int) {
	if m.addwebshipper_id != nil {
		*m.addwebshipper_id += i
	} else {
		m.addwebshipper_id = &i
	}
}

// AddedWebshipperID returns the value that was added to the "webshipper_id" field in this mutation.
func (m *DeliveryOptionMutation) AddedWebshipperID() (r int, exists bool) {
	v := m.addwebshipper_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearWebshipperID clears the value of the "webshipper_id" field.
func (m *DeliveryOptionMutation) ClearWebshipperID() {
	m.webshipper_id = nil
	m.addwebshipper_id = nil
	m.clearedFields[deliveryoption.FieldWebshipperID] = struct{}{}
}

// WebshipperIDCleared returns if the "webshipper_id" field was cleared in this mutation.
func (m *DeliveryOptionMutation) WebshipperIDCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldWebshipperID]
	return ok
}

// ResetWebshipperID resets all changes to the "webshipper_id" field.
func (m *DeliveryOptionMutation) ResetWebshipperID() {
	m.webshipper_id = nil
	m.addwebshipper_id = nil
	delete(m.clearedFields, deliveryoption.FieldWebshipperID)
}

// SetShipmondoIntegration sets the "shipmondo_integration" field.
func (m *DeliveryOptionMutation) SetShipmondoIntegration(b bool) {
	m.shipmondo_integration = &b
}

// ShipmondoIntegration returns the value of the "shipmondo_integration" field in the mutation.
func (m *DeliveryOptionMutation) ShipmondoIntegration() (r bool, exists bool) {
	v := m.shipmondo_integration
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmondoIntegration returns the old "shipmondo_integration" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldShipmondoIntegration(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmondoIntegration is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmondoIntegration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmondoIntegration: %w", err)
	}
	return oldValue.ShipmondoIntegration, nil
}

// ResetShipmondoIntegration resets all changes to the "shipmondo_integration" field.
func (m *DeliveryOptionMutation) ResetShipmondoIntegration() {
	m.shipmondo_integration = nil
}

// SetShipmondoDeliveryOption sets the "shipmondo_delivery_option" field.
func (m *DeliveryOptionMutation) SetShipmondoDeliveryOption(s string) {
	m.shipmondo_delivery_option = &s
}

// ShipmondoDeliveryOption returns the value of the "shipmondo_delivery_option" field in the mutation.
func (m *DeliveryOptionMutation) ShipmondoDeliveryOption() (r string, exists bool) {
	v := m.shipmondo_delivery_option
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmondoDeliveryOption returns the old "shipmondo_delivery_option" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldShipmondoDeliveryOption(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmondoDeliveryOption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmondoDeliveryOption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmondoDeliveryOption: %w", err)
	}
	return oldValue.ShipmondoDeliveryOption, nil
}

// ClearShipmondoDeliveryOption clears the value of the "shipmondo_delivery_option" field.
func (m *DeliveryOptionMutation) ClearShipmondoDeliveryOption() {
	m.shipmondo_delivery_option = nil
	m.clearedFields[deliveryoption.FieldShipmondoDeliveryOption] = struct{}{}
}

// ShipmondoDeliveryOptionCleared returns if the "shipmondo_delivery_option" field was cleared in this mutation.
func (m *DeliveryOptionMutation) ShipmondoDeliveryOptionCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldShipmondoDeliveryOption]
	return ok
}

// ResetShipmondoDeliveryOption resets all changes to the "shipmondo_delivery_option" field.
func (m *DeliveryOptionMutation) ResetShipmondoDeliveryOption() {
	m.shipmondo_delivery_option = nil
	delete(m.clearedFields, deliveryoption.FieldShipmondoDeliveryOption)
}

// SetCustomsEnabled sets the "customs_enabled" field.
func (m *DeliveryOptionMutation) SetCustomsEnabled(b bool) {
	m.customs_enabled = &b
}

// CustomsEnabled returns the value of the "customs_enabled" field in the mutation.
func (m *DeliveryOptionMutation) CustomsEnabled() (r bool, exists bool) {
	v := m.customs_enabled
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomsEnabled returns the old "customs_enabled" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldCustomsEnabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomsEnabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomsEnabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomsEnabled: %w", err)
	}
	return oldValue.CustomsEnabled, nil
}

// ResetCustomsEnabled resets all changes to the "customs_enabled" field.
func (m *DeliveryOptionMutation) ResetCustomsEnabled() {
	m.customs_enabled = nil
}

// SetCustomsSigner sets the "customs_signer" field.
func (m *DeliveryOptionMutation) SetCustomsSigner(s string) {
	m.customs_signer = &s
}

// CustomsSigner returns the value of the "customs_signer" field in the mutation.
func (m *DeliveryOptionMutation) CustomsSigner() (r string, exists bool) {
	v := m.customs_signer
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomsSigner returns the old "customs_signer" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldCustomsSigner(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomsSigner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomsSigner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomsSigner: %w", err)
	}
	return oldValue.CustomsSigner, nil
}

// ClearCustomsSigner clears the value of the "customs_signer" field.
func (m *DeliveryOptionMutation) ClearCustomsSigner() {
	m.customs_signer = nil
	m.clearedFields[deliveryoption.FieldCustomsSigner] = struct{}{}
}

// CustomsSignerCleared returns if the "customs_signer" field was cleared in this mutation.
func (m *DeliveryOptionMutation) CustomsSignerCleared() bool {
	_, ok := m.clearedFields[deliveryoption.FieldCustomsSigner]
	return ok
}

// ResetCustomsSigner resets all changes to the "customs_signer" field.
func (m *DeliveryOptionMutation) ResetCustomsSigner() {
	m.customs_signer = nil
	delete(m.clearedFields, deliveryoption.FieldCustomsSigner)
}

// SetHideIfCompanyEmpty sets the "hide_if_company_empty" field.
func (m *DeliveryOptionMutation) SetHideIfCompanyEmpty(b bool) {
	m.hide_if_company_empty = &b
}

// HideIfCompanyEmpty returns the value of the "hide_if_company_empty" field in the mutation.
func (m *DeliveryOptionMutation) HideIfCompanyEmpty() (r bool, exists bool) {
	v := m.hide_if_company_empty
	if v == nil {
		return
	}
	return *v, true
}

// OldHideIfCompanyEmpty returns the old "hide_if_company_empty" field's value of the DeliveryOption entity.
// If the DeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionMutation) OldHideIfCompanyEmpty(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHideIfCompanyEmpty is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHideIfCompanyEmpty requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHideIfCompanyEmpty: %w", err)
	}
	return oldValue.HideIfCompanyEmpty, nil
}

// ResetHideIfCompanyEmpty resets all changes to the "hide_if_company_empty" field.
func (m *DeliveryOptionMutation) ResetHideIfCompanyEmpty() {
	m.hide_if_company_empty = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryOptionMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryoption.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryOptionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryOptionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *DeliveryOptionMutation) SetCarrierID(id pulid.ID) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *DeliveryOptionMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *DeliveryOptionMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *DeliveryOptionMutation) CarrierID() (id pulid.ID, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) CarrierIDs() (ids []pulid.ID) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *DeliveryOptionMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// AddDeliveryRuleIDs adds the "delivery_rule" edge to the DeliveryRule entity by ids.
func (m *DeliveryOptionMutation) AddDeliveryRuleIDs(ids ...pulid.ID) {
	if m.delivery_rule == nil {
		m.delivery_rule = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_rule[ids[i]] = struct{}{}
	}
}

// ClearDeliveryRule clears the "delivery_rule" edge to the DeliveryRule entity.
func (m *DeliveryOptionMutation) ClearDeliveryRule() {
	m.cleareddelivery_rule = true
}

// DeliveryRuleCleared reports if the "delivery_rule" edge to the DeliveryRule entity was cleared.
func (m *DeliveryOptionMutation) DeliveryRuleCleared() bool {
	return m.cleareddelivery_rule
}

// RemoveDeliveryRuleIDs removes the "delivery_rule" edge to the DeliveryRule entity by IDs.
func (m *DeliveryOptionMutation) RemoveDeliveryRuleIDs(ids ...pulid.ID) {
	if m.removeddelivery_rule == nil {
		m.removeddelivery_rule = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_rule, ids[i])
		m.removeddelivery_rule[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryRule returns the removed IDs of the "delivery_rule" edge to the DeliveryRule entity.
func (m *DeliveryOptionMutation) RemovedDeliveryRuleIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_rule {
		ids = append(ids, id)
	}
	return
}

// DeliveryRuleIDs returns the "delivery_rule" edge IDs in the mutation.
func (m *DeliveryOptionMutation) DeliveryRuleIDs() (ids []pulid.ID) {
	for id := range m.delivery_rule {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryRule resets all changes to the "delivery_rule" edge.
func (m *DeliveryOptionMutation) ResetDeliveryRule() {
	m.delivery_rule = nil
	m.cleareddelivery_rule = false
	m.removeddelivery_rule = nil
}

// SetDeliveryOptionDAOID sets the "delivery_option_dao" edge to the DeliveryOptionDAO entity by id.
func (m *DeliveryOptionMutation) SetDeliveryOptionDAOID(id pulid.ID) {
	m.delivery_option_dao = &id
}

// ClearDeliveryOptionDAO clears the "delivery_option_dao" edge to the DeliveryOptionDAO entity.
func (m *DeliveryOptionMutation) ClearDeliveryOptionDAO() {
	m.cleareddelivery_option_dao = true
}

// DeliveryOptionDAOCleared reports if the "delivery_option_dao" edge to the DeliveryOptionDAO entity was cleared.
func (m *DeliveryOptionMutation) DeliveryOptionDAOCleared() bool {
	return m.cleareddelivery_option_dao
}

// DeliveryOptionDAOID returns the "delivery_option_dao" edge ID in the mutation.
func (m *DeliveryOptionMutation) DeliveryOptionDAOID() (id pulid.ID, exists bool) {
	if m.delivery_option_dao != nil {
		return *m.delivery_option_dao, true
	}
	return
}

// DeliveryOptionDAOIDs returns the "delivery_option_dao" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionDAOID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) DeliveryOptionDAOIDs() (ids []pulid.ID) {
	if id := m.delivery_option_dao; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOptionDAO resets all changes to the "delivery_option_dao" edge.
func (m *DeliveryOptionMutation) ResetDeliveryOptionDAO() {
	m.delivery_option_dao = nil
	m.cleareddelivery_option_dao = false
}

// SetDeliveryOptionDFID sets the "delivery_option_df" edge to the DeliveryOptionDF entity by id.
func (m *DeliveryOptionMutation) SetDeliveryOptionDFID(id pulid.ID) {
	m.delivery_option_df = &id
}

// ClearDeliveryOptionDF clears the "delivery_option_df" edge to the DeliveryOptionDF entity.
func (m *DeliveryOptionMutation) ClearDeliveryOptionDF() {
	m.cleareddelivery_option_df = true
}

// DeliveryOptionDFCleared reports if the "delivery_option_df" edge to the DeliveryOptionDF entity was cleared.
func (m *DeliveryOptionMutation) DeliveryOptionDFCleared() bool {
	return m.cleareddelivery_option_df
}

// DeliveryOptionDFID returns the "delivery_option_df" edge ID in the mutation.
func (m *DeliveryOptionMutation) DeliveryOptionDFID() (id pulid.ID, exists bool) {
	if m.delivery_option_df != nil {
		return *m.delivery_option_df, true
	}
	return
}

// DeliveryOptionDFIDs returns the "delivery_option_df" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionDFID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) DeliveryOptionDFIDs() (ids []pulid.ID) {
	if id := m.delivery_option_df; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOptionDF resets all changes to the "delivery_option_df" edge.
func (m *DeliveryOptionMutation) ResetDeliveryOptionDF() {
	m.delivery_option_df = nil
	m.cleareddelivery_option_df = false
}

// SetDeliveryOptionDSVID sets the "delivery_option_dsv" edge to the DeliveryOptionDSV entity by id.
func (m *DeliveryOptionMutation) SetDeliveryOptionDSVID(id pulid.ID) {
	m.delivery_option_dsv = &id
}

// ClearDeliveryOptionDSV clears the "delivery_option_dsv" edge to the DeliveryOptionDSV entity.
func (m *DeliveryOptionMutation) ClearDeliveryOptionDSV() {
	m.cleareddelivery_option_dsv = true
}

// DeliveryOptionDSVCleared reports if the "delivery_option_dsv" edge to the DeliveryOptionDSV entity was cleared.
func (m *DeliveryOptionMutation) DeliveryOptionDSVCleared() bool {
	return m.cleareddelivery_option_dsv
}

// DeliveryOptionDSVID returns the "delivery_option_dsv" edge ID in the mutation.
func (m *DeliveryOptionMutation) DeliveryOptionDSVID() (id pulid.ID, exists bool) {
	if m.delivery_option_dsv != nil {
		return *m.delivery_option_dsv, true
	}
	return
}

// DeliveryOptionDSVIDs returns the "delivery_option_dsv" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionDSVID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) DeliveryOptionDSVIDs() (ids []pulid.ID) {
	if id := m.delivery_option_dsv; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOptionDSV resets all changes to the "delivery_option_dsv" edge.
func (m *DeliveryOptionMutation) ResetDeliveryOptionDSV() {
	m.delivery_option_dsv = nil
	m.cleareddelivery_option_dsv = false
}

// SetDeliveryOptionEasyPostID sets the "delivery_option_easy_post" edge to the DeliveryOptionEasyPost entity by id.
func (m *DeliveryOptionMutation) SetDeliveryOptionEasyPostID(id pulid.ID) {
	m.delivery_option_easy_post = &id
}

// ClearDeliveryOptionEasyPost clears the "delivery_option_easy_post" edge to the DeliveryOptionEasyPost entity.
func (m *DeliveryOptionMutation) ClearDeliveryOptionEasyPost() {
	m.cleareddelivery_option_easy_post = true
}

// DeliveryOptionEasyPostCleared reports if the "delivery_option_easy_post" edge to the DeliveryOptionEasyPost entity was cleared.
func (m *DeliveryOptionMutation) DeliveryOptionEasyPostCleared() bool {
	return m.cleareddelivery_option_easy_post
}

// DeliveryOptionEasyPostID returns the "delivery_option_easy_post" edge ID in the mutation.
func (m *DeliveryOptionMutation) DeliveryOptionEasyPostID() (id pulid.ID, exists bool) {
	if m.delivery_option_easy_post != nil {
		return *m.delivery_option_easy_post, true
	}
	return
}

// DeliveryOptionEasyPostIDs returns the "delivery_option_easy_post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionEasyPostID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) DeliveryOptionEasyPostIDs() (ids []pulid.ID) {
	if id := m.delivery_option_easy_post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOptionEasyPost resets all changes to the "delivery_option_easy_post" edge.
func (m *DeliveryOptionMutation) ResetDeliveryOptionEasyPost() {
	m.delivery_option_easy_post = nil
	m.cleareddelivery_option_easy_post = false
}

// SetDeliveryOptionGLSID sets the "delivery_option_gls" edge to the DeliveryOptionGLS entity by id.
func (m *DeliveryOptionMutation) SetDeliveryOptionGLSID(id pulid.ID) {
	m.delivery_option_gls = &id
}

// ClearDeliveryOptionGLS clears the "delivery_option_gls" edge to the DeliveryOptionGLS entity.
func (m *DeliveryOptionMutation) ClearDeliveryOptionGLS() {
	m.cleareddelivery_option_gls = true
}

// DeliveryOptionGLSCleared reports if the "delivery_option_gls" edge to the DeliveryOptionGLS entity was cleared.
func (m *DeliveryOptionMutation) DeliveryOptionGLSCleared() bool {
	return m.cleareddelivery_option_gls
}

// DeliveryOptionGLSID returns the "delivery_option_gls" edge ID in the mutation.
func (m *DeliveryOptionMutation) DeliveryOptionGLSID() (id pulid.ID, exists bool) {
	if m.delivery_option_gls != nil {
		return *m.delivery_option_gls, true
	}
	return
}

// DeliveryOptionGLSIDs returns the "delivery_option_gls" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionGLSID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) DeliveryOptionGLSIDs() (ids []pulid.ID) {
	if id := m.delivery_option_gls; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOptionGLS resets all changes to the "delivery_option_gls" edge.
func (m *DeliveryOptionMutation) ResetDeliveryOptionGLS() {
	m.delivery_option_gls = nil
	m.cleareddelivery_option_gls = false
}

// SetDeliveryOptionPostNordID sets the "delivery_option_post_nord" edge to the DeliveryOptionPostNord entity by id.
func (m *DeliveryOptionMutation) SetDeliveryOptionPostNordID(id pulid.ID) {
	m.delivery_option_post_nord = &id
}

// ClearDeliveryOptionPostNord clears the "delivery_option_post_nord" edge to the DeliveryOptionPostNord entity.
func (m *DeliveryOptionMutation) ClearDeliveryOptionPostNord() {
	m.cleareddelivery_option_post_nord = true
}

// DeliveryOptionPostNordCleared reports if the "delivery_option_post_nord" edge to the DeliveryOptionPostNord entity was cleared.
func (m *DeliveryOptionMutation) DeliveryOptionPostNordCleared() bool {
	return m.cleareddelivery_option_post_nord
}

// DeliveryOptionPostNordID returns the "delivery_option_post_nord" edge ID in the mutation.
func (m *DeliveryOptionMutation) DeliveryOptionPostNordID() (id pulid.ID, exists bool) {
	if m.delivery_option_post_nord != nil {
		return *m.delivery_option_post_nord, true
	}
	return
}

// DeliveryOptionPostNordIDs returns the "delivery_option_post_nord" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionPostNordID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) DeliveryOptionPostNordIDs() (ids []pulid.ID) {
	if id := m.delivery_option_post_nord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOptionPostNord resets all changes to the "delivery_option_post_nord" edge.
func (m *DeliveryOptionMutation) ResetDeliveryOptionPostNord() {
	m.delivery_option_post_nord = nil
	m.cleareddelivery_option_post_nord = false
}

// SetDeliveryOptionUSPSID sets the "delivery_option_usps" edge to the DeliveryOptionUSPS entity by id.
func (m *DeliveryOptionMutation) SetDeliveryOptionUSPSID(id pulid.ID) {
	m.delivery_option_usps = &id
}

// ClearDeliveryOptionUSPS clears the "delivery_option_usps" edge to the DeliveryOptionUSPS entity.
func (m *DeliveryOptionMutation) ClearDeliveryOptionUSPS() {
	m.cleareddelivery_option_usps = true
}

// DeliveryOptionUSPSCleared reports if the "delivery_option_usps" edge to the DeliveryOptionUSPS entity was cleared.
func (m *DeliveryOptionMutation) DeliveryOptionUSPSCleared() bool {
	return m.cleareddelivery_option_usps
}

// DeliveryOptionUSPSID returns the "delivery_option_usps" edge ID in the mutation.
func (m *DeliveryOptionMutation) DeliveryOptionUSPSID() (id pulid.ID, exists bool) {
	if m.delivery_option_usps != nil {
		return *m.delivery_option_usps, true
	}
	return
}

// DeliveryOptionUSPSIDs returns the "delivery_option_usps" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionUSPSID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) DeliveryOptionUSPSIDs() (ids []pulid.ID) {
	if id := m.delivery_option_usps; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOptionUSPS resets all changes to the "delivery_option_usps" edge.
func (m *DeliveryOptionMutation) ResetDeliveryOptionUSPS() {
	m.delivery_option_usps = nil
	m.cleareddelivery_option_usps = false
}

// SetDeliveryOptionBringID sets the "delivery_option_bring" edge to the DeliveryOptionBring entity by id.
func (m *DeliveryOptionMutation) SetDeliveryOptionBringID(id pulid.ID) {
	m.delivery_option_bring = &id
}

// ClearDeliveryOptionBring clears the "delivery_option_bring" edge to the DeliveryOptionBring entity.
func (m *DeliveryOptionMutation) ClearDeliveryOptionBring() {
	m.cleareddelivery_option_bring = true
}

// DeliveryOptionBringCleared reports if the "delivery_option_bring" edge to the DeliveryOptionBring entity was cleared.
func (m *DeliveryOptionMutation) DeliveryOptionBringCleared() bool {
	return m.cleareddelivery_option_bring
}

// DeliveryOptionBringID returns the "delivery_option_bring" edge ID in the mutation.
func (m *DeliveryOptionMutation) DeliveryOptionBringID() (id pulid.ID, exists bool) {
	if m.delivery_option_bring != nil {
		return *m.delivery_option_bring, true
	}
	return
}

// DeliveryOptionBringIDs returns the "delivery_option_bring" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionBringID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) DeliveryOptionBringIDs() (ids []pulid.ID) {
	if id := m.delivery_option_bring; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOptionBring resets all changes to the "delivery_option_bring" edge.
func (m *DeliveryOptionMutation) ResetDeliveryOptionBring() {
	m.delivery_option_bring = nil
	m.cleareddelivery_option_bring = false
}

// AddReturnPortalIDs adds the "return_portals" edge to the ReturnPortal entity by ids.
func (m *DeliveryOptionMutation) AddReturnPortalIDs(ids ...pulid.ID) {
	if m.return_portals == nil {
		m.return_portals = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_portals[ids[i]] = struct{}{}
	}
}

// ClearReturnPortals clears the "return_portals" edge to the ReturnPortal entity.
func (m *DeliveryOptionMutation) ClearReturnPortals() {
	m.clearedreturn_portals = true
}

// ReturnPortalsCleared reports if the "return_portals" edge to the ReturnPortal entity was cleared.
func (m *DeliveryOptionMutation) ReturnPortalsCleared() bool {
	return m.clearedreturn_portals
}

// RemoveReturnPortalIDs removes the "return_portals" edge to the ReturnPortal entity by IDs.
func (m *DeliveryOptionMutation) RemoveReturnPortalIDs(ids ...pulid.ID) {
	if m.removedreturn_portals == nil {
		m.removedreturn_portals = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_portals, ids[i])
		m.removedreturn_portals[ids[i]] = struct{}{}
	}
}

// RemovedReturnPortals returns the removed IDs of the "return_portals" edge to the ReturnPortal entity.
func (m *DeliveryOptionMutation) RemovedReturnPortalsIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_portals {
		ids = append(ids, id)
	}
	return
}

// ReturnPortalsIDs returns the "return_portals" edge IDs in the mutation.
func (m *DeliveryOptionMutation) ReturnPortalsIDs() (ids []pulid.ID) {
	for id := range m.return_portals {
		ids = append(ids, id)
	}
	return
}

// ResetReturnPortals resets all changes to the "return_portals" edge.
func (m *DeliveryOptionMutation) ResetReturnPortals() {
	m.return_portals = nil
	m.clearedreturn_portals = false
	m.removedreturn_portals = nil
}

// AddColliIDs adds the "colli" edge to the Colli entity by ids.
func (m *DeliveryOptionMutation) AddColliIDs(ids ...pulid.ID) {
	if m.colli == nil {
		m.colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.colli[ids[i]] = struct{}{}
	}
}

// ClearColli clears the "colli" edge to the Colli entity.
func (m *DeliveryOptionMutation) ClearColli() {
	m.clearedcolli = true
}

// ColliCleared reports if the "colli" edge to the Colli entity was cleared.
func (m *DeliveryOptionMutation) ColliCleared() bool {
	return m.clearedcolli
}

// RemoveColliIDs removes the "colli" edge to the Colli entity by IDs.
func (m *DeliveryOptionMutation) RemoveColliIDs(ids ...pulid.ID) {
	if m.removedcolli == nil {
		m.removedcolli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.colli, ids[i])
		m.removedcolli[ids[i]] = struct{}{}
	}
}

// RemovedColli returns the removed IDs of the "colli" edge to the Colli entity.
func (m *DeliveryOptionMutation) RemovedColliIDs() (ids []pulid.ID) {
	for id := range m.removedcolli {
		ids = append(ids, id)
	}
	return
}

// ColliIDs returns the "colli" edge IDs in the mutation.
func (m *DeliveryOptionMutation) ColliIDs() (ids []pulid.ID) {
	for id := range m.colli {
		ids = append(ids, id)
	}
	return
}

// ResetColli resets all changes to the "colli" edge.
func (m *DeliveryOptionMutation) ResetColli() {
	m.colli = nil
	m.clearedcolli = false
	m.removedcolli = nil
}

// AddReturnColliIDs adds the "return_colli" edge to the ReturnColli entity by ids.
func (m *DeliveryOptionMutation) AddReturnColliIDs(ids ...pulid.ID) {
	if m.return_colli == nil {
		m.return_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_colli[ids[i]] = struct{}{}
	}
}

// ClearReturnColli clears the "return_colli" edge to the ReturnColli entity.
func (m *DeliveryOptionMutation) ClearReturnColli() {
	m.clearedreturn_colli = true
}

// ReturnColliCleared reports if the "return_colli" edge to the ReturnColli entity was cleared.
func (m *DeliveryOptionMutation) ReturnColliCleared() bool {
	return m.clearedreturn_colli
}

// RemoveReturnColliIDs removes the "return_colli" edge to the ReturnColli entity by IDs.
func (m *DeliveryOptionMutation) RemoveReturnColliIDs(ids ...pulid.ID) {
	if m.removedreturn_colli == nil {
		m.removedreturn_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_colli, ids[i])
		m.removedreturn_colli[ids[i]] = struct{}{}
	}
}

// RemovedReturnColli returns the removed IDs of the "return_colli" edge to the ReturnColli entity.
func (m *DeliveryOptionMutation) RemovedReturnColliIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_colli {
		ids = append(ids, id)
	}
	return
}

// ReturnColliIDs returns the "return_colli" edge IDs in the mutation.
func (m *DeliveryOptionMutation) ReturnColliIDs() (ids []pulid.ID) {
	for id := range m.return_colli {
		ids = append(ids, id)
	}
	return
}

// ResetReturnColli resets all changes to the "return_colli" edge.
func (m *DeliveryOptionMutation) ResetReturnColli() {
	m.return_colli = nil
	m.clearedreturn_colli = false
	m.removedreturn_colli = nil
}

// SetCarrierServiceID sets the "carrier_service" edge to the CarrierService entity by id.
func (m *DeliveryOptionMutation) SetCarrierServiceID(id pulid.ID) {
	m.carrier_service = &id
}

// ClearCarrierService clears the "carrier_service" edge to the CarrierService entity.
func (m *DeliveryOptionMutation) ClearCarrierService() {
	m.clearedcarrier_service = true
}

// CarrierServiceCleared reports if the "carrier_service" edge to the CarrierService entity was cleared.
func (m *DeliveryOptionMutation) CarrierServiceCleared() bool {
	return m.clearedcarrier_service
}

// CarrierServiceID returns the "carrier_service" edge ID in the mutation.
func (m *DeliveryOptionMutation) CarrierServiceID() (id pulid.ID, exists bool) {
	if m.carrier_service != nil {
		return *m.carrier_service, true
	}
	return
}

// CarrierServiceIDs returns the "carrier_service" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierServiceID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) CarrierServiceIDs() (ids []pulid.ID) {
	if id := m.carrier_service; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierService resets all changes to the "carrier_service" edge.
func (m *DeliveryOptionMutation) ResetCarrierService() {
	m.carrier_service = nil
	m.clearedcarrier_service = false
}

// SetConnectionID sets the "connection" edge to the Connection entity by id.
func (m *DeliveryOptionMutation) SetConnectionID(id pulid.ID) {
	m.connection = &id
}

// ClearConnection clears the "connection" edge to the Connection entity.
func (m *DeliveryOptionMutation) ClearConnection() {
	m.clearedconnection = true
}

// ConnectionCleared reports if the "connection" edge to the Connection entity was cleared.
func (m *DeliveryOptionMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionID returns the "connection" edge ID in the mutation.
func (m *DeliveryOptionMutation) ConnectionID() (id pulid.ID, exists bool) {
	if m.connection != nil {
		return *m.connection, true
	}
	return
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) ConnectionIDs() (ids []pulid.ID) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *DeliveryOptionMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// SetConnectionDefaultID sets the "connection_default" edge to the Connection entity by id.
func (m *DeliveryOptionMutation) SetConnectionDefaultID(id pulid.ID) {
	m.connection_default = &id
}

// ClearConnectionDefault clears the "connection_default" edge to the Connection entity.
func (m *DeliveryOptionMutation) ClearConnectionDefault() {
	m.clearedconnection_default = true
}

// ConnectionDefaultCleared reports if the "connection_default" edge to the Connection entity was cleared.
func (m *DeliveryOptionMutation) ConnectionDefaultCleared() bool {
	return m.clearedconnection_default
}

// ConnectionDefaultID returns the "connection_default" edge ID in the mutation.
func (m *DeliveryOptionMutation) ConnectionDefaultID() (id pulid.ID, exists bool) {
	if m.connection_default != nil {
		return *m.connection_default, true
	}
	return
}

// ConnectionDefaultIDs returns the "connection_default" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionDefaultID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) ConnectionDefaultIDs() (ids []pulid.ID) {
	if id := m.connection_default; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnectionDefault resets all changes to the "connection_default" edge.
func (m *DeliveryOptionMutation) ResetConnectionDefault() {
	m.connection_default = nil
	m.clearedconnection_default = false
}

// AddHypothesisTestDeliveryOptionGroupOneIDs adds the "hypothesis_test_delivery_option_group_one" edge to the HypothesisTestDeliveryOption entity by ids.
func (m *DeliveryOptionMutation) AddHypothesisTestDeliveryOptionGroupOneIDs(ids ...pulid.ID) {
	if m.hypothesis_test_delivery_option_group_one == nil {
		m.hypothesis_test_delivery_option_group_one = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.hypothesis_test_delivery_option_group_one[ids[i]] = struct{}{}
	}
}

// ClearHypothesisTestDeliveryOptionGroupOne clears the "hypothesis_test_delivery_option_group_one" edge to the HypothesisTestDeliveryOption entity.
func (m *DeliveryOptionMutation) ClearHypothesisTestDeliveryOptionGroupOne() {
	m.clearedhypothesis_test_delivery_option_group_one = true
}

// HypothesisTestDeliveryOptionGroupOneCleared reports if the "hypothesis_test_delivery_option_group_one" edge to the HypothesisTestDeliveryOption entity was cleared.
func (m *DeliveryOptionMutation) HypothesisTestDeliveryOptionGroupOneCleared() bool {
	return m.clearedhypothesis_test_delivery_option_group_one
}

// RemoveHypothesisTestDeliveryOptionGroupOneIDs removes the "hypothesis_test_delivery_option_group_one" edge to the HypothesisTestDeliveryOption entity by IDs.
func (m *DeliveryOptionMutation) RemoveHypothesisTestDeliveryOptionGroupOneIDs(ids ...pulid.ID) {
	if m.removedhypothesis_test_delivery_option_group_one == nil {
		m.removedhypothesis_test_delivery_option_group_one = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.hypothesis_test_delivery_option_group_one, ids[i])
		m.removedhypothesis_test_delivery_option_group_one[ids[i]] = struct{}{}
	}
}

// RemovedHypothesisTestDeliveryOptionGroupOne returns the removed IDs of the "hypothesis_test_delivery_option_group_one" edge to the HypothesisTestDeliveryOption entity.
func (m *DeliveryOptionMutation) RemovedHypothesisTestDeliveryOptionGroupOneIDs() (ids []pulid.ID) {
	for id := range m.removedhypothesis_test_delivery_option_group_one {
		ids = append(ids, id)
	}
	return
}

// HypothesisTestDeliveryOptionGroupOneIDs returns the "hypothesis_test_delivery_option_group_one" edge IDs in the mutation.
func (m *DeliveryOptionMutation) HypothesisTestDeliveryOptionGroupOneIDs() (ids []pulid.ID) {
	for id := range m.hypothesis_test_delivery_option_group_one {
		ids = append(ids, id)
	}
	return
}

// ResetHypothesisTestDeliveryOptionGroupOne resets all changes to the "hypothesis_test_delivery_option_group_one" edge.
func (m *DeliveryOptionMutation) ResetHypothesisTestDeliveryOptionGroupOne() {
	m.hypothesis_test_delivery_option_group_one = nil
	m.clearedhypothesis_test_delivery_option_group_one = false
	m.removedhypothesis_test_delivery_option_group_one = nil
}

// AddHypothesisTestDeliveryOptionGroupTwoIDs adds the "hypothesis_test_delivery_option_group_two" edge to the HypothesisTestDeliveryOption entity by ids.
func (m *DeliveryOptionMutation) AddHypothesisTestDeliveryOptionGroupTwoIDs(ids ...pulid.ID) {
	if m.hypothesis_test_delivery_option_group_two == nil {
		m.hypothesis_test_delivery_option_group_two = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.hypothesis_test_delivery_option_group_two[ids[i]] = struct{}{}
	}
}

// ClearHypothesisTestDeliveryOptionGroupTwo clears the "hypothesis_test_delivery_option_group_two" edge to the HypothesisTestDeliveryOption entity.
func (m *DeliveryOptionMutation) ClearHypothesisTestDeliveryOptionGroupTwo() {
	m.clearedhypothesis_test_delivery_option_group_two = true
}

// HypothesisTestDeliveryOptionGroupTwoCleared reports if the "hypothesis_test_delivery_option_group_two" edge to the HypothesisTestDeliveryOption entity was cleared.
func (m *DeliveryOptionMutation) HypothesisTestDeliveryOptionGroupTwoCleared() bool {
	return m.clearedhypothesis_test_delivery_option_group_two
}

// RemoveHypothesisTestDeliveryOptionGroupTwoIDs removes the "hypothesis_test_delivery_option_group_two" edge to the HypothesisTestDeliveryOption entity by IDs.
func (m *DeliveryOptionMutation) RemoveHypothesisTestDeliveryOptionGroupTwoIDs(ids ...pulid.ID) {
	if m.removedhypothesis_test_delivery_option_group_two == nil {
		m.removedhypothesis_test_delivery_option_group_two = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.hypothesis_test_delivery_option_group_two, ids[i])
		m.removedhypothesis_test_delivery_option_group_two[ids[i]] = struct{}{}
	}
}

// RemovedHypothesisTestDeliveryOptionGroupTwo returns the removed IDs of the "hypothesis_test_delivery_option_group_two" edge to the HypothesisTestDeliveryOption entity.
func (m *DeliveryOptionMutation) RemovedHypothesisTestDeliveryOptionGroupTwoIDs() (ids []pulid.ID) {
	for id := range m.removedhypothesis_test_delivery_option_group_two {
		ids = append(ids, id)
	}
	return
}

// HypothesisTestDeliveryOptionGroupTwoIDs returns the "hypothesis_test_delivery_option_group_two" edge IDs in the mutation.
func (m *DeliveryOptionMutation) HypothesisTestDeliveryOptionGroupTwoIDs() (ids []pulid.ID) {
	for id := range m.hypothesis_test_delivery_option_group_two {
		ids = append(ids, id)
	}
	return
}

// ResetHypothesisTestDeliveryOptionGroupTwo resets all changes to the "hypothesis_test_delivery_option_group_two" edge.
func (m *DeliveryOptionMutation) ResetHypothesisTestDeliveryOptionGroupTwo() {
	m.hypothesis_test_delivery_option_group_two = nil
	m.clearedhypothesis_test_delivery_option_group_two = false
	m.removedhypothesis_test_delivery_option_group_two = nil
}

// AddHypothesisTestDeliveryOptionLookupIDs adds the "hypothesis_test_delivery_option_lookup" edge to the HypothesisTestDeliveryOptionLookup entity by ids.
func (m *DeliveryOptionMutation) AddHypothesisTestDeliveryOptionLookupIDs(ids ...pulid.ID) {
	if m.hypothesis_test_delivery_option_lookup == nil {
		m.hypothesis_test_delivery_option_lookup = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.hypothesis_test_delivery_option_lookup[ids[i]] = struct{}{}
	}
}

// ClearHypothesisTestDeliveryOptionLookup clears the "hypothesis_test_delivery_option_lookup" edge to the HypothesisTestDeliveryOptionLookup entity.
func (m *DeliveryOptionMutation) ClearHypothesisTestDeliveryOptionLookup() {
	m.clearedhypothesis_test_delivery_option_lookup = true
}

// HypothesisTestDeliveryOptionLookupCleared reports if the "hypothesis_test_delivery_option_lookup" edge to the HypothesisTestDeliveryOptionLookup entity was cleared.
func (m *DeliveryOptionMutation) HypothesisTestDeliveryOptionLookupCleared() bool {
	return m.clearedhypothesis_test_delivery_option_lookup
}

// RemoveHypothesisTestDeliveryOptionLookupIDs removes the "hypothesis_test_delivery_option_lookup" edge to the HypothesisTestDeliveryOptionLookup entity by IDs.
func (m *DeliveryOptionMutation) RemoveHypothesisTestDeliveryOptionLookupIDs(ids ...pulid.ID) {
	if m.removedhypothesis_test_delivery_option_lookup == nil {
		m.removedhypothesis_test_delivery_option_lookup = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.hypothesis_test_delivery_option_lookup, ids[i])
		m.removedhypothesis_test_delivery_option_lookup[ids[i]] = struct{}{}
	}
}

// RemovedHypothesisTestDeliveryOptionLookup returns the removed IDs of the "hypothesis_test_delivery_option_lookup" edge to the HypothesisTestDeliveryOptionLookup entity.
func (m *DeliveryOptionMutation) RemovedHypothesisTestDeliveryOptionLookupIDs() (ids []pulid.ID) {
	for id := range m.removedhypothesis_test_delivery_option_lookup {
		ids = append(ids, id)
	}
	return
}

// HypothesisTestDeliveryOptionLookupIDs returns the "hypothesis_test_delivery_option_lookup" edge IDs in the mutation.
func (m *DeliveryOptionMutation) HypothesisTestDeliveryOptionLookupIDs() (ids []pulid.ID) {
	for id := range m.hypothesis_test_delivery_option_lookup {
		ids = append(ids, id)
	}
	return
}

// ResetHypothesisTestDeliveryOptionLookup resets all changes to the "hypothesis_test_delivery_option_lookup" edge.
func (m *DeliveryOptionMutation) ResetHypothesisTestDeliveryOptionLookup() {
	m.hypothesis_test_delivery_option_lookup = nil
	m.clearedhypothesis_test_delivery_option_lookup = false
	m.removedhypothesis_test_delivery_option_lookup = nil
}

// AddClickCollectLocationIDs adds the "click_collect_location" edge to the Location entity by ids.
func (m *DeliveryOptionMutation) AddClickCollectLocationIDs(ids ...pulid.ID) {
	if m.click_collect_location == nil {
		m.click_collect_location = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.click_collect_location[ids[i]] = struct{}{}
	}
}

// ClearClickCollectLocation clears the "click_collect_location" edge to the Location entity.
func (m *DeliveryOptionMutation) ClearClickCollectLocation() {
	m.clearedclick_collect_location = true
}

// ClickCollectLocationCleared reports if the "click_collect_location" edge to the Location entity was cleared.
func (m *DeliveryOptionMutation) ClickCollectLocationCleared() bool {
	return m.clearedclick_collect_location
}

// RemoveClickCollectLocationIDs removes the "click_collect_location" edge to the Location entity by IDs.
func (m *DeliveryOptionMutation) RemoveClickCollectLocationIDs(ids ...pulid.ID) {
	if m.removedclick_collect_location == nil {
		m.removedclick_collect_location = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.click_collect_location, ids[i])
		m.removedclick_collect_location[ids[i]] = struct{}{}
	}
}

// RemovedClickCollectLocation returns the removed IDs of the "click_collect_location" edge to the Location entity.
func (m *DeliveryOptionMutation) RemovedClickCollectLocationIDs() (ids []pulid.ID) {
	for id := range m.removedclick_collect_location {
		ids = append(ids, id)
	}
	return
}

// ClickCollectLocationIDs returns the "click_collect_location" edge IDs in the mutation.
func (m *DeliveryOptionMutation) ClickCollectLocationIDs() (ids []pulid.ID) {
	for id := range m.click_collect_location {
		ids = append(ids, id)
	}
	return
}

// ResetClickCollectLocation resets all changes to the "click_collect_location" edge.
func (m *DeliveryOptionMutation) ResetClickCollectLocation() {
	m.click_collect_location = nil
	m.clearedclick_collect_location = false
	m.removedclick_collect_location = nil
}

// SetEmailClickCollectAtStoreID sets the "email_click_collect_at_store" edge to the EmailTemplate entity by id.
func (m *DeliveryOptionMutation) SetEmailClickCollectAtStoreID(id pulid.ID) {
	m.email_click_collect_at_store = &id
}

// ClearEmailClickCollectAtStore clears the "email_click_collect_at_store" edge to the EmailTemplate entity.
func (m *DeliveryOptionMutation) ClearEmailClickCollectAtStore() {
	m.clearedemail_click_collect_at_store = true
}

// EmailClickCollectAtStoreCleared reports if the "email_click_collect_at_store" edge to the EmailTemplate entity was cleared.
func (m *DeliveryOptionMutation) EmailClickCollectAtStoreCleared() bool {
	return m.clearedemail_click_collect_at_store
}

// EmailClickCollectAtStoreID returns the "email_click_collect_at_store" edge ID in the mutation.
func (m *DeliveryOptionMutation) EmailClickCollectAtStoreID() (id pulid.ID, exists bool) {
	if m.email_click_collect_at_store != nil {
		return *m.email_click_collect_at_store, true
	}
	return
}

// EmailClickCollectAtStoreIDs returns the "email_click_collect_at_store" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailClickCollectAtStoreID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) EmailClickCollectAtStoreIDs() (ids []pulid.ID) {
	if id := m.email_click_collect_at_store; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailClickCollectAtStore resets all changes to the "email_click_collect_at_store" edge.
func (m *DeliveryOptionMutation) ResetEmailClickCollectAtStore() {
	m.email_click_collect_at_store = nil
	m.clearedemail_click_collect_at_store = false
}

// AddConsolidationIDs adds the "consolidation" edge to the Consolidation entity by ids.
func (m *DeliveryOptionMutation) AddConsolidationIDs(ids ...pulid.ID) {
	if m.consolidation == nil {
		m.consolidation = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.consolidation[ids[i]] = struct{}{}
	}
}

// ClearConsolidation clears the "consolidation" edge to the Consolidation entity.
func (m *DeliveryOptionMutation) ClearConsolidation() {
	m.clearedconsolidation = true
}

// ConsolidationCleared reports if the "consolidation" edge to the Consolidation entity was cleared.
func (m *DeliveryOptionMutation) ConsolidationCleared() bool {
	return m.clearedconsolidation
}

// RemoveConsolidationIDs removes the "consolidation" edge to the Consolidation entity by IDs.
func (m *DeliveryOptionMutation) RemoveConsolidationIDs(ids ...pulid.ID) {
	if m.removedconsolidation == nil {
		m.removedconsolidation = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.consolidation, ids[i])
		m.removedconsolidation[ids[i]] = struct{}{}
	}
}

// RemovedConsolidation returns the removed IDs of the "consolidation" edge to the Consolidation entity.
func (m *DeliveryOptionMutation) RemovedConsolidationIDs() (ids []pulid.ID) {
	for id := range m.removedconsolidation {
		ids = append(ids, id)
	}
	return
}

// ConsolidationIDs returns the "consolidation" edge IDs in the mutation.
func (m *DeliveryOptionMutation) ConsolidationIDs() (ids []pulid.ID) {
	for id := range m.consolidation {
		ids = append(ids, id)
	}
	return
}

// ResetConsolidation resets all changes to the "consolidation" edge.
func (m *DeliveryOptionMutation) ResetConsolidation() {
	m.consolidation = nil
	m.clearedconsolidation = false
	m.removedconsolidation = nil
}

// SetDefaultPackagingID sets the "default_packaging" edge to the Packaging entity by id.
func (m *DeliveryOptionMutation) SetDefaultPackagingID(id pulid.ID) {
	m.default_packaging = &id
}

// ClearDefaultPackaging clears the "default_packaging" edge to the Packaging entity.
func (m *DeliveryOptionMutation) ClearDefaultPackaging() {
	m.cleareddefault_packaging = true
}

// DefaultPackagingCleared reports if the "default_packaging" edge to the Packaging entity was cleared.
func (m *DeliveryOptionMutation) DefaultPackagingCleared() bool {
	return m.cleareddefault_packaging
}

// DefaultPackagingID returns the "default_packaging" edge ID in the mutation.
func (m *DeliveryOptionMutation) DefaultPackagingID() (id pulid.ID, exists bool) {
	if m.default_packaging != nil {
		return *m.default_packaging, true
	}
	return
}

// DefaultPackagingIDs returns the "default_packaging" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultPackagingID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionMutation) DefaultPackagingIDs() (ids []pulid.ID) {
	if id := m.default_packaging; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultPackaging resets all changes to the "default_packaging" edge.
func (m *DeliveryOptionMutation) ResetDefaultPackaging() {
	m.default_packaging = nil
	m.cleareddefault_packaging = false
}

// Where appends a list predicates to the DeliveryOptionMutation builder.
func (m *DeliveryOptionMutation) Where(ps ...predicate.DeliveryOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryOption).
func (m *DeliveryOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryOptionMutation) Fields() []string {
	fields := make([]string, 0, 19)
	if m.tenant != nil {
		fields = append(fields, deliveryoption.FieldTenantID)
	}
	if m.archived_at != nil {
		fields = append(fields, deliveryoption.FieldArchivedAt)
	}
	if m.name != nil {
		fields = append(fields, deliveryoption.FieldName)
	}
	if m.sort_order != nil {
		fields = append(fields, deliveryoption.FieldSortOrder)
	}
	if m.click_option_display_count != nil {
		fields = append(fields, deliveryoption.FieldClickOptionDisplayCount)
	}
	if m.description != nil {
		fields = append(fields, deliveryoption.FieldDescription)
	}
	if m.click_collect != nil {
		fields = append(fields, deliveryoption.FieldClickCollect)
	}
	if m.override_sender_address != nil {
		fields = append(fields, deliveryoption.FieldOverrideSenderAddress)
	}
	if m.override_return_address != nil {
		fields = append(fields, deliveryoption.FieldOverrideReturnAddress)
	}
	if m.hide_delivery_option != nil {
		fields = append(fields, deliveryoption.FieldHideDeliveryOption)
	}
	if m.delivery_estimate_from != nil {
		fields = append(fields, deliveryoption.FieldDeliveryEstimateFrom)
	}
	if m.delivery_estimate_to != nil {
		fields = append(fields, deliveryoption.FieldDeliveryEstimateTo)
	}
	if m.webshipper_integration != nil {
		fields = append(fields, deliveryoption.FieldWebshipperIntegration)
	}
	if m.webshipper_id != nil {
		fields = append(fields, deliveryoption.FieldWebshipperID)
	}
	if m.shipmondo_integration != nil {
		fields = append(fields, deliveryoption.FieldShipmondoIntegration)
	}
	if m.shipmondo_delivery_option != nil {
		fields = append(fields, deliveryoption.FieldShipmondoDeliveryOption)
	}
	if m.customs_enabled != nil {
		fields = append(fields, deliveryoption.FieldCustomsEnabled)
	}
	if m.customs_signer != nil {
		fields = append(fields, deliveryoption.FieldCustomsSigner)
	}
	if m.hide_if_company_empty != nil {
		fields = append(fields, deliveryoption.FieldHideIfCompanyEmpty)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryoption.FieldTenantID:
		return m.TenantID()
	case deliveryoption.FieldArchivedAt:
		return m.ArchivedAt()
	case deliveryoption.FieldName:
		return m.Name()
	case deliveryoption.FieldSortOrder:
		return m.SortOrder()
	case deliveryoption.FieldClickOptionDisplayCount:
		return m.ClickOptionDisplayCount()
	case deliveryoption.FieldDescription:
		return m.Description()
	case deliveryoption.FieldClickCollect:
		return m.ClickCollect()
	case deliveryoption.FieldOverrideSenderAddress:
		return m.OverrideSenderAddress()
	case deliveryoption.FieldOverrideReturnAddress:
		return m.OverrideReturnAddress()
	case deliveryoption.FieldHideDeliveryOption:
		return m.HideDeliveryOption()
	case deliveryoption.FieldDeliveryEstimateFrom:
		return m.DeliveryEstimateFrom()
	case deliveryoption.FieldDeliveryEstimateTo:
		return m.DeliveryEstimateTo()
	case deliveryoption.FieldWebshipperIntegration:
		return m.WebshipperIntegration()
	case deliveryoption.FieldWebshipperID:
		return m.WebshipperID()
	case deliveryoption.FieldShipmondoIntegration:
		return m.ShipmondoIntegration()
	case deliveryoption.FieldShipmondoDeliveryOption:
		return m.ShipmondoDeliveryOption()
	case deliveryoption.FieldCustomsEnabled:
		return m.CustomsEnabled()
	case deliveryoption.FieldCustomsSigner:
		return m.CustomsSigner()
	case deliveryoption.FieldHideIfCompanyEmpty:
		return m.HideIfCompanyEmpty()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryoption.FieldTenantID:
		return m.OldTenantID(ctx)
	case deliveryoption.FieldArchivedAt:
		return m.OldArchivedAt(ctx)
	case deliveryoption.FieldName:
		return m.OldName(ctx)
	case deliveryoption.FieldSortOrder:
		return m.OldSortOrder(ctx)
	case deliveryoption.FieldClickOptionDisplayCount:
		return m.OldClickOptionDisplayCount(ctx)
	case deliveryoption.FieldDescription:
		return m.OldDescription(ctx)
	case deliveryoption.FieldClickCollect:
		return m.OldClickCollect(ctx)
	case deliveryoption.FieldOverrideSenderAddress:
		return m.OldOverrideSenderAddress(ctx)
	case deliveryoption.FieldOverrideReturnAddress:
		return m.OldOverrideReturnAddress(ctx)
	case deliveryoption.FieldHideDeliveryOption:
		return m.OldHideDeliveryOption(ctx)
	case deliveryoption.FieldDeliveryEstimateFrom:
		return m.OldDeliveryEstimateFrom(ctx)
	case deliveryoption.FieldDeliveryEstimateTo:
		return m.OldDeliveryEstimateTo(ctx)
	case deliveryoption.FieldWebshipperIntegration:
		return m.OldWebshipperIntegration(ctx)
	case deliveryoption.FieldWebshipperID:
		return m.OldWebshipperID(ctx)
	case deliveryoption.FieldShipmondoIntegration:
		return m.OldShipmondoIntegration(ctx)
	case deliveryoption.FieldShipmondoDeliveryOption:
		return m.OldShipmondoDeliveryOption(ctx)
	case deliveryoption.FieldCustomsEnabled:
		return m.OldCustomsEnabled(ctx)
	case deliveryoption.FieldCustomsSigner:
		return m.OldCustomsSigner(ctx)
	case deliveryoption.FieldHideIfCompanyEmpty:
		return m.OldHideIfCompanyEmpty(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryoption.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case deliveryoption.FieldArchivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedAt(v)
		return nil
	case deliveryoption.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deliveryoption.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSortOrder(v)
		return nil
	case deliveryoption.FieldClickOptionDisplayCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickOptionDisplayCount(v)
		return nil
	case deliveryoption.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case deliveryoption.FieldClickCollect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickCollect(v)
		return nil
	case deliveryoption.FieldOverrideSenderAddress:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideSenderAddress(v)
		return nil
	case deliveryoption.FieldOverrideReturnAddress:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOverrideReturnAddress(v)
		return nil
	case deliveryoption.FieldHideDeliveryOption:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideDeliveryOption(v)
		return nil
	case deliveryoption.FieldDeliveryEstimateFrom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryEstimateFrom(v)
		return nil
	case deliveryoption.FieldDeliveryEstimateTo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeliveryEstimateTo(v)
		return nil
	case deliveryoption.FieldWebshipperIntegration:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebshipperIntegration(v)
		return nil
	case deliveryoption.FieldWebshipperID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWebshipperID(v)
		return nil
	case deliveryoption.FieldShipmondoIntegration:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmondoIntegration(v)
		return nil
	case deliveryoption.FieldShipmondoDeliveryOption:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmondoDeliveryOption(v)
		return nil
	case deliveryoption.FieldCustomsEnabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomsEnabled(v)
		return nil
	case deliveryoption.FieldCustomsSigner:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomsSigner(v)
		return nil
	case deliveryoption.FieldHideIfCompanyEmpty:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHideIfCompanyEmpty(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryOptionMutation) AddedFields() []string {
	var fields []string
	if m.addsort_order != nil {
		fields = append(fields, deliveryoption.FieldSortOrder)
	}
	if m.addclick_option_display_count != nil {
		fields = append(fields, deliveryoption.FieldClickOptionDisplayCount)
	}
	if m.adddelivery_estimate_from != nil {
		fields = append(fields, deliveryoption.FieldDeliveryEstimateFrom)
	}
	if m.adddelivery_estimate_to != nil {
		fields = append(fields, deliveryoption.FieldDeliveryEstimateTo)
	}
	if m.addwebshipper_id != nil {
		fields = append(fields, deliveryoption.FieldWebshipperID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deliveryoption.FieldSortOrder:
		return m.AddedSortOrder()
	case deliveryoption.FieldClickOptionDisplayCount:
		return m.AddedClickOptionDisplayCount()
	case deliveryoption.FieldDeliveryEstimateFrom:
		return m.AddedDeliveryEstimateFrom()
	case deliveryoption.FieldDeliveryEstimateTo:
		return m.AddedDeliveryEstimateTo()
	case deliveryoption.FieldWebshipperID:
		return m.AddedWebshipperID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deliveryoption.FieldSortOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSortOrder(v)
		return nil
	case deliveryoption.FieldClickOptionDisplayCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddClickOptionDisplayCount(v)
		return nil
	case deliveryoption.FieldDeliveryEstimateFrom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryEstimateFrom(v)
		return nil
	case deliveryoption.FieldDeliveryEstimateTo:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeliveryEstimateTo(v)
		return nil
	case deliveryoption.FieldWebshipperID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWebshipperID(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryOptionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(deliveryoption.FieldArchivedAt) {
		fields = append(fields, deliveryoption.FieldArchivedAt)
	}
	if m.FieldCleared(deliveryoption.FieldClickOptionDisplayCount) {
		fields = append(fields, deliveryoption.FieldClickOptionDisplayCount)
	}
	if m.FieldCleared(deliveryoption.FieldDescription) {
		fields = append(fields, deliveryoption.FieldDescription)
	}
	if m.FieldCleared(deliveryoption.FieldClickCollect) {
		fields = append(fields, deliveryoption.FieldClickCollect)
	}
	if m.FieldCleared(deliveryoption.FieldOverrideSenderAddress) {
		fields = append(fields, deliveryoption.FieldOverrideSenderAddress)
	}
	if m.FieldCleared(deliveryoption.FieldOverrideReturnAddress) {
		fields = append(fields, deliveryoption.FieldOverrideReturnAddress)
	}
	if m.FieldCleared(deliveryoption.FieldHideDeliveryOption) {
		fields = append(fields, deliveryoption.FieldHideDeliveryOption)
	}
	if m.FieldCleared(deliveryoption.FieldDeliveryEstimateFrom) {
		fields = append(fields, deliveryoption.FieldDeliveryEstimateFrom)
	}
	if m.FieldCleared(deliveryoption.FieldDeliveryEstimateTo) {
		fields = append(fields, deliveryoption.FieldDeliveryEstimateTo)
	}
	if m.FieldCleared(deliveryoption.FieldWebshipperID) {
		fields = append(fields, deliveryoption.FieldWebshipperID)
	}
	if m.FieldCleared(deliveryoption.FieldShipmondoDeliveryOption) {
		fields = append(fields, deliveryoption.FieldShipmondoDeliveryOption)
	}
	if m.FieldCleared(deliveryoption.FieldCustomsSigner) {
		fields = append(fields, deliveryoption.FieldCustomsSigner)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryOptionMutation) ClearField(name string) error {
	switch name {
	case deliveryoption.FieldArchivedAt:
		m.ClearArchivedAt()
		return nil
	case deliveryoption.FieldClickOptionDisplayCount:
		m.ClearClickOptionDisplayCount()
		return nil
	case deliveryoption.FieldDescription:
		m.ClearDescription()
		return nil
	case deliveryoption.FieldClickCollect:
		m.ClearClickCollect()
		return nil
	case deliveryoption.FieldOverrideSenderAddress:
		m.ClearOverrideSenderAddress()
		return nil
	case deliveryoption.FieldOverrideReturnAddress:
		m.ClearOverrideReturnAddress()
		return nil
	case deliveryoption.FieldHideDeliveryOption:
		m.ClearHideDeliveryOption()
		return nil
	case deliveryoption.FieldDeliveryEstimateFrom:
		m.ClearDeliveryEstimateFrom()
		return nil
	case deliveryoption.FieldDeliveryEstimateTo:
		m.ClearDeliveryEstimateTo()
		return nil
	case deliveryoption.FieldWebshipperID:
		m.ClearWebshipperID()
		return nil
	case deliveryoption.FieldShipmondoDeliveryOption:
		m.ClearShipmondoDeliveryOption()
		return nil
	case deliveryoption.FieldCustomsSigner:
		m.ClearCustomsSigner()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryOptionMutation) ResetField(name string) error {
	switch name {
	case deliveryoption.FieldTenantID:
		m.ResetTenantID()
		return nil
	case deliveryoption.FieldArchivedAt:
		m.ResetArchivedAt()
		return nil
	case deliveryoption.FieldName:
		m.ResetName()
		return nil
	case deliveryoption.FieldSortOrder:
		m.ResetSortOrder()
		return nil
	case deliveryoption.FieldClickOptionDisplayCount:
		m.ResetClickOptionDisplayCount()
		return nil
	case deliveryoption.FieldDescription:
		m.ResetDescription()
		return nil
	case deliveryoption.FieldClickCollect:
		m.ResetClickCollect()
		return nil
	case deliveryoption.FieldOverrideSenderAddress:
		m.ResetOverrideSenderAddress()
		return nil
	case deliveryoption.FieldOverrideReturnAddress:
		m.ResetOverrideReturnAddress()
		return nil
	case deliveryoption.FieldHideDeliveryOption:
		m.ResetHideDeliveryOption()
		return nil
	case deliveryoption.FieldDeliveryEstimateFrom:
		m.ResetDeliveryEstimateFrom()
		return nil
	case deliveryoption.FieldDeliveryEstimateTo:
		m.ResetDeliveryEstimateTo()
		return nil
	case deliveryoption.FieldWebshipperIntegration:
		m.ResetWebshipperIntegration()
		return nil
	case deliveryoption.FieldWebshipperID:
		m.ResetWebshipperID()
		return nil
	case deliveryoption.FieldShipmondoIntegration:
		m.ResetShipmondoIntegration()
		return nil
	case deliveryoption.FieldShipmondoDeliveryOption:
		m.ResetShipmondoDeliveryOption()
		return nil
	case deliveryoption.FieldCustomsEnabled:
		m.ResetCustomsEnabled()
		return nil
	case deliveryoption.FieldCustomsSigner:
		m.ResetCustomsSigner()
		return nil
	case deliveryoption.FieldHideIfCompanyEmpty:
		m.ResetHideIfCompanyEmpty()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 24)
	if m.tenant != nil {
		edges = append(edges, deliveryoption.EdgeTenant)
	}
	if m.carrier != nil {
		edges = append(edges, deliveryoption.EdgeCarrier)
	}
	if m.delivery_rule != nil {
		edges = append(edges, deliveryoption.EdgeDeliveryRule)
	}
	if m.delivery_option_dao != nil {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionDAO)
	}
	if m.delivery_option_df != nil {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionDF)
	}
	if m.delivery_option_dsv != nil {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionDSV)
	}
	if m.delivery_option_easy_post != nil {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionEasyPost)
	}
	if m.delivery_option_gls != nil {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionGLS)
	}
	if m.delivery_option_post_nord != nil {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionPostNord)
	}
	if m.delivery_option_usps != nil {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionUSPS)
	}
	if m.delivery_option_bring != nil {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionBring)
	}
	if m.return_portals != nil {
		edges = append(edges, deliveryoption.EdgeReturnPortals)
	}
	if m.colli != nil {
		edges = append(edges, deliveryoption.EdgeColli)
	}
	if m.return_colli != nil {
		edges = append(edges, deliveryoption.EdgeReturnColli)
	}
	if m.carrier_service != nil {
		edges = append(edges, deliveryoption.EdgeCarrierService)
	}
	if m.connection != nil {
		edges = append(edges, deliveryoption.EdgeConnection)
	}
	if m.connection_default != nil {
		edges = append(edges, deliveryoption.EdgeConnectionDefault)
	}
	if m.hypothesis_test_delivery_option_group_one != nil {
		edges = append(edges, deliveryoption.EdgeHypothesisTestDeliveryOptionGroupOne)
	}
	if m.hypothesis_test_delivery_option_group_two != nil {
		edges = append(edges, deliveryoption.EdgeHypothesisTestDeliveryOptionGroupTwo)
	}
	if m.hypothesis_test_delivery_option_lookup != nil {
		edges = append(edges, deliveryoption.EdgeHypothesisTestDeliveryOptionLookup)
	}
	if m.click_collect_location != nil {
		edges = append(edges, deliveryoption.EdgeClickCollectLocation)
	}
	if m.email_click_collect_at_store != nil {
		edges = append(edges, deliveryoption.EdgeEmailClickCollectAtStore)
	}
	if m.consolidation != nil {
		edges = append(edges, deliveryoption.EdgeConsolidation)
	}
	if m.default_packaging != nil {
		edges = append(edges, deliveryoption.EdgeDefaultPackaging)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryoption.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeDeliveryRule:
		ids := make([]ent.Value, 0, len(m.delivery_rule))
		for id := range m.delivery_rule {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeDeliveryOptionDAO:
		if id := m.delivery_option_dao; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeDeliveryOptionDF:
		if id := m.delivery_option_df; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeDeliveryOptionDSV:
		if id := m.delivery_option_dsv; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeDeliveryOptionEasyPost:
		if id := m.delivery_option_easy_post; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeDeliveryOptionGLS:
		if id := m.delivery_option_gls; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeDeliveryOptionPostNord:
		if id := m.delivery_option_post_nord; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeDeliveryOptionUSPS:
		if id := m.delivery_option_usps; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeDeliveryOptionBring:
		if id := m.delivery_option_bring; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeReturnPortals:
		ids := make([]ent.Value, 0, len(m.return_portals))
		for id := range m.return_portals {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeColli:
		ids := make([]ent.Value, 0, len(m.colli))
		for id := range m.colli {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeReturnColli:
		ids := make([]ent.Value, 0, len(m.return_colli))
		for id := range m.return_colli {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeCarrierService:
		if id := m.carrier_service; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeConnectionDefault:
		if id := m.connection_default; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeHypothesisTestDeliveryOptionGroupOne:
		ids := make([]ent.Value, 0, len(m.hypothesis_test_delivery_option_group_one))
		for id := range m.hypothesis_test_delivery_option_group_one {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeHypothesisTestDeliveryOptionGroupTwo:
		ids := make([]ent.Value, 0, len(m.hypothesis_test_delivery_option_group_two))
		for id := range m.hypothesis_test_delivery_option_group_two {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeHypothesisTestDeliveryOptionLookup:
		ids := make([]ent.Value, 0, len(m.hypothesis_test_delivery_option_lookup))
		for id := range m.hypothesis_test_delivery_option_lookup {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeClickCollectLocation:
		ids := make([]ent.Value, 0, len(m.click_collect_location))
		for id := range m.click_collect_location {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeEmailClickCollectAtStore:
		if id := m.email_click_collect_at_store; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoption.EdgeConsolidation:
		ids := make([]ent.Value, 0, len(m.consolidation))
		for id := range m.consolidation {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeDefaultPackaging:
		if id := m.default_packaging; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 24)
	if m.removeddelivery_rule != nil {
		edges = append(edges, deliveryoption.EdgeDeliveryRule)
	}
	if m.removedreturn_portals != nil {
		edges = append(edges, deliveryoption.EdgeReturnPortals)
	}
	if m.removedcolli != nil {
		edges = append(edges, deliveryoption.EdgeColli)
	}
	if m.removedreturn_colli != nil {
		edges = append(edges, deliveryoption.EdgeReturnColli)
	}
	if m.removedhypothesis_test_delivery_option_group_one != nil {
		edges = append(edges, deliveryoption.EdgeHypothesisTestDeliveryOptionGroupOne)
	}
	if m.removedhypothesis_test_delivery_option_group_two != nil {
		edges = append(edges, deliveryoption.EdgeHypothesisTestDeliveryOptionGroupTwo)
	}
	if m.removedhypothesis_test_delivery_option_lookup != nil {
		edges = append(edges, deliveryoption.EdgeHypothesisTestDeliveryOptionLookup)
	}
	if m.removedclick_collect_location != nil {
		edges = append(edges, deliveryoption.EdgeClickCollectLocation)
	}
	if m.removedconsolidation != nil {
		edges = append(edges, deliveryoption.EdgeConsolidation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryOptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryoption.EdgeDeliveryRule:
		ids := make([]ent.Value, 0, len(m.removeddelivery_rule))
		for id := range m.removeddelivery_rule {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeReturnPortals:
		ids := make([]ent.Value, 0, len(m.removedreturn_portals))
		for id := range m.removedreturn_portals {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeColli:
		ids := make([]ent.Value, 0, len(m.removedcolli))
		for id := range m.removedcolli {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeReturnColli:
		ids := make([]ent.Value, 0, len(m.removedreturn_colli))
		for id := range m.removedreturn_colli {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeHypothesisTestDeliveryOptionGroupOne:
		ids := make([]ent.Value, 0, len(m.removedhypothesis_test_delivery_option_group_one))
		for id := range m.removedhypothesis_test_delivery_option_group_one {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeHypothesisTestDeliveryOptionGroupTwo:
		ids := make([]ent.Value, 0, len(m.removedhypothesis_test_delivery_option_group_two))
		for id := range m.removedhypothesis_test_delivery_option_group_two {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeHypothesisTestDeliveryOptionLookup:
		ids := make([]ent.Value, 0, len(m.removedhypothesis_test_delivery_option_lookup))
		for id := range m.removedhypothesis_test_delivery_option_lookup {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeClickCollectLocation:
		ids := make([]ent.Value, 0, len(m.removedclick_collect_location))
		for id := range m.removedclick_collect_location {
			ids = append(ids, id)
		}
		return ids
	case deliveryoption.EdgeConsolidation:
		ids := make([]ent.Value, 0, len(m.removedconsolidation))
		for id := range m.removedconsolidation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 24)
	if m.clearedtenant {
		edges = append(edges, deliveryoption.EdgeTenant)
	}
	if m.clearedcarrier {
		edges = append(edges, deliveryoption.EdgeCarrier)
	}
	if m.cleareddelivery_rule {
		edges = append(edges, deliveryoption.EdgeDeliveryRule)
	}
	if m.cleareddelivery_option_dao {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionDAO)
	}
	if m.cleareddelivery_option_df {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionDF)
	}
	if m.cleareddelivery_option_dsv {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionDSV)
	}
	if m.cleareddelivery_option_easy_post {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionEasyPost)
	}
	if m.cleareddelivery_option_gls {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionGLS)
	}
	if m.cleareddelivery_option_post_nord {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionPostNord)
	}
	if m.cleareddelivery_option_usps {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionUSPS)
	}
	if m.cleareddelivery_option_bring {
		edges = append(edges, deliveryoption.EdgeDeliveryOptionBring)
	}
	if m.clearedreturn_portals {
		edges = append(edges, deliveryoption.EdgeReturnPortals)
	}
	if m.clearedcolli {
		edges = append(edges, deliveryoption.EdgeColli)
	}
	if m.clearedreturn_colli {
		edges = append(edges, deliveryoption.EdgeReturnColli)
	}
	if m.clearedcarrier_service {
		edges = append(edges, deliveryoption.EdgeCarrierService)
	}
	if m.clearedconnection {
		edges = append(edges, deliveryoption.EdgeConnection)
	}
	if m.clearedconnection_default {
		edges = append(edges, deliveryoption.EdgeConnectionDefault)
	}
	if m.clearedhypothesis_test_delivery_option_group_one {
		edges = append(edges, deliveryoption.EdgeHypothesisTestDeliveryOptionGroupOne)
	}
	if m.clearedhypothesis_test_delivery_option_group_two {
		edges = append(edges, deliveryoption.EdgeHypothesisTestDeliveryOptionGroupTwo)
	}
	if m.clearedhypothesis_test_delivery_option_lookup {
		edges = append(edges, deliveryoption.EdgeHypothesisTestDeliveryOptionLookup)
	}
	if m.clearedclick_collect_location {
		edges = append(edges, deliveryoption.EdgeClickCollectLocation)
	}
	if m.clearedemail_click_collect_at_store {
		edges = append(edges, deliveryoption.EdgeEmailClickCollectAtStore)
	}
	if m.clearedconsolidation {
		edges = append(edges, deliveryoption.EdgeConsolidation)
	}
	if m.cleareddefault_packaging {
		edges = append(edges, deliveryoption.EdgeDefaultPackaging)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryoption.EdgeTenant:
		return m.clearedtenant
	case deliveryoption.EdgeCarrier:
		return m.clearedcarrier
	case deliveryoption.EdgeDeliveryRule:
		return m.cleareddelivery_rule
	case deliveryoption.EdgeDeliveryOptionDAO:
		return m.cleareddelivery_option_dao
	case deliveryoption.EdgeDeliveryOptionDF:
		return m.cleareddelivery_option_df
	case deliveryoption.EdgeDeliveryOptionDSV:
		return m.cleareddelivery_option_dsv
	case deliveryoption.EdgeDeliveryOptionEasyPost:
		return m.cleareddelivery_option_easy_post
	case deliveryoption.EdgeDeliveryOptionGLS:
		return m.cleareddelivery_option_gls
	case deliveryoption.EdgeDeliveryOptionPostNord:
		return m.cleareddelivery_option_post_nord
	case deliveryoption.EdgeDeliveryOptionUSPS:
		return m.cleareddelivery_option_usps
	case deliveryoption.EdgeDeliveryOptionBring:
		return m.cleareddelivery_option_bring
	case deliveryoption.EdgeReturnPortals:
		return m.clearedreturn_portals
	case deliveryoption.EdgeColli:
		return m.clearedcolli
	case deliveryoption.EdgeReturnColli:
		return m.clearedreturn_colli
	case deliveryoption.EdgeCarrierService:
		return m.clearedcarrier_service
	case deliveryoption.EdgeConnection:
		return m.clearedconnection
	case deliveryoption.EdgeConnectionDefault:
		return m.clearedconnection_default
	case deliveryoption.EdgeHypothesisTestDeliveryOptionGroupOne:
		return m.clearedhypothesis_test_delivery_option_group_one
	case deliveryoption.EdgeHypothesisTestDeliveryOptionGroupTwo:
		return m.clearedhypothesis_test_delivery_option_group_two
	case deliveryoption.EdgeHypothesisTestDeliveryOptionLookup:
		return m.clearedhypothesis_test_delivery_option_lookup
	case deliveryoption.EdgeClickCollectLocation:
		return m.clearedclick_collect_location
	case deliveryoption.EdgeEmailClickCollectAtStore:
		return m.clearedemail_click_collect_at_store
	case deliveryoption.EdgeConsolidation:
		return m.clearedconsolidation
	case deliveryoption.EdgeDefaultPackaging:
		return m.cleareddefault_packaging
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryOptionMutation) ClearEdge(name string) error {
	switch name {
	case deliveryoption.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryoption.EdgeCarrier:
		m.ClearCarrier()
		return nil
	case deliveryoption.EdgeDeliveryOptionDAO:
		m.ClearDeliveryOptionDAO()
		return nil
	case deliveryoption.EdgeDeliveryOptionDF:
		m.ClearDeliveryOptionDF()
		return nil
	case deliveryoption.EdgeDeliveryOptionDSV:
		m.ClearDeliveryOptionDSV()
		return nil
	case deliveryoption.EdgeDeliveryOptionEasyPost:
		m.ClearDeliveryOptionEasyPost()
		return nil
	case deliveryoption.EdgeDeliveryOptionGLS:
		m.ClearDeliveryOptionGLS()
		return nil
	case deliveryoption.EdgeDeliveryOptionPostNord:
		m.ClearDeliveryOptionPostNord()
		return nil
	case deliveryoption.EdgeDeliveryOptionUSPS:
		m.ClearDeliveryOptionUSPS()
		return nil
	case deliveryoption.EdgeDeliveryOptionBring:
		m.ClearDeliveryOptionBring()
		return nil
	case deliveryoption.EdgeCarrierService:
		m.ClearCarrierService()
		return nil
	case deliveryoption.EdgeConnection:
		m.ClearConnection()
		return nil
	case deliveryoption.EdgeConnectionDefault:
		m.ClearConnectionDefault()
		return nil
	case deliveryoption.EdgeEmailClickCollectAtStore:
		m.ClearEmailClickCollectAtStore()
		return nil
	case deliveryoption.EdgeDefaultPackaging:
		m.ClearDefaultPackaging()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryOptionMutation) ResetEdge(name string) error {
	switch name {
	case deliveryoption.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryoption.EdgeCarrier:
		m.ResetCarrier()
		return nil
	case deliveryoption.EdgeDeliveryRule:
		m.ResetDeliveryRule()
		return nil
	case deliveryoption.EdgeDeliveryOptionDAO:
		m.ResetDeliveryOptionDAO()
		return nil
	case deliveryoption.EdgeDeliveryOptionDF:
		m.ResetDeliveryOptionDF()
		return nil
	case deliveryoption.EdgeDeliveryOptionDSV:
		m.ResetDeliveryOptionDSV()
		return nil
	case deliveryoption.EdgeDeliveryOptionEasyPost:
		m.ResetDeliveryOptionEasyPost()
		return nil
	case deliveryoption.EdgeDeliveryOptionGLS:
		m.ResetDeliveryOptionGLS()
		return nil
	case deliveryoption.EdgeDeliveryOptionPostNord:
		m.ResetDeliveryOptionPostNord()
		return nil
	case deliveryoption.EdgeDeliveryOptionUSPS:
		m.ResetDeliveryOptionUSPS()
		return nil
	case deliveryoption.EdgeDeliveryOptionBring:
		m.ResetDeliveryOptionBring()
		return nil
	case deliveryoption.EdgeReturnPortals:
		m.ResetReturnPortals()
		return nil
	case deliveryoption.EdgeColli:
		m.ResetColli()
		return nil
	case deliveryoption.EdgeReturnColli:
		m.ResetReturnColli()
		return nil
	case deliveryoption.EdgeCarrierService:
		m.ResetCarrierService()
		return nil
	case deliveryoption.EdgeConnection:
		m.ResetConnection()
		return nil
	case deliveryoption.EdgeConnectionDefault:
		m.ResetConnectionDefault()
		return nil
	case deliveryoption.EdgeHypothesisTestDeliveryOptionGroupOne:
		m.ResetHypothesisTestDeliveryOptionGroupOne()
		return nil
	case deliveryoption.EdgeHypothesisTestDeliveryOptionGroupTwo:
		m.ResetHypothesisTestDeliveryOptionGroupTwo()
		return nil
	case deliveryoption.EdgeHypothesisTestDeliveryOptionLookup:
		m.ResetHypothesisTestDeliveryOptionLookup()
		return nil
	case deliveryoption.EdgeClickCollectLocation:
		m.ResetClickCollectLocation()
		return nil
	case deliveryoption.EdgeEmailClickCollectAtStore:
		m.ResetEmailClickCollectAtStore()
		return nil
	case deliveryoption.EdgeConsolidation:
		m.ResetConsolidation()
		return nil
	case deliveryoption.EdgeDefaultPackaging:
		m.ResetDefaultPackaging()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOption edge %s", name)
}

// DeliveryOptionBringMutation represents an operation that mutates the DeliveryOptionBring nodes in the graph.
type DeliveryOptionBringMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *pulid.ID
	electronic_customs                      *bool
	clearedFields                           map[string]struct{}
	tenant                                  *pulid.ID
	clearedtenant                           bool
	delivery_option                         *pulid.ID
	cleareddelivery_option                  bool
	carrier_additional_service_bring        map[pulid.ID]struct{}
	removedcarrier_additional_service_bring map[pulid.ID]struct{}
	clearedcarrier_additional_service_bring bool
	done                                    bool
	oldValue                                func(context.Context) (*DeliveryOptionBring, error)
	predicates                              []predicate.DeliveryOptionBring
}

var _ ent.Mutation = (*DeliveryOptionBringMutation)(nil)

// deliveryoptionbringOption allows management of the mutation configuration using functional options.
type deliveryoptionbringOption func(*DeliveryOptionBringMutation)

// newDeliveryOptionBringMutation creates new mutation for the DeliveryOptionBring entity.
func newDeliveryOptionBringMutation(c config, op Op, opts ...deliveryoptionbringOption) *DeliveryOptionBringMutation {
	m := &DeliveryOptionBringMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryOptionBring,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryOptionBringID sets the ID field of the mutation.
func withDeliveryOptionBringID(id pulid.ID) deliveryoptionbringOption {
	return func(m *DeliveryOptionBringMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryOptionBring
		)
		m.oldValue = func(ctx context.Context) (*DeliveryOptionBring, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryOptionBring.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryOptionBring sets the old DeliveryOptionBring of the mutation.
func withDeliveryOptionBring(node *DeliveryOptionBring) deliveryoptionbringOption {
	return func(m *DeliveryOptionBringMutation) {
		m.oldValue = func(context.Context) (*DeliveryOptionBring, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryOptionBringMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryOptionBringMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryOptionBring entities.
func (m *DeliveryOptionBringMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryOptionBringMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryOptionBringMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryOptionBring.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryOptionBringMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryOptionBringMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryOptionBring entity.
// If the DeliveryOptionBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionBringMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryOptionBringMutation) ResetTenantID() {
	m.tenant = nil
}

// SetElectronicCustoms sets the "electronic_customs" field.
func (m *DeliveryOptionBringMutation) SetElectronicCustoms(b bool) {
	m.electronic_customs = &b
}

// ElectronicCustoms returns the value of the "electronic_customs" field in the mutation.
func (m *DeliveryOptionBringMutation) ElectronicCustoms() (r bool, exists bool) {
	v := m.electronic_customs
	if v == nil {
		return
	}
	return *v, true
}

// OldElectronicCustoms returns the old "electronic_customs" field's value of the DeliveryOptionBring entity.
// If the DeliveryOptionBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionBringMutation) OldElectronicCustoms(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldElectronicCustoms is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldElectronicCustoms requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldElectronicCustoms: %w", err)
	}
	return oldValue.ElectronicCustoms, nil
}

// ResetElectronicCustoms resets all changes to the "electronic_customs" field.
func (m *DeliveryOptionBringMutation) ResetElectronicCustoms() {
	m.electronic_customs = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryOptionBringMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryoptionbring.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryOptionBringMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionBringMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryOptionBringMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *DeliveryOptionBringMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *DeliveryOptionBringMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *DeliveryOptionBringMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *DeliveryOptionBringMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionBringMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *DeliveryOptionBringMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// AddCarrierAdditionalServiceBringIDs adds the "carrier_additional_service_bring" edge to the CarrierAdditionalServiceBring entity by ids.
func (m *DeliveryOptionBringMutation) AddCarrierAdditionalServiceBringIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_bring == nil {
		m.carrier_additional_service_bring = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_bring[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceBring clears the "carrier_additional_service_bring" edge to the CarrierAdditionalServiceBring entity.
func (m *DeliveryOptionBringMutation) ClearCarrierAdditionalServiceBring() {
	m.clearedcarrier_additional_service_bring = true
}

// CarrierAdditionalServiceBringCleared reports if the "carrier_additional_service_bring" edge to the CarrierAdditionalServiceBring entity was cleared.
func (m *DeliveryOptionBringMutation) CarrierAdditionalServiceBringCleared() bool {
	return m.clearedcarrier_additional_service_bring
}

// RemoveCarrierAdditionalServiceBringIDs removes the "carrier_additional_service_bring" edge to the CarrierAdditionalServiceBring entity by IDs.
func (m *DeliveryOptionBringMutation) RemoveCarrierAdditionalServiceBringIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_bring == nil {
		m.removedcarrier_additional_service_bring = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_bring, ids[i])
		m.removedcarrier_additional_service_bring[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceBring returns the removed IDs of the "carrier_additional_service_bring" edge to the CarrierAdditionalServiceBring entity.
func (m *DeliveryOptionBringMutation) RemovedCarrierAdditionalServiceBringIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_bring {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceBringIDs returns the "carrier_additional_service_bring" edge IDs in the mutation.
func (m *DeliveryOptionBringMutation) CarrierAdditionalServiceBringIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_bring {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceBring resets all changes to the "carrier_additional_service_bring" edge.
func (m *DeliveryOptionBringMutation) ResetCarrierAdditionalServiceBring() {
	m.carrier_additional_service_bring = nil
	m.clearedcarrier_additional_service_bring = false
	m.removedcarrier_additional_service_bring = nil
}

// Where appends a list predicates to the DeliveryOptionBringMutation builder.
func (m *DeliveryOptionBringMutation) Where(ps ...predicate.DeliveryOptionBring) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryOptionBringMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryOptionBringMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryOptionBring, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryOptionBringMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryOptionBringMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryOptionBring).
func (m *DeliveryOptionBringMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryOptionBringMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, deliveryoptionbring.FieldTenantID)
	}
	if m.electronic_customs != nil {
		fields = append(fields, deliveryoptionbring.FieldElectronicCustoms)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryOptionBringMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryoptionbring.FieldTenantID:
		return m.TenantID()
	case deliveryoptionbring.FieldElectronicCustoms:
		return m.ElectronicCustoms()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryOptionBringMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryoptionbring.FieldTenantID:
		return m.OldTenantID(ctx)
	case deliveryoptionbring.FieldElectronicCustoms:
		return m.OldElectronicCustoms(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryOptionBring field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionBringMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryoptionbring.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case deliveryoptionbring.FieldElectronicCustoms:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetElectronicCustoms(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionBring field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryOptionBringMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryOptionBringMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionBringMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryOptionBring numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryOptionBringMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryOptionBringMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryOptionBringMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryOptionBring nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryOptionBringMutation) ResetField(name string) error {
	switch name {
	case deliveryoptionbring.FieldTenantID:
		m.ResetTenantID()
		return nil
	case deliveryoptionbring.FieldElectronicCustoms:
		m.ResetElectronicCustoms()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionBring field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryOptionBringMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, deliveryoptionbring.EdgeTenant)
	}
	if m.delivery_option != nil {
		edges = append(edges, deliveryoptionbring.EdgeDeliveryOption)
	}
	if m.carrier_additional_service_bring != nil {
		edges = append(edges, deliveryoptionbring.EdgeCarrierAdditionalServiceBring)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryOptionBringMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptionbring.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptionbring.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptionbring.EdgeCarrierAdditionalServiceBring:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_bring))
		for id := range m.carrier_additional_service_bring {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryOptionBringMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcarrier_additional_service_bring != nil {
		edges = append(edges, deliveryoptionbring.EdgeCarrierAdditionalServiceBring)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryOptionBringMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptionbring.EdgeCarrierAdditionalServiceBring:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_bring))
		for id := range m.removedcarrier_additional_service_bring {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryOptionBringMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, deliveryoptionbring.EdgeTenant)
	}
	if m.cleareddelivery_option {
		edges = append(edges, deliveryoptionbring.EdgeDeliveryOption)
	}
	if m.clearedcarrier_additional_service_bring {
		edges = append(edges, deliveryoptionbring.EdgeCarrierAdditionalServiceBring)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryOptionBringMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryoptionbring.EdgeTenant:
		return m.clearedtenant
	case deliveryoptionbring.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case deliveryoptionbring.EdgeCarrierAdditionalServiceBring:
		return m.clearedcarrier_additional_service_bring
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryOptionBringMutation) ClearEdge(name string) error {
	switch name {
	case deliveryoptionbring.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryoptionbring.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionBring unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryOptionBringMutation) ResetEdge(name string) error {
	switch name {
	case deliveryoptionbring.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryoptionbring.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case deliveryoptionbring.EdgeCarrierAdditionalServiceBring:
		m.ResetCarrierAdditionalServiceBring()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionBring edge %s", name)
}

// DeliveryOptionDAOMutation represents an operation that mutates the DeliveryOptionDAO nodes in the graph.
type DeliveryOptionDAOMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *pulid.ID
	clearedFields                         map[string]struct{}
	tenant                                *pulid.ID
	clearedtenant                         bool
	delivery_option                       *pulid.ID
	cleareddelivery_option                bool
	carrier_additional_service_dao        map[pulid.ID]struct{}
	removedcarrier_additional_service_dao map[pulid.ID]struct{}
	clearedcarrier_additional_service_dao bool
	done                                  bool
	oldValue                              func(context.Context) (*DeliveryOptionDAO, error)
	predicates                            []predicate.DeliveryOptionDAO
}

var _ ent.Mutation = (*DeliveryOptionDAOMutation)(nil)

// deliveryoptiondaoOption allows management of the mutation configuration using functional options.
type deliveryoptiondaoOption func(*DeliveryOptionDAOMutation)

// newDeliveryOptionDAOMutation creates new mutation for the DeliveryOptionDAO entity.
func newDeliveryOptionDAOMutation(c config, op Op, opts ...deliveryoptiondaoOption) *DeliveryOptionDAOMutation {
	m := &DeliveryOptionDAOMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryOptionDAO,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryOptionDAOID sets the ID field of the mutation.
func withDeliveryOptionDAOID(id pulid.ID) deliveryoptiondaoOption {
	return func(m *DeliveryOptionDAOMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryOptionDAO
		)
		m.oldValue = func(ctx context.Context) (*DeliveryOptionDAO, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryOptionDAO.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryOptionDAO sets the old DeliveryOptionDAO of the mutation.
func withDeliveryOptionDAO(node *DeliveryOptionDAO) deliveryoptiondaoOption {
	return func(m *DeliveryOptionDAOMutation) {
		m.oldValue = func(context.Context) (*DeliveryOptionDAO, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryOptionDAOMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryOptionDAOMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryOptionDAO entities.
func (m *DeliveryOptionDAOMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryOptionDAOMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryOptionDAOMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryOptionDAO.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryOptionDAOMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryOptionDAOMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryOptionDAO entity.
// If the DeliveryOptionDAO object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionDAOMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryOptionDAOMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryOptionDAOMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryoptiondao.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryOptionDAOMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionDAOMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryOptionDAOMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *DeliveryOptionDAOMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *DeliveryOptionDAOMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *DeliveryOptionDAOMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *DeliveryOptionDAOMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionDAOMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *DeliveryOptionDAOMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// AddCarrierAdditionalServiceDAOIDs adds the "carrier_additional_service_dao" edge to the CarrierAdditionalServiceDAO entity by ids.
func (m *DeliveryOptionDAOMutation) AddCarrierAdditionalServiceDAOIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_dao == nil {
		m.carrier_additional_service_dao = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_dao[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceDAO clears the "carrier_additional_service_dao" edge to the CarrierAdditionalServiceDAO entity.
func (m *DeliveryOptionDAOMutation) ClearCarrierAdditionalServiceDAO() {
	m.clearedcarrier_additional_service_dao = true
}

// CarrierAdditionalServiceDAOCleared reports if the "carrier_additional_service_dao" edge to the CarrierAdditionalServiceDAO entity was cleared.
func (m *DeliveryOptionDAOMutation) CarrierAdditionalServiceDAOCleared() bool {
	return m.clearedcarrier_additional_service_dao
}

// RemoveCarrierAdditionalServiceDAOIDs removes the "carrier_additional_service_dao" edge to the CarrierAdditionalServiceDAO entity by IDs.
func (m *DeliveryOptionDAOMutation) RemoveCarrierAdditionalServiceDAOIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_dao == nil {
		m.removedcarrier_additional_service_dao = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_dao, ids[i])
		m.removedcarrier_additional_service_dao[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceDAO returns the removed IDs of the "carrier_additional_service_dao" edge to the CarrierAdditionalServiceDAO entity.
func (m *DeliveryOptionDAOMutation) RemovedCarrierAdditionalServiceDAOIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_dao {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceDAOIDs returns the "carrier_additional_service_dao" edge IDs in the mutation.
func (m *DeliveryOptionDAOMutation) CarrierAdditionalServiceDAOIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_dao {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceDAO resets all changes to the "carrier_additional_service_dao" edge.
func (m *DeliveryOptionDAOMutation) ResetCarrierAdditionalServiceDAO() {
	m.carrier_additional_service_dao = nil
	m.clearedcarrier_additional_service_dao = false
	m.removedcarrier_additional_service_dao = nil
}

// Where appends a list predicates to the DeliveryOptionDAOMutation builder.
func (m *DeliveryOptionDAOMutation) Where(ps ...predicate.DeliveryOptionDAO) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryOptionDAOMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryOptionDAOMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryOptionDAO, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryOptionDAOMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryOptionDAOMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryOptionDAO).
func (m *DeliveryOptionDAOMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryOptionDAOMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tenant != nil {
		fields = append(fields, deliveryoptiondao.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryOptionDAOMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryoptiondao.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryOptionDAOMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryoptiondao.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryOptionDAO field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionDAOMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryoptiondao.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDAO field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryOptionDAOMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryOptionDAOMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionDAOMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryOptionDAO numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryOptionDAOMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryOptionDAOMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryOptionDAOMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryOptionDAO nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryOptionDAOMutation) ResetField(name string) error {
	switch name {
	case deliveryoptiondao.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDAO field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryOptionDAOMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, deliveryoptiondao.EdgeTenant)
	}
	if m.delivery_option != nil {
		edges = append(edges, deliveryoptiondao.EdgeDeliveryOption)
	}
	if m.carrier_additional_service_dao != nil {
		edges = append(edges, deliveryoptiondao.EdgeCarrierAdditionalServiceDAO)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryOptionDAOMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptiondao.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptiondao.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptiondao.EdgeCarrierAdditionalServiceDAO:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_dao))
		for id := range m.carrier_additional_service_dao {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryOptionDAOMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcarrier_additional_service_dao != nil {
		edges = append(edges, deliveryoptiondao.EdgeCarrierAdditionalServiceDAO)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryOptionDAOMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptiondao.EdgeCarrierAdditionalServiceDAO:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_dao))
		for id := range m.removedcarrier_additional_service_dao {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryOptionDAOMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, deliveryoptiondao.EdgeTenant)
	}
	if m.cleareddelivery_option {
		edges = append(edges, deliveryoptiondao.EdgeDeliveryOption)
	}
	if m.clearedcarrier_additional_service_dao {
		edges = append(edges, deliveryoptiondao.EdgeCarrierAdditionalServiceDAO)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryOptionDAOMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryoptiondao.EdgeTenant:
		return m.clearedtenant
	case deliveryoptiondao.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case deliveryoptiondao.EdgeCarrierAdditionalServiceDAO:
		return m.clearedcarrier_additional_service_dao
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryOptionDAOMutation) ClearEdge(name string) error {
	switch name {
	case deliveryoptiondao.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryoptiondao.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDAO unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryOptionDAOMutation) ResetEdge(name string) error {
	switch name {
	case deliveryoptiondao.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryoptiondao.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case deliveryoptiondao.EdgeCarrierAdditionalServiceDAO:
		m.ResetCarrierAdditionalServiceDAO()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDAO edge %s", name)
}

// DeliveryOptionDFMutation represents an operation that mutates the DeliveryOptionDF nodes in the graph.
type DeliveryOptionDFMutation struct {
	config
	op                                   Op
	typ                                  string
	id                                   *pulid.ID
	clearedFields                        map[string]struct{}
	tenant                               *pulid.ID
	clearedtenant                        bool
	delivery_option                      *pulid.ID
	cleareddelivery_option               bool
	carrier_additional_service_df        map[pulid.ID]struct{}
	removedcarrier_additional_service_df map[pulid.ID]struct{}
	clearedcarrier_additional_service_df bool
	done                                 bool
	oldValue                             func(context.Context) (*DeliveryOptionDF, error)
	predicates                           []predicate.DeliveryOptionDF
}

var _ ent.Mutation = (*DeliveryOptionDFMutation)(nil)

// deliveryoptiondfOption allows management of the mutation configuration using functional options.
type deliveryoptiondfOption func(*DeliveryOptionDFMutation)

// newDeliveryOptionDFMutation creates new mutation for the DeliveryOptionDF entity.
func newDeliveryOptionDFMutation(c config, op Op, opts ...deliveryoptiondfOption) *DeliveryOptionDFMutation {
	m := &DeliveryOptionDFMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryOptionDF,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryOptionDFID sets the ID field of the mutation.
func withDeliveryOptionDFID(id pulid.ID) deliveryoptiondfOption {
	return func(m *DeliveryOptionDFMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryOptionDF
		)
		m.oldValue = func(ctx context.Context) (*DeliveryOptionDF, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryOptionDF.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryOptionDF sets the old DeliveryOptionDF of the mutation.
func withDeliveryOptionDF(node *DeliveryOptionDF) deliveryoptiondfOption {
	return func(m *DeliveryOptionDFMutation) {
		m.oldValue = func(context.Context) (*DeliveryOptionDF, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryOptionDFMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryOptionDFMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryOptionDF entities.
func (m *DeliveryOptionDFMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryOptionDFMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryOptionDFMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryOptionDF.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryOptionDFMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryOptionDFMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryOptionDF entity.
// If the DeliveryOptionDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionDFMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryOptionDFMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryOptionDFMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryoptiondf.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryOptionDFMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionDFMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryOptionDFMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *DeliveryOptionDFMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *DeliveryOptionDFMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *DeliveryOptionDFMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *DeliveryOptionDFMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionDFMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *DeliveryOptionDFMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// AddCarrierAdditionalServiceDFIDs adds the "carrier_additional_service_df" edge to the CarrierAdditionalServiceDF entity by ids.
func (m *DeliveryOptionDFMutation) AddCarrierAdditionalServiceDFIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_df == nil {
		m.carrier_additional_service_df = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_df[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceDF clears the "carrier_additional_service_df" edge to the CarrierAdditionalServiceDF entity.
func (m *DeliveryOptionDFMutation) ClearCarrierAdditionalServiceDF() {
	m.clearedcarrier_additional_service_df = true
}

// CarrierAdditionalServiceDFCleared reports if the "carrier_additional_service_df" edge to the CarrierAdditionalServiceDF entity was cleared.
func (m *DeliveryOptionDFMutation) CarrierAdditionalServiceDFCleared() bool {
	return m.clearedcarrier_additional_service_df
}

// RemoveCarrierAdditionalServiceDFIDs removes the "carrier_additional_service_df" edge to the CarrierAdditionalServiceDF entity by IDs.
func (m *DeliveryOptionDFMutation) RemoveCarrierAdditionalServiceDFIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_df == nil {
		m.removedcarrier_additional_service_df = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_df, ids[i])
		m.removedcarrier_additional_service_df[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceDF returns the removed IDs of the "carrier_additional_service_df" edge to the CarrierAdditionalServiceDF entity.
func (m *DeliveryOptionDFMutation) RemovedCarrierAdditionalServiceDFIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_df {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceDFIDs returns the "carrier_additional_service_df" edge IDs in the mutation.
func (m *DeliveryOptionDFMutation) CarrierAdditionalServiceDFIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_df {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceDF resets all changes to the "carrier_additional_service_df" edge.
func (m *DeliveryOptionDFMutation) ResetCarrierAdditionalServiceDF() {
	m.carrier_additional_service_df = nil
	m.clearedcarrier_additional_service_df = false
	m.removedcarrier_additional_service_df = nil
}

// Where appends a list predicates to the DeliveryOptionDFMutation builder.
func (m *DeliveryOptionDFMutation) Where(ps ...predicate.DeliveryOptionDF) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryOptionDFMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryOptionDFMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryOptionDF, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryOptionDFMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryOptionDFMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryOptionDF).
func (m *DeliveryOptionDFMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryOptionDFMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tenant != nil {
		fields = append(fields, deliveryoptiondf.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryOptionDFMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryoptiondf.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryOptionDFMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryoptiondf.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryOptionDF field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionDFMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryoptiondf.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDF field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryOptionDFMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryOptionDFMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionDFMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryOptionDF numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryOptionDFMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryOptionDFMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryOptionDFMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryOptionDF nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryOptionDFMutation) ResetField(name string) error {
	switch name {
	case deliveryoptiondf.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDF field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryOptionDFMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, deliveryoptiondf.EdgeTenant)
	}
	if m.delivery_option != nil {
		edges = append(edges, deliveryoptiondf.EdgeDeliveryOption)
	}
	if m.carrier_additional_service_df != nil {
		edges = append(edges, deliveryoptiondf.EdgeCarrierAdditionalServiceDF)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryOptionDFMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptiondf.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptiondf.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptiondf.EdgeCarrierAdditionalServiceDF:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_df))
		for id := range m.carrier_additional_service_df {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryOptionDFMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcarrier_additional_service_df != nil {
		edges = append(edges, deliveryoptiondf.EdgeCarrierAdditionalServiceDF)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryOptionDFMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptiondf.EdgeCarrierAdditionalServiceDF:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_df))
		for id := range m.removedcarrier_additional_service_df {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryOptionDFMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, deliveryoptiondf.EdgeTenant)
	}
	if m.cleareddelivery_option {
		edges = append(edges, deliveryoptiondf.EdgeDeliveryOption)
	}
	if m.clearedcarrier_additional_service_df {
		edges = append(edges, deliveryoptiondf.EdgeCarrierAdditionalServiceDF)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryOptionDFMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryoptiondf.EdgeTenant:
		return m.clearedtenant
	case deliveryoptiondf.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case deliveryoptiondf.EdgeCarrierAdditionalServiceDF:
		return m.clearedcarrier_additional_service_df
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryOptionDFMutation) ClearEdge(name string) error {
	switch name {
	case deliveryoptiondf.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryoptiondf.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDF unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryOptionDFMutation) ResetEdge(name string) error {
	switch name {
	case deliveryoptiondf.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryoptiondf.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case deliveryoptiondf.EdgeCarrierAdditionalServiceDF:
		m.ResetCarrierAdditionalServiceDF()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDF edge %s", name)
}

// DeliveryOptionDSVMutation represents an operation that mutates the DeliveryOptionDSV nodes in the graph.
type DeliveryOptionDSVMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *pulid.ID
	clearedFields                         map[string]struct{}
	tenant                                *pulid.ID
	clearedtenant                         bool
	delivery_option                       *pulid.ID
	cleareddelivery_option                bool
	carrier_additional_service_dsv        map[pulid.ID]struct{}
	removedcarrier_additional_service_dsv map[pulid.ID]struct{}
	clearedcarrier_additional_service_dsv bool
	done                                  bool
	oldValue                              func(context.Context) (*DeliveryOptionDSV, error)
	predicates                            []predicate.DeliveryOptionDSV
}

var _ ent.Mutation = (*DeliveryOptionDSVMutation)(nil)

// deliveryoptiondsvOption allows management of the mutation configuration using functional options.
type deliveryoptiondsvOption func(*DeliveryOptionDSVMutation)

// newDeliveryOptionDSVMutation creates new mutation for the DeliveryOptionDSV entity.
func newDeliveryOptionDSVMutation(c config, op Op, opts ...deliveryoptiondsvOption) *DeliveryOptionDSVMutation {
	m := &DeliveryOptionDSVMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryOptionDSV,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryOptionDSVID sets the ID field of the mutation.
func withDeliveryOptionDSVID(id pulid.ID) deliveryoptiondsvOption {
	return func(m *DeliveryOptionDSVMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryOptionDSV
		)
		m.oldValue = func(ctx context.Context) (*DeliveryOptionDSV, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryOptionDSV.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryOptionDSV sets the old DeliveryOptionDSV of the mutation.
func withDeliveryOptionDSV(node *DeliveryOptionDSV) deliveryoptiondsvOption {
	return func(m *DeliveryOptionDSVMutation) {
		m.oldValue = func(context.Context) (*DeliveryOptionDSV, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryOptionDSVMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryOptionDSVMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryOptionDSV entities.
func (m *DeliveryOptionDSVMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryOptionDSVMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryOptionDSVMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryOptionDSV.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryOptionDSVMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryOptionDSVMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryOptionDSV entity.
// If the DeliveryOptionDSV object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionDSVMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryOptionDSVMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryOptionDSVMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryoptiondsv.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryOptionDSVMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionDSVMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryOptionDSVMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *DeliveryOptionDSVMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *DeliveryOptionDSVMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *DeliveryOptionDSVMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *DeliveryOptionDSVMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionDSVMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *DeliveryOptionDSVMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// AddCarrierAdditionalServiceDSVIDs adds the "carrier_additional_service_dsv" edge to the CarrierAdditionalServiceDSV entity by ids.
func (m *DeliveryOptionDSVMutation) AddCarrierAdditionalServiceDSVIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_dsv == nil {
		m.carrier_additional_service_dsv = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_dsv[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceDSV clears the "carrier_additional_service_dsv" edge to the CarrierAdditionalServiceDSV entity.
func (m *DeliveryOptionDSVMutation) ClearCarrierAdditionalServiceDSV() {
	m.clearedcarrier_additional_service_dsv = true
}

// CarrierAdditionalServiceDSVCleared reports if the "carrier_additional_service_dsv" edge to the CarrierAdditionalServiceDSV entity was cleared.
func (m *DeliveryOptionDSVMutation) CarrierAdditionalServiceDSVCleared() bool {
	return m.clearedcarrier_additional_service_dsv
}

// RemoveCarrierAdditionalServiceDSVIDs removes the "carrier_additional_service_dsv" edge to the CarrierAdditionalServiceDSV entity by IDs.
func (m *DeliveryOptionDSVMutation) RemoveCarrierAdditionalServiceDSVIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_dsv == nil {
		m.removedcarrier_additional_service_dsv = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_dsv, ids[i])
		m.removedcarrier_additional_service_dsv[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceDSV returns the removed IDs of the "carrier_additional_service_dsv" edge to the CarrierAdditionalServiceDSV entity.
func (m *DeliveryOptionDSVMutation) RemovedCarrierAdditionalServiceDSVIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_dsv {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceDSVIDs returns the "carrier_additional_service_dsv" edge IDs in the mutation.
func (m *DeliveryOptionDSVMutation) CarrierAdditionalServiceDSVIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_dsv {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceDSV resets all changes to the "carrier_additional_service_dsv" edge.
func (m *DeliveryOptionDSVMutation) ResetCarrierAdditionalServiceDSV() {
	m.carrier_additional_service_dsv = nil
	m.clearedcarrier_additional_service_dsv = false
	m.removedcarrier_additional_service_dsv = nil
}

// Where appends a list predicates to the DeliveryOptionDSVMutation builder.
func (m *DeliveryOptionDSVMutation) Where(ps ...predicate.DeliveryOptionDSV) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryOptionDSVMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryOptionDSVMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryOptionDSV, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryOptionDSVMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryOptionDSVMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryOptionDSV).
func (m *DeliveryOptionDSVMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryOptionDSVMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tenant != nil {
		fields = append(fields, deliveryoptiondsv.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryOptionDSVMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryoptiondsv.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryOptionDSVMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryoptiondsv.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryOptionDSV field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionDSVMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryoptiondsv.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDSV field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryOptionDSVMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryOptionDSVMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionDSVMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryOptionDSV numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryOptionDSVMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryOptionDSVMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryOptionDSVMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryOptionDSV nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryOptionDSVMutation) ResetField(name string) error {
	switch name {
	case deliveryoptiondsv.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDSV field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryOptionDSVMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, deliveryoptiondsv.EdgeTenant)
	}
	if m.delivery_option != nil {
		edges = append(edges, deliveryoptiondsv.EdgeDeliveryOption)
	}
	if m.carrier_additional_service_dsv != nil {
		edges = append(edges, deliveryoptiondsv.EdgeCarrierAdditionalServiceDSV)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryOptionDSVMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptiondsv.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptiondsv.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptiondsv.EdgeCarrierAdditionalServiceDSV:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_dsv))
		for id := range m.carrier_additional_service_dsv {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryOptionDSVMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcarrier_additional_service_dsv != nil {
		edges = append(edges, deliveryoptiondsv.EdgeCarrierAdditionalServiceDSV)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryOptionDSVMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptiondsv.EdgeCarrierAdditionalServiceDSV:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_dsv))
		for id := range m.removedcarrier_additional_service_dsv {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryOptionDSVMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, deliveryoptiondsv.EdgeTenant)
	}
	if m.cleareddelivery_option {
		edges = append(edges, deliveryoptiondsv.EdgeDeliveryOption)
	}
	if m.clearedcarrier_additional_service_dsv {
		edges = append(edges, deliveryoptiondsv.EdgeCarrierAdditionalServiceDSV)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryOptionDSVMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryoptiondsv.EdgeTenant:
		return m.clearedtenant
	case deliveryoptiondsv.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case deliveryoptiondsv.EdgeCarrierAdditionalServiceDSV:
		return m.clearedcarrier_additional_service_dsv
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryOptionDSVMutation) ClearEdge(name string) error {
	switch name {
	case deliveryoptiondsv.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryoptiondsv.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDSV unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryOptionDSVMutation) ResetEdge(name string) error {
	switch name {
	case deliveryoptiondsv.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryoptiondsv.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case deliveryoptiondsv.EdgeCarrierAdditionalServiceDSV:
		m.ResetCarrierAdditionalServiceDSV()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionDSV edge %s", name)
}

// DeliveryOptionEasyPostMutation represents an operation that mutates the DeliveryOptionEasyPost nodes in the graph.
type DeliveryOptionEasyPostMutation struct {
	config
	op                                Op
	typ                               string
	id                                *pulid.ID
	clearedFields                     map[string]struct{}
	tenant                            *pulid.ID
	clearedtenant                     bool
	delivery_option                   *pulid.ID
	cleareddelivery_option            bool
	carrier_add_serv_easy_post        map[pulid.ID]struct{}
	removedcarrier_add_serv_easy_post map[pulid.ID]struct{}
	clearedcarrier_add_serv_easy_post bool
	done                              bool
	oldValue                          func(context.Context) (*DeliveryOptionEasyPost, error)
	predicates                        []predicate.DeliveryOptionEasyPost
}

var _ ent.Mutation = (*DeliveryOptionEasyPostMutation)(nil)

// deliveryoptioneasypostOption allows management of the mutation configuration using functional options.
type deliveryoptioneasypostOption func(*DeliveryOptionEasyPostMutation)

// newDeliveryOptionEasyPostMutation creates new mutation for the DeliveryOptionEasyPost entity.
func newDeliveryOptionEasyPostMutation(c config, op Op, opts ...deliveryoptioneasypostOption) *DeliveryOptionEasyPostMutation {
	m := &DeliveryOptionEasyPostMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryOptionEasyPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryOptionEasyPostID sets the ID field of the mutation.
func withDeliveryOptionEasyPostID(id pulid.ID) deliveryoptioneasypostOption {
	return func(m *DeliveryOptionEasyPostMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryOptionEasyPost
		)
		m.oldValue = func(ctx context.Context) (*DeliveryOptionEasyPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryOptionEasyPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryOptionEasyPost sets the old DeliveryOptionEasyPost of the mutation.
func withDeliveryOptionEasyPost(node *DeliveryOptionEasyPost) deliveryoptioneasypostOption {
	return func(m *DeliveryOptionEasyPostMutation) {
		m.oldValue = func(context.Context) (*DeliveryOptionEasyPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryOptionEasyPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryOptionEasyPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryOptionEasyPost entities.
func (m *DeliveryOptionEasyPostMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryOptionEasyPostMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryOptionEasyPostMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryOptionEasyPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryOptionEasyPostMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryOptionEasyPostMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryOptionEasyPost entity.
// If the DeliveryOptionEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionEasyPostMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryOptionEasyPostMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryOptionEasyPostMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryoptioneasypost.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryOptionEasyPostMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionEasyPostMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryOptionEasyPostMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *DeliveryOptionEasyPostMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *DeliveryOptionEasyPostMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *DeliveryOptionEasyPostMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *DeliveryOptionEasyPostMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionEasyPostMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *DeliveryOptionEasyPostMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// AddCarrierAddServEasyPostIDs adds the "carrier_add_serv_easy_post" edge to the CarrierAdditionalServiceEasyPost entity by ids.
func (m *DeliveryOptionEasyPostMutation) AddCarrierAddServEasyPostIDs(ids ...pulid.ID) {
	if m.carrier_add_serv_easy_post == nil {
		m.carrier_add_serv_easy_post = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_add_serv_easy_post[ids[i]] = struct{}{}
	}
}

// ClearCarrierAddServEasyPost clears the "carrier_add_serv_easy_post" edge to the CarrierAdditionalServiceEasyPost entity.
func (m *DeliveryOptionEasyPostMutation) ClearCarrierAddServEasyPost() {
	m.clearedcarrier_add_serv_easy_post = true
}

// CarrierAddServEasyPostCleared reports if the "carrier_add_serv_easy_post" edge to the CarrierAdditionalServiceEasyPost entity was cleared.
func (m *DeliveryOptionEasyPostMutation) CarrierAddServEasyPostCleared() bool {
	return m.clearedcarrier_add_serv_easy_post
}

// RemoveCarrierAddServEasyPostIDs removes the "carrier_add_serv_easy_post" edge to the CarrierAdditionalServiceEasyPost entity by IDs.
func (m *DeliveryOptionEasyPostMutation) RemoveCarrierAddServEasyPostIDs(ids ...pulid.ID) {
	if m.removedcarrier_add_serv_easy_post == nil {
		m.removedcarrier_add_serv_easy_post = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_add_serv_easy_post, ids[i])
		m.removedcarrier_add_serv_easy_post[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAddServEasyPost returns the removed IDs of the "carrier_add_serv_easy_post" edge to the CarrierAdditionalServiceEasyPost entity.
func (m *DeliveryOptionEasyPostMutation) RemovedCarrierAddServEasyPostIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_add_serv_easy_post {
		ids = append(ids, id)
	}
	return
}

// CarrierAddServEasyPostIDs returns the "carrier_add_serv_easy_post" edge IDs in the mutation.
func (m *DeliveryOptionEasyPostMutation) CarrierAddServEasyPostIDs() (ids []pulid.ID) {
	for id := range m.carrier_add_serv_easy_post {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAddServEasyPost resets all changes to the "carrier_add_serv_easy_post" edge.
func (m *DeliveryOptionEasyPostMutation) ResetCarrierAddServEasyPost() {
	m.carrier_add_serv_easy_post = nil
	m.clearedcarrier_add_serv_easy_post = false
	m.removedcarrier_add_serv_easy_post = nil
}

// Where appends a list predicates to the DeliveryOptionEasyPostMutation builder.
func (m *DeliveryOptionEasyPostMutation) Where(ps ...predicate.DeliveryOptionEasyPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryOptionEasyPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryOptionEasyPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryOptionEasyPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryOptionEasyPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryOptionEasyPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryOptionEasyPost).
func (m *DeliveryOptionEasyPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryOptionEasyPostMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tenant != nil {
		fields = append(fields, deliveryoptioneasypost.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryOptionEasyPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryoptioneasypost.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryOptionEasyPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryoptioneasypost.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryOptionEasyPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionEasyPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryoptioneasypost.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionEasyPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryOptionEasyPostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryOptionEasyPostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionEasyPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryOptionEasyPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryOptionEasyPostMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryOptionEasyPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryOptionEasyPostMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryOptionEasyPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryOptionEasyPostMutation) ResetField(name string) error {
	switch name {
	case deliveryoptioneasypost.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionEasyPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryOptionEasyPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, deliveryoptioneasypost.EdgeTenant)
	}
	if m.delivery_option != nil {
		edges = append(edges, deliveryoptioneasypost.EdgeDeliveryOption)
	}
	if m.carrier_add_serv_easy_post != nil {
		edges = append(edges, deliveryoptioneasypost.EdgeCarrierAddServEasyPost)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryOptionEasyPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptioneasypost.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptioneasypost.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptioneasypost.EdgeCarrierAddServEasyPost:
		ids := make([]ent.Value, 0, len(m.carrier_add_serv_easy_post))
		for id := range m.carrier_add_serv_easy_post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryOptionEasyPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcarrier_add_serv_easy_post != nil {
		edges = append(edges, deliveryoptioneasypost.EdgeCarrierAddServEasyPost)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryOptionEasyPostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptioneasypost.EdgeCarrierAddServEasyPost:
		ids := make([]ent.Value, 0, len(m.removedcarrier_add_serv_easy_post))
		for id := range m.removedcarrier_add_serv_easy_post {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryOptionEasyPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, deliveryoptioneasypost.EdgeTenant)
	}
	if m.cleareddelivery_option {
		edges = append(edges, deliveryoptioneasypost.EdgeDeliveryOption)
	}
	if m.clearedcarrier_add_serv_easy_post {
		edges = append(edges, deliveryoptioneasypost.EdgeCarrierAddServEasyPost)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryOptionEasyPostMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryoptioneasypost.EdgeTenant:
		return m.clearedtenant
	case deliveryoptioneasypost.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case deliveryoptioneasypost.EdgeCarrierAddServEasyPost:
		return m.clearedcarrier_add_serv_easy_post
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryOptionEasyPostMutation) ClearEdge(name string) error {
	switch name {
	case deliveryoptioneasypost.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryoptioneasypost.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionEasyPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryOptionEasyPostMutation) ResetEdge(name string) error {
	switch name {
	case deliveryoptioneasypost.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryoptioneasypost.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case deliveryoptioneasypost.EdgeCarrierAddServEasyPost:
		m.ResetCarrierAddServEasyPost()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionEasyPost edge %s", name)
}

// DeliveryOptionGLSMutation represents an operation that mutates the DeliveryOptionGLS nodes in the graph.
type DeliveryOptionGLSMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *pulid.ID
	clearedFields                         map[string]struct{}
	tenant                                *pulid.ID
	clearedtenant                         bool
	delivery_option                       *pulid.ID
	cleareddelivery_option                bool
	carrier_additional_service_gls        map[pulid.ID]struct{}
	removedcarrier_additional_service_gls map[pulid.ID]struct{}
	clearedcarrier_additional_service_gls bool
	done                                  bool
	oldValue                              func(context.Context) (*DeliveryOptionGLS, error)
	predicates                            []predicate.DeliveryOptionGLS
}

var _ ent.Mutation = (*DeliveryOptionGLSMutation)(nil)

// deliveryoptionglsOption allows management of the mutation configuration using functional options.
type deliveryoptionglsOption func(*DeliveryOptionGLSMutation)

// newDeliveryOptionGLSMutation creates new mutation for the DeliveryOptionGLS entity.
func newDeliveryOptionGLSMutation(c config, op Op, opts ...deliveryoptionglsOption) *DeliveryOptionGLSMutation {
	m := &DeliveryOptionGLSMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryOptionGLS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryOptionGLSID sets the ID field of the mutation.
func withDeliveryOptionGLSID(id pulid.ID) deliveryoptionglsOption {
	return func(m *DeliveryOptionGLSMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryOptionGLS
		)
		m.oldValue = func(ctx context.Context) (*DeliveryOptionGLS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryOptionGLS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryOptionGLS sets the old DeliveryOptionGLS of the mutation.
func withDeliveryOptionGLS(node *DeliveryOptionGLS) deliveryoptionglsOption {
	return func(m *DeliveryOptionGLSMutation) {
		m.oldValue = func(context.Context) (*DeliveryOptionGLS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryOptionGLSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryOptionGLSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryOptionGLS entities.
func (m *DeliveryOptionGLSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryOptionGLSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryOptionGLSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryOptionGLS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryOptionGLSMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryOptionGLSMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryOptionGLS entity.
// If the DeliveryOptionGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionGLSMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryOptionGLSMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryOptionGLSMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryoptiongls.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryOptionGLSMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionGLSMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryOptionGLSMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *DeliveryOptionGLSMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *DeliveryOptionGLSMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *DeliveryOptionGLSMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *DeliveryOptionGLSMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionGLSMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *DeliveryOptionGLSMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// AddCarrierAdditionalServiceGlIDs adds the "carrier_additional_service_gls" edge to the CarrierAdditionalServiceGLS entity by ids.
func (m *DeliveryOptionGLSMutation) AddCarrierAdditionalServiceGlIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_gls == nil {
		m.carrier_additional_service_gls = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_gls[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceGLS clears the "carrier_additional_service_gls" edge to the CarrierAdditionalServiceGLS entity.
func (m *DeliveryOptionGLSMutation) ClearCarrierAdditionalServiceGLS() {
	m.clearedcarrier_additional_service_gls = true
}

// CarrierAdditionalServiceGLSCleared reports if the "carrier_additional_service_gls" edge to the CarrierAdditionalServiceGLS entity was cleared.
func (m *DeliveryOptionGLSMutation) CarrierAdditionalServiceGLSCleared() bool {
	return m.clearedcarrier_additional_service_gls
}

// RemoveCarrierAdditionalServiceGlIDs removes the "carrier_additional_service_gls" edge to the CarrierAdditionalServiceGLS entity by IDs.
func (m *DeliveryOptionGLSMutation) RemoveCarrierAdditionalServiceGlIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_gls == nil {
		m.removedcarrier_additional_service_gls = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_gls, ids[i])
		m.removedcarrier_additional_service_gls[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceGLS returns the removed IDs of the "carrier_additional_service_gls" edge to the CarrierAdditionalServiceGLS entity.
func (m *DeliveryOptionGLSMutation) RemovedCarrierAdditionalServiceGLSIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_gls {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceGLSIDs returns the "carrier_additional_service_gls" edge IDs in the mutation.
func (m *DeliveryOptionGLSMutation) CarrierAdditionalServiceGLSIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_gls {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceGLS resets all changes to the "carrier_additional_service_gls" edge.
func (m *DeliveryOptionGLSMutation) ResetCarrierAdditionalServiceGLS() {
	m.carrier_additional_service_gls = nil
	m.clearedcarrier_additional_service_gls = false
	m.removedcarrier_additional_service_gls = nil
}

// Where appends a list predicates to the DeliveryOptionGLSMutation builder.
func (m *DeliveryOptionGLSMutation) Where(ps ...predicate.DeliveryOptionGLS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryOptionGLSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryOptionGLSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryOptionGLS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryOptionGLSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryOptionGLSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryOptionGLS).
func (m *DeliveryOptionGLSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryOptionGLSMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tenant != nil {
		fields = append(fields, deliveryoptiongls.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryOptionGLSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryoptiongls.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryOptionGLSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryoptiongls.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryOptionGLS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionGLSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryoptiongls.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionGLS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryOptionGLSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryOptionGLSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionGLSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryOptionGLS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryOptionGLSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryOptionGLSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryOptionGLSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryOptionGLS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryOptionGLSMutation) ResetField(name string) error {
	switch name {
	case deliveryoptiongls.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionGLS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryOptionGLSMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, deliveryoptiongls.EdgeTenant)
	}
	if m.delivery_option != nil {
		edges = append(edges, deliveryoptiongls.EdgeDeliveryOption)
	}
	if m.carrier_additional_service_gls != nil {
		edges = append(edges, deliveryoptiongls.EdgeCarrierAdditionalServiceGLS)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryOptionGLSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptiongls.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptiongls.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptiongls.EdgeCarrierAdditionalServiceGLS:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_gls))
		for id := range m.carrier_additional_service_gls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryOptionGLSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcarrier_additional_service_gls != nil {
		edges = append(edges, deliveryoptiongls.EdgeCarrierAdditionalServiceGLS)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryOptionGLSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptiongls.EdgeCarrierAdditionalServiceGLS:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_gls))
		for id := range m.removedcarrier_additional_service_gls {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryOptionGLSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, deliveryoptiongls.EdgeTenant)
	}
	if m.cleareddelivery_option {
		edges = append(edges, deliveryoptiongls.EdgeDeliveryOption)
	}
	if m.clearedcarrier_additional_service_gls {
		edges = append(edges, deliveryoptiongls.EdgeCarrierAdditionalServiceGLS)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryOptionGLSMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryoptiongls.EdgeTenant:
		return m.clearedtenant
	case deliveryoptiongls.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case deliveryoptiongls.EdgeCarrierAdditionalServiceGLS:
		return m.clearedcarrier_additional_service_gls
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryOptionGLSMutation) ClearEdge(name string) error {
	switch name {
	case deliveryoptiongls.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryoptiongls.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionGLS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryOptionGLSMutation) ResetEdge(name string) error {
	switch name {
	case deliveryoptiongls.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryoptiongls.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case deliveryoptiongls.EdgeCarrierAdditionalServiceGLS:
		m.ResetCarrierAdditionalServiceGLS()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionGLS edge %s", name)
}

// DeliveryOptionPostNordMutation represents an operation that mutates the DeliveryOptionPostNord nodes in the graph.
type DeliveryOptionPostNordMutation struct {
	config
	op                                Op
	typ                               string
	id                                *pulid.ID
	format_zpl                        *bool
	clearedFields                     map[string]struct{}
	tenant                            *pulid.ID
	clearedtenant                     bool
	delivery_option                   *pulid.ID
	cleareddelivery_option            bool
	carrier_add_serv_post_nord        map[pulid.ID]struct{}
	removedcarrier_add_serv_post_nord map[pulid.ID]struct{}
	clearedcarrier_add_serv_post_nord bool
	done                              bool
	oldValue                          func(context.Context) (*DeliveryOptionPostNord, error)
	predicates                        []predicate.DeliveryOptionPostNord
}

var _ ent.Mutation = (*DeliveryOptionPostNordMutation)(nil)

// deliveryoptionpostnordOption allows management of the mutation configuration using functional options.
type deliveryoptionpostnordOption func(*DeliveryOptionPostNordMutation)

// newDeliveryOptionPostNordMutation creates new mutation for the DeliveryOptionPostNord entity.
func newDeliveryOptionPostNordMutation(c config, op Op, opts ...deliveryoptionpostnordOption) *DeliveryOptionPostNordMutation {
	m := &DeliveryOptionPostNordMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryOptionPostNord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryOptionPostNordID sets the ID field of the mutation.
func withDeliveryOptionPostNordID(id pulid.ID) deliveryoptionpostnordOption {
	return func(m *DeliveryOptionPostNordMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryOptionPostNord
		)
		m.oldValue = func(ctx context.Context) (*DeliveryOptionPostNord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryOptionPostNord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryOptionPostNord sets the old DeliveryOptionPostNord of the mutation.
func withDeliveryOptionPostNord(node *DeliveryOptionPostNord) deliveryoptionpostnordOption {
	return func(m *DeliveryOptionPostNordMutation) {
		m.oldValue = func(context.Context) (*DeliveryOptionPostNord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryOptionPostNordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryOptionPostNordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryOptionPostNord entities.
func (m *DeliveryOptionPostNordMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryOptionPostNordMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryOptionPostNordMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryOptionPostNord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryOptionPostNordMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryOptionPostNordMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryOptionPostNord entity.
// If the DeliveryOptionPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionPostNordMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryOptionPostNordMutation) ResetTenantID() {
	m.tenant = nil
}

// SetFormatZpl sets the "format_zpl" field.
func (m *DeliveryOptionPostNordMutation) SetFormatZpl(b bool) {
	m.format_zpl = &b
}

// FormatZpl returns the value of the "format_zpl" field in the mutation.
func (m *DeliveryOptionPostNordMutation) FormatZpl() (r bool, exists bool) {
	v := m.format_zpl
	if v == nil {
		return
	}
	return *v, true
}

// OldFormatZpl returns the old "format_zpl" field's value of the DeliveryOptionPostNord entity.
// If the DeliveryOptionPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionPostNordMutation) OldFormatZpl(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormatZpl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormatZpl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormatZpl: %w", err)
	}
	return oldValue.FormatZpl, nil
}

// ResetFormatZpl resets all changes to the "format_zpl" field.
func (m *DeliveryOptionPostNordMutation) ResetFormatZpl() {
	m.format_zpl = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryOptionPostNordMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryoptionpostnord.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryOptionPostNordMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionPostNordMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryOptionPostNordMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *DeliveryOptionPostNordMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *DeliveryOptionPostNordMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *DeliveryOptionPostNordMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *DeliveryOptionPostNordMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionPostNordMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *DeliveryOptionPostNordMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// AddCarrierAddServPostNordIDs adds the "carrier_add_serv_post_nord" edge to the CarrierAdditionalServicePostNord entity by ids.
func (m *DeliveryOptionPostNordMutation) AddCarrierAddServPostNordIDs(ids ...pulid.ID) {
	if m.carrier_add_serv_post_nord == nil {
		m.carrier_add_serv_post_nord = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_add_serv_post_nord[ids[i]] = struct{}{}
	}
}

// ClearCarrierAddServPostNord clears the "carrier_add_serv_post_nord" edge to the CarrierAdditionalServicePostNord entity.
func (m *DeliveryOptionPostNordMutation) ClearCarrierAddServPostNord() {
	m.clearedcarrier_add_serv_post_nord = true
}

// CarrierAddServPostNordCleared reports if the "carrier_add_serv_post_nord" edge to the CarrierAdditionalServicePostNord entity was cleared.
func (m *DeliveryOptionPostNordMutation) CarrierAddServPostNordCleared() bool {
	return m.clearedcarrier_add_serv_post_nord
}

// RemoveCarrierAddServPostNordIDs removes the "carrier_add_serv_post_nord" edge to the CarrierAdditionalServicePostNord entity by IDs.
func (m *DeliveryOptionPostNordMutation) RemoveCarrierAddServPostNordIDs(ids ...pulid.ID) {
	if m.removedcarrier_add_serv_post_nord == nil {
		m.removedcarrier_add_serv_post_nord = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_add_serv_post_nord, ids[i])
		m.removedcarrier_add_serv_post_nord[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAddServPostNord returns the removed IDs of the "carrier_add_serv_post_nord" edge to the CarrierAdditionalServicePostNord entity.
func (m *DeliveryOptionPostNordMutation) RemovedCarrierAddServPostNordIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_add_serv_post_nord {
		ids = append(ids, id)
	}
	return
}

// CarrierAddServPostNordIDs returns the "carrier_add_serv_post_nord" edge IDs in the mutation.
func (m *DeliveryOptionPostNordMutation) CarrierAddServPostNordIDs() (ids []pulid.ID) {
	for id := range m.carrier_add_serv_post_nord {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAddServPostNord resets all changes to the "carrier_add_serv_post_nord" edge.
func (m *DeliveryOptionPostNordMutation) ResetCarrierAddServPostNord() {
	m.carrier_add_serv_post_nord = nil
	m.clearedcarrier_add_serv_post_nord = false
	m.removedcarrier_add_serv_post_nord = nil
}

// Where appends a list predicates to the DeliveryOptionPostNordMutation builder.
func (m *DeliveryOptionPostNordMutation) Where(ps ...predicate.DeliveryOptionPostNord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryOptionPostNordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryOptionPostNordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryOptionPostNord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryOptionPostNordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryOptionPostNordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryOptionPostNord).
func (m *DeliveryOptionPostNordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryOptionPostNordMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, deliveryoptionpostnord.FieldTenantID)
	}
	if m.format_zpl != nil {
		fields = append(fields, deliveryoptionpostnord.FieldFormatZpl)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryOptionPostNordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryoptionpostnord.FieldTenantID:
		return m.TenantID()
	case deliveryoptionpostnord.FieldFormatZpl:
		return m.FormatZpl()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryOptionPostNordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryoptionpostnord.FieldTenantID:
		return m.OldTenantID(ctx)
	case deliveryoptionpostnord.FieldFormatZpl:
		return m.OldFormatZpl(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryOptionPostNord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionPostNordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryoptionpostnord.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case deliveryoptionpostnord.FieldFormatZpl:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormatZpl(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionPostNord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryOptionPostNordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryOptionPostNordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionPostNordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryOptionPostNord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryOptionPostNordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryOptionPostNordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryOptionPostNordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryOptionPostNord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryOptionPostNordMutation) ResetField(name string) error {
	switch name {
	case deliveryoptionpostnord.FieldTenantID:
		m.ResetTenantID()
		return nil
	case deliveryoptionpostnord.FieldFormatZpl:
		m.ResetFormatZpl()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionPostNord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryOptionPostNordMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, deliveryoptionpostnord.EdgeTenant)
	}
	if m.delivery_option != nil {
		edges = append(edges, deliveryoptionpostnord.EdgeDeliveryOption)
	}
	if m.carrier_add_serv_post_nord != nil {
		edges = append(edges, deliveryoptionpostnord.EdgeCarrierAddServPostNord)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryOptionPostNordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptionpostnord.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptionpostnord.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptionpostnord.EdgeCarrierAddServPostNord:
		ids := make([]ent.Value, 0, len(m.carrier_add_serv_post_nord))
		for id := range m.carrier_add_serv_post_nord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryOptionPostNordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcarrier_add_serv_post_nord != nil {
		edges = append(edges, deliveryoptionpostnord.EdgeCarrierAddServPostNord)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryOptionPostNordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptionpostnord.EdgeCarrierAddServPostNord:
		ids := make([]ent.Value, 0, len(m.removedcarrier_add_serv_post_nord))
		for id := range m.removedcarrier_add_serv_post_nord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryOptionPostNordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, deliveryoptionpostnord.EdgeTenant)
	}
	if m.cleareddelivery_option {
		edges = append(edges, deliveryoptionpostnord.EdgeDeliveryOption)
	}
	if m.clearedcarrier_add_serv_post_nord {
		edges = append(edges, deliveryoptionpostnord.EdgeCarrierAddServPostNord)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryOptionPostNordMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryoptionpostnord.EdgeTenant:
		return m.clearedtenant
	case deliveryoptionpostnord.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case deliveryoptionpostnord.EdgeCarrierAddServPostNord:
		return m.clearedcarrier_add_serv_post_nord
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryOptionPostNordMutation) ClearEdge(name string) error {
	switch name {
	case deliveryoptionpostnord.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryoptionpostnord.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionPostNord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryOptionPostNordMutation) ResetEdge(name string) error {
	switch name {
	case deliveryoptionpostnord.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryoptionpostnord.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case deliveryoptionpostnord.EdgeCarrierAddServPostNord:
		m.ResetCarrierAddServPostNord()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionPostNord edge %s", name)
}

// DeliveryOptionUSPSMutation represents an operation that mutates the DeliveryOptionUSPS nodes in the graph.
type DeliveryOptionUSPSMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *pulid.ID
	format_zpl                             *bool
	clearedFields                          map[string]struct{}
	tenant                                 *pulid.ID
	clearedtenant                          bool
	delivery_option                        *pulid.ID
	cleareddelivery_option                 bool
	carrier_additional_service_usps        map[pulid.ID]struct{}
	removedcarrier_additional_service_usps map[pulid.ID]struct{}
	clearedcarrier_additional_service_usps bool
	done                                   bool
	oldValue                               func(context.Context) (*DeliveryOptionUSPS, error)
	predicates                             []predicate.DeliveryOptionUSPS
}

var _ ent.Mutation = (*DeliveryOptionUSPSMutation)(nil)

// deliveryoptionuspsOption allows management of the mutation configuration using functional options.
type deliveryoptionuspsOption func(*DeliveryOptionUSPSMutation)

// newDeliveryOptionUSPSMutation creates new mutation for the DeliveryOptionUSPS entity.
func newDeliveryOptionUSPSMutation(c config, op Op, opts ...deliveryoptionuspsOption) *DeliveryOptionUSPSMutation {
	m := &DeliveryOptionUSPSMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryOptionUSPS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryOptionUSPSID sets the ID field of the mutation.
func withDeliveryOptionUSPSID(id pulid.ID) deliveryoptionuspsOption {
	return func(m *DeliveryOptionUSPSMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryOptionUSPS
		)
		m.oldValue = func(ctx context.Context) (*DeliveryOptionUSPS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryOptionUSPS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryOptionUSPS sets the old DeliveryOptionUSPS of the mutation.
func withDeliveryOptionUSPS(node *DeliveryOptionUSPS) deliveryoptionuspsOption {
	return func(m *DeliveryOptionUSPSMutation) {
		m.oldValue = func(context.Context) (*DeliveryOptionUSPS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryOptionUSPSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryOptionUSPSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryOptionUSPS entities.
func (m *DeliveryOptionUSPSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryOptionUSPSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryOptionUSPSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryOptionUSPS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryOptionUSPSMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryOptionUSPSMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryOptionUSPS entity.
// If the DeliveryOptionUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionUSPSMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryOptionUSPSMutation) ResetTenantID() {
	m.tenant = nil
}

// SetFormatZpl sets the "format_zpl" field.
func (m *DeliveryOptionUSPSMutation) SetFormatZpl(b bool) {
	m.format_zpl = &b
}

// FormatZpl returns the value of the "format_zpl" field in the mutation.
func (m *DeliveryOptionUSPSMutation) FormatZpl() (r bool, exists bool) {
	v := m.format_zpl
	if v == nil {
		return
	}
	return *v, true
}

// OldFormatZpl returns the old "format_zpl" field's value of the DeliveryOptionUSPS entity.
// If the DeliveryOptionUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryOptionUSPSMutation) OldFormatZpl(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFormatZpl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFormatZpl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFormatZpl: %w", err)
	}
	return oldValue.FormatZpl, nil
}

// ResetFormatZpl resets all changes to the "format_zpl" field.
func (m *DeliveryOptionUSPSMutation) ResetFormatZpl() {
	m.format_zpl = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryOptionUSPSMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryoptionusps.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryOptionUSPSMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionUSPSMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryOptionUSPSMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *DeliveryOptionUSPSMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *DeliveryOptionUSPSMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *DeliveryOptionUSPSMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *DeliveryOptionUSPSMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *DeliveryOptionUSPSMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *DeliveryOptionUSPSMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// AddCarrierAdditionalServiceUspIDs adds the "carrier_additional_service_usps" edge to the CarrierAdditionalServiceUSPS entity by ids.
func (m *DeliveryOptionUSPSMutation) AddCarrierAdditionalServiceUspIDs(ids ...pulid.ID) {
	if m.carrier_additional_service_usps == nil {
		m.carrier_additional_service_usps = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.carrier_additional_service_usps[ids[i]] = struct{}{}
	}
}

// ClearCarrierAdditionalServiceUSPS clears the "carrier_additional_service_usps" edge to the CarrierAdditionalServiceUSPS entity.
func (m *DeliveryOptionUSPSMutation) ClearCarrierAdditionalServiceUSPS() {
	m.clearedcarrier_additional_service_usps = true
}

// CarrierAdditionalServiceUSPSCleared reports if the "carrier_additional_service_usps" edge to the CarrierAdditionalServiceUSPS entity was cleared.
func (m *DeliveryOptionUSPSMutation) CarrierAdditionalServiceUSPSCleared() bool {
	return m.clearedcarrier_additional_service_usps
}

// RemoveCarrierAdditionalServiceUspIDs removes the "carrier_additional_service_usps" edge to the CarrierAdditionalServiceUSPS entity by IDs.
func (m *DeliveryOptionUSPSMutation) RemoveCarrierAdditionalServiceUspIDs(ids ...pulid.ID) {
	if m.removedcarrier_additional_service_usps == nil {
		m.removedcarrier_additional_service_usps = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.carrier_additional_service_usps, ids[i])
		m.removedcarrier_additional_service_usps[ids[i]] = struct{}{}
	}
}

// RemovedCarrierAdditionalServiceUSPS returns the removed IDs of the "carrier_additional_service_usps" edge to the CarrierAdditionalServiceUSPS entity.
func (m *DeliveryOptionUSPSMutation) RemovedCarrierAdditionalServiceUSPSIDs() (ids []pulid.ID) {
	for id := range m.removedcarrier_additional_service_usps {
		ids = append(ids, id)
	}
	return
}

// CarrierAdditionalServiceUSPSIDs returns the "carrier_additional_service_usps" edge IDs in the mutation.
func (m *DeliveryOptionUSPSMutation) CarrierAdditionalServiceUSPSIDs() (ids []pulid.ID) {
	for id := range m.carrier_additional_service_usps {
		ids = append(ids, id)
	}
	return
}

// ResetCarrierAdditionalServiceUSPS resets all changes to the "carrier_additional_service_usps" edge.
func (m *DeliveryOptionUSPSMutation) ResetCarrierAdditionalServiceUSPS() {
	m.carrier_additional_service_usps = nil
	m.clearedcarrier_additional_service_usps = false
	m.removedcarrier_additional_service_usps = nil
}

// Where appends a list predicates to the DeliveryOptionUSPSMutation builder.
func (m *DeliveryOptionUSPSMutation) Where(ps ...predicate.DeliveryOptionUSPS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryOptionUSPSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryOptionUSPSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryOptionUSPS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryOptionUSPSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryOptionUSPSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryOptionUSPS).
func (m *DeliveryOptionUSPSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryOptionUSPSMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, deliveryoptionusps.FieldTenantID)
	}
	if m.format_zpl != nil {
		fields = append(fields, deliveryoptionusps.FieldFormatZpl)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryOptionUSPSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryoptionusps.FieldTenantID:
		return m.TenantID()
	case deliveryoptionusps.FieldFormatZpl:
		return m.FormatZpl()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryOptionUSPSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryoptionusps.FieldTenantID:
		return m.OldTenantID(ctx)
	case deliveryoptionusps.FieldFormatZpl:
		return m.OldFormatZpl(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryOptionUSPS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionUSPSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryoptionusps.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case deliveryoptionusps.FieldFormatZpl:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFormatZpl(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionUSPS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryOptionUSPSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryOptionUSPSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryOptionUSPSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryOptionUSPS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryOptionUSPSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryOptionUSPSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryOptionUSPSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryOptionUSPS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryOptionUSPSMutation) ResetField(name string) error {
	switch name {
	case deliveryoptionusps.FieldTenantID:
		m.ResetTenantID()
		return nil
	case deliveryoptionusps.FieldFormatZpl:
		m.ResetFormatZpl()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionUSPS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryOptionUSPSMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, deliveryoptionusps.EdgeTenant)
	}
	if m.delivery_option != nil {
		edges = append(edges, deliveryoptionusps.EdgeDeliveryOption)
	}
	if m.carrier_additional_service_usps != nil {
		edges = append(edges, deliveryoptionusps.EdgeCarrierAdditionalServiceUSPS)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryOptionUSPSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptionusps.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptionusps.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case deliveryoptionusps.EdgeCarrierAdditionalServiceUSPS:
		ids := make([]ent.Value, 0, len(m.carrier_additional_service_usps))
		for id := range m.carrier_additional_service_usps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryOptionUSPSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedcarrier_additional_service_usps != nil {
		edges = append(edges, deliveryoptionusps.EdgeCarrierAdditionalServiceUSPS)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryOptionUSPSMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryoptionusps.EdgeCarrierAdditionalServiceUSPS:
		ids := make([]ent.Value, 0, len(m.removedcarrier_additional_service_usps))
		for id := range m.removedcarrier_additional_service_usps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryOptionUSPSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, deliveryoptionusps.EdgeTenant)
	}
	if m.cleareddelivery_option {
		edges = append(edges, deliveryoptionusps.EdgeDeliveryOption)
	}
	if m.clearedcarrier_additional_service_usps {
		edges = append(edges, deliveryoptionusps.EdgeCarrierAdditionalServiceUSPS)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryOptionUSPSMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryoptionusps.EdgeTenant:
		return m.clearedtenant
	case deliveryoptionusps.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case deliveryoptionusps.EdgeCarrierAdditionalServiceUSPS:
		return m.clearedcarrier_additional_service_usps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryOptionUSPSMutation) ClearEdge(name string) error {
	switch name {
	case deliveryoptionusps.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryoptionusps.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionUSPS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryOptionUSPSMutation) ResetEdge(name string) error {
	switch name {
	case deliveryoptionusps.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryoptionusps.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case deliveryoptionusps.EdgeCarrierAdditionalServiceUSPS:
		m.ResetCarrierAdditionalServiceUSPS()
		return nil
	}
	return fmt.Errorf("unknown DeliveryOptionUSPS edge %s", name)
}

// DeliveryRuleMutation represents an operation that mutates the DeliveryRule nodes in the graph.
type DeliveryRuleMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *pulid.ID
	name                                  *string
	price                                 *float64
	addprice                              *float64
	clearedFields                         map[string]struct{}
	tenant                                *pulid.ID
	clearedtenant                         bool
	delivery_rule_constraint_group        map[pulid.ID]struct{}
	removeddelivery_rule_constraint_group map[pulid.ID]struct{}
	cleareddelivery_rule_constraint_group bool
	delivery_option                       *pulid.ID
	cleareddelivery_option                bool
	country                               map[pulid.ID]struct{}
	removedcountry                        map[pulid.ID]struct{}
	clearedcountry                        bool
	currency                              *pulid.ID
	clearedcurrency                       bool
	done                                  bool
	oldValue                              func(context.Context) (*DeliveryRule, error)
	predicates                            []predicate.DeliveryRule
}

var _ ent.Mutation = (*DeliveryRuleMutation)(nil)

// deliveryruleOption allows management of the mutation configuration using functional options.
type deliveryruleOption func(*DeliveryRuleMutation)

// newDeliveryRuleMutation creates new mutation for the DeliveryRule entity.
func newDeliveryRuleMutation(c config, op Op, opts ...deliveryruleOption) *DeliveryRuleMutation {
	m := &DeliveryRuleMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryRule,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryRuleID sets the ID field of the mutation.
func withDeliveryRuleID(id pulid.ID) deliveryruleOption {
	return func(m *DeliveryRuleMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryRule
		)
		m.oldValue = func(ctx context.Context) (*DeliveryRule, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryRule.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryRule sets the old DeliveryRule of the mutation.
func withDeliveryRule(node *DeliveryRule) deliveryruleOption {
	return func(m *DeliveryRuleMutation) {
		m.oldValue = func(context.Context) (*DeliveryRule, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryRuleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryRuleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryRule entities.
func (m *DeliveryRuleMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryRuleMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryRuleMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryRule.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryRuleMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryRuleMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryRule entity.
// If the DeliveryRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryRuleMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryRuleMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *DeliveryRuleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DeliveryRuleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DeliveryRule entity.
// If the DeliveryRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryRuleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DeliveryRuleMutation) ResetName() {
	m.name = nil
}

// SetPrice sets the "price" field.
func (m *DeliveryRuleMutation) SetPrice(f float64) {
	m.price = &f
	m.addprice = nil
}

// Price returns the value of the "price" field in the mutation.
func (m *DeliveryRuleMutation) Price() (r float64, exists bool) {
	v := m.price
	if v == nil {
		return
	}
	return *v, true
}

// OldPrice returns the old "price" field's value of the DeliveryRule entity.
// If the DeliveryRule object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryRuleMutation) OldPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrice: %w", err)
	}
	return oldValue.Price, nil
}

// AddPrice adds f to the "price" field.
func (m *DeliveryRuleMutation) AddPrice(f float64) {
	if m.addprice != nil {
		*m.addprice += f
	} else {
		m.addprice = &f
	}
}

// AddedPrice returns the value that was added to the "price" field in this mutation.
func (m *DeliveryRuleMutation) AddedPrice() (r float64, exists bool) {
	v := m.addprice
	if v == nil {
		return
	}
	return *v, true
}

// ResetPrice resets all changes to the "price" field.
func (m *DeliveryRuleMutation) ResetPrice() {
	m.price = nil
	m.addprice = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryRuleMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryrule.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryRuleMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryRuleMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryRuleMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddDeliveryRuleConstraintGroupIDs adds the "delivery_rule_constraint_group" edge to the DeliveryRuleConstraintGroup entity by ids.
func (m *DeliveryRuleMutation) AddDeliveryRuleConstraintGroupIDs(ids ...pulid.ID) {
	if m.delivery_rule_constraint_group == nil {
		m.delivery_rule_constraint_group = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_rule_constraint_group[ids[i]] = struct{}{}
	}
}

// ClearDeliveryRuleConstraintGroup clears the "delivery_rule_constraint_group" edge to the DeliveryRuleConstraintGroup entity.
func (m *DeliveryRuleMutation) ClearDeliveryRuleConstraintGroup() {
	m.cleareddelivery_rule_constraint_group = true
}

// DeliveryRuleConstraintGroupCleared reports if the "delivery_rule_constraint_group" edge to the DeliveryRuleConstraintGroup entity was cleared.
func (m *DeliveryRuleMutation) DeliveryRuleConstraintGroupCleared() bool {
	return m.cleareddelivery_rule_constraint_group
}

// RemoveDeliveryRuleConstraintGroupIDs removes the "delivery_rule_constraint_group" edge to the DeliveryRuleConstraintGroup entity by IDs.
func (m *DeliveryRuleMutation) RemoveDeliveryRuleConstraintGroupIDs(ids ...pulid.ID) {
	if m.removeddelivery_rule_constraint_group == nil {
		m.removeddelivery_rule_constraint_group = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_rule_constraint_group, ids[i])
		m.removeddelivery_rule_constraint_group[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryRuleConstraintGroup returns the removed IDs of the "delivery_rule_constraint_group" edge to the DeliveryRuleConstraintGroup entity.
func (m *DeliveryRuleMutation) RemovedDeliveryRuleConstraintGroupIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_rule_constraint_group {
		ids = append(ids, id)
	}
	return
}

// DeliveryRuleConstraintGroupIDs returns the "delivery_rule_constraint_group" edge IDs in the mutation.
func (m *DeliveryRuleMutation) DeliveryRuleConstraintGroupIDs() (ids []pulid.ID) {
	for id := range m.delivery_rule_constraint_group {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryRuleConstraintGroup resets all changes to the "delivery_rule_constraint_group" edge.
func (m *DeliveryRuleMutation) ResetDeliveryRuleConstraintGroup() {
	m.delivery_rule_constraint_group = nil
	m.cleareddelivery_rule_constraint_group = false
	m.removeddelivery_rule_constraint_group = nil
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *DeliveryRuleMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *DeliveryRuleMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *DeliveryRuleMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *DeliveryRuleMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *DeliveryRuleMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *DeliveryRuleMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// AddCountryIDs adds the "country" edge to the Country entity by ids.
func (m *DeliveryRuleMutation) AddCountryIDs(ids ...pulid.ID) {
	if m.country == nil {
		m.country = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.country[ids[i]] = struct{}{}
	}
}

// ClearCountry clears the "country" edge to the Country entity.
func (m *DeliveryRuleMutation) ClearCountry() {
	m.clearedcountry = true
}

// CountryCleared reports if the "country" edge to the Country entity was cleared.
func (m *DeliveryRuleMutation) CountryCleared() bool {
	return m.clearedcountry
}

// RemoveCountryIDs removes the "country" edge to the Country entity by IDs.
func (m *DeliveryRuleMutation) RemoveCountryIDs(ids ...pulid.ID) {
	if m.removedcountry == nil {
		m.removedcountry = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.country, ids[i])
		m.removedcountry[ids[i]] = struct{}{}
	}
}

// RemovedCountry returns the removed IDs of the "country" edge to the Country entity.
func (m *DeliveryRuleMutation) RemovedCountryIDs() (ids []pulid.ID) {
	for id := range m.removedcountry {
		ids = append(ids, id)
	}
	return
}

// CountryIDs returns the "country" edge IDs in the mutation.
func (m *DeliveryRuleMutation) CountryIDs() (ids []pulid.ID) {
	for id := range m.country {
		ids = append(ids, id)
	}
	return
}

// ResetCountry resets all changes to the "country" edge.
func (m *DeliveryRuleMutation) ResetCountry() {
	m.country = nil
	m.clearedcountry = false
	m.removedcountry = nil
}

// SetCurrencyID sets the "currency" edge to the Currency entity by id.
func (m *DeliveryRuleMutation) SetCurrencyID(id pulid.ID) {
	m.currency = &id
}

// ClearCurrency clears the "currency" edge to the Currency entity.
func (m *DeliveryRuleMutation) ClearCurrency() {
	m.clearedcurrency = true
}

// CurrencyCleared reports if the "currency" edge to the Currency entity was cleared.
func (m *DeliveryRuleMutation) CurrencyCleared() bool {
	return m.clearedcurrency
}

// CurrencyID returns the "currency" edge ID in the mutation.
func (m *DeliveryRuleMutation) CurrencyID() (id pulid.ID, exists bool) {
	if m.currency != nil {
		return *m.currency, true
	}
	return
}

// CurrencyIDs returns the "currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyID instead. It exists only for internal usage by the builders.
func (m *DeliveryRuleMutation) CurrencyIDs() (ids []pulid.ID) {
	if id := m.currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrency resets all changes to the "currency" edge.
func (m *DeliveryRuleMutation) ResetCurrency() {
	m.currency = nil
	m.clearedcurrency = false
}

// Where appends a list predicates to the DeliveryRuleMutation builder.
func (m *DeliveryRuleMutation) Where(ps ...predicate.DeliveryRule) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryRuleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryRuleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryRule, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryRuleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryRuleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryRule).
func (m *DeliveryRuleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryRuleMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, deliveryrule.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, deliveryrule.FieldName)
	}
	if m.price != nil {
		fields = append(fields, deliveryrule.FieldPrice)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryRuleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryrule.FieldTenantID:
		return m.TenantID()
	case deliveryrule.FieldName:
		return m.Name()
	case deliveryrule.FieldPrice:
		return m.Price()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryRuleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryrule.FieldTenantID:
		return m.OldTenantID(ctx)
	case deliveryrule.FieldName:
		return m.OldName(ctx)
	case deliveryrule.FieldPrice:
		return m.OldPrice(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryRule field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryRuleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryrule.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case deliveryrule.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case deliveryrule.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrice(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryRule field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryRuleMutation) AddedFields() []string {
	var fields []string
	if m.addprice != nil {
		fields = append(fields, deliveryrule.FieldPrice)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryRuleMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case deliveryrule.FieldPrice:
		return m.AddedPrice()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryRuleMutation) AddField(name string, value ent.Value) error {
	switch name {
	case deliveryrule.FieldPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPrice(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryRule numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryRuleMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryRuleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryRuleMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryRule nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryRuleMutation) ResetField(name string) error {
	switch name {
	case deliveryrule.FieldTenantID:
		m.ResetTenantID()
		return nil
	case deliveryrule.FieldName:
		m.ResetName()
		return nil
	case deliveryrule.FieldPrice:
		m.ResetPrice()
		return nil
	}
	return fmt.Errorf("unknown DeliveryRule field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryRuleMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, deliveryrule.EdgeTenant)
	}
	if m.delivery_rule_constraint_group != nil {
		edges = append(edges, deliveryrule.EdgeDeliveryRuleConstraintGroup)
	}
	if m.delivery_option != nil {
		edges = append(edges, deliveryrule.EdgeDeliveryOption)
	}
	if m.country != nil {
		edges = append(edges, deliveryrule.EdgeCountry)
	}
	if m.currency != nil {
		edges = append(edges, deliveryrule.EdgeCurrency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryRuleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryrule.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryrule.EdgeDeliveryRuleConstraintGroup:
		ids := make([]ent.Value, 0, len(m.delivery_rule_constraint_group))
		for id := range m.delivery_rule_constraint_group {
			ids = append(ids, id)
		}
		return ids
	case deliveryrule.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case deliveryrule.EdgeCountry:
		ids := make([]ent.Value, 0, len(m.country))
		for id := range m.country {
			ids = append(ids, id)
		}
		return ids
	case deliveryrule.EdgeCurrency:
		if id := m.currency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryRuleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removeddelivery_rule_constraint_group != nil {
		edges = append(edges, deliveryrule.EdgeDeliveryRuleConstraintGroup)
	}
	if m.removedcountry != nil {
		edges = append(edges, deliveryrule.EdgeCountry)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryRuleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryrule.EdgeDeliveryRuleConstraintGroup:
		ids := make([]ent.Value, 0, len(m.removeddelivery_rule_constraint_group))
		for id := range m.removeddelivery_rule_constraint_group {
			ids = append(ids, id)
		}
		return ids
	case deliveryrule.EdgeCountry:
		ids := make([]ent.Value, 0, len(m.removedcountry))
		for id := range m.removedcountry {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryRuleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, deliveryrule.EdgeTenant)
	}
	if m.cleareddelivery_rule_constraint_group {
		edges = append(edges, deliveryrule.EdgeDeliveryRuleConstraintGroup)
	}
	if m.cleareddelivery_option {
		edges = append(edges, deliveryrule.EdgeDeliveryOption)
	}
	if m.clearedcountry {
		edges = append(edges, deliveryrule.EdgeCountry)
	}
	if m.clearedcurrency {
		edges = append(edges, deliveryrule.EdgeCurrency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryRuleMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryrule.EdgeTenant:
		return m.clearedtenant
	case deliveryrule.EdgeDeliveryRuleConstraintGroup:
		return m.cleareddelivery_rule_constraint_group
	case deliveryrule.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case deliveryrule.EdgeCountry:
		return m.clearedcountry
	case deliveryrule.EdgeCurrency:
		return m.clearedcurrency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryRuleMutation) ClearEdge(name string) error {
	switch name {
	case deliveryrule.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryrule.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	case deliveryrule.EdgeCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown DeliveryRule unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryRuleMutation) ResetEdge(name string) error {
	switch name {
	case deliveryrule.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryrule.EdgeDeliveryRuleConstraintGroup:
		m.ResetDeliveryRuleConstraintGroup()
		return nil
	case deliveryrule.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case deliveryrule.EdgeCountry:
		m.ResetCountry()
		return nil
	case deliveryrule.EdgeCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown DeliveryRule edge %s", name)
}

// DeliveryRuleConstraintMutation represents an operation that mutates the DeliveryRuleConstraint nodes in the graph.
type DeliveryRuleConstraintMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *pulid.ID
	property_type                         *deliveryruleconstraint.PropertyType
	comparison                            *deliveryruleconstraint.Comparison
	selected_value                        **fieldjson.DeliveryRuleConstraintSelectedValue
	clearedFields                         map[string]struct{}
	tenant                                *pulid.ID
	clearedtenant                         bool
	delivery_rule_constraint_group        *pulid.ID
	cleareddelivery_rule_constraint_group bool
	done                                  bool
	oldValue                              func(context.Context) (*DeliveryRuleConstraint, error)
	predicates                            []predicate.DeliveryRuleConstraint
}

var _ ent.Mutation = (*DeliveryRuleConstraintMutation)(nil)

// deliveryruleconstraintOption allows management of the mutation configuration using functional options.
type deliveryruleconstraintOption func(*DeliveryRuleConstraintMutation)

// newDeliveryRuleConstraintMutation creates new mutation for the DeliveryRuleConstraint entity.
func newDeliveryRuleConstraintMutation(c config, op Op, opts ...deliveryruleconstraintOption) *DeliveryRuleConstraintMutation {
	m := &DeliveryRuleConstraintMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryRuleConstraint,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryRuleConstraintID sets the ID field of the mutation.
func withDeliveryRuleConstraintID(id pulid.ID) deliveryruleconstraintOption {
	return func(m *DeliveryRuleConstraintMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryRuleConstraint
		)
		m.oldValue = func(ctx context.Context) (*DeliveryRuleConstraint, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryRuleConstraint.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryRuleConstraint sets the old DeliveryRuleConstraint of the mutation.
func withDeliveryRuleConstraint(node *DeliveryRuleConstraint) deliveryruleconstraintOption {
	return func(m *DeliveryRuleConstraintMutation) {
		m.oldValue = func(context.Context) (*DeliveryRuleConstraint, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryRuleConstraintMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryRuleConstraintMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryRuleConstraint entities.
func (m *DeliveryRuleConstraintMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryRuleConstraintMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryRuleConstraintMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryRuleConstraint.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryRuleConstraintMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryRuleConstraintMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryRuleConstraint entity.
// If the DeliveryRuleConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryRuleConstraintMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryRuleConstraintMutation) ResetTenantID() {
	m.tenant = nil
}

// SetPropertyType sets the "property_type" field.
func (m *DeliveryRuleConstraintMutation) SetPropertyType(dt deliveryruleconstraint.PropertyType) {
	m.property_type = &dt
}

// PropertyType returns the value of the "property_type" field in the mutation.
func (m *DeliveryRuleConstraintMutation) PropertyType() (r deliveryruleconstraint.PropertyType, exists bool) {
	v := m.property_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyType returns the old "property_type" field's value of the DeliveryRuleConstraint entity.
// If the DeliveryRuleConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryRuleConstraintMutation) OldPropertyType(ctx context.Context) (v deliveryruleconstraint.PropertyType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyType: %w", err)
	}
	return oldValue.PropertyType, nil
}

// ResetPropertyType resets all changes to the "property_type" field.
func (m *DeliveryRuleConstraintMutation) ResetPropertyType() {
	m.property_type = nil
}

// SetComparison sets the "comparison" field.
func (m *DeliveryRuleConstraintMutation) SetComparison(d deliveryruleconstraint.Comparison) {
	m.comparison = &d
}

// Comparison returns the value of the "comparison" field in the mutation.
func (m *DeliveryRuleConstraintMutation) Comparison() (r deliveryruleconstraint.Comparison, exists bool) {
	v := m.comparison
	if v == nil {
		return
	}
	return *v, true
}

// OldComparison returns the old "comparison" field's value of the DeliveryRuleConstraint entity.
// If the DeliveryRuleConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryRuleConstraintMutation) OldComparison(ctx context.Context) (v deliveryruleconstraint.Comparison, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComparison is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComparison requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComparison: %w", err)
	}
	return oldValue.Comparison, nil
}

// ResetComparison resets all changes to the "comparison" field.
func (m *DeliveryRuleConstraintMutation) ResetComparison() {
	m.comparison = nil
}

// SetSelectedValue sets the "selected_value" field.
func (m *DeliveryRuleConstraintMutation) SetSelectedValue(frcsv *fieldjson.DeliveryRuleConstraintSelectedValue) {
	m.selected_value = &frcsv
}

// SelectedValue returns the value of the "selected_value" field in the mutation.
func (m *DeliveryRuleConstraintMutation) SelectedValue() (r *fieldjson.DeliveryRuleConstraintSelectedValue, exists bool) {
	v := m.selected_value
	if v == nil {
		return
	}
	return *v, true
}

// OldSelectedValue returns the old "selected_value" field's value of the DeliveryRuleConstraint entity.
// If the DeliveryRuleConstraint object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryRuleConstraintMutation) OldSelectedValue(ctx context.Context) (v *fieldjson.DeliveryRuleConstraintSelectedValue, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSelectedValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSelectedValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSelectedValue: %w", err)
	}
	return oldValue.SelectedValue, nil
}

// ResetSelectedValue resets all changes to the "selected_value" field.
func (m *DeliveryRuleConstraintMutation) ResetSelectedValue() {
	m.selected_value = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryRuleConstraintMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryruleconstraint.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryRuleConstraintMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryRuleConstraintMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryRuleConstraintMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDeliveryRuleConstraintGroupID sets the "delivery_rule_constraint_group" edge to the DeliveryRuleConstraintGroup entity by id.
func (m *DeliveryRuleConstraintMutation) SetDeliveryRuleConstraintGroupID(id pulid.ID) {
	m.delivery_rule_constraint_group = &id
}

// ClearDeliveryRuleConstraintGroup clears the "delivery_rule_constraint_group" edge to the DeliveryRuleConstraintGroup entity.
func (m *DeliveryRuleConstraintMutation) ClearDeliveryRuleConstraintGroup() {
	m.cleareddelivery_rule_constraint_group = true
}

// DeliveryRuleConstraintGroupCleared reports if the "delivery_rule_constraint_group" edge to the DeliveryRuleConstraintGroup entity was cleared.
func (m *DeliveryRuleConstraintMutation) DeliveryRuleConstraintGroupCleared() bool {
	return m.cleareddelivery_rule_constraint_group
}

// DeliveryRuleConstraintGroupID returns the "delivery_rule_constraint_group" edge ID in the mutation.
func (m *DeliveryRuleConstraintMutation) DeliveryRuleConstraintGroupID() (id pulid.ID, exists bool) {
	if m.delivery_rule_constraint_group != nil {
		return *m.delivery_rule_constraint_group, true
	}
	return
}

// DeliveryRuleConstraintGroupIDs returns the "delivery_rule_constraint_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryRuleConstraintGroupID instead. It exists only for internal usage by the builders.
func (m *DeliveryRuleConstraintMutation) DeliveryRuleConstraintGroupIDs() (ids []pulid.ID) {
	if id := m.delivery_rule_constraint_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryRuleConstraintGroup resets all changes to the "delivery_rule_constraint_group" edge.
func (m *DeliveryRuleConstraintMutation) ResetDeliveryRuleConstraintGroup() {
	m.delivery_rule_constraint_group = nil
	m.cleareddelivery_rule_constraint_group = false
}

// Where appends a list predicates to the DeliveryRuleConstraintMutation builder.
func (m *DeliveryRuleConstraintMutation) Where(ps ...predicate.DeliveryRuleConstraint) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryRuleConstraintMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryRuleConstraintMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryRuleConstraint, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryRuleConstraintMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryRuleConstraintMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryRuleConstraint).
func (m *DeliveryRuleConstraintMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryRuleConstraintMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, deliveryruleconstraint.FieldTenantID)
	}
	if m.property_type != nil {
		fields = append(fields, deliveryruleconstraint.FieldPropertyType)
	}
	if m.comparison != nil {
		fields = append(fields, deliveryruleconstraint.FieldComparison)
	}
	if m.selected_value != nil {
		fields = append(fields, deliveryruleconstraint.FieldSelectedValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryRuleConstraintMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryruleconstraint.FieldTenantID:
		return m.TenantID()
	case deliveryruleconstraint.FieldPropertyType:
		return m.PropertyType()
	case deliveryruleconstraint.FieldComparison:
		return m.Comparison()
	case deliveryruleconstraint.FieldSelectedValue:
		return m.SelectedValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryRuleConstraintMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryruleconstraint.FieldTenantID:
		return m.OldTenantID(ctx)
	case deliveryruleconstraint.FieldPropertyType:
		return m.OldPropertyType(ctx)
	case deliveryruleconstraint.FieldComparison:
		return m.OldComparison(ctx)
	case deliveryruleconstraint.FieldSelectedValue:
		return m.OldSelectedValue(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryRuleConstraint field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryRuleConstraintMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryruleconstraint.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case deliveryruleconstraint.FieldPropertyType:
		v, ok := value.(deliveryruleconstraint.PropertyType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyType(v)
		return nil
	case deliveryruleconstraint.FieldComparison:
		v, ok := value.(deliveryruleconstraint.Comparison)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComparison(v)
		return nil
	case deliveryruleconstraint.FieldSelectedValue:
		v, ok := value.(*fieldjson.DeliveryRuleConstraintSelectedValue)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSelectedValue(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryRuleConstraint field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryRuleConstraintMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryRuleConstraintMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryRuleConstraintMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryRuleConstraint numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryRuleConstraintMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryRuleConstraintMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryRuleConstraintMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryRuleConstraint nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryRuleConstraintMutation) ResetField(name string) error {
	switch name {
	case deliveryruleconstraint.FieldTenantID:
		m.ResetTenantID()
		return nil
	case deliveryruleconstraint.FieldPropertyType:
		m.ResetPropertyType()
		return nil
	case deliveryruleconstraint.FieldComparison:
		m.ResetComparison()
		return nil
	case deliveryruleconstraint.FieldSelectedValue:
		m.ResetSelectedValue()
		return nil
	}
	return fmt.Errorf("unknown DeliveryRuleConstraint field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryRuleConstraintMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, deliveryruleconstraint.EdgeTenant)
	}
	if m.delivery_rule_constraint_group != nil {
		edges = append(edges, deliveryruleconstraint.EdgeDeliveryRuleConstraintGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryRuleConstraintMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryruleconstraint.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryruleconstraint.EdgeDeliveryRuleConstraintGroup:
		if id := m.delivery_rule_constraint_group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryRuleConstraintMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryRuleConstraintMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryRuleConstraintMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, deliveryruleconstraint.EdgeTenant)
	}
	if m.cleareddelivery_rule_constraint_group {
		edges = append(edges, deliveryruleconstraint.EdgeDeliveryRuleConstraintGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryRuleConstraintMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryruleconstraint.EdgeTenant:
		return m.clearedtenant
	case deliveryruleconstraint.EdgeDeliveryRuleConstraintGroup:
		return m.cleareddelivery_rule_constraint_group
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryRuleConstraintMutation) ClearEdge(name string) error {
	switch name {
	case deliveryruleconstraint.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryruleconstraint.EdgeDeliveryRuleConstraintGroup:
		m.ClearDeliveryRuleConstraintGroup()
		return nil
	}
	return fmt.Errorf("unknown DeliveryRuleConstraint unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryRuleConstraintMutation) ResetEdge(name string) error {
	switch name {
	case deliveryruleconstraint.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryruleconstraint.EdgeDeliveryRuleConstraintGroup:
		m.ResetDeliveryRuleConstraintGroup()
		return nil
	}
	return fmt.Errorf("unknown DeliveryRuleConstraint edge %s", name)
}

// DeliveryRuleConstraintGroupMutation represents an operation that mutates the DeliveryRuleConstraintGroup nodes in the graph.
type DeliveryRuleConstraintGroupMutation struct {
	config
	op                               Op
	typ                              string
	id                               *pulid.ID
	constraint_logic                 *deliveryruleconstraintgroup.ConstraintLogic
	clearedFields                    map[string]struct{}
	tenant                           *pulid.ID
	clearedtenant                    bool
	delivery_rule_constraints        map[pulid.ID]struct{}
	removeddelivery_rule_constraints map[pulid.ID]struct{}
	cleareddelivery_rule_constraints bool
	delivery_rule                    *pulid.ID
	cleareddelivery_rule             bool
	done                             bool
	oldValue                         func(context.Context) (*DeliveryRuleConstraintGroup, error)
	predicates                       []predicate.DeliveryRuleConstraintGroup
}

var _ ent.Mutation = (*DeliveryRuleConstraintGroupMutation)(nil)

// deliveryruleconstraintgroupOption allows management of the mutation configuration using functional options.
type deliveryruleconstraintgroupOption func(*DeliveryRuleConstraintGroupMutation)

// newDeliveryRuleConstraintGroupMutation creates new mutation for the DeliveryRuleConstraintGroup entity.
func newDeliveryRuleConstraintGroupMutation(c config, op Op, opts ...deliveryruleconstraintgroupOption) *DeliveryRuleConstraintGroupMutation {
	m := &DeliveryRuleConstraintGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeDeliveryRuleConstraintGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDeliveryRuleConstraintGroupID sets the ID field of the mutation.
func withDeliveryRuleConstraintGroupID(id pulid.ID) deliveryruleconstraintgroupOption {
	return func(m *DeliveryRuleConstraintGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *DeliveryRuleConstraintGroup
		)
		m.oldValue = func(ctx context.Context) (*DeliveryRuleConstraintGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DeliveryRuleConstraintGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDeliveryRuleConstraintGroup sets the old DeliveryRuleConstraintGroup of the mutation.
func withDeliveryRuleConstraintGroup(node *DeliveryRuleConstraintGroup) deliveryruleconstraintgroupOption {
	return func(m *DeliveryRuleConstraintGroupMutation) {
		m.oldValue = func(context.Context) (*DeliveryRuleConstraintGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DeliveryRuleConstraintGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DeliveryRuleConstraintGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DeliveryRuleConstraintGroup entities.
func (m *DeliveryRuleConstraintGroupMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DeliveryRuleConstraintGroupMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DeliveryRuleConstraintGroupMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DeliveryRuleConstraintGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DeliveryRuleConstraintGroupMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DeliveryRuleConstraintGroupMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DeliveryRuleConstraintGroup entity.
// If the DeliveryRuleConstraintGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryRuleConstraintGroupMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DeliveryRuleConstraintGroupMutation) ResetTenantID() {
	m.tenant = nil
}

// SetConstraintLogic sets the "constraint_logic" field.
func (m *DeliveryRuleConstraintGroupMutation) SetConstraintLogic(dl deliveryruleconstraintgroup.ConstraintLogic) {
	m.constraint_logic = &dl
}

// ConstraintLogic returns the value of the "constraint_logic" field in the mutation.
func (m *DeliveryRuleConstraintGroupMutation) ConstraintLogic() (r deliveryruleconstraintgroup.ConstraintLogic, exists bool) {
	v := m.constraint_logic
	if v == nil {
		return
	}
	return *v, true
}

// OldConstraintLogic returns the old "constraint_logic" field's value of the DeliveryRuleConstraintGroup entity.
// If the DeliveryRuleConstraintGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DeliveryRuleConstraintGroupMutation) OldConstraintLogic(ctx context.Context) (v deliveryruleconstraintgroup.ConstraintLogic, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConstraintLogic is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConstraintLogic requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConstraintLogic: %w", err)
	}
	return oldValue.ConstraintLogic, nil
}

// ResetConstraintLogic resets all changes to the "constraint_logic" field.
func (m *DeliveryRuleConstraintGroupMutation) ResetConstraintLogic() {
	m.constraint_logic = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DeliveryRuleConstraintGroupMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[deliveryruleconstraintgroup.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DeliveryRuleConstraintGroupMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DeliveryRuleConstraintGroupMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DeliveryRuleConstraintGroupMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddDeliveryRuleConstraintIDs adds the "delivery_rule_constraints" edge to the DeliveryRuleConstraint entity by ids.
func (m *DeliveryRuleConstraintGroupMutation) AddDeliveryRuleConstraintIDs(ids ...pulid.ID) {
	if m.delivery_rule_constraints == nil {
		m.delivery_rule_constraints = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_rule_constraints[ids[i]] = struct{}{}
	}
}

// ClearDeliveryRuleConstraints clears the "delivery_rule_constraints" edge to the DeliveryRuleConstraint entity.
func (m *DeliveryRuleConstraintGroupMutation) ClearDeliveryRuleConstraints() {
	m.cleareddelivery_rule_constraints = true
}

// DeliveryRuleConstraintsCleared reports if the "delivery_rule_constraints" edge to the DeliveryRuleConstraint entity was cleared.
func (m *DeliveryRuleConstraintGroupMutation) DeliveryRuleConstraintsCleared() bool {
	return m.cleareddelivery_rule_constraints
}

// RemoveDeliveryRuleConstraintIDs removes the "delivery_rule_constraints" edge to the DeliveryRuleConstraint entity by IDs.
func (m *DeliveryRuleConstraintGroupMutation) RemoveDeliveryRuleConstraintIDs(ids ...pulid.ID) {
	if m.removeddelivery_rule_constraints == nil {
		m.removeddelivery_rule_constraints = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_rule_constraints, ids[i])
		m.removeddelivery_rule_constraints[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryRuleConstraints returns the removed IDs of the "delivery_rule_constraints" edge to the DeliveryRuleConstraint entity.
func (m *DeliveryRuleConstraintGroupMutation) RemovedDeliveryRuleConstraintsIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_rule_constraints {
		ids = append(ids, id)
	}
	return
}

// DeliveryRuleConstraintsIDs returns the "delivery_rule_constraints" edge IDs in the mutation.
func (m *DeliveryRuleConstraintGroupMutation) DeliveryRuleConstraintsIDs() (ids []pulid.ID) {
	for id := range m.delivery_rule_constraints {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryRuleConstraints resets all changes to the "delivery_rule_constraints" edge.
func (m *DeliveryRuleConstraintGroupMutation) ResetDeliveryRuleConstraints() {
	m.delivery_rule_constraints = nil
	m.cleareddelivery_rule_constraints = false
	m.removeddelivery_rule_constraints = nil
}

// SetDeliveryRuleID sets the "delivery_rule" edge to the DeliveryRule entity by id.
func (m *DeliveryRuleConstraintGroupMutation) SetDeliveryRuleID(id pulid.ID) {
	m.delivery_rule = &id
}

// ClearDeliveryRule clears the "delivery_rule" edge to the DeliveryRule entity.
func (m *DeliveryRuleConstraintGroupMutation) ClearDeliveryRule() {
	m.cleareddelivery_rule = true
}

// DeliveryRuleCleared reports if the "delivery_rule" edge to the DeliveryRule entity was cleared.
func (m *DeliveryRuleConstraintGroupMutation) DeliveryRuleCleared() bool {
	return m.cleareddelivery_rule
}

// DeliveryRuleID returns the "delivery_rule" edge ID in the mutation.
func (m *DeliveryRuleConstraintGroupMutation) DeliveryRuleID() (id pulid.ID, exists bool) {
	if m.delivery_rule != nil {
		return *m.delivery_rule, true
	}
	return
}

// DeliveryRuleIDs returns the "delivery_rule" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryRuleID instead. It exists only for internal usage by the builders.
func (m *DeliveryRuleConstraintGroupMutation) DeliveryRuleIDs() (ids []pulid.ID) {
	if id := m.delivery_rule; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryRule resets all changes to the "delivery_rule" edge.
func (m *DeliveryRuleConstraintGroupMutation) ResetDeliveryRule() {
	m.delivery_rule = nil
	m.cleareddelivery_rule = false
}

// Where appends a list predicates to the DeliveryRuleConstraintGroupMutation builder.
func (m *DeliveryRuleConstraintGroupMutation) Where(ps ...predicate.DeliveryRuleConstraintGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DeliveryRuleConstraintGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DeliveryRuleConstraintGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DeliveryRuleConstraintGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DeliveryRuleConstraintGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DeliveryRuleConstraintGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DeliveryRuleConstraintGroup).
func (m *DeliveryRuleConstraintGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DeliveryRuleConstraintGroupMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, deliveryruleconstraintgroup.FieldTenantID)
	}
	if m.constraint_logic != nil {
		fields = append(fields, deliveryruleconstraintgroup.FieldConstraintLogic)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DeliveryRuleConstraintGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case deliveryruleconstraintgroup.FieldTenantID:
		return m.TenantID()
	case deliveryruleconstraintgroup.FieldConstraintLogic:
		return m.ConstraintLogic()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DeliveryRuleConstraintGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case deliveryruleconstraintgroup.FieldTenantID:
		return m.OldTenantID(ctx)
	case deliveryruleconstraintgroup.FieldConstraintLogic:
		return m.OldConstraintLogic(ctx)
	}
	return nil, fmt.Errorf("unknown DeliveryRuleConstraintGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryRuleConstraintGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case deliveryruleconstraintgroup.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case deliveryruleconstraintgroup.FieldConstraintLogic:
		v, ok := value.(deliveryruleconstraintgroup.ConstraintLogic)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConstraintLogic(v)
		return nil
	}
	return fmt.Errorf("unknown DeliveryRuleConstraintGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DeliveryRuleConstraintGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DeliveryRuleConstraintGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DeliveryRuleConstraintGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DeliveryRuleConstraintGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DeliveryRuleConstraintGroupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DeliveryRuleConstraintGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DeliveryRuleConstraintGroupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown DeliveryRuleConstraintGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DeliveryRuleConstraintGroupMutation) ResetField(name string) error {
	switch name {
	case deliveryruleconstraintgroup.FieldTenantID:
		m.ResetTenantID()
		return nil
	case deliveryruleconstraintgroup.FieldConstraintLogic:
		m.ResetConstraintLogic()
		return nil
	}
	return fmt.Errorf("unknown DeliveryRuleConstraintGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DeliveryRuleConstraintGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, deliveryruleconstraintgroup.EdgeTenant)
	}
	if m.delivery_rule_constraints != nil {
		edges = append(edges, deliveryruleconstraintgroup.EdgeDeliveryRuleConstraints)
	}
	if m.delivery_rule != nil {
		edges = append(edges, deliveryruleconstraintgroup.EdgeDeliveryRule)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DeliveryRuleConstraintGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case deliveryruleconstraintgroup.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case deliveryruleconstraintgroup.EdgeDeliveryRuleConstraints:
		ids := make([]ent.Value, 0, len(m.delivery_rule_constraints))
		for id := range m.delivery_rule_constraints {
			ids = append(ids, id)
		}
		return ids
	case deliveryruleconstraintgroup.EdgeDeliveryRule:
		if id := m.delivery_rule; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DeliveryRuleConstraintGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removeddelivery_rule_constraints != nil {
		edges = append(edges, deliveryruleconstraintgroup.EdgeDeliveryRuleConstraints)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DeliveryRuleConstraintGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case deliveryruleconstraintgroup.EdgeDeliveryRuleConstraints:
		ids := make([]ent.Value, 0, len(m.removeddelivery_rule_constraints))
		for id := range m.removeddelivery_rule_constraints {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DeliveryRuleConstraintGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, deliveryruleconstraintgroup.EdgeTenant)
	}
	if m.cleareddelivery_rule_constraints {
		edges = append(edges, deliveryruleconstraintgroup.EdgeDeliveryRuleConstraints)
	}
	if m.cleareddelivery_rule {
		edges = append(edges, deliveryruleconstraintgroup.EdgeDeliveryRule)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DeliveryRuleConstraintGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case deliveryruleconstraintgroup.EdgeTenant:
		return m.clearedtenant
	case deliveryruleconstraintgroup.EdgeDeliveryRuleConstraints:
		return m.cleareddelivery_rule_constraints
	case deliveryruleconstraintgroup.EdgeDeliveryRule:
		return m.cleareddelivery_rule
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DeliveryRuleConstraintGroupMutation) ClearEdge(name string) error {
	switch name {
	case deliveryruleconstraintgroup.EdgeTenant:
		m.ClearTenant()
		return nil
	case deliveryruleconstraintgroup.EdgeDeliveryRule:
		m.ClearDeliveryRule()
		return nil
	}
	return fmt.Errorf("unknown DeliveryRuleConstraintGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DeliveryRuleConstraintGroupMutation) ResetEdge(name string) error {
	switch name {
	case deliveryruleconstraintgroup.EdgeTenant:
		m.ResetTenant()
		return nil
	case deliveryruleconstraintgroup.EdgeDeliveryRuleConstraints:
		m.ResetDeliveryRuleConstraints()
		return nil
	case deliveryruleconstraintgroup.EdgeDeliveryRule:
		m.ResetDeliveryRule()
		return nil
	}
	return fmt.Errorf("unknown DeliveryRuleConstraintGroup edge %s", name)
}

// DocumentMutation represents an operation that mutates the Document nodes in the graph.
type DocumentMutation struct {
	config
	op                             Op
	typ                            string
	id                             *pulid.ID
	name                           *string
	html_template                  *string
	html_header                    *string
	html_footer                    *string
	last_base64_pdf                *string
	merge_type                     *document.MergeType
	paper_size                     *document.PaperSize
	start_at                       *time.Time
	end_at                         *time.Time
	created_at                     *time.Time
	clearedFields                  map[string]struct{}
	tenant                         *pulid.ID
	clearedtenant                  bool
	carrier_brand                  *pulid.ID
	clearedcarrier_brand           bool
	connection_packing_slip        map[pulid.ID]struct{}
	removedconnection_packing_slip map[pulid.ID]struct{}
	clearedconnection_packing_slip bool
	done                           bool
	oldValue                       func(context.Context) (*Document, error)
	predicates                     []predicate.Document
}

var _ ent.Mutation = (*DocumentMutation)(nil)

// documentOption allows management of the mutation configuration using functional options.
type documentOption func(*DocumentMutation)

// newDocumentMutation creates new mutation for the Document entity.
func newDocumentMutation(c config, op Op, opts ...documentOption) *DocumentMutation {
	m := &DocumentMutation{
		config:        c,
		op:            op,
		typ:           TypeDocument,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentID sets the ID field of the mutation.
func withDocumentID(id pulid.ID) documentOption {
	return func(m *DocumentMutation) {
		var (
			err   error
			once  sync.Once
			value *Document
		)
		m.oldValue = func(ctx context.Context) (*Document, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Document.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocument sets the old Document of the mutation.
func withDocument(node *Document) documentOption {
	return func(m *DocumentMutation) {
		m.oldValue = func(context.Context) (*Document, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Document entities.
func (m *DocumentMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Document.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DocumentMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DocumentMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DocumentMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *DocumentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DocumentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DocumentMutation) ResetName() {
	m.name = nil
}

// SetHTMLTemplate sets the "html_template" field.
func (m *DocumentMutation) SetHTMLTemplate(s string) {
	m.html_template = &s
}

// HTMLTemplate returns the value of the "html_template" field in the mutation.
func (m *DocumentMutation) HTMLTemplate() (r string, exists bool) {
	v := m.html_template
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLTemplate returns the old "html_template" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldHTMLTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLTemplate: %w", err)
	}
	return oldValue.HTMLTemplate, nil
}

// ClearHTMLTemplate clears the value of the "html_template" field.
func (m *DocumentMutation) ClearHTMLTemplate() {
	m.html_template = nil
	m.clearedFields[document.FieldHTMLTemplate] = struct{}{}
}

// HTMLTemplateCleared returns if the "html_template" field was cleared in this mutation.
func (m *DocumentMutation) HTMLTemplateCleared() bool {
	_, ok := m.clearedFields[document.FieldHTMLTemplate]
	return ok
}

// ResetHTMLTemplate resets all changes to the "html_template" field.
func (m *DocumentMutation) ResetHTMLTemplate() {
	m.html_template = nil
	delete(m.clearedFields, document.FieldHTMLTemplate)
}

// SetHTMLHeader sets the "html_header" field.
func (m *DocumentMutation) SetHTMLHeader(s string) {
	m.html_header = &s
}

// HTMLHeader returns the value of the "html_header" field in the mutation.
func (m *DocumentMutation) HTMLHeader() (r string, exists bool) {
	v := m.html_header
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLHeader returns the old "html_header" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldHTMLHeader(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLHeader is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLHeader requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLHeader: %w", err)
	}
	return oldValue.HTMLHeader, nil
}

// ClearHTMLHeader clears the value of the "html_header" field.
func (m *DocumentMutation) ClearHTMLHeader() {
	m.html_header = nil
	m.clearedFields[document.FieldHTMLHeader] = struct{}{}
}

// HTMLHeaderCleared returns if the "html_header" field was cleared in this mutation.
func (m *DocumentMutation) HTMLHeaderCleared() bool {
	_, ok := m.clearedFields[document.FieldHTMLHeader]
	return ok
}

// ResetHTMLHeader resets all changes to the "html_header" field.
func (m *DocumentMutation) ResetHTMLHeader() {
	m.html_header = nil
	delete(m.clearedFields, document.FieldHTMLHeader)
}

// SetHTMLFooter sets the "html_footer" field.
func (m *DocumentMutation) SetHTMLFooter(s string) {
	m.html_footer = &s
}

// HTMLFooter returns the value of the "html_footer" field in the mutation.
func (m *DocumentMutation) HTMLFooter() (r string, exists bool) {
	v := m.html_footer
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLFooter returns the old "html_footer" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldHTMLFooter(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLFooter is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLFooter requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLFooter: %w", err)
	}
	return oldValue.HTMLFooter, nil
}

// ClearHTMLFooter clears the value of the "html_footer" field.
func (m *DocumentMutation) ClearHTMLFooter() {
	m.html_footer = nil
	m.clearedFields[document.FieldHTMLFooter] = struct{}{}
}

// HTMLFooterCleared returns if the "html_footer" field was cleared in this mutation.
func (m *DocumentMutation) HTMLFooterCleared() bool {
	_, ok := m.clearedFields[document.FieldHTMLFooter]
	return ok
}

// ResetHTMLFooter resets all changes to the "html_footer" field.
func (m *DocumentMutation) ResetHTMLFooter() {
	m.html_footer = nil
	delete(m.clearedFields, document.FieldHTMLFooter)
}

// SetLastBase64Pdf sets the "last_base64_pdf" field.
func (m *DocumentMutation) SetLastBase64Pdf(s string) {
	m.last_base64_pdf = &s
}

// LastBase64Pdf returns the value of the "last_base64_pdf" field in the mutation.
func (m *DocumentMutation) LastBase64Pdf() (r string, exists bool) {
	v := m.last_base64_pdf
	if v == nil {
		return
	}
	return *v, true
}

// OldLastBase64Pdf returns the old "last_base64_pdf" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldLastBase64Pdf(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastBase64Pdf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastBase64Pdf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastBase64Pdf: %w", err)
	}
	return oldValue.LastBase64Pdf, nil
}

// ClearLastBase64Pdf clears the value of the "last_base64_pdf" field.
func (m *DocumentMutation) ClearLastBase64Pdf() {
	m.last_base64_pdf = nil
	m.clearedFields[document.FieldLastBase64Pdf] = struct{}{}
}

// LastBase64PdfCleared returns if the "last_base64_pdf" field was cleared in this mutation.
func (m *DocumentMutation) LastBase64PdfCleared() bool {
	_, ok := m.clearedFields[document.FieldLastBase64Pdf]
	return ok
}

// ResetLastBase64Pdf resets all changes to the "last_base64_pdf" field.
func (m *DocumentMutation) ResetLastBase64Pdf() {
	m.last_base64_pdf = nil
	delete(m.clearedFields, document.FieldLastBase64Pdf)
}

// SetMergeType sets the "merge_type" field.
func (m *DocumentMutation) SetMergeType(dt document.MergeType) {
	m.merge_type = &dt
}

// MergeType returns the value of the "merge_type" field in the mutation.
func (m *DocumentMutation) MergeType() (r document.MergeType, exists bool) {
	v := m.merge_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMergeType returns the old "merge_type" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldMergeType(ctx context.Context) (v document.MergeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMergeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMergeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMergeType: %w", err)
	}
	return oldValue.MergeType, nil
}

// ResetMergeType resets all changes to the "merge_type" field.
func (m *DocumentMutation) ResetMergeType() {
	m.merge_type = nil
}

// SetPaperSize sets the "paper_size" field.
func (m *DocumentMutation) SetPaperSize(ds document.PaperSize) {
	m.paper_size = &ds
}

// PaperSize returns the value of the "paper_size" field in the mutation.
func (m *DocumentMutation) PaperSize() (r document.PaperSize, exists bool) {
	v := m.paper_size
	if v == nil {
		return
	}
	return *v, true
}

// OldPaperSize returns the old "paper_size" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldPaperSize(ctx context.Context) (v document.PaperSize, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPaperSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPaperSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPaperSize: %w", err)
	}
	return oldValue.PaperSize, nil
}

// ResetPaperSize resets all changes to the "paper_size" field.
func (m *DocumentMutation) ResetPaperSize() {
	m.paper_size = nil
}

// SetStartAt sets the "start_at" field.
func (m *DocumentMutation) SetStartAt(t time.Time) {
	m.start_at = &t
}

// StartAt returns the value of the "start_at" field in the mutation.
func (m *DocumentMutation) StartAt() (r time.Time, exists bool) {
	v := m.start_at
	if v == nil {
		return
	}
	return *v, true
}

// OldStartAt returns the old "start_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldStartAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStartAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStartAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartAt: %w", err)
	}
	return oldValue.StartAt, nil
}

// ResetStartAt resets all changes to the "start_at" field.
func (m *DocumentMutation) ResetStartAt() {
	m.start_at = nil
}

// SetEndAt sets the "end_at" field.
func (m *DocumentMutation) SetEndAt(t time.Time) {
	m.end_at = &t
}

// EndAt returns the value of the "end_at" field in the mutation.
func (m *DocumentMutation) EndAt() (r time.Time, exists bool) {
	v := m.end_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEndAt returns the old "end_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldEndAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEndAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEndAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndAt: %w", err)
	}
	return oldValue.EndAt, nil
}

// ResetEndAt resets all changes to the "end_at" field.
func (m *DocumentMutation) ResetEndAt() {
	m.end_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Document entity.
// If the Document object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DocumentMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[document.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DocumentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DocumentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierBrandID sets the "carrier_brand" edge to the CarrierBrand entity by id.
func (m *DocumentMutation) SetCarrierBrandID(id pulid.ID) {
	m.carrier_brand = &id
}

// ClearCarrierBrand clears the "carrier_brand" edge to the CarrierBrand entity.
func (m *DocumentMutation) ClearCarrierBrand() {
	m.clearedcarrier_brand = true
}

// CarrierBrandCleared reports if the "carrier_brand" edge to the CarrierBrand entity was cleared.
func (m *DocumentMutation) CarrierBrandCleared() bool {
	return m.clearedcarrier_brand
}

// CarrierBrandID returns the "carrier_brand" edge ID in the mutation.
func (m *DocumentMutation) CarrierBrandID() (id pulid.ID, exists bool) {
	if m.carrier_brand != nil {
		return *m.carrier_brand, true
	}
	return
}

// CarrierBrandIDs returns the "carrier_brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierBrandID instead. It exists only for internal usage by the builders.
func (m *DocumentMutation) CarrierBrandIDs() (ids []pulid.ID) {
	if id := m.carrier_brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierBrand resets all changes to the "carrier_brand" edge.
func (m *DocumentMutation) ResetCarrierBrand() {
	m.carrier_brand = nil
	m.clearedcarrier_brand = false
}

// AddConnectionPackingSlipIDs adds the "connection_packing_slip" edge to the Connection entity by ids.
func (m *DocumentMutation) AddConnectionPackingSlipIDs(ids ...pulid.ID) {
	if m.connection_packing_slip == nil {
		m.connection_packing_slip = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.connection_packing_slip[ids[i]] = struct{}{}
	}
}

// ClearConnectionPackingSlip clears the "connection_packing_slip" edge to the Connection entity.
func (m *DocumentMutation) ClearConnectionPackingSlip() {
	m.clearedconnection_packing_slip = true
}

// ConnectionPackingSlipCleared reports if the "connection_packing_slip" edge to the Connection entity was cleared.
func (m *DocumentMutation) ConnectionPackingSlipCleared() bool {
	return m.clearedconnection_packing_slip
}

// RemoveConnectionPackingSlipIDs removes the "connection_packing_slip" edge to the Connection entity by IDs.
func (m *DocumentMutation) RemoveConnectionPackingSlipIDs(ids ...pulid.ID) {
	if m.removedconnection_packing_slip == nil {
		m.removedconnection_packing_slip = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.connection_packing_slip, ids[i])
		m.removedconnection_packing_slip[ids[i]] = struct{}{}
	}
}

// RemovedConnectionPackingSlip returns the removed IDs of the "connection_packing_slip" edge to the Connection entity.
func (m *DocumentMutation) RemovedConnectionPackingSlipIDs() (ids []pulid.ID) {
	for id := range m.removedconnection_packing_slip {
		ids = append(ids, id)
	}
	return
}

// ConnectionPackingSlipIDs returns the "connection_packing_slip" edge IDs in the mutation.
func (m *DocumentMutation) ConnectionPackingSlipIDs() (ids []pulid.ID) {
	for id := range m.connection_packing_slip {
		ids = append(ids, id)
	}
	return
}

// ResetConnectionPackingSlip resets all changes to the "connection_packing_slip" edge.
func (m *DocumentMutation) ResetConnectionPackingSlip() {
	m.connection_packing_slip = nil
	m.clearedconnection_packing_slip = false
	m.removedconnection_packing_slip = nil
}

// Where appends a list predicates to the DocumentMutation builder.
func (m *DocumentMutation) Where(ps ...predicate.Document) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Document, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Document).
func (m *DocumentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.tenant != nil {
		fields = append(fields, document.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, document.FieldName)
	}
	if m.html_template != nil {
		fields = append(fields, document.FieldHTMLTemplate)
	}
	if m.html_header != nil {
		fields = append(fields, document.FieldHTMLHeader)
	}
	if m.html_footer != nil {
		fields = append(fields, document.FieldHTMLFooter)
	}
	if m.last_base64_pdf != nil {
		fields = append(fields, document.FieldLastBase64Pdf)
	}
	if m.merge_type != nil {
		fields = append(fields, document.FieldMergeType)
	}
	if m.paper_size != nil {
		fields = append(fields, document.FieldPaperSize)
	}
	if m.start_at != nil {
		fields = append(fields, document.FieldStartAt)
	}
	if m.end_at != nil {
		fields = append(fields, document.FieldEndAt)
	}
	if m.created_at != nil {
		fields = append(fields, document.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case document.FieldTenantID:
		return m.TenantID()
	case document.FieldName:
		return m.Name()
	case document.FieldHTMLTemplate:
		return m.HTMLTemplate()
	case document.FieldHTMLHeader:
		return m.HTMLHeader()
	case document.FieldHTMLFooter:
		return m.HTMLFooter()
	case document.FieldLastBase64Pdf:
		return m.LastBase64Pdf()
	case document.FieldMergeType:
		return m.MergeType()
	case document.FieldPaperSize:
		return m.PaperSize()
	case document.FieldStartAt:
		return m.StartAt()
	case document.FieldEndAt:
		return m.EndAt()
	case document.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case document.FieldTenantID:
		return m.OldTenantID(ctx)
	case document.FieldName:
		return m.OldName(ctx)
	case document.FieldHTMLTemplate:
		return m.OldHTMLTemplate(ctx)
	case document.FieldHTMLHeader:
		return m.OldHTMLHeader(ctx)
	case document.FieldHTMLFooter:
		return m.OldHTMLFooter(ctx)
	case document.FieldLastBase64Pdf:
		return m.OldLastBase64Pdf(ctx)
	case document.FieldMergeType:
		return m.OldMergeType(ctx)
	case document.FieldPaperSize:
		return m.OldPaperSize(ctx)
	case document.FieldStartAt:
		return m.OldStartAt(ctx)
	case document.FieldEndAt:
		return m.OldEndAt(ctx)
	case document.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Document field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case document.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case document.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case document.FieldHTMLTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLTemplate(v)
		return nil
	case document.FieldHTMLHeader:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLHeader(v)
		return nil
	case document.FieldHTMLFooter:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLFooter(v)
		return nil
	case document.FieldLastBase64Pdf:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastBase64Pdf(v)
		return nil
	case document.FieldMergeType:
		v, ok := value.(document.MergeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMergeType(v)
		return nil
	case document.FieldPaperSize:
		v, ok := value.(document.PaperSize)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaperSize(v)
		return nil
	case document.FieldStartAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartAt(v)
		return nil
	case document.FieldEndAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndAt(v)
		return nil
	case document.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Document numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(document.FieldHTMLTemplate) {
		fields = append(fields, document.FieldHTMLTemplate)
	}
	if m.FieldCleared(document.FieldHTMLHeader) {
		fields = append(fields, document.FieldHTMLHeader)
	}
	if m.FieldCleared(document.FieldHTMLFooter) {
		fields = append(fields, document.FieldHTMLFooter)
	}
	if m.FieldCleared(document.FieldLastBase64Pdf) {
		fields = append(fields, document.FieldLastBase64Pdf)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentMutation) ClearField(name string) error {
	switch name {
	case document.FieldHTMLTemplate:
		m.ClearHTMLTemplate()
		return nil
	case document.FieldHTMLHeader:
		m.ClearHTMLHeader()
		return nil
	case document.FieldHTMLFooter:
		m.ClearHTMLFooter()
		return nil
	case document.FieldLastBase64Pdf:
		m.ClearLastBase64Pdf()
		return nil
	}
	return fmt.Errorf("unknown Document nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentMutation) ResetField(name string) error {
	switch name {
	case document.FieldTenantID:
		m.ResetTenantID()
		return nil
	case document.FieldName:
		m.ResetName()
		return nil
	case document.FieldHTMLTemplate:
		m.ResetHTMLTemplate()
		return nil
	case document.FieldHTMLHeader:
		m.ResetHTMLHeader()
		return nil
	case document.FieldHTMLFooter:
		m.ResetHTMLFooter()
		return nil
	case document.FieldLastBase64Pdf:
		m.ResetLastBase64Pdf()
		return nil
	case document.FieldMergeType:
		m.ResetMergeType()
		return nil
	case document.FieldPaperSize:
		m.ResetPaperSize()
		return nil
	case document.FieldStartAt:
		m.ResetStartAt()
		return nil
	case document.FieldEndAt:
		m.ResetEndAt()
		return nil
	case document.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Document field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, document.EdgeTenant)
	}
	if m.carrier_brand != nil {
		edges = append(edges, document.EdgeCarrierBrand)
	}
	if m.connection_packing_slip != nil {
		edges = append(edges, document.EdgeConnectionPackingSlip)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeCarrierBrand:
		if id := m.carrier_brand; id != nil {
			return []ent.Value{*id}
		}
	case document.EdgeConnectionPackingSlip:
		ids := make([]ent.Value, 0, len(m.connection_packing_slip))
		for id := range m.connection_packing_slip {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedconnection_packing_slip != nil {
		edges = append(edges, document.EdgeConnectionPackingSlip)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case document.EdgeConnectionPackingSlip:
		ids := make([]ent.Value, 0, len(m.removedconnection_packing_slip))
		for id := range m.removedconnection_packing_slip {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, document.EdgeTenant)
	}
	if m.clearedcarrier_brand {
		edges = append(edges, document.EdgeCarrierBrand)
	}
	if m.clearedconnection_packing_slip {
		edges = append(edges, document.EdgeConnectionPackingSlip)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentMutation) EdgeCleared(name string) bool {
	switch name {
	case document.EdgeTenant:
		return m.clearedtenant
	case document.EdgeCarrierBrand:
		return m.clearedcarrier_brand
	case document.EdgeConnectionPackingSlip:
		return m.clearedconnection_packing_slip
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentMutation) ClearEdge(name string) error {
	switch name {
	case document.EdgeTenant:
		m.ClearTenant()
		return nil
	case document.EdgeCarrierBrand:
		m.ClearCarrierBrand()
		return nil
	}
	return fmt.Errorf("unknown Document unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentMutation) ResetEdge(name string) error {
	switch name {
	case document.EdgeTenant:
		m.ResetTenant()
		return nil
	case document.EdgeCarrierBrand:
		m.ResetCarrierBrand()
		return nil
	case document.EdgeConnectionPackingSlip:
		m.ResetConnectionPackingSlip()
		return nil
	}
	return fmt.Errorf("unknown Document edge %s", name)
}

// DocumentFileMutation represents an operation that mutates the DocumentFile nodes in the graph.
type DocumentFileMutation struct {
	config
	op                     Op
	typ                    string
	id                     *pulid.ID
	created_at             *time.Time
	storage_type           *documentfile.StorageType
	storage_path           *string
	storage_path_zpl       *string
	doc_type               *documentfile.DocType
	data_pdf_base64        *string
	data_zpl_base64        *string
	clearedFields          map[string]struct{}
	tenant                 *pulid.ID
	clearedtenant          bool
	colli                  *pulid.ID
	clearedcolli           bool
	shipment_parcel        *pulid.ID
	clearedshipment_parcel bool
	done                   bool
	oldValue               func(context.Context) (*DocumentFile, error)
	predicates             []predicate.DocumentFile
}

var _ ent.Mutation = (*DocumentFileMutation)(nil)

// documentfileOption allows management of the mutation configuration using functional options.
type documentfileOption func(*DocumentFileMutation)

// newDocumentFileMutation creates new mutation for the DocumentFile entity.
func newDocumentFileMutation(c config, op Op, opts ...documentfileOption) *DocumentFileMutation {
	m := &DocumentFileMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentFileID sets the ID field of the mutation.
func withDocumentFileID(id pulid.ID) documentfileOption {
	return func(m *DocumentFileMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentFile
		)
		m.oldValue = func(ctx context.Context) (*DocumentFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentFile sets the old DocumentFile of the mutation.
func withDocumentFile(node *DocumentFile) documentfileOption {
	return func(m *DocumentFileMutation) {
		m.oldValue = func(context.Context) (*DocumentFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocumentFile entities.
func (m *DocumentFileMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentFileMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentFileMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *DocumentFileMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *DocumentFileMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the DocumentFile entity.
// If the DocumentFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentFileMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *DocumentFileMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *DocumentFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *DocumentFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the DocumentFile entity.
// If the DocumentFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *DocumentFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStorageType sets the "storage_type" field.
func (m *DocumentFileMutation) SetStorageType(dt documentfile.StorageType) {
	m.storage_type = &dt
}

// StorageType returns the value of the "storage_type" field in the mutation.
func (m *DocumentFileMutation) StorageType() (r documentfile.StorageType, exists bool) {
	v := m.storage_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageType returns the old "storage_type" field's value of the DocumentFile entity.
// If the DocumentFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentFileMutation) OldStorageType(ctx context.Context) (v documentfile.StorageType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageType: %w", err)
	}
	return oldValue.StorageType, nil
}

// ResetStorageType resets all changes to the "storage_type" field.
func (m *DocumentFileMutation) ResetStorageType() {
	m.storage_type = nil
}

// SetStoragePath sets the "storage_path" field.
func (m *DocumentFileMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *DocumentFileMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the DocumentFile entity.
// If the DocumentFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentFileMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ClearStoragePath clears the value of the "storage_path" field.
func (m *DocumentFileMutation) ClearStoragePath() {
	m.storage_path = nil
	m.clearedFields[documentfile.FieldStoragePath] = struct{}{}
}

// StoragePathCleared returns if the "storage_path" field was cleared in this mutation.
func (m *DocumentFileMutation) StoragePathCleared() bool {
	_, ok := m.clearedFields[documentfile.FieldStoragePath]
	return ok
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *DocumentFileMutation) ResetStoragePath() {
	m.storage_path = nil
	delete(m.clearedFields, documentfile.FieldStoragePath)
}

// SetStoragePathZpl sets the "storage_path_zpl" field.
func (m *DocumentFileMutation) SetStoragePathZpl(s string) {
	m.storage_path_zpl = &s
}

// StoragePathZpl returns the value of the "storage_path_zpl" field in the mutation.
func (m *DocumentFileMutation) StoragePathZpl() (r string, exists bool) {
	v := m.storage_path_zpl
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePathZpl returns the old "storage_path_zpl" field's value of the DocumentFile entity.
// If the DocumentFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentFileMutation) OldStoragePathZpl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePathZpl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePathZpl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePathZpl: %w", err)
	}
	return oldValue.StoragePathZpl, nil
}

// ClearStoragePathZpl clears the value of the "storage_path_zpl" field.
func (m *DocumentFileMutation) ClearStoragePathZpl() {
	m.storage_path_zpl = nil
	m.clearedFields[documentfile.FieldStoragePathZpl] = struct{}{}
}

// StoragePathZplCleared returns if the "storage_path_zpl" field was cleared in this mutation.
func (m *DocumentFileMutation) StoragePathZplCleared() bool {
	_, ok := m.clearedFields[documentfile.FieldStoragePathZpl]
	return ok
}

// ResetStoragePathZpl resets all changes to the "storage_path_zpl" field.
func (m *DocumentFileMutation) ResetStoragePathZpl() {
	m.storage_path_zpl = nil
	delete(m.clearedFields, documentfile.FieldStoragePathZpl)
}

// SetDocType sets the "doc_type" field.
func (m *DocumentFileMutation) SetDocType(dt documentfile.DocType) {
	m.doc_type = &dt
}

// DocType returns the value of the "doc_type" field in the mutation.
func (m *DocumentFileMutation) DocType() (r documentfile.DocType, exists bool) {
	v := m.doc_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDocType returns the old "doc_type" field's value of the DocumentFile entity.
// If the DocumentFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentFileMutation) OldDocType(ctx context.Context) (v documentfile.DocType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocType: %w", err)
	}
	return oldValue.DocType, nil
}

// ResetDocType resets all changes to the "doc_type" field.
func (m *DocumentFileMutation) ResetDocType() {
	m.doc_type = nil
}

// SetDataPdfBase64 sets the "data_pdf_base64" field.
func (m *DocumentFileMutation) SetDataPdfBase64(s string) {
	m.data_pdf_base64 = &s
}

// DataPdfBase64 returns the value of the "data_pdf_base64" field in the mutation.
func (m *DocumentFileMutation) DataPdfBase64() (r string, exists bool) {
	v := m.data_pdf_base64
	if v == nil {
		return
	}
	return *v, true
}

// OldDataPdfBase64 returns the old "data_pdf_base64" field's value of the DocumentFile entity.
// If the DocumentFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentFileMutation) OldDataPdfBase64(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataPdfBase64 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataPdfBase64 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataPdfBase64: %w", err)
	}
	return oldValue.DataPdfBase64, nil
}

// ClearDataPdfBase64 clears the value of the "data_pdf_base64" field.
func (m *DocumentFileMutation) ClearDataPdfBase64() {
	m.data_pdf_base64 = nil
	m.clearedFields[documentfile.FieldDataPdfBase64] = struct{}{}
}

// DataPdfBase64Cleared returns if the "data_pdf_base64" field was cleared in this mutation.
func (m *DocumentFileMutation) DataPdfBase64Cleared() bool {
	_, ok := m.clearedFields[documentfile.FieldDataPdfBase64]
	return ok
}

// ResetDataPdfBase64 resets all changes to the "data_pdf_base64" field.
func (m *DocumentFileMutation) ResetDataPdfBase64() {
	m.data_pdf_base64 = nil
	delete(m.clearedFields, documentfile.FieldDataPdfBase64)
}

// SetDataZplBase64 sets the "data_zpl_base64" field.
func (m *DocumentFileMutation) SetDataZplBase64(s string) {
	m.data_zpl_base64 = &s
}

// DataZplBase64 returns the value of the "data_zpl_base64" field in the mutation.
func (m *DocumentFileMutation) DataZplBase64() (r string, exists bool) {
	v := m.data_zpl_base64
	if v == nil {
		return
	}
	return *v, true
}

// OldDataZplBase64 returns the old "data_zpl_base64" field's value of the DocumentFile entity.
// If the DocumentFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentFileMutation) OldDataZplBase64(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDataZplBase64 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDataZplBase64 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDataZplBase64: %w", err)
	}
	return oldValue.DataZplBase64, nil
}

// ClearDataZplBase64 clears the value of the "data_zpl_base64" field.
func (m *DocumentFileMutation) ClearDataZplBase64() {
	m.data_zpl_base64 = nil
	m.clearedFields[documentfile.FieldDataZplBase64] = struct{}{}
}

// DataZplBase64Cleared returns if the "data_zpl_base64" field was cleared in this mutation.
func (m *DocumentFileMutation) DataZplBase64Cleared() bool {
	_, ok := m.clearedFields[documentfile.FieldDataZplBase64]
	return ok
}

// ResetDataZplBase64 resets all changes to the "data_zpl_base64" field.
func (m *DocumentFileMutation) ResetDataZplBase64() {
	m.data_zpl_base64 = nil
	delete(m.clearedFields, documentfile.FieldDataZplBase64)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *DocumentFileMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[documentfile.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *DocumentFileMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *DocumentFileMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *DocumentFileMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetColliID sets the "colli" edge to the Colli entity by id.
func (m *DocumentFileMutation) SetColliID(id pulid.ID) {
	m.colli = &id
}

// ClearColli clears the "colli" edge to the Colli entity.
func (m *DocumentFileMutation) ClearColli() {
	m.clearedcolli = true
}

// ColliCleared reports if the "colli" edge to the Colli entity was cleared.
func (m *DocumentFileMutation) ColliCleared() bool {
	return m.clearedcolli
}

// ColliID returns the "colli" edge ID in the mutation.
func (m *DocumentFileMutation) ColliID() (id pulid.ID, exists bool) {
	if m.colli != nil {
		return *m.colli, true
	}
	return
}

// ColliIDs returns the "colli" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ColliID instead. It exists only for internal usage by the builders.
func (m *DocumentFileMutation) ColliIDs() (ids []pulid.ID) {
	if id := m.colli; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetColli resets all changes to the "colli" edge.
func (m *DocumentFileMutation) ResetColli() {
	m.colli = nil
	m.clearedcolli = false
}

// SetShipmentParcelID sets the "shipment_parcel" edge to the ShipmentParcel entity by id.
func (m *DocumentFileMutation) SetShipmentParcelID(id pulid.ID) {
	m.shipment_parcel = &id
}

// ClearShipmentParcel clears the "shipment_parcel" edge to the ShipmentParcel entity.
func (m *DocumentFileMutation) ClearShipmentParcel() {
	m.clearedshipment_parcel = true
}

// ShipmentParcelCleared reports if the "shipment_parcel" edge to the ShipmentParcel entity was cleared.
func (m *DocumentFileMutation) ShipmentParcelCleared() bool {
	return m.clearedshipment_parcel
}

// ShipmentParcelID returns the "shipment_parcel" edge ID in the mutation.
func (m *DocumentFileMutation) ShipmentParcelID() (id pulid.ID, exists bool) {
	if m.shipment_parcel != nil {
		return *m.shipment_parcel, true
	}
	return
}

// ShipmentParcelIDs returns the "shipment_parcel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentParcelID instead. It exists only for internal usage by the builders.
func (m *DocumentFileMutation) ShipmentParcelIDs() (ids []pulid.ID) {
	if id := m.shipment_parcel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentParcel resets all changes to the "shipment_parcel" edge.
func (m *DocumentFileMutation) ResetShipmentParcel() {
	m.shipment_parcel = nil
	m.clearedshipment_parcel = false
}

// Where appends a list predicates to the DocumentFileMutation builder.
func (m *DocumentFileMutation) Where(ps ...predicate.DocumentFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentFile).
func (m *DocumentFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentFileMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant != nil {
		fields = append(fields, documentfile.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, documentfile.FieldCreatedAt)
	}
	if m.storage_type != nil {
		fields = append(fields, documentfile.FieldStorageType)
	}
	if m.storage_path != nil {
		fields = append(fields, documentfile.FieldStoragePath)
	}
	if m.storage_path_zpl != nil {
		fields = append(fields, documentfile.FieldStoragePathZpl)
	}
	if m.doc_type != nil {
		fields = append(fields, documentfile.FieldDocType)
	}
	if m.data_pdf_base64 != nil {
		fields = append(fields, documentfile.FieldDataPdfBase64)
	}
	if m.data_zpl_base64 != nil {
		fields = append(fields, documentfile.FieldDataZplBase64)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documentfile.FieldTenantID:
		return m.TenantID()
	case documentfile.FieldCreatedAt:
		return m.CreatedAt()
	case documentfile.FieldStorageType:
		return m.StorageType()
	case documentfile.FieldStoragePath:
		return m.StoragePath()
	case documentfile.FieldStoragePathZpl:
		return m.StoragePathZpl()
	case documentfile.FieldDocType:
		return m.DocType()
	case documentfile.FieldDataPdfBase64:
		return m.DataPdfBase64()
	case documentfile.FieldDataZplBase64:
		return m.DataZplBase64()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documentfile.FieldTenantID:
		return m.OldTenantID(ctx)
	case documentfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case documentfile.FieldStorageType:
		return m.OldStorageType(ctx)
	case documentfile.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case documentfile.FieldStoragePathZpl:
		return m.OldStoragePathZpl(ctx)
	case documentfile.FieldDocType:
		return m.OldDocType(ctx)
	case documentfile.FieldDataPdfBase64:
		return m.OldDataPdfBase64(ctx)
	case documentfile.FieldDataZplBase64:
		return m.OldDataZplBase64(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documentfile.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case documentfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case documentfile.FieldStorageType:
		v, ok := value.(documentfile.StorageType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageType(v)
		return nil
	case documentfile.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case documentfile.FieldStoragePathZpl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePathZpl(v)
		return nil
	case documentfile.FieldDocType:
		v, ok := value.(documentfile.DocType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocType(v)
		return nil
	case documentfile.FieldDataPdfBase64:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataPdfBase64(v)
		return nil
	case documentfile.FieldDataZplBase64:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDataZplBase64(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentFileMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentFileMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DocumentFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(documentfile.FieldStoragePath) {
		fields = append(fields, documentfile.FieldStoragePath)
	}
	if m.FieldCleared(documentfile.FieldStoragePathZpl) {
		fields = append(fields, documentfile.FieldStoragePathZpl)
	}
	if m.FieldCleared(documentfile.FieldDataPdfBase64) {
		fields = append(fields, documentfile.FieldDataPdfBase64)
	}
	if m.FieldCleared(documentfile.FieldDataZplBase64) {
		fields = append(fields, documentfile.FieldDataZplBase64)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentFileMutation) ClearField(name string) error {
	switch name {
	case documentfile.FieldStoragePath:
		m.ClearStoragePath()
		return nil
	case documentfile.FieldStoragePathZpl:
		m.ClearStoragePathZpl()
		return nil
	case documentfile.FieldDataPdfBase64:
		m.ClearDataPdfBase64()
		return nil
	case documentfile.FieldDataZplBase64:
		m.ClearDataZplBase64()
		return nil
	}
	return fmt.Errorf("unknown DocumentFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentFileMutation) ResetField(name string) error {
	switch name {
	case documentfile.FieldTenantID:
		m.ResetTenantID()
		return nil
	case documentfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case documentfile.FieldStorageType:
		m.ResetStorageType()
		return nil
	case documentfile.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case documentfile.FieldStoragePathZpl:
		m.ResetStoragePathZpl()
		return nil
	case documentfile.FieldDocType:
		m.ResetDocType()
		return nil
	case documentfile.FieldDataPdfBase64:
		m.ResetDataPdfBase64()
		return nil
	case documentfile.FieldDataZplBase64:
		m.ResetDataZplBase64()
		return nil
	}
	return fmt.Errorf("unknown DocumentFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, documentfile.EdgeTenant)
	}
	if m.colli != nil {
		edges = append(edges, documentfile.EdgeColli)
	}
	if m.shipment_parcel != nil {
		edges = append(edges, documentfile.EdgeShipmentParcel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case documentfile.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case documentfile.EdgeColli:
		if id := m.colli; id != nil {
			return []ent.Value{*id}
		}
	case documentfile.EdgeShipmentParcel:
		if id := m.shipment_parcel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, documentfile.EdgeTenant)
	}
	if m.clearedcolli {
		edges = append(edges, documentfile.EdgeColli)
	}
	if m.clearedshipment_parcel {
		edges = append(edges, documentfile.EdgeShipmentParcel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentFileMutation) EdgeCleared(name string) bool {
	switch name {
	case documentfile.EdgeTenant:
		return m.clearedtenant
	case documentfile.EdgeColli:
		return m.clearedcolli
	case documentfile.EdgeShipmentParcel:
		return m.clearedshipment_parcel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentFileMutation) ClearEdge(name string) error {
	switch name {
	case documentfile.EdgeTenant:
		m.ClearTenant()
		return nil
	case documentfile.EdgeColli:
		m.ClearColli()
		return nil
	case documentfile.EdgeShipmentParcel:
		m.ClearShipmentParcel()
		return nil
	}
	return fmt.Errorf("unknown DocumentFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentFileMutation) ResetEdge(name string) error {
	switch name {
	case documentfile.EdgeTenant:
		m.ResetTenant()
		return nil
	case documentfile.EdgeColli:
		m.ResetColli()
		return nil
	case documentfile.EdgeShipmentParcel:
		m.ResetShipmentParcel()
		return nil
	}
	return fmt.Errorf("unknown DocumentFile edge %s", name)
}

// EmailTemplateMutation represents an operation that mutates the EmailTemplate nodes in the graph.
type EmailTemplateMutation struct {
	config
	op                                            Op
	typ                                           string
	id                                            *pulid.ID
	name                                          *string
	subject                                       *string
	html_template                                 *string
	merge_type                                    *emailtemplate.MergeType
	created_at                                    *time.Time
	updated_at                                    *time.Time
	clearedFields                                 map[string]struct{}
	tenant                                        *pulid.ID
	clearedtenant                                 bool
	return_portal_confirmation_label              map[pulid.ID]struct{}
	removedreturn_portal_confirmation_label       map[pulid.ID]struct{}
	clearedreturn_portal_confirmation_label       bool
	return_portal_confirmation_qr_code            map[pulid.ID]struct{}
	removedreturn_portal_confirmation_qr_code     map[pulid.ID]struct{}
	clearedreturn_portal_confirmation_qr_code     bool
	return_portal_received                        map[pulid.ID]struct{}
	removedreturn_portal_received                 map[pulid.ID]struct{}
	clearedreturn_portal_received                 bool
	return_portal_accepted                        map[pulid.ID]struct{}
	removedreturn_portal_accepted                 map[pulid.ID]struct{}
	clearedreturn_portal_accepted                 bool
	delivery_option_click_collect_at_store        map[pulid.ID]struct{}
	removeddelivery_option_click_collect_at_store map[pulid.ID]struct{}
	cleareddelivery_option_click_collect_at_store bool
	notifications                                 map[pulid.ID]struct{}
	removednotifications                          map[pulid.ID]struct{}
	clearednotifications                          bool
	done                                          bool
	oldValue                                      func(context.Context) (*EmailTemplate, error)
	predicates                                    []predicate.EmailTemplate
}

var _ ent.Mutation = (*EmailTemplateMutation)(nil)

// emailtemplateOption allows management of the mutation configuration using functional options.
type emailtemplateOption func(*EmailTemplateMutation)

// newEmailTemplateMutation creates new mutation for the EmailTemplate entity.
func newEmailTemplateMutation(c config, op Op, opts ...emailtemplateOption) *EmailTemplateMutation {
	m := &EmailTemplateMutation{
		config:        c,
		op:            op,
		typ:           TypeEmailTemplate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withEmailTemplateID sets the ID field of the mutation.
func withEmailTemplateID(id pulid.ID) emailtemplateOption {
	return func(m *EmailTemplateMutation) {
		var (
			err   error
			once  sync.Once
			value *EmailTemplate
		)
		m.oldValue = func(ctx context.Context) (*EmailTemplate, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().EmailTemplate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withEmailTemplate sets the old EmailTemplate of the mutation.
func withEmailTemplate(node *EmailTemplate) emailtemplateOption {
	return func(m *EmailTemplateMutation) {
		m.oldValue = func(context.Context) (*EmailTemplate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m EmailTemplateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m EmailTemplateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of EmailTemplate entities.
func (m *EmailTemplateMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *EmailTemplateMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *EmailTemplateMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().EmailTemplate.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *EmailTemplateMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *EmailTemplateMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *EmailTemplateMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *EmailTemplateMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *EmailTemplateMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *EmailTemplateMutation) ResetName() {
	m.name = nil
}

// SetSubject sets the "subject" field.
func (m *EmailTemplateMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *EmailTemplateMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *EmailTemplateMutation) ResetSubject() {
	m.subject = nil
}

// SetHTMLTemplate sets the "html_template" field.
func (m *EmailTemplateMutation) SetHTMLTemplate(s string) {
	m.html_template = &s
}

// HTMLTemplate returns the value of the "html_template" field in the mutation.
func (m *EmailTemplateMutation) HTMLTemplate() (r string, exists bool) {
	v := m.html_template
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLTemplate returns the old "html_template" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldHTMLTemplate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLTemplate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLTemplate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLTemplate: %w", err)
	}
	return oldValue.HTMLTemplate, nil
}

// ResetHTMLTemplate resets all changes to the "html_template" field.
func (m *EmailTemplateMutation) ResetHTMLTemplate() {
	m.html_template = nil
}

// SetMergeType sets the "merge_type" field.
func (m *EmailTemplateMutation) SetMergeType(et emailtemplate.MergeType) {
	m.merge_type = &et
}

// MergeType returns the value of the "merge_type" field in the mutation.
func (m *EmailTemplateMutation) MergeType() (r emailtemplate.MergeType, exists bool) {
	v := m.merge_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMergeType returns the old "merge_type" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldMergeType(ctx context.Context) (v emailtemplate.MergeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMergeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMergeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMergeType: %w", err)
	}
	return oldValue.MergeType, nil
}

// ResetMergeType resets all changes to the "merge_type" field.
func (m *EmailTemplateMutation) ResetMergeType() {
	m.merge_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *EmailTemplateMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *EmailTemplateMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *EmailTemplateMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[emailtemplate.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *EmailTemplateMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[emailtemplate.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *EmailTemplateMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, emailtemplate.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *EmailTemplateMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *EmailTemplateMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the EmailTemplate entity.
// If the EmailTemplate object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *EmailTemplateMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *EmailTemplateMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *EmailTemplateMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[emailtemplate.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *EmailTemplateMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *EmailTemplateMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *EmailTemplateMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddReturnPortalConfirmationLabelIDs adds the "return_portal_confirmation_label" edge to the ReturnPortal entity by ids.
func (m *EmailTemplateMutation) AddReturnPortalConfirmationLabelIDs(ids ...pulid.ID) {
	if m.return_portal_confirmation_label == nil {
		m.return_portal_confirmation_label = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_portal_confirmation_label[ids[i]] = struct{}{}
	}
}

// ClearReturnPortalConfirmationLabel clears the "return_portal_confirmation_label" edge to the ReturnPortal entity.
func (m *EmailTemplateMutation) ClearReturnPortalConfirmationLabel() {
	m.clearedreturn_portal_confirmation_label = true
}

// ReturnPortalConfirmationLabelCleared reports if the "return_portal_confirmation_label" edge to the ReturnPortal entity was cleared.
func (m *EmailTemplateMutation) ReturnPortalConfirmationLabelCleared() bool {
	return m.clearedreturn_portal_confirmation_label
}

// RemoveReturnPortalConfirmationLabelIDs removes the "return_portal_confirmation_label" edge to the ReturnPortal entity by IDs.
func (m *EmailTemplateMutation) RemoveReturnPortalConfirmationLabelIDs(ids ...pulid.ID) {
	if m.removedreturn_portal_confirmation_label == nil {
		m.removedreturn_portal_confirmation_label = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_portal_confirmation_label, ids[i])
		m.removedreturn_portal_confirmation_label[ids[i]] = struct{}{}
	}
}

// RemovedReturnPortalConfirmationLabel returns the removed IDs of the "return_portal_confirmation_label" edge to the ReturnPortal entity.
func (m *EmailTemplateMutation) RemovedReturnPortalConfirmationLabelIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_portal_confirmation_label {
		ids = append(ids, id)
	}
	return
}

// ReturnPortalConfirmationLabelIDs returns the "return_portal_confirmation_label" edge IDs in the mutation.
func (m *EmailTemplateMutation) ReturnPortalConfirmationLabelIDs() (ids []pulid.ID) {
	for id := range m.return_portal_confirmation_label {
		ids = append(ids, id)
	}
	return
}

// ResetReturnPortalConfirmationLabel resets all changes to the "return_portal_confirmation_label" edge.
func (m *EmailTemplateMutation) ResetReturnPortalConfirmationLabel() {
	m.return_portal_confirmation_label = nil
	m.clearedreturn_portal_confirmation_label = false
	m.removedreturn_portal_confirmation_label = nil
}

// AddReturnPortalConfirmationQrCodeIDs adds the "return_portal_confirmation_qr_code" edge to the ReturnPortal entity by ids.
func (m *EmailTemplateMutation) AddReturnPortalConfirmationQrCodeIDs(ids ...pulid.ID) {
	if m.return_portal_confirmation_qr_code == nil {
		m.return_portal_confirmation_qr_code = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_portal_confirmation_qr_code[ids[i]] = struct{}{}
	}
}

// ClearReturnPortalConfirmationQrCode clears the "return_portal_confirmation_qr_code" edge to the ReturnPortal entity.
func (m *EmailTemplateMutation) ClearReturnPortalConfirmationQrCode() {
	m.clearedreturn_portal_confirmation_qr_code = true
}

// ReturnPortalConfirmationQrCodeCleared reports if the "return_portal_confirmation_qr_code" edge to the ReturnPortal entity was cleared.
func (m *EmailTemplateMutation) ReturnPortalConfirmationQrCodeCleared() bool {
	return m.clearedreturn_portal_confirmation_qr_code
}

// RemoveReturnPortalConfirmationQrCodeIDs removes the "return_portal_confirmation_qr_code" edge to the ReturnPortal entity by IDs.
func (m *EmailTemplateMutation) RemoveReturnPortalConfirmationQrCodeIDs(ids ...pulid.ID) {
	if m.removedreturn_portal_confirmation_qr_code == nil {
		m.removedreturn_portal_confirmation_qr_code = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_portal_confirmation_qr_code, ids[i])
		m.removedreturn_portal_confirmation_qr_code[ids[i]] = struct{}{}
	}
}

// RemovedReturnPortalConfirmationQrCode returns the removed IDs of the "return_portal_confirmation_qr_code" edge to the ReturnPortal entity.
func (m *EmailTemplateMutation) RemovedReturnPortalConfirmationQrCodeIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_portal_confirmation_qr_code {
		ids = append(ids, id)
	}
	return
}

// ReturnPortalConfirmationQrCodeIDs returns the "return_portal_confirmation_qr_code" edge IDs in the mutation.
func (m *EmailTemplateMutation) ReturnPortalConfirmationQrCodeIDs() (ids []pulid.ID) {
	for id := range m.return_portal_confirmation_qr_code {
		ids = append(ids, id)
	}
	return
}

// ResetReturnPortalConfirmationQrCode resets all changes to the "return_portal_confirmation_qr_code" edge.
func (m *EmailTemplateMutation) ResetReturnPortalConfirmationQrCode() {
	m.return_portal_confirmation_qr_code = nil
	m.clearedreturn_portal_confirmation_qr_code = false
	m.removedreturn_portal_confirmation_qr_code = nil
}

// AddReturnPortalReceivedIDs adds the "return_portal_received" edge to the ReturnPortal entity by ids.
func (m *EmailTemplateMutation) AddReturnPortalReceivedIDs(ids ...pulid.ID) {
	if m.return_portal_received == nil {
		m.return_portal_received = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_portal_received[ids[i]] = struct{}{}
	}
}

// ClearReturnPortalReceived clears the "return_portal_received" edge to the ReturnPortal entity.
func (m *EmailTemplateMutation) ClearReturnPortalReceived() {
	m.clearedreturn_portal_received = true
}

// ReturnPortalReceivedCleared reports if the "return_portal_received" edge to the ReturnPortal entity was cleared.
func (m *EmailTemplateMutation) ReturnPortalReceivedCleared() bool {
	return m.clearedreturn_portal_received
}

// RemoveReturnPortalReceivedIDs removes the "return_portal_received" edge to the ReturnPortal entity by IDs.
func (m *EmailTemplateMutation) RemoveReturnPortalReceivedIDs(ids ...pulid.ID) {
	if m.removedreturn_portal_received == nil {
		m.removedreturn_portal_received = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_portal_received, ids[i])
		m.removedreturn_portal_received[ids[i]] = struct{}{}
	}
}

// RemovedReturnPortalReceived returns the removed IDs of the "return_portal_received" edge to the ReturnPortal entity.
func (m *EmailTemplateMutation) RemovedReturnPortalReceivedIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_portal_received {
		ids = append(ids, id)
	}
	return
}

// ReturnPortalReceivedIDs returns the "return_portal_received" edge IDs in the mutation.
func (m *EmailTemplateMutation) ReturnPortalReceivedIDs() (ids []pulid.ID) {
	for id := range m.return_portal_received {
		ids = append(ids, id)
	}
	return
}

// ResetReturnPortalReceived resets all changes to the "return_portal_received" edge.
func (m *EmailTemplateMutation) ResetReturnPortalReceived() {
	m.return_portal_received = nil
	m.clearedreturn_portal_received = false
	m.removedreturn_portal_received = nil
}

// AddReturnPortalAcceptedIDs adds the "return_portal_accepted" edge to the ReturnPortal entity by ids.
func (m *EmailTemplateMutation) AddReturnPortalAcceptedIDs(ids ...pulid.ID) {
	if m.return_portal_accepted == nil {
		m.return_portal_accepted = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_portal_accepted[ids[i]] = struct{}{}
	}
}

// ClearReturnPortalAccepted clears the "return_portal_accepted" edge to the ReturnPortal entity.
func (m *EmailTemplateMutation) ClearReturnPortalAccepted() {
	m.clearedreturn_portal_accepted = true
}

// ReturnPortalAcceptedCleared reports if the "return_portal_accepted" edge to the ReturnPortal entity was cleared.
func (m *EmailTemplateMutation) ReturnPortalAcceptedCleared() bool {
	return m.clearedreturn_portal_accepted
}

// RemoveReturnPortalAcceptedIDs removes the "return_portal_accepted" edge to the ReturnPortal entity by IDs.
func (m *EmailTemplateMutation) RemoveReturnPortalAcceptedIDs(ids ...pulid.ID) {
	if m.removedreturn_portal_accepted == nil {
		m.removedreturn_portal_accepted = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_portal_accepted, ids[i])
		m.removedreturn_portal_accepted[ids[i]] = struct{}{}
	}
}

// RemovedReturnPortalAccepted returns the removed IDs of the "return_portal_accepted" edge to the ReturnPortal entity.
func (m *EmailTemplateMutation) RemovedReturnPortalAcceptedIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_portal_accepted {
		ids = append(ids, id)
	}
	return
}

// ReturnPortalAcceptedIDs returns the "return_portal_accepted" edge IDs in the mutation.
func (m *EmailTemplateMutation) ReturnPortalAcceptedIDs() (ids []pulid.ID) {
	for id := range m.return_portal_accepted {
		ids = append(ids, id)
	}
	return
}

// ResetReturnPortalAccepted resets all changes to the "return_portal_accepted" edge.
func (m *EmailTemplateMutation) ResetReturnPortalAccepted() {
	m.return_portal_accepted = nil
	m.clearedreturn_portal_accepted = false
	m.removedreturn_portal_accepted = nil
}

// AddDeliveryOptionClickCollectAtStoreIDs adds the "delivery_option_click_collect_at_store" edge to the DeliveryOption entity by ids.
func (m *EmailTemplateMutation) AddDeliveryOptionClickCollectAtStoreIDs(ids ...pulid.ID) {
	if m.delivery_option_click_collect_at_store == nil {
		m.delivery_option_click_collect_at_store = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_click_collect_at_store[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionClickCollectAtStore clears the "delivery_option_click_collect_at_store" edge to the DeliveryOption entity.
func (m *EmailTemplateMutation) ClearDeliveryOptionClickCollectAtStore() {
	m.cleareddelivery_option_click_collect_at_store = true
}

// DeliveryOptionClickCollectAtStoreCleared reports if the "delivery_option_click_collect_at_store" edge to the DeliveryOption entity was cleared.
func (m *EmailTemplateMutation) DeliveryOptionClickCollectAtStoreCleared() bool {
	return m.cleareddelivery_option_click_collect_at_store
}

// RemoveDeliveryOptionClickCollectAtStoreIDs removes the "delivery_option_click_collect_at_store" edge to the DeliveryOption entity by IDs.
func (m *EmailTemplateMutation) RemoveDeliveryOptionClickCollectAtStoreIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_click_collect_at_store == nil {
		m.removeddelivery_option_click_collect_at_store = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_click_collect_at_store, ids[i])
		m.removeddelivery_option_click_collect_at_store[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionClickCollectAtStore returns the removed IDs of the "delivery_option_click_collect_at_store" edge to the DeliveryOption entity.
func (m *EmailTemplateMutation) RemovedDeliveryOptionClickCollectAtStoreIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_click_collect_at_store {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionClickCollectAtStoreIDs returns the "delivery_option_click_collect_at_store" edge IDs in the mutation.
func (m *EmailTemplateMutation) DeliveryOptionClickCollectAtStoreIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_click_collect_at_store {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionClickCollectAtStore resets all changes to the "delivery_option_click_collect_at_store" edge.
func (m *EmailTemplateMutation) ResetDeliveryOptionClickCollectAtStore() {
	m.delivery_option_click_collect_at_store = nil
	m.cleareddelivery_option_click_collect_at_store = false
	m.removeddelivery_option_click_collect_at_store = nil
}

// AddNotificationIDs adds the "notifications" edge to the Notification entity by ids.
func (m *EmailTemplateMutation) AddNotificationIDs(ids ...pulid.ID) {
	if m.notifications == nil {
		m.notifications = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.notifications[ids[i]] = struct{}{}
	}
}

// ClearNotifications clears the "notifications" edge to the Notification entity.
func (m *EmailTemplateMutation) ClearNotifications() {
	m.clearednotifications = true
}

// NotificationsCleared reports if the "notifications" edge to the Notification entity was cleared.
func (m *EmailTemplateMutation) NotificationsCleared() bool {
	return m.clearednotifications
}

// RemoveNotificationIDs removes the "notifications" edge to the Notification entity by IDs.
func (m *EmailTemplateMutation) RemoveNotificationIDs(ids ...pulid.ID) {
	if m.removednotifications == nil {
		m.removednotifications = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.notifications, ids[i])
		m.removednotifications[ids[i]] = struct{}{}
	}
}

// RemovedNotifications returns the removed IDs of the "notifications" edge to the Notification entity.
func (m *EmailTemplateMutation) RemovedNotificationsIDs() (ids []pulid.ID) {
	for id := range m.removednotifications {
		ids = append(ids, id)
	}
	return
}

// NotificationsIDs returns the "notifications" edge IDs in the mutation.
func (m *EmailTemplateMutation) NotificationsIDs() (ids []pulid.ID) {
	for id := range m.notifications {
		ids = append(ids, id)
	}
	return
}

// ResetNotifications resets all changes to the "notifications" edge.
func (m *EmailTemplateMutation) ResetNotifications() {
	m.notifications = nil
	m.clearednotifications = false
	m.removednotifications = nil
}

// Where appends a list predicates to the EmailTemplateMutation builder.
func (m *EmailTemplateMutation) Where(ps ...predicate.EmailTemplate) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the EmailTemplateMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *EmailTemplateMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.EmailTemplate, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *EmailTemplateMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *EmailTemplateMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (EmailTemplate).
func (m *EmailTemplateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *EmailTemplateMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, emailtemplate.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, emailtemplate.FieldName)
	}
	if m.subject != nil {
		fields = append(fields, emailtemplate.FieldSubject)
	}
	if m.html_template != nil {
		fields = append(fields, emailtemplate.FieldHTMLTemplate)
	}
	if m.merge_type != nil {
		fields = append(fields, emailtemplate.FieldMergeType)
	}
	if m.created_at != nil {
		fields = append(fields, emailtemplate.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, emailtemplate.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *EmailTemplateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case emailtemplate.FieldTenantID:
		return m.TenantID()
	case emailtemplate.FieldName:
		return m.Name()
	case emailtemplate.FieldSubject:
		return m.Subject()
	case emailtemplate.FieldHTMLTemplate:
		return m.HTMLTemplate()
	case emailtemplate.FieldMergeType:
		return m.MergeType()
	case emailtemplate.FieldCreatedAt:
		return m.CreatedAt()
	case emailtemplate.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *EmailTemplateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case emailtemplate.FieldTenantID:
		return m.OldTenantID(ctx)
	case emailtemplate.FieldName:
		return m.OldName(ctx)
	case emailtemplate.FieldSubject:
		return m.OldSubject(ctx)
	case emailtemplate.FieldHTMLTemplate:
		return m.OldHTMLTemplate(ctx)
	case emailtemplate.FieldMergeType:
		return m.OldMergeType(ctx)
	case emailtemplate.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case emailtemplate.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown EmailTemplate field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailTemplateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case emailtemplate.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case emailtemplate.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case emailtemplate.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case emailtemplate.FieldHTMLTemplate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLTemplate(v)
		return nil
	case emailtemplate.FieldMergeType:
		v, ok := value.(emailtemplate.MergeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMergeType(v)
		return nil
	case emailtemplate.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case emailtemplate.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *EmailTemplateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *EmailTemplateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *EmailTemplateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown EmailTemplate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *EmailTemplateMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(emailtemplate.FieldCreatedAt) {
		fields = append(fields, emailtemplate.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *EmailTemplateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *EmailTemplateMutation) ClearField(name string) error {
	switch name {
	case emailtemplate.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *EmailTemplateMutation) ResetField(name string) error {
	switch name {
	case emailtemplate.FieldTenantID:
		m.ResetTenantID()
		return nil
	case emailtemplate.FieldName:
		m.ResetName()
		return nil
	case emailtemplate.FieldSubject:
		m.ResetSubject()
		return nil
	case emailtemplate.FieldHTMLTemplate:
		m.ResetHTMLTemplate()
		return nil
	case emailtemplate.FieldMergeType:
		m.ResetMergeType()
		return nil
	case emailtemplate.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case emailtemplate.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *EmailTemplateMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.tenant != nil {
		edges = append(edges, emailtemplate.EdgeTenant)
	}
	if m.return_portal_confirmation_label != nil {
		edges = append(edges, emailtemplate.EdgeReturnPortalConfirmationLabel)
	}
	if m.return_portal_confirmation_qr_code != nil {
		edges = append(edges, emailtemplate.EdgeReturnPortalConfirmationQrCode)
	}
	if m.return_portal_received != nil {
		edges = append(edges, emailtemplate.EdgeReturnPortalReceived)
	}
	if m.return_portal_accepted != nil {
		edges = append(edges, emailtemplate.EdgeReturnPortalAccepted)
	}
	if m.delivery_option_click_collect_at_store != nil {
		edges = append(edges, emailtemplate.EdgeDeliveryOptionClickCollectAtStore)
	}
	if m.notifications != nil {
		edges = append(edges, emailtemplate.EdgeNotifications)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *EmailTemplateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case emailtemplate.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case emailtemplate.EdgeReturnPortalConfirmationLabel:
		ids := make([]ent.Value, 0, len(m.return_portal_confirmation_label))
		for id := range m.return_portal_confirmation_label {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeReturnPortalConfirmationQrCode:
		ids := make([]ent.Value, 0, len(m.return_portal_confirmation_qr_code))
		for id := range m.return_portal_confirmation_qr_code {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeReturnPortalReceived:
		ids := make([]ent.Value, 0, len(m.return_portal_received))
		for id := range m.return_portal_received {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeReturnPortalAccepted:
		ids := make([]ent.Value, 0, len(m.return_portal_accepted))
		for id := range m.return_portal_accepted {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeDeliveryOptionClickCollectAtStore:
		ids := make([]ent.Value, 0, len(m.delivery_option_click_collect_at_store))
		for id := range m.delivery_option_click_collect_at_store {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.notifications))
		for id := range m.notifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *EmailTemplateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedreturn_portal_confirmation_label != nil {
		edges = append(edges, emailtemplate.EdgeReturnPortalConfirmationLabel)
	}
	if m.removedreturn_portal_confirmation_qr_code != nil {
		edges = append(edges, emailtemplate.EdgeReturnPortalConfirmationQrCode)
	}
	if m.removedreturn_portal_received != nil {
		edges = append(edges, emailtemplate.EdgeReturnPortalReceived)
	}
	if m.removedreturn_portal_accepted != nil {
		edges = append(edges, emailtemplate.EdgeReturnPortalAccepted)
	}
	if m.removeddelivery_option_click_collect_at_store != nil {
		edges = append(edges, emailtemplate.EdgeDeliveryOptionClickCollectAtStore)
	}
	if m.removednotifications != nil {
		edges = append(edges, emailtemplate.EdgeNotifications)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *EmailTemplateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case emailtemplate.EdgeReturnPortalConfirmationLabel:
		ids := make([]ent.Value, 0, len(m.removedreturn_portal_confirmation_label))
		for id := range m.removedreturn_portal_confirmation_label {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeReturnPortalConfirmationQrCode:
		ids := make([]ent.Value, 0, len(m.removedreturn_portal_confirmation_qr_code))
		for id := range m.removedreturn_portal_confirmation_qr_code {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeReturnPortalReceived:
		ids := make([]ent.Value, 0, len(m.removedreturn_portal_received))
		for id := range m.removedreturn_portal_received {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeReturnPortalAccepted:
		ids := make([]ent.Value, 0, len(m.removedreturn_portal_accepted))
		for id := range m.removedreturn_portal_accepted {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeDeliveryOptionClickCollectAtStore:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_click_collect_at_store))
		for id := range m.removeddelivery_option_click_collect_at_store {
			ids = append(ids, id)
		}
		return ids
	case emailtemplate.EdgeNotifications:
		ids := make([]ent.Value, 0, len(m.removednotifications))
		for id := range m.removednotifications {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *EmailTemplateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedtenant {
		edges = append(edges, emailtemplate.EdgeTenant)
	}
	if m.clearedreturn_portal_confirmation_label {
		edges = append(edges, emailtemplate.EdgeReturnPortalConfirmationLabel)
	}
	if m.clearedreturn_portal_confirmation_qr_code {
		edges = append(edges, emailtemplate.EdgeReturnPortalConfirmationQrCode)
	}
	if m.clearedreturn_portal_received {
		edges = append(edges, emailtemplate.EdgeReturnPortalReceived)
	}
	if m.clearedreturn_portal_accepted {
		edges = append(edges, emailtemplate.EdgeReturnPortalAccepted)
	}
	if m.cleareddelivery_option_click_collect_at_store {
		edges = append(edges, emailtemplate.EdgeDeliveryOptionClickCollectAtStore)
	}
	if m.clearednotifications {
		edges = append(edges, emailtemplate.EdgeNotifications)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *EmailTemplateMutation) EdgeCleared(name string) bool {
	switch name {
	case emailtemplate.EdgeTenant:
		return m.clearedtenant
	case emailtemplate.EdgeReturnPortalConfirmationLabel:
		return m.clearedreturn_portal_confirmation_label
	case emailtemplate.EdgeReturnPortalConfirmationQrCode:
		return m.clearedreturn_portal_confirmation_qr_code
	case emailtemplate.EdgeReturnPortalReceived:
		return m.clearedreturn_portal_received
	case emailtemplate.EdgeReturnPortalAccepted:
		return m.clearedreturn_portal_accepted
	case emailtemplate.EdgeDeliveryOptionClickCollectAtStore:
		return m.cleareddelivery_option_click_collect_at_store
	case emailtemplate.EdgeNotifications:
		return m.clearednotifications
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *EmailTemplateMutation) ClearEdge(name string) error {
	switch name {
	case emailtemplate.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *EmailTemplateMutation) ResetEdge(name string) error {
	switch name {
	case emailtemplate.EdgeTenant:
		m.ResetTenant()
		return nil
	case emailtemplate.EdgeReturnPortalConfirmationLabel:
		m.ResetReturnPortalConfirmationLabel()
		return nil
	case emailtemplate.EdgeReturnPortalConfirmationQrCode:
		m.ResetReturnPortalConfirmationQrCode()
		return nil
	case emailtemplate.EdgeReturnPortalReceived:
		m.ResetReturnPortalReceived()
		return nil
	case emailtemplate.EdgeReturnPortalAccepted:
		m.ResetReturnPortalAccepted()
		return nil
	case emailtemplate.EdgeDeliveryOptionClickCollectAtStore:
		m.ResetDeliveryOptionClickCollectAtStore()
		return nil
	case emailtemplate.EdgeNotifications:
		m.ResetNotifications()
		return nil
	}
	return fmt.Errorf("unknown EmailTemplate edge %s", name)
}

// HypothesisTestMutation represents an operation that mutates the HypothesisTest nodes in the graph.
type HypothesisTestMutation struct {
	config
	op                                     Op
	typ                                    string
	id                                     *pulid.ID
	name                                   *string
	active                                 *bool
	clearedFields                          map[string]struct{}
	tenant                                 *pulid.ID
	clearedtenant                          bool
	hypothesis_test_delivery_option        *pulid.ID
	clearedhypothesis_test_delivery_option bool
	connection                             *pulid.ID
	clearedconnection                      bool
	done                                   bool
	oldValue                               func(context.Context) (*HypothesisTest, error)
	predicates                             []predicate.HypothesisTest
}

var _ ent.Mutation = (*HypothesisTestMutation)(nil)

// hypothesistestOption allows management of the mutation configuration using functional options.
type hypothesistestOption func(*HypothesisTestMutation)

// newHypothesisTestMutation creates new mutation for the HypothesisTest entity.
func newHypothesisTestMutation(c config, op Op, opts ...hypothesistestOption) *HypothesisTestMutation {
	m := &HypothesisTestMutation{
		config:        c,
		op:            op,
		typ:           TypeHypothesisTest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHypothesisTestID sets the ID field of the mutation.
func withHypothesisTestID(id pulid.ID) hypothesistestOption {
	return func(m *HypothesisTestMutation) {
		var (
			err   error
			once  sync.Once
			value *HypothesisTest
		)
		m.oldValue = func(ctx context.Context) (*HypothesisTest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HypothesisTest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHypothesisTest sets the old HypothesisTest of the mutation.
func withHypothesisTest(node *HypothesisTest) hypothesistestOption {
	return func(m *HypothesisTestMutation) {
		m.oldValue = func(context.Context) (*HypothesisTest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HypothesisTestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HypothesisTestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HypothesisTest entities.
func (m *HypothesisTestMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HypothesisTestMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HypothesisTestMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HypothesisTest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *HypothesisTestMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *HypothesisTestMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the HypothesisTest entity.
// If the HypothesisTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *HypothesisTestMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *HypothesisTestMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *HypothesisTestMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the HypothesisTest entity.
// If the HypothesisTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *HypothesisTestMutation) ResetName() {
	m.name = nil
}

// SetActive sets the "active" field.
func (m *HypothesisTestMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *HypothesisTestMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the HypothesisTest entity.
// If the HypothesisTest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *HypothesisTestMutation) ResetActive() {
	m.active = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *HypothesisTestMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[hypothesistest.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *HypothesisTestMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *HypothesisTestMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetHypothesisTestDeliveryOptionID sets the "hypothesis_test_delivery_option" edge to the HypothesisTestDeliveryOption entity by id.
func (m *HypothesisTestMutation) SetHypothesisTestDeliveryOptionID(id pulid.ID) {
	m.hypothesis_test_delivery_option = &id
}

// ClearHypothesisTestDeliveryOption clears the "hypothesis_test_delivery_option" edge to the HypothesisTestDeliveryOption entity.
func (m *HypothesisTestMutation) ClearHypothesisTestDeliveryOption() {
	m.clearedhypothesis_test_delivery_option = true
}

// HypothesisTestDeliveryOptionCleared reports if the "hypothesis_test_delivery_option" edge to the HypothesisTestDeliveryOption entity was cleared.
func (m *HypothesisTestMutation) HypothesisTestDeliveryOptionCleared() bool {
	return m.clearedhypothesis_test_delivery_option
}

// HypothesisTestDeliveryOptionID returns the "hypothesis_test_delivery_option" edge ID in the mutation.
func (m *HypothesisTestMutation) HypothesisTestDeliveryOptionID() (id pulid.ID, exists bool) {
	if m.hypothesis_test_delivery_option != nil {
		return *m.hypothesis_test_delivery_option, true
	}
	return
}

// HypothesisTestDeliveryOptionIDs returns the "hypothesis_test_delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HypothesisTestDeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestMutation) HypothesisTestDeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.hypothesis_test_delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHypothesisTestDeliveryOption resets all changes to the "hypothesis_test_delivery_option" edge.
func (m *HypothesisTestMutation) ResetHypothesisTestDeliveryOption() {
	m.hypothesis_test_delivery_option = nil
	m.clearedhypothesis_test_delivery_option = false
}

// SetConnectionID sets the "connection" edge to the Connection entity by id.
func (m *HypothesisTestMutation) SetConnectionID(id pulid.ID) {
	m.connection = &id
}

// ClearConnection clears the "connection" edge to the Connection entity.
func (m *HypothesisTestMutation) ClearConnection() {
	m.clearedconnection = true
}

// ConnectionCleared reports if the "connection" edge to the Connection entity was cleared.
func (m *HypothesisTestMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionID returns the "connection" edge ID in the mutation.
func (m *HypothesisTestMutation) ConnectionID() (id pulid.ID, exists bool) {
	if m.connection != nil {
		return *m.connection, true
	}
	return
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestMutation) ConnectionIDs() (ids []pulid.ID) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *HypothesisTestMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// Where appends a list predicates to the HypothesisTestMutation builder.
func (m *HypothesisTestMutation) Where(ps ...predicate.HypothesisTest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HypothesisTestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HypothesisTestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HypothesisTest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HypothesisTestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HypothesisTestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HypothesisTest).
func (m *HypothesisTestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HypothesisTestMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, hypothesistest.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, hypothesistest.FieldName)
	}
	if m.active != nil {
		fields = append(fields, hypothesistest.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HypothesisTestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hypothesistest.FieldTenantID:
		return m.TenantID()
	case hypothesistest.FieldName:
		return m.Name()
	case hypothesistest.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HypothesisTestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hypothesistest.FieldTenantID:
		return m.OldTenantID(ctx)
	case hypothesistest.FieldName:
		return m.OldName(ctx)
	case hypothesistest.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown HypothesisTest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HypothesisTestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hypothesistest.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case hypothesistest.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case hypothesistest.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown HypothesisTest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HypothesisTestMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HypothesisTestMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HypothesisTestMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HypothesisTest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HypothesisTestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HypothesisTestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HypothesisTestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HypothesisTest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HypothesisTestMutation) ResetField(name string) error {
	switch name {
	case hypothesistest.FieldTenantID:
		m.ResetTenantID()
		return nil
	case hypothesistest.FieldName:
		m.ResetName()
		return nil
	case hypothesistest.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HypothesisTestMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, hypothesistest.EdgeTenant)
	}
	if m.hypothesis_test_delivery_option != nil {
		edges = append(edges, hypothesistest.EdgeHypothesisTestDeliveryOption)
	}
	if m.connection != nil {
		edges = append(edges, hypothesistest.EdgeConnection)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HypothesisTestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hypothesistest.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case hypothesistest.EdgeHypothesisTestDeliveryOption:
		if id := m.hypothesis_test_delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case hypothesistest.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HypothesisTestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HypothesisTestMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HypothesisTestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, hypothesistest.EdgeTenant)
	}
	if m.clearedhypothesis_test_delivery_option {
		edges = append(edges, hypothesistest.EdgeHypothesisTestDeliveryOption)
	}
	if m.clearedconnection {
		edges = append(edges, hypothesistest.EdgeConnection)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HypothesisTestMutation) EdgeCleared(name string) bool {
	switch name {
	case hypothesistest.EdgeTenant:
		return m.clearedtenant
	case hypothesistest.EdgeHypothesisTestDeliveryOption:
		return m.clearedhypothesis_test_delivery_option
	case hypothesistest.EdgeConnection:
		return m.clearedconnection
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HypothesisTestMutation) ClearEdge(name string) error {
	switch name {
	case hypothesistest.EdgeTenant:
		m.ClearTenant()
		return nil
	case hypothesistest.EdgeHypothesisTestDeliveryOption:
		m.ClearHypothesisTestDeliveryOption()
		return nil
	case hypothesistest.EdgeConnection:
		m.ClearConnection()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HypothesisTestMutation) ResetEdge(name string) error {
	switch name {
	case hypothesistest.EdgeTenant:
		m.ResetTenant()
		return nil
	case hypothesistest.EdgeHypothesisTestDeliveryOption:
		m.ResetHypothesisTestDeliveryOption()
		return nil
	case hypothesistest.EdgeConnection:
		m.ResetConnection()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTest edge %s", name)
}

// HypothesisTestDeliveryOptionMutation represents an operation that mutates the HypothesisTestDeliveryOption nodes in the graph.
type HypothesisTestDeliveryOptionMutation struct {
	config
	op                                             Op
	typ                                            string
	id                                             *pulid.ID
	randomize_within_group_sort                    *bool
	by_interval_rotation                           *bool
	rotation_interval_hours                        *int
	addrotation_interval_hours                     *int
	by_order                                       *bool
	clearedFields                                  map[string]struct{}
	tenant                                         *pulid.ID
	clearedtenant                                  bool
	hypothesis_test                                *pulid.ID
	clearedhypothesis_test                         bool
	hypothesis_test_delivery_option_request        map[pulid.ID]struct{}
	removedhypothesis_test_delivery_option_request map[pulid.ID]struct{}
	clearedhypothesis_test_delivery_option_request bool
	delivery_option_group_one                      map[pulid.ID]struct{}
	removeddelivery_option_group_one               map[pulid.ID]struct{}
	cleareddelivery_option_group_one               bool
	delivery_option_group_two                      map[pulid.ID]struct{}
	removeddelivery_option_group_two               map[pulid.ID]struct{}
	cleareddelivery_option_group_two               bool
	done                                           bool
	oldValue                                       func(context.Context) (*HypothesisTestDeliveryOption, error)
	predicates                                     []predicate.HypothesisTestDeliveryOption
}

var _ ent.Mutation = (*HypothesisTestDeliveryOptionMutation)(nil)

// hypothesistestdeliveryoptionOption allows management of the mutation configuration using functional options.
type hypothesistestdeliveryoptionOption func(*HypothesisTestDeliveryOptionMutation)

// newHypothesisTestDeliveryOptionMutation creates new mutation for the HypothesisTestDeliveryOption entity.
func newHypothesisTestDeliveryOptionMutation(c config, op Op, opts ...hypothesistestdeliveryoptionOption) *HypothesisTestDeliveryOptionMutation {
	m := &HypothesisTestDeliveryOptionMutation{
		config:        c,
		op:            op,
		typ:           TypeHypothesisTestDeliveryOption,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHypothesisTestDeliveryOptionID sets the ID field of the mutation.
func withHypothesisTestDeliveryOptionID(id pulid.ID) hypothesistestdeliveryoptionOption {
	return func(m *HypothesisTestDeliveryOptionMutation) {
		var (
			err   error
			once  sync.Once
			value *HypothesisTestDeliveryOption
		)
		m.oldValue = func(ctx context.Context) (*HypothesisTestDeliveryOption, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HypothesisTestDeliveryOption.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHypothesisTestDeliveryOption sets the old HypothesisTestDeliveryOption of the mutation.
func withHypothesisTestDeliveryOption(node *HypothesisTestDeliveryOption) hypothesistestdeliveryoptionOption {
	return func(m *HypothesisTestDeliveryOptionMutation) {
		m.oldValue = func(context.Context) (*HypothesisTestDeliveryOption, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HypothesisTestDeliveryOptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HypothesisTestDeliveryOptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HypothesisTestDeliveryOption entities.
func (m *HypothesisTestDeliveryOptionMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HypothesisTestDeliveryOptionMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HypothesisTestDeliveryOptionMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HypothesisTestDeliveryOption.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *HypothesisTestDeliveryOptionMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *HypothesisTestDeliveryOptionMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the HypothesisTestDeliveryOption entity.
// If the HypothesisTestDeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *HypothesisTestDeliveryOptionMutation) ResetTenantID() {
	m.tenant = nil
}

// SetRandomizeWithinGroupSort sets the "randomize_within_group_sort" field.
func (m *HypothesisTestDeliveryOptionMutation) SetRandomizeWithinGroupSort(b bool) {
	m.randomize_within_group_sort = &b
}

// RandomizeWithinGroupSort returns the value of the "randomize_within_group_sort" field in the mutation.
func (m *HypothesisTestDeliveryOptionMutation) RandomizeWithinGroupSort() (r bool, exists bool) {
	v := m.randomize_within_group_sort
	if v == nil {
		return
	}
	return *v, true
}

// OldRandomizeWithinGroupSort returns the old "randomize_within_group_sort" field's value of the HypothesisTestDeliveryOption entity.
// If the HypothesisTestDeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionMutation) OldRandomizeWithinGroupSort(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRandomizeWithinGroupSort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRandomizeWithinGroupSort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRandomizeWithinGroupSort: %w", err)
	}
	return oldValue.RandomizeWithinGroupSort, nil
}

// ResetRandomizeWithinGroupSort resets all changes to the "randomize_within_group_sort" field.
func (m *HypothesisTestDeliveryOptionMutation) ResetRandomizeWithinGroupSort() {
	m.randomize_within_group_sort = nil
}

// SetByIntervalRotation sets the "by_interval_rotation" field.
func (m *HypothesisTestDeliveryOptionMutation) SetByIntervalRotation(b bool) {
	m.by_interval_rotation = &b
}

// ByIntervalRotation returns the value of the "by_interval_rotation" field in the mutation.
func (m *HypothesisTestDeliveryOptionMutation) ByIntervalRotation() (r bool, exists bool) {
	v := m.by_interval_rotation
	if v == nil {
		return
	}
	return *v, true
}

// OldByIntervalRotation returns the old "by_interval_rotation" field's value of the HypothesisTestDeliveryOption entity.
// If the HypothesisTestDeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionMutation) OldByIntervalRotation(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldByIntervalRotation is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldByIntervalRotation requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldByIntervalRotation: %w", err)
	}
	return oldValue.ByIntervalRotation, nil
}

// ResetByIntervalRotation resets all changes to the "by_interval_rotation" field.
func (m *HypothesisTestDeliveryOptionMutation) ResetByIntervalRotation() {
	m.by_interval_rotation = nil
}

// SetRotationIntervalHours sets the "rotation_interval_hours" field.
func (m *HypothesisTestDeliveryOptionMutation) SetRotationIntervalHours(i int) {
	m.rotation_interval_hours = &i
	m.addrotation_interval_hours = nil
}

// RotationIntervalHours returns the value of the "rotation_interval_hours" field in the mutation.
func (m *HypothesisTestDeliveryOptionMutation) RotationIntervalHours() (r int, exists bool) {
	v := m.rotation_interval_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldRotationIntervalHours returns the old "rotation_interval_hours" field's value of the HypothesisTestDeliveryOption entity.
// If the HypothesisTestDeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionMutation) OldRotationIntervalHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRotationIntervalHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRotationIntervalHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRotationIntervalHours: %w", err)
	}
	return oldValue.RotationIntervalHours, nil
}

// AddRotationIntervalHours adds i to the "rotation_interval_hours" field.
func (m *HypothesisTestDeliveryOptionMutation) AddRotationIntervalHours(i int) {
	if m.addrotation_interval_hours != nil {
		*m.addrotation_interval_hours += i
	} else {
		m.addrotation_interval_hours = &i
	}
}

// AddedRotationIntervalHours returns the value that was added to the "rotation_interval_hours" field in this mutation.
func (m *HypothesisTestDeliveryOptionMutation) AddedRotationIntervalHours() (r int, exists bool) {
	v := m.addrotation_interval_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetRotationIntervalHours resets all changes to the "rotation_interval_hours" field.
func (m *HypothesisTestDeliveryOptionMutation) ResetRotationIntervalHours() {
	m.rotation_interval_hours = nil
	m.addrotation_interval_hours = nil
}

// SetByOrder sets the "by_order" field.
func (m *HypothesisTestDeliveryOptionMutation) SetByOrder(b bool) {
	m.by_order = &b
}

// ByOrder returns the value of the "by_order" field in the mutation.
func (m *HypothesisTestDeliveryOptionMutation) ByOrder() (r bool, exists bool) {
	v := m.by_order
	if v == nil {
		return
	}
	return *v, true
}

// OldByOrder returns the old "by_order" field's value of the HypothesisTestDeliveryOption entity.
// If the HypothesisTestDeliveryOption object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionMutation) OldByOrder(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldByOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldByOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldByOrder: %w", err)
	}
	return oldValue.ByOrder, nil
}

// ResetByOrder resets all changes to the "by_order" field.
func (m *HypothesisTestDeliveryOptionMutation) ResetByOrder() {
	m.by_order = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *HypothesisTestDeliveryOptionMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[hypothesistestdeliveryoption.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *HypothesisTestDeliveryOptionMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestDeliveryOptionMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *HypothesisTestDeliveryOptionMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetHypothesisTestID sets the "hypothesis_test" edge to the HypothesisTest entity by id.
func (m *HypothesisTestDeliveryOptionMutation) SetHypothesisTestID(id pulid.ID) {
	m.hypothesis_test = &id
}

// ClearHypothesisTest clears the "hypothesis_test" edge to the HypothesisTest entity.
func (m *HypothesisTestDeliveryOptionMutation) ClearHypothesisTest() {
	m.clearedhypothesis_test = true
}

// HypothesisTestCleared reports if the "hypothesis_test" edge to the HypothesisTest entity was cleared.
func (m *HypothesisTestDeliveryOptionMutation) HypothesisTestCleared() bool {
	return m.clearedhypothesis_test
}

// HypothesisTestID returns the "hypothesis_test" edge ID in the mutation.
func (m *HypothesisTestDeliveryOptionMutation) HypothesisTestID() (id pulid.ID, exists bool) {
	if m.hypothesis_test != nil {
		return *m.hypothesis_test, true
	}
	return
}

// HypothesisTestIDs returns the "hypothesis_test" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HypothesisTestID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestDeliveryOptionMutation) HypothesisTestIDs() (ids []pulid.ID) {
	if id := m.hypothesis_test; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHypothesisTest resets all changes to the "hypothesis_test" edge.
func (m *HypothesisTestDeliveryOptionMutation) ResetHypothesisTest() {
	m.hypothesis_test = nil
	m.clearedhypothesis_test = false
}

// AddHypothesisTestDeliveryOptionRequestIDs adds the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity by ids.
func (m *HypothesisTestDeliveryOptionMutation) AddHypothesisTestDeliveryOptionRequestIDs(ids ...pulid.ID) {
	if m.hypothesis_test_delivery_option_request == nil {
		m.hypothesis_test_delivery_option_request = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.hypothesis_test_delivery_option_request[ids[i]] = struct{}{}
	}
}

// ClearHypothesisTestDeliveryOptionRequest clears the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity.
func (m *HypothesisTestDeliveryOptionMutation) ClearHypothesisTestDeliveryOptionRequest() {
	m.clearedhypothesis_test_delivery_option_request = true
}

// HypothesisTestDeliveryOptionRequestCleared reports if the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity was cleared.
func (m *HypothesisTestDeliveryOptionMutation) HypothesisTestDeliveryOptionRequestCleared() bool {
	return m.clearedhypothesis_test_delivery_option_request
}

// RemoveHypothesisTestDeliveryOptionRequestIDs removes the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity by IDs.
func (m *HypothesisTestDeliveryOptionMutation) RemoveHypothesisTestDeliveryOptionRequestIDs(ids ...pulid.ID) {
	if m.removedhypothesis_test_delivery_option_request == nil {
		m.removedhypothesis_test_delivery_option_request = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.hypothesis_test_delivery_option_request, ids[i])
		m.removedhypothesis_test_delivery_option_request[ids[i]] = struct{}{}
	}
}

// RemovedHypothesisTestDeliveryOptionRequest returns the removed IDs of the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity.
func (m *HypothesisTestDeliveryOptionMutation) RemovedHypothesisTestDeliveryOptionRequestIDs() (ids []pulid.ID) {
	for id := range m.removedhypothesis_test_delivery_option_request {
		ids = append(ids, id)
	}
	return
}

// HypothesisTestDeliveryOptionRequestIDs returns the "hypothesis_test_delivery_option_request" edge IDs in the mutation.
func (m *HypothesisTestDeliveryOptionMutation) HypothesisTestDeliveryOptionRequestIDs() (ids []pulid.ID) {
	for id := range m.hypothesis_test_delivery_option_request {
		ids = append(ids, id)
	}
	return
}

// ResetHypothesisTestDeliveryOptionRequest resets all changes to the "hypothesis_test_delivery_option_request" edge.
func (m *HypothesisTestDeliveryOptionMutation) ResetHypothesisTestDeliveryOptionRequest() {
	m.hypothesis_test_delivery_option_request = nil
	m.clearedhypothesis_test_delivery_option_request = false
	m.removedhypothesis_test_delivery_option_request = nil
}

// AddDeliveryOptionGroupOneIDs adds the "delivery_option_group_one" edge to the DeliveryOption entity by ids.
func (m *HypothesisTestDeliveryOptionMutation) AddDeliveryOptionGroupOneIDs(ids ...pulid.ID) {
	if m.delivery_option_group_one == nil {
		m.delivery_option_group_one = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_group_one[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionGroupOne clears the "delivery_option_group_one" edge to the DeliveryOption entity.
func (m *HypothesisTestDeliveryOptionMutation) ClearDeliveryOptionGroupOne() {
	m.cleareddelivery_option_group_one = true
}

// DeliveryOptionGroupOneCleared reports if the "delivery_option_group_one" edge to the DeliveryOption entity was cleared.
func (m *HypothesisTestDeliveryOptionMutation) DeliveryOptionGroupOneCleared() bool {
	return m.cleareddelivery_option_group_one
}

// RemoveDeliveryOptionGroupOneIDs removes the "delivery_option_group_one" edge to the DeliveryOption entity by IDs.
func (m *HypothesisTestDeliveryOptionMutation) RemoveDeliveryOptionGroupOneIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_group_one == nil {
		m.removeddelivery_option_group_one = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_group_one, ids[i])
		m.removeddelivery_option_group_one[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionGroupOne returns the removed IDs of the "delivery_option_group_one" edge to the DeliveryOption entity.
func (m *HypothesisTestDeliveryOptionMutation) RemovedDeliveryOptionGroupOneIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_group_one {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionGroupOneIDs returns the "delivery_option_group_one" edge IDs in the mutation.
func (m *HypothesisTestDeliveryOptionMutation) DeliveryOptionGroupOneIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_group_one {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionGroupOne resets all changes to the "delivery_option_group_one" edge.
func (m *HypothesisTestDeliveryOptionMutation) ResetDeliveryOptionGroupOne() {
	m.delivery_option_group_one = nil
	m.cleareddelivery_option_group_one = false
	m.removeddelivery_option_group_one = nil
}

// AddDeliveryOptionGroupTwoIDs adds the "delivery_option_group_two" edge to the DeliveryOption entity by ids.
func (m *HypothesisTestDeliveryOptionMutation) AddDeliveryOptionGroupTwoIDs(ids ...pulid.ID) {
	if m.delivery_option_group_two == nil {
		m.delivery_option_group_two = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option_group_two[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptionGroupTwo clears the "delivery_option_group_two" edge to the DeliveryOption entity.
func (m *HypothesisTestDeliveryOptionMutation) ClearDeliveryOptionGroupTwo() {
	m.cleareddelivery_option_group_two = true
}

// DeliveryOptionGroupTwoCleared reports if the "delivery_option_group_two" edge to the DeliveryOption entity was cleared.
func (m *HypothesisTestDeliveryOptionMutation) DeliveryOptionGroupTwoCleared() bool {
	return m.cleareddelivery_option_group_two
}

// RemoveDeliveryOptionGroupTwoIDs removes the "delivery_option_group_two" edge to the DeliveryOption entity by IDs.
func (m *HypothesisTestDeliveryOptionMutation) RemoveDeliveryOptionGroupTwoIDs(ids ...pulid.ID) {
	if m.removeddelivery_option_group_two == nil {
		m.removeddelivery_option_group_two = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option_group_two, ids[i])
		m.removeddelivery_option_group_two[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptionGroupTwo returns the removed IDs of the "delivery_option_group_two" edge to the DeliveryOption entity.
func (m *HypothesisTestDeliveryOptionMutation) RemovedDeliveryOptionGroupTwoIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option_group_two {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionGroupTwoIDs returns the "delivery_option_group_two" edge IDs in the mutation.
func (m *HypothesisTestDeliveryOptionMutation) DeliveryOptionGroupTwoIDs() (ids []pulid.ID) {
	for id := range m.delivery_option_group_two {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptionGroupTwo resets all changes to the "delivery_option_group_two" edge.
func (m *HypothesisTestDeliveryOptionMutation) ResetDeliveryOptionGroupTwo() {
	m.delivery_option_group_two = nil
	m.cleareddelivery_option_group_two = false
	m.removeddelivery_option_group_two = nil
}

// Where appends a list predicates to the HypothesisTestDeliveryOptionMutation builder.
func (m *HypothesisTestDeliveryOptionMutation) Where(ps ...predicate.HypothesisTestDeliveryOption) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HypothesisTestDeliveryOptionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HypothesisTestDeliveryOptionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HypothesisTestDeliveryOption, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HypothesisTestDeliveryOptionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HypothesisTestDeliveryOptionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HypothesisTestDeliveryOption).
func (m *HypothesisTestDeliveryOptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HypothesisTestDeliveryOptionMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, hypothesistestdeliveryoption.FieldTenantID)
	}
	if m.randomize_within_group_sort != nil {
		fields = append(fields, hypothesistestdeliveryoption.FieldRandomizeWithinGroupSort)
	}
	if m.by_interval_rotation != nil {
		fields = append(fields, hypothesistestdeliveryoption.FieldByIntervalRotation)
	}
	if m.rotation_interval_hours != nil {
		fields = append(fields, hypothesistestdeliveryoption.FieldRotationIntervalHours)
	}
	if m.by_order != nil {
		fields = append(fields, hypothesistestdeliveryoption.FieldByOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HypothesisTestDeliveryOptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hypothesistestdeliveryoption.FieldTenantID:
		return m.TenantID()
	case hypothesistestdeliveryoption.FieldRandomizeWithinGroupSort:
		return m.RandomizeWithinGroupSort()
	case hypothesistestdeliveryoption.FieldByIntervalRotation:
		return m.ByIntervalRotation()
	case hypothesistestdeliveryoption.FieldRotationIntervalHours:
		return m.RotationIntervalHours()
	case hypothesistestdeliveryoption.FieldByOrder:
		return m.ByOrder()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HypothesisTestDeliveryOptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hypothesistestdeliveryoption.FieldTenantID:
		return m.OldTenantID(ctx)
	case hypothesistestdeliveryoption.FieldRandomizeWithinGroupSort:
		return m.OldRandomizeWithinGroupSort(ctx)
	case hypothesistestdeliveryoption.FieldByIntervalRotation:
		return m.OldByIntervalRotation(ctx)
	case hypothesistestdeliveryoption.FieldRotationIntervalHours:
		return m.OldRotationIntervalHours(ctx)
	case hypothesistestdeliveryoption.FieldByOrder:
		return m.OldByOrder(ctx)
	}
	return nil, fmt.Errorf("unknown HypothesisTestDeliveryOption field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HypothesisTestDeliveryOptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hypothesistestdeliveryoption.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case hypothesistestdeliveryoption.FieldRandomizeWithinGroupSort:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRandomizeWithinGroupSort(v)
		return nil
	case hypothesistestdeliveryoption.FieldByIntervalRotation:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetByIntervalRotation(v)
		return nil
	case hypothesistestdeliveryoption.FieldRotationIntervalHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRotationIntervalHours(v)
		return nil
	case hypothesistestdeliveryoption.FieldByOrder:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetByOrder(v)
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOption field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HypothesisTestDeliveryOptionMutation) AddedFields() []string {
	var fields []string
	if m.addrotation_interval_hours != nil {
		fields = append(fields, hypothesistestdeliveryoption.FieldRotationIntervalHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HypothesisTestDeliveryOptionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hypothesistestdeliveryoption.FieldRotationIntervalHours:
		return m.AddedRotationIntervalHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HypothesisTestDeliveryOptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hypothesistestdeliveryoption.FieldRotationIntervalHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRotationIntervalHours(v)
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOption numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HypothesisTestDeliveryOptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HypothesisTestDeliveryOptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HypothesisTestDeliveryOptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HypothesisTestDeliveryOption nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HypothesisTestDeliveryOptionMutation) ResetField(name string) error {
	switch name {
	case hypothesistestdeliveryoption.FieldTenantID:
		m.ResetTenantID()
		return nil
	case hypothesistestdeliveryoption.FieldRandomizeWithinGroupSort:
		m.ResetRandomizeWithinGroupSort()
		return nil
	case hypothesistestdeliveryoption.FieldByIntervalRotation:
		m.ResetByIntervalRotation()
		return nil
	case hypothesistestdeliveryoption.FieldRotationIntervalHours:
		m.ResetRotationIntervalHours()
		return nil
	case hypothesistestdeliveryoption.FieldByOrder:
		m.ResetByOrder()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOption field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HypothesisTestDeliveryOptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, hypothesistestdeliveryoption.EdgeTenant)
	}
	if m.hypothesis_test != nil {
		edges = append(edges, hypothesistestdeliveryoption.EdgeHypothesisTest)
	}
	if m.hypothesis_test_delivery_option_request != nil {
		edges = append(edges, hypothesistestdeliveryoption.EdgeHypothesisTestDeliveryOptionRequest)
	}
	if m.delivery_option_group_one != nil {
		edges = append(edges, hypothesistestdeliveryoption.EdgeDeliveryOptionGroupOne)
	}
	if m.delivery_option_group_two != nil {
		edges = append(edges, hypothesistestdeliveryoption.EdgeDeliveryOptionGroupTwo)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HypothesisTestDeliveryOptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hypothesistestdeliveryoption.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case hypothesistestdeliveryoption.EdgeHypothesisTest:
		if id := m.hypothesis_test; id != nil {
			return []ent.Value{*id}
		}
	case hypothesistestdeliveryoption.EdgeHypothesisTestDeliveryOptionRequest:
		ids := make([]ent.Value, 0, len(m.hypothesis_test_delivery_option_request))
		for id := range m.hypothesis_test_delivery_option_request {
			ids = append(ids, id)
		}
		return ids
	case hypothesistestdeliveryoption.EdgeDeliveryOptionGroupOne:
		ids := make([]ent.Value, 0, len(m.delivery_option_group_one))
		for id := range m.delivery_option_group_one {
			ids = append(ids, id)
		}
		return ids
	case hypothesistestdeliveryoption.EdgeDeliveryOptionGroupTwo:
		ids := make([]ent.Value, 0, len(m.delivery_option_group_two))
		for id := range m.delivery_option_group_two {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HypothesisTestDeliveryOptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedhypothesis_test_delivery_option_request != nil {
		edges = append(edges, hypothesistestdeliveryoption.EdgeHypothesisTestDeliveryOptionRequest)
	}
	if m.removeddelivery_option_group_one != nil {
		edges = append(edges, hypothesistestdeliveryoption.EdgeDeliveryOptionGroupOne)
	}
	if m.removeddelivery_option_group_two != nil {
		edges = append(edges, hypothesistestdeliveryoption.EdgeDeliveryOptionGroupTwo)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HypothesisTestDeliveryOptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hypothesistestdeliveryoption.EdgeHypothesisTestDeliveryOptionRequest:
		ids := make([]ent.Value, 0, len(m.removedhypothesis_test_delivery_option_request))
		for id := range m.removedhypothesis_test_delivery_option_request {
			ids = append(ids, id)
		}
		return ids
	case hypothesistestdeliveryoption.EdgeDeliveryOptionGroupOne:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_group_one))
		for id := range m.removeddelivery_option_group_one {
			ids = append(ids, id)
		}
		return ids
	case hypothesistestdeliveryoption.EdgeDeliveryOptionGroupTwo:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option_group_two))
		for id := range m.removeddelivery_option_group_two {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HypothesisTestDeliveryOptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, hypothesistestdeliveryoption.EdgeTenant)
	}
	if m.clearedhypothesis_test {
		edges = append(edges, hypothesistestdeliveryoption.EdgeHypothesisTest)
	}
	if m.clearedhypothesis_test_delivery_option_request {
		edges = append(edges, hypothesistestdeliveryoption.EdgeHypothesisTestDeliveryOptionRequest)
	}
	if m.cleareddelivery_option_group_one {
		edges = append(edges, hypothesistestdeliveryoption.EdgeDeliveryOptionGroupOne)
	}
	if m.cleareddelivery_option_group_two {
		edges = append(edges, hypothesistestdeliveryoption.EdgeDeliveryOptionGroupTwo)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HypothesisTestDeliveryOptionMutation) EdgeCleared(name string) bool {
	switch name {
	case hypothesistestdeliveryoption.EdgeTenant:
		return m.clearedtenant
	case hypothesistestdeliveryoption.EdgeHypothesisTest:
		return m.clearedhypothesis_test
	case hypothesistestdeliveryoption.EdgeHypothesisTestDeliveryOptionRequest:
		return m.clearedhypothesis_test_delivery_option_request
	case hypothesistestdeliveryoption.EdgeDeliveryOptionGroupOne:
		return m.cleareddelivery_option_group_one
	case hypothesistestdeliveryoption.EdgeDeliveryOptionGroupTwo:
		return m.cleareddelivery_option_group_two
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HypothesisTestDeliveryOptionMutation) ClearEdge(name string) error {
	switch name {
	case hypothesistestdeliveryoption.EdgeTenant:
		m.ClearTenant()
		return nil
	case hypothesistestdeliveryoption.EdgeHypothesisTest:
		m.ClearHypothesisTest()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOption unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HypothesisTestDeliveryOptionMutation) ResetEdge(name string) error {
	switch name {
	case hypothesistestdeliveryoption.EdgeTenant:
		m.ResetTenant()
		return nil
	case hypothesistestdeliveryoption.EdgeHypothesisTest:
		m.ResetHypothesisTest()
		return nil
	case hypothesistestdeliveryoption.EdgeHypothesisTestDeliveryOptionRequest:
		m.ResetHypothesisTestDeliveryOptionRequest()
		return nil
	case hypothesistestdeliveryoption.EdgeDeliveryOptionGroupOne:
		m.ResetDeliveryOptionGroupOne()
		return nil
	case hypothesistestdeliveryoption.EdgeDeliveryOptionGroupTwo:
		m.ResetDeliveryOptionGroupTwo()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOption edge %s", name)
}

// HypothesisTestDeliveryOptionLookupMutation represents an operation that mutates the HypothesisTestDeliveryOptionLookup nodes in the graph.
type HypothesisTestDeliveryOptionLookupMutation struct {
	config
	op                                             Op
	typ                                            string
	id                                             *pulid.ID
	clearedFields                                  map[string]struct{}
	tenant                                         *pulid.ID
	clearedtenant                                  bool
	delivery_option                                *pulid.ID
	cleareddelivery_option                         bool
	hypothesis_test_delivery_option_request        *pulid.ID
	clearedhypothesis_test_delivery_option_request bool
	done                                           bool
	oldValue                                       func(context.Context) (*HypothesisTestDeliveryOptionLookup, error)
	predicates                                     []predicate.HypothesisTestDeliveryOptionLookup
}

var _ ent.Mutation = (*HypothesisTestDeliveryOptionLookupMutation)(nil)

// hypothesistestdeliveryoptionlookupOption allows management of the mutation configuration using functional options.
type hypothesistestdeliveryoptionlookupOption func(*HypothesisTestDeliveryOptionLookupMutation)

// newHypothesisTestDeliveryOptionLookupMutation creates new mutation for the HypothesisTestDeliveryOptionLookup entity.
func newHypothesisTestDeliveryOptionLookupMutation(c config, op Op, opts ...hypothesistestdeliveryoptionlookupOption) *HypothesisTestDeliveryOptionLookupMutation {
	m := &HypothesisTestDeliveryOptionLookupMutation{
		config:        c,
		op:            op,
		typ:           TypeHypothesisTestDeliveryOptionLookup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHypothesisTestDeliveryOptionLookupID sets the ID field of the mutation.
func withHypothesisTestDeliveryOptionLookupID(id pulid.ID) hypothesistestdeliveryoptionlookupOption {
	return func(m *HypothesisTestDeliveryOptionLookupMutation) {
		var (
			err   error
			once  sync.Once
			value *HypothesisTestDeliveryOptionLookup
		)
		m.oldValue = func(ctx context.Context) (*HypothesisTestDeliveryOptionLookup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HypothesisTestDeliveryOptionLookup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHypothesisTestDeliveryOptionLookup sets the old HypothesisTestDeliveryOptionLookup of the mutation.
func withHypothesisTestDeliveryOptionLookup(node *HypothesisTestDeliveryOptionLookup) hypothesistestdeliveryoptionlookupOption {
	return func(m *HypothesisTestDeliveryOptionLookupMutation) {
		m.oldValue = func(context.Context) (*HypothesisTestDeliveryOptionLookup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HypothesisTestDeliveryOptionLookupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HypothesisTestDeliveryOptionLookupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HypothesisTestDeliveryOptionLookup entities.
func (m *HypothesisTestDeliveryOptionLookupMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HypothesisTestDeliveryOptionLookupMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HypothesisTestDeliveryOptionLookup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *HypothesisTestDeliveryOptionLookupMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the HypothesisTestDeliveryOptionLookup entity.
// If the HypothesisTestDeliveryOptionLookup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionLookupMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *HypothesisTestDeliveryOptionLookupMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *HypothesisTestDeliveryOptionLookupMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[hypothesistestdeliveryoptionlookup.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *HypothesisTestDeliveryOptionLookupMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestDeliveryOptionLookupMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *HypothesisTestDeliveryOptionLookupMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *HypothesisTestDeliveryOptionLookupMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *HypothesisTestDeliveryOptionLookupMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *HypothesisTestDeliveryOptionLookupMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestDeliveryOptionLookupMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *HypothesisTestDeliveryOptionLookupMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// SetHypothesisTestDeliveryOptionRequestID sets the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity by id.
func (m *HypothesisTestDeliveryOptionLookupMutation) SetHypothesisTestDeliveryOptionRequestID(id pulid.ID) {
	m.hypothesis_test_delivery_option_request = &id
}

// ClearHypothesisTestDeliveryOptionRequest clears the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity.
func (m *HypothesisTestDeliveryOptionLookupMutation) ClearHypothesisTestDeliveryOptionRequest() {
	m.clearedhypothesis_test_delivery_option_request = true
}

// HypothesisTestDeliveryOptionRequestCleared reports if the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity was cleared.
func (m *HypothesisTestDeliveryOptionLookupMutation) HypothesisTestDeliveryOptionRequestCleared() bool {
	return m.clearedhypothesis_test_delivery_option_request
}

// HypothesisTestDeliveryOptionRequestID returns the "hypothesis_test_delivery_option_request" edge ID in the mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) HypothesisTestDeliveryOptionRequestID() (id pulid.ID, exists bool) {
	if m.hypothesis_test_delivery_option_request != nil {
		return *m.hypothesis_test_delivery_option_request, true
	}
	return
}

// HypothesisTestDeliveryOptionRequestIDs returns the "hypothesis_test_delivery_option_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HypothesisTestDeliveryOptionRequestID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestDeliveryOptionLookupMutation) HypothesisTestDeliveryOptionRequestIDs() (ids []pulid.ID) {
	if id := m.hypothesis_test_delivery_option_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHypothesisTestDeliveryOptionRequest resets all changes to the "hypothesis_test_delivery_option_request" edge.
func (m *HypothesisTestDeliveryOptionLookupMutation) ResetHypothesisTestDeliveryOptionRequest() {
	m.hypothesis_test_delivery_option_request = nil
	m.clearedhypothesis_test_delivery_option_request = false
}

// Where appends a list predicates to the HypothesisTestDeliveryOptionLookupMutation builder.
func (m *HypothesisTestDeliveryOptionLookupMutation) Where(ps ...predicate.HypothesisTestDeliveryOptionLookup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HypothesisTestDeliveryOptionLookupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HypothesisTestDeliveryOptionLookupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HypothesisTestDeliveryOptionLookup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HypothesisTestDeliveryOptionLookupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HypothesisTestDeliveryOptionLookupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HypothesisTestDeliveryOptionLookup).
func (m *HypothesisTestDeliveryOptionLookupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HypothesisTestDeliveryOptionLookupMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tenant != nil {
		fields = append(fields, hypothesistestdeliveryoptionlookup.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HypothesisTestDeliveryOptionLookupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hypothesistestdeliveryoptionlookup.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HypothesisTestDeliveryOptionLookupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hypothesistestdeliveryoptionlookup.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown HypothesisTestDeliveryOptionLookup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HypothesisTestDeliveryOptionLookupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hypothesistestdeliveryoptionlookup.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionLookup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HypothesisTestDeliveryOptionLookupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HypothesisTestDeliveryOptionLookupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionLookup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HypothesisTestDeliveryOptionLookupMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionLookup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HypothesisTestDeliveryOptionLookupMutation) ResetField(name string) error {
	switch name {
	case hypothesistestdeliveryoptionlookup.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionLookup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, hypothesistestdeliveryoptionlookup.EdgeTenant)
	}
	if m.delivery_option != nil {
		edges = append(edges, hypothesistestdeliveryoptionlookup.EdgeDeliveryOption)
	}
	if m.hypothesis_test_delivery_option_request != nil {
		edges = append(edges, hypothesistestdeliveryoptionlookup.EdgeHypothesisTestDeliveryOptionRequest)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hypothesistestdeliveryoptionlookup.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case hypothesistestdeliveryoptionlookup.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case hypothesistestdeliveryoptionlookup.EdgeHypothesisTestDeliveryOptionRequest:
		if id := m.hypothesis_test_delivery_option_request; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, hypothesistestdeliveryoptionlookup.EdgeTenant)
	}
	if m.cleareddelivery_option {
		edges = append(edges, hypothesistestdeliveryoptionlookup.EdgeDeliveryOption)
	}
	if m.clearedhypothesis_test_delivery_option_request {
		edges = append(edges, hypothesistestdeliveryoptionlookup.EdgeHypothesisTestDeliveryOptionRequest)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HypothesisTestDeliveryOptionLookupMutation) EdgeCleared(name string) bool {
	switch name {
	case hypothesistestdeliveryoptionlookup.EdgeTenant:
		return m.clearedtenant
	case hypothesistestdeliveryoptionlookup.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case hypothesistestdeliveryoptionlookup.EdgeHypothesisTestDeliveryOptionRequest:
		return m.clearedhypothesis_test_delivery_option_request
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HypothesisTestDeliveryOptionLookupMutation) ClearEdge(name string) error {
	switch name {
	case hypothesistestdeliveryoptionlookup.EdgeTenant:
		m.ClearTenant()
		return nil
	case hypothesistestdeliveryoptionlookup.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	case hypothesistestdeliveryoptionlookup.EdgeHypothesisTestDeliveryOptionRequest:
		m.ClearHypothesisTestDeliveryOptionRequest()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionLookup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HypothesisTestDeliveryOptionLookupMutation) ResetEdge(name string) error {
	switch name {
	case hypothesistestdeliveryoptionlookup.EdgeTenant:
		m.ResetTenant()
		return nil
	case hypothesistestdeliveryoptionlookup.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case hypothesistestdeliveryoptionlookup.EdgeHypothesisTestDeliveryOptionRequest:
		m.ResetHypothesisTestDeliveryOptionRequest()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionLookup edge %s", name)
}

// HypothesisTestDeliveryOptionRequestMutation represents an operation that mutates the HypothesisTestDeliveryOptionRequest nodes in the graph.
type HypothesisTestDeliveryOptionRequestMutation struct {
	config
	op                                            Op
	typ                                           string
	id                                            *pulid.ID
	order_hash                                    *string
	shipping_address_hash                         *string
	is_control_group                              *bool
	request_count                                 *uint
	addrequest_count                              *int
	created_at                                    *time.Time
	last_requested_at                             *time.Time
	clearedFields                                 map[string]struct{}
	tenant                                        *pulid.ID
	clearedtenant                                 bool
	hypothesis_test_delivery_option               *pulid.ID
	clearedhypothesis_test_delivery_option        bool
	_order                                        *pulid.ID
	cleared_order                                 bool
	hypothesis_test_delivery_option_lookup        map[pulid.ID]struct{}
	removedhypothesis_test_delivery_option_lookup map[pulid.ID]struct{}
	clearedhypothesis_test_delivery_option_lookup bool
	done                                          bool
	oldValue                                      func(context.Context) (*HypothesisTestDeliveryOptionRequest, error)
	predicates                                    []predicate.HypothesisTestDeliveryOptionRequest
}

var _ ent.Mutation = (*HypothesisTestDeliveryOptionRequestMutation)(nil)

// hypothesistestdeliveryoptionrequestOption allows management of the mutation configuration using functional options.
type hypothesistestdeliveryoptionrequestOption func(*HypothesisTestDeliveryOptionRequestMutation)

// newHypothesisTestDeliveryOptionRequestMutation creates new mutation for the HypothesisTestDeliveryOptionRequest entity.
func newHypothesisTestDeliveryOptionRequestMutation(c config, op Op, opts ...hypothesistestdeliveryoptionrequestOption) *HypothesisTestDeliveryOptionRequestMutation {
	m := &HypothesisTestDeliveryOptionRequestMutation{
		config:        c,
		op:            op,
		typ:           TypeHypothesisTestDeliveryOptionRequest,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHypothesisTestDeliveryOptionRequestID sets the ID field of the mutation.
func withHypothesisTestDeliveryOptionRequestID(id pulid.ID) hypothesistestdeliveryoptionrequestOption {
	return func(m *HypothesisTestDeliveryOptionRequestMutation) {
		var (
			err   error
			once  sync.Once
			value *HypothesisTestDeliveryOptionRequest
		)
		m.oldValue = func(ctx context.Context) (*HypothesisTestDeliveryOptionRequest, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().HypothesisTestDeliveryOptionRequest.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHypothesisTestDeliveryOptionRequest sets the old HypothesisTestDeliveryOptionRequest of the mutation.
func withHypothesisTestDeliveryOptionRequest(node *HypothesisTestDeliveryOptionRequest) hypothesistestdeliveryoptionrequestOption {
	return func(m *HypothesisTestDeliveryOptionRequestMutation) {
		m.oldValue = func(context.Context) (*HypothesisTestDeliveryOptionRequest, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HypothesisTestDeliveryOptionRequestMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HypothesisTestDeliveryOptionRequestMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of HypothesisTestDeliveryOptionRequest entities.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *HypothesisTestDeliveryOptionRequestMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().HypothesisTestDeliveryOptionRequest.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the HypothesisTestDeliveryOptionRequest entity.
// If the HypothesisTestDeliveryOptionRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionRequestMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetTenantID() {
	m.tenant = nil
}

// SetOrderHash sets the "order_hash" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetOrderHash(s string) {
	m.order_hash = &s
}

// OrderHash returns the value of the "order_hash" field in the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) OrderHash() (r string, exists bool) {
	v := m.order_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderHash returns the old "order_hash" field's value of the HypothesisTestDeliveryOptionRequest entity.
// If the HypothesisTestDeliveryOptionRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionRequestMutation) OldOrderHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderHash: %w", err)
	}
	return oldValue.OrderHash, nil
}

// ResetOrderHash resets all changes to the "order_hash" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetOrderHash() {
	m.order_hash = nil
}

// SetShippingAddressHash sets the "shipping_address_hash" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetShippingAddressHash(s string) {
	m.shipping_address_hash = &s
}

// ShippingAddressHash returns the value of the "shipping_address_hash" field in the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) ShippingAddressHash() (r string, exists bool) {
	v := m.shipping_address_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingAddressHash returns the old "shipping_address_hash" field's value of the HypothesisTestDeliveryOptionRequest entity.
// If the HypothesisTestDeliveryOptionRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionRequestMutation) OldShippingAddressHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingAddressHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingAddressHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingAddressHash: %w", err)
	}
	return oldValue.ShippingAddressHash, nil
}

// ResetShippingAddressHash resets all changes to the "shipping_address_hash" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetShippingAddressHash() {
	m.shipping_address_hash = nil
}

// SetIsControlGroup sets the "is_control_group" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetIsControlGroup(b bool) {
	m.is_control_group = &b
}

// IsControlGroup returns the value of the "is_control_group" field in the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) IsControlGroup() (r bool, exists bool) {
	v := m.is_control_group
	if v == nil {
		return
	}
	return *v, true
}

// OldIsControlGroup returns the old "is_control_group" field's value of the HypothesisTestDeliveryOptionRequest entity.
// If the HypothesisTestDeliveryOptionRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionRequestMutation) OldIsControlGroup(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsControlGroup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsControlGroup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsControlGroup: %w", err)
	}
	return oldValue.IsControlGroup, nil
}

// ResetIsControlGroup resets all changes to the "is_control_group" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetIsControlGroup() {
	m.is_control_group = nil
}

// SetRequestCount sets the "request_count" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetRequestCount(u uint) {
	m.request_count = &u
	m.addrequest_count = nil
}

// RequestCount returns the value of the "request_count" field in the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) RequestCount() (r uint, exists bool) {
	v := m.request_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRequestCount returns the old "request_count" field's value of the HypothesisTestDeliveryOptionRequest entity.
// If the HypothesisTestDeliveryOptionRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionRequestMutation) OldRequestCount(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRequestCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRequestCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRequestCount: %w", err)
	}
	return oldValue.RequestCount, nil
}

// AddRequestCount adds u to the "request_count" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) AddRequestCount(u int) {
	if m.addrequest_count != nil {
		*m.addrequest_count += u
	} else {
		m.addrequest_count = &u
	}
}

// AddedRequestCount returns the value that was added to the "request_count" field in this mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) AddedRequestCount() (r int, exists bool) {
	v := m.addrequest_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRequestCount resets all changes to the "request_count" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetRequestCount() {
	m.request_count = nil
	m.addrequest_count = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the HypothesisTestDeliveryOptionRequest entity.
// If the HypothesisTestDeliveryOptionRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionRequestMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLastRequestedAt sets the "last_requested_at" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetLastRequestedAt(t time.Time) {
	m.last_requested_at = &t
}

// LastRequestedAt returns the value of the "last_requested_at" field in the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) LastRequestedAt() (r time.Time, exists bool) {
	v := m.last_requested_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastRequestedAt returns the old "last_requested_at" field's value of the HypothesisTestDeliveryOptionRequest entity.
// If the HypothesisTestDeliveryOptionRequest object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *HypothesisTestDeliveryOptionRequestMutation) OldLastRequestedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastRequestedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastRequestedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastRequestedAt: %w", err)
	}
	return oldValue.LastRequestedAt, nil
}

// ResetLastRequestedAt resets all changes to the "last_requested_at" field.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetLastRequestedAt() {
	m.last_requested_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *HypothesisTestDeliveryOptionRequestMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[hypothesistestdeliveryoptionrequest.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *HypothesisTestDeliveryOptionRequestMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestDeliveryOptionRequestMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetHypothesisTestDeliveryOptionID sets the "hypothesis_test_delivery_option" edge to the HypothesisTestDeliveryOption entity by id.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetHypothesisTestDeliveryOptionID(id pulid.ID) {
	m.hypothesis_test_delivery_option = &id
}

// ClearHypothesisTestDeliveryOption clears the "hypothesis_test_delivery_option" edge to the HypothesisTestDeliveryOption entity.
func (m *HypothesisTestDeliveryOptionRequestMutation) ClearHypothesisTestDeliveryOption() {
	m.clearedhypothesis_test_delivery_option = true
}

// HypothesisTestDeliveryOptionCleared reports if the "hypothesis_test_delivery_option" edge to the HypothesisTestDeliveryOption entity was cleared.
func (m *HypothesisTestDeliveryOptionRequestMutation) HypothesisTestDeliveryOptionCleared() bool {
	return m.clearedhypothesis_test_delivery_option
}

// HypothesisTestDeliveryOptionID returns the "hypothesis_test_delivery_option" edge ID in the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) HypothesisTestDeliveryOptionID() (id pulid.ID, exists bool) {
	if m.hypothesis_test_delivery_option != nil {
		return *m.hypothesis_test_delivery_option, true
	}
	return
}

// HypothesisTestDeliveryOptionIDs returns the "hypothesis_test_delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HypothesisTestDeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestDeliveryOptionRequestMutation) HypothesisTestDeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.hypothesis_test_delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHypothesisTestDeliveryOption resets all changes to the "hypothesis_test_delivery_option" edge.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetHypothesisTestDeliveryOption() {
	m.hypothesis_test_delivery_option = nil
	m.clearedhypothesis_test_delivery_option = false
}

// SetOrderID sets the "order" edge to the Order entity by id.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetOrderID(id pulid.ID) {
	m._order = &id
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *HypothesisTestDeliveryOptionRequestMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *HypothesisTestDeliveryOptionRequestMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderID returns the "order" edge ID in the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) OrderID() (id pulid.ID, exists bool) {
	if m._order != nil {
		return *m._order, true
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *HypothesisTestDeliveryOptionRequestMutation) OrderIDs() (ids []pulid.ID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// AddHypothesisTestDeliveryOptionLookupIDs adds the "hypothesis_test_delivery_option_lookup" edge to the HypothesisTestDeliveryOptionLookup entity by ids.
func (m *HypothesisTestDeliveryOptionRequestMutation) AddHypothesisTestDeliveryOptionLookupIDs(ids ...pulid.ID) {
	if m.hypothesis_test_delivery_option_lookup == nil {
		m.hypothesis_test_delivery_option_lookup = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.hypothesis_test_delivery_option_lookup[ids[i]] = struct{}{}
	}
}

// ClearHypothesisTestDeliveryOptionLookup clears the "hypothesis_test_delivery_option_lookup" edge to the HypothesisTestDeliveryOptionLookup entity.
func (m *HypothesisTestDeliveryOptionRequestMutation) ClearHypothesisTestDeliveryOptionLookup() {
	m.clearedhypothesis_test_delivery_option_lookup = true
}

// HypothesisTestDeliveryOptionLookupCleared reports if the "hypothesis_test_delivery_option_lookup" edge to the HypothesisTestDeliveryOptionLookup entity was cleared.
func (m *HypothesisTestDeliveryOptionRequestMutation) HypothesisTestDeliveryOptionLookupCleared() bool {
	return m.clearedhypothesis_test_delivery_option_lookup
}

// RemoveHypothesisTestDeliveryOptionLookupIDs removes the "hypothesis_test_delivery_option_lookup" edge to the HypothesisTestDeliveryOptionLookup entity by IDs.
func (m *HypothesisTestDeliveryOptionRequestMutation) RemoveHypothesisTestDeliveryOptionLookupIDs(ids ...pulid.ID) {
	if m.removedhypothesis_test_delivery_option_lookup == nil {
		m.removedhypothesis_test_delivery_option_lookup = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.hypothesis_test_delivery_option_lookup, ids[i])
		m.removedhypothesis_test_delivery_option_lookup[ids[i]] = struct{}{}
	}
}

// RemovedHypothesisTestDeliveryOptionLookup returns the removed IDs of the "hypothesis_test_delivery_option_lookup" edge to the HypothesisTestDeliveryOptionLookup entity.
func (m *HypothesisTestDeliveryOptionRequestMutation) RemovedHypothesisTestDeliveryOptionLookupIDs() (ids []pulid.ID) {
	for id := range m.removedhypothesis_test_delivery_option_lookup {
		ids = append(ids, id)
	}
	return
}

// HypothesisTestDeliveryOptionLookupIDs returns the "hypothesis_test_delivery_option_lookup" edge IDs in the mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) HypothesisTestDeliveryOptionLookupIDs() (ids []pulid.ID) {
	for id := range m.hypothesis_test_delivery_option_lookup {
		ids = append(ids, id)
	}
	return
}

// ResetHypothesisTestDeliveryOptionLookup resets all changes to the "hypothesis_test_delivery_option_lookup" edge.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetHypothesisTestDeliveryOptionLookup() {
	m.hypothesis_test_delivery_option_lookup = nil
	m.clearedhypothesis_test_delivery_option_lookup = false
	m.removedhypothesis_test_delivery_option_lookup = nil
}

// Where appends a list predicates to the HypothesisTestDeliveryOptionRequestMutation builder.
func (m *HypothesisTestDeliveryOptionRequestMutation) Where(ps ...predicate.HypothesisTestDeliveryOptionRequest) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the HypothesisTestDeliveryOptionRequestMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *HypothesisTestDeliveryOptionRequestMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.HypothesisTestDeliveryOptionRequest, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *HypothesisTestDeliveryOptionRequestMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (HypothesisTestDeliveryOptionRequest).
func (m *HypothesisTestDeliveryOptionRequestMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *HypothesisTestDeliveryOptionRequestMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, hypothesistestdeliveryoptionrequest.FieldTenantID)
	}
	if m.order_hash != nil {
		fields = append(fields, hypothesistestdeliveryoptionrequest.FieldOrderHash)
	}
	if m.shipping_address_hash != nil {
		fields = append(fields, hypothesistestdeliveryoptionrequest.FieldShippingAddressHash)
	}
	if m.is_control_group != nil {
		fields = append(fields, hypothesistestdeliveryoptionrequest.FieldIsControlGroup)
	}
	if m.request_count != nil {
		fields = append(fields, hypothesistestdeliveryoptionrequest.FieldRequestCount)
	}
	if m.created_at != nil {
		fields = append(fields, hypothesistestdeliveryoptionrequest.FieldCreatedAt)
	}
	if m.last_requested_at != nil {
		fields = append(fields, hypothesistestdeliveryoptionrequest.FieldLastRequestedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *HypothesisTestDeliveryOptionRequestMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case hypothesistestdeliveryoptionrequest.FieldTenantID:
		return m.TenantID()
	case hypothesistestdeliveryoptionrequest.FieldOrderHash:
		return m.OrderHash()
	case hypothesistestdeliveryoptionrequest.FieldShippingAddressHash:
		return m.ShippingAddressHash()
	case hypothesistestdeliveryoptionrequest.FieldIsControlGroup:
		return m.IsControlGroup()
	case hypothesistestdeliveryoptionrequest.FieldRequestCount:
		return m.RequestCount()
	case hypothesistestdeliveryoptionrequest.FieldCreatedAt:
		return m.CreatedAt()
	case hypothesistestdeliveryoptionrequest.FieldLastRequestedAt:
		return m.LastRequestedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *HypothesisTestDeliveryOptionRequestMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case hypothesistestdeliveryoptionrequest.FieldTenantID:
		return m.OldTenantID(ctx)
	case hypothesistestdeliveryoptionrequest.FieldOrderHash:
		return m.OldOrderHash(ctx)
	case hypothesistestdeliveryoptionrequest.FieldShippingAddressHash:
		return m.OldShippingAddressHash(ctx)
	case hypothesistestdeliveryoptionrequest.FieldIsControlGroup:
		return m.OldIsControlGroup(ctx)
	case hypothesistestdeliveryoptionrequest.FieldRequestCount:
		return m.OldRequestCount(ctx)
	case hypothesistestdeliveryoptionrequest.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case hypothesistestdeliveryoptionrequest.FieldLastRequestedAt:
		return m.OldLastRequestedAt(ctx)
	}
	return nil, fmt.Errorf("unknown HypothesisTestDeliveryOptionRequest field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HypothesisTestDeliveryOptionRequestMutation) SetField(name string, value ent.Value) error {
	switch name {
	case hypothesistestdeliveryoptionrequest.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case hypothesistestdeliveryoptionrequest.FieldOrderHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderHash(v)
		return nil
	case hypothesistestdeliveryoptionrequest.FieldShippingAddressHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingAddressHash(v)
		return nil
	case hypothesistestdeliveryoptionrequest.FieldIsControlGroup:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsControlGroup(v)
		return nil
	case hypothesistestdeliveryoptionrequest.FieldRequestCount:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRequestCount(v)
		return nil
	case hypothesistestdeliveryoptionrequest.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case hypothesistestdeliveryoptionrequest.FieldLastRequestedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastRequestedAt(v)
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionRequest field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) AddedFields() []string {
	var fields []string
	if m.addrequest_count != nil {
		fields = append(fields, hypothesistestdeliveryoptionrequest.FieldRequestCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *HypothesisTestDeliveryOptionRequestMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case hypothesistestdeliveryoptionrequest.FieldRequestCount:
		return m.AddedRequestCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *HypothesisTestDeliveryOptionRequestMutation) AddField(name string, value ent.Value) error {
	switch name {
	case hypothesistestdeliveryoptionrequest.FieldRequestCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRequestCount(v)
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionRequest numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *HypothesisTestDeliveryOptionRequestMutation) ClearField(name string) error {
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionRequest nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetField(name string) error {
	switch name {
	case hypothesistestdeliveryoptionrequest.FieldTenantID:
		m.ResetTenantID()
		return nil
	case hypothesistestdeliveryoptionrequest.FieldOrderHash:
		m.ResetOrderHash()
		return nil
	case hypothesistestdeliveryoptionrequest.FieldShippingAddressHash:
		m.ResetShippingAddressHash()
		return nil
	case hypothesistestdeliveryoptionrequest.FieldIsControlGroup:
		m.ResetIsControlGroup()
		return nil
	case hypothesistestdeliveryoptionrequest.FieldRequestCount:
		m.ResetRequestCount()
		return nil
	case hypothesistestdeliveryoptionrequest.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case hypothesistestdeliveryoptionrequest.FieldLastRequestedAt:
		m.ResetLastRequestedAt()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionRequest field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, hypothesistestdeliveryoptionrequest.EdgeTenant)
	}
	if m.hypothesis_test_delivery_option != nil {
		edges = append(edges, hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOption)
	}
	if m._order != nil {
		edges = append(edges, hypothesistestdeliveryoptionrequest.EdgeOrder)
	}
	if m.hypothesis_test_delivery_option_lookup != nil {
		edges = append(edges, hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOptionLookup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case hypothesistestdeliveryoptionrequest.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOption:
		if id := m.hypothesis_test_delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case hypothesistestdeliveryoptionrequest.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOptionLookup:
		ids := make([]ent.Value, 0, len(m.hypothesis_test_delivery_option_lookup))
		for id := range m.hypothesis_test_delivery_option_lookup {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedhypothesis_test_delivery_option_lookup != nil {
		edges = append(edges, hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOptionLookup)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOptionLookup:
		ids := make([]ent.Value, 0, len(m.removedhypothesis_test_delivery_option_lookup))
		for id := range m.removedhypothesis_test_delivery_option_lookup {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, hypothesistestdeliveryoptionrequest.EdgeTenant)
	}
	if m.clearedhypothesis_test_delivery_option {
		edges = append(edges, hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOption)
	}
	if m.cleared_order {
		edges = append(edges, hypothesistestdeliveryoptionrequest.EdgeOrder)
	}
	if m.clearedhypothesis_test_delivery_option_lookup {
		edges = append(edges, hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOptionLookup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *HypothesisTestDeliveryOptionRequestMutation) EdgeCleared(name string) bool {
	switch name {
	case hypothesistestdeliveryoptionrequest.EdgeTenant:
		return m.clearedtenant
	case hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOption:
		return m.clearedhypothesis_test_delivery_option
	case hypothesistestdeliveryoptionrequest.EdgeOrder:
		return m.cleared_order
	case hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOptionLookup:
		return m.clearedhypothesis_test_delivery_option_lookup
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *HypothesisTestDeliveryOptionRequestMutation) ClearEdge(name string) error {
	switch name {
	case hypothesistestdeliveryoptionrequest.EdgeTenant:
		m.ClearTenant()
		return nil
	case hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOption:
		m.ClearHypothesisTestDeliveryOption()
		return nil
	case hypothesistestdeliveryoptionrequest.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionRequest unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *HypothesisTestDeliveryOptionRequestMutation) ResetEdge(name string) error {
	switch name {
	case hypothesistestdeliveryoptionrequest.EdgeTenant:
		m.ResetTenant()
		return nil
	case hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOption:
		m.ResetHypothesisTestDeliveryOption()
		return nil
	case hypothesistestdeliveryoptionrequest.EdgeOrder:
		m.ResetOrder()
		return nil
	case hypothesistestdeliveryoptionrequest.EdgeHypothesisTestDeliveryOptionLookup:
		m.ResetHypothesisTestDeliveryOptionLookup()
		return nil
	}
	return fmt.Errorf("unknown HypothesisTestDeliveryOptionRequest edge %s", name)
}

// InventoryItemMutation represents an operation that mutates the InventoryItem nodes in the graph.
type InventoryItemMutation struct {
	config
	op                             Op
	typ                            string
	id                             *pulid.ID
	external_ID                    *string
	code                           *string
	sku                            *string
	clearedFields                  map[string]struct{}
	tenant                         *pulid.ID
	clearedtenant                  bool
	country_harmonized_code        map[pulid.ID]struct{}
	removedcountry_harmonized_code map[pulid.ID]struct{}
	clearedcountry_harmonized_code bool
	country_of_origin              *pulid.ID
	clearedcountry_of_origin       bool
	product_variant                *pulid.ID
	clearedproduct_variant         bool
	done                           bool
	oldValue                       func(context.Context) (*InventoryItem, error)
	predicates                     []predicate.InventoryItem
}

var _ ent.Mutation = (*InventoryItemMutation)(nil)

// inventoryitemOption allows management of the mutation configuration using functional options.
type inventoryitemOption func(*InventoryItemMutation)

// newInventoryItemMutation creates new mutation for the InventoryItem entity.
func newInventoryItemMutation(c config, op Op, opts ...inventoryitemOption) *InventoryItemMutation {
	m := &InventoryItemMutation{
		config:        c,
		op:            op,
		typ:           TypeInventoryItem,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withInventoryItemID sets the ID field of the mutation.
func withInventoryItemID(id pulid.ID) inventoryitemOption {
	return func(m *InventoryItemMutation) {
		var (
			err   error
			once  sync.Once
			value *InventoryItem
		)
		m.oldValue = func(ctx context.Context) (*InventoryItem, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().InventoryItem.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withInventoryItem sets the old InventoryItem of the mutation.
func withInventoryItem(node *InventoryItem) inventoryitemOption {
	return func(m *InventoryItemMutation) {
		m.oldValue = func(context.Context) (*InventoryItem, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m InventoryItemMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m InventoryItemMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of InventoryItem entities.
func (m *InventoryItemMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *InventoryItemMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *InventoryItemMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().InventoryItem.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *InventoryItemMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *InventoryItemMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the InventoryItem entity.
// If the InventoryItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *InventoryItemMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_ID" field.
func (m *InventoryItemMutation) SetExternalID(s string) {
	m.external_ID = &s
}

// ExternalID returns the value of the "external_ID" field in the mutation.
func (m *InventoryItemMutation) ExternalID() (r string, exists bool) {
	v := m.external_ID
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_ID" field's value of the InventoryItem entity.
// If the InventoryItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_ID" field.
func (m *InventoryItemMutation) ClearExternalID() {
	m.external_ID = nil
	m.clearedFields[inventoryitem.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_ID" field was cleared in this mutation.
func (m *InventoryItemMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[inventoryitem.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_ID" field.
func (m *InventoryItemMutation) ResetExternalID() {
	m.external_ID = nil
	delete(m.clearedFields, inventoryitem.FieldExternalID)
}

// SetCode sets the "code" field.
func (m *InventoryItemMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *InventoryItemMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the InventoryItem entity.
// If the InventoryItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemMutation) OldCode(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ClearCode clears the value of the "code" field.
func (m *InventoryItemMutation) ClearCode() {
	m.code = nil
	m.clearedFields[inventoryitem.FieldCode] = struct{}{}
}

// CodeCleared returns if the "code" field was cleared in this mutation.
func (m *InventoryItemMutation) CodeCleared() bool {
	_, ok := m.clearedFields[inventoryitem.FieldCode]
	return ok
}

// ResetCode resets all changes to the "code" field.
func (m *InventoryItemMutation) ResetCode() {
	m.code = nil
	delete(m.clearedFields, inventoryitem.FieldCode)
}

// SetSku sets the "sku" field.
func (m *InventoryItemMutation) SetSku(s string) {
	m.sku = &s
}

// Sku returns the value of the "sku" field in the mutation.
func (m *InventoryItemMutation) Sku() (r string, exists bool) {
	v := m.sku
	if v == nil {
		return
	}
	return *v, true
}

// OldSku returns the old "sku" field's value of the InventoryItem entity.
// If the InventoryItem object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *InventoryItemMutation) OldSku(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSku is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSku requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSku: %w", err)
	}
	return oldValue.Sku, nil
}

// ClearSku clears the value of the "sku" field.
func (m *InventoryItemMutation) ClearSku() {
	m.sku = nil
	m.clearedFields[inventoryitem.FieldSku] = struct{}{}
}

// SkuCleared returns if the "sku" field was cleared in this mutation.
func (m *InventoryItemMutation) SkuCleared() bool {
	_, ok := m.clearedFields[inventoryitem.FieldSku]
	return ok
}

// ResetSku resets all changes to the "sku" field.
func (m *InventoryItemMutation) ResetSku() {
	m.sku = nil
	delete(m.clearedFields, inventoryitem.FieldSku)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *InventoryItemMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[inventoryitem.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *InventoryItemMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *InventoryItemMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *InventoryItemMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddCountryHarmonizedCodeIDs adds the "country_harmonized_code" edge to the CountryHarmonizedCode entity by ids.
func (m *InventoryItemMutation) AddCountryHarmonizedCodeIDs(ids ...pulid.ID) {
	if m.country_harmonized_code == nil {
		m.country_harmonized_code = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.country_harmonized_code[ids[i]] = struct{}{}
	}
}

// ClearCountryHarmonizedCode clears the "country_harmonized_code" edge to the CountryHarmonizedCode entity.
func (m *InventoryItemMutation) ClearCountryHarmonizedCode() {
	m.clearedcountry_harmonized_code = true
}

// CountryHarmonizedCodeCleared reports if the "country_harmonized_code" edge to the CountryHarmonizedCode entity was cleared.
func (m *InventoryItemMutation) CountryHarmonizedCodeCleared() bool {
	return m.clearedcountry_harmonized_code
}

// RemoveCountryHarmonizedCodeIDs removes the "country_harmonized_code" edge to the CountryHarmonizedCode entity by IDs.
func (m *InventoryItemMutation) RemoveCountryHarmonizedCodeIDs(ids ...pulid.ID) {
	if m.removedcountry_harmonized_code == nil {
		m.removedcountry_harmonized_code = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.country_harmonized_code, ids[i])
		m.removedcountry_harmonized_code[ids[i]] = struct{}{}
	}
}

// RemovedCountryHarmonizedCode returns the removed IDs of the "country_harmonized_code" edge to the CountryHarmonizedCode entity.
func (m *InventoryItemMutation) RemovedCountryHarmonizedCodeIDs() (ids []pulid.ID) {
	for id := range m.removedcountry_harmonized_code {
		ids = append(ids, id)
	}
	return
}

// CountryHarmonizedCodeIDs returns the "country_harmonized_code" edge IDs in the mutation.
func (m *InventoryItemMutation) CountryHarmonizedCodeIDs() (ids []pulid.ID) {
	for id := range m.country_harmonized_code {
		ids = append(ids, id)
	}
	return
}

// ResetCountryHarmonizedCode resets all changes to the "country_harmonized_code" edge.
func (m *InventoryItemMutation) ResetCountryHarmonizedCode() {
	m.country_harmonized_code = nil
	m.clearedcountry_harmonized_code = false
	m.removedcountry_harmonized_code = nil
}

// SetCountryOfOriginID sets the "country_of_origin" edge to the Country entity by id.
func (m *InventoryItemMutation) SetCountryOfOriginID(id pulid.ID) {
	m.country_of_origin = &id
}

// ClearCountryOfOrigin clears the "country_of_origin" edge to the Country entity.
func (m *InventoryItemMutation) ClearCountryOfOrigin() {
	m.clearedcountry_of_origin = true
}

// CountryOfOriginCleared reports if the "country_of_origin" edge to the Country entity was cleared.
func (m *InventoryItemMutation) CountryOfOriginCleared() bool {
	return m.clearedcountry_of_origin
}

// CountryOfOriginID returns the "country_of_origin" edge ID in the mutation.
func (m *InventoryItemMutation) CountryOfOriginID() (id pulid.ID, exists bool) {
	if m.country_of_origin != nil {
		return *m.country_of_origin, true
	}
	return
}

// CountryOfOriginIDs returns the "country_of_origin" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CountryOfOriginID instead. It exists only for internal usage by the builders.
func (m *InventoryItemMutation) CountryOfOriginIDs() (ids []pulid.ID) {
	if id := m.country_of_origin; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCountryOfOrigin resets all changes to the "country_of_origin" edge.
func (m *InventoryItemMutation) ResetCountryOfOrigin() {
	m.country_of_origin = nil
	m.clearedcountry_of_origin = false
}

// SetProductVariantID sets the "product_variant" edge to the ProductVariant entity by id.
func (m *InventoryItemMutation) SetProductVariantID(id pulid.ID) {
	m.product_variant = &id
}

// ClearProductVariant clears the "product_variant" edge to the ProductVariant entity.
func (m *InventoryItemMutation) ClearProductVariant() {
	m.clearedproduct_variant = true
}

// ProductVariantCleared reports if the "product_variant" edge to the ProductVariant entity was cleared.
func (m *InventoryItemMutation) ProductVariantCleared() bool {
	return m.clearedproduct_variant
}

// ProductVariantID returns the "product_variant" edge ID in the mutation.
func (m *InventoryItemMutation) ProductVariantID() (id pulid.ID, exists bool) {
	if m.product_variant != nil {
		return *m.product_variant, true
	}
	return
}

// ProductVariantIDs returns the "product_variant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductVariantID instead. It exists only for internal usage by the builders.
func (m *InventoryItemMutation) ProductVariantIDs() (ids []pulid.ID) {
	if id := m.product_variant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductVariant resets all changes to the "product_variant" edge.
func (m *InventoryItemMutation) ResetProductVariant() {
	m.product_variant = nil
	m.clearedproduct_variant = false
}

// Where appends a list predicates to the InventoryItemMutation builder.
func (m *InventoryItemMutation) Where(ps ...predicate.InventoryItem) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the InventoryItemMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *InventoryItemMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.InventoryItem, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *InventoryItemMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *InventoryItemMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (InventoryItem).
func (m *InventoryItemMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *InventoryItemMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, inventoryitem.FieldTenantID)
	}
	if m.external_ID != nil {
		fields = append(fields, inventoryitem.FieldExternalID)
	}
	if m.code != nil {
		fields = append(fields, inventoryitem.FieldCode)
	}
	if m.sku != nil {
		fields = append(fields, inventoryitem.FieldSku)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *InventoryItemMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case inventoryitem.FieldTenantID:
		return m.TenantID()
	case inventoryitem.FieldExternalID:
		return m.ExternalID()
	case inventoryitem.FieldCode:
		return m.Code()
	case inventoryitem.FieldSku:
		return m.Sku()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *InventoryItemMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case inventoryitem.FieldTenantID:
		return m.OldTenantID(ctx)
	case inventoryitem.FieldExternalID:
		return m.OldExternalID(ctx)
	case inventoryitem.FieldCode:
		return m.OldCode(ctx)
	case inventoryitem.FieldSku:
		return m.OldSku(ctx)
	}
	return nil, fmt.Errorf("unknown InventoryItem field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryItemMutation) SetField(name string, value ent.Value) error {
	switch name {
	case inventoryitem.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case inventoryitem.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case inventoryitem.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case inventoryitem.FieldSku:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSku(v)
		return nil
	}
	return fmt.Errorf("unknown InventoryItem field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *InventoryItemMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *InventoryItemMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *InventoryItemMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown InventoryItem numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *InventoryItemMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(inventoryitem.FieldExternalID) {
		fields = append(fields, inventoryitem.FieldExternalID)
	}
	if m.FieldCleared(inventoryitem.FieldCode) {
		fields = append(fields, inventoryitem.FieldCode)
	}
	if m.FieldCleared(inventoryitem.FieldSku) {
		fields = append(fields, inventoryitem.FieldSku)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *InventoryItemMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *InventoryItemMutation) ClearField(name string) error {
	switch name {
	case inventoryitem.FieldExternalID:
		m.ClearExternalID()
		return nil
	case inventoryitem.FieldCode:
		m.ClearCode()
		return nil
	case inventoryitem.FieldSku:
		m.ClearSku()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *InventoryItemMutation) ResetField(name string) error {
	switch name {
	case inventoryitem.FieldTenantID:
		m.ResetTenantID()
		return nil
	case inventoryitem.FieldExternalID:
		m.ResetExternalID()
		return nil
	case inventoryitem.FieldCode:
		m.ResetCode()
		return nil
	case inventoryitem.FieldSku:
		m.ResetSku()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *InventoryItemMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, inventoryitem.EdgeTenant)
	}
	if m.country_harmonized_code != nil {
		edges = append(edges, inventoryitem.EdgeCountryHarmonizedCode)
	}
	if m.country_of_origin != nil {
		edges = append(edges, inventoryitem.EdgeCountryOfOrigin)
	}
	if m.product_variant != nil {
		edges = append(edges, inventoryitem.EdgeProductVariant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *InventoryItemMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case inventoryitem.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case inventoryitem.EdgeCountryHarmonizedCode:
		ids := make([]ent.Value, 0, len(m.country_harmonized_code))
		for id := range m.country_harmonized_code {
			ids = append(ids, id)
		}
		return ids
	case inventoryitem.EdgeCountryOfOrigin:
		if id := m.country_of_origin; id != nil {
			return []ent.Value{*id}
		}
	case inventoryitem.EdgeProductVariant:
		if id := m.product_variant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *InventoryItemMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedcountry_harmonized_code != nil {
		edges = append(edges, inventoryitem.EdgeCountryHarmonizedCode)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *InventoryItemMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case inventoryitem.EdgeCountryHarmonizedCode:
		ids := make([]ent.Value, 0, len(m.removedcountry_harmonized_code))
		for id := range m.removedcountry_harmonized_code {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *InventoryItemMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, inventoryitem.EdgeTenant)
	}
	if m.clearedcountry_harmonized_code {
		edges = append(edges, inventoryitem.EdgeCountryHarmonizedCode)
	}
	if m.clearedcountry_of_origin {
		edges = append(edges, inventoryitem.EdgeCountryOfOrigin)
	}
	if m.clearedproduct_variant {
		edges = append(edges, inventoryitem.EdgeProductVariant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *InventoryItemMutation) EdgeCleared(name string) bool {
	switch name {
	case inventoryitem.EdgeTenant:
		return m.clearedtenant
	case inventoryitem.EdgeCountryHarmonizedCode:
		return m.clearedcountry_harmonized_code
	case inventoryitem.EdgeCountryOfOrigin:
		return m.clearedcountry_of_origin
	case inventoryitem.EdgeProductVariant:
		return m.clearedproduct_variant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *InventoryItemMutation) ClearEdge(name string) error {
	switch name {
	case inventoryitem.EdgeTenant:
		m.ClearTenant()
		return nil
	case inventoryitem.EdgeCountryOfOrigin:
		m.ClearCountryOfOrigin()
		return nil
	case inventoryitem.EdgeProductVariant:
		m.ClearProductVariant()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *InventoryItemMutation) ResetEdge(name string) error {
	switch name {
	case inventoryitem.EdgeTenant:
		m.ResetTenant()
		return nil
	case inventoryitem.EdgeCountryHarmonizedCode:
		m.ResetCountryHarmonizedCode()
		return nil
	case inventoryitem.EdgeCountryOfOrigin:
		m.ResetCountryOfOrigin()
		return nil
	case inventoryitem.EdgeProductVariant:
		m.ResetProductVariant()
		return nil
	}
	return fmt.Errorf("unknown InventoryItem edge %s", name)
}

// LanguageMutation represents an operation that mutates the Language nodes in the graph.
type LanguageMutation struct {
	config
	op              Op
	typ             string
	id              *pulid.ID
	label           *string
	internal_id     *language.InternalID
	clearedFields   map[string]struct{}
	users           map[pulid.ID]struct{}
	removedusers    map[pulid.ID]struct{}
	clearedusers    bool
	language        map[pulid.ID]struct{}
	removedlanguage map[pulid.ID]struct{}
	clearedlanguage bool
	done            bool
	oldValue        func(context.Context) (*Language, error)
	predicates      []predicate.Language
}

var _ ent.Mutation = (*LanguageMutation)(nil)

// languageOption allows management of the mutation configuration using functional options.
type languageOption func(*LanguageMutation)

// newLanguageMutation creates new mutation for the Language entity.
func newLanguageMutation(c config, op Op, opts ...languageOption) *LanguageMutation {
	m := &LanguageMutation{
		config:        c,
		op:            op,
		typ:           TypeLanguage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLanguageID sets the ID field of the mutation.
func withLanguageID(id pulid.ID) languageOption {
	return func(m *LanguageMutation) {
		var (
			err   error
			once  sync.Once
			value *Language
		)
		m.oldValue = func(ctx context.Context) (*Language, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Language.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLanguage sets the old Language of the mutation.
func withLanguage(node *Language) languageOption {
	return func(m *LanguageMutation) {
		m.oldValue = func(context.Context) (*Language, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LanguageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LanguageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Language entities.
func (m *LanguageMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LanguageMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LanguageMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Language.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *LanguageMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *LanguageMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *LanguageMutation) ResetLabel() {
	m.label = nil
}

// SetInternalID sets the "internal_id" field.
func (m *LanguageMutation) SetInternalID(li language.InternalID) {
	m.internal_id = &li
}

// InternalID returns the value of the "internal_id" field in the mutation.
func (m *LanguageMutation) InternalID() (r language.InternalID, exists bool) {
	v := m.internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalID returns the old "internal_id" field's value of the Language entity.
// If the Language object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LanguageMutation) OldInternalID(ctx context.Context) (v language.InternalID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalID: %w", err)
	}
	return oldValue.InternalID, nil
}

// ResetInternalID resets all changes to the "internal_id" field.
func (m *LanguageMutation) ResetInternalID() {
	m.internal_id = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *LanguageMutation) AddUserIDs(ids ...pulid.ID) {
	if m.users == nil {
		m.users = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *LanguageMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *LanguageMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *LanguageMutation) RemoveUserIDs(ids ...pulid.ID) {
	if m.removedusers == nil {
		m.removedusers = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *LanguageMutation) RemovedUsersIDs() (ids []pulid.ID) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *LanguageMutation) UsersIDs() (ids []pulid.ID) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *LanguageMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddLanguageIDs adds the "language" edge to the Tenant entity by ids.
func (m *LanguageMutation) AddLanguageIDs(ids ...pulid.ID) {
	if m.language == nil {
		m.language = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.language[ids[i]] = struct{}{}
	}
}

// ClearLanguage clears the "language" edge to the Tenant entity.
func (m *LanguageMutation) ClearLanguage() {
	m.clearedlanguage = true
}

// LanguageCleared reports if the "language" edge to the Tenant entity was cleared.
func (m *LanguageMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// RemoveLanguageIDs removes the "language" edge to the Tenant entity by IDs.
func (m *LanguageMutation) RemoveLanguageIDs(ids ...pulid.ID) {
	if m.removedlanguage == nil {
		m.removedlanguage = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.language, ids[i])
		m.removedlanguage[ids[i]] = struct{}{}
	}
}

// RemovedLanguage returns the removed IDs of the "language" edge to the Tenant entity.
func (m *LanguageMutation) RemovedLanguageIDs() (ids []pulid.ID) {
	for id := range m.removedlanguage {
		ids = append(ids, id)
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
func (m *LanguageMutation) LanguageIDs() (ids []pulid.ID) {
	for id := range m.language {
		ids = append(ids, id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *LanguageMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
	m.removedlanguage = nil
}

// Where appends a list predicates to the LanguageMutation builder.
func (m *LanguageMutation) Where(ps ...predicate.Language) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LanguageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LanguageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Language, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LanguageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LanguageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Language).
func (m *LanguageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LanguageMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.label != nil {
		fields = append(fields, language.FieldLabel)
	}
	if m.internal_id != nil {
		fields = append(fields, language.FieldInternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LanguageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case language.FieldLabel:
		return m.Label()
	case language.FieldInternalID:
		return m.InternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LanguageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case language.FieldLabel:
		return m.OldLabel(ctx)
	case language.FieldInternalID:
		return m.OldInternalID(ctx)
	}
	return nil, fmt.Errorf("unknown Language field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case language.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case language.FieldInternalID:
		v, ok := value.(language.InternalID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalID(v)
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LanguageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LanguageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LanguageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Language numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LanguageMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LanguageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LanguageMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Language nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LanguageMutation) ResetField(name string) error {
	switch name {
	case language.FieldLabel:
		m.ResetLabel()
		return nil
	case language.FieldInternalID:
		m.ResetInternalID()
		return nil
	}
	return fmt.Errorf("unknown Language field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LanguageMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.users != nil {
		edges = append(edges, language.EdgeUsers)
	}
	if m.language != nil {
		edges = append(edges, language.EdgeLanguage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LanguageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case language.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeLanguage:
		ids := make([]ent.Value, 0, len(m.language))
		for id := range m.language {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LanguageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedusers != nil {
		edges = append(edges, language.EdgeUsers)
	}
	if m.removedlanguage != nil {
		edges = append(edges, language.EdgeLanguage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LanguageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case language.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case language.EdgeLanguage:
		ids := make([]ent.Value, 0, len(m.removedlanguage))
		for id := range m.removedlanguage {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LanguageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedusers {
		edges = append(edges, language.EdgeUsers)
	}
	if m.clearedlanguage {
		edges = append(edges, language.EdgeLanguage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LanguageMutation) EdgeCleared(name string) bool {
	switch name {
	case language.EdgeUsers:
		return m.clearedusers
	case language.EdgeLanguage:
		return m.clearedlanguage
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LanguageMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Language unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LanguageMutation) ResetEdge(name string) error {
	switch name {
	case language.EdgeUsers:
		m.ResetUsers()
		return nil
	case language.EdgeLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown Language edge %s", name)
}

// LocationMutation represents an operation that mutates the Location nodes in the graph.
type LocationMutation struct {
	config
	op                       Op
	typ                      string
	id                       *pulid.ID
	name                     *string
	clearedFields            map[string]struct{}
	tenant                   *pulid.ID
	clearedtenant            bool
	address                  *pulid.ID
	clearedaddress           bool
	location_tags            map[pulid.ID]struct{}
	removedlocation_tags     map[pulid.ID]struct{}
	clearedlocation_tags     bool
	sender_connection        map[pulid.ID]struct{}
	removedsender_connection map[pulid.ID]struct{}
	clearedsender_connection bool
	pickup_connection        map[pulid.ID]struct{}
	removedpickup_connection map[pulid.ID]struct{}
	clearedpickup_connection bool
	return_connection        map[pulid.ID]struct{}
	removedreturn_connection map[pulid.ID]struct{}
	clearedreturn_connection bool
	seller_connection        map[pulid.ID]struct{}
	removedseller_connection map[pulid.ID]struct{}
	clearedseller_connection bool
	return_portal            map[pulid.ID]struct{}
	removedreturn_portal     map[pulid.ID]struct{}
	clearedreturn_portal     bool
	delivery_option          map[pulid.ID]struct{}
	removeddelivery_option   map[pulid.ID]struct{}
	cleareddelivery_option   bool
	colli                    map[pulid.ID]struct{}
	removedcolli             map[pulid.ID]struct{}
	clearedcolli             bool
	done                     bool
	oldValue                 func(context.Context) (*Location, error)
	predicates               []predicate.Location
}

var _ ent.Mutation = (*LocationMutation)(nil)

// locationOption allows management of the mutation configuration using functional options.
type locationOption func(*LocationMutation)

// newLocationMutation creates new mutation for the Location entity.
func newLocationMutation(c config, op Op, opts ...locationOption) *LocationMutation {
	m := &LocationMutation{
		config:        c,
		op:            op,
		typ:           TypeLocation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationID sets the ID field of the mutation.
func withLocationID(id pulid.ID) locationOption {
	return func(m *LocationMutation) {
		var (
			err   error
			once  sync.Once
			value *Location
		)
		m.oldValue = func(ctx context.Context) (*Location, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Location.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocation sets the old Location of the mutation.
func withLocation(node *Location) locationOption {
	return func(m *LocationMutation) {
		m.oldValue = func(context.Context) (*Location, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Location entities.
func (m *LocationMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Location.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *LocationMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *LocationMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *LocationMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *LocationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Location entity.
// If the Location object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocationMutation) ResetName() {
	m.name = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *LocationMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[location.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *LocationMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *LocationMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetAddressID sets the "address" edge to the Address entity by id.
func (m *LocationMutation) SetAddressID(id pulid.ID) {
	m.address = &id
}

// ClearAddress clears the "address" edge to the Address entity.
func (m *LocationMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the Address entity was cleared.
func (m *LocationMutation) AddressCleared() bool {
	return m.clearedaddress
}

// AddressID returns the "address" edge ID in the mutation.
func (m *LocationMutation) AddressID() (id pulid.ID, exists bool) {
	if m.address != nil {
		return *m.address, true
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *LocationMutation) AddressIDs() (ids []pulid.ID) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *LocationMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// AddLocationTagIDs adds the "location_tags" edge to the LocationTag entity by ids.
func (m *LocationMutation) AddLocationTagIDs(ids ...pulid.ID) {
	if m.location_tags == nil {
		m.location_tags = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.location_tags[ids[i]] = struct{}{}
	}
}

// ClearLocationTags clears the "location_tags" edge to the LocationTag entity.
func (m *LocationMutation) ClearLocationTags() {
	m.clearedlocation_tags = true
}

// LocationTagsCleared reports if the "location_tags" edge to the LocationTag entity was cleared.
func (m *LocationMutation) LocationTagsCleared() bool {
	return m.clearedlocation_tags
}

// RemoveLocationTagIDs removes the "location_tags" edge to the LocationTag entity by IDs.
func (m *LocationMutation) RemoveLocationTagIDs(ids ...pulid.ID) {
	if m.removedlocation_tags == nil {
		m.removedlocation_tags = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.location_tags, ids[i])
		m.removedlocation_tags[ids[i]] = struct{}{}
	}
}

// RemovedLocationTags returns the removed IDs of the "location_tags" edge to the LocationTag entity.
func (m *LocationMutation) RemovedLocationTagsIDs() (ids []pulid.ID) {
	for id := range m.removedlocation_tags {
		ids = append(ids, id)
	}
	return
}

// LocationTagsIDs returns the "location_tags" edge IDs in the mutation.
func (m *LocationMutation) LocationTagsIDs() (ids []pulid.ID) {
	for id := range m.location_tags {
		ids = append(ids, id)
	}
	return
}

// ResetLocationTags resets all changes to the "location_tags" edge.
func (m *LocationMutation) ResetLocationTags() {
	m.location_tags = nil
	m.clearedlocation_tags = false
	m.removedlocation_tags = nil
}

// AddSenderConnectionIDs adds the "sender_connection" edge to the Connection entity by ids.
func (m *LocationMutation) AddSenderConnectionIDs(ids ...pulid.ID) {
	if m.sender_connection == nil {
		m.sender_connection = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.sender_connection[ids[i]] = struct{}{}
	}
}

// ClearSenderConnection clears the "sender_connection" edge to the Connection entity.
func (m *LocationMutation) ClearSenderConnection() {
	m.clearedsender_connection = true
}

// SenderConnectionCleared reports if the "sender_connection" edge to the Connection entity was cleared.
func (m *LocationMutation) SenderConnectionCleared() bool {
	return m.clearedsender_connection
}

// RemoveSenderConnectionIDs removes the "sender_connection" edge to the Connection entity by IDs.
func (m *LocationMutation) RemoveSenderConnectionIDs(ids ...pulid.ID) {
	if m.removedsender_connection == nil {
		m.removedsender_connection = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.sender_connection, ids[i])
		m.removedsender_connection[ids[i]] = struct{}{}
	}
}

// RemovedSenderConnection returns the removed IDs of the "sender_connection" edge to the Connection entity.
func (m *LocationMutation) RemovedSenderConnectionIDs() (ids []pulid.ID) {
	for id := range m.removedsender_connection {
		ids = append(ids, id)
	}
	return
}

// SenderConnectionIDs returns the "sender_connection" edge IDs in the mutation.
func (m *LocationMutation) SenderConnectionIDs() (ids []pulid.ID) {
	for id := range m.sender_connection {
		ids = append(ids, id)
	}
	return
}

// ResetSenderConnection resets all changes to the "sender_connection" edge.
func (m *LocationMutation) ResetSenderConnection() {
	m.sender_connection = nil
	m.clearedsender_connection = false
	m.removedsender_connection = nil
}

// AddPickupConnectionIDs adds the "pickup_connection" edge to the Connection entity by ids.
func (m *LocationMutation) AddPickupConnectionIDs(ids ...pulid.ID) {
	if m.pickup_connection == nil {
		m.pickup_connection = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.pickup_connection[ids[i]] = struct{}{}
	}
}

// ClearPickupConnection clears the "pickup_connection" edge to the Connection entity.
func (m *LocationMutation) ClearPickupConnection() {
	m.clearedpickup_connection = true
}

// PickupConnectionCleared reports if the "pickup_connection" edge to the Connection entity was cleared.
func (m *LocationMutation) PickupConnectionCleared() bool {
	return m.clearedpickup_connection
}

// RemovePickupConnectionIDs removes the "pickup_connection" edge to the Connection entity by IDs.
func (m *LocationMutation) RemovePickupConnectionIDs(ids ...pulid.ID) {
	if m.removedpickup_connection == nil {
		m.removedpickup_connection = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.pickup_connection, ids[i])
		m.removedpickup_connection[ids[i]] = struct{}{}
	}
}

// RemovedPickupConnection returns the removed IDs of the "pickup_connection" edge to the Connection entity.
func (m *LocationMutation) RemovedPickupConnectionIDs() (ids []pulid.ID) {
	for id := range m.removedpickup_connection {
		ids = append(ids, id)
	}
	return
}

// PickupConnectionIDs returns the "pickup_connection" edge IDs in the mutation.
func (m *LocationMutation) PickupConnectionIDs() (ids []pulid.ID) {
	for id := range m.pickup_connection {
		ids = append(ids, id)
	}
	return
}

// ResetPickupConnection resets all changes to the "pickup_connection" edge.
func (m *LocationMutation) ResetPickupConnection() {
	m.pickup_connection = nil
	m.clearedpickup_connection = false
	m.removedpickup_connection = nil
}

// AddReturnConnectionIDs adds the "return_connection" edge to the Connection entity by ids.
func (m *LocationMutation) AddReturnConnectionIDs(ids ...pulid.ID) {
	if m.return_connection == nil {
		m.return_connection = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_connection[ids[i]] = struct{}{}
	}
}

// ClearReturnConnection clears the "return_connection" edge to the Connection entity.
func (m *LocationMutation) ClearReturnConnection() {
	m.clearedreturn_connection = true
}

// ReturnConnectionCleared reports if the "return_connection" edge to the Connection entity was cleared.
func (m *LocationMutation) ReturnConnectionCleared() bool {
	return m.clearedreturn_connection
}

// RemoveReturnConnectionIDs removes the "return_connection" edge to the Connection entity by IDs.
func (m *LocationMutation) RemoveReturnConnectionIDs(ids ...pulid.ID) {
	if m.removedreturn_connection == nil {
		m.removedreturn_connection = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_connection, ids[i])
		m.removedreturn_connection[ids[i]] = struct{}{}
	}
}

// RemovedReturnConnection returns the removed IDs of the "return_connection" edge to the Connection entity.
func (m *LocationMutation) RemovedReturnConnectionIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_connection {
		ids = append(ids, id)
	}
	return
}

// ReturnConnectionIDs returns the "return_connection" edge IDs in the mutation.
func (m *LocationMutation) ReturnConnectionIDs() (ids []pulid.ID) {
	for id := range m.return_connection {
		ids = append(ids, id)
	}
	return
}

// ResetReturnConnection resets all changes to the "return_connection" edge.
func (m *LocationMutation) ResetReturnConnection() {
	m.return_connection = nil
	m.clearedreturn_connection = false
	m.removedreturn_connection = nil
}

// AddSellerConnectionIDs adds the "seller_connection" edge to the Connection entity by ids.
func (m *LocationMutation) AddSellerConnectionIDs(ids ...pulid.ID) {
	if m.seller_connection == nil {
		m.seller_connection = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.seller_connection[ids[i]] = struct{}{}
	}
}

// ClearSellerConnection clears the "seller_connection" edge to the Connection entity.
func (m *LocationMutation) ClearSellerConnection() {
	m.clearedseller_connection = true
}

// SellerConnectionCleared reports if the "seller_connection" edge to the Connection entity was cleared.
func (m *LocationMutation) SellerConnectionCleared() bool {
	return m.clearedseller_connection
}

// RemoveSellerConnectionIDs removes the "seller_connection" edge to the Connection entity by IDs.
func (m *LocationMutation) RemoveSellerConnectionIDs(ids ...pulid.ID) {
	if m.removedseller_connection == nil {
		m.removedseller_connection = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.seller_connection, ids[i])
		m.removedseller_connection[ids[i]] = struct{}{}
	}
}

// RemovedSellerConnection returns the removed IDs of the "seller_connection" edge to the Connection entity.
func (m *LocationMutation) RemovedSellerConnectionIDs() (ids []pulid.ID) {
	for id := range m.removedseller_connection {
		ids = append(ids, id)
	}
	return
}

// SellerConnectionIDs returns the "seller_connection" edge IDs in the mutation.
func (m *LocationMutation) SellerConnectionIDs() (ids []pulid.ID) {
	for id := range m.seller_connection {
		ids = append(ids, id)
	}
	return
}

// ResetSellerConnection resets all changes to the "seller_connection" edge.
func (m *LocationMutation) ResetSellerConnection() {
	m.seller_connection = nil
	m.clearedseller_connection = false
	m.removedseller_connection = nil
}

// AddReturnPortalIDs adds the "return_portal" edge to the ReturnPortal entity by ids.
func (m *LocationMutation) AddReturnPortalIDs(ids ...pulid.ID) {
	if m.return_portal == nil {
		m.return_portal = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_portal[ids[i]] = struct{}{}
	}
}

// ClearReturnPortal clears the "return_portal" edge to the ReturnPortal entity.
func (m *LocationMutation) ClearReturnPortal() {
	m.clearedreturn_portal = true
}

// ReturnPortalCleared reports if the "return_portal" edge to the ReturnPortal entity was cleared.
func (m *LocationMutation) ReturnPortalCleared() bool {
	return m.clearedreturn_portal
}

// RemoveReturnPortalIDs removes the "return_portal" edge to the ReturnPortal entity by IDs.
func (m *LocationMutation) RemoveReturnPortalIDs(ids ...pulid.ID) {
	if m.removedreturn_portal == nil {
		m.removedreturn_portal = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_portal, ids[i])
		m.removedreturn_portal[ids[i]] = struct{}{}
	}
}

// RemovedReturnPortal returns the removed IDs of the "return_portal" edge to the ReturnPortal entity.
func (m *LocationMutation) RemovedReturnPortalIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_portal {
		ids = append(ids, id)
	}
	return
}

// ReturnPortalIDs returns the "return_portal" edge IDs in the mutation.
func (m *LocationMutation) ReturnPortalIDs() (ids []pulid.ID) {
	for id := range m.return_portal {
		ids = append(ids, id)
	}
	return
}

// ResetReturnPortal resets all changes to the "return_portal" edge.
func (m *LocationMutation) ResetReturnPortal() {
	m.return_portal = nil
	m.clearedreturn_portal = false
	m.removedreturn_portal = nil
}

// AddDeliveryOptionIDs adds the "delivery_option" edge to the DeliveryOption entity by ids.
func (m *LocationMutation) AddDeliveryOptionIDs(ids ...pulid.ID) {
	if m.delivery_option == nil {
		m.delivery_option = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *LocationMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *LocationMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// RemoveDeliveryOptionIDs removes the "delivery_option" edge to the DeliveryOption entity by IDs.
func (m *LocationMutation) RemoveDeliveryOptionIDs(ids ...pulid.ID) {
	if m.removeddelivery_option == nil {
		m.removeddelivery_option = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option, ids[i])
		m.removeddelivery_option[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOption returns the removed IDs of the "delivery_option" edge to the DeliveryOption entity.
func (m *LocationMutation) RemovedDeliveryOptionIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
func (m *LocationMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	for id := range m.delivery_option {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *LocationMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
	m.removeddelivery_option = nil
}

// AddColliIDs adds the "colli" edge to the Colli entity by ids.
func (m *LocationMutation) AddColliIDs(ids ...pulid.ID) {
	if m.colli == nil {
		m.colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.colli[ids[i]] = struct{}{}
	}
}

// ClearColli clears the "colli" edge to the Colli entity.
func (m *LocationMutation) ClearColli() {
	m.clearedcolli = true
}

// ColliCleared reports if the "colli" edge to the Colli entity was cleared.
func (m *LocationMutation) ColliCleared() bool {
	return m.clearedcolli
}

// RemoveColliIDs removes the "colli" edge to the Colli entity by IDs.
func (m *LocationMutation) RemoveColliIDs(ids ...pulid.ID) {
	if m.removedcolli == nil {
		m.removedcolli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.colli, ids[i])
		m.removedcolli[ids[i]] = struct{}{}
	}
}

// RemovedColli returns the removed IDs of the "colli" edge to the Colli entity.
func (m *LocationMutation) RemovedColliIDs() (ids []pulid.ID) {
	for id := range m.removedcolli {
		ids = append(ids, id)
	}
	return
}

// ColliIDs returns the "colli" edge IDs in the mutation.
func (m *LocationMutation) ColliIDs() (ids []pulid.ID) {
	for id := range m.colli {
		ids = append(ids, id)
	}
	return
}

// ResetColli resets all changes to the "colli" edge.
func (m *LocationMutation) ResetColli() {
	m.colli = nil
	m.clearedcolli = false
	m.removedcolli = nil
}

// Where appends a list predicates to the LocationMutation builder.
func (m *LocationMutation) Where(ps ...predicate.Location) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Location, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Location).
func (m *LocationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, location.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, location.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case location.FieldTenantID:
		return m.TenantID()
	case location.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case location.FieldTenantID:
		return m.OldTenantID(ctx)
	case location.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Location field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case location.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case location.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Location numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Location nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationMutation) ResetField(name string) error {
	switch name {
	case location.FieldTenantID:
		m.ResetTenantID()
		return nil
	case location.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Location field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.tenant != nil {
		edges = append(edges, location.EdgeTenant)
	}
	if m.address != nil {
		edges = append(edges, location.EdgeAddress)
	}
	if m.location_tags != nil {
		edges = append(edges, location.EdgeLocationTags)
	}
	if m.sender_connection != nil {
		edges = append(edges, location.EdgeSenderConnection)
	}
	if m.pickup_connection != nil {
		edges = append(edges, location.EdgePickupConnection)
	}
	if m.return_connection != nil {
		edges = append(edges, location.EdgeReturnConnection)
	}
	if m.seller_connection != nil {
		edges = append(edges, location.EdgeSellerConnection)
	}
	if m.return_portal != nil {
		edges = append(edges, location.EdgeReturnPortal)
	}
	if m.delivery_option != nil {
		edges = append(edges, location.EdgeDeliveryOption)
	}
	if m.colli != nil {
		edges = append(edges, location.EdgeColli)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	case location.EdgeLocationTags:
		ids := make([]ent.Value, 0, len(m.location_tags))
		for id := range m.location_tags {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeSenderConnection:
		ids := make([]ent.Value, 0, len(m.sender_connection))
		for id := range m.sender_connection {
			ids = append(ids, id)
		}
		return ids
	case location.EdgePickupConnection:
		ids := make([]ent.Value, 0, len(m.pickup_connection))
		for id := range m.pickup_connection {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeReturnConnection:
		ids := make([]ent.Value, 0, len(m.return_connection))
		for id := range m.return_connection {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeSellerConnection:
		ids := make([]ent.Value, 0, len(m.seller_connection))
		for id := range m.seller_connection {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeReturnPortal:
		ids := make([]ent.Value, 0, len(m.return_portal))
		for id := range m.return_portal {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeDeliveryOption:
		ids := make([]ent.Value, 0, len(m.delivery_option))
		for id := range m.delivery_option {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeColli:
		ids := make([]ent.Value, 0, len(m.colli))
		for id := range m.colli {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedlocation_tags != nil {
		edges = append(edges, location.EdgeLocationTags)
	}
	if m.removedsender_connection != nil {
		edges = append(edges, location.EdgeSenderConnection)
	}
	if m.removedpickup_connection != nil {
		edges = append(edges, location.EdgePickupConnection)
	}
	if m.removedreturn_connection != nil {
		edges = append(edges, location.EdgeReturnConnection)
	}
	if m.removedseller_connection != nil {
		edges = append(edges, location.EdgeSellerConnection)
	}
	if m.removedreturn_portal != nil {
		edges = append(edges, location.EdgeReturnPortal)
	}
	if m.removeddelivery_option != nil {
		edges = append(edges, location.EdgeDeliveryOption)
	}
	if m.removedcolli != nil {
		edges = append(edges, location.EdgeColli)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case location.EdgeLocationTags:
		ids := make([]ent.Value, 0, len(m.removedlocation_tags))
		for id := range m.removedlocation_tags {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeSenderConnection:
		ids := make([]ent.Value, 0, len(m.removedsender_connection))
		for id := range m.removedsender_connection {
			ids = append(ids, id)
		}
		return ids
	case location.EdgePickupConnection:
		ids := make([]ent.Value, 0, len(m.removedpickup_connection))
		for id := range m.removedpickup_connection {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeReturnConnection:
		ids := make([]ent.Value, 0, len(m.removedreturn_connection))
		for id := range m.removedreturn_connection {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeSellerConnection:
		ids := make([]ent.Value, 0, len(m.removedseller_connection))
		for id := range m.removedseller_connection {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeReturnPortal:
		ids := make([]ent.Value, 0, len(m.removedreturn_portal))
		for id := range m.removedreturn_portal {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeDeliveryOption:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option))
		for id := range m.removeddelivery_option {
			ids = append(ids, id)
		}
		return ids
	case location.EdgeColli:
		ids := make([]ent.Value, 0, len(m.removedcolli))
		for id := range m.removedcolli {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedtenant {
		edges = append(edges, location.EdgeTenant)
	}
	if m.clearedaddress {
		edges = append(edges, location.EdgeAddress)
	}
	if m.clearedlocation_tags {
		edges = append(edges, location.EdgeLocationTags)
	}
	if m.clearedsender_connection {
		edges = append(edges, location.EdgeSenderConnection)
	}
	if m.clearedpickup_connection {
		edges = append(edges, location.EdgePickupConnection)
	}
	if m.clearedreturn_connection {
		edges = append(edges, location.EdgeReturnConnection)
	}
	if m.clearedseller_connection {
		edges = append(edges, location.EdgeSellerConnection)
	}
	if m.clearedreturn_portal {
		edges = append(edges, location.EdgeReturnPortal)
	}
	if m.cleareddelivery_option {
		edges = append(edges, location.EdgeDeliveryOption)
	}
	if m.clearedcolli {
		edges = append(edges, location.EdgeColli)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationMutation) EdgeCleared(name string) bool {
	switch name {
	case location.EdgeTenant:
		return m.clearedtenant
	case location.EdgeAddress:
		return m.clearedaddress
	case location.EdgeLocationTags:
		return m.clearedlocation_tags
	case location.EdgeSenderConnection:
		return m.clearedsender_connection
	case location.EdgePickupConnection:
		return m.clearedpickup_connection
	case location.EdgeReturnConnection:
		return m.clearedreturn_connection
	case location.EdgeSellerConnection:
		return m.clearedseller_connection
	case location.EdgeReturnPortal:
		return m.clearedreturn_portal
	case location.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case location.EdgeColli:
		return m.clearedcolli
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationMutation) ClearEdge(name string) error {
	switch name {
	case location.EdgeTenant:
		m.ClearTenant()
		return nil
	case location.EdgeAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown Location unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationMutation) ResetEdge(name string) error {
	switch name {
	case location.EdgeTenant:
		m.ResetTenant()
		return nil
	case location.EdgeAddress:
		m.ResetAddress()
		return nil
	case location.EdgeLocationTags:
		m.ResetLocationTags()
		return nil
	case location.EdgeSenderConnection:
		m.ResetSenderConnection()
		return nil
	case location.EdgePickupConnection:
		m.ResetPickupConnection()
		return nil
	case location.EdgeReturnConnection:
		m.ResetReturnConnection()
		return nil
	case location.EdgeSellerConnection:
		m.ResetSellerConnection()
		return nil
	case location.EdgeReturnPortal:
		m.ResetReturnPortal()
		return nil
	case location.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case location.EdgeColli:
		m.ResetColli()
		return nil
	}
	return fmt.Errorf("unknown Location edge %s", name)
}

// LocationTagMutation represents an operation that mutates the LocationTag nodes in the graph.
type LocationTagMutation struct {
	config
	op              Op
	typ             string
	id              *pulid.ID
	label           *string
	internal_id     *string
	clearedFields   map[string]struct{}
	location        map[pulid.ID]struct{}
	removedlocation map[pulid.ID]struct{}
	clearedlocation bool
	done            bool
	oldValue        func(context.Context) (*LocationTag, error)
	predicates      []predicate.LocationTag
}

var _ ent.Mutation = (*LocationTagMutation)(nil)

// locationtagOption allows management of the mutation configuration using functional options.
type locationtagOption func(*LocationTagMutation)

// newLocationTagMutation creates new mutation for the LocationTag entity.
func newLocationTagMutation(c config, op Op, opts ...locationtagOption) *LocationTagMutation {
	m := &LocationTagMutation{
		config:        c,
		op:            op,
		typ:           TypeLocationTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocationTagID sets the ID field of the mutation.
func withLocationTagID(id pulid.ID) locationtagOption {
	return func(m *LocationTagMutation) {
		var (
			err   error
			once  sync.Once
			value *LocationTag
		)
		m.oldValue = func(ctx context.Context) (*LocationTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LocationTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocationTag sets the old LocationTag of the mutation.
func withLocationTag(node *LocationTag) locationtagOption {
	return func(m *LocationTagMutation) {
		m.oldValue = func(context.Context) (*LocationTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocationTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocationTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LocationTag entities.
func (m *LocationTagMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocationTagMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocationTagMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LocationTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *LocationTagMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *LocationTagMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the LocationTag entity.
// If the LocationTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationTagMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *LocationTagMutation) ResetLabel() {
	m.label = nil
}

// SetInternalID sets the "internal_id" field.
func (m *LocationTagMutation) SetInternalID(s string) {
	m.internal_id = &s
}

// InternalID returns the value of the "internal_id" field in the mutation.
func (m *LocationTagMutation) InternalID() (r string, exists bool) {
	v := m.internal_id
	if v == nil {
		return
	}
	return *v, true
}

// OldInternalID returns the old "internal_id" field's value of the LocationTag entity.
// If the LocationTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocationTagMutation) OldInternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInternalID: %w", err)
	}
	return oldValue.InternalID, nil
}

// ResetInternalID resets all changes to the "internal_id" field.
func (m *LocationTagMutation) ResetInternalID() {
	m.internal_id = nil
}

// AddLocationIDs adds the "location" edge to the Location entity by ids.
func (m *LocationTagMutation) AddLocationIDs(ids ...pulid.ID) {
	if m.location == nil {
		m.location = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.location[ids[i]] = struct{}{}
	}
}

// ClearLocation clears the "location" edge to the Location entity.
func (m *LocationTagMutation) ClearLocation() {
	m.clearedlocation = true
}

// LocationCleared reports if the "location" edge to the Location entity was cleared.
func (m *LocationTagMutation) LocationCleared() bool {
	return m.clearedlocation
}

// RemoveLocationIDs removes the "location" edge to the Location entity by IDs.
func (m *LocationTagMutation) RemoveLocationIDs(ids ...pulid.ID) {
	if m.removedlocation == nil {
		m.removedlocation = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.location, ids[i])
		m.removedlocation[ids[i]] = struct{}{}
	}
}

// RemovedLocation returns the removed IDs of the "location" edge to the Location entity.
func (m *LocationTagMutation) RemovedLocationIDs() (ids []pulid.ID) {
	for id := range m.removedlocation {
		ids = append(ids, id)
	}
	return
}

// LocationIDs returns the "location" edge IDs in the mutation.
func (m *LocationTagMutation) LocationIDs() (ids []pulid.ID) {
	for id := range m.location {
		ids = append(ids, id)
	}
	return
}

// ResetLocation resets all changes to the "location" edge.
func (m *LocationTagMutation) ResetLocation() {
	m.location = nil
	m.clearedlocation = false
	m.removedlocation = nil
}

// Where appends a list predicates to the LocationTagMutation builder.
func (m *LocationTagMutation) Where(ps ...predicate.LocationTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocationTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocationTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LocationTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocationTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocationTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LocationTag).
func (m *LocationTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocationTagMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.label != nil {
		fields = append(fields, locationtag.FieldLabel)
	}
	if m.internal_id != nil {
		fields = append(fields, locationtag.FieldInternalID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocationTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case locationtag.FieldLabel:
		return m.Label()
	case locationtag.FieldInternalID:
		return m.InternalID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocationTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case locationtag.FieldLabel:
		return m.OldLabel(ctx)
	case locationtag.FieldInternalID:
		return m.OldInternalID(ctx)
	}
	return nil, fmt.Errorf("unknown LocationTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case locationtag.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case locationtag.FieldInternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInternalID(v)
		return nil
	}
	return fmt.Errorf("unknown LocationTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocationTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocationTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocationTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LocationTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocationTagMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocationTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocationTagMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LocationTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocationTagMutation) ResetField(name string) error {
	switch name {
	case locationtag.FieldLabel:
		m.ResetLabel()
		return nil
	case locationtag.FieldInternalID:
		m.ResetInternalID()
		return nil
	}
	return fmt.Errorf("unknown LocationTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocationTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.location != nil {
		edges = append(edges, locationtag.EdgeLocation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocationTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case locationtag.EdgeLocation:
		ids := make([]ent.Value, 0, len(m.location))
		for id := range m.location {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocationTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedlocation != nil {
		edges = append(edges, locationtag.EdgeLocation)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocationTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case locationtag.EdgeLocation:
		ids := make([]ent.Value, 0, len(m.removedlocation))
		for id := range m.removedlocation {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocationTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlocation {
		edges = append(edges, locationtag.EdgeLocation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocationTagMutation) EdgeCleared(name string) bool {
	switch name {
	case locationtag.EdgeLocation:
		return m.clearedlocation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocationTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LocationTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocationTagMutation) ResetEdge(name string) error {
	switch name {
	case locationtag.EdgeLocation:
		m.ResetLocation()
		return nil
	}
	return fmt.Errorf("unknown LocationTag edge %s", name)
}

// NotificationMutation represents an operation that mutates the Notification nodes in the graph.
type NotificationMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.ID
	name                  *string
	active                *bool
	clearedFields         map[string]struct{}
	tenant                *pulid.ID
	clearedtenant         bool
	connection            *pulid.ID
	clearedconnection     bool
	email_template        *pulid.ID
	clearedemail_template bool
	done                  bool
	oldValue              func(context.Context) (*Notification, error)
	predicates            []predicate.Notification
}

var _ ent.Mutation = (*NotificationMutation)(nil)

// notificationOption allows management of the mutation configuration using functional options.
type notificationOption func(*NotificationMutation)

// newNotificationMutation creates new mutation for the Notification entity.
func newNotificationMutation(c config, op Op, opts ...notificationOption) *NotificationMutation {
	m := &NotificationMutation{
		config:        c,
		op:            op,
		typ:           TypeNotification,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNotificationID sets the ID field of the mutation.
func withNotificationID(id pulid.ID) notificationOption {
	return func(m *NotificationMutation) {
		var (
			err   error
			once  sync.Once
			value *Notification
		)
		m.oldValue = func(ctx context.Context) (*Notification, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Notification.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNotification sets the old Notification of the mutation.
func withNotification(node *Notification) notificationOption {
	return func(m *NotificationMutation) {
		m.oldValue = func(context.Context) (*Notification, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NotificationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NotificationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Notification entities.
func (m *NotificationMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *NotificationMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *NotificationMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Notification.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *NotificationMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *NotificationMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *NotificationMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *NotificationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *NotificationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *NotificationMutation) ResetName() {
	m.name = nil
}

// SetActive sets the "active" field.
func (m *NotificationMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *NotificationMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the Notification entity.
// If the Notification object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *NotificationMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *NotificationMutation) ResetActive() {
	m.active = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *NotificationMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[notification.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *NotificationMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *NotificationMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetConnectionID sets the "connection" edge to the Connection entity by id.
func (m *NotificationMutation) SetConnectionID(id pulid.ID) {
	m.connection = &id
}

// ClearConnection clears the "connection" edge to the Connection entity.
func (m *NotificationMutation) ClearConnection() {
	m.clearedconnection = true
}

// ConnectionCleared reports if the "connection" edge to the Connection entity was cleared.
func (m *NotificationMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionID returns the "connection" edge ID in the mutation.
func (m *NotificationMutation) ConnectionID() (id pulid.ID, exists bool) {
	if m.connection != nil {
		return *m.connection, true
	}
	return
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) ConnectionIDs() (ids []pulid.ID) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *NotificationMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// SetEmailTemplateID sets the "email_template" edge to the EmailTemplate entity by id.
func (m *NotificationMutation) SetEmailTemplateID(id pulid.ID) {
	m.email_template = &id
}

// ClearEmailTemplate clears the "email_template" edge to the EmailTemplate entity.
func (m *NotificationMutation) ClearEmailTemplate() {
	m.clearedemail_template = true
}

// EmailTemplateCleared reports if the "email_template" edge to the EmailTemplate entity was cleared.
func (m *NotificationMutation) EmailTemplateCleared() bool {
	return m.clearedemail_template
}

// EmailTemplateID returns the "email_template" edge ID in the mutation.
func (m *NotificationMutation) EmailTemplateID() (id pulid.ID, exists bool) {
	if m.email_template != nil {
		return *m.email_template, true
	}
	return
}

// EmailTemplateIDs returns the "email_template" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailTemplateID instead. It exists only for internal usage by the builders.
func (m *NotificationMutation) EmailTemplateIDs() (ids []pulid.ID) {
	if id := m.email_template; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailTemplate resets all changes to the "email_template" edge.
func (m *NotificationMutation) ResetEmailTemplate() {
	m.email_template = nil
	m.clearedemail_template = false
}

// Where appends a list predicates to the NotificationMutation builder.
func (m *NotificationMutation) Where(ps ...predicate.Notification) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the NotificationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *NotificationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Notification, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *NotificationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *NotificationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Notification).
func (m *NotificationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *NotificationMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, notification.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, notification.FieldName)
	}
	if m.active != nil {
		fields = append(fields, notification.FieldActive)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *NotificationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case notification.FieldTenantID:
		return m.TenantID()
	case notification.FieldName:
		return m.Name()
	case notification.FieldActive:
		return m.Active()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *NotificationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case notification.FieldTenantID:
		return m.OldTenantID(ctx)
	case notification.FieldName:
		return m.OldName(ctx)
	case notification.FieldActive:
		return m.OldActive(ctx)
	}
	return nil, fmt.Errorf("unknown Notification field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case notification.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case notification.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case notification.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *NotificationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *NotificationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *NotificationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Notification numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *NotificationMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *NotificationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *NotificationMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Notification nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *NotificationMutation) ResetField(name string) error {
	switch name {
	case notification.FieldTenantID:
		m.ResetTenantID()
		return nil
	case notification.FieldName:
		m.ResetName()
		return nil
	case notification.FieldActive:
		m.ResetActive()
		return nil
	}
	return fmt.Errorf("unknown Notification field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *NotificationMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, notification.EdgeTenant)
	}
	if m.connection != nil {
		edges = append(edges, notification.EdgeConnection)
	}
	if m.email_template != nil {
		edges = append(edges, notification.EdgeEmailTemplate)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *NotificationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case notification.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case notification.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	case notification.EdgeEmailTemplate:
		if id := m.email_template; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *NotificationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *NotificationMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *NotificationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, notification.EdgeTenant)
	}
	if m.clearedconnection {
		edges = append(edges, notification.EdgeConnection)
	}
	if m.clearedemail_template {
		edges = append(edges, notification.EdgeEmailTemplate)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *NotificationMutation) EdgeCleared(name string) bool {
	switch name {
	case notification.EdgeTenant:
		return m.clearedtenant
	case notification.EdgeConnection:
		return m.clearedconnection
	case notification.EdgeEmailTemplate:
		return m.clearedemail_template
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *NotificationMutation) ClearEdge(name string) error {
	switch name {
	case notification.EdgeTenant:
		m.ClearTenant()
		return nil
	case notification.EdgeConnection:
		m.ClearConnection()
		return nil
	case notification.EdgeEmailTemplate:
		m.ClearEmailTemplate()
		return nil
	}
	return fmt.Errorf("unknown Notification unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *NotificationMutation) ResetEdge(name string) error {
	switch name {
	case notification.EdgeTenant:
		m.ResetTenant()
		return nil
	case notification.EdgeConnection:
		m.ResetConnection()
		return nil
	case notification.EdgeEmailTemplate:
		m.ResetEmailTemplate()
		return nil
	}
	return fmt.Errorf("unknown Notification edge %s", name)
}

// OTKRequestsMutation represents an operation that mutates the OTKRequests nodes in the graph.
type OTKRequestsMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.ID
	otk           *string
	clearedFields map[string]struct{}
	tenant        *pulid.ID
	clearedtenant bool
	users         *pulid.ID
	clearedusers  bool
	done          bool
	oldValue      func(context.Context) (*OTKRequests, error)
	predicates    []predicate.OTKRequests
}

var _ ent.Mutation = (*OTKRequestsMutation)(nil)

// otkrequestsOption allows management of the mutation configuration using functional options.
type otkrequestsOption func(*OTKRequestsMutation)

// newOTKRequestsMutation creates new mutation for the OTKRequests entity.
func newOTKRequestsMutation(c config, op Op, opts ...otkrequestsOption) *OTKRequestsMutation {
	m := &OTKRequestsMutation{
		config:        c,
		op:            op,
		typ:           TypeOTKRequests,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOTKRequestsID sets the ID field of the mutation.
func withOTKRequestsID(id pulid.ID) otkrequestsOption {
	return func(m *OTKRequestsMutation) {
		var (
			err   error
			once  sync.Once
			value *OTKRequests
		)
		m.oldValue = func(ctx context.Context) (*OTKRequests, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OTKRequests.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOTKRequests sets the old OTKRequests of the mutation.
func withOTKRequests(node *OTKRequests) otkrequestsOption {
	return func(m *OTKRequestsMutation) {
		m.oldValue = func(context.Context) (*OTKRequests, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OTKRequestsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OTKRequestsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OTKRequests entities.
func (m *OTKRequestsMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OTKRequestsMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OTKRequestsMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OTKRequests.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OTKRequestsMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OTKRequestsMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OTKRequests entity.
// If the OTKRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTKRequestsMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OTKRequestsMutation) ResetTenantID() {
	m.tenant = nil
}

// SetOtk sets the "otk" field.
func (m *OTKRequestsMutation) SetOtk(s string) {
	m.otk = &s
}

// Otk returns the value of the "otk" field in the mutation.
func (m *OTKRequestsMutation) Otk() (r string, exists bool) {
	v := m.otk
	if v == nil {
		return
	}
	return *v, true
}

// OldOtk returns the old "otk" field's value of the OTKRequests entity.
// If the OTKRequests object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OTKRequestsMutation) OldOtk(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOtk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOtk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOtk: %w", err)
	}
	return oldValue.Otk, nil
}

// ResetOtk resets all changes to the "otk" field.
func (m *OTKRequestsMutation) ResetOtk() {
	m.otk = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OTKRequestsMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[otkrequests.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OTKRequestsMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OTKRequestsMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OTKRequestsMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *OTKRequestsMutation) SetUsersID(id pulid.ID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *OTKRequestsMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *OTKRequestsMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *OTKRequestsMutation) UsersID() (id pulid.ID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *OTKRequestsMutation) UsersIDs() (ids []pulid.ID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *OTKRequestsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the OTKRequestsMutation builder.
func (m *OTKRequestsMutation) Where(ps ...predicate.OTKRequests) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OTKRequestsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OTKRequestsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OTKRequests, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OTKRequestsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OTKRequestsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OTKRequests).
func (m *OTKRequestsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OTKRequestsMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, otkrequests.FieldTenantID)
	}
	if m.otk != nil {
		fields = append(fields, otkrequests.FieldOtk)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OTKRequestsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case otkrequests.FieldTenantID:
		return m.TenantID()
	case otkrequests.FieldOtk:
		return m.Otk()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OTKRequestsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case otkrequests.FieldTenantID:
		return m.OldTenantID(ctx)
	case otkrequests.FieldOtk:
		return m.OldOtk(ctx)
	}
	return nil, fmt.Errorf("unknown OTKRequests field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OTKRequestsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case otkrequests.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case otkrequests.FieldOtk:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOtk(v)
		return nil
	}
	return fmt.Errorf("unknown OTKRequests field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OTKRequestsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OTKRequestsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OTKRequestsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OTKRequests numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OTKRequestsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OTKRequestsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OTKRequestsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OTKRequests nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OTKRequestsMutation) ResetField(name string) error {
	switch name {
	case otkrequests.FieldTenantID:
		m.ResetTenantID()
		return nil
	case otkrequests.FieldOtk:
		m.ResetOtk()
		return nil
	}
	return fmt.Errorf("unknown OTKRequests field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OTKRequestsMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, otkrequests.EdgeTenant)
	}
	if m.users != nil {
		edges = append(edges, otkrequests.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OTKRequestsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case otkrequests.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case otkrequests.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OTKRequestsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OTKRequestsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OTKRequestsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, otkrequests.EdgeTenant)
	}
	if m.clearedusers {
		edges = append(edges, otkrequests.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OTKRequestsMutation) EdgeCleared(name string) bool {
	switch name {
	case otkrequests.EdgeTenant:
		return m.clearedtenant
	case otkrequests.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OTKRequestsMutation) ClearEdge(name string) error {
	switch name {
	case otkrequests.EdgeTenant:
		m.ClearTenant()
		return nil
	case otkrequests.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown OTKRequests unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OTKRequestsMutation) ResetEdge(name string) error {
	switch name {
	case otkrequests.EdgeTenant:
		m.ResetTenant()
		return nil
	case otkrequests.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown OTKRequests edge %s", name)
}

// OrderMutation represents an operation that mutates the Order nodes in the graph.
type OrderMutation struct {
	config
	op                                             Op
	typ                                            string
	id                                             *pulid.ID
	order_public_id                                *string
	external_id                                    *string
	comment_internal                               *string
	comment_external                               *string
	created_at                                     *time.Time
	email_sync_confirmation_at                     *time.Time
	status                                         *order.Status
	note_attributes                                *fieldjson.NoteAttributes
	clearedFields                                  map[string]struct{}
	tenant                                         *pulid.ID
	clearedtenant                                  bool
	order_history                                  map[pulid.ID]struct{}
	removedorder_history                           map[pulid.ID]struct{}
	clearedorder_history                           bool
	connection                                     *pulid.ID
	clearedconnection                              bool
	colli                                          map[pulid.ID]struct{}
	removedcolli                                   map[pulid.ID]struct{}
	clearedcolli                                   bool
	return_colli                                   map[pulid.ID]struct{}
	removedreturn_colli                            map[pulid.ID]struct{}
	clearedreturn_colli                            bool
	hypothesis_test_delivery_option_request        *pulid.ID
	clearedhypothesis_test_delivery_option_request bool
	pallet                                         *pulid.ID
	clearedpallet                                  bool
	consolidation                                  *pulid.ID
	clearedconsolidation                           bool
	done                                           bool
	oldValue                                       func(context.Context) (*Order, error)
	predicates                                     []predicate.Order
}

var _ ent.Mutation = (*OrderMutation)(nil)

// orderOption allows management of the mutation configuration using functional options.
type orderOption func(*OrderMutation)

// newOrderMutation creates new mutation for the Order entity.
func newOrderMutation(c config, op Op, opts ...orderOption) *OrderMutation {
	m := &OrderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrder,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderID sets the ID field of the mutation.
func withOrderID(id pulid.ID) orderOption {
	return func(m *OrderMutation) {
		var (
			err   error
			once  sync.Once
			value *Order
		)
		m.oldValue = func(ctx context.Context) (*Order, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Order.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrder sets the old Order of the mutation.
func withOrder(node *Order) orderOption {
	return func(m *OrderMutation) {
		m.oldValue = func(context.Context) (*Order, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Order entities.
func (m *OrderMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Order.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OrderMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OrderMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OrderMutation) ResetTenantID() {
	m.tenant = nil
}

// SetOrderPublicID sets the "order_public_id" field.
func (m *OrderMutation) SetOrderPublicID(s string) {
	m.order_public_id = &s
}

// OrderPublicID returns the value of the "order_public_id" field in the mutation.
func (m *OrderMutation) OrderPublicID() (r string, exists bool) {
	v := m.order_public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOrderPublicID returns the old "order_public_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldOrderPublicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrderPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrderPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrderPublicID: %w", err)
	}
	return oldValue.OrderPublicID, nil
}

// ResetOrderPublicID resets all changes to the "order_public_id" field.
func (m *OrderMutation) ResetOrderPublicID() {
	m.order_public_id = nil
}

// SetExternalID sets the "external_id" field.
func (m *OrderMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *OrderMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *OrderMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[order.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *OrderMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[order.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *OrderMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, order.FieldExternalID)
}

// SetCommentInternal sets the "comment_internal" field.
func (m *OrderMutation) SetCommentInternal(s string) {
	m.comment_internal = &s
}

// CommentInternal returns the value of the "comment_internal" field in the mutation.
func (m *OrderMutation) CommentInternal() (r string, exists bool) {
	v := m.comment_internal
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentInternal returns the old "comment_internal" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCommentInternal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentInternal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentInternal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentInternal: %w", err)
	}
	return oldValue.CommentInternal, nil
}

// ClearCommentInternal clears the value of the "comment_internal" field.
func (m *OrderMutation) ClearCommentInternal() {
	m.comment_internal = nil
	m.clearedFields[order.FieldCommentInternal] = struct{}{}
}

// CommentInternalCleared returns if the "comment_internal" field was cleared in this mutation.
func (m *OrderMutation) CommentInternalCleared() bool {
	_, ok := m.clearedFields[order.FieldCommentInternal]
	return ok
}

// ResetCommentInternal resets all changes to the "comment_internal" field.
func (m *OrderMutation) ResetCommentInternal() {
	m.comment_internal = nil
	delete(m.clearedFields, order.FieldCommentInternal)
}

// SetCommentExternal sets the "comment_external" field.
func (m *OrderMutation) SetCommentExternal(s string) {
	m.comment_external = &s
}

// CommentExternal returns the value of the "comment_external" field in the mutation.
func (m *OrderMutation) CommentExternal() (r string, exists bool) {
	v := m.comment_external
	if v == nil {
		return
	}
	return *v, true
}

// OldCommentExternal returns the old "comment_external" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCommentExternal(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCommentExternal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCommentExternal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCommentExternal: %w", err)
	}
	return oldValue.CommentExternal, nil
}

// ClearCommentExternal clears the value of the "comment_external" field.
func (m *OrderMutation) ClearCommentExternal() {
	m.comment_external = nil
	m.clearedFields[order.FieldCommentExternal] = struct{}{}
}

// CommentExternalCleared returns if the "comment_external" field was cleared in this mutation.
func (m *OrderMutation) CommentExternalCleared() bool {
	_, ok := m.clearedFields[order.FieldCommentExternal]
	return ok
}

// ResetCommentExternal resets all changes to the "comment_external" field.
func (m *OrderMutation) ResetCommentExternal() {
	m.comment_external = nil
	delete(m.clearedFields, order.FieldCommentExternal)
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetEmailSyncConfirmationAt sets the "email_sync_confirmation_at" field.
func (m *OrderMutation) SetEmailSyncConfirmationAt(t time.Time) {
	m.email_sync_confirmation_at = &t
}

// EmailSyncConfirmationAt returns the value of the "email_sync_confirmation_at" field in the mutation.
func (m *OrderMutation) EmailSyncConfirmationAt() (r time.Time, exists bool) {
	v := m.email_sync_confirmation_at
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailSyncConfirmationAt returns the old "email_sync_confirmation_at" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldEmailSyncConfirmationAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailSyncConfirmationAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailSyncConfirmationAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailSyncConfirmationAt: %w", err)
	}
	return oldValue.EmailSyncConfirmationAt, nil
}

// ClearEmailSyncConfirmationAt clears the value of the "email_sync_confirmation_at" field.
func (m *OrderMutation) ClearEmailSyncConfirmationAt() {
	m.email_sync_confirmation_at = nil
	m.clearedFields[order.FieldEmailSyncConfirmationAt] = struct{}{}
}

// EmailSyncConfirmationAtCleared returns if the "email_sync_confirmation_at" field was cleared in this mutation.
func (m *OrderMutation) EmailSyncConfirmationAtCleared() bool {
	_, ok := m.clearedFields[order.FieldEmailSyncConfirmationAt]
	return ok
}

// ResetEmailSyncConfirmationAt resets all changes to the "email_sync_confirmation_at" field.
func (m *OrderMutation) ResetEmailSyncConfirmationAt() {
	m.email_sync_confirmation_at = nil
	delete(m.clearedFields, order.FieldEmailSyncConfirmationAt)
}

// SetStatus sets the "status" field.
func (m *OrderMutation) SetStatus(o order.Status) {
	m.status = &o
}

// Status returns the value of the "status" field in the mutation.
func (m *OrderMutation) Status() (r order.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldStatus(ctx context.Context) (v order.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *OrderMutation) ResetStatus() {
	m.status = nil
}

// SetNoteAttributes sets the "note_attributes" field.
func (m *OrderMutation) SetNoteAttributes(fa fieldjson.NoteAttributes) {
	m.note_attributes = &fa
}

// NoteAttributes returns the value of the "note_attributes" field in the mutation.
func (m *OrderMutation) NoteAttributes() (r fieldjson.NoteAttributes, exists bool) {
	v := m.note_attributes
	if v == nil {
		return
	}
	return *v, true
}

// OldNoteAttributes returns the old "note_attributes" field's value of the Order entity.
// If the Order object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderMutation) OldNoteAttributes(ctx context.Context) (v fieldjson.NoteAttributes, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNoteAttributes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNoteAttributes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNoteAttributes: %w", err)
	}
	return oldValue.NoteAttributes, nil
}

// ClearNoteAttributes clears the value of the "note_attributes" field.
func (m *OrderMutation) ClearNoteAttributes() {
	m.note_attributes = nil
	m.clearedFields[order.FieldNoteAttributes] = struct{}{}
}

// NoteAttributesCleared returns if the "note_attributes" field was cleared in this mutation.
func (m *OrderMutation) NoteAttributesCleared() bool {
	_, ok := m.clearedFields[order.FieldNoteAttributes]
	return ok
}

// ResetNoteAttributes resets all changes to the "note_attributes" field.
func (m *OrderMutation) ResetNoteAttributes() {
	m.note_attributes = nil
	delete(m.clearedFields, order.FieldNoteAttributes)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OrderMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[order.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OrderMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OrderMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddOrderHistoryIDs adds the "order_history" edge to the OrderHistory entity by ids.
func (m *OrderMutation) AddOrderHistoryIDs(ids ...pulid.ID) {
	if m.order_history == nil {
		m.order_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.order_history[ids[i]] = struct{}{}
	}
}

// ClearOrderHistory clears the "order_history" edge to the OrderHistory entity.
func (m *OrderMutation) ClearOrderHistory() {
	m.clearedorder_history = true
}

// OrderHistoryCleared reports if the "order_history" edge to the OrderHistory entity was cleared.
func (m *OrderMutation) OrderHistoryCleared() bool {
	return m.clearedorder_history
}

// RemoveOrderHistoryIDs removes the "order_history" edge to the OrderHistory entity by IDs.
func (m *OrderMutation) RemoveOrderHistoryIDs(ids ...pulid.ID) {
	if m.removedorder_history == nil {
		m.removedorder_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.order_history, ids[i])
		m.removedorder_history[ids[i]] = struct{}{}
	}
}

// RemovedOrderHistory returns the removed IDs of the "order_history" edge to the OrderHistory entity.
func (m *OrderMutation) RemovedOrderHistoryIDs() (ids []pulid.ID) {
	for id := range m.removedorder_history {
		ids = append(ids, id)
	}
	return
}

// OrderHistoryIDs returns the "order_history" edge IDs in the mutation.
func (m *OrderMutation) OrderHistoryIDs() (ids []pulid.ID) {
	for id := range m.order_history {
		ids = append(ids, id)
	}
	return
}

// ResetOrderHistory resets all changes to the "order_history" edge.
func (m *OrderMutation) ResetOrderHistory() {
	m.order_history = nil
	m.clearedorder_history = false
	m.removedorder_history = nil
}

// SetConnectionID sets the "connection" edge to the Connection entity by id.
func (m *OrderMutation) SetConnectionID(id pulid.ID) {
	m.connection = &id
}

// ClearConnection clears the "connection" edge to the Connection entity.
func (m *OrderMutation) ClearConnection() {
	m.clearedconnection = true
}

// ConnectionCleared reports if the "connection" edge to the Connection entity was cleared.
func (m *OrderMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionID returns the "connection" edge ID in the mutation.
func (m *OrderMutation) ConnectionID() (id pulid.ID, exists bool) {
	if m.connection != nil {
		return *m.connection, true
	}
	return
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) ConnectionIDs() (ids []pulid.ID) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *OrderMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// AddColliIDs adds the "colli" edge to the Colli entity by ids.
func (m *OrderMutation) AddColliIDs(ids ...pulid.ID) {
	if m.colli == nil {
		m.colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.colli[ids[i]] = struct{}{}
	}
}

// ClearColli clears the "colli" edge to the Colli entity.
func (m *OrderMutation) ClearColli() {
	m.clearedcolli = true
}

// ColliCleared reports if the "colli" edge to the Colli entity was cleared.
func (m *OrderMutation) ColliCleared() bool {
	return m.clearedcolli
}

// RemoveColliIDs removes the "colli" edge to the Colli entity by IDs.
func (m *OrderMutation) RemoveColliIDs(ids ...pulid.ID) {
	if m.removedcolli == nil {
		m.removedcolli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.colli, ids[i])
		m.removedcolli[ids[i]] = struct{}{}
	}
}

// RemovedColli returns the removed IDs of the "colli" edge to the Colli entity.
func (m *OrderMutation) RemovedColliIDs() (ids []pulid.ID) {
	for id := range m.removedcolli {
		ids = append(ids, id)
	}
	return
}

// ColliIDs returns the "colli" edge IDs in the mutation.
func (m *OrderMutation) ColliIDs() (ids []pulid.ID) {
	for id := range m.colli {
		ids = append(ids, id)
	}
	return
}

// ResetColli resets all changes to the "colli" edge.
func (m *OrderMutation) ResetColli() {
	m.colli = nil
	m.clearedcolli = false
	m.removedcolli = nil
}

// AddReturnColliIDs adds the "return_colli" edge to the ReturnColli entity by ids.
func (m *OrderMutation) AddReturnColliIDs(ids ...pulid.ID) {
	if m.return_colli == nil {
		m.return_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_colli[ids[i]] = struct{}{}
	}
}

// ClearReturnColli clears the "return_colli" edge to the ReturnColli entity.
func (m *OrderMutation) ClearReturnColli() {
	m.clearedreturn_colli = true
}

// ReturnColliCleared reports if the "return_colli" edge to the ReturnColli entity was cleared.
func (m *OrderMutation) ReturnColliCleared() bool {
	return m.clearedreturn_colli
}

// RemoveReturnColliIDs removes the "return_colli" edge to the ReturnColli entity by IDs.
func (m *OrderMutation) RemoveReturnColliIDs(ids ...pulid.ID) {
	if m.removedreturn_colli == nil {
		m.removedreturn_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_colli, ids[i])
		m.removedreturn_colli[ids[i]] = struct{}{}
	}
}

// RemovedReturnColli returns the removed IDs of the "return_colli" edge to the ReturnColli entity.
func (m *OrderMutation) RemovedReturnColliIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_colli {
		ids = append(ids, id)
	}
	return
}

// ReturnColliIDs returns the "return_colli" edge IDs in the mutation.
func (m *OrderMutation) ReturnColliIDs() (ids []pulid.ID) {
	for id := range m.return_colli {
		ids = append(ids, id)
	}
	return
}

// ResetReturnColli resets all changes to the "return_colli" edge.
func (m *OrderMutation) ResetReturnColli() {
	m.return_colli = nil
	m.clearedreturn_colli = false
	m.removedreturn_colli = nil
}

// SetHypothesisTestDeliveryOptionRequestID sets the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity by id.
func (m *OrderMutation) SetHypothesisTestDeliveryOptionRequestID(id pulid.ID) {
	m.hypothesis_test_delivery_option_request = &id
}

// ClearHypothesisTestDeliveryOptionRequest clears the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity.
func (m *OrderMutation) ClearHypothesisTestDeliveryOptionRequest() {
	m.clearedhypothesis_test_delivery_option_request = true
}

// HypothesisTestDeliveryOptionRequestCleared reports if the "hypothesis_test_delivery_option_request" edge to the HypothesisTestDeliveryOptionRequest entity was cleared.
func (m *OrderMutation) HypothesisTestDeliveryOptionRequestCleared() bool {
	return m.clearedhypothesis_test_delivery_option_request
}

// HypothesisTestDeliveryOptionRequestID returns the "hypothesis_test_delivery_option_request" edge ID in the mutation.
func (m *OrderMutation) HypothesisTestDeliveryOptionRequestID() (id pulid.ID, exists bool) {
	if m.hypothesis_test_delivery_option_request != nil {
		return *m.hypothesis_test_delivery_option_request, true
	}
	return
}

// HypothesisTestDeliveryOptionRequestIDs returns the "hypothesis_test_delivery_option_request" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// HypothesisTestDeliveryOptionRequestID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) HypothesisTestDeliveryOptionRequestIDs() (ids []pulid.ID) {
	if id := m.hypothesis_test_delivery_option_request; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHypothesisTestDeliveryOptionRequest resets all changes to the "hypothesis_test_delivery_option_request" edge.
func (m *OrderMutation) ResetHypothesisTestDeliveryOptionRequest() {
	m.hypothesis_test_delivery_option_request = nil
	m.clearedhypothesis_test_delivery_option_request = false
}

// SetPalletID sets the "pallet" edge to the Pallet entity by id.
func (m *OrderMutation) SetPalletID(id pulid.ID) {
	m.pallet = &id
}

// ClearPallet clears the "pallet" edge to the Pallet entity.
func (m *OrderMutation) ClearPallet() {
	m.clearedpallet = true
}

// PalletCleared reports if the "pallet" edge to the Pallet entity was cleared.
func (m *OrderMutation) PalletCleared() bool {
	return m.clearedpallet
}

// PalletID returns the "pallet" edge ID in the mutation.
func (m *OrderMutation) PalletID() (id pulid.ID, exists bool) {
	if m.pallet != nil {
		return *m.pallet, true
	}
	return
}

// PalletIDs returns the "pallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PalletID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) PalletIDs() (ids []pulid.ID) {
	if id := m.pallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPallet resets all changes to the "pallet" edge.
func (m *OrderMutation) ResetPallet() {
	m.pallet = nil
	m.clearedpallet = false
}

// SetConsolidationID sets the "consolidation" edge to the Consolidation entity by id.
func (m *OrderMutation) SetConsolidationID(id pulid.ID) {
	m.consolidation = &id
}

// ClearConsolidation clears the "consolidation" edge to the Consolidation entity.
func (m *OrderMutation) ClearConsolidation() {
	m.clearedconsolidation = true
}

// ConsolidationCleared reports if the "consolidation" edge to the Consolidation entity was cleared.
func (m *OrderMutation) ConsolidationCleared() bool {
	return m.clearedconsolidation
}

// ConsolidationID returns the "consolidation" edge ID in the mutation.
func (m *OrderMutation) ConsolidationID() (id pulid.ID, exists bool) {
	if m.consolidation != nil {
		return *m.consolidation, true
	}
	return
}

// ConsolidationIDs returns the "consolidation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConsolidationID instead. It exists only for internal usage by the builders.
func (m *OrderMutation) ConsolidationIDs() (ids []pulid.ID) {
	if id := m.consolidation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConsolidation resets all changes to the "consolidation" edge.
func (m *OrderMutation) ResetConsolidation() {
	m.consolidation = nil
	m.clearedconsolidation = false
}

// Where appends a list predicates to the OrderMutation builder.
func (m *OrderMutation) Where(ps ...predicate.Order) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Order, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Order).
func (m *OrderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.tenant != nil {
		fields = append(fields, order.FieldTenantID)
	}
	if m.order_public_id != nil {
		fields = append(fields, order.FieldOrderPublicID)
	}
	if m.external_id != nil {
		fields = append(fields, order.FieldExternalID)
	}
	if m.comment_internal != nil {
		fields = append(fields, order.FieldCommentInternal)
	}
	if m.comment_external != nil {
		fields = append(fields, order.FieldCommentExternal)
	}
	if m.created_at != nil {
		fields = append(fields, order.FieldCreatedAt)
	}
	if m.email_sync_confirmation_at != nil {
		fields = append(fields, order.FieldEmailSyncConfirmationAt)
	}
	if m.status != nil {
		fields = append(fields, order.FieldStatus)
	}
	if m.note_attributes != nil {
		fields = append(fields, order.FieldNoteAttributes)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case order.FieldTenantID:
		return m.TenantID()
	case order.FieldOrderPublicID:
		return m.OrderPublicID()
	case order.FieldExternalID:
		return m.ExternalID()
	case order.FieldCommentInternal:
		return m.CommentInternal()
	case order.FieldCommentExternal:
		return m.CommentExternal()
	case order.FieldCreatedAt:
		return m.CreatedAt()
	case order.FieldEmailSyncConfirmationAt:
		return m.EmailSyncConfirmationAt()
	case order.FieldStatus:
		return m.Status()
	case order.FieldNoteAttributes:
		return m.NoteAttributes()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case order.FieldTenantID:
		return m.OldTenantID(ctx)
	case order.FieldOrderPublicID:
		return m.OldOrderPublicID(ctx)
	case order.FieldExternalID:
		return m.OldExternalID(ctx)
	case order.FieldCommentInternal:
		return m.OldCommentInternal(ctx)
	case order.FieldCommentExternal:
		return m.OldCommentExternal(ctx)
	case order.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case order.FieldEmailSyncConfirmationAt:
		return m.OldEmailSyncConfirmationAt(ctx)
	case order.FieldStatus:
		return m.OldStatus(ctx)
	case order.FieldNoteAttributes:
		return m.OldNoteAttributes(ctx)
	}
	return nil, fmt.Errorf("unknown Order field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case order.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case order.FieldOrderPublicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrderPublicID(v)
		return nil
	case order.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case order.FieldCommentInternal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentInternal(v)
		return nil
	case order.FieldCommentExternal:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCommentExternal(v)
		return nil
	case order.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case order.FieldEmailSyncConfirmationAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailSyncConfirmationAt(v)
		return nil
	case order.FieldStatus:
		v, ok := value.(order.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case order.FieldNoteAttributes:
		v, ok := value.(fieldjson.NoteAttributes)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNoteAttributes(v)
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Order numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(order.FieldExternalID) {
		fields = append(fields, order.FieldExternalID)
	}
	if m.FieldCleared(order.FieldCommentInternal) {
		fields = append(fields, order.FieldCommentInternal)
	}
	if m.FieldCleared(order.FieldCommentExternal) {
		fields = append(fields, order.FieldCommentExternal)
	}
	if m.FieldCleared(order.FieldEmailSyncConfirmationAt) {
		fields = append(fields, order.FieldEmailSyncConfirmationAt)
	}
	if m.FieldCleared(order.FieldNoteAttributes) {
		fields = append(fields, order.FieldNoteAttributes)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderMutation) ClearField(name string) error {
	switch name {
	case order.FieldExternalID:
		m.ClearExternalID()
		return nil
	case order.FieldCommentInternal:
		m.ClearCommentInternal()
		return nil
	case order.FieldCommentExternal:
		m.ClearCommentExternal()
		return nil
	case order.FieldEmailSyncConfirmationAt:
		m.ClearEmailSyncConfirmationAt()
		return nil
	case order.FieldNoteAttributes:
		m.ClearNoteAttributes()
		return nil
	}
	return fmt.Errorf("unknown Order nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderMutation) ResetField(name string) error {
	switch name {
	case order.FieldTenantID:
		m.ResetTenantID()
		return nil
	case order.FieldOrderPublicID:
		m.ResetOrderPublicID()
		return nil
	case order.FieldExternalID:
		m.ResetExternalID()
		return nil
	case order.FieldCommentInternal:
		m.ResetCommentInternal()
		return nil
	case order.FieldCommentExternal:
		m.ResetCommentExternal()
		return nil
	case order.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case order.FieldEmailSyncConfirmationAt:
		m.ResetEmailSyncConfirmationAt()
		return nil
	case order.FieldStatus:
		m.ResetStatus()
		return nil
	case order.FieldNoteAttributes:
		m.ResetNoteAttributes()
		return nil
	}
	return fmt.Errorf("unknown Order field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.tenant != nil {
		edges = append(edges, order.EdgeTenant)
	}
	if m.order_history != nil {
		edges = append(edges, order.EdgeOrderHistory)
	}
	if m.connection != nil {
		edges = append(edges, order.EdgeConnection)
	}
	if m.colli != nil {
		edges = append(edges, order.EdgeColli)
	}
	if m.return_colli != nil {
		edges = append(edges, order.EdgeReturnColli)
	}
	if m.hypothesis_test_delivery_option_request != nil {
		edges = append(edges, order.EdgeHypothesisTestDeliveryOptionRequest)
	}
	if m.pallet != nil {
		edges = append(edges, order.EdgePallet)
	}
	if m.consolidation != nil {
		edges = append(edges, order.EdgeConsolidation)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeOrderHistory:
		ids := make([]ent.Value, 0, len(m.order_history))
		for id := range m.order_history {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeColli:
		ids := make([]ent.Value, 0, len(m.colli))
		for id := range m.colli {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeReturnColli:
		ids := make([]ent.Value, 0, len(m.return_colli))
		for id := range m.return_colli {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeHypothesisTestDeliveryOptionRequest:
		if id := m.hypothesis_test_delivery_option_request; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgePallet:
		if id := m.pallet; id != nil {
			return []ent.Value{*id}
		}
	case order.EdgeConsolidation:
		if id := m.consolidation; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedorder_history != nil {
		edges = append(edges, order.EdgeOrderHistory)
	}
	if m.removedcolli != nil {
		edges = append(edges, order.EdgeColli)
	}
	if m.removedreturn_colli != nil {
		edges = append(edges, order.EdgeReturnColli)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case order.EdgeOrderHistory:
		ids := make([]ent.Value, 0, len(m.removedorder_history))
		for id := range m.removedorder_history {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeColli:
		ids := make([]ent.Value, 0, len(m.removedcolli))
		for id := range m.removedcolli {
			ids = append(ids, id)
		}
		return ids
	case order.EdgeReturnColli:
		ids := make([]ent.Value, 0, len(m.removedreturn_colli))
		for id := range m.removedreturn_colli {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedtenant {
		edges = append(edges, order.EdgeTenant)
	}
	if m.clearedorder_history {
		edges = append(edges, order.EdgeOrderHistory)
	}
	if m.clearedconnection {
		edges = append(edges, order.EdgeConnection)
	}
	if m.clearedcolli {
		edges = append(edges, order.EdgeColli)
	}
	if m.clearedreturn_colli {
		edges = append(edges, order.EdgeReturnColli)
	}
	if m.clearedhypothesis_test_delivery_option_request {
		edges = append(edges, order.EdgeHypothesisTestDeliveryOptionRequest)
	}
	if m.clearedpallet {
		edges = append(edges, order.EdgePallet)
	}
	if m.clearedconsolidation {
		edges = append(edges, order.EdgeConsolidation)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderMutation) EdgeCleared(name string) bool {
	switch name {
	case order.EdgeTenant:
		return m.clearedtenant
	case order.EdgeOrderHistory:
		return m.clearedorder_history
	case order.EdgeConnection:
		return m.clearedconnection
	case order.EdgeColli:
		return m.clearedcolli
	case order.EdgeReturnColli:
		return m.clearedreturn_colli
	case order.EdgeHypothesisTestDeliveryOptionRequest:
		return m.clearedhypothesis_test_delivery_option_request
	case order.EdgePallet:
		return m.clearedpallet
	case order.EdgeConsolidation:
		return m.clearedconsolidation
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderMutation) ClearEdge(name string) error {
	switch name {
	case order.EdgeTenant:
		m.ClearTenant()
		return nil
	case order.EdgeConnection:
		m.ClearConnection()
		return nil
	case order.EdgeHypothesisTestDeliveryOptionRequest:
		m.ClearHypothesisTestDeliveryOptionRequest()
		return nil
	case order.EdgePallet:
		m.ClearPallet()
		return nil
	case order.EdgeConsolidation:
		m.ClearConsolidation()
		return nil
	}
	return fmt.Errorf("unknown Order unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderMutation) ResetEdge(name string) error {
	switch name {
	case order.EdgeTenant:
		m.ResetTenant()
		return nil
	case order.EdgeOrderHistory:
		m.ResetOrderHistory()
		return nil
	case order.EdgeConnection:
		m.ResetConnection()
		return nil
	case order.EdgeColli:
		m.ResetColli()
		return nil
	case order.EdgeReturnColli:
		m.ResetReturnColli()
		return nil
	case order.EdgeHypothesisTestDeliveryOptionRequest:
		m.ResetHypothesisTestDeliveryOptionRequest()
		return nil
	case order.EdgePallet:
		m.ResetPallet()
		return nil
	case order.EdgeConsolidation:
		m.ResetConsolidation()
		return nil
	}
	return fmt.Errorf("unknown Order edge %s", name)
}

// OrderHistoryMutation represents an operation that mutates the OrderHistory nodes in the graph.
type OrderHistoryMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.ID
	description           *string
	_type                 *orderhistory.Type
	clearedFields         map[string]struct{}
	change_history        *pulid.ID
	clearedchange_history bool
	tenant                *pulid.ID
	clearedtenant         bool
	_order                *pulid.ID
	cleared_order         bool
	done                  bool
	oldValue              func(context.Context) (*OrderHistory, error)
	predicates            []predicate.OrderHistory
}

var _ ent.Mutation = (*OrderHistoryMutation)(nil)

// orderhistoryOption allows management of the mutation configuration using functional options.
type orderhistoryOption func(*OrderHistoryMutation)

// newOrderHistoryMutation creates new mutation for the OrderHistory entity.
func newOrderHistoryMutation(c config, op Op, opts ...orderhistoryOption) *OrderHistoryMutation {
	m := &OrderHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderHistoryID sets the ID field of the mutation.
func withOrderHistoryID(id pulid.ID) orderhistoryOption {
	return func(m *OrderHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderHistory
		)
		m.oldValue = func(ctx context.Context) (*OrderHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderHistory sets the old OrderHistory of the mutation.
func withOrderHistory(node *OrderHistory) orderhistoryOption {
	return func(m *OrderHistoryMutation) {
		m.oldValue = func(context.Context) (*OrderHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderHistory entities.
func (m *OrderHistoryMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderHistoryMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderHistoryMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OrderHistoryMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OrderHistoryMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OrderHistoryMutation) ResetTenantID() {
	m.tenant = nil
}

// SetDescription sets the "description" field.
func (m *OrderHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *OrderHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *OrderHistoryMutation) ResetDescription() {
	m.description = nil
}

// SetType sets the "type" field.
func (m *OrderHistoryMutation) SetType(o orderhistory.Type) {
	m._type = &o
}

// GetType returns the value of the "type" field in the mutation.
func (m *OrderHistoryMutation) GetType() (r orderhistory.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the OrderHistory entity.
// If the OrderHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderHistoryMutation) OldType(ctx context.Context) (v orderhistory.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *OrderHistoryMutation) ResetType() {
	m._type = nil
}

// SetChangeHistoryID sets the "change_history" edge to the ChangeHistory entity by id.
func (m *OrderHistoryMutation) SetChangeHistoryID(id pulid.ID) {
	m.change_history = &id
}

// ClearChangeHistory clears the "change_history" edge to the ChangeHistory entity.
func (m *OrderHistoryMutation) ClearChangeHistory() {
	m.clearedchange_history = true
}

// ChangeHistoryCleared reports if the "change_history" edge to the ChangeHistory entity was cleared.
func (m *OrderHistoryMutation) ChangeHistoryCleared() bool {
	return m.clearedchange_history
}

// ChangeHistoryID returns the "change_history" edge ID in the mutation.
func (m *OrderHistoryMutation) ChangeHistoryID() (id pulid.ID, exists bool) {
	if m.change_history != nil {
		return *m.change_history, true
	}
	return
}

// ChangeHistoryIDs returns the "change_history" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChangeHistoryID instead. It exists only for internal usage by the builders.
func (m *OrderHistoryMutation) ChangeHistoryIDs() (ids []pulid.ID) {
	if id := m.change_history; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChangeHistory resets all changes to the "change_history" edge.
func (m *OrderHistoryMutation) ResetChangeHistory() {
	m.change_history = nil
	m.clearedchange_history = false
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OrderHistoryMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[orderhistory.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OrderHistoryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OrderHistoryMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OrderHistoryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetOrderID sets the "order" edge to the Order entity by id.
func (m *OrderHistoryMutation) SetOrderID(id pulid.ID) {
	m._order = &id
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *OrderHistoryMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *OrderHistoryMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderID returns the "order" edge ID in the mutation.
func (m *OrderHistoryMutation) OrderID() (id pulid.ID, exists bool) {
	if m._order != nil {
		return *m._order, true
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *OrderHistoryMutation) OrderIDs() (ids []pulid.ID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *OrderHistoryMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// Where appends a list predicates to the OrderHistoryMutation builder.
func (m *OrderHistoryMutation) Where(ps ...predicate.OrderHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderHistory).
func (m *OrderHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderHistoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, orderhistory.FieldTenantID)
	}
	if m.description != nil {
		fields = append(fields, orderhistory.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, orderhistory.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderhistory.FieldTenantID:
		return m.TenantID()
	case orderhistory.FieldDescription:
		return m.Description()
	case orderhistory.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderhistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case orderhistory.FieldDescription:
		return m.OldDescription(ctx)
	case orderhistory.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown OrderHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderhistory.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case orderhistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case orderhistory.FieldType:
		v, ok := value.(orderhistory.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown OrderHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown OrderHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderHistoryMutation) ResetField(name string) error {
	switch name {
	case orderhistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case orderhistory.FieldDescription:
		m.ResetDescription()
		return nil
	case orderhistory.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown OrderHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.change_history != nil {
		edges = append(edges, orderhistory.EdgeChangeHistory)
	}
	if m.tenant != nil {
		edges = append(edges, orderhistory.EdgeTenant)
	}
	if m._order != nil {
		edges = append(edges, orderhistory.EdgeOrder)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderhistory.EdgeChangeHistory:
		if id := m.change_history; id != nil {
			return []ent.Value{*id}
		}
	case orderhistory.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case orderhistory.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchange_history {
		edges = append(edges, orderhistory.EdgeChangeHistory)
	}
	if m.clearedtenant {
		edges = append(edges, orderhistory.EdgeTenant)
	}
	if m.cleared_order {
		edges = append(edges, orderhistory.EdgeOrder)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case orderhistory.EdgeChangeHistory:
		return m.clearedchange_history
	case orderhistory.EdgeTenant:
		return m.clearedtenant
	case orderhistory.EdgeOrder:
		return m.cleared_order
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderHistoryMutation) ClearEdge(name string) error {
	switch name {
	case orderhistory.EdgeChangeHistory:
		m.ClearChangeHistory()
		return nil
	case orderhistory.EdgeTenant:
		m.ClearTenant()
		return nil
	case orderhistory.EdgeOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderHistoryMutation) ResetEdge(name string) error {
	switch name {
	case orderhistory.EdgeChangeHistory:
		m.ResetChangeHistory()
		return nil
	case orderhistory.EdgeTenant:
		m.ResetTenant()
		return nil
	case orderhistory.EdgeOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown OrderHistory edge %s", name)
}

// OrderLineMutation represents an operation that mutates the OrderLine nodes in the graph.
type OrderLineMutation struct {
	config
	op                            Op
	typ                           string
	id                            *pulid.ID
	unit_price                    *float64
	addunit_price                 *float64
	discount_allocation_amount    *float64
	adddiscount_allocation_amount *float64
	external_id                   *string
	units                         *int
	addunits                      *int
	created_at                    *time.Time
	updated_at                    *time.Time
	clearedFields                 map[string]struct{}
	tenant                        *pulid.ID
	clearedtenant                 bool
	product_variant               *pulid.ID
	clearedproduct_variant        bool
	colli                         *pulid.ID
	clearedcolli                  bool
	return_order_line             map[pulid.ID]struct{}
	removedreturn_order_line      map[pulid.ID]struct{}
	clearedreturn_order_line      bool
	currency                      *pulid.ID
	clearedcurrency               bool
	done                          bool
	oldValue                      func(context.Context) (*OrderLine, error)
	predicates                    []predicate.OrderLine
}

var _ ent.Mutation = (*OrderLineMutation)(nil)

// orderlineOption allows management of the mutation configuration using functional options.
type orderlineOption func(*OrderLineMutation)

// newOrderLineMutation creates new mutation for the OrderLine entity.
func newOrderLineMutation(c config, op Op, opts ...orderlineOption) *OrderLineMutation {
	m := &OrderLineMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderLine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderLineID sets the ID field of the mutation.
func withOrderLineID(id pulid.ID) orderlineOption {
	return func(m *OrderLineMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderLine
		)
		m.oldValue = func(ctx context.Context) (*OrderLine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderLine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderLine sets the old OrderLine of the mutation.
func withOrderLine(node *OrderLine) orderlineOption {
	return func(m *OrderLineMutation) {
		m.oldValue = func(context.Context) (*OrderLine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderLineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderLineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderLine entities.
func (m *OrderLineMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderLineMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderLineMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderLine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OrderLineMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OrderLineMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OrderLine entity.
// If the OrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OrderLineMutation) ResetTenantID() {
	m.tenant = nil
}

// SetUnitPrice sets the "unit_price" field.
func (m *OrderLineMutation) SetUnitPrice(f float64) {
	m.unit_price = &f
	m.addunit_price = nil
}

// UnitPrice returns the value of the "unit_price" field in the mutation.
func (m *OrderLineMutation) UnitPrice() (r float64, exists bool) {
	v := m.unit_price
	if v == nil {
		return
	}
	return *v, true
}

// OldUnitPrice returns the old "unit_price" field's value of the OrderLine entity.
// If the OrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineMutation) OldUnitPrice(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnitPrice is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnitPrice requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnitPrice: %w", err)
	}
	return oldValue.UnitPrice, nil
}

// AddUnitPrice adds f to the "unit_price" field.
func (m *OrderLineMutation) AddUnitPrice(f float64) {
	if m.addunit_price != nil {
		*m.addunit_price += f
	} else {
		m.addunit_price = &f
	}
}

// AddedUnitPrice returns the value that was added to the "unit_price" field in this mutation.
func (m *OrderLineMutation) AddedUnitPrice() (r float64, exists bool) {
	v := m.addunit_price
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnitPrice resets all changes to the "unit_price" field.
func (m *OrderLineMutation) ResetUnitPrice() {
	m.unit_price = nil
	m.addunit_price = nil
}

// SetDiscountAllocationAmount sets the "discount_allocation_amount" field.
func (m *OrderLineMutation) SetDiscountAllocationAmount(f float64) {
	m.discount_allocation_amount = &f
	m.adddiscount_allocation_amount = nil
}

// DiscountAllocationAmount returns the value of the "discount_allocation_amount" field in the mutation.
func (m *OrderLineMutation) DiscountAllocationAmount() (r float64, exists bool) {
	v := m.discount_allocation_amount
	if v == nil {
		return
	}
	return *v, true
}

// OldDiscountAllocationAmount returns the old "discount_allocation_amount" field's value of the OrderLine entity.
// If the OrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineMutation) OldDiscountAllocationAmount(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDiscountAllocationAmount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDiscountAllocationAmount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiscountAllocationAmount: %w", err)
	}
	return oldValue.DiscountAllocationAmount, nil
}

// AddDiscountAllocationAmount adds f to the "discount_allocation_amount" field.
func (m *OrderLineMutation) AddDiscountAllocationAmount(f float64) {
	if m.adddiscount_allocation_amount != nil {
		*m.adddiscount_allocation_amount += f
	} else {
		m.adddiscount_allocation_amount = &f
	}
}

// AddedDiscountAllocationAmount returns the value that was added to the "discount_allocation_amount" field in this mutation.
func (m *OrderLineMutation) AddedDiscountAllocationAmount() (r float64, exists bool) {
	v := m.adddiscount_allocation_amount
	if v == nil {
		return
	}
	return *v, true
}

// ResetDiscountAllocationAmount resets all changes to the "discount_allocation_amount" field.
func (m *OrderLineMutation) ResetDiscountAllocationAmount() {
	m.discount_allocation_amount = nil
	m.adddiscount_allocation_amount = nil
}

// SetExternalID sets the "external_id" field.
func (m *OrderLineMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *OrderLineMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the OrderLine entity.
// If the OrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *OrderLineMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[orderline.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *OrderLineMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[orderline.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *OrderLineMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, orderline.FieldExternalID)
}

// SetUnits sets the "units" field.
func (m *OrderLineMutation) SetUnits(i int) {
	m.units = &i
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *OrderLineMutation) Units() (r int, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the OrderLine entity.
// If the OrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineMutation) OldUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds i to the "units" field.
func (m *OrderLineMutation) AddUnits(i int) {
	if m.addunits != nil {
		*m.addunits += i
	} else {
		m.addunits = &i
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *OrderLineMutation) AddedUnits() (r int, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnits resets all changes to the "units" field.
func (m *OrderLineMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *OrderLineMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OrderLineMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OrderLine entity.
// If the OrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OrderLineMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[orderline.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OrderLineMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[orderline.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OrderLineMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, orderline.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OrderLineMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OrderLineMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OrderLine entity.
// If the OrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OrderLineMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetProductVariantID sets the "product_variant_id" field.
func (m *OrderLineMutation) SetProductVariantID(pu pulid.ID) {
	m.product_variant = &pu
}

// ProductVariantID returns the value of the "product_variant_id" field in the mutation.
func (m *OrderLineMutation) ProductVariantID() (r pulid.ID, exists bool) {
	v := m.product_variant
	if v == nil {
		return
	}
	return *v, true
}

// OldProductVariantID returns the old "product_variant_id" field's value of the OrderLine entity.
// If the OrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineMutation) OldProductVariantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductVariantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductVariantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductVariantID: %w", err)
	}
	return oldValue.ProductVariantID, nil
}

// ResetProductVariantID resets all changes to the "product_variant_id" field.
func (m *OrderLineMutation) ResetProductVariantID() {
	m.product_variant = nil
}

// SetColliID sets the "colli_id" field.
func (m *OrderLineMutation) SetColliID(pu pulid.ID) {
	m.colli = &pu
}

// ColliID returns the value of the "colli_id" field in the mutation.
func (m *OrderLineMutation) ColliID() (r pulid.ID, exists bool) {
	v := m.colli
	if v == nil {
		return
	}
	return *v, true
}

// OldColliID returns the old "colli_id" field's value of the OrderLine entity.
// If the OrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderLineMutation) OldColliID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColliID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColliID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColliID: %w", err)
	}
	return oldValue.ColliID, nil
}

// ResetColliID resets all changes to the "colli_id" field.
func (m *OrderLineMutation) ResetColliID() {
	m.colli = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OrderLineMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[orderline.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OrderLineMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OrderLineMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OrderLineMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearProductVariant clears the "product_variant" edge to the ProductVariant entity.
func (m *OrderLineMutation) ClearProductVariant() {
	m.clearedproduct_variant = true
	m.clearedFields[orderline.FieldProductVariantID] = struct{}{}
}

// ProductVariantCleared reports if the "product_variant" edge to the ProductVariant entity was cleared.
func (m *OrderLineMutation) ProductVariantCleared() bool {
	return m.clearedproduct_variant
}

// ProductVariantIDs returns the "product_variant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductVariantID instead. It exists only for internal usage by the builders.
func (m *OrderLineMutation) ProductVariantIDs() (ids []pulid.ID) {
	if id := m.product_variant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProductVariant resets all changes to the "product_variant" edge.
func (m *OrderLineMutation) ResetProductVariant() {
	m.product_variant = nil
	m.clearedproduct_variant = false
}

// ClearColli clears the "colli" edge to the Colli entity.
func (m *OrderLineMutation) ClearColli() {
	m.clearedcolli = true
	m.clearedFields[orderline.FieldColliID] = struct{}{}
}

// ColliCleared reports if the "colli" edge to the Colli entity was cleared.
func (m *OrderLineMutation) ColliCleared() bool {
	return m.clearedcolli
}

// ColliIDs returns the "colli" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ColliID instead. It exists only for internal usage by the builders.
func (m *OrderLineMutation) ColliIDs() (ids []pulid.ID) {
	if id := m.colli; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetColli resets all changes to the "colli" edge.
func (m *OrderLineMutation) ResetColli() {
	m.colli = nil
	m.clearedcolli = false
}

// AddReturnOrderLineIDs adds the "return_order_line" edge to the ReturnOrderLine entity by ids.
func (m *OrderLineMutation) AddReturnOrderLineIDs(ids ...pulid.ID) {
	if m.return_order_line == nil {
		m.return_order_line = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_order_line[ids[i]] = struct{}{}
	}
}

// ClearReturnOrderLine clears the "return_order_line" edge to the ReturnOrderLine entity.
func (m *OrderLineMutation) ClearReturnOrderLine() {
	m.clearedreturn_order_line = true
}

// ReturnOrderLineCleared reports if the "return_order_line" edge to the ReturnOrderLine entity was cleared.
func (m *OrderLineMutation) ReturnOrderLineCleared() bool {
	return m.clearedreturn_order_line
}

// RemoveReturnOrderLineIDs removes the "return_order_line" edge to the ReturnOrderLine entity by IDs.
func (m *OrderLineMutation) RemoveReturnOrderLineIDs(ids ...pulid.ID) {
	if m.removedreturn_order_line == nil {
		m.removedreturn_order_line = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_order_line, ids[i])
		m.removedreturn_order_line[ids[i]] = struct{}{}
	}
}

// RemovedReturnOrderLine returns the removed IDs of the "return_order_line" edge to the ReturnOrderLine entity.
func (m *OrderLineMutation) RemovedReturnOrderLineIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_order_line {
		ids = append(ids, id)
	}
	return
}

// ReturnOrderLineIDs returns the "return_order_line" edge IDs in the mutation.
func (m *OrderLineMutation) ReturnOrderLineIDs() (ids []pulid.ID) {
	for id := range m.return_order_line {
		ids = append(ids, id)
	}
	return
}

// ResetReturnOrderLine resets all changes to the "return_order_line" edge.
func (m *OrderLineMutation) ResetReturnOrderLine() {
	m.return_order_line = nil
	m.clearedreturn_order_line = false
	m.removedreturn_order_line = nil
}

// SetCurrencyID sets the "currency" edge to the Currency entity by id.
func (m *OrderLineMutation) SetCurrencyID(id pulid.ID) {
	m.currency = &id
}

// ClearCurrency clears the "currency" edge to the Currency entity.
func (m *OrderLineMutation) ClearCurrency() {
	m.clearedcurrency = true
}

// CurrencyCleared reports if the "currency" edge to the Currency entity was cleared.
func (m *OrderLineMutation) CurrencyCleared() bool {
	return m.clearedcurrency
}

// CurrencyID returns the "currency" edge ID in the mutation.
func (m *OrderLineMutation) CurrencyID() (id pulid.ID, exists bool) {
	if m.currency != nil {
		return *m.currency, true
	}
	return
}

// CurrencyIDs returns the "currency" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CurrencyID instead. It exists only for internal usage by the builders.
func (m *OrderLineMutation) CurrencyIDs() (ids []pulid.ID) {
	if id := m.currency; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCurrency resets all changes to the "currency" edge.
func (m *OrderLineMutation) ResetCurrency() {
	m.currency = nil
	m.clearedcurrency = false
}

// Where appends a list predicates to the OrderLineMutation builder.
func (m *OrderLineMutation) Where(ps ...predicate.OrderLine) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderLineMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderLineMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderLine, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderLineMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderLineMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderLine).
func (m *OrderLineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderLineMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.tenant != nil {
		fields = append(fields, orderline.FieldTenantID)
	}
	if m.unit_price != nil {
		fields = append(fields, orderline.FieldUnitPrice)
	}
	if m.discount_allocation_amount != nil {
		fields = append(fields, orderline.FieldDiscountAllocationAmount)
	}
	if m.external_id != nil {
		fields = append(fields, orderline.FieldExternalID)
	}
	if m.units != nil {
		fields = append(fields, orderline.FieldUnits)
	}
	if m.created_at != nil {
		fields = append(fields, orderline.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, orderline.FieldUpdatedAt)
	}
	if m.product_variant != nil {
		fields = append(fields, orderline.FieldProductVariantID)
	}
	if m.colli != nil {
		fields = append(fields, orderline.FieldColliID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderLineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case orderline.FieldTenantID:
		return m.TenantID()
	case orderline.FieldUnitPrice:
		return m.UnitPrice()
	case orderline.FieldDiscountAllocationAmount:
		return m.DiscountAllocationAmount()
	case orderline.FieldExternalID:
		return m.ExternalID()
	case orderline.FieldUnits:
		return m.Units()
	case orderline.FieldCreatedAt:
		return m.CreatedAt()
	case orderline.FieldUpdatedAt:
		return m.UpdatedAt()
	case orderline.FieldProductVariantID:
		return m.ProductVariantID()
	case orderline.FieldColliID:
		return m.ColliID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderLineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case orderline.FieldTenantID:
		return m.OldTenantID(ctx)
	case orderline.FieldUnitPrice:
		return m.OldUnitPrice(ctx)
	case orderline.FieldDiscountAllocationAmount:
		return m.OldDiscountAllocationAmount(ctx)
	case orderline.FieldExternalID:
		return m.OldExternalID(ctx)
	case orderline.FieldUnits:
		return m.OldUnits(ctx)
	case orderline.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case orderline.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case orderline.FieldProductVariantID:
		return m.OldProductVariantID(ctx)
	case orderline.FieldColliID:
		return m.OldColliID(ctx)
	}
	return nil, fmt.Errorf("unknown OrderLine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderLineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case orderline.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case orderline.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnitPrice(v)
		return nil
	case orderline.FieldDiscountAllocationAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiscountAllocationAmount(v)
		return nil
	case orderline.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case orderline.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	case orderline.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case orderline.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case orderline.FieldProductVariantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductVariantID(v)
		return nil
	case orderline.FieldColliID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColliID(v)
		return nil
	}
	return fmt.Errorf("unknown OrderLine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderLineMutation) AddedFields() []string {
	var fields []string
	if m.addunit_price != nil {
		fields = append(fields, orderline.FieldUnitPrice)
	}
	if m.adddiscount_allocation_amount != nil {
		fields = append(fields, orderline.FieldDiscountAllocationAmount)
	}
	if m.addunits != nil {
		fields = append(fields, orderline.FieldUnits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderLineMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case orderline.FieldUnitPrice:
		return m.AddedUnitPrice()
	case orderline.FieldDiscountAllocationAmount:
		return m.AddedDiscountAllocationAmount()
	case orderline.FieldUnits:
		return m.AddedUnits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderLineMutation) AddField(name string, value ent.Value) error {
	switch name {
	case orderline.FieldUnitPrice:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnitPrice(v)
		return nil
	case orderline.FieldDiscountAllocationAmount:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDiscountAllocationAmount(v)
		return nil
	case orderline.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	}
	return fmt.Errorf("unknown OrderLine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderLineMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(orderline.FieldExternalID) {
		fields = append(fields, orderline.FieldExternalID)
	}
	if m.FieldCleared(orderline.FieldCreatedAt) {
		fields = append(fields, orderline.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderLineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderLineMutation) ClearField(name string) error {
	switch name {
	case orderline.FieldExternalID:
		m.ClearExternalID()
		return nil
	case orderline.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown OrderLine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderLineMutation) ResetField(name string) error {
	switch name {
	case orderline.FieldTenantID:
		m.ResetTenantID()
		return nil
	case orderline.FieldUnitPrice:
		m.ResetUnitPrice()
		return nil
	case orderline.FieldDiscountAllocationAmount:
		m.ResetDiscountAllocationAmount()
		return nil
	case orderline.FieldExternalID:
		m.ResetExternalID()
		return nil
	case orderline.FieldUnits:
		m.ResetUnits()
		return nil
	case orderline.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case orderline.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case orderline.FieldProductVariantID:
		m.ResetProductVariantID()
		return nil
	case orderline.FieldColliID:
		m.ResetColliID()
		return nil
	}
	return fmt.Errorf("unknown OrderLine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderLineMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, orderline.EdgeTenant)
	}
	if m.product_variant != nil {
		edges = append(edges, orderline.EdgeProductVariant)
	}
	if m.colli != nil {
		edges = append(edges, orderline.EdgeColli)
	}
	if m.return_order_line != nil {
		edges = append(edges, orderline.EdgeReturnOrderLine)
	}
	if m.currency != nil {
		edges = append(edges, orderline.EdgeCurrency)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderLineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case orderline.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case orderline.EdgeProductVariant:
		if id := m.product_variant; id != nil {
			return []ent.Value{*id}
		}
	case orderline.EdgeColli:
		if id := m.colli; id != nil {
			return []ent.Value{*id}
		}
	case orderline.EdgeReturnOrderLine:
		ids := make([]ent.Value, 0, len(m.return_order_line))
		for id := range m.return_order_line {
			ids = append(ids, id)
		}
		return ids
	case orderline.EdgeCurrency:
		if id := m.currency; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderLineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedreturn_order_line != nil {
		edges = append(edges, orderline.EdgeReturnOrderLine)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderLineMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case orderline.EdgeReturnOrderLine:
		ids := make([]ent.Value, 0, len(m.removedreturn_order_line))
		for id := range m.removedreturn_order_line {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderLineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, orderline.EdgeTenant)
	}
	if m.clearedproduct_variant {
		edges = append(edges, orderline.EdgeProductVariant)
	}
	if m.clearedcolli {
		edges = append(edges, orderline.EdgeColli)
	}
	if m.clearedreturn_order_line {
		edges = append(edges, orderline.EdgeReturnOrderLine)
	}
	if m.clearedcurrency {
		edges = append(edges, orderline.EdgeCurrency)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderLineMutation) EdgeCleared(name string) bool {
	switch name {
	case orderline.EdgeTenant:
		return m.clearedtenant
	case orderline.EdgeProductVariant:
		return m.clearedproduct_variant
	case orderline.EdgeColli:
		return m.clearedcolli
	case orderline.EdgeReturnOrderLine:
		return m.clearedreturn_order_line
	case orderline.EdgeCurrency:
		return m.clearedcurrency
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderLineMutation) ClearEdge(name string) error {
	switch name {
	case orderline.EdgeTenant:
		m.ClearTenant()
		return nil
	case orderline.EdgeProductVariant:
		m.ClearProductVariant()
		return nil
	case orderline.EdgeColli:
		m.ClearColli()
		return nil
	case orderline.EdgeCurrency:
		m.ClearCurrency()
		return nil
	}
	return fmt.Errorf("unknown OrderLine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderLineMutation) ResetEdge(name string) error {
	switch name {
	case orderline.EdgeTenant:
		m.ResetTenant()
		return nil
	case orderline.EdgeProductVariant:
		m.ResetProductVariant()
		return nil
	case orderline.EdgeColli:
		m.ResetColli()
		return nil
	case orderline.EdgeReturnOrderLine:
		m.ResetReturnOrderLine()
		return nil
	case orderline.EdgeCurrency:
		m.ResetCurrency()
		return nil
	}
	return fmt.Errorf("unknown OrderLine edge %s", name)
}

// OrderSenderMutation represents an operation that mutates the OrderSender nodes in the graph.
type OrderSenderMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.ID
	uniqueness_id *string
	first_name    *string
	last_name     *string
	email         *string
	phone_number  *string
	vat_number    *string
	clearedFields map[string]struct{}
	tenant        *pulid.ID
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*OrderSender, error)
	predicates    []predicate.OrderSender
}

var _ ent.Mutation = (*OrderSenderMutation)(nil)

// ordersenderOption allows management of the mutation configuration using functional options.
type ordersenderOption func(*OrderSenderMutation)

// newOrderSenderMutation creates new mutation for the OrderSender entity.
func newOrderSenderMutation(c config, op Op, opts ...ordersenderOption) *OrderSenderMutation {
	m := &OrderSenderMutation{
		config:        c,
		op:            op,
		typ:           TypeOrderSender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOrderSenderID sets the ID field of the mutation.
func withOrderSenderID(id pulid.ID) ordersenderOption {
	return func(m *OrderSenderMutation) {
		var (
			err   error
			once  sync.Once
			value *OrderSender
		)
		m.oldValue = func(ctx context.Context) (*OrderSender, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OrderSender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOrderSender sets the old OrderSender of the mutation.
func withOrderSender(node *OrderSender) ordersenderOption {
	return func(m *OrderSenderMutation) {
		m.oldValue = func(context.Context) (*OrderSender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OrderSenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OrderSenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OrderSender entities.
func (m *OrderSenderMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OrderSenderMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OrderSenderMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OrderSender.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *OrderSenderMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *OrderSenderMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the OrderSender entity.
// If the OrderSender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSenderMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *OrderSenderMutation) ResetTenantID() {
	m.tenant = nil
}

// SetUniquenessID sets the "uniqueness_id" field.
func (m *OrderSenderMutation) SetUniquenessID(s string) {
	m.uniqueness_id = &s
}

// UniquenessID returns the value of the "uniqueness_id" field in the mutation.
func (m *OrderSenderMutation) UniquenessID() (r string, exists bool) {
	v := m.uniqueness_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUniquenessID returns the old "uniqueness_id" field's value of the OrderSender entity.
// If the OrderSender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSenderMutation) OldUniquenessID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUniquenessID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUniquenessID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniquenessID: %w", err)
	}
	return oldValue.UniquenessID, nil
}

// ClearUniquenessID clears the value of the "uniqueness_id" field.
func (m *OrderSenderMutation) ClearUniquenessID() {
	m.uniqueness_id = nil
	m.clearedFields[ordersender.FieldUniquenessID] = struct{}{}
}

// UniquenessIDCleared returns if the "uniqueness_id" field was cleared in this mutation.
func (m *OrderSenderMutation) UniquenessIDCleared() bool {
	_, ok := m.clearedFields[ordersender.FieldUniquenessID]
	return ok
}

// ResetUniquenessID resets all changes to the "uniqueness_id" field.
func (m *OrderSenderMutation) ResetUniquenessID() {
	m.uniqueness_id = nil
	delete(m.clearedFields, ordersender.FieldUniquenessID)
}

// SetFirstName sets the "first_name" field.
func (m *OrderSenderMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *OrderSenderMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the OrderSender entity.
// If the OrderSender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSenderMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *OrderSenderMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *OrderSenderMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *OrderSenderMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the OrderSender entity.
// If the OrderSender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSenderMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *OrderSenderMutation) ResetLastName() {
	m.last_name = nil
}

// SetEmail sets the "email" field.
func (m *OrderSenderMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *OrderSenderMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the OrderSender entity.
// If the OrderSender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSenderMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *OrderSenderMutation) ResetEmail() {
	m.email = nil
}

// SetPhoneNumber sets the "phone_number" field.
func (m *OrderSenderMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *OrderSenderMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the OrderSender entity.
// If the OrderSender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSenderMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *OrderSenderMutation) ResetPhoneNumber() {
	m.phone_number = nil
}

// SetVatNumber sets the "vat_number" field.
func (m *OrderSenderMutation) SetVatNumber(s string) {
	m.vat_number = &s
}

// VatNumber returns the value of the "vat_number" field in the mutation.
func (m *OrderSenderMutation) VatNumber() (r string, exists bool) {
	v := m.vat_number
	if v == nil {
		return
	}
	return *v, true
}

// OldVatNumber returns the old "vat_number" field's value of the OrderSender entity.
// If the OrderSender object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OrderSenderMutation) OldVatNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVatNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVatNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatNumber: %w", err)
	}
	return oldValue.VatNumber, nil
}

// ResetVatNumber resets all changes to the "vat_number" field.
func (m *OrderSenderMutation) ResetVatNumber() {
	m.vat_number = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *OrderSenderMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[ordersender.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *OrderSenderMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *OrderSenderMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *OrderSenderMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the OrderSenderMutation builder.
func (m *OrderSenderMutation) Where(ps ...predicate.OrderSender) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OrderSenderMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OrderSenderMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OrderSender, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OrderSenderMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OrderSenderMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OrderSender).
func (m *OrderSenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OrderSenderMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, ordersender.FieldTenantID)
	}
	if m.uniqueness_id != nil {
		fields = append(fields, ordersender.FieldUniquenessID)
	}
	if m.first_name != nil {
		fields = append(fields, ordersender.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, ordersender.FieldLastName)
	}
	if m.email != nil {
		fields = append(fields, ordersender.FieldEmail)
	}
	if m.phone_number != nil {
		fields = append(fields, ordersender.FieldPhoneNumber)
	}
	if m.vat_number != nil {
		fields = append(fields, ordersender.FieldVatNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OrderSenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case ordersender.FieldTenantID:
		return m.TenantID()
	case ordersender.FieldUniquenessID:
		return m.UniquenessID()
	case ordersender.FieldFirstName:
		return m.FirstName()
	case ordersender.FieldLastName:
		return m.LastName()
	case ordersender.FieldEmail:
		return m.Email()
	case ordersender.FieldPhoneNumber:
		return m.PhoneNumber()
	case ordersender.FieldVatNumber:
		return m.VatNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OrderSenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case ordersender.FieldTenantID:
		return m.OldTenantID(ctx)
	case ordersender.FieldUniquenessID:
		return m.OldUniquenessID(ctx)
	case ordersender.FieldFirstName:
		return m.OldFirstName(ctx)
	case ordersender.FieldLastName:
		return m.OldLastName(ctx)
	case ordersender.FieldEmail:
		return m.OldEmail(ctx)
	case ordersender.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case ordersender.FieldVatNumber:
		return m.OldVatNumber(ctx)
	}
	return nil, fmt.Errorf("unknown OrderSender field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case ordersender.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case ordersender.FieldUniquenessID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniquenessID(v)
		return nil
	case ordersender.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case ordersender.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case ordersender.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case ordersender.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case ordersender.FieldVatNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatNumber(v)
		return nil
	}
	return fmt.Errorf("unknown OrderSender field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OrderSenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OrderSenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OrderSenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OrderSender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OrderSenderMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(ordersender.FieldUniquenessID) {
		fields = append(fields, ordersender.FieldUniquenessID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OrderSenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OrderSenderMutation) ClearField(name string) error {
	switch name {
	case ordersender.FieldUniquenessID:
		m.ClearUniquenessID()
		return nil
	}
	return fmt.Errorf("unknown OrderSender nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OrderSenderMutation) ResetField(name string) error {
	switch name {
	case ordersender.FieldTenantID:
		m.ResetTenantID()
		return nil
	case ordersender.FieldUniquenessID:
		m.ResetUniquenessID()
		return nil
	case ordersender.FieldFirstName:
		m.ResetFirstName()
		return nil
	case ordersender.FieldLastName:
		m.ResetLastName()
		return nil
	case ordersender.FieldEmail:
		m.ResetEmail()
		return nil
	case ordersender.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case ordersender.FieldVatNumber:
		m.ResetVatNumber()
		return nil
	}
	return fmt.Errorf("unknown OrderSender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OrderSenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, ordersender.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OrderSenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case ordersender.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OrderSenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OrderSenderMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OrderSenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, ordersender.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OrderSenderMutation) EdgeCleared(name string) bool {
	switch name {
	case ordersender.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OrderSenderMutation) ClearEdge(name string) error {
	switch name {
	case ordersender.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown OrderSender unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OrderSenderMutation) ResetEdge(name string) error {
	switch name {
	case ordersender.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown OrderSender edge %s", name)
}

// PackagingMutation represents an operation that mutates the Packaging nodes in the graph.
type PackagingMutation struct {
	config
	op                     Op
	typ                    string
	id                     *pulid.ID
	archived_at            *time.Time
	name                   *string
	height_cm              *int
	addheight_cm           *int
	width_cm               *int
	addwidth_cm            *int
	length_cm              *int
	addlength_cm           *int
	clearedFields          map[string]struct{}
	tenant                 *pulid.ID
	clearedtenant          bool
	shipment_parcel        map[pulid.ID]struct{}
	removedshipment_parcel map[pulid.ID]struct{}
	clearedshipment_parcel bool
	pallet                 map[pulid.ID]struct{}
	removedpallet          map[pulid.ID]struct{}
	clearedpallet          bool
	colli                  map[pulid.ID]struct{}
	removedcolli           map[pulid.ID]struct{}
	clearedcolli           bool
	return_colli           map[pulid.ID]struct{}
	removedreturn_colli    map[pulid.ID]struct{}
	clearedreturn_colli    bool
	packaging_df           *pulid.ID
	clearedpackaging_df    bool
	packaging_usps         *pulid.ID
	clearedpackaging_usps  bool
	carrier_brand          *pulid.ID
	clearedcarrier_brand   bool
	delivery_option        map[pulid.ID]struct{}
	removeddelivery_option map[pulid.ID]struct{}
	cleareddelivery_option bool
	done                   bool
	oldValue               func(context.Context) (*Packaging, error)
	predicates             []predicate.Packaging
}

var _ ent.Mutation = (*PackagingMutation)(nil)

// packagingOption allows management of the mutation configuration using functional options.
type packagingOption func(*PackagingMutation)

// newPackagingMutation creates new mutation for the Packaging entity.
func newPackagingMutation(c config, op Op, opts ...packagingOption) *PackagingMutation {
	m := &PackagingMutation{
		config:        c,
		op:            op,
		typ:           TypePackaging,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackagingID sets the ID field of the mutation.
func withPackagingID(id pulid.ID) packagingOption {
	return func(m *PackagingMutation) {
		var (
			err   error
			once  sync.Once
			value *Packaging
		)
		m.oldValue = func(ctx context.Context) (*Packaging, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Packaging.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackaging sets the old Packaging of the mutation.
func withPackaging(node *Packaging) packagingOption {
	return func(m *PackagingMutation) {
		m.oldValue = func(context.Context) (*Packaging, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackagingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackagingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Packaging entities.
func (m *PackagingMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackagingMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackagingMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Packaging.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PackagingMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PackagingMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Packaging entity.
// If the Packaging object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PackagingMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchivedAt sets the "archived_at" field.
func (m *PackagingMutation) SetArchivedAt(t time.Time) {
	m.archived_at = &t
}

// ArchivedAt returns the value of the "archived_at" field in the mutation.
func (m *PackagingMutation) ArchivedAt() (r time.Time, exists bool) {
	v := m.archived_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedAt returns the old "archived_at" field's value of the Packaging entity.
// If the Packaging object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingMutation) OldArchivedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedAt: %w", err)
	}
	return oldValue.ArchivedAt, nil
}

// ClearArchivedAt clears the value of the "archived_at" field.
func (m *PackagingMutation) ClearArchivedAt() {
	m.archived_at = nil
	m.clearedFields[packaging.FieldArchivedAt] = struct{}{}
}

// ArchivedAtCleared returns if the "archived_at" field was cleared in this mutation.
func (m *PackagingMutation) ArchivedAtCleared() bool {
	_, ok := m.clearedFields[packaging.FieldArchivedAt]
	return ok
}

// ResetArchivedAt resets all changes to the "archived_at" field.
func (m *PackagingMutation) ResetArchivedAt() {
	m.archived_at = nil
	delete(m.clearedFields, packaging.FieldArchivedAt)
}

// SetName sets the "name" field.
func (m *PackagingMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PackagingMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Packaging entity.
// If the Packaging object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PackagingMutation) ResetName() {
	m.name = nil
}

// SetHeightCm sets the "height_cm" field.
func (m *PackagingMutation) SetHeightCm(i int) {
	m.height_cm = &i
	m.addheight_cm = nil
}

// HeightCm returns the value of the "height_cm" field in the mutation.
func (m *PackagingMutation) HeightCm() (r int, exists bool) {
	v := m.height_cm
	if v == nil {
		return
	}
	return *v, true
}

// OldHeightCm returns the old "height_cm" field's value of the Packaging entity.
// If the Packaging object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingMutation) OldHeightCm(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeightCm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeightCm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeightCm: %w", err)
	}
	return oldValue.HeightCm, nil
}

// AddHeightCm adds i to the "height_cm" field.
func (m *PackagingMutation) AddHeightCm(i int) {
	if m.addheight_cm != nil {
		*m.addheight_cm += i
	} else {
		m.addheight_cm = &i
	}
}

// AddedHeightCm returns the value that was added to the "height_cm" field in this mutation.
func (m *PackagingMutation) AddedHeightCm() (r int, exists bool) {
	v := m.addheight_cm
	if v == nil {
		return
	}
	return *v, true
}

// ResetHeightCm resets all changes to the "height_cm" field.
func (m *PackagingMutation) ResetHeightCm() {
	m.height_cm = nil
	m.addheight_cm = nil
}

// SetWidthCm sets the "width_cm" field.
func (m *PackagingMutation) SetWidthCm(i int) {
	m.width_cm = &i
	m.addwidth_cm = nil
}

// WidthCm returns the value of the "width_cm" field in the mutation.
func (m *PackagingMutation) WidthCm() (r int, exists bool) {
	v := m.width_cm
	if v == nil {
		return
	}
	return *v, true
}

// OldWidthCm returns the old "width_cm" field's value of the Packaging entity.
// If the Packaging object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingMutation) OldWidthCm(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWidthCm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWidthCm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWidthCm: %w", err)
	}
	return oldValue.WidthCm, nil
}

// AddWidthCm adds i to the "width_cm" field.
func (m *PackagingMutation) AddWidthCm(i int) {
	if m.addwidth_cm != nil {
		*m.addwidth_cm += i
	} else {
		m.addwidth_cm = &i
	}
}

// AddedWidthCm returns the value that was added to the "width_cm" field in this mutation.
func (m *PackagingMutation) AddedWidthCm() (r int, exists bool) {
	v := m.addwidth_cm
	if v == nil {
		return
	}
	return *v, true
}

// ResetWidthCm resets all changes to the "width_cm" field.
func (m *PackagingMutation) ResetWidthCm() {
	m.width_cm = nil
	m.addwidth_cm = nil
}

// SetLengthCm sets the "length_cm" field.
func (m *PackagingMutation) SetLengthCm(i int) {
	m.length_cm = &i
	m.addlength_cm = nil
}

// LengthCm returns the value of the "length_cm" field in the mutation.
func (m *PackagingMutation) LengthCm() (r int, exists bool) {
	v := m.length_cm
	if v == nil {
		return
	}
	return *v, true
}

// OldLengthCm returns the old "length_cm" field's value of the Packaging entity.
// If the Packaging object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingMutation) OldLengthCm(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLengthCm is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLengthCm requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLengthCm: %w", err)
	}
	return oldValue.LengthCm, nil
}

// AddLengthCm adds i to the "length_cm" field.
func (m *PackagingMutation) AddLengthCm(i int) {
	if m.addlength_cm != nil {
		*m.addlength_cm += i
	} else {
		m.addlength_cm = &i
	}
}

// AddedLengthCm returns the value that was added to the "length_cm" field in this mutation.
func (m *PackagingMutation) AddedLengthCm() (r int, exists bool) {
	v := m.addlength_cm
	if v == nil {
		return
	}
	return *v, true
}

// ResetLengthCm resets all changes to the "length_cm" field.
func (m *PackagingMutation) ResetLengthCm() {
	m.length_cm = nil
	m.addlength_cm = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PackagingMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[packaging.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PackagingMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PackagingMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PackagingMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddShipmentParcelIDs adds the "shipment_parcel" edge to the ShipmentParcel entity by ids.
func (m *PackagingMutation) AddShipmentParcelIDs(ids ...pulid.ID) {
	if m.shipment_parcel == nil {
		m.shipment_parcel = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.shipment_parcel[ids[i]] = struct{}{}
	}
}

// ClearShipmentParcel clears the "shipment_parcel" edge to the ShipmentParcel entity.
func (m *PackagingMutation) ClearShipmentParcel() {
	m.clearedshipment_parcel = true
}

// ShipmentParcelCleared reports if the "shipment_parcel" edge to the ShipmentParcel entity was cleared.
func (m *PackagingMutation) ShipmentParcelCleared() bool {
	return m.clearedshipment_parcel
}

// RemoveShipmentParcelIDs removes the "shipment_parcel" edge to the ShipmentParcel entity by IDs.
func (m *PackagingMutation) RemoveShipmentParcelIDs(ids ...pulid.ID) {
	if m.removedshipment_parcel == nil {
		m.removedshipment_parcel = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.shipment_parcel, ids[i])
		m.removedshipment_parcel[ids[i]] = struct{}{}
	}
}

// RemovedShipmentParcel returns the removed IDs of the "shipment_parcel" edge to the ShipmentParcel entity.
func (m *PackagingMutation) RemovedShipmentParcelIDs() (ids []pulid.ID) {
	for id := range m.removedshipment_parcel {
		ids = append(ids, id)
	}
	return
}

// ShipmentParcelIDs returns the "shipment_parcel" edge IDs in the mutation.
func (m *PackagingMutation) ShipmentParcelIDs() (ids []pulid.ID) {
	for id := range m.shipment_parcel {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentParcel resets all changes to the "shipment_parcel" edge.
func (m *PackagingMutation) ResetShipmentParcel() {
	m.shipment_parcel = nil
	m.clearedshipment_parcel = false
	m.removedshipment_parcel = nil
}

// AddPalletIDs adds the "pallet" edge to the Pallet entity by ids.
func (m *PackagingMutation) AddPalletIDs(ids ...pulid.ID) {
	if m.pallet == nil {
		m.pallet = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.pallet[ids[i]] = struct{}{}
	}
}

// ClearPallet clears the "pallet" edge to the Pallet entity.
func (m *PackagingMutation) ClearPallet() {
	m.clearedpallet = true
}

// PalletCleared reports if the "pallet" edge to the Pallet entity was cleared.
func (m *PackagingMutation) PalletCleared() bool {
	return m.clearedpallet
}

// RemovePalletIDs removes the "pallet" edge to the Pallet entity by IDs.
func (m *PackagingMutation) RemovePalletIDs(ids ...pulid.ID) {
	if m.removedpallet == nil {
		m.removedpallet = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.pallet, ids[i])
		m.removedpallet[ids[i]] = struct{}{}
	}
}

// RemovedPallet returns the removed IDs of the "pallet" edge to the Pallet entity.
func (m *PackagingMutation) RemovedPalletIDs() (ids []pulid.ID) {
	for id := range m.removedpallet {
		ids = append(ids, id)
	}
	return
}

// PalletIDs returns the "pallet" edge IDs in the mutation.
func (m *PackagingMutation) PalletIDs() (ids []pulid.ID) {
	for id := range m.pallet {
		ids = append(ids, id)
	}
	return
}

// ResetPallet resets all changes to the "pallet" edge.
func (m *PackagingMutation) ResetPallet() {
	m.pallet = nil
	m.clearedpallet = false
	m.removedpallet = nil
}

// AddColliIDs adds the "colli" edge to the Colli entity by ids.
func (m *PackagingMutation) AddColliIDs(ids ...pulid.ID) {
	if m.colli == nil {
		m.colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.colli[ids[i]] = struct{}{}
	}
}

// ClearColli clears the "colli" edge to the Colli entity.
func (m *PackagingMutation) ClearColli() {
	m.clearedcolli = true
}

// ColliCleared reports if the "colli" edge to the Colli entity was cleared.
func (m *PackagingMutation) ColliCleared() bool {
	return m.clearedcolli
}

// RemoveColliIDs removes the "colli" edge to the Colli entity by IDs.
func (m *PackagingMutation) RemoveColliIDs(ids ...pulid.ID) {
	if m.removedcolli == nil {
		m.removedcolli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.colli, ids[i])
		m.removedcolli[ids[i]] = struct{}{}
	}
}

// RemovedColli returns the removed IDs of the "colli" edge to the Colli entity.
func (m *PackagingMutation) RemovedColliIDs() (ids []pulid.ID) {
	for id := range m.removedcolli {
		ids = append(ids, id)
	}
	return
}

// ColliIDs returns the "colli" edge IDs in the mutation.
func (m *PackagingMutation) ColliIDs() (ids []pulid.ID) {
	for id := range m.colli {
		ids = append(ids, id)
	}
	return
}

// ResetColli resets all changes to the "colli" edge.
func (m *PackagingMutation) ResetColli() {
	m.colli = nil
	m.clearedcolli = false
	m.removedcolli = nil
}

// AddReturnColliIDs adds the "return_colli" edge to the ReturnColli entity by ids.
func (m *PackagingMutation) AddReturnColliIDs(ids ...pulid.ID) {
	if m.return_colli == nil {
		m.return_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_colli[ids[i]] = struct{}{}
	}
}

// ClearReturnColli clears the "return_colli" edge to the ReturnColli entity.
func (m *PackagingMutation) ClearReturnColli() {
	m.clearedreturn_colli = true
}

// ReturnColliCleared reports if the "return_colli" edge to the ReturnColli entity was cleared.
func (m *PackagingMutation) ReturnColliCleared() bool {
	return m.clearedreturn_colli
}

// RemoveReturnColliIDs removes the "return_colli" edge to the ReturnColli entity by IDs.
func (m *PackagingMutation) RemoveReturnColliIDs(ids ...pulid.ID) {
	if m.removedreturn_colli == nil {
		m.removedreturn_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_colli, ids[i])
		m.removedreturn_colli[ids[i]] = struct{}{}
	}
}

// RemovedReturnColli returns the removed IDs of the "return_colli" edge to the ReturnColli entity.
func (m *PackagingMutation) RemovedReturnColliIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_colli {
		ids = append(ids, id)
	}
	return
}

// ReturnColliIDs returns the "return_colli" edge IDs in the mutation.
func (m *PackagingMutation) ReturnColliIDs() (ids []pulid.ID) {
	for id := range m.return_colli {
		ids = append(ids, id)
	}
	return
}

// ResetReturnColli resets all changes to the "return_colli" edge.
func (m *PackagingMutation) ResetReturnColli() {
	m.return_colli = nil
	m.clearedreturn_colli = false
	m.removedreturn_colli = nil
}

// SetPackagingDFID sets the "packaging_df" edge to the PackagingDF entity by id.
func (m *PackagingMutation) SetPackagingDFID(id pulid.ID) {
	m.packaging_df = &id
}

// ClearPackagingDF clears the "packaging_df" edge to the PackagingDF entity.
func (m *PackagingMutation) ClearPackagingDF() {
	m.clearedpackaging_df = true
}

// PackagingDFCleared reports if the "packaging_df" edge to the PackagingDF entity was cleared.
func (m *PackagingMutation) PackagingDFCleared() bool {
	return m.clearedpackaging_df
}

// PackagingDFID returns the "packaging_df" edge ID in the mutation.
func (m *PackagingMutation) PackagingDFID() (id pulid.ID, exists bool) {
	if m.packaging_df != nil {
		return *m.packaging_df, true
	}
	return
}

// PackagingDFIDs returns the "packaging_df" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackagingDFID instead. It exists only for internal usage by the builders.
func (m *PackagingMutation) PackagingDFIDs() (ids []pulid.ID) {
	if id := m.packaging_df; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackagingDF resets all changes to the "packaging_df" edge.
func (m *PackagingMutation) ResetPackagingDF() {
	m.packaging_df = nil
	m.clearedpackaging_df = false
}

// SetPackagingUSPSID sets the "packaging_usps" edge to the PackagingUSPS entity by id.
func (m *PackagingMutation) SetPackagingUSPSID(id pulid.ID) {
	m.packaging_usps = &id
}

// ClearPackagingUSPS clears the "packaging_usps" edge to the PackagingUSPS entity.
func (m *PackagingMutation) ClearPackagingUSPS() {
	m.clearedpackaging_usps = true
}

// PackagingUSPSCleared reports if the "packaging_usps" edge to the PackagingUSPS entity was cleared.
func (m *PackagingMutation) PackagingUSPSCleared() bool {
	return m.clearedpackaging_usps
}

// PackagingUSPSID returns the "packaging_usps" edge ID in the mutation.
func (m *PackagingMutation) PackagingUSPSID() (id pulid.ID, exists bool) {
	if m.packaging_usps != nil {
		return *m.packaging_usps, true
	}
	return
}

// PackagingUSPSIDs returns the "packaging_usps" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackagingUSPSID instead. It exists only for internal usage by the builders.
func (m *PackagingMutation) PackagingUSPSIDs() (ids []pulid.ID) {
	if id := m.packaging_usps; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackagingUSPS resets all changes to the "packaging_usps" edge.
func (m *PackagingMutation) ResetPackagingUSPS() {
	m.packaging_usps = nil
	m.clearedpackaging_usps = false
}

// SetCarrierBrandID sets the "carrier_brand" edge to the CarrierBrand entity by id.
func (m *PackagingMutation) SetCarrierBrandID(id pulid.ID) {
	m.carrier_brand = &id
}

// ClearCarrierBrand clears the "carrier_brand" edge to the CarrierBrand entity.
func (m *PackagingMutation) ClearCarrierBrand() {
	m.clearedcarrier_brand = true
}

// CarrierBrandCleared reports if the "carrier_brand" edge to the CarrierBrand entity was cleared.
func (m *PackagingMutation) CarrierBrandCleared() bool {
	return m.clearedcarrier_brand
}

// CarrierBrandID returns the "carrier_brand" edge ID in the mutation.
func (m *PackagingMutation) CarrierBrandID() (id pulid.ID, exists bool) {
	if m.carrier_brand != nil {
		return *m.carrier_brand, true
	}
	return
}

// CarrierBrandIDs returns the "carrier_brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierBrandID instead. It exists only for internal usage by the builders.
func (m *PackagingMutation) CarrierBrandIDs() (ids []pulid.ID) {
	if id := m.carrier_brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierBrand resets all changes to the "carrier_brand" edge.
func (m *PackagingMutation) ResetCarrierBrand() {
	m.carrier_brand = nil
	m.clearedcarrier_brand = false
}

// AddDeliveryOptionIDs adds the "delivery_option" edge to the DeliveryOption entity by ids.
func (m *PackagingMutation) AddDeliveryOptionIDs(ids ...pulid.ID) {
	if m.delivery_option == nil {
		m.delivery_option = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_option[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *PackagingMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *PackagingMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// RemoveDeliveryOptionIDs removes the "delivery_option" edge to the DeliveryOption entity by IDs.
func (m *PackagingMutation) RemoveDeliveryOptionIDs(ids ...pulid.ID) {
	if m.removeddelivery_option == nil {
		m.removeddelivery_option = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_option, ids[i])
		m.removeddelivery_option[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOption returns the removed IDs of the "delivery_option" edge to the DeliveryOption entity.
func (m *PackagingMutation) RemovedDeliveryOptionIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_option {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
func (m *PackagingMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	for id := range m.delivery_option {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *PackagingMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
	m.removeddelivery_option = nil
}

// Where appends a list predicates to the PackagingMutation builder.
func (m *PackagingMutation) Where(ps ...predicate.Packaging) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackagingMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackagingMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Packaging, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackagingMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackagingMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Packaging).
func (m *PackagingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackagingMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.tenant != nil {
		fields = append(fields, packaging.FieldTenantID)
	}
	if m.archived_at != nil {
		fields = append(fields, packaging.FieldArchivedAt)
	}
	if m.name != nil {
		fields = append(fields, packaging.FieldName)
	}
	if m.height_cm != nil {
		fields = append(fields, packaging.FieldHeightCm)
	}
	if m.width_cm != nil {
		fields = append(fields, packaging.FieldWidthCm)
	}
	if m.length_cm != nil {
		fields = append(fields, packaging.FieldLengthCm)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackagingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packaging.FieldTenantID:
		return m.TenantID()
	case packaging.FieldArchivedAt:
		return m.ArchivedAt()
	case packaging.FieldName:
		return m.Name()
	case packaging.FieldHeightCm:
		return m.HeightCm()
	case packaging.FieldWidthCm:
		return m.WidthCm()
	case packaging.FieldLengthCm:
		return m.LengthCm()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackagingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packaging.FieldTenantID:
		return m.OldTenantID(ctx)
	case packaging.FieldArchivedAt:
		return m.OldArchivedAt(ctx)
	case packaging.FieldName:
		return m.OldName(ctx)
	case packaging.FieldHeightCm:
		return m.OldHeightCm(ctx)
	case packaging.FieldWidthCm:
		return m.OldWidthCm(ctx)
	case packaging.FieldLengthCm:
		return m.OldLengthCm(ctx)
	}
	return nil, fmt.Errorf("unknown Packaging field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackagingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packaging.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case packaging.FieldArchivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedAt(v)
		return nil
	case packaging.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case packaging.FieldHeightCm:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeightCm(v)
		return nil
	case packaging.FieldWidthCm:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWidthCm(v)
		return nil
	case packaging.FieldLengthCm:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLengthCm(v)
		return nil
	}
	return fmt.Errorf("unknown Packaging field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackagingMutation) AddedFields() []string {
	var fields []string
	if m.addheight_cm != nil {
		fields = append(fields, packaging.FieldHeightCm)
	}
	if m.addwidth_cm != nil {
		fields = append(fields, packaging.FieldWidthCm)
	}
	if m.addlength_cm != nil {
		fields = append(fields, packaging.FieldLengthCm)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackagingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case packaging.FieldHeightCm:
		return m.AddedHeightCm()
	case packaging.FieldWidthCm:
		return m.AddedWidthCm()
	case packaging.FieldLengthCm:
		return m.AddedLengthCm()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackagingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case packaging.FieldHeightCm:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHeightCm(v)
		return nil
	case packaging.FieldWidthCm:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWidthCm(v)
		return nil
	case packaging.FieldLengthCm:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddLengthCm(v)
		return nil
	}
	return fmt.Errorf("unknown Packaging numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackagingMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(packaging.FieldArchivedAt) {
		fields = append(fields, packaging.FieldArchivedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackagingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackagingMutation) ClearField(name string) error {
	switch name {
	case packaging.FieldArchivedAt:
		m.ClearArchivedAt()
		return nil
	}
	return fmt.Errorf("unknown Packaging nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackagingMutation) ResetField(name string) error {
	switch name {
	case packaging.FieldTenantID:
		m.ResetTenantID()
		return nil
	case packaging.FieldArchivedAt:
		m.ResetArchivedAt()
		return nil
	case packaging.FieldName:
		m.ResetName()
		return nil
	case packaging.FieldHeightCm:
		m.ResetHeightCm()
		return nil
	case packaging.FieldWidthCm:
		m.ResetWidthCm()
		return nil
	case packaging.FieldLengthCm:
		m.ResetLengthCm()
		return nil
	}
	return fmt.Errorf("unknown Packaging field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackagingMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.tenant != nil {
		edges = append(edges, packaging.EdgeTenant)
	}
	if m.shipment_parcel != nil {
		edges = append(edges, packaging.EdgeShipmentParcel)
	}
	if m.pallet != nil {
		edges = append(edges, packaging.EdgePallet)
	}
	if m.colli != nil {
		edges = append(edges, packaging.EdgeColli)
	}
	if m.return_colli != nil {
		edges = append(edges, packaging.EdgeReturnColli)
	}
	if m.packaging_df != nil {
		edges = append(edges, packaging.EdgePackagingDF)
	}
	if m.packaging_usps != nil {
		edges = append(edges, packaging.EdgePackagingUSPS)
	}
	if m.carrier_brand != nil {
		edges = append(edges, packaging.EdgeCarrierBrand)
	}
	if m.delivery_option != nil {
		edges = append(edges, packaging.EdgeDeliveryOption)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackagingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packaging.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case packaging.EdgeShipmentParcel:
		ids := make([]ent.Value, 0, len(m.shipment_parcel))
		for id := range m.shipment_parcel {
			ids = append(ids, id)
		}
		return ids
	case packaging.EdgePallet:
		ids := make([]ent.Value, 0, len(m.pallet))
		for id := range m.pallet {
			ids = append(ids, id)
		}
		return ids
	case packaging.EdgeColli:
		ids := make([]ent.Value, 0, len(m.colli))
		for id := range m.colli {
			ids = append(ids, id)
		}
		return ids
	case packaging.EdgeReturnColli:
		ids := make([]ent.Value, 0, len(m.return_colli))
		for id := range m.return_colli {
			ids = append(ids, id)
		}
		return ids
	case packaging.EdgePackagingDF:
		if id := m.packaging_df; id != nil {
			return []ent.Value{*id}
		}
	case packaging.EdgePackagingUSPS:
		if id := m.packaging_usps; id != nil {
			return []ent.Value{*id}
		}
	case packaging.EdgeCarrierBrand:
		if id := m.carrier_brand; id != nil {
			return []ent.Value{*id}
		}
	case packaging.EdgeDeliveryOption:
		ids := make([]ent.Value, 0, len(m.delivery_option))
		for id := range m.delivery_option {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackagingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedshipment_parcel != nil {
		edges = append(edges, packaging.EdgeShipmentParcel)
	}
	if m.removedpallet != nil {
		edges = append(edges, packaging.EdgePallet)
	}
	if m.removedcolli != nil {
		edges = append(edges, packaging.EdgeColli)
	}
	if m.removedreturn_colli != nil {
		edges = append(edges, packaging.EdgeReturnColli)
	}
	if m.removeddelivery_option != nil {
		edges = append(edges, packaging.EdgeDeliveryOption)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackagingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packaging.EdgeShipmentParcel:
		ids := make([]ent.Value, 0, len(m.removedshipment_parcel))
		for id := range m.removedshipment_parcel {
			ids = append(ids, id)
		}
		return ids
	case packaging.EdgePallet:
		ids := make([]ent.Value, 0, len(m.removedpallet))
		for id := range m.removedpallet {
			ids = append(ids, id)
		}
		return ids
	case packaging.EdgeColli:
		ids := make([]ent.Value, 0, len(m.removedcolli))
		for id := range m.removedcolli {
			ids = append(ids, id)
		}
		return ids
	case packaging.EdgeReturnColli:
		ids := make([]ent.Value, 0, len(m.removedreturn_colli))
		for id := range m.removedreturn_colli {
			ids = append(ids, id)
		}
		return ids
	case packaging.EdgeDeliveryOption:
		ids := make([]ent.Value, 0, len(m.removeddelivery_option))
		for id := range m.removeddelivery_option {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackagingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedtenant {
		edges = append(edges, packaging.EdgeTenant)
	}
	if m.clearedshipment_parcel {
		edges = append(edges, packaging.EdgeShipmentParcel)
	}
	if m.clearedpallet {
		edges = append(edges, packaging.EdgePallet)
	}
	if m.clearedcolli {
		edges = append(edges, packaging.EdgeColli)
	}
	if m.clearedreturn_colli {
		edges = append(edges, packaging.EdgeReturnColli)
	}
	if m.clearedpackaging_df {
		edges = append(edges, packaging.EdgePackagingDF)
	}
	if m.clearedpackaging_usps {
		edges = append(edges, packaging.EdgePackagingUSPS)
	}
	if m.clearedcarrier_brand {
		edges = append(edges, packaging.EdgeCarrierBrand)
	}
	if m.cleareddelivery_option {
		edges = append(edges, packaging.EdgeDeliveryOption)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackagingMutation) EdgeCleared(name string) bool {
	switch name {
	case packaging.EdgeTenant:
		return m.clearedtenant
	case packaging.EdgeShipmentParcel:
		return m.clearedshipment_parcel
	case packaging.EdgePallet:
		return m.clearedpallet
	case packaging.EdgeColli:
		return m.clearedcolli
	case packaging.EdgeReturnColli:
		return m.clearedreturn_colli
	case packaging.EdgePackagingDF:
		return m.clearedpackaging_df
	case packaging.EdgePackagingUSPS:
		return m.clearedpackaging_usps
	case packaging.EdgeCarrierBrand:
		return m.clearedcarrier_brand
	case packaging.EdgeDeliveryOption:
		return m.cleareddelivery_option
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackagingMutation) ClearEdge(name string) error {
	switch name {
	case packaging.EdgeTenant:
		m.ClearTenant()
		return nil
	case packaging.EdgePackagingDF:
		m.ClearPackagingDF()
		return nil
	case packaging.EdgePackagingUSPS:
		m.ClearPackagingUSPS()
		return nil
	case packaging.EdgeCarrierBrand:
		m.ClearCarrierBrand()
		return nil
	}
	return fmt.Errorf("unknown Packaging unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackagingMutation) ResetEdge(name string) error {
	switch name {
	case packaging.EdgeTenant:
		m.ResetTenant()
		return nil
	case packaging.EdgeShipmentParcel:
		m.ResetShipmentParcel()
		return nil
	case packaging.EdgePallet:
		m.ResetPallet()
		return nil
	case packaging.EdgeColli:
		m.ResetColli()
		return nil
	case packaging.EdgeReturnColli:
		m.ResetReturnColli()
		return nil
	case packaging.EdgePackagingDF:
		m.ResetPackagingDF()
		return nil
	case packaging.EdgePackagingUSPS:
		m.ResetPackagingUSPS()
		return nil
	case packaging.EdgeCarrierBrand:
		m.ResetCarrierBrand()
		return nil
	case packaging.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	}
	return fmt.Errorf("unknown Packaging edge %s", name)
}

// PackagingDFMutation represents an operation that mutates the PackagingDF nodes in the graph.
type PackagingDFMutation struct {
	config
	op               Op
	typ              string
	id               *pulid.ID
	api_type         *packagingdf.APIType
	max_weight       *float64
	addmax_weight    *float64
	min_weight       *float64
	addmin_weight    *float64
	stackable        *bool
	clearedFields    map[string]struct{}
	tenant           *pulid.ID
	clearedtenant    bool
	packaging        *pulid.ID
	clearedpackaging bool
	done             bool
	oldValue         func(context.Context) (*PackagingDF, error)
	predicates       []predicate.PackagingDF
}

var _ ent.Mutation = (*PackagingDFMutation)(nil)

// packagingdfOption allows management of the mutation configuration using functional options.
type packagingdfOption func(*PackagingDFMutation)

// newPackagingDFMutation creates new mutation for the PackagingDF entity.
func newPackagingDFMutation(c config, op Op, opts ...packagingdfOption) *PackagingDFMutation {
	m := &PackagingDFMutation{
		config:        c,
		op:            op,
		typ:           TypePackagingDF,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackagingDFID sets the ID field of the mutation.
func withPackagingDFID(id pulid.ID) packagingdfOption {
	return func(m *PackagingDFMutation) {
		var (
			err   error
			once  sync.Once
			value *PackagingDF
		)
		m.oldValue = func(ctx context.Context) (*PackagingDF, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackagingDF.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackagingDF sets the old PackagingDF of the mutation.
func withPackagingDF(node *PackagingDF) packagingdfOption {
	return func(m *PackagingDFMutation) {
		m.oldValue = func(context.Context) (*PackagingDF, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackagingDFMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackagingDFMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PackagingDF entities.
func (m *PackagingDFMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackagingDFMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackagingDFMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackagingDF.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PackagingDFMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PackagingDFMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PackagingDF entity.
// If the PackagingDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingDFMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PackagingDFMutation) ResetTenantID() {
	m.tenant = nil
}

// SetAPIType sets the "api_type" field.
func (m *PackagingDFMutation) SetAPIType(pt packagingdf.APIType) {
	m.api_type = &pt
}

// APIType returns the value of the "api_type" field in the mutation.
func (m *PackagingDFMutation) APIType() (r packagingdf.APIType, exists bool) {
	v := m.api_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIType returns the old "api_type" field's value of the PackagingDF entity.
// If the PackagingDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingDFMutation) OldAPIType(ctx context.Context) (v packagingdf.APIType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIType: %w", err)
	}
	return oldValue.APIType, nil
}

// ResetAPIType resets all changes to the "api_type" field.
func (m *PackagingDFMutation) ResetAPIType() {
	m.api_type = nil
}

// SetMaxWeight sets the "max_weight" field.
func (m *PackagingDFMutation) SetMaxWeight(f float64) {
	m.max_weight = &f
	m.addmax_weight = nil
}

// MaxWeight returns the value of the "max_weight" field in the mutation.
func (m *PackagingDFMutation) MaxWeight() (r float64, exists bool) {
	v := m.max_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldMaxWeight returns the old "max_weight" field's value of the PackagingDF entity.
// If the PackagingDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingDFMutation) OldMaxWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaxWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaxWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaxWeight: %w", err)
	}
	return oldValue.MaxWeight, nil
}

// AddMaxWeight adds f to the "max_weight" field.
func (m *PackagingDFMutation) AddMaxWeight(f float64) {
	if m.addmax_weight != nil {
		*m.addmax_weight += f
	} else {
		m.addmax_weight = &f
	}
}

// AddedMaxWeight returns the value that was added to the "max_weight" field in this mutation.
func (m *PackagingDFMutation) AddedMaxWeight() (r float64, exists bool) {
	v := m.addmax_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearMaxWeight clears the value of the "max_weight" field.
func (m *PackagingDFMutation) ClearMaxWeight() {
	m.max_weight = nil
	m.addmax_weight = nil
	m.clearedFields[packagingdf.FieldMaxWeight] = struct{}{}
}

// MaxWeightCleared returns if the "max_weight" field was cleared in this mutation.
func (m *PackagingDFMutation) MaxWeightCleared() bool {
	_, ok := m.clearedFields[packagingdf.FieldMaxWeight]
	return ok
}

// ResetMaxWeight resets all changes to the "max_weight" field.
func (m *PackagingDFMutation) ResetMaxWeight() {
	m.max_weight = nil
	m.addmax_weight = nil
	delete(m.clearedFields, packagingdf.FieldMaxWeight)
}

// SetMinWeight sets the "min_weight" field.
func (m *PackagingDFMutation) SetMinWeight(f float64) {
	m.min_weight = &f
	m.addmin_weight = nil
}

// MinWeight returns the value of the "min_weight" field in the mutation.
func (m *PackagingDFMutation) MinWeight() (r float64, exists bool) {
	v := m.min_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldMinWeight returns the old "min_weight" field's value of the PackagingDF entity.
// If the PackagingDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingDFMutation) OldMinWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMinWeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMinWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMinWeight: %w", err)
	}
	return oldValue.MinWeight, nil
}

// AddMinWeight adds f to the "min_weight" field.
func (m *PackagingDFMutation) AddMinWeight(f float64) {
	if m.addmin_weight != nil {
		*m.addmin_weight += f
	} else {
		m.addmin_weight = &f
	}
}

// AddedMinWeight returns the value that was added to the "min_weight" field in this mutation.
func (m *PackagingDFMutation) AddedMinWeight() (r float64, exists bool) {
	v := m.addmin_weight
	if v == nil {
		return
	}
	return *v, true
}

// ClearMinWeight clears the value of the "min_weight" field.
func (m *PackagingDFMutation) ClearMinWeight() {
	m.min_weight = nil
	m.addmin_weight = nil
	m.clearedFields[packagingdf.FieldMinWeight] = struct{}{}
}

// MinWeightCleared returns if the "min_weight" field was cleared in this mutation.
func (m *PackagingDFMutation) MinWeightCleared() bool {
	_, ok := m.clearedFields[packagingdf.FieldMinWeight]
	return ok
}

// ResetMinWeight resets all changes to the "min_weight" field.
func (m *PackagingDFMutation) ResetMinWeight() {
	m.min_weight = nil
	m.addmin_weight = nil
	delete(m.clearedFields, packagingdf.FieldMinWeight)
}

// SetStackable sets the "stackable" field.
func (m *PackagingDFMutation) SetStackable(b bool) {
	m.stackable = &b
}

// Stackable returns the value of the "stackable" field in the mutation.
func (m *PackagingDFMutation) Stackable() (r bool, exists bool) {
	v := m.stackable
	if v == nil {
		return
	}
	return *v, true
}

// OldStackable returns the old "stackable" field's value of the PackagingDF entity.
// If the PackagingDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingDFMutation) OldStackable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStackable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStackable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStackable: %w", err)
	}
	return oldValue.Stackable, nil
}

// ResetStackable resets all changes to the "stackable" field.
func (m *PackagingDFMutation) ResetStackable() {
	m.stackable = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PackagingDFMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[packagingdf.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PackagingDFMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PackagingDFMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PackagingDFMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetPackagingID sets the "packaging" edge to the Packaging entity by id.
func (m *PackagingDFMutation) SetPackagingID(id pulid.ID) {
	m.packaging = &id
}

// ClearPackaging clears the "packaging" edge to the Packaging entity.
func (m *PackagingDFMutation) ClearPackaging() {
	m.clearedpackaging = true
}

// PackagingCleared reports if the "packaging" edge to the Packaging entity was cleared.
func (m *PackagingDFMutation) PackagingCleared() bool {
	return m.clearedpackaging
}

// PackagingID returns the "packaging" edge ID in the mutation.
func (m *PackagingDFMutation) PackagingID() (id pulid.ID, exists bool) {
	if m.packaging != nil {
		return *m.packaging, true
	}
	return
}

// PackagingIDs returns the "packaging" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackagingID instead. It exists only for internal usage by the builders.
func (m *PackagingDFMutation) PackagingIDs() (ids []pulid.ID) {
	if id := m.packaging; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackaging resets all changes to the "packaging" edge.
func (m *PackagingDFMutation) ResetPackaging() {
	m.packaging = nil
	m.clearedpackaging = false
}

// Where appends a list predicates to the PackagingDFMutation builder.
func (m *PackagingDFMutation) Where(ps ...predicate.PackagingDF) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackagingDFMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackagingDFMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackagingDF, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackagingDFMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackagingDFMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackagingDF).
func (m *PackagingDFMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackagingDFMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, packagingdf.FieldTenantID)
	}
	if m.api_type != nil {
		fields = append(fields, packagingdf.FieldAPIType)
	}
	if m.max_weight != nil {
		fields = append(fields, packagingdf.FieldMaxWeight)
	}
	if m.min_weight != nil {
		fields = append(fields, packagingdf.FieldMinWeight)
	}
	if m.stackable != nil {
		fields = append(fields, packagingdf.FieldStackable)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackagingDFMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagingdf.FieldTenantID:
		return m.TenantID()
	case packagingdf.FieldAPIType:
		return m.APIType()
	case packagingdf.FieldMaxWeight:
		return m.MaxWeight()
	case packagingdf.FieldMinWeight:
		return m.MinWeight()
	case packagingdf.FieldStackable:
		return m.Stackable()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackagingDFMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagingdf.FieldTenantID:
		return m.OldTenantID(ctx)
	case packagingdf.FieldAPIType:
		return m.OldAPIType(ctx)
	case packagingdf.FieldMaxWeight:
		return m.OldMaxWeight(ctx)
	case packagingdf.FieldMinWeight:
		return m.OldMinWeight(ctx)
	case packagingdf.FieldStackable:
		return m.OldStackable(ctx)
	}
	return nil, fmt.Errorf("unknown PackagingDF field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackagingDFMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagingdf.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case packagingdf.FieldAPIType:
		v, ok := value.(packagingdf.APIType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIType(v)
		return nil
	case packagingdf.FieldMaxWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaxWeight(v)
		return nil
	case packagingdf.FieldMinWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMinWeight(v)
		return nil
	case packagingdf.FieldStackable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStackable(v)
		return nil
	}
	return fmt.Errorf("unknown PackagingDF field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackagingDFMutation) AddedFields() []string {
	var fields []string
	if m.addmax_weight != nil {
		fields = append(fields, packagingdf.FieldMaxWeight)
	}
	if m.addmin_weight != nil {
		fields = append(fields, packagingdf.FieldMinWeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackagingDFMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case packagingdf.FieldMaxWeight:
		return m.AddedMaxWeight()
	case packagingdf.FieldMinWeight:
		return m.AddedMinWeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackagingDFMutation) AddField(name string, value ent.Value) error {
	switch name {
	case packagingdf.FieldMaxWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMaxWeight(v)
		return nil
	case packagingdf.FieldMinWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMinWeight(v)
		return nil
	}
	return fmt.Errorf("unknown PackagingDF numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackagingDFMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(packagingdf.FieldMaxWeight) {
		fields = append(fields, packagingdf.FieldMaxWeight)
	}
	if m.FieldCleared(packagingdf.FieldMinWeight) {
		fields = append(fields, packagingdf.FieldMinWeight)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackagingDFMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackagingDFMutation) ClearField(name string) error {
	switch name {
	case packagingdf.FieldMaxWeight:
		m.ClearMaxWeight()
		return nil
	case packagingdf.FieldMinWeight:
		m.ClearMinWeight()
		return nil
	}
	return fmt.Errorf("unknown PackagingDF nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackagingDFMutation) ResetField(name string) error {
	switch name {
	case packagingdf.FieldTenantID:
		m.ResetTenantID()
		return nil
	case packagingdf.FieldAPIType:
		m.ResetAPIType()
		return nil
	case packagingdf.FieldMaxWeight:
		m.ResetMaxWeight()
		return nil
	case packagingdf.FieldMinWeight:
		m.ResetMinWeight()
		return nil
	case packagingdf.FieldStackable:
		m.ResetStackable()
		return nil
	}
	return fmt.Errorf("unknown PackagingDF field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackagingDFMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, packagingdf.EdgeTenant)
	}
	if m.packaging != nil {
		edges = append(edges, packagingdf.EdgePackaging)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackagingDFMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagingdf.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case packagingdf.EdgePackaging:
		if id := m.packaging; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackagingDFMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackagingDFMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackagingDFMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, packagingdf.EdgeTenant)
	}
	if m.clearedpackaging {
		edges = append(edges, packagingdf.EdgePackaging)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackagingDFMutation) EdgeCleared(name string) bool {
	switch name {
	case packagingdf.EdgeTenant:
		return m.clearedtenant
	case packagingdf.EdgePackaging:
		return m.clearedpackaging
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackagingDFMutation) ClearEdge(name string) error {
	switch name {
	case packagingdf.EdgeTenant:
		m.ClearTenant()
		return nil
	case packagingdf.EdgePackaging:
		m.ClearPackaging()
		return nil
	}
	return fmt.Errorf("unknown PackagingDF unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackagingDFMutation) ResetEdge(name string) error {
	switch name {
	case packagingdf.EdgeTenant:
		m.ResetTenant()
		return nil
	case packagingdf.EdgePackaging:
		m.ResetPackaging()
		return nil
	}
	return fmt.Errorf("unknown PackagingDF edge %s", name)
}

// PackagingUSPSMutation represents an operation that mutates the PackagingUSPS nodes in the graph.
type PackagingUSPSMutation struct {
	config
	op                                        Op
	typ                                       string
	id                                        *pulid.ID
	clearedFields                             map[string]struct{}
	tenant                                    *pulid.ID
	clearedtenant                             bool
	packaging                                 *pulid.ID
	clearedpackaging                          bool
	packaging_usps_rate_indicator             *pulid.ID
	clearedpackaging_usps_rate_indicator      bool
	packaging_usps_processing_category        *pulid.ID
	clearedpackaging_usps_processing_category bool
	done                                      bool
	oldValue                                  func(context.Context) (*PackagingUSPS, error)
	predicates                                []predicate.PackagingUSPS
}

var _ ent.Mutation = (*PackagingUSPSMutation)(nil)

// packaginguspsOption allows management of the mutation configuration using functional options.
type packaginguspsOption func(*PackagingUSPSMutation)

// newPackagingUSPSMutation creates new mutation for the PackagingUSPS entity.
func newPackagingUSPSMutation(c config, op Op, opts ...packaginguspsOption) *PackagingUSPSMutation {
	m := &PackagingUSPSMutation{
		config:        c,
		op:            op,
		typ:           TypePackagingUSPS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackagingUSPSID sets the ID field of the mutation.
func withPackagingUSPSID(id pulid.ID) packaginguspsOption {
	return func(m *PackagingUSPSMutation) {
		var (
			err   error
			once  sync.Once
			value *PackagingUSPS
		)
		m.oldValue = func(ctx context.Context) (*PackagingUSPS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackagingUSPS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackagingUSPS sets the old PackagingUSPS of the mutation.
func withPackagingUSPS(node *PackagingUSPS) packaginguspsOption {
	return func(m *PackagingUSPSMutation) {
		m.oldValue = func(context.Context) (*PackagingUSPS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackagingUSPSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackagingUSPSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PackagingUSPS entities.
func (m *PackagingUSPSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackagingUSPSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackagingUSPSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackagingUSPS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PackagingUSPSMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PackagingUSPSMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PackagingUSPS entity.
// If the PackagingUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingUSPSMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PackagingUSPSMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PackagingUSPSMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[packagingusps.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PackagingUSPSMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PackagingUSPSMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PackagingUSPSMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetPackagingID sets the "packaging" edge to the Packaging entity by id.
func (m *PackagingUSPSMutation) SetPackagingID(id pulid.ID) {
	m.packaging = &id
}

// ClearPackaging clears the "packaging" edge to the Packaging entity.
func (m *PackagingUSPSMutation) ClearPackaging() {
	m.clearedpackaging = true
}

// PackagingCleared reports if the "packaging" edge to the Packaging entity was cleared.
func (m *PackagingUSPSMutation) PackagingCleared() bool {
	return m.clearedpackaging
}

// PackagingID returns the "packaging" edge ID in the mutation.
func (m *PackagingUSPSMutation) PackagingID() (id pulid.ID, exists bool) {
	if m.packaging != nil {
		return *m.packaging, true
	}
	return
}

// PackagingIDs returns the "packaging" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackagingID instead. It exists only for internal usage by the builders.
func (m *PackagingUSPSMutation) PackagingIDs() (ids []pulid.ID) {
	if id := m.packaging; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackaging resets all changes to the "packaging" edge.
func (m *PackagingUSPSMutation) ResetPackaging() {
	m.packaging = nil
	m.clearedpackaging = false
}

// SetPackagingUSPSRateIndicatorID sets the "packaging_usps_rate_indicator" edge to the PackagingUSPSRateIndicator entity by id.
func (m *PackagingUSPSMutation) SetPackagingUSPSRateIndicatorID(id pulid.ID) {
	m.packaging_usps_rate_indicator = &id
}

// ClearPackagingUSPSRateIndicator clears the "packaging_usps_rate_indicator" edge to the PackagingUSPSRateIndicator entity.
func (m *PackagingUSPSMutation) ClearPackagingUSPSRateIndicator() {
	m.clearedpackaging_usps_rate_indicator = true
}

// PackagingUSPSRateIndicatorCleared reports if the "packaging_usps_rate_indicator" edge to the PackagingUSPSRateIndicator entity was cleared.
func (m *PackagingUSPSMutation) PackagingUSPSRateIndicatorCleared() bool {
	return m.clearedpackaging_usps_rate_indicator
}

// PackagingUSPSRateIndicatorID returns the "packaging_usps_rate_indicator" edge ID in the mutation.
func (m *PackagingUSPSMutation) PackagingUSPSRateIndicatorID() (id pulid.ID, exists bool) {
	if m.packaging_usps_rate_indicator != nil {
		return *m.packaging_usps_rate_indicator, true
	}
	return
}

// PackagingUSPSRateIndicatorIDs returns the "packaging_usps_rate_indicator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackagingUSPSRateIndicatorID instead. It exists only for internal usage by the builders.
func (m *PackagingUSPSMutation) PackagingUSPSRateIndicatorIDs() (ids []pulid.ID) {
	if id := m.packaging_usps_rate_indicator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackagingUSPSRateIndicator resets all changes to the "packaging_usps_rate_indicator" edge.
func (m *PackagingUSPSMutation) ResetPackagingUSPSRateIndicator() {
	m.packaging_usps_rate_indicator = nil
	m.clearedpackaging_usps_rate_indicator = false
}

// SetPackagingUSPSProcessingCategoryID sets the "packaging_usps_processing_category" edge to the PackagingUSPSProcessingCategory entity by id.
func (m *PackagingUSPSMutation) SetPackagingUSPSProcessingCategoryID(id pulid.ID) {
	m.packaging_usps_processing_category = &id
}

// ClearPackagingUSPSProcessingCategory clears the "packaging_usps_processing_category" edge to the PackagingUSPSProcessingCategory entity.
func (m *PackagingUSPSMutation) ClearPackagingUSPSProcessingCategory() {
	m.clearedpackaging_usps_processing_category = true
}

// PackagingUSPSProcessingCategoryCleared reports if the "packaging_usps_processing_category" edge to the PackagingUSPSProcessingCategory entity was cleared.
func (m *PackagingUSPSMutation) PackagingUSPSProcessingCategoryCleared() bool {
	return m.clearedpackaging_usps_processing_category
}

// PackagingUSPSProcessingCategoryID returns the "packaging_usps_processing_category" edge ID in the mutation.
func (m *PackagingUSPSMutation) PackagingUSPSProcessingCategoryID() (id pulid.ID, exists bool) {
	if m.packaging_usps_processing_category != nil {
		return *m.packaging_usps_processing_category, true
	}
	return
}

// PackagingUSPSProcessingCategoryIDs returns the "packaging_usps_processing_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackagingUSPSProcessingCategoryID instead. It exists only for internal usage by the builders.
func (m *PackagingUSPSMutation) PackagingUSPSProcessingCategoryIDs() (ids []pulid.ID) {
	if id := m.packaging_usps_processing_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackagingUSPSProcessingCategory resets all changes to the "packaging_usps_processing_category" edge.
func (m *PackagingUSPSMutation) ResetPackagingUSPSProcessingCategory() {
	m.packaging_usps_processing_category = nil
	m.clearedpackaging_usps_processing_category = false
}

// Where appends a list predicates to the PackagingUSPSMutation builder.
func (m *PackagingUSPSMutation) Where(ps ...predicate.PackagingUSPS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackagingUSPSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackagingUSPSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackagingUSPS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackagingUSPSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackagingUSPSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackagingUSPS).
func (m *PackagingUSPSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackagingUSPSMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tenant != nil {
		fields = append(fields, packagingusps.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackagingUSPSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packagingusps.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackagingUSPSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packagingusps.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown PackagingUSPS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackagingUSPSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packagingusps.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown PackagingUSPS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackagingUSPSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackagingUSPSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackagingUSPSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackagingUSPS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackagingUSPSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackagingUSPSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackagingUSPSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackagingUSPS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackagingUSPSMutation) ResetField(name string) error {
	switch name {
	case packagingusps.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown PackagingUSPS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackagingUSPSMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, packagingusps.EdgeTenant)
	}
	if m.packaging != nil {
		edges = append(edges, packagingusps.EdgePackaging)
	}
	if m.packaging_usps_rate_indicator != nil {
		edges = append(edges, packagingusps.EdgePackagingUSPSRateIndicator)
	}
	if m.packaging_usps_processing_category != nil {
		edges = append(edges, packagingusps.EdgePackagingUSPSProcessingCategory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackagingUSPSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packagingusps.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case packagingusps.EdgePackaging:
		if id := m.packaging; id != nil {
			return []ent.Value{*id}
		}
	case packagingusps.EdgePackagingUSPSRateIndicator:
		if id := m.packaging_usps_rate_indicator; id != nil {
			return []ent.Value{*id}
		}
	case packagingusps.EdgePackagingUSPSProcessingCategory:
		if id := m.packaging_usps_processing_category; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackagingUSPSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackagingUSPSMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackagingUSPSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, packagingusps.EdgeTenant)
	}
	if m.clearedpackaging {
		edges = append(edges, packagingusps.EdgePackaging)
	}
	if m.clearedpackaging_usps_rate_indicator {
		edges = append(edges, packagingusps.EdgePackagingUSPSRateIndicator)
	}
	if m.clearedpackaging_usps_processing_category {
		edges = append(edges, packagingusps.EdgePackagingUSPSProcessingCategory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackagingUSPSMutation) EdgeCleared(name string) bool {
	switch name {
	case packagingusps.EdgeTenant:
		return m.clearedtenant
	case packagingusps.EdgePackaging:
		return m.clearedpackaging
	case packagingusps.EdgePackagingUSPSRateIndicator:
		return m.clearedpackaging_usps_rate_indicator
	case packagingusps.EdgePackagingUSPSProcessingCategory:
		return m.clearedpackaging_usps_processing_category
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackagingUSPSMutation) ClearEdge(name string) error {
	switch name {
	case packagingusps.EdgeTenant:
		m.ClearTenant()
		return nil
	case packagingusps.EdgePackaging:
		m.ClearPackaging()
		return nil
	case packagingusps.EdgePackagingUSPSRateIndicator:
		m.ClearPackagingUSPSRateIndicator()
		return nil
	case packagingusps.EdgePackagingUSPSProcessingCategory:
		m.ClearPackagingUSPSProcessingCategory()
		return nil
	}
	return fmt.Errorf("unknown PackagingUSPS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackagingUSPSMutation) ResetEdge(name string) error {
	switch name {
	case packagingusps.EdgeTenant:
		m.ResetTenant()
		return nil
	case packagingusps.EdgePackaging:
		m.ResetPackaging()
		return nil
	case packagingusps.EdgePackagingUSPSRateIndicator:
		m.ResetPackagingUSPSRateIndicator()
		return nil
	case packagingusps.EdgePackagingUSPSProcessingCategory:
		m.ResetPackagingUSPSProcessingCategory()
		return nil
	}
	return fmt.Errorf("unknown PackagingUSPS edge %s", name)
}

// PackagingUSPSProcessingCategoryMutation represents an operation that mutates the PackagingUSPSProcessingCategory nodes in the graph.
type PackagingUSPSProcessingCategoryMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.ID
	name                *string
	processing_category *packaginguspsprocessingcategory.ProcessingCategory
	clearedFields       map[string]struct{}
	done                bool
	oldValue            func(context.Context) (*PackagingUSPSProcessingCategory, error)
	predicates          []predicate.PackagingUSPSProcessingCategory
}

var _ ent.Mutation = (*PackagingUSPSProcessingCategoryMutation)(nil)

// packaginguspsprocessingcategoryOption allows management of the mutation configuration using functional options.
type packaginguspsprocessingcategoryOption func(*PackagingUSPSProcessingCategoryMutation)

// newPackagingUSPSProcessingCategoryMutation creates new mutation for the PackagingUSPSProcessingCategory entity.
func newPackagingUSPSProcessingCategoryMutation(c config, op Op, opts ...packaginguspsprocessingcategoryOption) *PackagingUSPSProcessingCategoryMutation {
	m := &PackagingUSPSProcessingCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypePackagingUSPSProcessingCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackagingUSPSProcessingCategoryID sets the ID field of the mutation.
func withPackagingUSPSProcessingCategoryID(id pulid.ID) packaginguspsprocessingcategoryOption {
	return func(m *PackagingUSPSProcessingCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PackagingUSPSProcessingCategory
		)
		m.oldValue = func(ctx context.Context) (*PackagingUSPSProcessingCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackagingUSPSProcessingCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackagingUSPSProcessingCategory sets the old PackagingUSPSProcessingCategory of the mutation.
func withPackagingUSPSProcessingCategory(node *PackagingUSPSProcessingCategory) packaginguspsprocessingcategoryOption {
	return func(m *PackagingUSPSProcessingCategoryMutation) {
		m.oldValue = func(context.Context) (*PackagingUSPSProcessingCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackagingUSPSProcessingCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackagingUSPSProcessingCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PackagingUSPSProcessingCategory entities.
func (m *PackagingUSPSProcessingCategoryMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackagingUSPSProcessingCategoryMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackagingUSPSProcessingCategoryMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackagingUSPSProcessingCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PackagingUSPSProcessingCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PackagingUSPSProcessingCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PackagingUSPSProcessingCategory entity.
// If the PackagingUSPSProcessingCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingUSPSProcessingCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PackagingUSPSProcessingCategoryMutation) ResetName() {
	m.name = nil
}

// SetProcessingCategory sets the "processing_category" field.
func (m *PackagingUSPSProcessingCategoryMutation) SetProcessingCategory(pc packaginguspsprocessingcategory.ProcessingCategory) {
	m.processing_category = &pc
}

// ProcessingCategory returns the value of the "processing_category" field in the mutation.
func (m *PackagingUSPSProcessingCategoryMutation) ProcessingCategory() (r packaginguspsprocessingcategory.ProcessingCategory, exists bool) {
	v := m.processing_category
	if v == nil {
		return
	}
	return *v, true
}

// OldProcessingCategory returns the old "processing_category" field's value of the PackagingUSPSProcessingCategory entity.
// If the PackagingUSPSProcessingCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingUSPSProcessingCategoryMutation) OldProcessingCategory(ctx context.Context) (v packaginguspsprocessingcategory.ProcessingCategory, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProcessingCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProcessingCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProcessingCategory: %w", err)
	}
	return oldValue.ProcessingCategory, nil
}

// ResetProcessingCategory resets all changes to the "processing_category" field.
func (m *PackagingUSPSProcessingCategoryMutation) ResetProcessingCategory() {
	m.processing_category = nil
}

// Where appends a list predicates to the PackagingUSPSProcessingCategoryMutation builder.
func (m *PackagingUSPSProcessingCategoryMutation) Where(ps ...predicate.PackagingUSPSProcessingCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackagingUSPSProcessingCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackagingUSPSProcessingCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackagingUSPSProcessingCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackagingUSPSProcessingCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackagingUSPSProcessingCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackagingUSPSProcessingCategory).
func (m *PackagingUSPSProcessingCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackagingUSPSProcessingCategoryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, packaginguspsprocessingcategory.FieldName)
	}
	if m.processing_category != nil {
		fields = append(fields, packaginguspsprocessingcategory.FieldProcessingCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackagingUSPSProcessingCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packaginguspsprocessingcategory.FieldName:
		return m.Name()
	case packaginguspsprocessingcategory.FieldProcessingCategory:
		return m.ProcessingCategory()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackagingUSPSProcessingCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packaginguspsprocessingcategory.FieldName:
		return m.OldName(ctx)
	case packaginguspsprocessingcategory.FieldProcessingCategory:
		return m.OldProcessingCategory(ctx)
	}
	return nil, fmt.Errorf("unknown PackagingUSPSProcessingCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackagingUSPSProcessingCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packaginguspsprocessingcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case packaginguspsprocessingcategory.FieldProcessingCategory:
		v, ok := value.(packaginguspsprocessingcategory.ProcessingCategory)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProcessingCategory(v)
		return nil
	}
	return fmt.Errorf("unknown PackagingUSPSProcessingCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackagingUSPSProcessingCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackagingUSPSProcessingCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackagingUSPSProcessingCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackagingUSPSProcessingCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackagingUSPSProcessingCategoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackagingUSPSProcessingCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackagingUSPSProcessingCategoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackagingUSPSProcessingCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackagingUSPSProcessingCategoryMutation) ResetField(name string) error {
	switch name {
	case packaginguspsprocessingcategory.FieldName:
		m.ResetName()
		return nil
	case packaginguspsprocessingcategory.FieldProcessingCategory:
		m.ResetProcessingCategory()
		return nil
	}
	return fmt.Errorf("unknown PackagingUSPSProcessingCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackagingUSPSProcessingCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackagingUSPSProcessingCategoryMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackagingUSPSProcessingCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackagingUSPSProcessingCategoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackagingUSPSProcessingCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackagingUSPSProcessingCategoryMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackagingUSPSProcessingCategoryMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown PackagingUSPSProcessingCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackagingUSPSProcessingCategoryMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown PackagingUSPSProcessingCategory edge %s", name)
}

// PackagingUSPSRateIndicatorMutation represents an operation that mutates the PackagingUSPSRateIndicator nodes in the graph.
type PackagingUSPSRateIndicatorMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.ID
	code                  *string
	name                  *string
	clearedFields         map[string]struct{}
	packaging_usps        map[pulid.ID]struct{}
	removedpackaging_usps map[pulid.ID]struct{}
	clearedpackaging_usps bool
	done                  bool
	oldValue              func(context.Context) (*PackagingUSPSRateIndicator, error)
	predicates            []predicate.PackagingUSPSRateIndicator
}

var _ ent.Mutation = (*PackagingUSPSRateIndicatorMutation)(nil)

// packaginguspsrateindicatorOption allows management of the mutation configuration using functional options.
type packaginguspsrateindicatorOption func(*PackagingUSPSRateIndicatorMutation)

// newPackagingUSPSRateIndicatorMutation creates new mutation for the PackagingUSPSRateIndicator entity.
func newPackagingUSPSRateIndicatorMutation(c config, op Op, opts ...packaginguspsrateindicatorOption) *PackagingUSPSRateIndicatorMutation {
	m := &PackagingUSPSRateIndicatorMutation{
		config:        c,
		op:            op,
		typ:           TypePackagingUSPSRateIndicator,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPackagingUSPSRateIndicatorID sets the ID field of the mutation.
func withPackagingUSPSRateIndicatorID(id pulid.ID) packaginguspsrateindicatorOption {
	return func(m *PackagingUSPSRateIndicatorMutation) {
		var (
			err   error
			once  sync.Once
			value *PackagingUSPSRateIndicator
		)
		m.oldValue = func(ctx context.Context) (*PackagingUSPSRateIndicator, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PackagingUSPSRateIndicator.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPackagingUSPSRateIndicator sets the old PackagingUSPSRateIndicator of the mutation.
func withPackagingUSPSRateIndicator(node *PackagingUSPSRateIndicator) packaginguspsrateindicatorOption {
	return func(m *PackagingUSPSRateIndicatorMutation) {
		m.oldValue = func(context.Context) (*PackagingUSPSRateIndicator, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PackagingUSPSRateIndicatorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PackagingUSPSRateIndicatorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PackagingUSPSRateIndicator entities.
func (m *PackagingUSPSRateIndicatorMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PackagingUSPSRateIndicatorMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PackagingUSPSRateIndicatorMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PackagingUSPSRateIndicator.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCode sets the "code" field.
func (m *PackagingUSPSRateIndicatorMutation) SetCode(s string) {
	m.code = &s
}

// Code returns the value of the "code" field in the mutation.
func (m *PackagingUSPSRateIndicatorMutation) Code() (r string, exists bool) {
	v := m.code
	if v == nil {
		return
	}
	return *v, true
}

// OldCode returns the old "code" field's value of the PackagingUSPSRateIndicator entity.
// If the PackagingUSPSRateIndicator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingUSPSRateIndicatorMutation) OldCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCode: %w", err)
	}
	return oldValue.Code, nil
}

// ResetCode resets all changes to the "code" field.
func (m *PackagingUSPSRateIndicatorMutation) ResetCode() {
	m.code = nil
}

// SetName sets the "name" field.
func (m *PackagingUSPSRateIndicatorMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PackagingUSPSRateIndicatorMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PackagingUSPSRateIndicator entity.
// If the PackagingUSPSRateIndicator object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PackagingUSPSRateIndicatorMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PackagingUSPSRateIndicatorMutation) ResetName() {
	m.name = nil
}

// AddPackagingUspIDs adds the "packaging_usps" edge to the PackagingUSPS entity by ids.
func (m *PackagingUSPSRateIndicatorMutation) AddPackagingUspIDs(ids ...pulid.ID) {
	if m.packaging_usps == nil {
		m.packaging_usps = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.packaging_usps[ids[i]] = struct{}{}
	}
}

// ClearPackagingUSPS clears the "packaging_usps" edge to the PackagingUSPS entity.
func (m *PackagingUSPSRateIndicatorMutation) ClearPackagingUSPS() {
	m.clearedpackaging_usps = true
}

// PackagingUSPSCleared reports if the "packaging_usps" edge to the PackagingUSPS entity was cleared.
func (m *PackagingUSPSRateIndicatorMutation) PackagingUSPSCleared() bool {
	return m.clearedpackaging_usps
}

// RemovePackagingUspIDs removes the "packaging_usps" edge to the PackagingUSPS entity by IDs.
func (m *PackagingUSPSRateIndicatorMutation) RemovePackagingUspIDs(ids ...pulid.ID) {
	if m.removedpackaging_usps == nil {
		m.removedpackaging_usps = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.packaging_usps, ids[i])
		m.removedpackaging_usps[ids[i]] = struct{}{}
	}
}

// RemovedPackagingUSPS returns the removed IDs of the "packaging_usps" edge to the PackagingUSPS entity.
func (m *PackagingUSPSRateIndicatorMutation) RemovedPackagingUSPSIDs() (ids []pulid.ID) {
	for id := range m.removedpackaging_usps {
		ids = append(ids, id)
	}
	return
}

// PackagingUSPSIDs returns the "packaging_usps" edge IDs in the mutation.
func (m *PackagingUSPSRateIndicatorMutation) PackagingUSPSIDs() (ids []pulid.ID) {
	for id := range m.packaging_usps {
		ids = append(ids, id)
	}
	return
}

// ResetPackagingUSPS resets all changes to the "packaging_usps" edge.
func (m *PackagingUSPSRateIndicatorMutation) ResetPackagingUSPS() {
	m.packaging_usps = nil
	m.clearedpackaging_usps = false
	m.removedpackaging_usps = nil
}

// Where appends a list predicates to the PackagingUSPSRateIndicatorMutation builder.
func (m *PackagingUSPSRateIndicatorMutation) Where(ps ...predicate.PackagingUSPSRateIndicator) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PackagingUSPSRateIndicatorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PackagingUSPSRateIndicatorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PackagingUSPSRateIndicator, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PackagingUSPSRateIndicatorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PackagingUSPSRateIndicatorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PackagingUSPSRateIndicator).
func (m *PackagingUSPSRateIndicatorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PackagingUSPSRateIndicatorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.code != nil {
		fields = append(fields, packaginguspsrateindicator.FieldCode)
	}
	if m.name != nil {
		fields = append(fields, packaginguspsrateindicator.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PackagingUSPSRateIndicatorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case packaginguspsrateindicator.FieldCode:
		return m.Code()
	case packaginguspsrateindicator.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PackagingUSPSRateIndicatorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case packaginguspsrateindicator.FieldCode:
		return m.OldCode(ctx)
	case packaginguspsrateindicator.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown PackagingUSPSRateIndicator field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackagingUSPSRateIndicatorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case packaginguspsrateindicator.FieldCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCode(v)
		return nil
	case packaginguspsrateindicator.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown PackagingUSPSRateIndicator field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PackagingUSPSRateIndicatorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PackagingUSPSRateIndicatorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PackagingUSPSRateIndicatorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PackagingUSPSRateIndicator numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PackagingUSPSRateIndicatorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PackagingUSPSRateIndicatorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PackagingUSPSRateIndicatorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PackagingUSPSRateIndicator nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PackagingUSPSRateIndicatorMutation) ResetField(name string) error {
	switch name {
	case packaginguspsrateindicator.FieldCode:
		m.ResetCode()
		return nil
	case packaginguspsrateindicator.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown PackagingUSPSRateIndicator field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PackagingUSPSRateIndicatorMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.packaging_usps != nil {
		edges = append(edges, packaginguspsrateindicator.EdgePackagingUSPS)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PackagingUSPSRateIndicatorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case packaginguspsrateindicator.EdgePackagingUSPS:
		ids := make([]ent.Value, 0, len(m.packaging_usps))
		for id := range m.packaging_usps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PackagingUSPSRateIndicatorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedpackaging_usps != nil {
		edges = append(edges, packaginguspsrateindicator.EdgePackagingUSPS)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PackagingUSPSRateIndicatorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case packaginguspsrateindicator.EdgePackagingUSPS:
		ids := make([]ent.Value, 0, len(m.removedpackaging_usps))
		for id := range m.removedpackaging_usps {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PackagingUSPSRateIndicatorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpackaging_usps {
		edges = append(edges, packaginguspsrateindicator.EdgePackagingUSPS)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PackagingUSPSRateIndicatorMutation) EdgeCleared(name string) bool {
	switch name {
	case packaginguspsrateindicator.EdgePackagingUSPS:
		return m.clearedpackaging_usps
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PackagingUSPSRateIndicatorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PackagingUSPSRateIndicator unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PackagingUSPSRateIndicatorMutation) ResetEdge(name string) error {
	switch name {
	case packaginguspsrateindicator.EdgePackagingUSPS:
		m.ResetPackagingUSPS()
		return nil
	}
	return fmt.Errorf("unknown PackagingUSPSRateIndicator edge %s", name)
}

// PalletMutation represents an operation that mutates the Pallet nodes in the graph.
type PalletMutation struct {
	config
	op                               Op
	typ                              string
	id                               *pulid.ID
	public_id                        *string
	description                      *string
	clearedFields                    map[string]struct{}
	tenant                           *pulid.ID
	clearedtenant                    bool
	orders                           map[pulid.ID]struct{}
	removedorders                    map[pulid.ID]struct{}
	clearedorders                    bool
	packaging                        *pulid.ID
	clearedpackaging                 bool
	consolidation                    *pulid.ID
	clearedconsolidation             bool
	shipment_pallet                  *pulid.ID
	clearedshipment_pallet           bool
	cancelled_shipment_pallet        map[pulid.ID]struct{}
	removedcancelled_shipment_pallet map[pulid.ID]struct{}
	clearedcancelled_shipment_pallet bool
	done                             bool
	oldValue                         func(context.Context) (*Pallet, error)
	predicates                       []predicate.Pallet
}

var _ ent.Mutation = (*PalletMutation)(nil)

// palletOption allows management of the mutation configuration using functional options.
type palletOption func(*PalletMutation)

// newPalletMutation creates new mutation for the Pallet entity.
func newPalletMutation(c config, op Op, opts ...palletOption) *PalletMutation {
	m := &PalletMutation{
		config:        c,
		op:            op,
		typ:           TypePallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPalletID sets the ID field of the mutation.
func withPalletID(id pulid.ID) palletOption {
	return func(m *PalletMutation) {
		var (
			err   error
			once  sync.Once
			value *Pallet
		)
		m.oldValue = func(ctx context.Context) (*Pallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Pallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPallet sets the old Pallet of the mutation.
func withPallet(node *Pallet) palletOption {
	return func(m *PalletMutation) {
		m.oldValue = func(context.Context) (*Pallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Pallet entities.
func (m *PalletMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PalletMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PalletMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Pallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PalletMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PalletMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Pallet entity.
// If the Pallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalletMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PalletMutation) ResetTenantID() {
	m.tenant = nil
}

// SetPublicID sets the "public_id" field.
func (m *PalletMutation) SetPublicID(s string) {
	m.public_id = &s
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *PalletMutation) PublicID() (r string, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the Pallet entity.
// If the Pallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalletMutation) OldPublicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *PalletMutation) ResetPublicID() {
	m.public_id = nil
}

// SetDescription sets the "description" field.
func (m *PalletMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PalletMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Pallet entity.
// If the Pallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PalletMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *PalletMutation) ResetDescription() {
	m.description = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PalletMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[pallet.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PalletMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PalletMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PalletMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddOrderIDs adds the "orders" edge to the Order entity by ids.
func (m *PalletMutation) AddOrderIDs(ids ...pulid.ID) {
	if m.orders == nil {
		m.orders = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.orders[ids[i]] = struct{}{}
	}
}

// ClearOrders clears the "orders" edge to the Order entity.
func (m *PalletMutation) ClearOrders() {
	m.clearedorders = true
}

// OrdersCleared reports if the "orders" edge to the Order entity was cleared.
func (m *PalletMutation) OrdersCleared() bool {
	return m.clearedorders
}

// RemoveOrderIDs removes the "orders" edge to the Order entity by IDs.
func (m *PalletMutation) RemoveOrderIDs(ids ...pulid.ID) {
	if m.removedorders == nil {
		m.removedorders = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.orders, ids[i])
		m.removedorders[ids[i]] = struct{}{}
	}
}

// RemovedOrders returns the removed IDs of the "orders" edge to the Order entity.
func (m *PalletMutation) RemovedOrdersIDs() (ids []pulid.ID) {
	for id := range m.removedorders {
		ids = append(ids, id)
	}
	return
}

// OrdersIDs returns the "orders" edge IDs in the mutation.
func (m *PalletMutation) OrdersIDs() (ids []pulid.ID) {
	for id := range m.orders {
		ids = append(ids, id)
	}
	return
}

// ResetOrders resets all changes to the "orders" edge.
func (m *PalletMutation) ResetOrders() {
	m.orders = nil
	m.clearedorders = false
	m.removedorders = nil
}

// SetPackagingID sets the "packaging" edge to the Packaging entity by id.
func (m *PalletMutation) SetPackagingID(id pulid.ID) {
	m.packaging = &id
}

// ClearPackaging clears the "packaging" edge to the Packaging entity.
func (m *PalletMutation) ClearPackaging() {
	m.clearedpackaging = true
}

// PackagingCleared reports if the "packaging" edge to the Packaging entity was cleared.
func (m *PalletMutation) PackagingCleared() bool {
	return m.clearedpackaging
}

// PackagingID returns the "packaging" edge ID in the mutation.
func (m *PalletMutation) PackagingID() (id pulid.ID, exists bool) {
	if m.packaging != nil {
		return *m.packaging, true
	}
	return
}

// PackagingIDs returns the "packaging" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackagingID instead. It exists only for internal usage by the builders.
func (m *PalletMutation) PackagingIDs() (ids []pulid.ID) {
	if id := m.packaging; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackaging resets all changes to the "packaging" edge.
func (m *PalletMutation) ResetPackaging() {
	m.packaging = nil
	m.clearedpackaging = false
}

// SetConsolidationID sets the "consolidation" edge to the Consolidation entity by id.
func (m *PalletMutation) SetConsolidationID(id pulid.ID) {
	m.consolidation = &id
}

// ClearConsolidation clears the "consolidation" edge to the Consolidation entity.
func (m *PalletMutation) ClearConsolidation() {
	m.clearedconsolidation = true
}

// ConsolidationCleared reports if the "consolidation" edge to the Consolidation entity was cleared.
func (m *PalletMutation) ConsolidationCleared() bool {
	return m.clearedconsolidation
}

// ConsolidationID returns the "consolidation" edge ID in the mutation.
func (m *PalletMutation) ConsolidationID() (id pulid.ID, exists bool) {
	if m.consolidation != nil {
		return *m.consolidation, true
	}
	return
}

// ConsolidationIDs returns the "consolidation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConsolidationID instead. It exists only for internal usage by the builders.
func (m *PalletMutation) ConsolidationIDs() (ids []pulid.ID) {
	if id := m.consolidation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConsolidation resets all changes to the "consolidation" edge.
func (m *PalletMutation) ResetConsolidation() {
	m.consolidation = nil
	m.clearedconsolidation = false
}

// SetShipmentPalletID sets the "shipment_pallet" edge to the ShipmentPallet entity by id.
func (m *PalletMutation) SetShipmentPalletID(id pulid.ID) {
	m.shipment_pallet = &id
}

// ClearShipmentPallet clears the "shipment_pallet" edge to the ShipmentPallet entity.
func (m *PalletMutation) ClearShipmentPallet() {
	m.clearedshipment_pallet = true
}

// ShipmentPalletCleared reports if the "shipment_pallet" edge to the ShipmentPallet entity was cleared.
func (m *PalletMutation) ShipmentPalletCleared() bool {
	return m.clearedshipment_pallet
}

// ShipmentPalletID returns the "shipment_pallet" edge ID in the mutation.
func (m *PalletMutation) ShipmentPalletID() (id pulid.ID, exists bool) {
	if m.shipment_pallet != nil {
		return *m.shipment_pallet, true
	}
	return
}

// ShipmentPalletIDs returns the "shipment_pallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentPalletID instead. It exists only for internal usage by the builders.
func (m *PalletMutation) ShipmentPalletIDs() (ids []pulid.ID) {
	if id := m.shipment_pallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentPallet resets all changes to the "shipment_pallet" edge.
func (m *PalletMutation) ResetShipmentPallet() {
	m.shipment_pallet = nil
	m.clearedshipment_pallet = false
}

// AddCancelledShipmentPalletIDs adds the "cancelled_shipment_pallet" edge to the ShipmentPallet entity by ids.
func (m *PalletMutation) AddCancelledShipmentPalletIDs(ids ...pulid.ID) {
	if m.cancelled_shipment_pallet == nil {
		m.cancelled_shipment_pallet = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.cancelled_shipment_pallet[ids[i]] = struct{}{}
	}
}

// ClearCancelledShipmentPallet clears the "cancelled_shipment_pallet" edge to the ShipmentPallet entity.
func (m *PalletMutation) ClearCancelledShipmentPallet() {
	m.clearedcancelled_shipment_pallet = true
}

// CancelledShipmentPalletCleared reports if the "cancelled_shipment_pallet" edge to the ShipmentPallet entity was cleared.
func (m *PalletMutation) CancelledShipmentPalletCleared() bool {
	return m.clearedcancelled_shipment_pallet
}

// RemoveCancelledShipmentPalletIDs removes the "cancelled_shipment_pallet" edge to the ShipmentPallet entity by IDs.
func (m *PalletMutation) RemoveCancelledShipmentPalletIDs(ids ...pulid.ID) {
	if m.removedcancelled_shipment_pallet == nil {
		m.removedcancelled_shipment_pallet = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.cancelled_shipment_pallet, ids[i])
		m.removedcancelled_shipment_pallet[ids[i]] = struct{}{}
	}
}

// RemovedCancelledShipmentPallet returns the removed IDs of the "cancelled_shipment_pallet" edge to the ShipmentPallet entity.
func (m *PalletMutation) RemovedCancelledShipmentPalletIDs() (ids []pulid.ID) {
	for id := range m.removedcancelled_shipment_pallet {
		ids = append(ids, id)
	}
	return
}

// CancelledShipmentPalletIDs returns the "cancelled_shipment_pallet" edge IDs in the mutation.
func (m *PalletMutation) CancelledShipmentPalletIDs() (ids []pulid.ID) {
	for id := range m.cancelled_shipment_pallet {
		ids = append(ids, id)
	}
	return
}

// ResetCancelledShipmentPallet resets all changes to the "cancelled_shipment_pallet" edge.
func (m *PalletMutation) ResetCancelledShipmentPallet() {
	m.cancelled_shipment_pallet = nil
	m.clearedcancelled_shipment_pallet = false
	m.removedcancelled_shipment_pallet = nil
}

// Where appends a list predicates to the PalletMutation builder.
func (m *PalletMutation) Where(ps ...predicate.Pallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Pallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Pallet).
func (m *PalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PalletMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, pallet.FieldTenantID)
	}
	if m.public_id != nil {
		fields = append(fields, pallet.FieldPublicID)
	}
	if m.description != nil {
		fields = append(fields, pallet.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case pallet.FieldTenantID:
		return m.TenantID()
	case pallet.FieldPublicID:
		return m.PublicID()
	case pallet.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case pallet.FieldTenantID:
		return m.OldTenantID(ctx)
	case pallet.FieldPublicID:
		return m.OldPublicID(ctx)
	case pallet.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown Pallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case pallet.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case pallet.FieldPublicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case pallet.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown Pallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PalletMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PalletMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Pallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PalletMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PalletMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Pallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PalletMutation) ResetField(name string) error {
	switch name {
	case pallet.FieldTenantID:
		m.ResetTenantID()
		return nil
	case pallet.FieldPublicID:
		m.ResetPublicID()
		return nil
	case pallet.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown Pallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 6)
	if m.tenant != nil {
		edges = append(edges, pallet.EdgeTenant)
	}
	if m.orders != nil {
		edges = append(edges, pallet.EdgeOrders)
	}
	if m.packaging != nil {
		edges = append(edges, pallet.EdgePackaging)
	}
	if m.consolidation != nil {
		edges = append(edges, pallet.EdgeConsolidation)
	}
	if m.shipment_pallet != nil {
		edges = append(edges, pallet.EdgeShipmentPallet)
	}
	if m.cancelled_shipment_pallet != nil {
		edges = append(edges, pallet.EdgeCancelledShipmentPallet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case pallet.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case pallet.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.orders))
		for id := range m.orders {
			ids = append(ids, id)
		}
		return ids
	case pallet.EdgePackaging:
		if id := m.packaging; id != nil {
			return []ent.Value{*id}
		}
	case pallet.EdgeConsolidation:
		if id := m.consolidation; id != nil {
			return []ent.Value{*id}
		}
	case pallet.EdgeShipmentPallet:
		if id := m.shipment_pallet; id != nil {
			return []ent.Value{*id}
		}
	case pallet.EdgeCancelledShipmentPallet:
		ids := make([]ent.Value, 0, len(m.cancelled_shipment_pallet))
		for id := range m.cancelled_shipment_pallet {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 6)
	if m.removedorders != nil {
		edges = append(edges, pallet.EdgeOrders)
	}
	if m.removedcancelled_shipment_pallet != nil {
		edges = append(edges, pallet.EdgeCancelledShipmentPallet)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PalletMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case pallet.EdgeOrders:
		ids := make([]ent.Value, 0, len(m.removedorders))
		for id := range m.removedorders {
			ids = append(ids, id)
		}
		return ids
	case pallet.EdgeCancelledShipmentPallet:
		ids := make([]ent.Value, 0, len(m.removedcancelled_shipment_pallet))
		for id := range m.removedcancelled_shipment_pallet {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 6)
	if m.clearedtenant {
		edges = append(edges, pallet.EdgeTenant)
	}
	if m.clearedorders {
		edges = append(edges, pallet.EdgeOrders)
	}
	if m.clearedpackaging {
		edges = append(edges, pallet.EdgePackaging)
	}
	if m.clearedconsolidation {
		edges = append(edges, pallet.EdgeConsolidation)
	}
	if m.clearedshipment_pallet {
		edges = append(edges, pallet.EdgeShipmentPallet)
	}
	if m.clearedcancelled_shipment_pallet {
		edges = append(edges, pallet.EdgeCancelledShipmentPallet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PalletMutation) EdgeCleared(name string) bool {
	switch name {
	case pallet.EdgeTenant:
		return m.clearedtenant
	case pallet.EdgeOrders:
		return m.clearedorders
	case pallet.EdgePackaging:
		return m.clearedpackaging
	case pallet.EdgeConsolidation:
		return m.clearedconsolidation
	case pallet.EdgeShipmentPallet:
		return m.clearedshipment_pallet
	case pallet.EdgeCancelledShipmentPallet:
		return m.clearedcancelled_shipment_pallet
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PalletMutation) ClearEdge(name string) error {
	switch name {
	case pallet.EdgeTenant:
		m.ClearTenant()
		return nil
	case pallet.EdgePackaging:
		m.ClearPackaging()
		return nil
	case pallet.EdgeConsolidation:
		m.ClearConsolidation()
		return nil
	case pallet.EdgeShipmentPallet:
		m.ClearShipmentPallet()
		return nil
	}
	return fmt.Errorf("unknown Pallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PalletMutation) ResetEdge(name string) error {
	switch name {
	case pallet.EdgeTenant:
		m.ResetTenant()
		return nil
	case pallet.EdgeOrders:
		m.ResetOrders()
		return nil
	case pallet.EdgePackaging:
		m.ResetPackaging()
		return nil
	case pallet.EdgeConsolidation:
		m.ResetConsolidation()
		return nil
	case pallet.EdgeShipmentPallet:
		m.ResetShipmentPallet()
		return nil
	case pallet.EdgeCancelledShipmentPallet:
		m.ResetCancelledShipmentPallet()
		return nil
	}
	return fmt.Errorf("unknown Pallet edge %s", name)
}

// ParcelShopMutation represents an operation that mutates the ParcelShop nodes in the graph.
type ParcelShopMutation struct {
	config
	op                           Op
	typ                          string
	id                           *pulid.ID
	name                         *string
	last_updated                 *time.Time
	clearedFields                map[string]struct{}
	parcel_shop_dao              *pulid.ID
	clearedparcel_shop_dao       bool
	parcel_shop_post_nord        *pulid.ID
	clearedparcel_shop_post_nord bool
	parcel_shop_gls              *pulid.ID
	clearedparcel_shop_gls       bool
	parcel_shop_bring            *pulid.ID
	clearedparcel_shop_bring     bool
	carrier_brand                *pulid.ID
	clearedcarrier_brand         bool
	address                      *pulid.ID
	clearedaddress               bool
	colli                        map[pulid.ID]struct{}
	removedcolli                 map[pulid.ID]struct{}
	clearedcolli                 bool
	business_hours_period        map[pulid.ID]struct{}
	removedbusiness_hours_period map[pulid.ID]struct{}
	clearedbusiness_hours_period bool
	done                         bool
	oldValue                     func(context.Context) (*ParcelShop, error)
	predicates                   []predicate.ParcelShop
}

var _ ent.Mutation = (*ParcelShopMutation)(nil)

// parcelshopOption allows management of the mutation configuration using functional options.
type parcelshopOption func(*ParcelShopMutation)

// newParcelShopMutation creates new mutation for the ParcelShop entity.
func newParcelShopMutation(c config, op Op, opts ...parcelshopOption) *ParcelShopMutation {
	m := &ParcelShopMutation{
		config:        c,
		op:            op,
		typ:           TypeParcelShop,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParcelShopID sets the ID field of the mutation.
func withParcelShopID(id pulid.ID) parcelshopOption {
	return func(m *ParcelShopMutation) {
		var (
			err   error
			once  sync.Once
			value *ParcelShop
		)
		m.oldValue = func(ctx context.Context) (*ParcelShop, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ParcelShop.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParcelShop sets the old ParcelShop of the mutation.
func withParcelShop(node *ParcelShop) parcelshopOption {
	return func(m *ParcelShopMutation) {
		m.oldValue = func(context.Context) (*ParcelShop, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParcelShopMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParcelShopMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ParcelShop entities.
func (m *ParcelShopMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParcelShopMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParcelShopMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ParcelShop.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *ParcelShopMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ParcelShopMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ParcelShop entity.
// If the ParcelShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ParcelShopMutation) ResetName() {
	m.name = nil
}

// SetLastUpdated sets the "last_updated" field.
func (m *ParcelShopMutation) SetLastUpdated(t time.Time) {
	m.last_updated = &t
}

// LastUpdated returns the value of the "last_updated" field in the mutation.
func (m *ParcelShopMutation) LastUpdated() (r time.Time, exists bool) {
	v := m.last_updated
	if v == nil {
		return
	}
	return *v, true
}

// OldLastUpdated returns the old "last_updated" field's value of the ParcelShop entity.
// If the ParcelShop object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopMutation) OldLastUpdated(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastUpdated is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastUpdated requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastUpdated: %w", err)
	}
	return oldValue.LastUpdated, nil
}

// ResetLastUpdated resets all changes to the "last_updated" field.
func (m *ParcelShopMutation) ResetLastUpdated() {
	m.last_updated = nil
}

// SetParcelShopDAOID sets the "parcel_shop_dao" edge to the ParcelShopDAO entity by id.
func (m *ParcelShopMutation) SetParcelShopDAOID(id pulid.ID) {
	m.parcel_shop_dao = &id
}

// ClearParcelShopDAO clears the "parcel_shop_dao" edge to the ParcelShopDAO entity.
func (m *ParcelShopMutation) ClearParcelShopDAO() {
	m.clearedparcel_shop_dao = true
}

// ParcelShopDAOCleared reports if the "parcel_shop_dao" edge to the ParcelShopDAO entity was cleared.
func (m *ParcelShopMutation) ParcelShopDAOCleared() bool {
	return m.clearedparcel_shop_dao
}

// ParcelShopDAOID returns the "parcel_shop_dao" edge ID in the mutation.
func (m *ParcelShopMutation) ParcelShopDAOID() (id pulid.ID, exists bool) {
	if m.parcel_shop_dao != nil {
		return *m.parcel_shop_dao, true
	}
	return
}

// ParcelShopDAOIDs returns the "parcel_shop_dao" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopDAOID instead. It exists only for internal usage by the builders.
func (m *ParcelShopMutation) ParcelShopDAOIDs() (ids []pulid.ID) {
	if id := m.parcel_shop_dao; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShopDAO resets all changes to the "parcel_shop_dao" edge.
func (m *ParcelShopMutation) ResetParcelShopDAO() {
	m.parcel_shop_dao = nil
	m.clearedparcel_shop_dao = false
}

// SetParcelShopPostNordID sets the "parcel_shop_post_nord" edge to the ParcelShopPostNord entity by id.
func (m *ParcelShopMutation) SetParcelShopPostNordID(id pulid.ID) {
	m.parcel_shop_post_nord = &id
}

// ClearParcelShopPostNord clears the "parcel_shop_post_nord" edge to the ParcelShopPostNord entity.
func (m *ParcelShopMutation) ClearParcelShopPostNord() {
	m.clearedparcel_shop_post_nord = true
}

// ParcelShopPostNordCleared reports if the "parcel_shop_post_nord" edge to the ParcelShopPostNord entity was cleared.
func (m *ParcelShopMutation) ParcelShopPostNordCleared() bool {
	return m.clearedparcel_shop_post_nord
}

// ParcelShopPostNordID returns the "parcel_shop_post_nord" edge ID in the mutation.
func (m *ParcelShopMutation) ParcelShopPostNordID() (id pulid.ID, exists bool) {
	if m.parcel_shop_post_nord != nil {
		return *m.parcel_shop_post_nord, true
	}
	return
}

// ParcelShopPostNordIDs returns the "parcel_shop_post_nord" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopPostNordID instead. It exists only for internal usage by the builders.
func (m *ParcelShopMutation) ParcelShopPostNordIDs() (ids []pulid.ID) {
	if id := m.parcel_shop_post_nord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShopPostNord resets all changes to the "parcel_shop_post_nord" edge.
func (m *ParcelShopMutation) ResetParcelShopPostNord() {
	m.parcel_shop_post_nord = nil
	m.clearedparcel_shop_post_nord = false
}

// SetParcelShopGLSID sets the "parcel_shop_gls" edge to the ParcelShopGLS entity by id.
func (m *ParcelShopMutation) SetParcelShopGLSID(id pulid.ID) {
	m.parcel_shop_gls = &id
}

// ClearParcelShopGLS clears the "parcel_shop_gls" edge to the ParcelShopGLS entity.
func (m *ParcelShopMutation) ClearParcelShopGLS() {
	m.clearedparcel_shop_gls = true
}

// ParcelShopGLSCleared reports if the "parcel_shop_gls" edge to the ParcelShopGLS entity was cleared.
func (m *ParcelShopMutation) ParcelShopGLSCleared() bool {
	return m.clearedparcel_shop_gls
}

// ParcelShopGLSID returns the "parcel_shop_gls" edge ID in the mutation.
func (m *ParcelShopMutation) ParcelShopGLSID() (id pulid.ID, exists bool) {
	if m.parcel_shop_gls != nil {
		return *m.parcel_shop_gls, true
	}
	return
}

// ParcelShopGLSIDs returns the "parcel_shop_gls" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopGLSID instead. It exists only for internal usage by the builders.
func (m *ParcelShopMutation) ParcelShopGLSIDs() (ids []pulid.ID) {
	if id := m.parcel_shop_gls; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShopGLS resets all changes to the "parcel_shop_gls" edge.
func (m *ParcelShopMutation) ResetParcelShopGLS() {
	m.parcel_shop_gls = nil
	m.clearedparcel_shop_gls = false
}

// SetParcelShopBringID sets the "parcel_shop_bring" edge to the ParcelShopBring entity by id.
func (m *ParcelShopMutation) SetParcelShopBringID(id pulid.ID) {
	m.parcel_shop_bring = &id
}

// ClearParcelShopBring clears the "parcel_shop_bring" edge to the ParcelShopBring entity.
func (m *ParcelShopMutation) ClearParcelShopBring() {
	m.clearedparcel_shop_bring = true
}

// ParcelShopBringCleared reports if the "parcel_shop_bring" edge to the ParcelShopBring entity was cleared.
func (m *ParcelShopMutation) ParcelShopBringCleared() bool {
	return m.clearedparcel_shop_bring
}

// ParcelShopBringID returns the "parcel_shop_bring" edge ID in the mutation.
func (m *ParcelShopMutation) ParcelShopBringID() (id pulid.ID, exists bool) {
	if m.parcel_shop_bring != nil {
		return *m.parcel_shop_bring, true
	}
	return
}

// ParcelShopBringIDs returns the "parcel_shop_bring" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopBringID instead. It exists only for internal usage by the builders.
func (m *ParcelShopMutation) ParcelShopBringIDs() (ids []pulid.ID) {
	if id := m.parcel_shop_bring; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShopBring resets all changes to the "parcel_shop_bring" edge.
func (m *ParcelShopMutation) ResetParcelShopBring() {
	m.parcel_shop_bring = nil
	m.clearedparcel_shop_bring = false
}

// SetCarrierBrandID sets the "carrier_brand" edge to the CarrierBrand entity by id.
func (m *ParcelShopMutation) SetCarrierBrandID(id pulid.ID) {
	m.carrier_brand = &id
}

// ClearCarrierBrand clears the "carrier_brand" edge to the CarrierBrand entity.
func (m *ParcelShopMutation) ClearCarrierBrand() {
	m.clearedcarrier_brand = true
}

// CarrierBrandCleared reports if the "carrier_brand" edge to the CarrierBrand entity was cleared.
func (m *ParcelShopMutation) CarrierBrandCleared() bool {
	return m.clearedcarrier_brand
}

// CarrierBrandID returns the "carrier_brand" edge ID in the mutation.
func (m *ParcelShopMutation) CarrierBrandID() (id pulid.ID, exists bool) {
	if m.carrier_brand != nil {
		return *m.carrier_brand, true
	}
	return
}

// CarrierBrandIDs returns the "carrier_brand" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierBrandID instead. It exists only for internal usage by the builders.
func (m *ParcelShopMutation) CarrierBrandIDs() (ids []pulid.ID) {
	if id := m.carrier_brand; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrierBrand resets all changes to the "carrier_brand" edge.
func (m *ParcelShopMutation) ResetCarrierBrand() {
	m.carrier_brand = nil
	m.clearedcarrier_brand = false
}

// SetAddressID sets the "address" edge to the AddressGlobal entity by id.
func (m *ParcelShopMutation) SetAddressID(id pulid.ID) {
	m.address = &id
}

// ClearAddress clears the "address" edge to the AddressGlobal entity.
func (m *ParcelShopMutation) ClearAddress() {
	m.clearedaddress = true
}

// AddressCleared reports if the "address" edge to the AddressGlobal entity was cleared.
func (m *ParcelShopMutation) AddressCleared() bool {
	return m.clearedaddress
}

// AddressID returns the "address" edge ID in the mutation.
func (m *ParcelShopMutation) AddressID() (id pulid.ID, exists bool) {
	if m.address != nil {
		return *m.address, true
	}
	return
}

// AddressIDs returns the "address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressID instead. It exists only for internal usage by the builders.
func (m *ParcelShopMutation) AddressIDs() (ids []pulid.ID) {
	if id := m.address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddress resets all changes to the "address" edge.
func (m *ParcelShopMutation) ResetAddress() {
	m.address = nil
	m.clearedaddress = false
}

// AddColliIDs adds the "colli" edge to the Colli entity by ids.
func (m *ParcelShopMutation) AddColliIDs(ids ...pulid.ID) {
	if m.colli == nil {
		m.colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.colli[ids[i]] = struct{}{}
	}
}

// ClearColli clears the "colli" edge to the Colli entity.
func (m *ParcelShopMutation) ClearColli() {
	m.clearedcolli = true
}

// ColliCleared reports if the "colli" edge to the Colli entity was cleared.
func (m *ParcelShopMutation) ColliCleared() bool {
	return m.clearedcolli
}

// RemoveColliIDs removes the "colli" edge to the Colli entity by IDs.
func (m *ParcelShopMutation) RemoveColliIDs(ids ...pulid.ID) {
	if m.removedcolli == nil {
		m.removedcolli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.colli, ids[i])
		m.removedcolli[ids[i]] = struct{}{}
	}
}

// RemovedColli returns the removed IDs of the "colli" edge to the Colli entity.
func (m *ParcelShopMutation) RemovedColliIDs() (ids []pulid.ID) {
	for id := range m.removedcolli {
		ids = append(ids, id)
	}
	return
}

// ColliIDs returns the "colli" edge IDs in the mutation.
func (m *ParcelShopMutation) ColliIDs() (ids []pulid.ID) {
	for id := range m.colli {
		ids = append(ids, id)
	}
	return
}

// ResetColli resets all changes to the "colli" edge.
func (m *ParcelShopMutation) ResetColli() {
	m.colli = nil
	m.clearedcolli = false
	m.removedcolli = nil
}

// AddBusinessHoursPeriodIDs adds the "business_hours_period" edge to the BusinessHoursPeriod entity by ids.
func (m *ParcelShopMutation) AddBusinessHoursPeriodIDs(ids ...pulid.ID) {
	if m.business_hours_period == nil {
		m.business_hours_period = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.business_hours_period[ids[i]] = struct{}{}
	}
}

// ClearBusinessHoursPeriod clears the "business_hours_period" edge to the BusinessHoursPeriod entity.
func (m *ParcelShopMutation) ClearBusinessHoursPeriod() {
	m.clearedbusiness_hours_period = true
}

// BusinessHoursPeriodCleared reports if the "business_hours_period" edge to the BusinessHoursPeriod entity was cleared.
func (m *ParcelShopMutation) BusinessHoursPeriodCleared() bool {
	return m.clearedbusiness_hours_period
}

// RemoveBusinessHoursPeriodIDs removes the "business_hours_period" edge to the BusinessHoursPeriod entity by IDs.
func (m *ParcelShopMutation) RemoveBusinessHoursPeriodIDs(ids ...pulid.ID) {
	if m.removedbusiness_hours_period == nil {
		m.removedbusiness_hours_period = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.business_hours_period, ids[i])
		m.removedbusiness_hours_period[ids[i]] = struct{}{}
	}
}

// RemovedBusinessHoursPeriod returns the removed IDs of the "business_hours_period" edge to the BusinessHoursPeriod entity.
func (m *ParcelShopMutation) RemovedBusinessHoursPeriodIDs() (ids []pulid.ID) {
	for id := range m.removedbusiness_hours_period {
		ids = append(ids, id)
	}
	return
}

// BusinessHoursPeriodIDs returns the "business_hours_period" edge IDs in the mutation.
func (m *ParcelShopMutation) BusinessHoursPeriodIDs() (ids []pulid.ID) {
	for id := range m.business_hours_period {
		ids = append(ids, id)
	}
	return
}

// ResetBusinessHoursPeriod resets all changes to the "business_hours_period" edge.
func (m *ParcelShopMutation) ResetBusinessHoursPeriod() {
	m.business_hours_period = nil
	m.clearedbusiness_hours_period = false
	m.removedbusiness_hours_period = nil
}

// Where appends a list predicates to the ParcelShopMutation builder.
func (m *ParcelShopMutation) Where(ps ...predicate.ParcelShop) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ParcelShopMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ParcelShopMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ParcelShop, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ParcelShopMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ParcelShopMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ParcelShop).
func (m *ParcelShopMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParcelShopMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, parcelshop.FieldName)
	}
	if m.last_updated != nil {
		fields = append(fields, parcelshop.FieldLastUpdated)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParcelShopMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case parcelshop.FieldName:
		return m.Name()
	case parcelshop.FieldLastUpdated:
		return m.LastUpdated()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParcelShopMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case parcelshop.FieldName:
		return m.OldName(ctx)
	case parcelshop.FieldLastUpdated:
		return m.OldLastUpdated(ctx)
	}
	return nil, fmt.Errorf("unknown ParcelShop field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelShopMutation) SetField(name string, value ent.Value) error {
	switch name {
	case parcelshop.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case parcelshop.FieldLastUpdated:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastUpdated(v)
		return nil
	}
	return fmt.Errorf("unknown ParcelShop field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParcelShopMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParcelShopMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelShopMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ParcelShop numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParcelShopMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParcelShopMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParcelShopMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ParcelShop nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParcelShopMutation) ResetField(name string) error {
	switch name {
	case parcelshop.FieldName:
		m.ResetName()
		return nil
	case parcelshop.FieldLastUpdated:
		m.ResetLastUpdated()
		return nil
	}
	return fmt.Errorf("unknown ParcelShop field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParcelShopMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.parcel_shop_dao != nil {
		edges = append(edges, parcelshop.EdgeParcelShopDAO)
	}
	if m.parcel_shop_post_nord != nil {
		edges = append(edges, parcelshop.EdgeParcelShopPostNord)
	}
	if m.parcel_shop_gls != nil {
		edges = append(edges, parcelshop.EdgeParcelShopGLS)
	}
	if m.parcel_shop_bring != nil {
		edges = append(edges, parcelshop.EdgeParcelShopBring)
	}
	if m.carrier_brand != nil {
		edges = append(edges, parcelshop.EdgeCarrierBrand)
	}
	if m.address != nil {
		edges = append(edges, parcelshop.EdgeAddress)
	}
	if m.colli != nil {
		edges = append(edges, parcelshop.EdgeColli)
	}
	if m.business_hours_period != nil {
		edges = append(edges, parcelshop.EdgeBusinessHoursPeriod)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParcelShopMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case parcelshop.EdgeParcelShopDAO:
		if id := m.parcel_shop_dao; id != nil {
			return []ent.Value{*id}
		}
	case parcelshop.EdgeParcelShopPostNord:
		if id := m.parcel_shop_post_nord; id != nil {
			return []ent.Value{*id}
		}
	case parcelshop.EdgeParcelShopGLS:
		if id := m.parcel_shop_gls; id != nil {
			return []ent.Value{*id}
		}
	case parcelshop.EdgeParcelShopBring:
		if id := m.parcel_shop_bring; id != nil {
			return []ent.Value{*id}
		}
	case parcelshop.EdgeCarrierBrand:
		if id := m.carrier_brand; id != nil {
			return []ent.Value{*id}
		}
	case parcelshop.EdgeAddress:
		if id := m.address; id != nil {
			return []ent.Value{*id}
		}
	case parcelshop.EdgeColli:
		ids := make([]ent.Value, 0, len(m.colli))
		for id := range m.colli {
			ids = append(ids, id)
		}
		return ids
	case parcelshop.EdgeBusinessHoursPeriod:
		ids := make([]ent.Value, 0, len(m.business_hours_period))
		for id := range m.business_hours_period {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParcelShopMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedcolli != nil {
		edges = append(edges, parcelshop.EdgeColli)
	}
	if m.removedbusiness_hours_period != nil {
		edges = append(edges, parcelshop.EdgeBusinessHoursPeriod)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParcelShopMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case parcelshop.EdgeColli:
		ids := make([]ent.Value, 0, len(m.removedcolli))
		for id := range m.removedcolli {
			ids = append(ids, id)
		}
		return ids
	case parcelshop.EdgeBusinessHoursPeriod:
		ids := make([]ent.Value, 0, len(m.removedbusiness_hours_period))
		for id := range m.removedbusiness_hours_period {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParcelShopMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedparcel_shop_dao {
		edges = append(edges, parcelshop.EdgeParcelShopDAO)
	}
	if m.clearedparcel_shop_post_nord {
		edges = append(edges, parcelshop.EdgeParcelShopPostNord)
	}
	if m.clearedparcel_shop_gls {
		edges = append(edges, parcelshop.EdgeParcelShopGLS)
	}
	if m.clearedparcel_shop_bring {
		edges = append(edges, parcelshop.EdgeParcelShopBring)
	}
	if m.clearedcarrier_brand {
		edges = append(edges, parcelshop.EdgeCarrierBrand)
	}
	if m.clearedaddress {
		edges = append(edges, parcelshop.EdgeAddress)
	}
	if m.clearedcolli {
		edges = append(edges, parcelshop.EdgeColli)
	}
	if m.clearedbusiness_hours_period {
		edges = append(edges, parcelshop.EdgeBusinessHoursPeriod)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParcelShopMutation) EdgeCleared(name string) bool {
	switch name {
	case parcelshop.EdgeParcelShopDAO:
		return m.clearedparcel_shop_dao
	case parcelshop.EdgeParcelShopPostNord:
		return m.clearedparcel_shop_post_nord
	case parcelshop.EdgeParcelShopGLS:
		return m.clearedparcel_shop_gls
	case parcelshop.EdgeParcelShopBring:
		return m.clearedparcel_shop_bring
	case parcelshop.EdgeCarrierBrand:
		return m.clearedcarrier_brand
	case parcelshop.EdgeAddress:
		return m.clearedaddress
	case parcelshop.EdgeColli:
		return m.clearedcolli
	case parcelshop.EdgeBusinessHoursPeriod:
		return m.clearedbusiness_hours_period
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParcelShopMutation) ClearEdge(name string) error {
	switch name {
	case parcelshop.EdgeParcelShopDAO:
		m.ClearParcelShopDAO()
		return nil
	case parcelshop.EdgeParcelShopPostNord:
		m.ClearParcelShopPostNord()
		return nil
	case parcelshop.EdgeParcelShopGLS:
		m.ClearParcelShopGLS()
		return nil
	case parcelshop.EdgeParcelShopBring:
		m.ClearParcelShopBring()
		return nil
	case parcelshop.EdgeCarrierBrand:
		m.ClearCarrierBrand()
		return nil
	case parcelshop.EdgeAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown ParcelShop unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParcelShopMutation) ResetEdge(name string) error {
	switch name {
	case parcelshop.EdgeParcelShopDAO:
		m.ResetParcelShopDAO()
		return nil
	case parcelshop.EdgeParcelShopPostNord:
		m.ResetParcelShopPostNord()
		return nil
	case parcelshop.EdgeParcelShopGLS:
		m.ResetParcelShopGLS()
		return nil
	case parcelshop.EdgeParcelShopBring:
		m.ResetParcelShopBring()
		return nil
	case parcelshop.EdgeCarrierBrand:
		m.ResetCarrierBrand()
		return nil
	case parcelshop.EdgeAddress:
		m.ResetAddress()
		return nil
	case parcelshop.EdgeColli:
		m.ResetColli()
		return nil
	case parcelshop.EdgeBusinessHoursPeriod:
		m.ResetBusinessHoursPeriod()
		return nil
	}
	return fmt.Errorf("unknown ParcelShop edge %s", name)
}

// ParcelShopBringMutation represents an operation that mutates the ParcelShopBring nodes in the graph.
type ParcelShopBringMutation struct {
	config
	op                      Op
	typ                     string
	id                      *pulid.ID
	point_type              *parcelshopbring.PointType
	bring_id                *string
	clearedFields           map[string]struct{}
	parcel_shop             *pulid.ID
	clearedparcel_shop      bool
	address_delivery        *pulid.ID
	clearedaddress_delivery bool
	done                    bool
	oldValue                func(context.Context) (*ParcelShopBring, error)
	predicates              []predicate.ParcelShopBring
}

var _ ent.Mutation = (*ParcelShopBringMutation)(nil)

// parcelshopbringOption allows management of the mutation configuration using functional options.
type parcelshopbringOption func(*ParcelShopBringMutation)

// newParcelShopBringMutation creates new mutation for the ParcelShopBring entity.
func newParcelShopBringMutation(c config, op Op, opts ...parcelshopbringOption) *ParcelShopBringMutation {
	m := &ParcelShopBringMutation{
		config:        c,
		op:            op,
		typ:           TypeParcelShopBring,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParcelShopBringID sets the ID field of the mutation.
func withParcelShopBringID(id pulid.ID) parcelshopbringOption {
	return func(m *ParcelShopBringMutation) {
		var (
			err   error
			once  sync.Once
			value *ParcelShopBring
		)
		m.oldValue = func(ctx context.Context) (*ParcelShopBring, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ParcelShopBring.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParcelShopBring sets the old ParcelShopBring of the mutation.
func withParcelShopBring(node *ParcelShopBring) parcelshopbringOption {
	return func(m *ParcelShopBringMutation) {
		m.oldValue = func(context.Context) (*ParcelShopBring, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParcelShopBringMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParcelShopBringMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ParcelShopBring entities.
func (m *ParcelShopBringMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParcelShopBringMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParcelShopBringMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ParcelShopBring.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPointType sets the "point_type" field.
func (m *ParcelShopBringMutation) SetPointType(pt parcelshopbring.PointType) {
	m.point_type = &pt
}

// PointType returns the value of the "point_type" field in the mutation.
func (m *ParcelShopBringMutation) PointType() (r parcelshopbring.PointType, exists bool) {
	v := m.point_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPointType returns the old "point_type" field's value of the ParcelShopBring entity.
// If the ParcelShopBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopBringMutation) OldPointType(ctx context.Context) (v parcelshopbring.PointType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPointType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPointType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPointType: %w", err)
	}
	return oldValue.PointType, nil
}

// ResetPointType resets all changes to the "point_type" field.
func (m *ParcelShopBringMutation) ResetPointType() {
	m.point_type = nil
}

// SetBringID sets the "bring_id" field.
func (m *ParcelShopBringMutation) SetBringID(s string) {
	m.bring_id = &s
}

// BringID returns the value of the "bring_id" field in the mutation.
func (m *ParcelShopBringMutation) BringID() (r string, exists bool) {
	v := m.bring_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBringID returns the old "bring_id" field's value of the ParcelShopBring entity.
// If the ParcelShopBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopBringMutation) OldBringID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBringID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBringID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBringID: %w", err)
	}
	return oldValue.BringID, nil
}

// ResetBringID resets all changes to the "bring_id" field.
func (m *ParcelShopBringMutation) ResetBringID() {
	m.bring_id = nil
}

// SetParcelShopID sets the "parcel_shop" edge to the ParcelShop entity by id.
func (m *ParcelShopBringMutation) SetParcelShopID(id pulid.ID) {
	m.parcel_shop = &id
}

// ClearParcelShop clears the "parcel_shop" edge to the ParcelShop entity.
func (m *ParcelShopBringMutation) ClearParcelShop() {
	m.clearedparcel_shop = true
}

// ParcelShopCleared reports if the "parcel_shop" edge to the ParcelShop entity was cleared.
func (m *ParcelShopBringMutation) ParcelShopCleared() bool {
	return m.clearedparcel_shop
}

// ParcelShopID returns the "parcel_shop" edge ID in the mutation.
func (m *ParcelShopBringMutation) ParcelShopID() (id pulid.ID, exists bool) {
	if m.parcel_shop != nil {
		return *m.parcel_shop, true
	}
	return
}

// ParcelShopIDs returns the "parcel_shop" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopID instead. It exists only for internal usage by the builders.
func (m *ParcelShopBringMutation) ParcelShopIDs() (ids []pulid.ID) {
	if id := m.parcel_shop; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShop resets all changes to the "parcel_shop" edge.
func (m *ParcelShopBringMutation) ResetParcelShop() {
	m.parcel_shop = nil
	m.clearedparcel_shop = false
}

// SetAddressDeliveryID sets the "address_delivery" edge to the AddressGlobal entity by id.
func (m *ParcelShopBringMutation) SetAddressDeliveryID(id pulid.ID) {
	m.address_delivery = &id
}

// ClearAddressDelivery clears the "address_delivery" edge to the AddressGlobal entity.
func (m *ParcelShopBringMutation) ClearAddressDelivery() {
	m.clearedaddress_delivery = true
}

// AddressDeliveryCleared reports if the "address_delivery" edge to the AddressGlobal entity was cleared.
func (m *ParcelShopBringMutation) AddressDeliveryCleared() bool {
	return m.clearedaddress_delivery
}

// AddressDeliveryID returns the "address_delivery" edge ID in the mutation.
func (m *ParcelShopBringMutation) AddressDeliveryID() (id pulid.ID, exists bool) {
	if m.address_delivery != nil {
		return *m.address_delivery, true
	}
	return
}

// AddressDeliveryIDs returns the "address_delivery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressDeliveryID instead. It exists only for internal usage by the builders.
func (m *ParcelShopBringMutation) AddressDeliveryIDs() (ids []pulid.ID) {
	if id := m.address_delivery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddressDelivery resets all changes to the "address_delivery" edge.
func (m *ParcelShopBringMutation) ResetAddressDelivery() {
	m.address_delivery = nil
	m.clearedaddress_delivery = false
}

// Where appends a list predicates to the ParcelShopBringMutation builder.
func (m *ParcelShopBringMutation) Where(ps ...predicate.ParcelShopBring) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ParcelShopBringMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ParcelShopBringMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ParcelShopBring, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ParcelShopBringMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ParcelShopBringMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ParcelShopBring).
func (m *ParcelShopBringMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParcelShopBringMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.point_type != nil {
		fields = append(fields, parcelshopbring.FieldPointType)
	}
	if m.bring_id != nil {
		fields = append(fields, parcelshopbring.FieldBringID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParcelShopBringMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case parcelshopbring.FieldPointType:
		return m.PointType()
	case parcelshopbring.FieldBringID:
		return m.BringID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParcelShopBringMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case parcelshopbring.FieldPointType:
		return m.OldPointType(ctx)
	case parcelshopbring.FieldBringID:
		return m.OldBringID(ctx)
	}
	return nil, fmt.Errorf("unknown ParcelShopBring field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelShopBringMutation) SetField(name string, value ent.Value) error {
	switch name {
	case parcelshopbring.FieldPointType:
		v, ok := value.(parcelshopbring.PointType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPointType(v)
		return nil
	case parcelshopbring.FieldBringID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBringID(v)
		return nil
	}
	return fmt.Errorf("unknown ParcelShopBring field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParcelShopBringMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParcelShopBringMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelShopBringMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ParcelShopBring numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParcelShopBringMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParcelShopBringMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParcelShopBringMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ParcelShopBring nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParcelShopBringMutation) ResetField(name string) error {
	switch name {
	case parcelshopbring.FieldPointType:
		m.ResetPointType()
		return nil
	case parcelshopbring.FieldBringID:
		m.ResetBringID()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopBring field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParcelShopBringMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parcel_shop != nil {
		edges = append(edges, parcelshopbring.EdgeParcelShop)
	}
	if m.address_delivery != nil {
		edges = append(edges, parcelshopbring.EdgeAddressDelivery)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParcelShopBringMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case parcelshopbring.EdgeParcelShop:
		if id := m.parcel_shop; id != nil {
			return []ent.Value{*id}
		}
	case parcelshopbring.EdgeAddressDelivery:
		if id := m.address_delivery; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParcelShopBringMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParcelShopBringMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParcelShopBringMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparcel_shop {
		edges = append(edges, parcelshopbring.EdgeParcelShop)
	}
	if m.clearedaddress_delivery {
		edges = append(edges, parcelshopbring.EdgeAddressDelivery)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParcelShopBringMutation) EdgeCleared(name string) bool {
	switch name {
	case parcelshopbring.EdgeParcelShop:
		return m.clearedparcel_shop
	case parcelshopbring.EdgeAddressDelivery:
		return m.clearedaddress_delivery
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParcelShopBringMutation) ClearEdge(name string) error {
	switch name {
	case parcelshopbring.EdgeParcelShop:
		m.ClearParcelShop()
		return nil
	case parcelshopbring.EdgeAddressDelivery:
		m.ClearAddressDelivery()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopBring unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParcelShopBringMutation) ResetEdge(name string) error {
	switch name {
	case parcelshopbring.EdgeParcelShop:
		m.ResetParcelShop()
		return nil
	case parcelshopbring.EdgeAddressDelivery:
		m.ResetAddressDelivery()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopBring edge %s", name)
}

// ParcelShopDAOMutation represents an operation that mutates the ParcelShopDAO nodes in the graph.
type ParcelShopDAOMutation struct {
	config
	op                 Op
	typ                string
	id                 *pulid.ID
	shop_id            *string
	clearedFields      map[string]struct{}
	parcel_shop        *pulid.ID
	clearedparcel_shop bool
	done               bool
	oldValue           func(context.Context) (*ParcelShopDAO, error)
	predicates         []predicate.ParcelShopDAO
}

var _ ent.Mutation = (*ParcelShopDAOMutation)(nil)

// parcelshopdaoOption allows management of the mutation configuration using functional options.
type parcelshopdaoOption func(*ParcelShopDAOMutation)

// newParcelShopDAOMutation creates new mutation for the ParcelShopDAO entity.
func newParcelShopDAOMutation(c config, op Op, opts ...parcelshopdaoOption) *ParcelShopDAOMutation {
	m := &ParcelShopDAOMutation{
		config:        c,
		op:            op,
		typ:           TypeParcelShopDAO,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParcelShopDAOID sets the ID field of the mutation.
func withParcelShopDAOID(id pulid.ID) parcelshopdaoOption {
	return func(m *ParcelShopDAOMutation) {
		var (
			err   error
			once  sync.Once
			value *ParcelShopDAO
		)
		m.oldValue = func(ctx context.Context) (*ParcelShopDAO, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ParcelShopDAO.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParcelShopDAO sets the old ParcelShopDAO of the mutation.
func withParcelShopDAO(node *ParcelShopDAO) parcelshopdaoOption {
	return func(m *ParcelShopDAOMutation) {
		m.oldValue = func(context.Context) (*ParcelShopDAO, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParcelShopDAOMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParcelShopDAOMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ParcelShopDAO entities.
func (m *ParcelShopDAOMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParcelShopDAOMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParcelShopDAOMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ParcelShopDAO.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetShopID sets the "shop_id" field.
func (m *ParcelShopDAOMutation) SetShopID(s string) {
	m.shop_id = &s
}

// ShopID returns the value of the "shop_id" field in the mutation.
func (m *ParcelShopDAOMutation) ShopID() (r string, exists bool) {
	v := m.shop_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShopID returns the old "shop_id" field's value of the ParcelShopDAO entity.
// If the ParcelShopDAO object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopDAOMutation) OldShopID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShopID: %w", err)
	}
	return oldValue.ShopID, nil
}

// ResetShopID resets all changes to the "shop_id" field.
func (m *ParcelShopDAOMutation) ResetShopID() {
	m.shop_id = nil
}

// SetParcelShopID sets the "parcel_shop" edge to the ParcelShop entity by id.
func (m *ParcelShopDAOMutation) SetParcelShopID(id pulid.ID) {
	m.parcel_shop = &id
}

// ClearParcelShop clears the "parcel_shop" edge to the ParcelShop entity.
func (m *ParcelShopDAOMutation) ClearParcelShop() {
	m.clearedparcel_shop = true
}

// ParcelShopCleared reports if the "parcel_shop" edge to the ParcelShop entity was cleared.
func (m *ParcelShopDAOMutation) ParcelShopCleared() bool {
	return m.clearedparcel_shop
}

// ParcelShopID returns the "parcel_shop" edge ID in the mutation.
func (m *ParcelShopDAOMutation) ParcelShopID() (id pulid.ID, exists bool) {
	if m.parcel_shop != nil {
		return *m.parcel_shop, true
	}
	return
}

// ParcelShopIDs returns the "parcel_shop" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopID instead. It exists only for internal usage by the builders.
func (m *ParcelShopDAOMutation) ParcelShopIDs() (ids []pulid.ID) {
	if id := m.parcel_shop; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShop resets all changes to the "parcel_shop" edge.
func (m *ParcelShopDAOMutation) ResetParcelShop() {
	m.parcel_shop = nil
	m.clearedparcel_shop = false
}

// Where appends a list predicates to the ParcelShopDAOMutation builder.
func (m *ParcelShopDAOMutation) Where(ps ...predicate.ParcelShopDAO) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ParcelShopDAOMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ParcelShopDAOMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ParcelShopDAO, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ParcelShopDAOMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ParcelShopDAOMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ParcelShopDAO).
func (m *ParcelShopDAOMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParcelShopDAOMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.shop_id != nil {
		fields = append(fields, parcelshopdao.FieldShopID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParcelShopDAOMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case parcelshopdao.FieldShopID:
		return m.ShopID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParcelShopDAOMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case parcelshopdao.FieldShopID:
		return m.OldShopID(ctx)
	}
	return nil, fmt.Errorf("unknown ParcelShopDAO field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelShopDAOMutation) SetField(name string, value ent.Value) error {
	switch name {
	case parcelshopdao.FieldShopID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShopID(v)
		return nil
	}
	return fmt.Errorf("unknown ParcelShopDAO field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParcelShopDAOMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParcelShopDAOMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelShopDAOMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ParcelShopDAO numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParcelShopDAOMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParcelShopDAOMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParcelShopDAOMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ParcelShopDAO nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParcelShopDAOMutation) ResetField(name string) error {
	switch name {
	case parcelshopdao.FieldShopID:
		m.ResetShopID()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopDAO field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParcelShopDAOMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parcel_shop != nil {
		edges = append(edges, parcelshopdao.EdgeParcelShop)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParcelShopDAOMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case parcelshopdao.EdgeParcelShop:
		if id := m.parcel_shop; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParcelShopDAOMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParcelShopDAOMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParcelShopDAOMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparcel_shop {
		edges = append(edges, parcelshopdao.EdgeParcelShop)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParcelShopDAOMutation) EdgeCleared(name string) bool {
	switch name {
	case parcelshopdao.EdgeParcelShop:
		return m.clearedparcel_shop
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParcelShopDAOMutation) ClearEdge(name string) error {
	switch name {
	case parcelshopdao.EdgeParcelShop:
		m.ClearParcelShop()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopDAO unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParcelShopDAOMutation) ResetEdge(name string) error {
	switch name {
	case parcelshopdao.EdgeParcelShop:
		m.ResetParcelShop()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopDAO edge %s", name)
}

// ParcelShopGLSMutation represents an operation that mutates the ParcelShopGLS nodes in the graph.
type ParcelShopGLSMutation struct {
	config
	op                 Op
	typ                string
	id                 *pulid.ID
	gls_parcel_shop_id *string
	partner_id         *string
	_type              *string
	clearedFields      map[string]struct{}
	parcel_shop        *pulid.ID
	clearedparcel_shop bool
	done               bool
	oldValue           func(context.Context) (*ParcelShopGLS, error)
	predicates         []predicate.ParcelShopGLS
}

var _ ent.Mutation = (*ParcelShopGLSMutation)(nil)

// parcelshopglsOption allows management of the mutation configuration using functional options.
type parcelshopglsOption func(*ParcelShopGLSMutation)

// newParcelShopGLSMutation creates new mutation for the ParcelShopGLS entity.
func newParcelShopGLSMutation(c config, op Op, opts ...parcelshopglsOption) *ParcelShopGLSMutation {
	m := &ParcelShopGLSMutation{
		config:        c,
		op:            op,
		typ:           TypeParcelShopGLS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParcelShopGLSID sets the ID field of the mutation.
func withParcelShopGLSID(id pulid.ID) parcelshopglsOption {
	return func(m *ParcelShopGLSMutation) {
		var (
			err   error
			once  sync.Once
			value *ParcelShopGLS
		)
		m.oldValue = func(ctx context.Context) (*ParcelShopGLS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ParcelShopGLS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParcelShopGLS sets the old ParcelShopGLS of the mutation.
func withParcelShopGLS(node *ParcelShopGLS) parcelshopglsOption {
	return func(m *ParcelShopGLSMutation) {
		m.oldValue = func(context.Context) (*ParcelShopGLS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParcelShopGLSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParcelShopGLSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ParcelShopGLS entities.
func (m *ParcelShopGLSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParcelShopGLSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParcelShopGLSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ParcelShopGLS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetGLSParcelShopID sets the "gls_parcel_shop_id" field.
func (m *ParcelShopGLSMutation) SetGLSParcelShopID(s string) {
	m.gls_parcel_shop_id = &s
}

// GLSParcelShopID returns the value of the "gls_parcel_shop_id" field in the mutation.
func (m *ParcelShopGLSMutation) GLSParcelShopID() (r string, exists bool) {
	v := m.gls_parcel_shop_id
	if v == nil {
		return
	}
	return *v, true
}

// OldGLSParcelShopID returns the old "gls_parcel_shop_id" field's value of the ParcelShopGLS entity.
// If the ParcelShopGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopGLSMutation) OldGLSParcelShopID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGLSParcelShopID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGLSParcelShopID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGLSParcelShopID: %w", err)
	}
	return oldValue.GLSParcelShopID, nil
}

// ResetGLSParcelShopID resets all changes to the "gls_parcel_shop_id" field.
func (m *ParcelShopGLSMutation) ResetGLSParcelShopID() {
	m.gls_parcel_shop_id = nil
}

// SetPartnerID sets the "partner_id" field.
func (m *ParcelShopGLSMutation) SetPartnerID(s string) {
	m.partner_id = &s
}

// PartnerID returns the value of the "partner_id" field in the mutation.
func (m *ParcelShopGLSMutation) PartnerID() (r string, exists bool) {
	v := m.partner_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPartnerID returns the old "partner_id" field's value of the ParcelShopGLS entity.
// If the ParcelShopGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopGLSMutation) OldPartnerID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPartnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPartnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPartnerID: %w", err)
	}
	return oldValue.PartnerID, nil
}

// ClearPartnerID clears the value of the "partner_id" field.
func (m *ParcelShopGLSMutation) ClearPartnerID() {
	m.partner_id = nil
	m.clearedFields[parcelshopgls.FieldPartnerID] = struct{}{}
}

// PartnerIDCleared returns if the "partner_id" field was cleared in this mutation.
func (m *ParcelShopGLSMutation) PartnerIDCleared() bool {
	_, ok := m.clearedFields[parcelshopgls.FieldPartnerID]
	return ok
}

// ResetPartnerID resets all changes to the "partner_id" field.
func (m *ParcelShopGLSMutation) ResetPartnerID() {
	m.partner_id = nil
	delete(m.clearedFields, parcelshopgls.FieldPartnerID)
}

// SetType sets the "type" field.
func (m *ParcelShopGLSMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ParcelShopGLSMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ParcelShopGLS entity.
// If the ParcelShopGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopGLSMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *ParcelShopGLSMutation) ClearType() {
	m._type = nil
	m.clearedFields[parcelshopgls.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *ParcelShopGLSMutation) TypeCleared() bool {
	_, ok := m.clearedFields[parcelshopgls.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *ParcelShopGLSMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, parcelshopgls.FieldType)
}

// SetParcelShopID sets the "parcel_shop" edge to the ParcelShop entity by id.
func (m *ParcelShopGLSMutation) SetParcelShopID(id pulid.ID) {
	m.parcel_shop = &id
}

// ClearParcelShop clears the "parcel_shop" edge to the ParcelShop entity.
func (m *ParcelShopGLSMutation) ClearParcelShop() {
	m.clearedparcel_shop = true
}

// ParcelShopCleared reports if the "parcel_shop" edge to the ParcelShop entity was cleared.
func (m *ParcelShopGLSMutation) ParcelShopCleared() bool {
	return m.clearedparcel_shop
}

// ParcelShopID returns the "parcel_shop" edge ID in the mutation.
func (m *ParcelShopGLSMutation) ParcelShopID() (id pulid.ID, exists bool) {
	if m.parcel_shop != nil {
		return *m.parcel_shop, true
	}
	return
}

// ParcelShopIDs returns the "parcel_shop" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopID instead. It exists only for internal usage by the builders.
func (m *ParcelShopGLSMutation) ParcelShopIDs() (ids []pulid.ID) {
	if id := m.parcel_shop; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShop resets all changes to the "parcel_shop" edge.
func (m *ParcelShopGLSMutation) ResetParcelShop() {
	m.parcel_shop = nil
	m.clearedparcel_shop = false
}

// Where appends a list predicates to the ParcelShopGLSMutation builder.
func (m *ParcelShopGLSMutation) Where(ps ...predicate.ParcelShopGLS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ParcelShopGLSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ParcelShopGLSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ParcelShopGLS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ParcelShopGLSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ParcelShopGLSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ParcelShopGLS).
func (m *ParcelShopGLSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParcelShopGLSMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.gls_parcel_shop_id != nil {
		fields = append(fields, parcelshopgls.FieldGLSParcelShopID)
	}
	if m.partner_id != nil {
		fields = append(fields, parcelshopgls.FieldPartnerID)
	}
	if m._type != nil {
		fields = append(fields, parcelshopgls.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParcelShopGLSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case parcelshopgls.FieldGLSParcelShopID:
		return m.GLSParcelShopID()
	case parcelshopgls.FieldPartnerID:
		return m.PartnerID()
	case parcelshopgls.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParcelShopGLSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case parcelshopgls.FieldGLSParcelShopID:
		return m.OldGLSParcelShopID(ctx)
	case parcelshopgls.FieldPartnerID:
		return m.OldPartnerID(ctx)
	case parcelshopgls.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ParcelShopGLS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelShopGLSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case parcelshopgls.FieldGLSParcelShopID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGLSParcelShopID(v)
		return nil
	case parcelshopgls.FieldPartnerID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPartnerID(v)
		return nil
	case parcelshopgls.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ParcelShopGLS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParcelShopGLSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParcelShopGLSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelShopGLSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ParcelShopGLS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParcelShopGLSMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(parcelshopgls.FieldPartnerID) {
		fields = append(fields, parcelshopgls.FieldPartnerID)
	}
	if m.FieldCleared(parcelshopgls.FieldType) {
		fields = append(fields, parcelshopgls.FieldType)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParcelShopGLSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParcelShopGLSMutation) ClearField(name string) error {
	switch name {
	case parcelshopgls.FieldPartnerID:
		m.ClearPartnerID()
		return nil
	case parcelshopgls.FieldType:
		m.ClearType()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopGLS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParcelShopGLSMutation) ResetField(name string) error {
	switch name {
	case parcelshopgls.FieldGLSParcelShopID:
		m.ResetGLSParcelShopID()
		return nil
	case parcelshopgls.FieldPartnerID:
		m.ResetPartnerID()
		return nil
	case parcelshopgls.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopGLS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParcelShopGLSMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.parcel_shop != nil {
		edges = append(edges, parcelshopgls.EdgeParcelShop)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParcelShopGLSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case parcelshopgls.EdgeParcelShop:
		if id := m.parcel_shop; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParcelShopGLSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParcelShopGLSMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParcelShopGLSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedparcel_shop {
		edges = append(edges, parcelshopgls.EdgeParcelShop)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParcelShopGLSMutation) EdgeCleared(name string) bool {
	switch name {
	case parcelshopgls.EdgeParcelShop:
		return m.clearedparcel_shop
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParcelShopGLSMutation) ClearEdge(name string) error {
	switch name {
	case parcelshopgls.EdgeParcelShop:
		m.ClearParcelShop()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopGLS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParcelShopGLSMutation) ResetEdge(name string) error {
	switch name {
	case parcelshopgls.EdgeParcelShop:
		m.ResetParcelShop()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopGLS edge %s", name)
}

// ParcelShopPostNordMutation represents an operation that mutates the ParcelShopPostNord nodes in the graph.
type ParcelShopPostNordMutation struct {
	config
	op                      Op
	typ                     string
	id                      *pulid.ID
	service_point_id        *string
	pudoid                  *string
	type_id                 *string
	clearedFields           map[string]struct{}
	parcel_shop             *pulid.ID
	clearedparcel_shop      bool
	address_delivery        *pulid.ID
	clearedaddress_delivery bool
	done                    bool
	oldValue                func(context.Context) (*ParcelShopPostNord, error)
	predicates              []predicate.ParcelShopPostNord
}

var _ ent.Mutation = (*ParcelShopPostNordMutation)(nil)

// parcelshoppostnordOption allows management of the mutation configuration using functional options.
type parcelshoppostnordOption func(*ParcelShopPostNordMutation)

// newParcelShopPostNordMutation creates new mutation for the ParcelShopPostNord entity.
func newParcelShopPostNordMutation(c config, op Op, opts ...parcelshoppostnordOption) *ParcelShopPostNordMutation {
	m := &ParcelShopPostNordMutation{
		config:        c,
		op:            op,
		typ:           TypeParcelShopPostNord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withParcelShopPostNordID sets the ID field of the mutation.
func withParcelShopPostNordID(id pulid.ID) parcelshoppostnordOption {
	return func(m *ParcelShopPostNordMutation) {
		var (
			err   error
			once  sync.Once
			value *ParcelShopPostNord
		)
		m.oldValue = func(ctx context.Context) (*ParcelShopPostNord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ParcelShopPostNord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withParcelShopPostNord sets the old ParcelShopPostNord of the mutation.
func withParcelShopPostNord(node *ParcelShopPostNord) parcelshoppostnordOption {
	return func(m *ParcelShopPostNordMutation) {
		m.oldValue = func(context.Context) (*ParcelShopPostNord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ParcelShopPostNordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ParcelShopPostNordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ParcelShopPostNord entities.
func (m *ParcelShopPostNordMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ParcelShopPostNordMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ParcelShopPostNordMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ParcelShopPostNord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetServicePointID sets the "service_point_id" field.
func (m *ParcelShopPostNordMutation) SetServicePointID(s string) {
	m.service_point_id = &s
}

// ServicePointID returns the value of the "service_point_id" field in the mutation.
func (m *ParcelShopPostNordMutation) ServicePointID() (r string, exists bool) {
	v := m.service_point_id
	if v == nil {
		return
	}
	return *v, true
}

// OldServicePointID returns the old "service_point_id" field's value of the ParcelShopPostNord entity.
// If the ParcelShopPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopPostNordMutation) OldServicePointID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldServicePointID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldServicePointID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldServicePointID: %w", err)
	}
	return oldValue.ServicePointID, nil
}

// ResetServicePointID resets all changes to the "service_point_id" field.
func (m *ParcelShopPostNordMutation) ResetServicePointID() {
	m.service_point_id = nil
}

// SetPudoid sets the "pudoid" field.
func (m *ParcelShopPostNordMutation) SetPudoid(s string) {
	m.pudoid = &s
}

// Pudoid returns the value of the "pudoid" field in the mutation.
func (m *ParcelShopPostNordMutation) Pudoid() (r string, exists bool) {
	v := m.pudoid
	if v == nil {
		return
	}
	return *v, true
}

// OldPudoid returns the old "pudoid" field's value of the ParcelShopPostNord entity.
// If the ParcelShopPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopPostNordMutation) OldPudoid(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPudoid is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPudoid requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPudoid: %w", err)
	}
	return oldValue.Pudoid, nil
}

// ResetPudoid resets all changes to the "pudoid" field.
func (m *ParcelShopPostNordMutation) ResetPudoid() {
	m.pudoid = nil
}

// SetTypeID sets the "type_id" field.
func (m *ParcelShopPostNordMutation) SetTypeID(s string) {
	m.type_id = &s
}

// TypeID returns the value of the "type_id" field in the mutation.
func (m *ParcelShopPostNordMutation) TypeID() (r string, exists bool) {
	v := m.type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldTypeID returns the old "type_id" field's value of the ParcelShopPostNord entity.
// If the ParcelShopPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ParcelShopPostNordMutation) OldTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTypeID: %w", err)
	}
	return oldValue.TypeID, nil
}

// ResetTypeID resets all changes to the "type_id" field.
func (m *ParcelShopPostNordMutation) ResetTypeID() {
	m.type_id = nil
}

// SetParcelShopID sets the "parcel_shop" edge to the ParcelShop entity by id.
func (m *ParcelShopPostNordMutation) SetParcelShopID(id pulid.ID) {
	m.parcel_shop = &id
}

// ClearParcelShop clears the "parcel_shop" edge to the ParcelShop entity.
func (m *ParcelShopPostNordMutation) ClearParcelShop() {
	m.clearedparcel_shop = true
}

// ParcelShopCleared reports if the "parcel_shop" edge to the ParcelShop entity was cleared.
func (m *ParcelShopPostNordMutation) ParcelShopCleared() bool {
	return m.clearedparcel_shop
}

// ParcelShopID returns the "parcel_shop" edge ID in the mutation.
func (m *ParcelShopPostNordMutation) ParcelShopID() (id pulid.ID, exists bool) {
	if m.parcel_shop != nil {
		return *m.parcel_shop, true
	}
	return
}

// ParcelShopIDs returns the "parcel_shop" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParcelShopID instead. It exists only for internal usage by the builders.
func (m *ParcelShopPostNordMutation) ParcelShopIDs() (ids []pulid.ID) {
	if id := m.parcel_shop; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParcelShop resets all changes to the "parcel_shop" edge.
func (m *ParcelShopPostNordMutation) ResetParcelShop() {
	m.parcel_shop = nil
	m.clearedparcel_shop = false
}

// SetAddressDeliveryID sets the "address_delivery" edge to the AddressGlobal entity by id.
func (m *ParcelShopPostNordMutation) SetAddressDeliveryID(id pulid.ID) {
	m.address_delivery = &id
}

// ClearAddressDelivery clears the "address_delivery" edge to the AddressGlobal entity.
func (m *ParcelShopPostNordMutation) ClearAddressDelivery() {
	m.clearedaddress_delivery = true
}

// AddressDeliveryCleared reports if the "address_delivery" edge to the AddressGlobal entity was cleared.
func (m *ParcelShopPostNordMutation) AddressDeliveryCleared() bool {
	return m.clearedaddress_delivery
}

// AddressDeliveryID returns the "address_delivery" edge ID in the mutation.
func (m *ParcelShopPostNordMutation) AddressDeliveryID() (id pulid.ID, exists bool) {
	if m.address_delivery != nil {
		return *m.address_delivery, true
	}
	return
}

// AddressDeliveryIDs returns the "address_delivery" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AddressDeliveryID instead. It exists only for internal usage by the builders.
func (m *ParcelShopPostNordMutation) AddressDeliveryIDs() (ids []pulid.ID) {
	if id := m.address_delivery; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAddressDelivery resets all changes to the "address_delivery" edge.
func (m *ParcelShopPostNordMutation) ResetAddressDelivery() {
	m.address_delivery = nil
	m.clearedaddress_delivery = false
}

// Where appends a list predicates to the ParcelShopPostNordMutation builder.
func (m *ParcelShopPostNordMutation) Where(ps ...predicate.ParcelShopPostNord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ParcelShopPostNordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ParcelShopPostNordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ParcelShopPostNord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ParcelShopPostNordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ParcelShopPostNordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ParcelShopPostNord).
func (m *ParcelShopPostNordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ParcelShopPostNordMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.service_point_id != nil {
		fields = append(fields, parcelshoppostnord.FieldServicePointID)
	}
	if m.pudoid != nil {
		fields = append(fields, parcelshoppostnord.FieldPudoid)
	}
	if m.type_id != nil {
		fields = append(fields, parcelshoppostnord.FieldTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ParcelShopPostNordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case parcelshoppostnord.FieldServicePointID:
		return m.ServicePointID()
	case parcelshoppostnord.FieldPudoid:
		return m.Pudoid()
	case parcelshoppostnord.FieldTypeID:
		return m.TypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ParcelShopPostNordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case parcelshoppostnord.FieldServicePointID:
		return m.OldServicePointID(ctx)
	case parcelshoppostnord.FieldPudoid:
		return m.OldPudoid(ctx)
	case parcelshoppostnord.FieldTypeID:
		return m.OldTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown ParcelShopPostNord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelShopPostNordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case parcelshoppostnord.FieldServicePointID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetServicePointID(v)
		return nil
	case parcelshoppostnord.FieldPudoid:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPudoid(v)
		return nil
	case parcelshoppostnord.FieldTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown ParcelShopPostNord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ParcelShopPostNordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ParcelShopPostNordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ParcelShopPostNordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ParcelShopPostNord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ParcelShopPostNordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ParcelShopPostNordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ParcelShopPostNordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ParcelShopPostNord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ParcelShopPostNordMutation) ResetField(name string) error {
	switch name {
	case parcelshoppostnord.FieldServicePointID:
		m.ResetServicePointID()
		return nil
	case parcelshoppostnord.FieldPudoid:
		m.ResetPudoid()
		return nil
	case parcelshoppostnord.FieldTypeID:
		m.ResetTypeID()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopPostNord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ParcelShopPostNordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.parcel_shop != nil {
		edges = append(edges, parcelshoppostnord.EdgeParcelShop)
	}
	if m.address_delivery != nil {
		edges = append(edges, parcelshoppostnord.EdgeAddressDelivery)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ParcelShopPostNordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case parcelshoppostnord.EdgeParcelShop:
		if id := m.parcel_shop; id != nil {
			return []ent.Value{*id}
		}
	case parcelshoppostnord.EdgeAddressDelivery:
		if id := m.address_delivery; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ParcelShopPostNordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ParcelShopPostNordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ParcelShopPostNordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedparcel_shop {
		edges = append(edges, parcelshoppostnord.EdgeParcelShop)
	}
	if m.clearedaddress_delivery {
		edges = append(edges, parcelshoppostnord.EdgeAddressDelivery)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ParcelShopPostNordMutation) EdgeCleared(name string) bool {
	switch name {
	case parcelshoppostnord.EdgeParcelShop:
		return m.clearedparcel_shop
	case parcelshoppostnord.EdgeAddressDelivery:
		return m.clearedaddress_delivery
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ParcelShopPostNordMutation) ClearEdge(name string) error {
	switch name {
	case parcelshoppostnord.EdgeParcelShop:
		m.ClearParcelShop()
		return nil
	case parcelshoppostnord.EdgeAddressDelivery:
		m.ClearAddressDelivery()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopPostNord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ParcelShopPostNordMutation) ResetEdge(name string) error {
	switch name {
	case parcelshoppostnord.EdgeParcelShop:
		m.ResetParcelShop()
		return nil
	case parcelshoppostnord.EdgeAddressDelivery:
		m.ResetAddressDelivery()
		return nil
	}
	return fmt.Errorf("unknown ParcelShopPostNord edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op                       Op
	typ                      string
	id                       *pulid.ID
	label                    *string
	rank                     *int
	addrank                  *int
	price_dkk                *int
	addprice_dkk             *int
	created_at               *time.Time
	clearedFields            map[string]struct{}
	tenant                   map[pulid.ID]struct{}
	removedtenant            map[pulid.ID]struct{}
	clearedtenant            bool
	plan_history_plan        map[pulid.ID]struct{}
	removedplan_history_plan map[pulid.ID]struct{}
	clearedplan_history_plan bool
	done                     bool
	oldValue                 func(context.Context) (*Plan, error)
	predicates               []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id pulid.ID) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plan entities.
func (m *PlanMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetLabel sets the "label" field.
func (m *PlanMutation) SetLabel(s string) {
	m.label = &s
}

// Label returns the value of the "label" field in the mutation.
func (m *PlanMutation) Label() (r string, exists bool) {
	v := m.label
	if v == nil {
		return
	}
	return *v, true
}

// OldLabel returns the old "label" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldLabel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabel: %w", err)
	}
	return oldValue.Label, nil
}

// ResetLabel resets all changes to the "label" field.
func (m *PlanMutation) ResetLabel() {
	m.label = nil
}

// SetRank sets the "rank" field.
func (m *PlanMutation) SetRank(i int) {
	m.rank = &i
	m.addrank = nil
}

// Rank returns the value of the "rank" field in the mutation.
func (m *PlanMutation) Rank() (r int, exists bool) {
	v := m.rank
	if v == nil {
		return
	}
	return *v, true
}

// OldRank returns the old "rank" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldRank(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRank is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRank requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRank: %w", err)
	}
	return oldValue.Rank, nil
}

// AddRank adds i to the "rank" field.
func (m *PlanMutation) AddRank(i int) {
	if m.addrank != nil {
		*m.addrank += i
	} else {
		m.addrank = &i
	}
}

// AddedRank returns the value that was added to the "rank" field in this mutation.
func (m *PlanMutation) AddedRank() (r int, exists bool) {
	v := m.addrank
	if v == nil {
		return
	}
	return *v, true
}

// ResetRank resets all changes to the "rank" field.
func (m *PlanMutation) ResetRank() {
	m.rank = nil
	m.addrank = nil
}

// SetPriceDkk sets the "price_dkk" field.
func (m *PlanMutation) SetPriceDkk(i int) {
	m.price_dkk = &i
	m.addprice_dkk = nil
}

// PriceDkk returns the value of the "price_dkk" field in the mutation.
func (m *PlanMutation) PriceDkk() (r int, exists bool) {
	v := m.price_dkk
	if v == nil {
		return
	}
	return *v, true
}

// OldPriceDkk returns the old "price_dkk" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldPriceDkk(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriceDkk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriceDkk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriceDkk: %w", err)
	}
	return oldValue.PriceDkk, nil
}

// AddPriceDkk adds i to the "price_dkk" field.
func (m *PlanMutation) AddPriceDkk(i int) {
	if m.addprice_dkk != nil {
		*m.addprice_dkk += i
	} else {
		m.addprice_dkk = &i
	}
}

// AddedPriceDkk returns the value that was added to the "price_dkk" field in this mutation.
func (m *PlanMutation) AddedPriceDkk() (r int, exists bool) {
	v := m.addprice_dkk
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriceDkk resets all changes to the "price_dkk" field.
func (m *PlanMutation) ResetPriceDkk() {
	m.price_dkk = nil
	m.addprice_dkk = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// AddTenantIDs adds the "tenant" edge to the Tenant entity by ids.
func (m *PlanMutation) AddTenantIDs(ids ...pulid.ID) {
	if m.tenant == nil {
		m.tenant = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.tenant[ids[i]] = struct{}{}
	}
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PlanMutation) ClearTenant() {
	m.clearedtenant = true
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PlanMutation) TenantCleared() bool {
	return m.clearedtenant
}

// RemoveTenantIDs removes the "tenant" edge to the Tenant entity by IDs.
func (m *PlanMutation) RemoveTenantIDs(ids ...pulid.ID) {
	if m.removedtenant == nil {
		m.removedtenant = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.tenant, ids[i])
		m.removedtenant[ids[i]] = struct{}{}
	}
}

// RemovedTenant returns the removed IDs of the "tenant" edge to the Tenant entity.
func (m *PlanMutation) RemovedTenantIDs() (ids []pulid.ID) {
	for id := range m.removedtenant {
		ids = append(ids, id)
	}
	return
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
func (m *PlanMutation) TenantIDs() (ids []pulid.ID) {
	for id := range m.tenant {
		ids = append(ids, id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PlanMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
	m.removedtenant = nil
}

// AddPlanHistoryPlanIDs adds the "plan_history_plan" edge to the PlanHistory entity by ids.
func (m *PlanMutation) AddPlanHistoryPlanIDs(ids ...pulid.ID) {
	if m.plan_history_plan == nil {
		m.plan_history_plan = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.plan_history_plan[ids[i]] = struct{}{}
	}
}

// ClearPlanHistoryPlan clears the "plan_history_plan" edge to the PlanHistory entity.
func (m *PlanMutation) ClearPlanHistoryPlan() {
	m.clearedplan_history_plan = true
}

// PlanHistoryPlanCleared reports if the "plan_history_plan" edge to the PlanHistory entity was cleared.
func (m *PlanMutation) PlanHistoryPlanCleared() bool {
	return m.clearedplan_history_plan
}

// RemovePlanHistoryPlanIDs removes the "plan_history_plan" edge to the PlanHistory entity by IDs.
func (m *PlanMutation) RemovePlanHistoryPlanIDs(ids ...pulid.ID) {
	if m.removedplan_history_plan == nil {
		m.removedplan_history_plan = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.plan_history_plan, ids[i])
		m.removedplan_history_plan[ids[i]] = struct{}{}
	}
}

// RemovedPlanHistoryPlan returns the removed IDs of the "plan_history_plan" edge to the PlanHistory entity.
func (m *PlanMutation) RemovedPlanHistoryPlanIDs() (ids []pulid.ID) {
	for id := range m.removedplan_history_plan {
		ids = append(ids, id)
	}
	return
}

// PlanHistoryPlanIDs returns the "plan_history_plan" edge IDs in the mutation.
func (m *PlanMutation) PlanHistoryPlanIDs() (ids []pulid.ID) {
	for id := range m.plan_history_plan {
		ids = append(ids, id)
	}
	return
}

// ResetPlanHistoryPlan resets all changes to the "plan_history_plan" edge.
func (m *PlanMutation) ResetPlanHistoryPlan() {
	m.plan_history_plan = nil
	m.clearedplan_history_plan = false
	m.removedplan_history_plan = nil
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.label != nil {
		fields = append(fields, plan.FieldLabel)
	}
	if m.rank != nil {
		fields = append(fields, plan.FieldRank)
	}
	if m.price_dkk != nil {
		fields = append(fields, plan.FieldPriceDkk)
	}
	if m.created_at != nil {
		fields = append(fields, plan.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldLabel:
		return m.Label()
	case plan.FieldRank:
		return m.Rank()
	case plan.FieldPriceDkk:
		return m.PriceDkk()
	case plan.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldLabel:
		return m.OldLabel(ctx)
	case plan.FieldRank:
		return m.OldRank(ctx)
	case plan.FieldPriceDkk:
		return m.OldPriceDkk(ctx)
	case plan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldLabel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabel(v)
		return nil
	case plan.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRank(v)
		return nil
	case plan.FieldPriceDkk:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriceDkk(v)
		return nil
	case plan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	var fields []string
	if m.addrank != nil {
		fields = append(fields, plan.FieldRank)
	}
	if m.addprice_dkk != nil {
		fields = append(fields, plan.FieldPriceDkk)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldRank:
		return m.AddedRank()
	case plan.FieldPriceDkk:
		return m.AddedPriceDkk()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	case plan.FieldRank:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRank(v)
		return nil
	case plan.FieldPriceDkk:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriceDkk(v)
		return nil
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldLabel:
		m.ResetLabel()
		return nil
	case plan.FieldRank:
		m.ResetRank()
		return nil
	case plan.FieldPriceDkk:
		m.ResetPriceDkk()
		return nil
	case plan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, plan.EdgeTenant)
	}
	if m.plan_history_plan != nil {
		edges = append(edges, plan.EdgePlanHistoryPlan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgeTenant:
		ids := make([]ent.Value, 0, len(m.tenant))
		for id := range m.tenant {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgePlanHistoryPlan:
		ids := make([]ent.Value, 0, len(m.plan_history_plan))
		for id := range m.plan_history_plan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedtenant != nil {
		edges = append(edges, plan.EdgeTenant)
	}
	if m.removedplan_history_plan != nil {
		edges = append(edges, plan.EdgePlanHistoryPlan)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case plan.EdgeTenant:
		ids := make([]ent.Value, 0, len(m.removedtenant))
		for id := range m.removedtenant {
			ids = append(ids, id)
		}
		return ids
	case plan.EdgePlanHistoryPlan:
		ids := make([]ent.Value, 0, len(m.removedplan_history_plan))
		for id := range m.removedplan_history_plan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, plan.EdgeTenant)
	}
	if m.clearedplan_history_plan {
		edges = append(edges, plan.EdgePlanHistoryPlan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	switch name {
	case plan.EdgeTenant:
		return m.clearedtenant
	case plan.EdgePlanHistoryPlan:
		return m.clearedplan_history_plan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	switch name {
	case plan.EdgeTenant:
		m.ResetTenant()
		return nil
	case plan.EdgePlanHistoryPlan:
		m.ResetPlanHistoryPlan()
		return nil
	}
	return fmt.Errorf("unknown Plan edge %s", name)
}

// PlanHistoryMutation represents an operation that mutates the PlanHistory nodes in the graph.
type PlanHistoryMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.ID
	created_at            *time.Time
	clearedFields         map[string]struct{}
	change_history        *pulid.ID
	clearedchange_history bool
	tenant                *pulid.ID
	clearedtenant         bool
	changed_by            *pulid.ID
	clearedchanged_by     bool
	changed_from          *pulid.ID
	clearedchanged_from   bool
	done                  bool
	oldValue              func(context.Context) (*PlanHistory, error)
	predicates            []predicate.PlanHistory
}

var _ ent.Mutation = (*PlanHistoryMutation)(nil)

// planhistoryOption allows management of the mutation configuration using functional options.
type planhistoryOption func(*PlanHistoryMutation)

// newPlanHistoryMutation creates new mutation for the PlanHistory entity.
func newPlanHistoryMutation(c config, op Op, opts ...planhistoryOption) *PlanHistoryMutation {
	m := &PlanHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypePlanHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanHistoryID sets the ID field of the mutation.
func withPlanHistoryID(id pulid.ID) planhistoryOption {
	return func(m *PlanHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PlanHistory
		)
		m.oldValue = func(ctx context.Context) (*PlanHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PlanHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlanHistory sets the old PlanHistory of the mutation.
func withPlanHistory(node *PlanHistory) planhistoryOption {
	return func(m *PlanHistoryMutation) {
		m.oldValue = func(context.Context) (*PlanHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PlanHistory entities.
func (m *PlanHistoryMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanHistoryMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanHistoryMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PlanHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PlanHistoryMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PlanHistoryMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PlanHistory entity.
// If the PlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanHistoryMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PlanHistoryMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanHistoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanHistoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PlanHistory entity.
// If the PlanHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanHistoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanHistoryMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetChangeHistoryID sets the "change_history" edge to the ChangeHistory entity by id.
func (m *PlanHistoryMutation) SetChangeHistoryID(id pulid.ID) {
	m.change_history = &id
}

// ClearChangeHistory clears the "change_history" edge to the ChangeHistory entity.
func (m *PlanHistoryMutation) ClearChangeHistory() {
	m.clearedchange_history = true
}

// ChangeHistoryCleared reports if the "change_history" edge to the ChangeHistory entity was cleared.
func (m *PlanHistoryMutation) ChangeHistoryCleared() bool {
	return m.clearedchange_history
}

// ChangeHistoryID returns the "change_history" edge ID in the mutation.
func (m *PlanHistoryMutation) ChangeHistoryID() (id pulid.ID, exists bool) {
	if m.change_history != nil {
		return *m.change_history, true
	}
	return
}

// ChangeHistoryIDs returns the "change_history" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChangeHistoryID instead. It exists only for internal usage by the builders.
func (m *PlanHistoryMutation) ChangeHistoryIDs() (ids []pulid.ID) {
	if id := m.change_history; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChangeHistory resets all changes to the "change_history" edge.
func (m *PlanHistoryMutation) ResetChangeHistory() {
	m.change_history = nil
	m.clearedchange_history = false
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PlanHistoryMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[planhistory.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PlanHistoryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PlanHistoryMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PlanHistoryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetChangedByID sets the "changed_by" edge to the User entity by id.
func (m *PlanHistoryMutation) SetChangedByID(id pulid.ID) {
	m.changed_by = &id
}

// ClearChangedBy clears the "changed_by" edge to the User entity.
func (m *PlanHistoryMutation) ClearChangedBy() {
	m.clearedchanged_by = true
}

// ChangedByCleared reports if the "changed_by" edge to the User entity was cleared.
func (m *PlanHistoryMutation) ChangedByCleared() bool {
	return m.clearedchanged_by
}

// ChangedByID returns the "changed_by" edge ID in the mutation.
func (m *PlanHistoryMutation) ChangedByID() (id pulid.ID, exists bool) {
	if m.changed_by != nil {
		return *m.changed_by, true
	}
	return
}

// ChangedByIDs returns the "changed_by" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChangedByID instead. It exists only for internal usage by the builders.
func (m *PlanHistoryMutation) ChangedByIDs() (ids []pulid.ID) {
	if id := m.changed_by; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChangedBy resets all changes to the "changed_by" edge.
func (m *PlanHistoryMutation) ResetChangedBy() {
	m.changed_by = nil
	m.clearedchanged_by = false
}

// SetChangedFromID sets the "changed_from" edge to the Plan entity by id.
func (m *PlanHistoryMutation) SetChangedFromID(id pulid.ID) {
	m.changed_from = &id
}

// ClearChangedFrom clears the "changed_from" edge to the Plan entity.
func (m *PlanHistoryMutation) ClearChangedFrom() {
	m.clearedchanged_from = true
}

// ChangedFromCleared reports if the "changed_from" edge to the Plan entity was cleared.
func (m *PlanHistoryMutation) ChangedFromCleared() bool {
	return m.clearedchanged_from
}

// ChangedFromID returns the "changed_from" edge ID in the mutation.
func (m *PlanHistoryMutation) ChangedFromID() (id pulid.ID, exists bool) {
	if m.changed_from != nil {
		return *m.changed_from, true
	}
	return
}

// ChangedFromIDs returns the "changed_from" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChangedFromID instead. It exists only for internal usage by the builders.
func (m *PlanHistoryMutation) ChangedFromIDs() (ids []pulid.ID) {
	if id := m.changed_from; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChangedFrom resets all changes to the "changed_from" edge.
func (m *PlanHistoryMutation) ResetChangedFrom() {
	m.changed_from = nil
	m.clearedchanged_from = false
}

// Where appends a list predicates to the PlanHistoryMutation builder.
func (m *PlanHistoryMutation) Where(ps ...predicate.PlanHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PlanHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PlanHistory).
func (m *PlanHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanHistoryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, planhistory.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, planhistory.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case planhistory.FieldTenantID:
		return m.TenantID()
	case planhistory.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case planhistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case planhistory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PlanHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case planhistory.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case planhistory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PlanHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PlanHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown PlanHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanHistoryMutation) ResetField(name string) error {
	switch name {
	case planhistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case planhistory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PlanHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.change_history != nil {
		edges = append(edges, planhistory.EdgeChangeHistory)
	}
	if m.tenant != nil {
		edges = append(edges, planhistory.EdgeTenant)
	}
	if m.changed_by != nil {
		edges = append(edges, planhistory.EdgeChangedBy)
	}
	if m.changed_from != nil {
		edges = append(edges, planhistory.EdgeChangedFrom)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case planhistory.EdgeChangeHistory:
		if id := m.change_history; id != nil {
			return []ent.Value{*id}
		}
	case planhistory.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case planhistory.EdgeChangedBy:
		if id := m.changed_by; id != nil {
			return []ent.Value{*id}
		}
	case planhistory.EdgeChangedFrom:
		if id := m.changed_from; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedchange_history {
		edges = append(edges, planhistory.EdgeChangeHistory)
	}
	if m.clearedtenant {
		edges = append(edges, planhistory.EdgeTenant)
	}
	if m.clearedchanged_by {
		edges = append(edges, planhistory.EdgeChangedBy)
	}
	if m.clearedchanged_from {
		edges = append(edges, planhistory.EdgeChangedFrom)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case planhistory.EdgeChangeHistory:
		return m.clearedchange_history
	case planhistory.EdgeTenant:
		return m.clearedtenant
	case planhistory.EdgeChangedBy:
		return m.clearedchanged_by
	case planhistory.EdgeChangedFrom:
		return m.clearedchanged_from
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanHistoryMutation) ClearEdge(name string) error {
	switch name {
	case planhistory.EdgeChangeHistory:
		m.ClearChangeHistory()
		return nil
	case planhistory.EdgeTenant:
		m.ClearTenant()
		return nil
	case planhistory.EdgeChangedBy:
		m.ClearChangedBy()
		return nil
	case planhistory.EdgeChangedFrom:
		m.ClearChangedFrom()
		return nil
	}
	return fmt.Errorf("unknown PlanHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanHistoryMutation) ResetEdge(name string) error {
	switch name {
	case planhistory.EdgeChangeHistory:
		m.ResetChangeHistory()
		return nil
	case planhistory.EdgeTenant:
		m.ResetTenant()
		return nil
	case planhistory.EdgeChangedBy:
		m.ResetChangedBy()
		return nil
	case planhistory.EdgeChangedFrom:
		m.ResetChangedFrom()
		return nil
	}
	return fmt.Errorf("unknown PlanHistory edge %s", name)
}

// PrintJobMutation represents an operation that mutates the PrintJob nodes in the graph.
type PrintJobMutation struct {
	config
	op                     Op
	typ                    string
	id                     *pulid.ID
	status                 *printjob.Status
	file_extension         *printjob.FileExtension
	document_type          *printjob.DocumentType
	printer_messages       *[]string
	appendprinter_messages []string
	base64_print_data      *string
	created_at             *time.Time
	clearedFields          map[string]struct{}
	tenant                 *pulid.ID
	clearedtenant          bool
	printer                *pulid.ID
	clearedprinter         bool
	colli                  *pulid.ID
	clearedcolli           bool
	shipment_parcel        *pulid.ID
	clearedshipment_parcel bool
	done                   bool
	oldValue               func(context.Context) (*PrintJob, error)
	predicates             []predicate.PrintJob
}

var _ ent.Mutation = (*PrintJobMutation)(nil)

// printjobOption allows management of the mutation configuration using functional options.
type printjobOption func(*PrintJobMutation)

// newPrintJobMutation creates new mutation for the PrintJob entity.
func newPrintJobMutation(c config, op Op, opts ...printjobOption) *PrintJobMutation {
	m := &PrintJobMutation{
		config:        c,
		op:            op,
		typ:           TypePrintJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrintJobID sets the ID field of the mutation.
func withPrintJobID(id pulid.ID) printjobOption {
	return func(m *PrintJobMutation) {
		var (
			err   error
			once  sync.Once
			value *PrintJob
		)
		m.oldValue = func(ctx context.Context) (*PrintJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PrintJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrintJob sets the old PrintJob of the mutation.
func withPrintJob(node *PrintJob) printjobOption {
	return func(m *PrintJobMutation) {
		m.oldValue = func(context.Context) (*PrintJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrintJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrintJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PrintJob entities.
func (m *PrintJobMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrintJobMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrintJobMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PrintJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PrintJobMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PrintJobMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PrintJobMutation) ResetTenantID() {
	m.tenant = nil
}

// SetStatus sets the "status" field.
func (m *PrintJobMutation) SetStatus(pr printjob.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *PrintJobMutation) Status() (r printjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldStatus(ctx context.Context) (v printjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PrintJobMutation) ResetStatus() {
	m.status = nil
}

// SetFileExtension sets the "file_extension" field.
func (m *PrintJobMutation) SetFileExtension(pe printjob.FileExtension) {
	m.file_extension = &pe
}

// FileExtension returns the value of the "file_extension" field in the mutation.
func (m *PrintJobMutation) FileExtension() (r printjob.FileExtension, exists bool) {
	v := m.file_extension
	if v == nil {
		return
	}
	return *v, true
}

// OldFileExtension returns the old "file_extension" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldFileExtension(ctx context.Context) (v printjob.FileExtension, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileExtension: %w", err)
	}
	return oldValue.FileExtension, nil
}

// ResetFileExtension resets all changes to the "file_extension" field.
func (m *PrintJobMutation) ResetFileExtension() {
	m.file_extension = nil
}

// SetDocumentType sets the "document_type" field.
func (m *PrintJobMutation) SetDocumentType(pt printjob.DocumentType) {
	m.document_type = &pt
}

// DocumentType returns the value of the "document_type" field in the mutation.
func (m *PrintJobMutation) DocumentType() (r printjob.DocumentType, exists bool) {
	v := m.document_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentType returns the old "document_type" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldDocumentType(ctx context.Context) (v printjob.DocumentType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentType: %w", err)
	}
	return oldValue.DocumentType, nil
}

// ResetDocumentType resets all changes to the "document_type" field.
func (m *PrintJobMutation) ResetDocumentType() {
	m.document_type = nil
}

// SetPrinterMessages sets the "printer_messages" field.
func (m *PrintJobMutation) SetPrinterMessages(s []string) {
	m.printer_messages = &s
	m.appendprinter_messages = nil
}

// PrinterMessages returns the value of the "printer_messages" field in the mutation.
func (m *PrintJobMutation) PrinterMessages() (r []string, exists bool) {
	v := m.printer_messages
	if v == nil {
		return
	}
	return *v, true
}

// OldPrinterMessages returns the old "printer_messages" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldPrinterMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrinterMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrinterMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrinterMessages: %w", err)
	}
	return oldValue.PrinterMessages, nil
}

// AppendPrinterMessages adds s to the "printer_messages" field.
func (m *PrintJobMutation) AppendPrinterMessages(s []string) {
	m.appendprinter_messages = append(m.appendprinter_messages, s...)
}

// AppendedPrinterMessages returns the list of values that were appended to the "printer_messages" field in this mutation.
func (m *PrintJobMutation) AppendedPrinterMessages() ([]string, bool) {
	if len(m.appendprinter_messages) == 0 {
		return nil, false
	}
	return m.appendprinter_messages, true
}

// ClearPrinterMessages clears the value of the "printer_messages" field.
func (m *PrintJobMutation) ClearPrinterMessages() {
	m.printer_messages = nil
	m.appendprinter_messages = nil
	m.clearedFields[printjob.FieldPrinterMessages] = struct{}{}
}

// PrinterMessagesCleared returns if the "printer_messages" field was cleared in this mutation.
func (m *PrintJobMutation) PrinterMessagesCleared() bool {
	_, ok := m.clearedFields[printjob.FieldPrinterMessages]
	return ok
}

// ResetPrinterMessages resets all changes to the "printer_messages" field.
func (m *PrintJobMutation) ResetPrinterMessages() {
	m.printer_messages = nil
	m.appendprinter_messages = nil
	delete(m.clearedFields, printjob.FieldPrinterMessages)
}

// SetBase64PrintData sets the "base64_print_data" field.
func (m *PrintJobMutation) SetBase64PrintData(s string) {
	m.base64_print_data = &s
}

// Base64PrintData returns the value of the "base64_print_data" field in the mutation.
func (m *PrintJobMutation) Base64PrintData() (r string, exists bool) {
	v := m.base64_print_data
	if v == nil {
		return
	}
	return *v, true
}

// OldBase64PrintData returns the old "base64_print_data" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldBase64PrintData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBase64PrintData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBase64PrintData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBase64PrintData: %w", err)
	}
	return oldValue.Base64PrintData, nil
}

// ResetBase64PrintData resets all changes to the "base64_print_data" field.
func (m *PrintJobMutation) ResetBase64PrintData() {
	m.base64_print_data = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PrintJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PrintJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PrintJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PrintJobMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[printjob.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PrintJobMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PrintJobMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PrintJobMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetPrinterID sets the "printer" edge to the Printer entity by id.
func (m *PrintJobMutation) SetPrinterID(id pulid.ID) {
	m.printer = &id
}

// ClearPrinter clears the "printer" edge to the Printer entity.
func (m *PrintJobMutation) ClearPrinter() {
	m.clearedprinter = true
}

// PrinterCleared reports if the "printer" edge to the Printer entity was cleared.
func (m *PrintJobMutation) PrinterCleared() bool {
	return m.clearedprinter
}

// PrinterID returns the "printer" edge ID in the mutation.
func (m *PrintJobMutation) PrinterID() (id pulid.ID, exists bool) {
	if m.printer != nil {
		return *m.printer, true
	}
	return
}

// PrinterIDs returns the "printer" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrinterID instead. It exists only for internal usage by the builders.
func (m *PrintJobMutation) PrinterIDs() (ids []pulid.ID) {
	if id := m.printer; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrinter resets all changes to the "printer" edge.
func (m *PrintJobMutation) ResetPrinter() {
	m.printer = nil
	m.clearedprinter = false
}

// SetColliID sets the "colli" edge to the Colli entity by id.
func (m *PrintJobMutation) SetColliID(id pulid.ID) {
	m.colli = &id
}

// ClearColli clears the "colli" edge to the Colli entity.
func (m *PrintJobMutation) ClearColli() {
	m.clearedcolli = true
}

// ColliCleared reports if the "colli" edge to the Colli entity was cleared.
func (m *PrintJobMutation) ColliCleared() bool {
	return m.clearedcolli
}

// ColliID returns the "colli" edge ID in the mutation.
func (m *PrintJobMutation) ColliID() (id pulid.ID, exists bool) {
	if m.colli != nil {
		return *m.colli, true
	}
	return
}

// ColliIDs returns the "colli" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ColliID instead. It exists only for internal usage by the builders.
func (m *PrintJobMutation) ColliIDs() (ids []pulid.ID) {
	if id := m.colli; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetColli resets all changes to the "colli" edge.
func (m *PrintJobMutation) ResetColli() {
	m.colli = nil
	m.clearedcolli = false
}

// SetShipmentParcelID sets the "shipment_parcel" edge to the ShipmentParcel entity by id.
func (m *PrintJobMutation) SetShipmentParcelID(id pulid.ID) {
	m.shipment_parcel = &id
}

// ClearShipmentParcel clears the "shipment_parcel" edge to the ShipmentParcel entity.
func (m *PrintJobMutation) ClearShipmentParcel() {
	m.clearedshipment_parcel = true
}

// ShipmentParcelCleared reports if the "shipment_parcel" edge to the ShipmentParcel entity was cleared.
func (m *PrintJobMutation) ShipmentParcelCleared() bool {
	return m.clearedshipment_parcel
}

// ShipmentParcelID returns the "shipment_parcel" edge ID in the mutation.
func (m *PrintJobMutation) ShipmentParcelID() (id pulid.ID, exists bool) {
	if m.shipment_parcel != nil {
		return *m.shipment_parcel, true
	}
	return
}

// ShipmentParcelIDs returns the "shipment_parcel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentParcelID instead. It exists only for internal usage by the builders.
func (m *PrintJobMutation) ShipmentParcelIDs() (ids []pulid.ID) {
	if id := m.shipment_parcel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentParcel resets all changes to the "shipment_parcel" edge.
func (m *PrintJobMutation) ResetShipmentParcel() {
	m.shipment_parcel = nil
	m.clearedshipment_parcel = false
}

// Where appends a list predicates to the PrintJobMutation builder.
func (m *PrintJobMutation) Where(ps ...predicate.PrintJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrintJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrintJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PrintJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrintJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrintJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PrintJob).
func (m *PrintJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrintJobMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, printjob.FieldTenantID)
	}
	if m.status != nil {
		fields = append(fields, printjob.FieldStatus)
	}
	if m.file_extension != nil {
		fields = append(fields, printjob.FieldFileExtension)
	}
	if m.document_type != nil {
		fields = append(fields, printjob.FieldDocumentType)
	}
	if m.printer_messages != nil {
		fields = append(fields, printjob.FieldPrinterMessages)
	}
	if m.base64_print_data != nil {
		fields = append(fields, printjob.FieldBase64PrintData)
	}
	if m.created_at != nil {
		fields = append(fields, printjob.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrintJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case printjob.FieldTenantID:
		return m.TenantID()
	case printjob.FieldStatus:
		return m.Status()
	case printjob.FieldFileExtension:
		return m.FileExtension()
	case printjob.FieldDocumentType:
		return m.DocumentType()
	case printjob.FieldPrinterMessages:
		return m.PrinterMessages()
	case printjob.FieldBase64PrintData:
		return m.Base64PrintData()
	case printjob.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrintJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case printjob.FieldTenantID:
		return m.OldTenantID(ctx)
	case printjob.FieldStatus:
		return m.OldStatus(ctx)
	case printjob.FieldFileExtension:
		return m.OldFileExtension(ctx)
	case printjob.FieldDocumentType:
		return m.OldDocumentType(ctx)
	case printjob.FieldPrinterMessages:
		return m.OldPrinterMessages(ctx)
	case printjob.FieldBase64PrintData:
		return m.OldBase64PrintData(ctx)
	case printjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PrintJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrintJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case printjob.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case printjob.FieldStatus:
		v, ok := value.(printjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case printjob.FieldFileExtension:
		v, ok := value.(printjob.FileExtension)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileExtension(v)
		return nil
	case printjob.FieldDocumentType:
		v, ok := value.(printjob.DocumentType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentType(v)
		return nil
	case printjob.FieldPrinterMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrinterMessages(v)
		return nil
	case printjob.FieldBase64PrintData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBase64PrintData(v)
		return nil
	case printjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PrintJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrintJobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrintJobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrintJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PrintJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrintJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(printjob.FieldPrinterMessages) {
		fields = append(fields, printjob.FieldPrinterMessages)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrintJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrintJobMutation) ClearField(name string) error {
	switch name {
	case printjob.FieldPrinterMessages:
		m.ClearPrinterMessages()
		return nil
	}
	return fmt.Errorf("unknown PrintJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrintJobMutation) ResetField(name string) error {
	switch name {
	case printjob.FieldTenantID:
		m.ResetTenantID()
		return nil
	case printjob.FieldStatus:
		m.ResetStatus()
		return nil
	case printjob.FieldFileExtension:
		m.ResetFileExtension()
		return nil
	case printjob.FieldDocumentType:
		m.ResetDocumentType()
		return nil
	case printjob.FieldPrinterMessages:
		m.ResetPrinterMessages()
		return nil
	case printjob.FieldBase64PrintData:
		m.ResetBase64PrintData()
		return nil
	case printjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PrintJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrintJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, printjob.EdgeTenant)
	}
	if m.printer != nil {
		edges = append(edges, printjob.EdgePrinter)
	}
	if m.colli != nil {
		edges = append(edges, printjob.EdgeColli)
	}
	if m.shipment_parcel != nil {
		edges = append(edges, printjob.EdgeShipmentParcel)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrintJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case printjob.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case printjob.EdgePrinter:
		if id := m.printer; id != nil {
			return []ent.Value{*id}
		}
	case printjob.EdgeColli:
		if id := m.colli; id != nil {
			return []ent.Value{*id}
		}
	case printjob.EdgeShipmentParcel:
		if id := m.shipment_parcel; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrintJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrintJobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrintJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, printjob.EdgeTenant)
	}
	if m.clearedprinter {
		edges = append(edges, printjob.EdgePrinter)
	}
	if m.clearedcolli {
		edges = append(edges, printjob.EdgeColli)
	}
	if m.clearedshipment_parcel {
		edges = append(edges, printjob.EdgeShipmentParcel)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrintJobMutation) EdgeCleared(name string) bool {
	switch name {
	case printjob.EdgeTenant:
		return m.clearedtenant
	case printjob.EdgePrinter:
		return m.clearedprinter
	case printjob.EdgeColli:
		return m.clearedcolli
	case printjob.EdgeShipmentParcel:
		return m.clearedshipment_parcel
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrintJobMutation) ClearEdge(name string) error {
	switch name {
	case printjob.EdgeTenant:
		m.ClearTenant()
		return nil
	case printjob.EdgePrinter:
		m.ClearPrinter()
		return nil
	case printjob.EdgeColli:
		m.ClearColli()
		return nil
	case printjob.EdgeShipmentParcel:
		m.ClearShipmentParcel()
		return nil
	}
	return fmt.Errorf("unknown PrintJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrintJobMutation) ResetEdge(name string) error {
	switch name {
	case printjob.EdgeTenant:
		m.ResetTenant()
		return nil
	case printjob.EdgePrinter:
		m.ResetPrinter()
		return nil
	case printjob.EdgeColli:
		m.ResetColli()
		return nil
	case printjob.EdgeShipmentParcel:
		m.ResetShipmentParcel()
		return nil
	}
	return fmt.Errorf("unknown PrintJob edge %s", name)
}

// PrinterMutation represents an operation that mutates the Printer nodes in the graph.
type PrinterMutation struct {
	config
	op                 Op
	typ                string
	id                 *pulid.ID
	device_id          *pulid.ID
	name               *string
	label_zpl          *bool
	label_pdf          *bool
	label_png          *bool
	document           *bool
	rotate_180         *bool
	use_shell          *bool
	print_size         *printer.PrintSize
	created_at         *time.Time
	last_ping          *time.Time
	clearedFields      map[string]struct{}
	tenant             *pulid.ID
	clearedtenant      bool
	workstation        *pulid.ID
	clearedworkstation bool
	print_jobs         map[pulid.ID]struct{}
	removedprint_jobs  map[pulid.ID]struct{}
	clearedprint_jobs  bool
	done               bool
	oldValue           func(context.Context) (*Printer, error)
	predicates         []predicate.Printer
}

var _ ent.Mutation = (*PrinterMutation)(nil)

// printerOption allows management of the mutation configuration using functional options.
type printerOption func(*PrinterMutation)

// newPrinterMutation creates new mutation for the Printer entity.
func newPrinterMutation(c config, op Op, opts ...printerOption) *PrinterMutation {
	m := &PrinterMutation{
		config:        c,
		op:            op,
		typ:           TypePrinter,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrinterID sets the ID field of the mutation.
func withPrinterID(id pulid.ID) printerOption {
	return func(m *PrinterMutation) {
		var (
			err   error
			once  sync.Once
			value *Printer
		)
		m.oldValue = func(ctx context.Context) (*Printer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Printer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrinter sets the old Printer of the mutation.
func withPrinter(node *Printer) printerOption {
	return func(m *PrinterMutation) {
		m.oldValue = func(context.Context) (*Printer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrinterMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrinterMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Printer entities.
func (m *PrinterMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrinterMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrinterMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Printer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *PrinterMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *PrinterMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *PrinterMutation) ResetTenantID() {
	m.tenant = nil
}

// SetDeviceID sets the "device_id" field.
func (m *PrinterMutation) SetDeviceID(pu pulid.ID) {
	m.device_id = &pu
}

// DeviceID returns the value of the "device_id" field in the mutation.
func (m *PrinterMutation) DeviceID() (r pulid.ID, exists bool) {
	v := m.device_id
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceID returns the old "device_id" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldDeviceID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceID: %w", err)
	}
	return oldValue.DeviceID, nil
}

// ResetDeviceID resets all changes to the "device_id" field.
func (m *PrinterMutation) ResetDeviceID() {
	m.device_id = nil
}

// SetName sets the "name" field.
func (m *PrinterMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PrinterMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PrinterMutation) ResetName() {
	m.name = nil
}

// SetLabelZpl sets the "label_zpl" field.
func (m *PrinterMutation) SetLabelZpl(b bool) {
	m.label_zpl = &b
}

// LabelZpl returns the value of the "label_zpl" field in the mutation.
func (m *PrinterMutation) LabelZpl() (r bool, exists bool) {
	v := m.label_zpl
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelZpl returns the old "label_zpl" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldLabelZpl(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelZpl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelZpl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelZpl: %w", err)
	}
	return oldValue.LabelZpl, nil
}

// ResetLabelZpl resets all changes to the "label_zpl" field.
func (m *PrinterMutation) ResetLabelZpl() {
	m.label_zpl = nil
}

// SetLabelPdf sets the "label_pdf" field.
func (m *PrinterMutation) SetLabelPdf(b bool) {
	m.label_pdf = &b
}

// LabelPdf returns the value of the "label_pdf" field in the mutation.
func (m *PrinterMutation) LabelPdf() (r bool, exists bool) {
	v := m.label_pdf
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelPdf returns the old "label_pdf" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldLabelPdf(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelPdf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelPdf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelPdf: %w", err)
	}
	return oldValue.LabelPdf, nil
}

// ResetLabelPdf resets all changes to the "label_pdf" field.
func (m *PrinterMutation) ResetLabelPdf() {
	m.label_pdf = nil
}

// SetLabelPng sets the "label_png" field.
func (m *PrinterMutation) SetLabelPng(b bool) {
	m.label_png = &b
}

// LabelPng returns the value of the "label_png" field in the mutation.
func (m *PrinterMutation) LabelPng() (r bool, exists bool) {
	v := m.label_png
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelPng returns the old "label_png" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldLabelPng(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelPng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelPng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelPng: %w", err)
	}
	return oldValue.LabelPng, nil
}

// ResetLabelPng resets all changes to the "label_png" field.
func (m *PrinterMutation) ResetLabelPng() {
	m.label_png = nil
}

// SetDocument sets the "document" field.
func (m *PrinterMutation) SetDocument(b bool) {
	m.document = &b
}

// Document returns the value of the "document" field in the mutation.
func (m *PrinterMutation) Document() (r bool, exists bool) {
	v := m.document
	if v == nil {
		return
	}
	return *v, true
}

// OldDocument returns the old "document" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldDocument(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocument is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocument requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocument: %w", err)
	}
	return oldValue.Document, nil
}

// ResetDocument resets all changes to the "document" field.
func (m *PrinterMutation) ResetDocument() {
	m.document = nil
}

// SetRotate180 sets the "rotate_180" field.
func (m *PrinterMutation) SetRotate180(b bool) {
	m.rotate_180 = &b
}

// Rotate180 returns the value of the "rotate_180" field in the mutation.
func (m *PrinterMutation) Rotate180() (r bool, exists bool) {
	v := m.rotate_180
	if v == nil {
		return
	}
	return *v, true
}

// OldRotate180 returns the old "rotate_180" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldRotate180(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRotate180 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRotate180 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRotate180: %w", err)
	}
	return oldValue.Rotate180, nil
}

// ResetRotate180 resets all changes to the "rotate_180" field.
func (m *PrinterMutation) ResetRotate180() {
	m.rotate_180 = nil
}

// SetUseShell sets the "use_shell" field.
func (m *PrinterMutation) SetUseShell(b bool) {
	m.use_shell = &b
}

// UseShell returns the value of the "use_shell" field in the mutation.
func (m *PrinterMutation) UseShell() (r bool, exists bool) {
	v := m.use_shell
	if v == nil {
		return
	}
	return *v, true
}

// OldUseShell returns the old "use_shell" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldUseShell(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseShell is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseShell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseShell: %w", err)
	}
	return oldValue.UseShell, nil
}

// ResetUseShell resets all changes to the "use_shell" field.
func (m *PrinterMutation) ResetUseShell() {
	m.use_shell = nil
}

// SetPrintSize sets the "print_size" field.
func (m *PrinterMutation) SetPrintSize(ps printer.PrintSize) {
	m.print_size = &ps
}

// PrintSize returns the value of the "print_size" field in the mutation.
func (m *PrinterMutation) PrintSize() (r printer.PrintSize, exists bool) {
	v := m.print_size
	if v == nil {
		return
	}
	return *v, true
}

// OldPrintSize returns the old "print_size" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldPrintSize(ctx context.Context) (v printer.PrintSize, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrintSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrintSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrintSize: %w", err)
	}
	return oldValue.PrintSize, nil
}

// ResetPrintSize resets all changes to the "print_size" field.
func (m *PrinterMutation) ResetPrintSize() {
	m.print_size = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *PrinterMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PrinterMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PrinterMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLastPing sets the "last_ping" field.
func (m *PrinterMutation) SetLastPing(t time.Time) {
	m.last_ping = &t
}

// LastPing returns the value of the "last_ping" field in the mutation.
func (m *PrinterMutation) LastPing() (r time.Time, exists bool) {
	v := m.last_ping
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPing returns the old "last_ping" field's value of the Printer entity.
// If the Printer object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrinterMutation) OldLastPing(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPing: %w", err)
	}
	return oldValue.LastPing, nil
}

// ResetLastPing resets all changes to the "last_ping" field.
func (m *PrinterMutation) ResetLastPing() {
	m.last_ping = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *PrinterMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[printer.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *PrinterMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *PrinterMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *PrinterMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetWorkstationID sets the "workstation" edge to the Workstation entity by id.
func (m *PrinterMutation) SetWorkstationID(id pulid.ID) {
	m.workstation = &id
}

// ClearWorkstation clears the "workstation" edge to the Workstation entity.
func (m *PrinterMutation) ClearWorkstation() {
	m.clearedworkstation = true
}

// WorkstationCleared reports if the "workstation" edge to the Workstation entity was cleared.
func (m *PrinterMutation) WorkstationCleared() bool {
	return m.clearedworkstation
}

// WorkstationID returns the "workstation" edge ID in the mutation.
func (m *PrinterMutation) WorkstationID() (id pulid.ID, exists bool) {
	if m.workstation != nil {
		return *m.workstation, true
	}
	return
}

// WorkstationIDs returns the "workstation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkstationID instead. It exists only for internal usage by the builders.
func (m *PrinterMutation) WorkstationIDs() (ids []pulid.ID) {
	if id := m.workstation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkstation resets all changes to the "workstation" edge.
func (m *PrinterMutation) ResetWorkstation() {
	m.workstation = nil
	m.clearedworkstation = false
}

// AddPrintJobIDs adds the "print_jobs" edge to the PrintJob entity by ids.
func (m *PrinterMutation) AddPrintJobIDs(ids ...pulid.ID) {
	if m.print_jobs == nil {
		m.print_jobs = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.print_jobs[ids[i]] = struct{}{}
	}
}

// ClearPrintJobs clears the "print_jobs" edge to the PrintJob entity.
func (m *PrinterMutation) ClearPrintJobs() {
	m.clearedprint_jobs = true
}

// PrintJobsCleared reports if the "print_jobs" edge to the PrintJob entity was cleared.
func (m *PrinterMutation) PrintJobsCleared() bool {
	return m.clearedprint_jobs
}

// RemovePrintJobIDs removes the "print_jobs" edge to the PrintJob entity by IDs.
func (m *PrinterMutation) RemovePrintJobIDs(ids ...pulid.ID) {
	if m.removedprint_jobs == nil {
		m.removedprint_jobs = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.print_jobs, ids[i])
		m.removedprint_jobs[ids[i]] = struct{}{}
	}
}

// RemovedPrintJobs returns the removed IDs of the "print_jobs" edge to the PrintJob entity.
func (m *PrinterMutation) RemovedPrintJobsIDs() (ids []pulid.ID) {
	for id := range m.removedprint_jobs {
		ids = append(ids, id)
	}
	return
}

// PrintJobsIDs returns the "print_jobs" edge IDs in the mutation.
func (m *PrinterMutation) PrintJobsIDs() (ids []pulid.ID) {
	for id := range m.print_jobs {
		ids = append(ids, id)
	}
	return
}

// ResetPrintJobs resets all changes to the "print_jobs" edge.
func (m *PrinterMutation) ResetPrintJobs() {
	m.print_jobs = nil
	m.clearedprint_jobs = false
	m.removedprint_jobs = nil
}

// Where appends a list predicates to the PrinterMutation builder.
func (m *PrinterMutation) Where(ps ...predicate.Printer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrinterMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrinterMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Printer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrinterMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrinterMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Printer).
func (m *PrinterMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrinterMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.tenant != nil {
		fields = append(fields, printer.FieldTenantID)
	}
	if m.device_id != nil {
		fields = append(fields, printer.FieldDeviceID)
	}
	if m.name != nil {
		fields = append(fields, printer.FieldName)
	}
	if m.label_zpl != nil {
		fields = append(fields, printer.FieldLabelZpl)
	}
	if m.label_pdf != nil {
		fields = append(fields, printer.FieldLabelPdf)
	}
	if m.label_png != nil {
		fields = append(fields, printer.FieldLabelPng)
	}
	if m.document != nil {
		fields = append(fields, printer.FieldDocument)
	}
	if m.rotate_180 != nil {
		fields = append(fields, printer.FieldRotate180)
	}
	if m.use_shell != nil {
		fields = append(fields, printer.FieldUseShell)
	}
	if m.print_size != nil {
		fields = append(fields, printer.FieldPrintSize)
	}
	if m.created_at != nil {
		fields = append(fields, printer.FieldCreatedAt)
	}
	if m.last_ping != nil {
		fields = append(fields, printer.FieldLastPing)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrinterMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case printer.FieldTenantID:
		return m.TenantID()
	case printer.FieldDeviceID:
		return m.DeviceID()
	case printer.FieldName:
		return m.Name()
	case printer.FieldLabelZpl:
		return m.LabelZpl()
	case printer.FieldLabelPdf:
		return m.LabelPdf()
	case printer.FieldLabelPng:
		return m.LabelPng()
	case printer.FieldDocument:
		return m.Document()
	case printer.FieldRotate180:
		return m.Rotate180()
	case printer.FieldUseShell:
		return m.UseShell()
	case printer.FieldPrintSize:
		return m.PrintSize()
	case printer.FieldCreatedAt:
		return m.CreatedAt()
	case printer.FieldLastPing:
		return m.LastPing()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrinterMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case printer.FieldTenantID:
		return m.OldTenantID(ctx)
	case printer.FieldDeviceID:
		return m.OldDeviceID(ctx)
	case printer.FieldName:
		return m.OldName(ctx)
	case printer.FieldLabelZpl:
		return m.OldLabelZpl(ctx)
	case printer.FieldLabelPdf:
		return m.OldLabelPdf(ctx)
	case printer.FieldLabelPng:
		return m.OldLabelPng(ctx)
	case printer.FieldDocument:
		return m.OldDocument(ctx)
	case printer.FieldRotate180:
		return m.OldRotate180(ctx)
	case printer.FieldUseShell:
		return m.OldUseShell(ctx)
	case printer.FieldPrintSize:
		return m.OldPrintSize(ctx)
	case printer.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case printer.FieldLastPing:
		return m.OldLastPing(ctx)
	}
	return nil, fmt.Errorf("unknown Printer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrinterMutation) SetField(name string, value ent.Value) error {
	switch name {
	case printer.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case printer.FieldDeviceID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceID(v)
		return nil
	case printer.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case printer.FieldLabelZpl:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelZpl(v)
		return nil
	case printer.FieldLabelPdf:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelPdf(v)
		return nil
	case printer.FieldLabelPng:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelPng(v)
		return nil
	case printer.FieldDocument:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocument(v)
		return nil
	case printer.FieldRotate180:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRotate180(v)
		return nil
	case printer.FieldUseShell:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseShell(v)
		return nil
	case printer.FieldPrintSize:
		v, ok := value.(printer.PrintSize)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrintSize(v)
		return nil
	case printer.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case printer.FieldLastPing:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPing(v)
		return nil
	}
	return fmt.Errorf("unknown Printer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrinterMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrinterMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrinterMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Printer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrinterMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrinterMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrinterMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Printer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrinterMutation) ResetField(name string) error {
	switch name {
	case printer.FieldTenantID:
		m.ResetTenantID()
		return nil
	case printer.FieldDeviceID:
		m.ResetDeviceID()
		return nil
	case printer.FieldName:
		m.ResetName()
		return nil
	case printer.FieldLabelZpl:
		m.ResetLabelZpl()
		return nil
	case printer.FieldLabelPdf:
		m.ResetLabelPdf()
		return nil
	case printer.FieldLabelPng:
		m.ResetLabelPng()
		return nil
	case printer.FieldDocument:
		m.ResetDocument()
		return nil
	case printer.FieldRotate180:
		m.ResetRotate180()
		return nil
	case printer.FieldUseShell:
		m.ResetUseShell()
		return nil
	case printer.FieldPrintSize:
		m.ResetPrintSize()
		return nil
	case printer.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case printer.FieldLastPing:
		m.ResetLastPing()
		return nil
	}
	return fmt.Errorf("unknown Printer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrinterMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, printer.EdgeTenant)
	}
	if m.workstation != nil {
		edges = append(edges, printer.EdgeWorkstation)
	}
	if m.print_jobs != nil {
		edges = append(edges, printer.EdgePrintJobs)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrinterMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case printer.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case printer.EdgeWorkstation:
		if id := m.workstation; id != nil {
			return []ent.Value{*id}
		}
	case printer.EdgePrintJobs:
		ids := make([]ent.Value, 0, len(m.print_jobs))
		for id := range m.print_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrinterMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedprint_jobs != nil {
		edges = append(edges, printer.EdgePrintJobs)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrinterMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case printer.EdgePrintJobs:
		ids := make([]ent.Value, 0, len(m.removedprint_jobs))
		for id := range m.removedprint_jobs {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrinterMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, printer.EdgeTenant)
	}
	if m.clearedworkstation {
		edges = append(edges, printer.EdgeWorkstation)
	}
	if m.clearedprint_jobs {
		edges = append(edges, printer.EdgePrintJobs)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrinterMutation) EdgeCleared(name string) bool {
	switch name {
	case printer.EdgeTenant:
		return m.clearedtenant
	case printer.EdgeWorkstation:
		return m.clearedworkstation
	case printer.EdgePrintJobs:
		return m.clearedprint_jobs
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrinterMutation) ClearEdge(name string) error {
	switch name {
	case printer.EdgeTenant:
		m.ClearTenant()
		return nil
	case printer.EdgeWorkstation:
		m.ClearWorkstation()
		return nil
	}
	return fmt.Errorf("unknown Printer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrinterMutation) ResetEdge(name string) error {
	switch name {
	case printer.EdgeTenant:
		m.ResetTenant()
		return nil
	case printer.EdgeWorkstation:
		m.ResetWorkstation()
		return nil
	case printer.EdgePrintJobs:
		m.ResetPrintJobs()
		return nil
	}
	return fmt.Errorf("unknown Printer edge %s", name)
}

// ProductMutation represents an operation that mutates the Product nodes in the graph.
type ProductMutation struct {
	config
	op                     Op
	typ                    string
	id                     *pulid.ID
	external_id            *string
	title                  *string
	body_html              *string
	status                 *product.Status
	created_at             *time.Time
	updated_at             *time.Time
	clearedFields          map[string]struct{}
	tenant                 *pulid.ID
	clearedtenant          bool
	product_tags           map[pulid.ID]struct{}
	removedproduct_tags    map[pulid.ID]struct{}
	clearedproduct_tags    bool
	product_variant        map[pulid.ID]struct{}
	removedproduct_variant map[pulid.ID]struct{}
	clearedproduct_variant bool
	product_image          map[pulid.ID]struct{}
	removedproduct_image   map[pulid.ID]struct{}
	clearedproduct_image   bool
	done                   bool
	oldValue               func(context.Context) (*Product, error)
	predicates             []predicate.Product
}

var _ ent.Mutation = (*ProductMutation)(nil)

// productOption allows management of the mutation configuration using functional options.
type productOption func(*ProductMutation)

// newProductMutation creates new mutation for the Product entity.
func newProductMutation(c config, op Op, opts ...productOption) *ProductMutation {
	m := &ProductMutation{
		config:        c,
		op:            op,
		typ:           TypeProduct,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductID sets the ID field of the mutation.
func withProductID(id pulid.ID) productOption {
	return func(m *ProductMutation) {
		var (
			err   error
			once  sync.Once
			value *Product
		)
		m.oldValue = func(ctx context.Context) (*Product, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Product.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProduct sets the old Product of the mutation.
func withProduct(node *Product) productOption {
	return func(m *ProductMutation) {
		m.oldValue = func(context.Context) (*Product, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Product entities.
func (m *ProductMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Product.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ProductMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProductMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProductMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *ProductMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *ProductMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *ProductMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[product.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *ProductMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[product.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *ProductMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, product.FieldExternalID)
}

// SetTitle sets the "title" field.
func (m *ProductMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProductMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ProductMutation) ResetTitle() {
	m.title = nil
}

// SetBodyHTML sets the "body_html" field.
func (m *ProductMutation) SetBodyHTML(s string) {
	m.body_html = &s
}

// BodyHTML returns the value of the "body_html" field in the mutation.
func (m *ProductMutation) BodyHTML() (r string, exists bool) {
	v := m.body_html
	if v == nil {
		return
	}
	return *v, true
}

// OldBodyHTML returns the old "body_html" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldBodyHTML(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBodyHTML is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBodyHTML requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBodyHTML: %w", err)
	}
	return oldValue.BodyHTML, nil
}

// ClearBodyHTML clears the value of the "body_html" field.
func (m *ProductMutation) ClearBodyHTML() {
	m.body_html = nil
	m.clearedFields[product.FieldBodyHTML] = struct{}{}
}

// BodyHTMLCleared returns if the "body_html" field was cleared in this mutation.
func (m *ProductMutation) BodyHTMLCleared() bool {
	_, ok := m.clearedFields[product.FieldBodyHTML]
	return ok
}

// ResetBodyHTML resets all changes to the "body_html" field.
func (m *ProductMutation) ResetBodyHTML() {
	m.body_html = nil
	delete(m.clearedFields, product.FieldBodyHTML)
}

// SetStatus sets the "status" field.
func (m *ProductMutation) SetStatus(pr product.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *ProductMutation) Status() (r product.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldStatus(ctx context.Context) (v product.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ProductMutation) ResetStatus() {
	m.status = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[product.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[product.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, product.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Product entity.
// If the Product object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ProductMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[product.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ProductMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ProductMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ProductMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddProductTagIDs adds the "product_tags" edge to the ProductTag entity by ids.
func (m *ProductMutation) AddProductTagIDs(ids ...pulid.ID) {
	if m.product_tags == nil {
		m.product_tags = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.product_tags[ids[i]] = struct{}{}
	}
}

// ClearProductTags clears the "product_tags" edge to the ProductTag entity.
func (m *ProductMutation) ClearProductTags() {
	m.clearedproduct_tags = true
}

// ProductTagsCleared reports if the "product_tags" edge to the ProductTag entity was cleared.
func (m *ProductMutation) ProductTagsCleared() bool {
	return m.clearedproduct_tags
}

// RemoveProductTagIDs removes the "product_tags" edge to the ProductTag entity by IDs.
func (m *ProductMutation) RemoveProductTagIDs(ids ...pulid.ID) {
	if m.removedproduct_tags == nil {
		m.removedproduct_tags = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.product_tags, ids[i])
		m.removedproduct_tags[ids[i]] = struct{}{}
	}
}

// RemovedProductTags returns the removed IDs of the "product_tags" edge to the ProductTag entity.
func (m *ProductMutation) RemovedProductTagsIDs() (ids []pulid.ID) {
	for id := range m.removedproduct_tags {
		ids = append(ids, id)
	}
	return
}

// ProductTagsIDs returns the "product_tags" edge IDs in the mutation.
func (m *ProductMutation) ProductTagsIDs() (ids []pulid.ID) {
	for id := range m.product_tags {
		ids = append(ids, id)
	}
	return
}

// ResetProductTags resets all changes to the "product_tags" edge.
func (m *ProductMutation) ResetProductTags() {
	m.product_tags = nil
	m.clearedproduct_tags = false
	m.removedproduct_tags = nil
}

// AddProductVariantIDs adds the "product_variant" edge to the ProductVariant entity by ids.
func (m *ProductMutation) AddProductVariantIDs(ids ...pulid.ID) {
	if m.product_variant == nil {
		m.product_variant = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.product_variant[ids[i]] = struct{}{}
	}
}

// ClearProductVariant clears the "product_variant" edge to the ProductVariant entity.
func (m *ProductMutation) ClearProductVariant() {
	m.clearedproduct_variant = true
}

// ProductVariantCleared reports if the "product_variant" edge to the ProductVariant entity was cleared.
func (m *ProductMutation) ProductVariantCleared() bool {
	return m.clearedproduct_variant
}

// RemoveProductVariantIDs removes the "product_variant" edge to the ProductVariant entity by IDs.
func (m *ProductMutation) RemoveProductVariantIDs(ids ...pulid.ID) {
	if m.removedproduct_variant == nil {
		m.removedproduct_variant = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.product_variant, ids[i])
		m.removedproduct_variant[ids[i]] = struct{}{}
	}
}

// RemovedProductVariant returns the removed IDs of the "product_variant" edge to the ProductVariant entity.
func (m *ProductMutation) RemovedProductVariantIDs() (ids []pulid.ID) {
	for id := range m.removedproduct_variant {
		ids = append(ids, id)
	}
	return
}

// ProductVariantIDs returns the "product_variant" edge IDs in the mutation.
func (m *ProductMutation) ProductVariantIDs() (ids []pulid.ID) {
	for id := range m.product_variant {
		ids = append(ids, id)
	}
	return
}

// ResetProductVariant resets all changes to the "product_variant" edge.
func (m *ProductMutation) ResetProductVariant() {
	m.product_variant = nil
	m.clearedproduct_variant = false
	m.removedproduct_variant = nil
}

// AddProductImageIDs adds the "product_image" edge to the ProductImage entity by ids.
func (m *ProductMutation) AddProductImageIDs(ids ...pulid.ID) {
	if m.product_image == nil {
		m.product_image = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.product_image[ids[i]] = struct{}{}
	}
}

// ClearProductImage clears the "product_image" edge to the ProductImage entity.
func (m *ProductMutation) ClearProductImage() {
	m.clearedproduct_image = true
}

// ProductImageCleared reports if the "product_image" edge to the ProductImage entity was cleared.
func (m *ProductMutation) ProductImageCleared() bool {
	return m.clearedproduct_image
}

// RemoveProductImageIDs removes the "product_image" edge to the ProductImage entity by IDs.
func (m *ProductMutation) RemoveProductImageIDs(ids ...pulid.ID) {
	if m.removedproduct_image == nil {
		m.removedproduct_image = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.product_image, ids[i])
		m.removedproduct_image[ids[i]] = struct{}{}
	}
}

// RemovedProductImage returns the removed IDs of the "product_image" edge to the ProductImage entity.
func (m *ProductMutation) RemovedProductImageIDs() (ids []pulid.ID) {
	for id := range m.removedproduct_image {
		ids = append(ids, id)
	}
	return
}

// ProductImageIDs returns the "product_image" edge IDs in the mutation.
func (m *ProductMutation) ProductImageIDs() (ids []pulid.ID) {
	for id := range m.product_image {
		ids = append(ids, id)
	}
	return
}

// ResetProductImage resets all changes to the "product_image" edge.
func (m *ProductMutation) ResetProductImage() {
	m.product_image = nil
	m.clearedproduct_image = false
	m.removedproduct_image = nil
}

// Where appends a list predicates to the ProductMutation builder.
func (m *ProductMutation) Where(ps ...predicate.Product) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Product, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Product).
func (m *ProductMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, product.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, product.FieldExternalID)
	}
	if m.title != nil {
		fields = append(fields, product.FieldTitle)
	}
	if m.body_html != nil {
		fields = append(fields, product.FieldBodyHTML)
	}
	if m.status != nil {
		fields = append(fields, product.FieldStatus)
	}
	if m.created_at != nil {
		fields = append(fields, product.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, product.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case product.FieldTenantID:
		return m.TenantID()
	case product.FieldExternalID:
		return m.ExternalID()
	case product.FieldTitle:
		return m.Title()
	case product.FieldBodyHTML:
		return m.BodyHTML()
	case product.FieldStatus:
		return m.Status()
	case product.FieldCreatedAt:
		return m.CreatedAt()
	case product.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case product.FieldTenantID:
		return m.OldTenantID(ctx)
	case product.FieldExternalID:
		return m.OldExternalID(ctx)
	case product.FieldTitle:
		return m.OldTitle(ctx)
	case product.FieldBodyHTML:
		return m.OldBodyHTML(ctx)
	case product.FieldStatus:
		return m.OldStatus(ctx)
	case product.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case product.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Product field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) SetField(name string, value ent.Value) error {
	switch name {
	case product.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case product.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case product.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case product.FieldBodyHTML:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBodyHTML(v)
		return nil
	case product.FieldStatus:
		v, ok := value.(product.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case product.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case product.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Product numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(product.FieldExternalID) {
		fields = append(fields, product.FieldExternalID)
	}
	if m.FieldCleared(product.FieldBodyHTML) {
		fields = append(fields, product.FieldBodyHTML)
	}
	if m.FieldCleared(product.FieldCreatedAt) {
		fields = append(fields, product.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductMutation) ClearField(name string) error {
	switch name {
	case product.FieldExternalID:
		m.ClearExternalID()
		return nil
	case product.FieldBodyHTML:
		m.ClearBodyHTML()
		return nil
	case product.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Product nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductMutation) ResetField(name string) error {
	switch name {
	case product.FieldTenantID:
		m.ResetTenantID()
		return nil
	case product.FieldExternalID:
		m.ResetExternalID()
		return nil
	case product.FieldTitle:
		m.ResetTitle()
		return nil
	case product.FieldBodyHTML:
		m.ResetBodyHTML()
		return nil
	case product.FieldStatus:
		m.ResetStatus()
		return nil
	case product.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case product.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Product field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, product.EdgeTenant)
	}
	if m.product_tags != nil {
		edges = append(edges, product.EdgeProductTags)
	}
	if m.product_variant != nil {
		edges = append(edges, product.EdgeProductVariant)
	}
	if m.product_image != nil {
		edges = append(edges, product.EdgeProductImage)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case product.EdgeProductTags:
		ids := make([]ent.Value, 0, len(m.product_tags))
		for id := range m.product_tags {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductVariant:
		ids := make([]ent.Value, 0, len(m.product_variant))
		for id := range m.product_variant {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductImage:
		ids := make([]ent.Value, 0, len(m.product_image))
		for id := range m.product_image {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedproduct_tags != nil {
		edges = append(edges, product.EdgeProductTags)
	}
	if m.removedproduct_variant != nil {
		edges = append(edges, product.EdgeProductVariant)
	}
	if m.removedproduct_image != nil {
		edges = append(edges, product.EdgeProductImage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case product.EdgeProductTags:
		ids := make([]ent.Value, 0, len(m.removedproduct_tags))
		for id := range m.removedproduct_tags {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductVariant:
		ids := make([]ent.Value, 0, len(m.removedproduct_variant))
		for id := range m.removedproduct_variant {
			ids = append(ids, id)
		}
		return ids
	case product.EdgeProductImage:
		ids := make([]ent.Value, 0, len(m.removedproduct_image))
		for id := range m.removedproduct_image {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, product.EdgeTenant)
	}
	if m.clearedproduct_tags {
		edges = append(edges, product.EdgeProductTags)
	}
	if m.clearedproduct_variant {
		edges = append(edges, product.EdgeProductVariant)
	}
	if m.clearedproduct_image {
		edges = append(edges, product.EdgeProductImage)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductMutation) EdgeCleared(name string) bool {
	switch name {
	case product.EdgeTenant:
		return m.clearedtenant
	case product.EdgeProductTags:
		return m.clearedproduct_tags
	case product.EdgeProductVariant:
		return m.clearedproduct_variant
	case product.EdgeProductImage:
		return m.clearedproduct_image
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductMutation) ClearEdge(name string) error {
	switch name {
	case product.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown Product unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductMutation) ResetEdge(name string) error {
	switch name {
	case product.EdgeTenant:
		m.ResetTenant()
		return nil
	case product.EdgeProductTags:
		m.ResetProductTags()
		return nil
	case product.EdgeProductVariant:
		m.ResetProductVariant()
		return nil
	case product.EdgeProductImage:
		m.ResetProductImage()
		return nil
	}
	return fmt.Errorf("unknown Product edge %s", name)
}

// ProductImageMutation represents an operation that mutates the ProductImage nodes in the graph.
type ProductImageMutation struct {
	config
	op                     Op
	typ                    string
	id                     *pulid.ID
	external_id            *string
	url                    *string
	clearedFields          map[string]struct{}
	tenant                 *pulid.ID
	clearedtenant          bool
	product                *pulid.ID
	clearedproduct         bool
	product_variant        map[pulid.ID]struct{}
	removedproduct_variant map[pulid.ID]struct{}
	clearedproduct_variant bool
	done                   bool
	oldValue               func(context.Context) (*ProductImage, error)
	predicates             []predicate.ProductImage
}

var _ ent.Mutation = (*ProductImageMutation)(nil)

// productimageOption allows management of the mutation configuration using functional options.
type productimageOption func(*ProductImageMutation)

// newProductImageMutation creates new mutation for the ProductImage entity.
func newProductImageMutation(c config, op Op, opts ...productimageOption) *ProductImageMutation {
	m := &ProductImageMutation{
		config:        c,
		op:            op,
		typ:           TypeProductImage,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductImageID sets the ID field of the mutation.
func withProductImageID(id pulid.ID) productimageOption {
	return func(m *ProductImageMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductImage
		)
		m.oldValue = func(ctx context.Context) (*ProductImage, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductImage.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductImage sets the old ProductImage of the mutation.
func withProductImage(node *ProductImage) productimageOption {
	return func(m *ProductImageMutation) {
		m.oldValue = func(context.Context) (*ProductImage, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductImageMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductImageMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductImage entities.
func (m *ProductImageMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductImageMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductImageMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductImage.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ProductImageMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProductImageMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProductImage entity.
// If the ProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductImageMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProductImageMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExternalID sets the "external_id" field.
func (m *ProductImageMutation) SetExternalID(s string) {
	m.external_id = &s
}

// ExternalID returns the value of the "external_id" field in the mutation.
func (m *ProductImageMutation) ExternalID() (r string, exists bool) {
	v := m.external_id
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_id" field's value of the ProductImage entity.
// If the ProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductImageMutation) OldExternalID(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_id" field.
func (m *ProductImageMutation) ClearExternalID() {
	m.external_id = nil
	m.clearedFields[productimage.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_id" field was cleared in this mutation.
func (m *ProductImageMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[productimage.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_id" field.
func (m *ProductImageMutation) ResetExternalID() {
	m.external_id = nil
	delete(m.clearedFields, productimage.FieldExternalID)
}

// SetURL sets the "url" field.
func (m *ProductImageMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the value of the "url" field in the mutation.
func (m *ProductImageMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// OldURL returns the old "url" field's value of the ProductImage entity.
// If the ProductImage object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductImageMutation) OldURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldURL: %w", err)
	}
	return oldValue.URL, nil
}

// ResetURL resets all changes to the "url" field.
func (m *ProductImageMutation) ResetURL() {
	m.url = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ProductImageMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[productimage.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ProductImageMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ProductImageMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ProductImageMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *ProductImageMutation) SetProductID(id pulid.ID) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductImageMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductImageMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *ProductImageMutation) ProductID() (id pulid.ID, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductImageMutation) ProductIDs() (ids []pulid.ID) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductImageMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// AddProductVariantIDs adds the "product_variant" edge to the ProductVariant entity by ids.
func (m *ProductImageMutation) AddProductVariantIDs(ids ...pulid.ID) {
	if m.product_variant == nil {
		m.product_variant = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.product_variant[ids[i]] = struct{}{}
	}
}

// ClearProductVariant clears the "product_variant" edge to the ProductVariant entity.
func (m *ProductImageMutation) ClearProductVariant() {
	m.clearedproduct_variant = true
}

// ProductVariantCleared reports if the "product_variant" edge to the ProductVariant entity was cleared.
func (m *ProductImageMutation) ProductVariantCleared() bool {
	return m.clearedproduct_variant
}

// RemoveProductVariantIDs removes the "product_variant" edge to the ProductVariant entity by IDs.
func (m *ProductImageMutation) RemoveProductVariantIDs(ids ...pulid.ID) {
	if m.removedproduct_variant == nil {
		m.removedproduct_variant = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.product_variant, ids[i])
		m.removedproduct_variant[ids[i]] = struct{}{}
	}
}

// RemovedProductVariant returns the removed IDs of the "product_variant" edge to the ProductVariant entity.
func (m *ProductImageMutation) RemovedProductVariantIDs() (ids []pulid.ID) {
	for id := range m.removedproduct_variant {
		ids = append(ids, id)
	}
	return
}

// ProductVariantIDs returns the "product_variant" edge IDs in the mutation.
func (m *ProductImageMutation) ProductVariantIDs() (ids []pulid.ID) {
	for id := range m.product_variant {
		ids = append(ids, id)
	}
	return
}

// ResetProductVariant resets all changes to the "product_variant" edge.
func (m *ProductImageMutation) ResetProductVariant() {
	m.product_variant = nil
	m.clearedproduct_variant = false
	m.removedproduct_variant = nil
}

// Where appends a list predicates to the ProductImageMutation builder.
func (m *ProductImageMutation) Where(ps ...predicate.ProductImage) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductImageMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductImageMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductImage, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductImageMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductImageMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductImage).
func (m *ProductImageMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductImageMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, productimage.FieldTenantID)
	}
	if m.external_id != nil {
		fields = append(fields, productimage.FieldExternalID)
	}
	if m.url != nil {
		fields = append(fields, productimage.FieldURL)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductImageMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productimage.FieldTenantID:
		return m.TenantID()
	case productimage.FieldExternalID:
		return m.ExternalID()
	case productimage.FieldURL:
		return m.URL()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductImageMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productimage.FieldTenantID:
		return m.OldTenantID(ctx)
	case productimage.FieldExternalID:
		return m.OldExternalID(ctx)
	case productimage.FieldURL:
		return m.OldURL(ctx)
	}
	return nil, fmt.Errorf("unknown ProductImage field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductImageMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productimage.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case productimage.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case productimage.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	}
	return fmt.Errorf("unknown ProductImage field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductImageMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductImageMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductImageMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductImage numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductImageMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productimage.FieldExternalID) {
		fields = append(fields, productimage.FieldExternalID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductImageMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductImageMutation) ClearField(name string) error {
	switch name {
	case productimage.FieldExternalID:
		m.ClearExternalID()
		return nil
	}
	return fmt.Errorf("unknown ProductImage nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductImageMutation) ResetField(name string) error {
	switch name {
	case productimage.FieldTenantID:
		m.ResetTenantID()
		return nil
	case productimage.FieldExternalID:
		m.ResetExternalID()
		return nil
	case productimage.FieldURL:
		m.ResetURL()
		return nil
	}
	return fmt.Errorf("unknown ProductImage field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductImageMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, productimage.EdgeTenant)
	}
	if m.product != nil {
		edges = append(edges, productimage.EdgeProduct)
	}
	if m.product_variant != nil {
		edges = append(edges, productimage.EdgeProductVariant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductImageMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productimage.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case productimage.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case productimage.EdgeProductVariant:
		ids := make([]ent.Value, 0, len(m.product_variant))
		for id := range m.product_variant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductImageMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproduct_variant != nil {
		edges = append(edges, productimage.EdgeProductVariant)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductImageMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productimage.EdgeProductVariant:
		ids := make([]ent.Value, 0, len(m.removedproduct_variant))
		for id := range m.removedproduct_variant {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductImageMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, productimage.EdgeTenant)
	}
	if m.clearedproduct {
		edges = append(edges, productimage.EdgeProduct)
	}
	if m.clearedproduct_variant {
		edges = append(edges, productimage.EdgeProductVariant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductImageMutation) EdgeCleared(name string) bool {
	switch name {
	case productimage.EdgeTenant:
		return m.clearedtenant
	case productimage.EdgeProduct:
		return m.clearedproduct
	case productimage.EdgeProductVariant:
		return m.clearedproduct_variant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductImageMutation) ClearEdge(name string) error {
	switch name {
	case productimage.EdgeTenant:
		m.ClearTenant()
		return nil
	case productimage.EdgeProduct:
		m.ClearProduct()
		return nil
	}
	return fmt.Errorf("unknown ProductImage unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductImageMutation) ResetEdge(name string) error {
	switch name {
	case productimage.EdgeTenant:
		m.ResetTenant()
		return nil
	case productimage.EdgeProduct:
		m.ResetProduct()
		return nil
	case productimage.EdgeProductVariant:
		m.ResetProductVariant()
		return nil
	}
	return fmt.Errorf("unknown ProductImage edge %s", name)
}

// ProductTagMutation represents an operation that mutates the ProductTag nodes in the graph.
type ProductTagMutation struct {
	config
	op              Op
	typ             string
	id              *pulid.ID
	name            *string
	created_at      *time.Time
	clearedFields   map[string]struct{}
	tenant          *pulid.ID
	clearedtenant   bool
	products        map[pulid.ID]struct{}
	removedproducts map[pulid.ID]struct{}
	clearedproducts bool
	done            bool
	oldValue        func(context.Context) (*ProductTag, error)
	predicates      []predicate.ProductTag
}

var _ ent.Mutation = (*ProductTagMutation)(nil)

// producttagOption allows management of the mutation configuration using functional options.
type producttagOption func(*ProductTagMutation)

// newProductTagMutation creates new mutation for the ProductTag entity.
func newProductTagMutation(c config, op Op, opts ...producttagOption) *ProductTagMutation {
	m := &ProductTagMutation{
		config:        c,
		op:            op,
		typ:           TypeProductTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductTagID sets the ID field of the mutation.
func withProductTagID(id pulid.ID) producttagOption {
	return func(m *ProductTagMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductTag
		)
		m.oldValue = func(ctx context.Context) (*ProductTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductTag sets the old ProductTag of the mutation.
func withProductTag(node *ProductTag) producttagOption {
	return func(m *ProductTagMutation) {
		m.oldValue = func(context.Context) (*ProductTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductTag entities.
func (m *ProductTagMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductTagMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductTagMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ProductTagMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProductTagMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProductTag entity.
// If the ProductTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTagMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProductTagMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *ProductTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProductTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProductTag entity.
// If the ProductTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProductTagMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductTag entity.
// If the ProductTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductTagMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[producttag.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductTagMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[producttag.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductTagMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, producttag.FieldCreatedAt)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ProductTagMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[producttag.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ProductTagMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ProductTagMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ProductTagMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddProductIDs adds the "products" edge to the Product entity by ids.
func (m *ProductTagMutation) AddProductIDs(ids ...pulid.ID) {
	if m.products == nil {
		m.products = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.products[ids[i]] = struct{}{}
	}
}

// ClearProducts clears the "products" edge to the Product entity.
func (m *ProductTagMutation) ClearProducts() {
	m.clearedproducts = true
}

// ProductsCleared reports if the "products" edge to the Product entity was cleared.
func (m *ProductTagMutation) ProductsCleared() bool {
	return m.clearedproducts
}

// RemoveProductIDs removes the "products" edge to the Product entity by IDs.
func (m *ProductTagMutation) RemoveProductIDs(ids ...pulid.ID) {
	if m.removedproducts == nil {
		m.removedproducts = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.products, ids[i])
		m.removedproducts[ids[i]] = struct{}{}
	}
}

// RemovedProducts returns the removed IDs of the "products" edge to the Product entity.
func (m *ProductTagMutation) RemovedProductsIDs() (ids []pulid.ID) {
	for id := range m.removedproducts {
		ids = append(ids, id)
	}
	return
}

// ProductsIDs returns the "products" edge IDs in the mutation.
func (m *ProductTagMutation) ProductsIDs() (ids []pulid.ID) {
	for id := range m.products {
		ids = append(ids, id)
	}
	return
}

// ResetProducts resets all changes to the "products" edge.
func (m *ProductTagMutation) ResetProducts() {
	m.products = nil
	m.clearedproducts = false
	m.removedproducts = nil
}

// Where appends a list predicates to the ProductTagMutation builder.
func (m *ProductTagMutation) Where(ps ...predicate.ProductTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductTag).
func (m *ProductTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductTagMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, producttag.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, producttag.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, producttag.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case producttag.FieldTenantID:
		return m.TenantID()
	case producttag.FieldName:
		return m.Name()
	case producttag.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case producttag.FieldTenantID:
		return m.OldTenantID(ctx)
	case producttag.FieldName:
		return m.OldName(ctx)
	case producttag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProductTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case producttag.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case producttag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case producttag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProductTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProductTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(producttag.FieldCreatedAt) {
		fields = append(fields, producttag.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductTagMutation) ClearField(name string) error {
	switch name {
	case producttag.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProductTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductTagMutation) ResetField(name string) error {
	switch name {
	case producttag.FieldTenantID:
		m.ResetTenantID()
		return nil
	case producttag.FieldName:
		m.ResetName()
		return nil
	case producttag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProductTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, producttag.EdgeTenant)
	}
	if m.products != nil {
		edges = append(edges, producttag.EdgeProducts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case producttag.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case producttag.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.products))
		for id := range m.products {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedproducts != nil {
		edges = append(edges, producttag.EdgeProducts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case producttag.EdgeProducts:
		ids := make([]ent.Value, 0, len(m.removedproducts))
		for id := range m.removedproducts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, producttag.EdgeTenant)
	}
	if m.clearedproducts {
		edges = append(edges, producttag.EdgeProducts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductTagMutation) EdgeCleared(name string) bool {
	switch name {
	case producttag.EdgeTenant:
		return m.clearedtenant
	case producttag.EdgeProducts:
		return m.clearedproducts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductTagMutation) ClearEdge(name string) error {
	switch name {
	case producttag.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown ProductTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductTagMutation) ResetEdge(name string) error {
	switch name {
	case producttag.EdgeTenant:
		m.ResetTenant()
		return nil
	case producttag.EdgeProducts:
		m.ResetProducts()
		return nil
	}
	return fmt.Errorf("unknown ProductTag edge %s", name)
}

// ProductVariantMutation represents an operation that mutates the ProductVariant nodes in the graph.
type ProductVariantMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.ID
	archived              *bool
	external_ID           *string
	description           *string
	ean_number            *string
	weight_g              *int
	addweight_g           *int
	dimension_length      *int
	adddimension_length   *int
	dimension_width       *int
	adddimension_width    *int
	dimension_height      *int
	adddimension_height   *int
	created_at            *time.Time
	updated_at            *time.Time
	clearedFields         map[string]struct{}
	tenant                *pulid.ID
	clearedtenant         bool
	product               *pulid.ID
	clearedproduct        bool
	order_lines           map[pulid.ID]struct{}
	removedorder_lines    map[pulid.ID]struct{}
	clearedorder_lines    bool
	product_image         map[pulid.ID]struct{}
	removedproduct_image  map[pulid.ID]struct{}
	clearedproduct_image  bool
	inventory_item        *pulid.ID
	clearedinventory_item bool
	done                  bool
	oldValue              func(context.Context) (*ProductVariant, error)
	predicates            []predicate.ProductVariant
}

var _ ent.Mutation = (*ProductVariantMutation)(nil)

// productvariantOption allows management of the mutation configuration using functional options.
type productvariantOption func(*ProductVariantMutation)

// newProductVariantMutation creates new mutation for the ProductVariant entity.
func newProductVariantMutation(c config, op Op, opts ...productvariantOption) *ProductVariantMutation {
	m := &ProductVariantMutation{
		config:        c,
		op:            op,
		typ:           TypeProductVariant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProductVariantID sets the ID field of the mutation.
func withProductVariantID(id pulid.ID) productvariantOption {
	return func(m *ProductVariantMutation) {
		var (
			err   error
			once  sync.Once
			value *ProductVariant
		)
		m.oldValue = func(ctx context.Context) (*ProductVariant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProductVariant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProductVariant sets the old ProductVariant of the mutation.
func withProductVariant(node *ProductVariant) productvariantOption {
	return func(m *ProductVariantMutation) {
		m.oldValue = func(context.Context) (*ProductVariant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProductVariantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProductVariantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ProductVariant entities.
func (m *ProductVariantMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProductVariantMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ProductVariantMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ProductVariant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ProductVariantMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ProductVariantMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ProductVariantMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchived sets the "archived" field.
func (m *ProductVariantMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *ProductVariantMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *ProductVariantMutation) ResetArchived() {
	m.archived = nil
}

// SetExternalID sets the "external_ID" field.
func (m *ProductVariantMutation) SetExternalID(s string) {
	m.external_ID = &s
}

// ExternalID returns the value of the "external_ID" field in the mutation.
func (m *ProductVariantMutation) ExternalID() (r string, exists bool) {
	v := m.external_ID
	if v == nil {
		return
	}
	return *v, true
}

// OldExternalID returns the old "external_ID" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldExternalID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExternalID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExternalID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExternalID: %w", err)
	}
	return oldValue.ExternalID, nil
}

// ClearExternalID clears the value of the "external_ID" field.
func (m *ProductVariantMutation) ClearExternalID() {
	m.external_ID = nil
	m.clearedFields[productvariant.FieldExternalID] = struct{}{}
}

// ExternalIDCleared returns if the "external_ID" field was cleared in this mutation.
func (m *ProductVariantMutation) ExternalIDCleared() bool {
	_, ok := m.clearedFields[productvariant.FieldExternalID]
	return ok
}

// ResetExternalID resets all changes to the "external_ID" field.
func (m *ProductVariantMutation) ResetExternalID() {
	m.external_ID = nil
	delete(m.clearedFields, productvariant.FieldExternalID)
}

// SetDescription sets the "description" field.
func (m *ProductVariantMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ProductVariantMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *ProductVariantMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[productvariant.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *ProductVariantMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[productvariant.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *ProductVariantMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, productvariant.FieldDescription)
}

// SetEanNumber sets the "ean_number" field.
func (m *ProductVariantMutation) SetEanNumber(s string) {
	m.ean_number = &s
}

// EanNumber returns the value of the "ean_number" field in the mutation.
func (m *ProductVariantMutation) EanNumber() (r string, exists bool) {
	v := m.ean_number
	if v == nil {
		return
	}
	return *v, true
}

// OldEanNumber returns the old "ean_number" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldEanNumber(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEanNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEanNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEanNumber: %w", err)
	}
	return oldValue.EanNumber, nil
}

// ClearEanNumber clears the value of the "ean_number" field.
func (m *ProductVariantMutation) ClearEanNumber() {
	m.ean_number = nil
	m.clearedFields[productvariant.FieldEanNumber] = struct{}{}
}

// EanNumberCleared returns if the "ean_number" field was cleared in this mutation.
func (m *ProductVariantMutation) EanNumberCleared() bool {
	_, ok := m.clearedFields[productvariant.FieldEanNumber]
	return ok
}

// ResetEanNumber resets all changes to the "ean_number" field.
func (m *ProductVariantMutation) ResetEanNumber() {
	m.ean_number = nil
	delete(m.clearedFields, productvariant.FieldEanNumber)
}

// SetWeightG sets the "weight_g" field.
func (m *ProductVariantMutation) SetWeightG(i int) {
	m.weight_g = &i
	m.addweight_g = nil
}

// WeightG returns the value of the "weight_g" field in the mutation.
func (m *ProductVariantMutation) WeightG() (r int, exists bool) {
	v := m.weight_g
	if v == nil {
		return
	}
	return *v, true
}

// OldWeightG returns the old "weight_g" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldWeightG(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWeightG is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWeightG requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeightG: %w", err)
	}
	return oldValue.WeightG, nil
}

// AddWeightG adds i to the "weight_g" field.
func (m *ProductVariantMutation) AddWeightG(i int) {
	if m.addweight_g != nil {
		*m.addweight_g += i
	} else {
		m.addweight_g = &i
	}
}

// AddedWeightG returns the value that was added to the "weight_g" field in this mutation.
func (m *ProductVariantMutation) AddedWeightG() (r int, exists bool) {
	v := m.addweight_g
	if v == nil {
		return
	}
	return *v, true
}

// ClearWeightG clears the value of the "weight_g" field.
func (m *ProductVariantMutation) ClearWeightG() {
	m.weight_g = nil
	m.addweight_g = nil
	m.clearedFields[productvariant.FieldWeightG] = struct{}{}
}

// WeightGCleared returns if the "weight_g" field was cleared in this mutation.
func (m *ProductVariantMutation) WeightGCleared() bool {
	_, ok := m.clearedFields[productvariant.FieldWeightG]
	return ok
}

// ResetWeightG resets all changes to the "weight_g" field.
func (m *ProductVariantMutation) ResetWeightG() {
	m.weight_g = nil
	m.addweight_g = nil
	delete(m.clearedFields, productvariant.FieldWeightG)
}

// SetDimensionLength sets the "dimension_length" field.
func (m *ProductVariantMutation) SetDimensionLength(i int) {
	m.dimension_length = &i
	m.adddimension_length = nil
}

// DimensionLength returns the value of the "dimension_length" field in the mutation.
func (m *ProductVariantMutation) DimensionLength() (r int, exists bool) {
	v := m.dimension_length
	if v == nil {
		return
	}
	return *v, true
}

// OldDimensionLength returns the old "dimension_length" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldDimensionLength(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimensionLength is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimensionLength requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimensionLength: %w", err)
	}
	return oldValue.DimensionLength, nil
}

// AddDimensionLength adds i to the "dimension_length" field.
func (m *ProductVariantMutation) AddDimensionLength(i int) {
	if m.adddimension_length != nil {
		*m.adddimension_length += i
	} else {
		m.adddimension_length = &i
	}
}

// AddedDimensionLength returns the value that was added to the "dimension_length" field in this mutation.
func (m *ProductVariantMutation) AddedDimensionLength() (r int, exists bool) {
	v := m.adddimension_length
	if v == nil {
		return
	}
	return *v, true
}

// ClearDimensionLength clears the value of the "dimension_length" field.
func (m *ProductVariantMutation) ClearDimensionLength() {
	m.dimension_length = nil
	m.adddimension_length = nil
	m.clearedFields[productvariant.FieldDimensionLength] = struct{}{}
}

// DimensionLengthCleared returns if the "dimension_length" field was cleared in this mutation.
func (m *ProductVariantMutation) DimensionLengthCleared() bool {
	_, ok := m.clearedFields[productvariant.FieldDimensionLength]
	return ok
}

// ResetDimensionLength resets all changes to the "dimension_length" field.
func (m *ProductVariantMutation) ResetDimensionLength() {
	m.dimension_length = nil
	m.adddimension_length = nil
	delete(m.clearedFields, productvariant.FieldDimensionLength)
}

// SetDimensionWidth sets the "dimension_width" field.
func (m *ProductVariantMutation) SetDimensionWidth(i int) {
	m.dimension_width = &i
	m.adddimension_width = nil
}

// DimensionWidth returns the value of the "dimension_width" field in the mutation.
func (m *ProductVariantMutation) DimensionWidth() (r int, exists bool) {
	v := m.dimension_width
	if v == nil {
		return
	}
	return *v, true
}

// OldDimensionWidth returns the old "dimension_width" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldDimensionWidth(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimensionWidth is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimensionWidth requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimensionWidth: %w", err)
	}
	return oldValue.DimensionWidth, nil
}

// AddDimensionWidth adds i to the "dimension_width" field.
func (m *ProductVariantMutation) AddDimensionWidth(i int) {
	if m.adddimension_width != nil {
		*m.adddimension_width += i
	} else {
		m.adddimension_width = &i
	}
}

// AddedDimensionWidth returns the value that was added to the "dimension_width" field in this mutation.
func (m *ProductVariantMutation) AddedDimensionWidth() (r int, exists bool) {
	v := m.adddimension_width
	if v == nil {
		return
	}
	return *v, true
}

// ClearDimensionWidth clears the value of the "dimension_width" field.
func (m *ProductVariantMutation) ClearDimensionWidth() {
	m.dimension_width = nil
	m.adddimension_width = nil
	m.clearedFields[productvariant.FieldDimensionWidth] = struct{}{}
}

// DimensionWidthCleared returns if the "dimension_width" field was cleared in this mutation.
func (m *ProductVariantMutation) DimensionWidthCleared() bool {
	_, ok := m.clearedFields[productvariant.FieldDimensionWidth]
	return ok
}

// ResetDimensionWidth resets all changes to the "dimension_width" field.
func (m *ProductVariantMutation) ResetDimensionWidth() {
	m.dimension_width = nil
	m.adddimension_width = nil
	delete(m.clearedFields, productvariant.FieldDimensionWidth)
}

// SetDimensionHeight sets the "dimension_height" field.
func (m *ProductVariantMutation) SetDimensionHeight(i int) {
	m.dimension_height = &i
	m.adddimension_height = nil
}

// DimensionHeight returns the value of the "dimension_height" field in the mutation.
func (m *ProductVariantMutation) DimensionHeight() (r int, exists bool) {
	v := m.dimension_height
	if v == nil {
		return
	}
	return *v, true
}

// OldDimensionHeight returns the old "dimension_height" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldDimensionHeight(ctx context.Context) (v *int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDimensionHeight is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDimensionHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDimensionHeight: %w", err)
	}
	return oldValue.DimensionHeight, nil
}

// AddDimensionHeight adds i to the "dimension_height" field.
func (m *ProductVariantMutation) AddDimensionHeight(i int) {
	if m.adddimension_height != nil {
		*m.adddimension_height += i
	} else {
		m.adddimension_height = &i
	}
}

// AddedDimensionHeight returns the value that was added to the "dimension_height" field in this mutation.
func (m *ProductVariantMutation) AddedDimensionHeight() (r int, exists bool) {
	v := m.adddimension_height
	if v == nil {
		return
	}
	return *v, true
}

// ClearDimensionHeight clears the value of the "dimension_height" field.
func (m *ProductVariantMutation) ClearDimensionHeight() {
	m.dimension_height = nil
	m.adddimension_height = nil
	m.clearedFields[productvariant.FieldDimensionHeight] = struct{}{}
}

// DimensionHeightCleared returns if the "dimension_height" field was cleared in this mutation.
func (m *ProductVariantMutation) DimensionHeightCleared() bool {
	_, ok := m.clearedFields[productvariant.FieldDimensionHeight]
	return ok
}

// ResetDimensionHeight resets all changes to the "dimension_height" field.
func (m *ProductVariantMutation) ResetDimensionHeight() {
	m.dimension_height = nil
	m.adddimension_height = nil
	delete(m.clearedFields, productvariant.FieldDimensionHeight)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProductVariantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProductVariantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProductVariantMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[productvariant.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProductVariantMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[productvariant.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProductVariantMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, productvariant.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *ProductVariantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *ProductVariantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the ProductVariant entity.
// If the ProductVariant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProductVariantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *ProductVariantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ProductVariantMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[productvariant.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ProductVariantMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ProductVariantMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ProductVariantMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetProductID sets the "product" edge to the Product entity by id.
func (m *ProductVariantMutation) SetProductID(id pulid.ID) {
	m.product = &id
}

// ClearProduct clears the "product" edge to the Product entity.
func (m *ProductVariantMutation) ClearProduct() {
	m.clearedproduct = true
}

// ProductCleared reports if the "product" edge to the Product entity was cleared.
func (m *ProductVariantMutation) ProductCleared() bool {
	return m.clearedproduct
}

// ProductID returns the "product" edge ID in the mutation.
func (m *ProductVariantMutation) ProductID() (id pulid.ID, exists bool) {
	if m.product != nil {
		return *m.product, true
	}
	return
}

// ProductIDs returns the "product" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProductID instead. It exists only for internal usage by the builders.
func (m *ProductVariantMutation) ProductIDs() (ids []pulid.ID) {
	if id := m.product; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProduct resets all changes to the "product" edge.
func (m *ProductVariantMutation) ResetProduct() {
	m.product = nil
	m.clearedproduct = false
}

// AddOrderLineIDs adds the "order_lines" edge to the OrderLine entity by ids.
func (m *ProductVariantMutation) AddOrderLineIDs(ids ...pulid.ID) {
	if m.order_lines == nil {
		m.order_lines = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.order_lines[ids[i]] = struct{}{}
	}
}

// ClearOrderLines clears the "order_lines" edge to the OrderLine entity.
func (m *ProductVariantMutation) ClearOrderLines() {
	m.clearedorder_lines = true
}

// OrderLinesCleared reports if the "order_lines" edge to the OrderLine entity was cleared.
func (m *ProductVariantMutation) OrderLinesCleared() bool {
	return m.clearedorder_lines
}

// RemoveOrderLineIDs removes the "order_lines" edge to the OrderLine entity by IDs.
func (m *ProductVariantMutation) RemoveOrderLineIDs(ids ...pulid.ID) {
	if m.removedorder_lines == nil {
		m.removedorder_lines = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.order_lines, ids[i])
		m.removedorder_lines[ids[i]] = struct{}{}
	}
}

// RemovedOrderLines returns the removed IDs of the "order_lines" edge to the OrderLine entity.
func (m *ProductVariantMutation) RemovedOrderLinesIDs() (ids []pulid.ID) {
	for id := range m.removedorder_lines {
		ids = append(ids, id)
	}
	return
}

// OrderLinesIDs returns the "order_lines" edge IDs in the mutation.
func (m *ProductVariantMutation) OrderLinesIDs() (ids []pulid.ID) {
	for id := range m.order_lines {
		ids = append(ids, id)
	}
	return
}

// ResetOrderLines resets all changes to the "order_lines" edge.
func (m *ProductVariantMutation) ResetOrderLines() {
	m.order_lines = nil
	m.clearedorder_lines = false
	m.removedorder_lines = nil
}

// AddProductImageIDs adds the "product_image" edge to the ProductImage entity by ids.
func (m *ProductVariantMutation) AddProductImageIDs(ids ...pulid.ID) {
	if m.product_image == nil {
		m.product_image = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.product_image[ids[i]] = struct{}{}
	}
}

// ClearProductImage clears the "product_image" edge to the ProductImage entity.
func (m *ProductVariantMutation) ClearProductImage() {
	m.clearedproduct_image = true
}

// ProductImageCleared reports if the "product_image" edge to the ProductImage entity was cleared.
func (m *ProductVariantMutation) ProductImageCleared() bool {
	return m.clearedproduct_image
}

// RemoveProductImageIDs removes the "product_image" edge to the ProductImage entity by IDs.
func (m *ProductVariantMutation) RemoveProductImageIDs(ids ...pulid.ID) {
	if m.removedproduct_image == nil {
		m.removedproduct_image = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.product_image, ids[i])
		m.removedproduct_image[ids[i]] = struct{}{}
	}
}

// RemovedProductImage returns the removed IDs of the "product_image" edge to the ProductImage entity.
func (m *ProductVariantMutation) RemovedProductImageIDs() (ids []pulid.ID) {
	for id := range m.removedproduct_image {
		ids = append(ids, id)
	}
	return
}

// ProductImageIDs returns the "product_image" edge IDs in the mutation.
func (m *ProductVariantMutation) ProductImageIDs() (ids []pulid.ID) {
	for id := range m.product_image {
		ids = append(ids, id)
	}
	return
}

// ResetProductImage resets all changes to the "product_image" edge.
func (m *ProductVariantMutation) ResetProductImage() {
	m.product_image = nil
	m.clearedproduct_image = false
	m.removedproduct_image = nil
}

// SetInventoryItemID sets the "inventory_item" edge to the InventoryItem entity by id.
func (m *ProductVariantMutation) SetInventoryItemID(id pulid.ID) {
	m.inventory_item = &id
}

// ClearInventoryItem clears the "inventory_item" edge to the InventoryItem entity.
func (m *ProductVariantMutation) ClearInventoryItem() {
	m.clearedinventory_item = true
}

// InventoryItemCleared reports if the "inventory_item" edge to the InventoryItem entity was cleared.
func (m *ProductVariantMutation) InventoryItemCleared() bool {
	return m.clearedinventory_item
}

// InventoryItemID returns the "inventory_item" edge ID in the mutation.
func (m *ProductVariantMutation) InventoryItemID() (id pulid.ID, exists bool) {
	if m.inventory_item != nil {
		return *m.inventory_item, true
	}
	return
}

// InventoryItemIDs returns the "inventory_item" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// InventoryItemID instead. It exists only for internal usage by the builders.
func (m *ProductVariantMutation) InventoryItemIDs() (ids []pulid.ID) {
	if id := m.inventory_item; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetInventoryItem resets all changes to the "inventory_item" edge.
func (m *ProductVariantMutation) ResetInventoryItem() {
	m.inventory_item = nil
	m.clearedinventory_item = false
}

// Where appends a list predicates to the ProductVariantMutation builder.
func (m *ProductVariantMutation) Where(ps ...predicate.ProductVariant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ProductVariantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ProductVariantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ProductVariant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ProductVariantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ProductVariantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ProductVariant).
func (m *ProductVariantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProductVariantMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.tenant != nil {
		fields = append(fields, productvariant.FieldTenantID)
	}
	if m.archived != nil {
		fields = append(fields, productvariant.FieldArchived)
	}
	if m.external_ID != nil {
		fields = append(fields, productvariant.FieldExternalID)
	}
	if m.description != nil {
		fields = append(fields, productvariant.FieldDescription)
	}
	if m.ean_number != nil {
		fields = append(fields, productvariant.FieldEanNumber)
	}
	if m.weight_g != nil {
		fields = append(fields, productvariant.FieldWeightG)
	}
	if m.dimension_length != nil {
		fields = append(fields, productvariant.FieldDimensionLength)
	}
	if m.dimension_width != nil {
		fields = append(fields, productvariant.FieldDimensionWidth)
	}
	if m.dimension_height != nil {
		fields = append(fields, productvariant.FieldDimensionHeight)
	}
	if m.created_at != nil {
		fields = append(fields, productvariant.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, productvariant.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProductVariantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case productvariant.FieldTenantID:
		return m.TenantID()
	case productvariant.FieldArchived:
		return m.Archived()
	case productvariant.FieldExternalID:
		return m.ExternalID()
	case productvariant.FieldDescription:
		return m.Description()
	case productvariant.FieldEanNumber:
		return m.EanNumber()
	case productvariant.FieldWeightG:
		return m.WeightG()
	case productvariant.FieldDimensionLength:
		return m.DimensionLength()
	case productvariant.FieldDimensionWidth:
		return m.DimensionWidth()
	case productvariant.FieldDimensionHeight:
		return m.DimensionHeight()
	case productvariant.FieldCreatedAt:
		return m.CreatedAt()
	case productvariant.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProductVariantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case productvariant.FieldTenantID:
		return m.OldTenantID(ctx)
	case productvariant.FieldArchived:
		return m.OldArchived(ctx)
	case productvariant.FieldExternalID:
		return m.OldExternalID(ctx)
	case productvariant.FieldDescription:
		return m.OldDescription(ctx)
	case productvariant.FieldEanNumber:
		return m.OldEanNumber(ctx)
	case productvariant.FieldWeightG:
		return m.OldWeightG(ctx)
	case productvariant.FieldDimensionLength:
		return m.OldDimensionLength(ctx)
	case productvariant.FieldDimensionWidth:
		return m.OldDimensionWidth(ctx)
	case productvariant.FieldDimensionHeight:
		return m.OldDimensionHeight(ctx)
	case productvariant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case productvariant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProductVariant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductVariantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case productvariant.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case productvariant.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	case productvariant.FieldExternalID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExternalID(v)
		return nil
	case productvariant.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case productvariant.FieldEanNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEanNumber(v)
		return nil
	case productvariant.FieldWeightG:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeightG(v)
		return nil
	case productvariant.FieldDimensionLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimensionLength(v)
		return nil
	case productvariant.FieldDimensionWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimensionWidth(v)
		return nil
	case productvariant.FieldDimensionHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDimensionHeight(v)
		return nil
	case productvariant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case productvariant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProductVariant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProductVariantMutation) AddedFields() []string {
	var fields []string
	if m.addweight_g != nil {
		fields = append(fields, productvariant.FieldWeightG)
	}
	if m.adddimension_length != nil {
		fields = append(fields, productvariant.FieldDimensionLength)
	}
	if m.adddimension_width != nil {
		fields = append(fields, productvariant.FieldDimensionWidth)
	}
	if m.adddimension_height != nil {
		fields = append(fields, productvariant.FieldDimensionHeight)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProductVariantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case productvariant.FieldWeightG:
		return m.AddedWeightG()
	case productvariant.FieldDimensionLength:
		return m.AddedDimensionLength()
	case productvariant.FieldDimensionWidth:
		return m.AddedDimensionWidth()
	case productvariant.FieldDimensionHeight:
		return m.AddedDimensionHeight()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProductVariantMutation) AddField(name string, value ent.Value) error {
	switch name {
	case productvariant.FieldWeightG:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeightG(v)
		return nil
	case productvariant.FieldDimensionLength:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDimensionLength(v)
		return nil
	case productvariant.FieldDimensionWidth:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDimensionWidth(v)
		return nil
	case productvariant.FieldDimensionHeight:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDimensionHeight(v)
		return nil
	}
	return fmt.Errorf("unknown ProductVariant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProductVariantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(productvariant.FieldExternalID) {
		fields = append(fields, productvariant.FieldExternalID)
	}
	if m.FieldCleared(productvariant.FieldDescription) {
		fields = append(fields, productvariant.FieldDescription)
	}
	if m.FieldCleared(productvariant.FieldEanNumber) {
		fields = append(fields, productvariant.FieldEanNumber)
	}
	if m.FieldCleared(productvariant.FieldWeightG) {
		fields = append(fields, productvariant.FieldWeightG)
	}
	if m.FieldCleared(productvariant.FieldDimensionLength) {
		fields = append(fields, productvariant.FieldDimensionLength)
	}
	if m.FieldCleared(productvariant.FieldDimensionWidth) {
		fields = append(fields, productvariant.FieldDimensionWidth)
	}
	if m.FieldCleared(productvariant.FieldDimensionHeight) {
		fields = append(fields, productvariant.FieldDimensionHeight)
	}
	if m.FieldCleared(productvariant.FieldCreatedAt) {
		fields = append(fields, productvariant.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProductVariantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProductVariantMutation) ClearField(name string) error {
	switch name {
	case productvariant.FieldExternalID:
		m.ClearExternalID()
		return nil
	case productvariant.FieldDescription:
		m.ClearDescription()
		return nil
	case productvariant.FieldEanNumber:
		m.ClearEanNumber()
		return nil
	case productvariant.FieldWeightG:
		m.ClearWeightG()
		return nil
	case productvariant.FieldDimensionLength:
		m.ClearDimensionLength()
		return nil
	case productvariant.FieldDimensionWidth:
		m.ClearDimensionWidth()
		return nil
	case productvariant.FieldDimensionHeight:
		m.ClearDimensionHeight()
		return nil
	case productvariant.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProductVariant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProductVariantMutation) ResetField(name string) error {
	switch name {
	case productvariant.FieldTenantID:
		m.ResetTenantID()
		return nil
	case productvariant.FieldArchived:
		m.ResetArchived()
		return nil
	case productvariant.FieldExternalID:
		m.ResetExternalID()
		return nil
	case productvariant.FieldDescription:
		m.ResetDescription()
		return nil
	case productvariant.FieldEanNumber:
		m.ResetEanNumber()
		return nil
	case productvariant.FieldWeightG:
		m.ResetWeightG()
		return nil
	case productvariant.FieldDimensionLength:
		m.ResetDimensionLength()
		return nil
	case productvariant.FieldDimensionWidth:
		m.ResetDimensionWidth()
		return nil
	case productvariant.FieldDimensionHeight:
		m.ResetDimensionHeight()
		return nil
	case productvariant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case productvariant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProductVariant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProductVariantMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.tenant != nil {
		edges = append(edges, productvariant.EdgeTenant)
	}
	if m.product != nil {
		edges = append(edges, productvariant.EdgeProduct)
	}
	if m.order_lines != nil {
		edges = append(edges, productvariant.EdgeOrderLines)
	}
	if m.product_image != nil {
		edges = append(edges, productvariant.EdgeProductImage)
	}
	if m.inventory_item != nil {
		edges = append(edges, productvariant.EdgeInventoryItem)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProductVariantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case productvariant.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case productvariant.EdgeProduct:
		if id := m.product; id != nil {
			return []ent.Value{*id}
		}
	case productvariant.EdgeOrderLines:
		ids := make([]ent.Value, 0, len(m.order_lines))
		for id := range m.order_lines {
			ids = append(ids, id)
		}
		return ids
	case productvariant.EdgeProductImage:
		ids := make([]ent.Value, 0, len(m.product_image))
		for id := range m.product_image {
			ids = append(ids, id)
		}
		return ids
	case productvariant.EdgeInventoryItem:
		if id := m.inventory_item; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProductVariantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedorder_lines != nil {
		edges = append(edges, productvariant.EdgeOrderLines)
	}
	if m.removedproduct_image != nil {
		edges = append(edges, productvariant.EdgeProductImage)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProductVariantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case productvariant.EdgeOrderLines:
		ids := make([]ent.Value, 0, len(m.removedorder_lines))
		for id := range m.removedorder_lines {
			ids = append(ids, id)
		}
		return ids
	case productvariant.EdgeProductImage:
		ids := make([]ent.Value, 0, len(m.removedproduct_image))
		for id := range m.removedproduct_image {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProductVariantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedtenant {
		edges = append(edges, productvariant.EdgeTenant)
	}
	if m.clearedproduct {
		edges = append(edges, productvariant.EdgeProduct)
	}
	if m.clearedorder_lines {
		edges = append(edges, productvariant.EdgeOrderLines)
	}
	if m.clearedproduct_image {
		edges = append(edges, productvariant.EdgeProductImage)
	}
	if m.clearedinventory_item {
		edges = append(edges, productvariant.EdgeInventoryItem)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProductVariantMutation) EdgeCleared(name string) bool {
	switch name {
	case productvariant.EdgeTenant:
		return m.clearedtenant
	case productvariant.EdgeProduct:
		return m.clearedproduct
	case productvariant.EdgeOrderLines:
		return m.clearedorder_lines
	case productvariant.EdgeProductImage:
		return m.clearedproduct_image
	case productvariant.EdgeInventoryItem:
		return m.clearedinventory_item
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProductVariantMutation) ClearEdge(name string) error {
	switch name {
	case productvariant.EdgeTenant:
		m.ClearTenant()
		return nil
	case productvariant.EdgeProduct:
		m.ClearProduct()
		return nil
	case productvariant.EdgeInventoryItem:
		m.ClearInventoryItem()
		return nil
	}
	return fmt.Errorf("unknown ProductVariant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProductVariantMutation) ResetEdge(name string) error {
	switch name {
	case productvariant.EdgeTenant:
		m.ResetTenant()
		return nil
	case productvariant.EdgeProduct:
		m.ResetProduct()
		return nil
	case productvariant.EdgeOrderLines:
		m.ResetOrderLines()
		return nil
	case productvariant.EdgeProductImage:
		m.ResetProductImage()
		return nil
	case productvariant.EdgeInventoryItem:
		m.ResetInventoryItem()
		return nil
	}
	return fmt.Errorf("unknown ProductVariant edge %s", name)
}

// ReturnColliMutation represents an operation that mutates the ReturnColli nodes in the graph.
type ReturnColliMutation struct {
	config
	op                          Op
	typ                         string
	id                          *pulid.ID
	expected_at                 *time.Time
	label_pdf                   *string
	label_png                   *string
	qr_code_png                 *string
	comment                     *string
	created_at                  *time.Time
	status                      *returncolli.Status
	email_received              *time.Time
	email_accepted              *time.Time
	email_confirmation_label    *time.Time
	email_confirmation_qr_code  *time.Time
	clearedFields               map[string]struct{}
	tenant                      *pulid.ID
	clearedtenant               bool
	recipient                   *pulid.ID
	clearedrecipient            bool
	sender                      *pulid.ID
	clearedsender               bool
	_order                      *pulid.ID
	cleared_order               bool
	delivery_option             *pulid.ID
	cleareddelivery_option      bool
	return_portal               *pulid.ID
	clearedreturn_portal        bool
	packaging                   *pulid.ID
	clearedpackaging            bool
	return_order_line           map[pulid.ID]struct{}
	removedreturn_order_line    map[pulid.ID]struct{}
	clearedreturn_order_line    bool
	return_colli_history        map[pulid.ID]struct{}
	removedreturn_colli_history map[pulid.ID]struct{}
	clearedreturn_colli_history bool
	done                        bool
	oldValue                    func(context.Context) (*ReturnColli, error)
	predicates                  []predicate.ReturnColli
}

var _ ent.Mutation = (*ReturnColliMutation)(nil)

// returncolliOption allows management of the mutation configuration using functional options.
type returncolliOption func(*ReturnColliMutation)

// newReturnColliMutation creates new mutation for the ReturnColli entity.
func newReturnColliMutation(c config, op Op, opts ...returncolliOption) *ReturnColliMutation {
	m := &ReturnColliMutation{
		config:        c,
		op:            op,
		typ:           TypeReturnColli,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReturnColliID sets the ID field of the mutation.
func withReturnColliID(id pulid.ID) returncolliOption {
	return func(m *ReturnColliMutation) {
		var (
			err   error
			once  sync.Once
			value *ReturnColli
		)
		m.oldValue = func(ctx context.Context) (*ReturnColli, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReturnColli.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReturnColli sets the old ReturnColli of the mutation.
func withReturnColli(node *ReturnColli) returncolliOption {
	return func(m *ReturnColliMutation) {
		m.oldValue = func(context.Context) (*ReturnColli, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReturnColliMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReturnColliMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReturnColli entities.
func (m *ReturnColliMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReturnColliMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReturnColliMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReturnColli.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ReturnColliMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ReturnColliMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ReturnColliMutation) ResetTenantID() {
	m.tenant = nil
}

// SetExpectedAt sets the "expected_at" field.
func (m *ReturnColliMutation) SetExpectedAt(t time.Time) {
	m.expected_at = &t
}

// ExpectedAt returns the value of the "expected_at" field in the mutation.
func (m *ReturnColliMutation) ExpectedAt() (r time.Time, exists bool) {
	v := m.expected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedAt returns the old "expected_at" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldExpectedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedAt: %w", err)
	}
	return oldValue.ExpectedAt, nil
}

// ClearExpectedAt clears the value of the "expected_at" field.
func (m *ReturnColliMutation) ClearExpectedAt() {
	m.expected_at = nil
	m.clearedFields[returncolli.FieldExpectedAt] = struct{}{}
}

// ExpectedAtCleared returns if the "expected_at" field was cleared in this mutation.
func (m *ReturnColliMutation) ExpectedAtCleared() bool {
	_, ok := m.clearedFields[returncolli.FieldExpectedAt]
	return ok
}

// ResetExpectedAt resets all changes to the "expected_at" field.
func (m *ReturnColliMutation) ResetExpectedAt() {
	m.expected_at = nil
	delete(m.clearedFields, returncolli.FieldExpectedAt)
}

// SetLabelPdf sets the "label_pdf" field.
func (m *ReturnColliMutation) SetLabelPdf(s string) {
	m.label_pdf = &s
}

// LabelPdf returns the value of the "label_pdf" field in the mutation.
func (m *ReturnColliMutation) LabelPdf() (r string, exists bool) {
	v := m.label_pdf
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelPdf returns the old "label_pdf" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldLabelPdf(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelPdf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelPdf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelPdf: %w", err)
	}
	return oldValue.LabelPdf, nil
}

// ClearLabelPdf clears the value of the "label_pdf" field.
func (m *ReturnColliMutation) ClearLabelPdf() {
	m.label_pdf = nil
	m.clearedFields[returncolli.FieldLabelPdf] = struct{}{}
}

// LabelPdfCleared returns if the "label_pdf" field was cleared in this mutation.
func (m *ReturnColliMutation) LabelPdfCleared() bool {
	_, ok := m.clearedFields[returncolli.FieldLabelPdf]
	return ok
}

// ResetLabelPdf resets all changes to the "label_pdf" field.
func (m *ReturnColliMutation) ResetLabelPdf() {
	m.label_pdf = nil
	delete(m.clearedFields, returncolli.FieldLabelPdf)
}

// SetLabelPng sets the "label_png" field.
func (m *ReturnColliMutation) SetLabelPng(s string) {
	m.label_png = &s
}

// LabelPng returns the value of the "label_png" field in the mutation.
func (m *ReturnColliMutation) LabelPng() (r string, exists bool) {
	v := m.label_png
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelPng returns the old "label_png" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldLabelPng(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelPng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelPng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelPng: %w", err)
	}
	return oldValue.LabelPng, nil
}

// ClearLabelPng clears the value of the "label_png" field.
func (m *ReturnColliMutation) ClearLabelPng() {
	m.label_png = nil
	m.clearedFields[returncolli.FieldLabelPng] = struct{}{}
}

// LabelPngCleared returns if the "label_png" field was cleared in this mutation.
func (m *ReturnColliMutation) LabelPngCleared() bool {
	_, ok := m.clearedFields[returncolli.FieldLabelPng]
	return ok
}

// ResetLabelPng resets all changes to the "label_png" field.
func (m *ReturnColliMutation) ResetLabelPng() {
	m.label_png = nil
	delete(m.clearedFields, returncolli.FieldLabelPng)
}

// SetQrCodePng sets the "qr_code_png" field.
func (m *ReturnColliMutation) SetQrCodePng(s string) {
	m.qr_code_png = &s
}

// QrCodePng returns the value of the "qr_code_png" field in the mutation.
func (m *ReturnColliMutation) QrCodePng() (r string, exists bool) {
	v := m.qr_code_png
	if v == nil {
		return
	}
	return *v, true
}

// OldQrCodePng returns the old "qr_code_png" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldQrCodePng(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldQrCodePng is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldQrCodePng requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQrCodePng: %w", err)
	}
	return oldValue.QrCodePng, nil
}

// ClearQrCodePng clears the value of the "qr_code_png" field.
func (m *ReturnColliMutation) ClearQrCodePng() {
	m.qr_code_png = nil
	m.clearedFields[returncolli.FieldQrCodePng] = struct{}{}
}

// QrCodePngCleared returns if the "qr_code_png" field was cleared in this mutation.
func (m *ReturnColliMutation) QrCodePngCleared() bool {
	_, ok := m.clearedFields[returncolli.FieldQrCodePng]
	return ok
}

// ResetQrCodePng resets all changes to the "qr_code_png" field.
func (m *ReturnColliMutation) ResetQrCodePng() {
	m.qr_code_png = nil
	delete(m.clearedFields, returncolli.FieldQrCodePng)
}

// SetComment sets the "comment" field.
func (m *ReturnColliMutation) SetComment(s string) {
	m.comment = &s
}

// Comment returns the value of the "comment" field in the mutation.
func (m *ReturnColliMutation) Comment() (r string, exists bool) {
	v := m.comment
	if v == nil {
		return
	}
	return *v, true
}

// OldComment returns the old "comment" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldComment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldComment is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldComment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldComment: %w", err)
	}
	return oldValue.Comment, nil
}

// ClearComment clears the value of the "comment" field.
func (m *ReturnColliMutation) ClearComment() {
	m.comment = nil
	m.clearedFields[returncolli.FieldComment] = struct{}{}
}

// CommentCleared returns if the "comment" field was cleared in this mutation.
func (m *ReturnColliMutation) CommentCleared() bool {
	_, ok := m.clearedFields[returncolli.FieldComment]
	return ok
}

// ResetComment resets all changes to the "comment" field.
func (m *ReturnColliMutation) ResetComment() {
	m.comment = nil
	delete(m.clearedFields, returncolli.FieldComment)
}

// SetCreatedAt sets the "created_at" field.
func (m *ReturnColliMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ReturnColliMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ReturnColliMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStatus sets the "status" field.
func (m *ReturnColliMutation) SetStatus(r returncolli.Status) {
	m.status = &r
}

// Status returns the value of the "status" field in the mutation.
func (m *ReturnColliMutation) Status() (r returncolli.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldStatus(ctx context.Context) (v returncolli.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ReturnColliMutation) ResetStatus() {
	m.status = nil
}

// SetEmailReceived sets the "email_received" field.
func (m *ReturnColliMutation) SetEmailReceived(t time.Time) {
	m.email_received = &t
}

// EmailReceived returns the value of the "email_received" field in the mutation.
func (m *ReturnColliMutation) EmailReceived() (r time.Time, exists bool) {
	v := m.email_received
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailReceived returns the old "email_received" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldEmailReceived(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailReceived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailReceived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailReceived: %w", err)
	}
	return oldValue.EmailReceived, nil
}

// ClearEmailReceived clears the value of the "email_received" field.
func (m *ReturnColliMutation) ClearEmailReceived() {
	m.email_received = nil
	m.clearedFields[returncolli.FieldEmailReceived] = struct{}{}
}

// EmailReceivedCleared returns if the "email_received" field was cleared in this mutation.
func (m *ReturnColliMutation) EmailReceivedCleared() bool {
	_, ok := m.clearedFields[returncolli.FieldEmailReceived]
	return ok
}

// ResetEmailReceived resets all changes to the "email_received" field.
func (m *ReturnColliMutation) ResetEmailReceived() {
	m.email_received = nil
	delete(m.clearedFields, returncolli.FieldEmailReceived)
}

// SetEmailAccepted sets the "email_accepted" field.
func (m *ReturnColliMutation) SetEmailAccepted(t time.Time) {
	m.email_accepted = &t
}

// EmailAccepted returns the value of the "email_accepted" field in the mutation.
func (m *ReturnColliMutation) EmailAccepted() (r time.Time, exists bool) {
	v := m.email_accepted
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailAccepted returns the old "email_accepted" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldEmailAccepted(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailAccepted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailAccepted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailAccepted: %w", err)
	}
	return oldValue.EmailAccepted, nil
}

// ClearEmailAccepted clears the value of the "email_accepted" field.
func (m *ReturnColliMutation) ClearEmailAccepted() {
	m.email_accepted = nil
	m.clearedFields[returncolli.FieldEmailAccepted] = struct{}{}
}

// EmailAcceptedCleared returns if the "email_accepted" field was cleared in this mutation.
func (m *ReturnColliMutation) EmailAcceptedCleared() bool {
	_, ok := m.clearedFields[returncolli.FieldEmailAccepted]
	return ok
}

// ResetEmailAccepted resets all changes to the "email_accepted" field.
func (m *ReturnColliMutation) ResetEmailAccepted() {
	m.email_accepted = nil
	delete(m.clearedFields, returncolli.FieldEmailAccepted)
}

// SetEmailConfirmationLabel sets the "email_confirmation_label" field.
func (m *ReturnColliMutation) SetEmailConfirmationLabel(t time.Time) {
	m.email_confirmation_label = &t
}

// EmailConfirmationLabel returns the value of the "email_confirmation_label" field in the mutation.
func (m *ReturnColliMutation) EmailConfirmationLabel() (r time.Time, exists bool) {
	v := m.email_confirmation_label
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailConfirmationLabel returns the old "email_confirmation_label" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldEmailConfirmationLabel(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailConfirmationLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailConfirmationLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailConfirmationLabel: %w", err)
	}
	return oldValue.EmailConfirmationLabel, nil
}

// ClearEmailConfirmationLabel clears the value of the "email_confirmation_label" field.
func (m *ReturnColliMutation) ClearEmailConfirmationLabel() {
	m.email_confirmation_label = nil
	m.clearedFields[returncolli.FieldEmailConfirmationLabel] = struct{}{}
}

// EmailConfirmationLabelCleared returns if the "email_confirmation_label" field was cleared in this mutation.
func (m *ReturnColliMutation) EmailConfirmationLabelCleared() bool {
	_, ok := m.clearedFields[returncolli.FieldEmailConfirmationLabel]
	return ok
}

// ResetEmailConfirmationLabel resets all changes to the "email_confirmation_label" field.
func (m *ReturnColliMutation) ResetEmailConfirmationLabel() {
	m.email_confirmation_label = nil
	delete(m.clearedFields, returncolli.FieldEmailConfirmationLabel)
}

// SetEmailConfirmationQrCode sets the "email_confirmation_qr_code" field.
func (m *ReturnColliMutation) SetEmailConfirmationQrCode(t time.Time) {
	m.email_confirmation_qr_code = &t
}

// EmailConfirmationQrCode returns the value of the "email_confirmation_qr_code" field in the mutation.
func (m *ReturnColliMutation) EmailConfirmationQrCode() (r time.Time, exists bool) {
	v := m.email_confirmation_qr_code
	if v == nil {
		return
	}
	return *v, true
}

// OldEmailConfirmationQrCode returns the old "email_confirmation_qr_code" field's value of the ReturnColli entity.
// If the ReturnColli object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliMutation) OldEmailConfirmationQrCode(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmailConfirmationQrCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmailConfirmationQrCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmailConfirmationQrCode: %w", err)
	}
	return oldValue.EmailConfirmationQrCode, nil
}

// ClearEmailConfirmationQrCode clears the value of the "email_confirmation_qr_code" field.
func (m *ReturnColliMutation) ClearEmailConfirmationQrCode() {
	m.email_confirmation_qr_code = nil
	m.clearedFields[returncolli.FieldEmailConfirmationQrCode] = struct{}{}
}

// EmailConfirmationQrCodeCleared returns if the "email_confirmation_qr_code" field was cleared in this mutation.
func (m *ReturnColliMutation) EmailConfirmationQrCodeCleared() bool {
	_, ok := m.clearedFields[returncolli.FieldEmailConfirmationQrCode]
	return ok
}

// ResetEmailConfirmationQrCode resets all changes to the "email_confirmation_qr_code" field.
func (m *ReturnColliMutation) ResetEmailConfirmationQrCode() {
	m.email_confirmation_qr_code = nil
	delete(m.clearedFields, returncolli.FieldEmailConfirmationQrCode)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ReturnColliMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[returncolli.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ReturnColliMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ReturnColliMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ReturnColliMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetRecipientID sets the "recipient" edge to the Address entity by id.
func (m *ReturnColliMutation) SetRecipientID(id pulid.ID) {
	m.recipient = &id
}

// ClearRecipient clears the "recipient" edge to the Address entity.
func (m *ReturnColliMutation) ClearRecipient() {
	m.clearedrecipient = true
}

// RecipientCleared reports if the "recipient" edge to the Address entity was cleared.
func (m *ReturnColliMutation) RecipientCleared() bool {
	return m.clearedrecipient
}

// RecipientID returns the "recipient" edge ID in the mutation.
func (m *ReturnColliMutation) RecipientID() (id pulid.ID, exists bool) {
	if m.recipient != nil {
		return *m.recipient, true
	}
	return
}

// RecipientIDs returns the "recipient" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// RecipientID instead. It exists only for internal usage by the builders.
func (m *ReturnColliMutation) RecipientIDs() (ids []pulid.ID) {
	if id := m.recipient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRecipient resets all changes to the "recipient" edge.
func (m *ReturnColliMutation) ResetRecipient() {
	m.recipient = nil
	m.clearedrecipient = false
}

// SetSenderID sets the "sender" edge to the Address entity by id.
func (m *ReturnColliMutation) SetSenderID(id pulid.ID) {
	m.sender = &id
}

// ClearSender clears the "sender" edge to the Address entity.
func (m *ReturnColliMutation) ClearSender() {
	m.clearedsender = true
}

// SenderCleared reports if the "sender" edge to the Address entity was cleared.
func (m *ReturnColliMutation) SenderCleared() bool {
	return m.clearedsender
}

// SenderID returns the "sender" edge ID in the mutation.
func (m *ReturnColliMutation) SenderID() (id pulid.ID, exists bool) {
	if m.sender != nil {
		return *m.sender, true
	}
	return
}

// SenderIDs returns the "sender" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SenderID instead. It exists only for internal usage by the builders.
func (m *ReturnColliMutation) SenderIDs() (ids []pulid.ID) {
	if id := m.sender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSender resets all changes to the "sender" edge.
func (m *ReturnColliMutation) ResetSender() {
	m.sender = nil
	m.clearedsender = false
}

// SetOrderID sets the "order" edge to the Order entity by id.
func (m *ReturnColliMutation) SetOrderID(id pulid.ID) {
	m._order = &id
}

// ClearOrder clears the "order" edge to the Order entity.
func (m *ReturnColliMutation) ClearOrder() {
	m.cleared_order = true
}

// OrderCleared reports if the "order" edge to the Order entity was cleared.
func (m *ReturnColliMutation) OrderCleared() bool {
	return m.cleared_order
}

// OrderID returns the "order" edge ID in the mutation.
func (m *ReturnColliMutation) OrderID() (id pulid.ID, exists bool) {
	if m._order != nil {
		return *m._order, true
	}
	return
}

// OrderIDs returns the "order" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderID instead. It exists only for internal usage by the builders.
func (m *ReturnColliMutation) OrderIDs() (ids []pulid.ID) {
	if id := m._order; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrder resets all changes to the "order" edge.
func (m *ReturnColliMutation) ResetOrder() {
	m._order = nil
	m.cleared_order = false
}

// SetDeliveryOptionID sets the "delivery_option" edge to the DeliveryOption entity by id.
func (m *ReturnColliMutation) SetDeliveryOptionID(id pulid.ID) {
	m.delivery_option = &id
}

// ClearDeliveryOption clears the "delivery_option" edge to the DeliveryOption entity.
func (m *ReturnColliMutation) ClearDeliveryOption() {
	m.cleareddelivery_option = true
}

// DeliveryOptionCleared reports if the "delivery_option" edge to the DeliveryOption entity was cleared.
func (m *ReturnColliMutation) DeliveryOptionCleared() bool {
	return m.cleareddelivery_option
}

// DeliveryOptionID returns the "delivery_option" edge ID in the mutation.
func (m *ReturnColliMutation) DeliveryOptionID() (id pulid.ID, exists bool) {
	if m.delivery_option != nil {
		return *m.delivery_option, true
	}
	return
}

// DeliveryOptionIDs returns the "delivery_option" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeliveryOptionID instead. It exists only for internal usage by the builders.
func (m *ReturnColliMutation) DeliveryOptionIDs() (ids []pulid.ID) {
	if id := m.delivery_option; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeliveryOption resets all changes to the "delivery_option" edge.
func (m *ReturnColliMutation) ResetDeliveryOption() {
	m.delivery_option = nil
	m.cleareddelivery_option = false
}

// SetReturnPortalID sets the "return_portal" edge to the ReturnPortal entity by id.
func (m *ReturnColliMutation) SetReturnPortalID(id pulid.ID) {
	m.return_portal = &id
}

// ClearReturnPortal clears the "return_portal" edge to the ReturnPortal entity.
func (m *ReturnColliMutation) ClearReturnPortal() {
	m.clearedreturn_portal = true
}

// ReturnPortalCleared reports if the "return_portal" edge to the ReturnPortal entity was cleared.
func (m *ReturnColliMutation) ReturnPortalCleared() bool {
	return m.clearedreturn_portal
}

// ReturnPortalID returns the "return_portal" edge ID in the mutation.
func (m *ReturnColliMutation) ReturnPortalID() (id pulid.ID, exists bool) {
	if m.return_portal != nil {
		return *m.return_portal, true
	}
	return
}

// ReturnPortalIDs returns the "return_portal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReturnPortalID instead. It exists only for internal usage by the builders.
func (m *ReturnColliMutation) ReturnPortalIDs() (ids []pulid.ID) {
	if id := m.return_portal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReturnPortal resets all changes to the "return_portal" edge.
func (m *ReturnColliMutation) ResetReturnPortal() {
	m.return_portal = nil
	m.clearedreturn_portal = false
}

// SetPackagingID sets the "packaging" edge to the Packaging entity by id.
func (m *ReturnColliMutation) SetPackagingID(id pulid.ID) {
	m.packaging = &id
}

// ClearPackaging clears the "packaging" edge to the Packaging entity.
func (m *ReturnColliMutation) ClearPackaging() {
	m.clearedpackaging = true
}

// PackagingCleared reports if the "packaging" edge to the Packaging entity was cleared.
func (m *ReturnColliMutation) PackagingCleared() bool {
	return m.clearedpackaging
}

// PackagingID returns the "packaging" edge ID in the mutation.
func (m *ReturnColliMutation) PackagingID() (id pulid.ID, exists bool) {
	if m.packaging != nil {
		return *m.packaging, true
	}
	return
}

// PackagingIDs returns the "packaging" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackagingID instead. It exists only for internal usage by the builders.
func (m *ReturnColliMutation) PackagingIDs() (ids []pulid.ID) {
	if id := m.packaging; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackaging resets all changes to the "packaging" edge.
func (m *ReturnColliMutation) ResetPackaging() {
	m.packaging = nil
	m.clearedpackaging = false
}

// AddReturnOrderLineIDs adds the "return_order_line" edge to the ReturnOrderLine entity by ids.
func (m *ReturnColliMutation) AddReturnOrderLineIDs(ids ...pulid.ID) {
	if m.return_order_line == nil {
		m.return_order_line = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_order_line[ids[i]] = struct{}{}
	}
}

// ClearReturnOrderLine clears the "return_order_line" edge to the ReturnOrderLine entity.
func (m *ReturnColliMutation) ClearReturnOrderLine() {
	m.clearedreturn_order_line = true
}

// ReturnOrderLineCleared reports if the "return_order_line" edge to the ReturnOrderLine entity was cleared.
func (m *ReturnColliMutation) ReturnOrderLineCleared() bool {
	return m.clearedreturn_order_line
}

// RemoveReturnOrderLineIDs removes the "return_order_line" edge to the ReturnOrderLine entity by IDs.
func (m *ReturnColliMutation) RemoveReturnOrderLineIDs(ids ...pulid.ID) {
	if m.removedreturn_order_line == nil {
		m.removedreturn_order_line = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_order_line, ids[i])
		m.removedreturn_order_line[ids[i]] = struct{}{}
	}
}

// RemovedReturnOrderLine returns the removed IDs of the "return_order_line" edge to the ReturnOrderLine entity.
func (m *ReturnColliMutation) RemovedReturnOrderLineIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_order_line {
		ids = append(ids, id)
	}
	return
}

// ReturnOrderLineIDs returns the "return_order_line" edge IDs in the mutation.
func (m *ReturnColliMutation) ReturnOrderLineIDs() (ids []pulid.ID) {
	for id := range m.return_order_line {
		ids = append(ids, id)
	}
	return
}

// ResetReturnOrderLine resets all changes to the "return_order_line" edge.
func (m *ReturnColliMutation) ResetReturnOrderLine() {
	m.return_order_line = nil
	m.clearedreturn_order_line = false
	m.removedreturn_order_line = nil
}

// AddReturnColliHistoryIDs adds the "return_colli_history" edge to the ReturnColliHistory entity by ids.
func (m *ReturnColliMutation) AddReturnColliHistoryIDs(ids ...pulid.ID) {
	if m.return_colli_history == nil {
		m.return_colli_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_colli_history[ids[i]] = struct{}{}
	}
}

// ClearReturnColliHistory clears the "return_colli_history" edge to the ReturnColliHistory entity.
func (m *ReturnColliMutation) ClearReturnColliHistory() {
	m.clearedreturn_colli_history = true
}

// ReturnColliHistoryCleared reports if the "return_colli_history" edge to the ReturnColliHistory entity was cleared.
func (m *ReturnColliMutation) ReturnColliHistoryCleared() bool {
	return m.clearedreturn_colli_history
}

// RemoveReturnColliHistoryIDs removes the "return_colli_history" edge to the ReturnColliHistory entity by IDs.
func (m *ReturnColliMutation) RemoveReturnColliHistoryIDs(ids ...pulid.ID) {
	if m.removedreturn_colli_history == nil {
		m.removedreturn_colli_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_colli_history, ids[i])
		m.removedreturn_colli_history[ids[i]] = struct{}{}
	}
}

// RemovedReturnColliHistory returns the removed IDs of the "return_colli_history" edge to the ReturnColliHistory entity.
func (m *ReturnColliMutation) RemovedReturnColliHistoryIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_colli_history {
		ids = append(ids, id)
	}
	return
}

// ReturnColliHistoryIDs returns the "return_colli_history" edge IDs in the mutation.
func (m *ReturnColliMutation) ReturnColliHistoryIDs() (ids []pulid.ID) {
	for id := range m.return_colli_history {
		ids = append(ids, id)
	}
	return
}

// ResetReturnColliHistory resets all changes to the "return_colli_history" edge.
func (m *ReturnColliMutation) ResetReturnColliHistory() {
	m.return_colli_history = nil
	m.clearedreturn_colli_history = false
	m.removedreturn_colli_history = nil
}

// Where appends a list predicates to the ReturnColliMutation builder.
func (m *ReturnColliMutation) Where(ps ...predicate.ReturnColli) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReturnColliMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReturnColliMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReturnColli, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReturnColliMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReturnColliMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReturnColli).
func (m *ReturnColliMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReturnColliMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.tenant != nil {
		fields = append(fields, returncolli.FieldTenantID)
	}
	if m.expected_at != nil {
		fields = append(fields, returncolli.FieldExpectedAt)
	}
	if m.label_pdf != nil {
		fields = append(fields, returncolli.FieldLabelPdf)
	}
	if m.label_png != nil {
		fields = append(fields, returncolli.FieldLabelPng)
	}
	if m.qr_code_png != nil {
		fields = append(fields, returncolli.FieldQrCodePng)
	}
	if m.comment != nil {
		fields = append(fields, returncolli.FieldComment)
	}
	if m.created_at != nil {
		fields = append(fields, returncolli.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, returncolli.FieldStatus)
	}
	if m.email_received != nil {
		fields = append(fields, returncolli.FieldEmailReceived)
	}
	if m.email_accepted != nil {
		fields = append(fields, returncolli.FieldEmailAccepted)
	}
	if m.email_confirmation_label != nil {
		fields = append(fields, returncolli.FieldEmailConfirmationLabel)
	}
	if m.email_confirmation_qr_code != nil {
		fields = append(fields, returncolli.FieldEmailConfirmationQrCode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReturnColliMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case returncolli.FieldTenantID:
		return m.TenantID()
	case returncolli.FieldExpectedAt:
		return m.ExpectedAt()
	case returncolli.FieldLabelPdf:
		return m.LabelPdf()
	case returncolli.FieldLabelPng:
		return m.LabelPng()
	case returncolli.FieldQrCodePng:
		return m.QrCodePng()
	case returncolli.FieldComment:
		return m.Comment()
	case returncolli.FieldCreatedAt:
		return m.CreatedAt()
	case returncolli.FieldStatus:
		return m.Status()
	case returncolli.FieldEmailReceived:
		return m.EmailReceived()
	case returncolli.FieldEmailAccepted:
		return m.EmailAccepted()
	case returncolli.FieldEmailConfirmationLabel:
		return m.EmailConfirmationLabel()
	case returncolli.FieldEmailConfirmationQrCode:
		return m.EmailConfirmationQrCode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReturnColliMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case returncolli.FieldTenantID:
		return m.OldTenantID(ctx)
	case returncolli.FieldExpectedAt:
		return m.OldExpectedAt(ctx)
	case returncolli.FieldLabelPdf:
		return m.OldLabelPdf(ctx)
	case returncolli.FieldLabelPng:
		return m.OldLabelPng(ctx)
	case returncolli.FieldQrCodePng:
		return m.OldQrCodePng(ctx)
	case returncolli.FieldComment:
		return m.OldComment(ctx)
	case returncolli.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case returncolli.FieldStatus:
		return m.OldStatus(ctx)
	case returncolli.FieldEmailReceived:
		return m.OldEmailReceived(ctx)
	case returncolli.FieldEmailAccepted:
		return m.OldEmailAccepted(ctx)
	case returncolli.FieldEmailConfirmationLabel:
		return m.OldEmailConfirmationLabel(ctx)
	case returncolli.FieldEmailConfirmationQrCode:
		return m.OldEmailConfirmationQrCode(ctx)
	}
	return nil, fmt.Errorf("unknown ReturnColli field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReturnColliMutation) SetField(name string, value ent.Value) error {
	switch name {
	case returncolli.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case returncolli.FieldExpectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedAt(v)
		return nil
	case returncolli.FieldLabelPdf:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelPdf(v)
		return nil
	case returncolli.FieldLabelPng:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelPng(v)
		return nil
	case returncolli.FieldQrCodePng:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQrCodePng(v)
		return nil
	case returncolli.FieldComment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetComment(v)
		return nil
	case returncolli.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case returncolli.FieldStatus:
		v, ok := value.(returncolli.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case returncolli.FieldEmailReceived:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailReceived(v)
		return nil
	case returncolli.FieldEmailAccepted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailAccepted(v)
		return nil
	case returncolli.FieldEmailConfirmationLabel:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailConfirmationLabel(v)
		return nil
	case returncolli.FieldEmailConfirmationQrCode:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmailConfirmationQrCode(v)
		return nil
	}
	return fmt.Errorf("unknown ReturnColli field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReturnColliMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReturnColliMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReturnColliMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReturnColli numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReturnColliMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(returncolli.FieldExpectedAt) {
		fields = append(fields, returncolli.FieldExpectedAt)
	}
	if m.FieldCleared(returncolli.FieldLabelPdf) {
		fields = append(fields, returncolli.FieldLabelPdf)
	}
	if m.FieldCleared(returncolli.FieldLabelPng) {
		fields = append(fields, returncolli.FieldLabelPng)
	}
	if m.FieldCleared(returncolli.FieldQrCodePng) {
		fields = append(fields, returncolli.FieldQrCodePng)
	}
	if m.FieldCleared(returncolli.FieldComment) {
		fields = append(fields, returncolli.FieldComment)
	}
	if m.FieldCleared(returncolli.FieldEmailReceived) {
		fields = append(fields, returncolli.FieldEmailReceived)
	}
	if m.FieldCleared(returncolli.FieldEmailAccepted) {
		fields = append(fields, returncolli.FieldEmailAccepted)
	}
	if m.FieldCleared(returncolli.FieldEmailConfirmationLabel) {
		fields = append(fields, returncolli.FieldEmailConfirmationLabel)
	}
	if m.FieldCleared(returncolli.FieldEmailConfirmationQrCode) {
		fields = append(fields, returncolli.FieldEmailConfirmationQrCode)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReturnColliMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReturnColliMutation) ClearField(name string) error {
	switch name {
	case returncolli.FieldExpectedAt:
		m.ClearExpectedAt()
		return nil
	case returncolli.FieldLabelPdf:
		m.ClearLabelPdf()
		return nil
	case returncolli.FieldLabelPng:
		m.ClearLabelPng()
		return nil
	case returncolli.FieldQrCodePng:
		m.ClearQrCodePng()
		return nil
	case returncolli.FieldComment:
		m.ClearComment()
		return nil
	case returncolli.FieldEmailReceived:
		m.ClearEmailReceived()
		return nil
	case returncolli.FieldEmailAccepted:
		m.ClearEmailAccepted()
		return nil
	case returncolli.FieldEmailConfirmationLabel:
		m.ClearEmailConfirmationLabel()
		return nil
	case returncolli.FieldEmailConfirmationQrCode:
		m.ClearEmailConfirmationQrCode()
		return nil
	}
	return fmt.Errorf("unknown ReturnColli nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReturnColliMutation) ResetField(name string) error {
	switch name {
	case returncolli.FieldTenantID:
		m.ResetTenantID()
		return nil
	case returncolli.FieldExpectedAt:
		m.ResetExpectedAt()
		return nil
	case returncolli.FieldLabelPdf:
		m.ResetLabelPdf()
		return nil
	case returncolli.FieldLabelPng:
		m.ResetLabelPng()
		return nil
	case returncolli.FieldQrCodePng:
		m.ResetQrCodePng()
		return nil
	case returncolli.FieldComment:
		m.ResetComment()
		return nil
	case returncolli.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case returncolli.FieldStatus:
		m.ResetStatus()
		return nil
	case returncolli.FieldEmailReceived:
		m.ResetEmailReceived()
		return nil
	case returncolli.FieldEmailAccepted:
		m.ResetEmailAccepted()
		return nil
	case returncolli.FieldEmailConfirmationLabel:
		m.ResetEmailConfirmationLabel()
		return nil
	case returncolli.FieldEmailConfirmationQrCode:
		m.ResetEmailConfirmationQrCode()
		return nil
	}
	return fmt.Errorf("unknown ReturnColli field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReturnColliMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.tenant != nil {
		edges = append(edges, returncolli.EdgeTenant)
	}
	if m.recipient != nil {
		edges = append(edges, returncolli.EdgeRecipient)
	}
	if m.sender != nil {
		edges = append(edges, returncolli.EdgeSender)
	}
	if m._order != nil {
		edges = append(edges, returncolli.EdgeOrder)
	}
	if m.delivery_option != nil {
		edges = append(edges, returncolli.EdgeDeliveryOption)
	}
	if m.return_portal != nil {
		edges = append(edges, returncolli.EdgeReturnPortal)
	}
	if m.packaging != nil {
		edges = append(edges, returncolli.EdgePackaging)
	}
	if m.return_order_line != nil {
		edges = append(edges, returncolli.EdgeReturnOrderLine)
	}
	if m.return_colli_history != nil {
		edges = append(edges, returncolli.EdgeReturnColliHistory)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReturnColliMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case returncolli.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case returncolli.EdgeRecipient:
		if id := m.recipient; id != nil {
			return []ent.Value{*id}
		}
	case returncolli.EdgeSender:
		if id := m.sender; id != nil {
			return []ent.Value{*id}
		}
	case returncolli.EdgeOrder:
		if id := m._order; id != nil {
			return []ent.Value{*id}
		}
	case returncolli.EdgeDeliveryOption:
		if id := m.delivery_option; id != nil {
			return []ent.Value{*id}
		}
	case returncolli.EdgeReturnPortal:
		if id := m.return_portal; id != nil {
			return []ent.Value{*id}
		}
	case returncolli.EdgePackaging:
		if id := m.packaging; id != nil {
			return []ent.Value{*id}
		}
	case returncolli.EdgeReturnOrderLine:
		ids := make([]ent.Value, 0, len(m.return_order_line))
		for id := range m.return_order_line {
			ids = append(ids, id)
		}
		return ids
	case returncolli.EdgeReturnColliHistory:
		ids := make([]ent.Value, 0, len(m.return_colli_history))
		for id := range m.return_colli_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReturnColliMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedreturn_order_line != nil {
		edges = append(edges, returncolli.EdgeReturnOrderLine)
	}
	if m.removedreturn_colli_history != nil {
		edges = append(edges, returncolli.EdgeReturnColliHistory)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReturnColliMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case returncolli.EdgeReturnOrderLine:
		ids := make([]ent.Value, 0, len(m.removedreturn_order_line))
		for id := range m.removedreturn_order_line {
			ids = append(ids, id)
		}
		return ids
	case returncolli.EdgeReturnColliHistory:
		ids := make([]ent.Value, 0, len(m.removedreturn_colli_history))
		for id := range m.removedreturn_colli_history {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReturnColliMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.clearedtenant {
		edges = append(edges, returncolli.EdgeTenant)
	}
	if m.clearedrecipient {
		edges = append(edges, returncolli.EdgeRecipient)
	}
	if m.clearedsender {
		edges = append(edges, returncolli.EdgeSender)
	}
	if m.cleared_order {
		edges = append(edges, returncolli.EdgeOrder)
	}
	if m.cleareddelivery_option {
		edges = append(edges, returncolli.EdgeDeliveryOption)
	}
	if m.clearedreturn_portal {
		edges = append(edges, returncolli.EdgeReturnPortal)
	}
	if m.clearedpackaging {
		edges = append(edges, returncolli.EdgePackaging)
	}
	if m.clearedreturn_order_line {
		edges = append(edges, returncolli.EdgeReturnOrderLine)
	}
	if m.clearedreturn_colli_history {
		edges = append(edges, returncolli.EdgeReturnColliHistory)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReturnColliMutation) EdgeCleared(name string) bool {
	switch name {
	case returncolli.EdgeTenant:
		return m.clearedtenant
	case returncolli.EdgeRecipient:
		return m.clearedrecipient
	case returncolli.EdgeSender:
		return m.clearedsender
	case returncolli.EdgeOrder:
		return m.cleared_order
	case returncolli.EdgeDeliveryOption:
		return m.cleareddelivery_option
	case returncolli.EdgeReturnPortal:
		return m.clearedreturn_portal
	case returncolli.EdgePackaging:
		return m.clearedpackaging
	case returncolli.EdgeReturnOrderLine:
		return m.clearedreturn_order_line
	case returncolli.EdgeReturnColliHistory:
		return m.clearedreturn_colli_history
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReturnColliMutation) ClearEdge(name string) error {
	switch name {
	case returncolli.EdgeTenant:
		m.ClearTenant()
		return nil
	case returncolli.EdgeRecipient:
		m.ClearRecipient()
		return nil
	case returncolli.EdgeSender:
		m.ClearSender()
		return nil
	case returncolli.EdgeOrder:
		m.ClearOrder()
		return nil
	case returncolli.EdgeDeliveryOption:
		m.ClearDeliveryOption()
		return nil
	case returncolli.EdgeReturnPortal:
		m.ClearReturnPortal()
		return nil
	case returncolli.EdgePackaging:
		m.ClearPackaging()
		return nil
	}
	return fmt.Errorf("unknown ReturnColli unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReturnColliMutation) ResetEdge(name string) error {
	switch name {
	case returncolli.EdgeTenant:
		m.ResetTenant()
		return nil
	case returncolli.EdgeRecipient:
		m.ResetRecipient()
		return nil
	case returncolli.EdgeSender:
		m.ResetSender()
		return nil
	case returncolli.EdgeOrder:
		m.ResetOrder()
		return nil
	case returncolli.EdgeDeliveryOption:
		m.ResetDeliveryOption()
		return nil
	case returncolli.EdgeReturnPortal:
		m.ResetReturnPortal()
		return nil
	case returncolli.EdgePackaging:
		m.ResetPackaging()
		return nil
	case returncolli.EdgeReturnOrderLine:
		m.ResetReturnOrderLine()
		return nil
	case returncolli.EdgeReturnColliHistory:
		m.ResetReturnColliHistory()
		return nil
	}
	return fmt.Errorf("unknown ReturnColli edge %s", name)
}

// ReturnColliHistoryMutation represents an operation that mutates the ReturnColliHistory nodes in the graph.
type ReturnColliHistoryMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.ID
	description           *string
	_type                 *returncollihistory.Type
	clearedFields         map[string]struct{}
	change_history        *pulid.ID
	clearedchange_history bool
	tenant                *pulid.ID
	clearedtenant         bool
	return_colli          *pulid.ID
	clearedreturn_colli   bool
	done                  bool
	oldValue              func(context.Context) (*ReturnColliHistory, error)
	predicates            []predicate.ReturnColliHistory
}

var _ ent.Mutation = (*ReturnColliHistoryMutation)(nil)

// returncollihistoryOption allows management of the mutation configuration using functional options.
type returncollihistoryOption func(*ReturnColliHistoryMutation)

// newReturnColliHistoryMutation creates new mutation for the ReturnColliHistory entity.
func newReturnColliHistoryMutation(c config, op Op, opts ...returncollihistoryOption) *ReturnColliHistoryMutation {
	m := &ReturnColliHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeReturnColliHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReturnColliHistoryID sets the ID field of the mutation.
func withReturnColliHistoryID(id pulid.ID) returncollihistoryOption {
	return func(m *ReturnColliHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ReturnColliHistory
		)
		m.oldValue = func(ctx context.Context) (*ReturnColliHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReturnColliHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReturnColliHistory sets the old ReturnColliHistory of the mutation.
func withReturnColliHistory(node *ReturnColliHistory) returncollihistoryOption {
	return func(m *ReturnColliHistoryMutation) {
		m.oldValue = func(context.Context) (*ReturnColliHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReturnColliHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReturnColliHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReturnColliHistory entities.
func (m *ReturnColliHistoryMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReturnColliHistoryMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReturnColliHistoryMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReturnColliHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ReturnColliHistoryMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ReturnColliHistoryMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ReturnColliHistory entity.
// If the ReturnColliHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliHistoryMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ReturnColliHistoryMutation) ResetTenantID() {
	m.tenant = nil
}

// SetDescription sets the "description" field.
func (m *ReturnColliHistoryMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ReturnColliHistoryMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ReturnColliHistory entity.
// If the ReturnColliHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliHistoryMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ReturnColliHistoryMutation) ResetDescription() {
	m.description = nil
}

// SetType sets the "type" field.
func (m *ReturnColliHistoryMutation) SetType(r returncollihistory.Type) {
	m._type = &r
}

// GetType returns the value of the "type" field in the mutation.
func (m *ReturnColliHistoryMutation) GetType() (r returncollihistory.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ReturnColliHistory entity.
// If the ReturnColliHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnColliHistoryMutation) OldType(ctx context.Context) (v returncollihistory.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ReturnColliHistoryMutation) ResetType() {
	m._type = nil
}

// SetChangeHistoryID sets the "change_history" edge to the ChangeHistory entity by id.
func (m *ReturnColliHistoryMutation) SetChangeHistoryID(id pulid.ID) {
	m.change_history = &id
}

// ClearChangeHistory clears the "change_history" edge to the ChangeHistory entity.
func (m *ReturnColliHistoryMutation) ClearChangeHistory() {
	m.clearedchange_history = true
}

// ChangeHistoryCleared reports if the "change_history" edge to the ChangeHistory entity was cleared.
func (m *ReturnColliHistoryMutation) ChangeHistoryCleared() bool {
	return m.clearedchange_history
}

// ChangeHistoryID returns the "change_history" edge ID in the mutation.
func (m *ReturnColliHistoryMutation) ChangeHistoryID() (id pulid.ID, exists bool) {
	if m.change_history != nil {
		return *m.change_history, true
	}
	return
}

// ChangeHistoryIDs returns the "change_history" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChangeHistoryID instead. It exists only for internal usage by the builders.
func (m *ReturnColliHistoryMutation) ChangeHistoryIDs() (ids []pulid.ID) {
	if id := m.change_history; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChangeHistory resets all changes to the "change_history" edge.
func (m *ReturnColliHistoryMutation) ResetChangeHistory() {
	m.change_history = nil
	m.clearedchange_history = false
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ReturnColliHistoryMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[returncollihistory.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ReturnColliHistoryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ReturnColliHistoryMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ReturnColliHistoryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetReturnColliID sets the "return_colli" edge to the ReturnColli entity by id.
func (m *ReturnColliHistoryMutation) SetReturnColliID(id pulid.ID) {
	m.return_colli = &id
}

// ClearReturnColli clears the "return_colli" edge to the ReturnColli entity.
func (m *ReturnColliHistoryMutation) ClearReturnColli() {
	m.clearedreturn_colli = true
}

// ReturnColliCleared reports if the "return_colli" edge to the ReturnColli entity was cleared.
func (m *ReturnColliHistoryMutation) ReturnColliCleared() bool {
	return m.clearedreturn_colli
}

// ReturnColliID returns the "return_colli" edge ID in the mutation.
func (m *ReturnColliHistoryMutation) ReturnColliID() (id pulid.ID, exists bool) {
	if m.return_colli != nil {
		return *m.return_colli, true
	}
	return
}

// ReturnColliIDs returns the "return_colli" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReturnColliID instead. It exists only for internal usage by the builders.
func (m *ReturnColliHistoryMutation) ReturnColliIDs() (ids []pulid.ID) {
	if id := m.return_colli; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReturnColli resets all changes to the "return_colli" edge.
func (m *ReturnColliHistoryMutation) ResetReturnColli() {
	m.return_colli = nil
	m.clearedreturn_colli = false
}

// Where appends a list predicates to the ReturnColliHistoryMutation builder.
func (m *ReturnColliHistoryMutation) Where(ps ...predicate.ReturnColliHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReturnColliHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReturnColliHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReturnColliHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReturnColliHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReturnColliHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReturnColliHistory).
func (m *ReturnColliHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReturnColliHistoryMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, returncollihistory.FieldTenantID)
	}
	if m.description != nil {
		fields = append(fields, returncollihistory.FieldDescription)
	}
	if m._type != nil {
		fields = append(fields, returncollihistory.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReturnColliHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case returncollihistory.FieldTenantID:
		return m.TenantID()
	case returncollihistory.FieldDescription:
		return m.Description()
	case returncollihistory.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReturnColliHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case returncollihistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case returncollihistory.FieldDescription:
		return m.OldDescription(ctx)
	case returncollihistory.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ReturnColliHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReturnColliHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case returncollihistory.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case returncollihistory.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case returncollihistory.FieldType:
		v, ok := value.(returncollihistory.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ReturnColliHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReturnColliHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReturnColliHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReturnColliHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReturnColliHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReturnColliHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReturnColliHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReturnColliHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReturnColliHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReturnColliHistoryMutation) ResetField(name string) error {
	switch name {
	case returncollihistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case returncollihistory.FieldDescription:
		m.ResetDescription()
		return nil
	case returncollihistory.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ReturnColliHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReturnColliHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.change_history != nil {
		edges = append(edges, returncollihistory.EdgeChangeHistory)
	}
	if m.tenant != nil {
		edges = append(edges, returncollihistory.EdgeTenant)
	}
	if m.return_colli != nil {
		edges = append(edges, returncollihistory.EdgeReturnColli)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReturnColliHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case returncollihistory.EdgeChangeHistory:
		if id := m.change_history; id != nil {
			return []ent.Value{*id}
		}
	case returncollihistory.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case returncollihistory.EdgeReturnColli:
		if id := m.return_colli; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReturnColliHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReturnColliHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReturnColliHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchange_history {
		edges = append(edges, returncollihistory.EdgeChangeHistory)
	}
	if m.clearedtenant {
		edges = append(edges, returncollihistory.EdgeTenant)
	}
	if m.clearedreturn_colli {
		edges = append(edges, returncollihistory.EdgeReturnColli)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReturnColliHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case returncollihistory.EdgeChangeHistory:
		return m.clearedchange_history
	case returncollihistory.EdgeTenant:
		return m.clearedtenant
	case returncollihistory.EdgeReturnColli:
		return m.clearedreturn_colli
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReturnColliHistoryMutation) ClearEdge(name string) error {
	switch name {
	case returncollihistory.EdgeChangeHistory:
		m.ClearChangeHistory()
		return nil
	case returncollihistory.EdgeTenant:
		m.ClearTenant()
		return nil
	case returncollihistory.EdgeReturnColli:
		m.ClearReturnColli()
		return nil
	}
	return fmt.Errorf("unknown ReturnColliHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReturnColliHistoryMutation) ResetEdge(name string) error {
	switch name {
	case returncollihistory.EdgeChangeHistory:
		m.ResetChangeHistory()
		return nil
	case returncollihistory.EdgeTenant:
		m.ResetTenant()
		return nil
	case returncollihistory.EdgeReturnColli:
		m.ResetReturnColli()
		return nil
	}
	return fmt.Errorf("unknown ReturnColliHistory edge %s", name)
}

// ReturnOrderLineMutation represents an operation that mutates the ReturnOrderLine nodes in the graph.
type ReturnOrderLineMutation struct {
	config
	op                         Op
	typ                        string
	id                         *pulid.ID
	units                      *int
	addunits                   *int
	clearedFields              map[string]struct{}
	tenant                     *pulid.ID
	clearedtenant              bool
	return_colli               *pulid.ID
	clearedreturn_colli        bool
	order_line                 *pulid.ID
	clearedorder_line          bool
	return_portal_claim        *pulid.ID
	clearedreturn_portal_claim bool
	done                       bool
	oldValue                   func(context.Context) (*ReturnOrderLine, error)
	predicates                 []predicate.ReturnOrderLine
}

var _ ent.Mutation = (*ReturnOrderLineMutation)(nil)

// returnorderlineOption allows management of the mutation configuration using functional options.
type returnorderlineOption func(*ReturnOrderLineMutation)

// newReturnOrderLineMutation creates new mutation for the ReturnOrderLine entity.
func newReturnOrderLineMutation(c config, op Op, opts ...returnorderlineOption) *ReturnOrderLineMutation {
	m := &ReturnOrderLineMutation{
		config:        c,
		op:            op,
		typ:           TypeReturnOrderLine,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReturnOrderLineID sets the ID field of the mutation.
func withReturnOrderLineID(id pulid.ID) returnorderlineOption {
	return func(m *ReturnOrderLineMutation) {
		var (
			err   error
			once  sync.Once
			value *ReturnOrderLine
		)
		m.oldValue = func(ctx context.Context) (*ReturnOrderLine, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReturnOrderLine.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReturnOrderLine sets the old ReturnOrderLine of the mutation.
func withReturnOrderLine(node *ReturnOrderLine) returnorderlineOption {
	return func(m *ReturnOrderLineMutation) {
		m.oldValue = func(context.Context) (*ReturnOrderLine, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReturnOrderLineMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReturnOrderLineMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReturnOrderLine entities.
func (m *ReturnOrderLineMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReturnOrderLineMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReturnOrderLineMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReturnOrderLine.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ReturnOrderLineMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ReturnOrderLineMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ReturnOrderLine entity.
// If the ReturnOrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnOrderLineMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ReturnOrderLineMutation) ResetTenantID() {
	m.tenant = nil
}

// SetUnits sets the "units" field.
func (m *ReturnOrderLineMutation) SetUnits(i int) {
	m.units = &i
	m.addunits = nil
}

// Units returns the value of the "units" field in the mutation.
func (m *ReturnOrderLineMutation) Units() (r int, exists bool) {
	v := m.units
	if v == nil {
		return
	}
	return *v, true
}

// OldUnits returns the old "units" field's value of the ReturnOrderLine entity.
// If the ReturnOrderLine object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnOrderLineMutation) OldUnits(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnits is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnits requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnits: %w", err)
	}
	return oldValue.Units, nil
}

// AddUnits adds i to the "units" field.
func (m *ReturnOrderLineMutation) AddUnits(i int) {
	if m.addunits != nil {
		*m.addunits += i
	} else {
		m.addunits = &i
	}
}

// AddedUnits returns the value that was added to the "units" field in this mutation.
func (m *ReturnOrderLineMutation) AddedUnits() (r int, exists bool) {
	v := m.addunits
	if v == nil {
		return
	}
	return *v, true
}

// ResetUnits resets all changes to the "units" field.
func (m *ReturnOrderLineMutation) ResetUnits() {
	m.units = nil
	m.addunits = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ReturnOrderLineMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[returnorderline.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ReturnOrderLineMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ReturnOrderLineMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ReturnOrderLineMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetReturnColliID sets the "return_colli" edge to the ReturnColli entity by id.
func (m *ReturnOrderLineMutation) SetReturnColliID(id pulid.ID) {
	m.return_colli = &id
}

// ClearReturnColli clears the "return_colli" edge to the ReturnColli entity.
func (m *ReturnOrderLineMutation) ClearReturnColli() {
	m.clearedreturn_colli = true
}

// ReturnColliCleared reports if the "return_colli" edge to the ReturnColli entity was cleared.
func (m *ReturnOrderLineMutation) ReturnColliCleared() bool {
	return m.clearedreturn_colli
}

// ReturnColliID returns the "return_colli" edge ID in the mutation.
func (m *ReturnOrderLineMutation) ReturnColliID() (id pulid.ID, exists bool) {
	if m.return_colli != nil {
		return *m.return_colli, true
	}
	return
}

// ReturnColliIDs returns the "return_colli" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReturnColliID instead. It exists only for internal usage by the builders.
func (m *ReturnOrderLineMutation) ReturnColliIDs() (ids []pulid.ID) {
	if id := m.return_colli; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReturnColli resets all changes to the "return_colli" edge.
func (m *ReturnOrderLineMutation) ResetReturnColli() {
	m.return_colli = nil
	m.clearedreturn_colli = false
}

// SetOrderLineID sets the "order_line" edge to the OrderLine entity by id.
func (m *ReturnOrderLineMutation) SetOrderLineID(id pulid.ID) {
	m.order_line = &id
}

// ClearOrderLine clears the "order_line" edge to the OrderLine entity.
func (m *ReturnOrderLineMutation) ClearOrderLine() {
	m.clearedorder_line = true
}

// OrderLineCleared reports if the "order_line" edge to the OrderLine entity was cleared.
func (m *ReturnOrderLineMutation) OrderLineCleared() bool {
	return m.clearedorder_line
}

// OrderLineID returns the "order_line" edge ID in the mutation.
func (m *ReturnOrderLineMutation) OrderLineID() (id pulid.ID, exists bool) {
	if m.order_line != nil {
		return *m.order_line, true
	}
	return
}

// OrderLineIDs returns the "order_line" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OrderLineID instead. It exists only for internal usage by the builders.
func (m *ReturnOrderLineMutation) OrderLineIDs() (ids []pulid.ID) {
	if id := m.order_line; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOrderLine resets all changes to the "order_line" edge.
func (m *ReturnOrderLineMutation) ResetOrderLine() {
	m.order_line = nil
	m.clearedorder_line = false
}

// SetReturnPortalClaimID sets the "return_portal_claim" edge to the ReturnPortalClaim entity by id.
func (m *ReturnOrderLineMutation) SetReturnPortalClaimID(id pulid.ID) {
	m.return_portal_claim = &id
}

// ClearReturnPortalClaim clears the "return_portal_claim" edge to the ReturnPortalClaim entity.
func (m *ReturnOrderLineMutation) ClearReturnPortalClaim() {
	m.clearedreturn_portal_claim = true
}

// ReturnPortalClaimCleared reports if the "return_portal_claim" edge to the ReturnPortalClaim entity was cleared.
func (m *ReturnOrderLineMutation) ReturnPortalClaimCleared() bool {
	return m.clearedreturn_portal_claim
}

// ReturnPortalClaimID returns the "return_portal_claim" edge ID in the mutation.
func (m *ReturnOrderLineMutation) ReturnPortalClaimID() (id pulid.ID, exists bool) {
	if m.return_portal_claim != nil {
		return *m.return_portal_claim, true
	}
	return
}

// ReturnPortalClaimIDs returns the "return_portal_claim" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReturnPortalClaimID instead. It exists only for internal usage by the builders.
func (m *ReturnOrderLineMutation) ReturnPortalClaimIDs() (ids []pulid.ID) {
	if id := m.return_portal_claim; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReturnPortalClaim resets all changes to the "return_portal_claim" edge.
func (m *ReturnOrderLineMutation) ResetReturnPortalClaim() {
	m.return_portal_claim = nil
	m.clearedreturn_portal_claim = false
}

// Where appends a list predicates to the ReturnOrderLineMutation builder.
func (m *ReturnOrderLineMutation) Where(ps ...predicate.ReturnOrderLine) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReturnOrderLineMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReturnOrderLineMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReturnOrderLine, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReturnOrderLineMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReturnOrderLineMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReturnOrderLine).
func (m *ReturnOrderLineMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReturnOrderLineMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, returnorderline.FieldTenantID)
	}
	if m.units != nil {
		fields = append(fields, returnorderline.FieldUnits)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReturnOrderLineMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case returnorderline.FieldTenantID:
		return m.TenantID()
	case returnorderline.FieldUnits:
		return m.Units()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReturnOrderLineMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case returnorderline.FieldTenantID:
		return m.OldTenantID(ctx)
	case returnorderline.FieldUnits:
		return m.OldUnits(ctx)
	}
	return nil, fmt.Errorf("unknown ReturnOrderLine field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReturnOrderLineMutation) SetField(name string, value ent.Value) error {
	switch name {
	case returnorderline.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case returnorderline.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnits(v)
		return nil
	}
	return fmt.Errorf("unknown ReturnOrderLine field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReturnOrderLineMutation) AddedFields() []string {
	var fields []string
	if m.addunits != nil {
		fields = append(fields, returnorderline.FieldUnits)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReturnOrderLineMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case returnorderline.FieldUnits:
		return m.AddedUnits()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReturnOrderLineMutation) AddField(name string, value ent.Value) error {
	switch name {
	case returnorderline.FieldUnits:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUnits(v)
		return nil
	}
	return fmt.Errorf("unknown ReturnOrderLine numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReturnOrderLineMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReturnOrderLineMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReturnOrderLineMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReturnOrderLine nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReturnOrderLineMutation) ResetField(name string) error {
	switch name {
	case returnorderline.FieldTenantID:
		m.ResetTenantID()
		return nil
	case returnorderline.FieldUnits:
		m.ResetUnits()
		return nil
	}
	return fmt.Errorf("unknown ReturnOrderLine field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReturnOrderLineMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, returnorderline.EdgeTenant)
	}
	if m.return_colli != nil {
		edges = append(edges, returnorderline.EdgeReturnColli)
	}
	if m.order_line != nil {
		edges = append(edges, returnorderline.EdgeOrderLine)
	}
	if m.return_portal_claim != nil {
		edges = append(edges, returnorderline.EdgeReturnPortalClaim)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReturnOrderLineMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case returnorderline.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case returnorderline.EdgeReturnColli:
		if id := m.return_colli; id != nil {
			return []ent.Value{*id}
		}
	case returnorderline.EdgeOrderLine:
		if id := m.order_line; id != nil {
			return []ent.Value{*id}
		}
	case returnorderline.EdgeReturnPortalClaim:
		if id := m.return_portal_claim; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReturnOrderLineMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReturnOrderLineMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReturnOrderLineMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, returnorderline.EdgeTenant)
	}
	if m.clearedreturn_colli {
		edges = append(edges, returnorderline.EdgeReturnColli)
	}
	if m.clearedorder_line {
		edges = append(edges, returnorderline.EdgeOrderLine)
	}
	if m.clearedreturn_portal_claim {
		edges = append(edges, returnorderline.EdgeReturnPortalClaim)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReturnOrderLineMutation) EdgeCleared(name string) bool {
	switch name {
	case returnorderline.EdgeTenant:
		return m.clearedtenant
	case returnorderline.EdgeReturnColli:
		return m.clearedreturn_colli
	case returnorderline.EdgeOrderLine:
		return m.clearedorder_line
	case returnorderline.EdgeReturnPortalClaim:
		return m.clearedreturn_portal_claim
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReturnOrderLineMutation) ClearEdge(name string) error {
	switch name {
	case returnorderline.EdgeTenant:
		m.ClearTenant()
		return nil
	case returnorderline.EdgeReturnColli:
		m.ClearReturnColli()
		return nil
	case returnorderline.EdgeOrderLine:
		m.ClearOrderLine()
		return nil
	case returnorderline.EdgeReturnPortalClaim:
		m.ClearReturnPortalClaim()
		return nil
	}
	return fmt.Errorf("unknown ReturnOrderLine unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReturnOrderLineMutation) ResetEdge(name string) error {
	switch name {
	case returnorderline.EdgeTenant:
		m.ResetTenant()
		return nil
	case returnorderline.EdgeReturnColli:
		m.ResetReturnColli()
		return nil
	case returnorderline.EdgeOrderLine:
		m.ResetOrderLine()
		return nil
	case returnorderline.EdgeReturnPortalClaim:
		m.ResetReturnPortalClaim()
		return nil
	}
	return fmt.Errorf("unknown ReturnOrderLine edge %s", name)
}

// ReturnPortalMutation represents an operation that mutates the ReturnPortal nodes in the graph.
type ReturnPortalMutation struct {
	config
	op                                Op
	typ                               string
	id                                *pulid.ID
	name                              *string
	return_open_hours                 *int
	addreturn_open_hours              *int
	automatically_accept              *bool
	clearedFields                     map[string]struct{}
	tenant                            *pulid.ID
	clearedtenant                     bool
	return_portal_claim               map[pulid.ID]struct{}
	removedreturn_portal_claim        map[pulid.ID]struct{}
	clearedreturn_portal_claim        bool
	return_location                   map[pulid.ID]struct{}
	removedreturn_location            map[pulid.ID]struct{}
	clearedreturn_location            bool
	delivery_options                  map[pulid.ID]struct{}
	removeddelivery_options           map[pulid.ID]struct{}
	cleareddelivery_options           bool
	connection                        *pulid.ID
	clearedconnection                 bool
	email_confirmation_label          *pulid.ID
	clearedemail_confirmation_label   bool
	email_confirmation_qr_code        *pulid.ID
	clearedemail_confirmation_qr_code bool
	email_received                    *pulid.ID
	clearedemail_received             bool
	email_accepted                    *pulid.ID
	clearedemail_accepted             bool
	return_colli                      map[pulid.ID]struct{}
	removedreturn_colli               map[pulid.ID]struct{}
	clearedreturn_colli               bool
	done                              bool
	oldValue                          func(context.Context) (*ReturnPortal, error)
	predicates                        []predicate.ReturnPortal
}

var _ ent.Mutation = (*ReturnPortalMutation)(nil)

// returnportalOption allows management of the mutation configuration using functional options.
type returnportalOption func(*ReturnPortalMutation)

// newReturnPortalMutation creates new mutation for the ReturnPortal entity.
func newReturnPortalMutation(c config, op Op, opts ...returnportalOption) *ReturnPortalMutation {
	m := &ReturnPortalMutation{
		config:        c,
		op:            op,
		typ:           TypeReturnPortal,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReturnPortalID sets the ID field of the mutation.
func withReturnPortalID(id pulid.ID) returnportalOption {
	return func(m *ReturnPortalMutation) {
		var (
			err   error
			once  sync.Once
			value *ReturnPortal
		)
		m.oldValue = func(ctx context.Context) (*ReturnPortal, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReturnPortal.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReturnPortal sets the old ReturnPortal of the mutation.
func withReturnPortal(node *ReturnPortal) returnportalOption {
	return func(m *ReturnPortalMutation) {
		m.oldValue = func(context.Context) (*ReturnPortal, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReturnPortalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReturnPortalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReturnPortal entities.
func (m *ReturnPortalMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReturnPortalMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReturnPortalMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReturnPortal.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ReturnPortalMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ReturnPortalMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ReturnPortal entity.
// If the ReturnPortal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnPortalMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ReturnPortalMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *ReturnPortalMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReturnPortalMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ReturnPortal entity.
// If the ReturnPortal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnPortalMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReturnPortalMutation) ResetName() {
	m.name = nil
}

// SetReturnOpenHours sets the "return_open_hours" field.
func (m *ReturnPortalMutation) SetReturnOpenHours(i int) {
	m.return_open_hours = &i
	m.addreturn_open_hours = nil
}

// ReturnOpenHours returns the value of the "return_open_hours" field in the mutation.
func (m *ReturnPortalMutation) ReturnOpenHours() (r int, exists bool) {
	v := m.return_open_hours
	if v == nil {
		return
	}
	return *v, true
}

// OldReturnOpenHours returns the old "return_open_hours" field's value of the ReturnPortal entity.
// If the ReturnPortal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnPortalMutation) OldReturnOpenHours(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReturnOpenHours is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReturnOpenHours requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReturnOpenHours: %w", err)
	}
	return oldValue.ReturnOpenHours, nil
}

// AddReturnOpenHours adds i to the "return_open_hours" field.
func (m *ReturnPortalMutation) AddReturnOpenHours(i int) {
	if m.addreturn_open_hours != nil {
		*m.addreturn_open_hours += i
	} else {
		m.addreturn_open_hours = &i
	}
}

// AddedReturnOpenHours returns the value that was added to the "return_open_hours" field in this mutation.
func (m *ReturnPortalMutation) AddedReturnOpenHours() (r int, exists bool) {
	v := m.addreturn_open_hours
	if v == nil {
		return
	}
	return *v, true
}

// ResetReturnOpenHours resets all changes to the "return_open_hours" field.
func (m *ReturnPortalMutation) ResetReturnOpenHours() {
	m.return_open_hours = nil
	m.addreturn_open_hours = nil
}

// SetAutomaticallyAccept sets the "automatically_accept" field.
func (m *ReturnPortalMutation) SetAutomaticallyAccept(b bool) {
	m.automatically_accept = &b
}

// AutomaticallyAccept returns the value of the "automatically_accept" field in the mutation.
func (m *ReturnPortalMutation) AutomaticallyAccept() (r bool, exists bool) {
	v := m.automatically_accept
	if v == nil {
		return
	}
	return *v, true
}

// OldAutomaticallyAccept returns the old "automatically_accept" field's value of the ReturnPortal entity.
// If the ReturnPortal object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnPortalMutation) OldAutomaticallyAccept(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutomaticallyAccept is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutomaticallyAccept requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutomaticallyAccept: %w", err)
	}
	return oldValue.AutomaticallyAccept, nil
}

// ResetAutomaticallyAccept resets all changes to the "automatically_accept" field.
func (m *ReturnPortalMutation) ResetAutomaticallyAccept() {
	m.automatically_accept = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ReturnPortalMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[returnportal.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ReturnPortalMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ReturnPortalMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ReturnPortalMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddReturnPortalClaimIDs adds the "return_portal_claim" edge to the ReturnPortalClaim entity by ids.
func (m *ReturnPortalMutation) AddReturnPortalClaimIDs(ids ...pulid.ID) {
	if m.return_portal_claim == nil {
		m.return_portal_claim = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_portal_claim[ids[i]] = struct{}{}
	}
}

// ClearReturnPortalClaim clears the "return_portal_claim" edge to the ReturnPortalClaim entity.
func (m *ReturnPortalMutation) ClearReturnPortalClaim() {
	m.clearedreturn_portal_claim = true
}

// ReturnPortalClaimCleared reports if the "return_portal_claim" edge to the ReturnPortalClaim entity was cleared.
func (m *ReturnPortalMutation) ReturnPortalClaimCleared() bool {
	return m.clearedreturn_portal_claim
}

// RemoveReturnPortalClaimIDs removes the "return_portal_claim" edge to the ReturnPortalClaim entity by IDs.
func (m *ReturnPortalMutation) RemoveReturnPortalClaimIDs(ids ...pulid.ID) {
	if m.removedreturn_portal_claim == nil {
		m.removedreturn_portal_claim = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_portal_claim, ids[i])
		m.removedreturn_portal_claim[ids[i]] = struct{}{}
	}
}

// RemovedReturnPortalClaim returns the removed IDs of the "return_portal_claim" edge to the ReturnPortalClaim entity.
func (m *ReturnPortalMutation) RemovedReturnPortalClaimIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_portal_claim {
		ids = append(ids, id)
	}
	return
}

// ReturnPortalClaimIDs returns the "return_portal_claim" edge IDs in the mutation.
func (m *ReturnPortalMutation) ReturnPortalClaimIDs() (ids []pulid.ID) {
	for id := range m.return_portal_claim {
		ids = append(ids, id)
	}
	return
}

// ResetReturnPortalClaim resets all changes to the "return_portal_claim" edge.
func (m *ReturnPortalMutation) ResetReturnPortalClaim() {
	m.return_portal_claim = nil
	m.clearedreturn_portal_claim = false
	m.removedreturn_portal_claim = nil
}

// AddReturnLocationIDs adds the "return_location" edge to the Location entity by ids.
func (m *ReturnPortalMutation) AddReturnLocationIDs(ids ...pulid.ID) {
	if m.return_location == nil {
		m.return_location = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_location[ids[i]] = struct{}{}
	}
}

// ClearReturnLocation clears the "return_location" edge to the Location entity.
func (m *ReturnPortalMutation) ClearReturnLocation() {
	m.clearedreturn_location = true
}

// ReturnLocationCleared reports if the "return_location" edge to the Location entity was cleared.
func (m *ReturnPortalMutation) ReturnLocationCleared() bool {
	return m.clearedreturn_location
}

// RemoveReturnLocationIDs removes the "return_location" edge to the Location entity by IDs.
func (m *ReturnPortalMutation) RemoveReturnLocationIDs(ids ...pulid.ID) {
	if m.removedreturn_location == nil {
		m.removedreturn_location = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_location, ids[i])
		m.removedreturn_location[ids[i]] = struct{}{}
	}
}

// RemovedReturnLocation returns the removed IDs of the "return_location" edge to the Location entity.
func (m *ReturnPortalMutation) RemovedReturnLocationIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_location {
		ids = append(ids, id)
	}
	return
}

// ReturnLocationIDs returns the "return_location" edge IDs in the mutation.
func (m *ReturnPortalMutation) ReturnLocationIDs() (ids []pulid.ID) {
	for id := range m.return_location {
		ids = append(ids, id)
	}
	return
}

// ResetReturnLocation resets all changes to the "return_location" edge.
func (m *ReturnPortalMutation) ResetReturnLocation() {
	m.return_location = nil
	m.clearedreturn_location = false
	m.removedreturn_location = nil
}

// AddDeliveryOptionIDs adds the "delivery_options" edge to the DeliveryOption entity by ids.
func (m *ReturnPortalMutation) AddDeliveryOptionIDs(ids ...pulid.ID) {
	if m.delivery_options == nil {
		m.delivery_options = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.delivery_options[ids[i]] = struct{}{}
	}
}

// ClearDeliveryOptions clears the "delivery_options" edge to the DeliveryOption entity.
func (m *ReturnPortalMutation) ClearDeliveryOptions() {
	m.cleareddelivery_options = true
}

// DeliveryOptionsCleared reports if the "delivery_options" edge to the DeliveryOption entity was cleared.
func (m *ReturnPortalMutation) DeliveryOptionsCleared() bool {
	return m.cleareddelivery_options
}

// RemoveDeliveryOptionIDs removes the "delivery_options" edge to the DeliveryOption entity by IDs.
func (m *ReturnPortalMutation) RemoveDeliveryOptionIDs(ids ...pulid.ID) {
	if m.removeddelivery_options == nil {
		m.removeddelivery_options = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.delivery_options, ids[i])
		m.removeddelivery_options[ids[i]] = struct{}{}
	}
}

// RemovedDeliveryOptions returns the removed IDs of the "delivery_options" edge to the DeliveryOption entity.
func (m *ReturnPortalMutation) RemovedDeliveryOptionsIDs() (ids []pulid.ID) {
	for id := range m.removeddelivery_options {
		ids = append(ids, id)
	}
	return
}

// DeliveryOptionsIDs returns the "delivery_options" edge IDs in the mutation.
func (m *ReturnPortalMutation) DeliveryOptionsIDs() (ids []pulid.ID) {
	for id := range m.delivery_options {
		ids = append(ids, id)
	}
	return
}

// ResetDeliveryOptions resets all changes to the "delivery_options" edge.
func (m *ReturnPortalMutation) ResetDeliveryOptions() {
	m.delivery_options = nil
	m.cleareddelivery_options = false
	m.removeddelivery_options = nil
}

// SetConnectionID sets the "connection" edge to the Connection entity by id.
func (m *ReturnPortalMutation) SetConnectionID(id pulid.ID) {
	m.connection = &id
}

// ClearConnection clears the "connection" edge to the Connection entity.
func (m *ReturnPortalMutation) ClearConnection() {
	m.clearedconnection = true
}

// ConnectionCleared reports if the "connection" edge to the Connection entity was cleared.
func (m *ReturnPortalMutation) ConnectionCleared() bool {
	return m.clearedconnection
}

// ConnectionID returns the "connection" edge ID in the mutation.
func (m *ReturnPortalMutation) ConnectionID() (id pulid.ID, exists bool) {
	if m.connection != nil {
		return *m.connection, true
	}
	return
}

// ConnectionIDs returns the "connection" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConnectionID instead. It exists only for internal usage by the builders.
func (m *ReturnPortalMutation) ConnectionIDs() (ids []pulid.ID) {
	if id := m.connection; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConnection resets all changes to the "connection" edge.
func (m *ReturnPortalMutation) ResetConnection() {
	m.connection = nil
	m.clearedconnection = false
}

// SetEmailConfirmationLabelID sets the "email_confirmation_label" edge to the EmailTemplate entity by id.
func (m *ReturnPortalMutation) SetEmailConfirmationLabelID(id pulid.ID) {
	m.email_confirmation_label = &id
}

// ClearEmailConfirmationLabel clears the "email_confirmation_label" edge to the EmailTemplate entity.
func (m *ReturnPortalMutation) ClearEmailConfirmationLabel() {
	m.clearedemail_confirmation_label = true
}

// EmailConfirmationLabelCleared reports if the "email_confirmation_label" edge to the EmailTemplate entity was cleared.
func (m *ReturnPortalMutation) EmailConfirmationLabelCleared() bool {
	return m.clearedemail_confirmation_label
}

// EmailConfirmationLabelID returns the "email_confirmation_label" edge ID in the mutation.
func (m *ReturnPortalMutation) EmailConfirmationLabelID() (id pulid.ID, exists bool) {
	if m.email_confirmation_label != nil {
		return *m.email_confirmation_label, true
	}
	return
}

// EmailConfirmationLabelIDs returns the "email_confirmation_label" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailConfirmationLabelID instead. It exists only for internal usage by the builders.
func (m *ReturnPortalMutation) EmailConfirmationLabelIDs() (ids []pulid.ID) {
	if id := m.email_confirmation_label; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailConfirmationLabel resets all changes to the "email_confirmation_label" edge.
func (m *ReturnPortalMutation) ResetEmailConfirmationLabel() {
	m.email_confirmation_label = nil
	m.clearedemail_confirmation_label = false
}

// SetEmailConfirmationQrCodeID sets the "email_confirmation_qr_code" edge to the EmailTemplate entity by id.
func (m *ReturnPortalMutation) SetEmailConfirmationQrCodeID(id pulid.ID) {
	m.email_confirmation_qr_code = &id
}

// ClearEmailConfirmationQrCode clears the "email_confirmation_qr_code" edge to the EmailTemplate entity.
func (m *ReturnPortalMutation) ClearEmailConfirmationQrCode() {
	m.clearedemail_confirmation_qr_code = true
}

// EmailConfirmationQrCodeCleared reports if the "email_confirmation_qr_code" edge to the EmailTemplate entity was cleared.
func (m *ReturnPortalMutation) EmailConfirmationQrCodeCleared() bool {
	return m.clearedemail_confirmation_qr_code
}

// EmailConfirmationQrCodeID returns the "email_confirmation_qr_code" edge ID in the mutation.
func (m *ReturnPortalMutation) EmailConfirmationQrCodeID() (id pulid.ID, exists bool) {
	if m.email_confirmation_qr_code != nil {
		return *m.email_confirmation_qr_code, true
	}
	return
}

// EmailConfirmationQrCodeIDs returns the "email_confirmation_qr_code" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailConfirmationQrCodeID instead. It exists only for internal usage by the builders.
func (m *ReturnPortalMutation) EmailConfirmationQrCodeIDs() (ids []pulid.ID) {
	if id := m.email_confirmation_qr_code; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailConfirmationQrCode resets all changes to the "email_confirmation_qr_code" edge.
func (m *ReturnPortalMutation) ResetEmailConfirmationQrCode() {
	m.email_confirmation_qr_code = nil
	m.clearedemail_confirmation_qr_code = false
}

// SetEmailReceivedID sets the "email_received" edge to the EmailTemplate entity by id.
func (m *ReturnPortalMutation) SetEmailReceivedID(id pulid.ID) {
	m.email_received = &id
}

// ClearEmailReceived clears the "email_received" edge to the EmailTemplate entity.
func (m *ReturnPortalMutation) ClearEmailReceived() {
	m.clearedemail_received = true
}

// EmailReceivedCleared reports if the "email_received" edge to the EmailTemplate entity was cleared.
func (m *ReturnPortalMutation) EmailReceivedCleared() bool {
	return m.clearedemail_received
}

// EmailReceivedID returns the "email_received" edge ID in the mutation.
func (m *ReturnPortalMutation) EmailReceivedID() (id pulid.ID, exists bool) {
	if m.email_received != nil {
		return *m.email_received, true
	}
	return
}

// EmailReceivedIDs returns the "email_received" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailReceivedID instead. It exists only for internal usage by the builders.
func (m *ReturnPortalMutation) EmailReceivedIDs() (ids []pulid.ID) {
	if id := m.email_received; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailReceived resets all changes to the "email_received" edge.
func (m *ReturnPortalMutation) ResetEmailReceived() {
	m.email_received = nil
	m.clearedemail_received = false
}

// SetEmailAcceptedID sets the "email_accepted" edge to the EmailTemplate entity by id.
func (m *ReturnPortalMutation) SetEmailAcceptedID(id pulid.ID) {
	m.email_accepted = &id
}

// ClearEmailAccepted clears the "email_accepted" edge to the EmailTemplate entity.
func (m *ReturnPortalMutation) ClearEmailAccepted() {
	m.clearedemail_accepted = true
}

// EmailAcceptedCleared reports if the "email_accepted" edge to the EmailTemplate entity was cleared.
func (m *ReturnPortalMutation) EmailAcceptedCleared() bool {
	return m.clearedemail_accepted
}

// EmailAcceptedID returns the "email_accepted" edge ID in the mutation.
func (m *ReturnPortalMutation) EmailAcceptedID() (id pulid.ID, exists bool) {
	if m.email_accepted != nil {
		return *m.email_accepted, true
	}
	return
}

// EmailAcceptedIDs returns the "email_accepted" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// EmailAcceptedID instead. It exists only for internal usage by the builders.
func (m *ReturnPortalMutation) EmailAcceptedIDs() (ids []pulid.ID) {
	if id := m.email_accepted; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetEmailAccepted resets all changes to the "email_accepted" edge.
func (m *ReturnPortalMutation) ResetEmailAccepted() {
	m.email_accepted = nil
	m.clearedemail_accepted = false
}

// AddReturnColliIDs adds the "return_colli" edge to the ReturnColli entity by ids.
func (m *ReturnPortalMutation) AddReturnColliIDs(ids ...pulid.ID) {
	if m.return_colli == nil {
		m.return_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_colli[ids[i]] = struct{}{}
	}
}

// ClearReturnColli clears the "return_colli" edge to the ReturnColli entity.
func (m *ReturnPortalMutation) ClearReturnColli() {
	m.clearedreturn_colli = true
}

// ReturnColliCleared reports if the "return_colli" edge to the ReturnColli entity was cleared.
func (m *ReturnPortalMutation) ReturnColliCleared() bool {
	return m.clearedreturn_colli
}

// RemoveReturnColliIDs removes the "return_colli" edge to the ReturnColli entity by IDs.
func (m *ReturnPortalMutation) RemoveReturnColliIDs(ids ...pulid.ID) {
	if m.removedreturn_colli == nil {
		m.removedreturn_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_colli, ids[i])
		m.removedreturn_colli[ids[i]] = struct{}{}
	}
}

// RemovedReturnColli returns the removed IDs of the "return_colli" edge to the ReturnColli entity.
func (m *ReturnPortalMutation) RemovedReturnColliIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_colli {
		ids = append(ids, id)
	}
	return
}

// ReturnColliIDs returns the "return_colli" edge IDs in the mutation.
func (m *ReturnPortalMutation) ReturnColliIDs() (ids []pulid.ID) {
	for id := range m.return_colli {
		ids = append(ids, id)
	}
	return
}

// ResetReturnColli resets all changes to the "return_colli" edge.
func (m *ReturnPortalMutation) ResetReturnColli() {
	m.return_colli = nil
	m.clearedreturn_colli = false
	m.removedreturn_colli = nil
}

// Where appends a list predicates to the ReturnPortalMutation builder.
func (m *ReturnPortalMutation) Where(ps ...predicate.ReturnPortal) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReturnPortalMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReturnPortalMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReturnPortal, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReturnPortalMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReturnPortalMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReturnPortal).
func (m *ReturnPortalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReturnPortalMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, returnportal.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, returnportal.FieldName)
	}
	if m.return_open_hours != nil {
		fields = append(fields, returnportal.FieldReturnOpenHours)
	}
	if m.automatically_accept != nil {
		fields = append(fields, returnportal.FieldAutomaticallyAccept)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReturnPortalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case returnportal.FieldTenantID:
		return m.TenantID()
	case returnportal.FieldName:
		return m.Name()
	case returnportal.FieldReturnOpenHours:
		return m.ReturnOpenHours()
	case returnportal.FieldAutomaticallyAccept:
		return m.AutomaticallyAccept()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReturnPortalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case returnportal.FieldTenantID:
		return m.OldTenantID(ctx)
	case returnportal.FieldName:
		return m.OldName(ctx)
	case returnportal.FieldReturnOpenHours:
		return m.OldReturnOpenHours(ctx)
	case returnportal.FieldAutomaticallyAccept:
		return m.OldAutomaticallyAccept(ctx)
	}
	return nil, fmt.Errorf("unknown ReturnPortal field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReturnPortalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case returnportal.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case returnportal.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case returnportal.FieldReturnOpenHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReturnOpenHours(v)
		return nil
	case returnportal.FieldAutomaticallyAccept:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutomaticallyAccept(v)
		return nil
	}
	return fmt.Errorf("unknown ReturnPortal field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReturnPortalMutation) AddedFields() []string {
	var fields []string
	if m.addreturn_open_hours != nil {
		fields = append(fields, returnportal.FieldReturnOpenHours)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReturnPortalMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case returnportal.FieldReturnOpenHours:
		return m.AddedReturnOpenHours()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReturnPortalMutation) AddField(name string, value ent.Value) error {
	switch name {
	case returnportal.FieldReturnOpenHours:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddReturnOpenHours(v)
		return nil
	}
	return fmt.Errorf("unknown ReturnPortal numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReturnPortalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReturnPortalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReturnPortalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReturnPortal nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReturnPortalMutation) ResetField(name string) error {
	switch name {
	case returnportal.FieldTenantID:
		m.ResetTenantID()
		return nil
	case returnportal.FieldName:
		m.ResetName()
		return nil
	case returnportal.FieldReturnOpenHours:
		m.ResetReturnOpenHours()
		return nil
	case returnportal.FieldAutomaticallyAccept:
		m.ResetAutomaticallyAccept()
		return nil
	}
	return fmt.Errorf("unknown ReturnPortal field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReturnPortalMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.tenant != nil {
		edges = append(edges, returnportal.EdgeTenant)
	}
	if m.return_portal_claim != nil {
		edges = append(edges, returnportal.EdgeReturnPortalClaim)
	}
	if m.return_location != nil {
		edges = append(edges, returnportal.EdgeReturnLocation)
	}
	if m.delivery_options != nil {
		edges = append(edges, returnportal.EdgeDeliveryOptions)
	}
	if m.connection != nil {
		edges = append(edges, returnportal.EdgeConnection)
	}
	if m.email_confirmation_label != nil {
		edges = append(edges, returnportal.EdgeEmailConfirmationLabel)
	}
	if m.email_confirmation_qr_code != nil {
		edges = append(edges, returnportal.EdgeEmailConfirmationQrCode)
	}
	if m.email_received != nil {
		edges = append(edges, returnportal.EdgeEmailReceived)
	}
	if m.email_accepted != nil {
		edges = append(edges, returnportal.EdgeEmailAccepted)
	}
	if m.return_colli != nil {
		edges = append(edges, returnportal.EdgeReturnColli)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReturnPortalMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case returnportal.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case returnportal.EdgeReturnPortalClaim:
		ids := make([]ent.Value, 0, len(m.return_portal_claim))
		for id := range m.return_portal_claim {
			ids = append(ids, id)
		}
		return ids
	case returnportal.EdgeReturnLocation:
		ids := make([]ent.Value, 0, len(m.return_location))
		for id := range m.return_location {
			ids = append(ids, id)
		}
		return ids
	case returnportal.EdgeDeliveryOptions:
		ids := make([]ent.Value, 0, len(m.delivery_options))
		for id := range m.delivery_options {
			ids = append(ids, id)
		}
		return ids
	case returnportal.EdgeConnection:
		if id := m.connection; id != nil {
			return []ent.Value{*id}
		}
	case returnportal.EdgeEmailConfirmationLabel:
		if id := m.email_confirmation_label; id != nil {
			return []ent.Value{*id}
		}
	case returnportal.EdgeEmailConfirmationQrCode:
		if id := m.email_confirmation_qr_code; id != nil {
			return []ent.Value{*id}
		}
	case returnportal.EdgeEmailReceived:
		if id := m.email_received; id != nil {
			return []ent.Value{*id}
		}
	case returnportal.EdgeEmailAccepted:
		if id := m.email_accepted; id != nil {
			return []ent.Value{*id}
		}
	case returnportal.EdgeReturnColli:
		ids := make([]ent.Value, 0, len(m.return_colli))
		for id := range m.return_colli {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReturnPortalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedreturn_portal_claim != nil {
		edges = append(edges, returnportal.EdgeReturnPortalClaim)
	}
	if m.removedreturn_location != nil {
		edges = append(edges, returnportal.EdgeReturnLocation)
	}
	if m.removeddelivery_options != nil {
		edges = append(edges, returnportal.EdgeDeliveryOptions)
	}
	if m.removedreturn_colli != nil {
		edges = append(edges, returnportal.EdgeReturnColli)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReturnPortalMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case returnportal.EdgeReturnPortalClaim:
		ids := make([]ent.Value, 0, len(m.removedreturn_portal_claim))
		for id := range m.removedreturn_portal_claim {
			ids = append(ids, id)
		}
		return ids
	case returnportal.EdgeReturnLocation:
		ids := make([]ent.Value, 0, len(m.removedreturn_location))
		for id := range m.removedreturn_location {
			ids = append(ids, id)
		}
		return ids
	case returnportal.EdgeDeliveryOptions:
		ids := make([]ent.Value, 0, len(m.removeddelivery_options))
		for id := range m.removeddelivery_options {
			ids = append(ids, id)
		}
		return ids
	case returnportal.EdgeReturnColli:
		ids := make([]ent.Value, 0, len(m.removedreturn_colli))
		for id := range m.removedreturn_colli {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReturnPortalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedtenant {
		edges = append(edges, returnportal.EdgeTenant)
	}
	if m.clearedreturn_portal_claim {
		edges = append(edges, returnportal.EdgeReturnPortalClaim)
	}
	if m.clearedreturn_location {
		edges = append(edges, returnportal.EdgeReturnLocation)
	}
	if m.cleareddelivery_options {
		edges = append(edges, returnportal.EdgeDeliveryOptions)
	}
	if m.clearedconnection {
		edges = append(edges, returnportal.EdgeConnection)
	}
	if m.clearedemail_confirmation_label {
		edges = append(edges, returnportal.EdgeEmailConfirmationLabel)
	}
	if m.clearedemail_confirmation_qr_code {
		edges = append(edges, returnportal.EdgeEmailConfirmationQrCode)
	}
	if m.clearedemail_received {
		edges = append(edges, returnportal.EdgeEmailReceived)
	}
	if m.clearedemail_accepted {
		edges = append(edges, returnportal.EdgeEmailAccepted)
	}
	if m.clearedreturn_colli {
		edges = append(edges, returnportal.EdgeReturnColli)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReturnPortalMutation) EdgeCleared(name string) bool {
	switch name {
	case returnportal.EdgeTenant:
		return m.clearedtenant
	case returnportal.EdgeReturnPortalClaim:
		return m.clearedreturn_portal_claim
	case returnportal.EdgeReturnLocation:
		return m.clearedreturn_location
	case returnportal.EdgeDeliveryOptions:
		return m.cleareddelivery_options
	case returnportal.EdgeConnection:
		return m.clearedconnection
	case returnportal.EdgeEmailConfirmationLabel:
		return m.clearedemail_confirmation_label
	case returnportal.EdgeEmailConfirmationQrCode:
		return m.clearedemail_confirmation_qr_code
	case returnportal.EdgeEmailReceived:
		return m.clearedemail_received
	case returnportal.EdgeEmailAccepted:
		return m.clearedemail_accepted
	case returnportal.EdgeReturnColli:
		return m.clearedreturn_colli
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReturnPortalMutation) ClearEdge(name string) error {
	switch name {
	case returnportal.EdgeTenant:
		m.ClearTenant()
		return nil
	case returnportal.EdgeConnection:
		m.ClearConnection()
		return nil
	case returnportal.EdgeEmailConfirmationLabel:
		m.ClearEmailConfirmationLabel()
		return nil
	case returnportal.EdgeEmailConfirmationQrCode:
		m.ClearEmailConfirmationQrCode()
		return nil
	case returnportal.EdgeEmailReceived:
		m.ClearEmailReceived()
		return nil
	case returnportal.EdgeEmailAccepted:
		m.ClearEmailAccepted()
		return nil
	}
	return fmt.Errorf("unknown ReturnPortal unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReturnPortalMutation) ResetEdge(name string) error {
	switch name {
	case returnportal.EdgeTenant:
		m.ResetTenant()
		return nil
	case returnportal.EdgeReturnPortalClaim:
		m.ResetReturnPortalClaim()
		return nil
	case returnportal.EdgeReturnLocation:
		m.ResetReturnLocation()
		return nil
	case returnportal.EdgeDeliveryOptions:
		m.ResetDeliveryOptions()
		return nil
	case returnportal.EdgeConnection:
		m.ResetConnection()
		return nil
	case returnportal.EdgeEmailConfirmationLabel:
		m.ResetEmailConfirmationLabel()
		return nil
	case returnportal.EdgeEmailConfirmationQrCode:
		m.ResetEmailConfirmationQrCode()
		return nil
	case returnportal.EdgeEmailReceived:
		m.ResetEmailReceived()
		return nil
	case returnportal.EdgeEmailAccepted:
		m.ResetEmailAccepted()
		return nil
	case returnportal.EdgeReturnColli:
		m.ResetReturnColli()
		return nil
	}
	return fmt.Errorf("unknown ReturnPortal edge %s", name)
}

// ReturnPortalClaimMutation represents an operation that mutates the ReturnPortalClaim nodes in the graph.
type ReturnPortalClaimMutation struct {
	config
	op                       Op
	typ                      string
	id                       *pulid.ID
	name                     *string
	description              *string
	restockable              *bool
	archived                 *bool
	clearedFields            map[string]struct{}
	tenant                   *pulid.ID
	clearedtenant            bool
	return_portal            *pulid.ID
	clearedreturn_portal     bool
	return_location          *pulid.ID
	clearedreturn_location   bool
	return_order_line        map[pulid.ID]struct{}
	removedreturn_order_line map[pulid.ID]struct{}
	clearedreturn_order_line bool
	done                     bool
	oldValue                 func(context.Context) (*ReturnPortalClaim, error)
	predicates               []predicate.ReturnPortalClaim
}

var _ ent.Mutation = (*ReturnPortalClaimMutation)(nil)

// returnportalclaimOption allows management of the mutation configuration using functional options.
type returnportalclaimOption func(*ReturnPortalClaimMutation)

// newReturnPortalClaimMutation creates new mutation for the ReturnPortalClaim entity.
func newReturnPortalClaimMutation(c config, op Op, opts ...returnportalclaimOption) *ReturnPortalClaimMutation {
	m := &ReturnPortalClaimMutation{
		config:        c,
		op:            op,
		typ:           TypeReturnPortalClaim,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withReturnPortalClaimID sets the ID field of the mutation.
func withReturnPortalClaimID(id pulid.ID) returnportalclaimOption {
	return func(m *ReturnPortalClaimMutation) {
		var (
			err   error
			once  sync.Once
			value *ReturnPortalClaim
		)
		m.oldValue = func(ctx context.Context) (*ReturnPortalClaim, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ReturnPortalClaim.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withReturnPortalClaim sets the old ReturnPortalClaim of the mutation.
func withReturnPortalClaim(node *ReturnPortalClaim) returnportalclaimOption {
	return func(m *ReturnPortalClaimMutation) {
		m.oldValue = func(context.Context) (*ReturnPortalClaim, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ReturnPortalClaimMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ReturnPortalClaimMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ReturnPortalClaim entities.
func (m *ReturnPortalClaimMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ReturnPortalClaimMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ReturnPortalClaimMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ReturnPortalClaim.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ReturnPortalClaimMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ReturnPortalClaimMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ReturnPortalClaim entity.
// If the ReturnPortalClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnPortalClaimMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ReturnPortalClaimMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *ReturnPortalClaimMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ReturnPortalClaimMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ReturnPortalClaim entity.
// If the ReturnPortalClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnPortalClaimMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ReturnPortalClaimMutation) ResetName() {
	m.name = nil
}

// SetDescription sets the "description" field.
func (m *ReturnPortalClaimMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ReturnPortalClaimMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the ReturnPortalClaim entity.
// If the ReturnPortalClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnPortalClaimMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ReturnPortalClaimMutation) ResetDescription() {
	m.description = nil
}

// SetRestockable sets the "restockable" field.
func (m *ReturnPortalClaimMutation) SetRestockable(b bool) {
	m.restockable = &b
}

// Restockable returns the value of the "restockable" field in the mutation.
func (m *ReturnPortalClaimMutation) Restockable() (r bool, exists bool) {
	v := m.restockable
	if v == nil {
		return
	}
	return *v, true
}

// OldRestockable returns the old "restockable" field's value of the ReturnPortalClaim entity.
// If the ReturnPortalClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnPortalClaimMutation) OldRestockable(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRestockable is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRestockable requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRestockable: %w", err)
	}
	return oldValue.Restockable, nil
}

// ResetRestockable resets all changes to the "restockable" field.
func (m *ReturnPortalClaimMutation) ResetRestockable() {
	m.restockable = nil
}

// SetArchived sets the "archived" field.
func (m *ReturnPortalClaimMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *ReturnPortalClaimMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the ReturnPortalClaim entity.
// If the ReturnPortalClaim object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ReturnPortalClaimMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *ReturnPortalClaimMutation) ResetArchived() {
	m.archived = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ReturnPortalClaimMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[returnportalclaim.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ReturnPortalClaimMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ReturnPortalClaimMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ReturnPortalClaimMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetReturnPortalID sets the "return_portal" edge to the ReturnPortal entity by id.
func (m *ReturnPortalClaimMutation) SetReturnPortalID(id pulid.ID) {
	m.return_portal = &id
}

// ClearReturnPortal clears the "return_portal" edge to the ReturnPortal entity.
func (m *ReturnPortalClaimMutation) ClearReturnPortal() {
	m.clearedreturn_portal = true
}

// ReturnPortalCleared reports if the "return_portal" edge to the ReturnPortal entity was cleared.
func (m *ReturnPortalClaimMutation) ReturnPortalCleared() bool {
	return m.clearedreturn_portal
}

// ReturnPortalID returns the "return_portal" edge ID in the mutation.
func (m *ReturnPortalClaimMutation) ReturnPortalID() (id pulid.ID, exists bool) {
	if m.return_portal != nil {
		return *m.return_portal, true
	}
	return
}

// ReturnPortalIDs returns the "return_portal" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReturnPortalID instead. It exists only for internal usage by the builders.
func (m *ReturnPortalClaimMutation) ReturnPortalIDs() (ids []pulid.ID) {
	if id := m.return_portal; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReturnPortal resets all changes to the "return_portal" edge.
func (m *ReturnPortalClaimMutation) ResetReturnPortal() {
	m.return_portal = nil
	m.clearedreturn_portal = false
}

// SetReturnLocationID sets the "return_location" edge to the Location entity by id.
func (m *ReturnPortalClaimMutation) SetReturnLocationID(id pulid.ID) {
	m.return_location = &id
}

// ClearReturnLocation clears the "return_location" edge to the Location entity.
func (m *ReturnPortalClaimMutation) ClearReturnLocation() {
	m.clearedreturn_location = true
}

// ReturnLocationCleared reports if the "return_location" edge to the Location entity was cleared.
func (m *ReturnPortalClaimMutation) ReturnLocationCleared() bool {
	return m.clearedreturn_location
}

// ReturnLocationID returns the "return_location" edge ID in the mutation.
func (m *ReturnPortalClaimMutation) ReturnLocationID() (id pulid.ID, exists bool) {
	if m.return_location != nil {
		return *m.return_location, true
	}
	return
}

// ReturnLocationIDs returns the "return_location" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReturnLocationID instead. It exists only for internal usage by the builders.
func (m *ReturnPortalClaimMutation) ReturnLocationIDs() (ids []pulid.ID) {
	if id := m.return_location; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReturnLocation resets all changes to the "return_location" edge.
func (m *ReturnPortalClaimMutation) ResetReturnLocation() {
	m.return_location = nil
	m.clearedreturn_location = false
}

// AddReturnOrderLineIDs adds the "return_order_line" edge to the ReturnOrderLine entity by ids.
func (m *ReturnPortalClaimMutation) AddReturnOrderLineIDs(ids ...pulid.ID) {
	if m.return_order_line == nil {
		m.return_order_line = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.return_order_line[ids[i]] = struct{}{}
	}
}

// ClearReturnOrderLine clears the "return_order_line" edge to the ReturnOrderLine entity.
func (m *ReturnPortalClaimMutation) ClearReturnOrderLine() {
	m.clearedreturn_order_line = true
}

// ReturnOrderLineCleared reports if the "return_order_line" edge to the ReturnOrderLine entity was cleared.
func (m *ReturnPortalClaimMutation) ReturnOrderLineCleared() bool {
	return m.clearedreturn_order_line
}

// RemoveReturnOrderLineIDs removes the "return_order_line" edge to the ReturnOrderLine entity by IDs.
func (m *ReturnPortalClaimMutation) RemoveReturnOrderLineIDs(ids ...pulid.ID) {
	if m.removedreturn_order_line == nil {
		m.removedreturn_order_line = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.return_order_line, ids[i])
		m.removedreturn_order_line[ids[i]] = struct{}{}
	}
}

// RemovedReturnOrderLine returns the removed IDs of the "return_order_line" edge to the ReturnOrderLine entity.
func (m *ReturnPortalClaimMutation) RemovedReturnOrderLineIDs() (ids []pulid.ID) {
	for id := range m.removedreturn_order_line {
		ids = append(ids, id)
	}
	return
}

// ReturnOrderLineIDs returns the "return_order_line" edge IDs in the mutation.
func (m *ReturnPortalClaimMutation) ReturnOrderLineIDs() (ids []pulid.ID) {
	for id := range m.return_order_line {
		ids = append(ids, id)
	}
	return
}

// ResetReturnOrderLine resets all changes to the "return_order_line" edge.
func (m *ReturnPortalClaimMutation) ResetReturnOrderLine() {
	m.return_order_line = nil
	m.clearedreturn_order_line = false
	m.removedreturn_order_line = nil
}

// Where appends a list predicates to the ReturnPortalClaimMutation builder.
func (m *ReturnPortalClaimMutation) Where(ps ...predicate.ReturnPortalClaim) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ReturnPortalClaimMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ReturnPortalClaimMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ReturnPortalClaim, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ReturnPortalClaimMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ReturnPortalClaimMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ReturnPortalClaim).
func (m *ReturnPortalClaimMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ReturnPortalClaimMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, returnportalclaim.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, returnportalclaim.FieldName)
	}
	if m.description != nil {
		fields = append(fields, returnportalclaim.FieldDescription)
	}
	if m.restockable != nil {
		fields = append(fields, returnportalclaim.FieldRestockable)
	}
	if m.archived != nil {
		fields = append(fields, returnportalclaim.FieldArchived)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ReturnPortalClaimMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case returnportalclaim.FieldTenantID:
		return m.TenantID()
	case returnportalclaim.FieldName:
		return m.Name()
	case returnportalclaim.FieldDescription:
		return m.Description()
	case returnportalclaim.FieldRestockable:
		return m.Restockable()
	case returnportalclaim.FieldArchived:
		return m.Archived()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ReturnPortalClaimMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case returnportalclaim.FieldTenantID:
		return m.OldTenantID(ctx)
	case returnportalclaim.FieldName:
		return m.OldName(ctx)
	case returnportalclaim.FieldDescription:
		return m.OldDescription(ctx)
	case returnportalclaim.FieldRestockable:
		return m.OldRestockable(ctx)
	case returnportalclaim.FieldArchived:
		return m.OldArchived(ctx)
	}
	return nil, fmt.Errorf("unknown ReturnPortalClaim field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReturnPortalClaimMutation) SetField(name string, value ent.Value) error {
	switch name {
	case returnportalclaim.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case returnportalclaim.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case returnportalclaim.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case returnportalclaim.FieldRestockable:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRestockable(v)
		return nil
	case returnportalclaim.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	}
	return fmt.Errorf("unknown ReturnPortalClaim field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ReturnPortalClaimMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ReturnPortalClaimMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ReturnPortalClaimMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ReturnPortalClaim numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ReturnPortalClaimMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ReturnPortalClaimMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ReturnPortalClaimMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ReturnPortalClaim nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ReturnPortalClaimMutation) ResetField(name string) error {
	switch name {
	case returnportalclaim.FieldTenantID:
		m.ResetTenantID()
		return nil
	case returnportalclaim.FieldName:
		m.ResetName()
		return nil
	case returnportalclaim.FieldDescription:
		m.ResetDescription()
		return nil
	case returnportalclaim.FieldRestockable:
		m.ResetRestockable()
		return nil
	case returnportalclaim.FieldArchived:
		m.ResetArchived()
		return nil
	}
	return fmt.Errorf("unknown ReturnPortalClaim field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ReturnPortalClaimMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, returnportalclaim.EdgeTenant)
	}
	if m.return_portal != nil {
		edges = append(edges, returnportalclaim.EdgeReturnPortal)
	}
	if m.return_location != nil {
		edges = append(edges, returnportalclaim.EdgeReturnLocation)
	}
	if m.return_order_line != nil {
		edges = append(edges, returnportalclaim.EdgeReturnOrderLine)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ReturnPortalClaimMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case returnportalclaim.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case returnportalclaim.EdgeReturnPortal:
		if id := m.return_portal; id != nil {
			return []ent.Value{*id}
		}
	case returnportalclaim.EdgeReturnLocation:
		if id := m.return_location; id != nil {
			return []ent.Value{*id}
		}
	case returnportalclaim.EdgeReturnOrderLine:
		ids := make([]ent.Value, 0, len(m.return_order_line))
		for id := range m.return_order_line {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ReturnPortalClaimMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedreturn_order_line != nil {
		edges = append(edges, returnportalclaim.EdgeReturnOrderLine)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ReturnPortalClaimMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case returnportalclaim.EdgeReturnOrderLine:
		ids := make([]ent.Value, 0, len(m.removedreturn_order_line))
		for id := range m.removedreturn_order_line {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ReturnPortalClaimMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, returnportalclaim.EdgeTenant)
	}
	if m.clearedreturn_portal {
		edges = append(edges, returnportalclaim.EdgeReturnPortal)
	}
	if m.clearedreturn_location {
		edges = append(edges, returnportalclaim.EdgeReturnLocation)
	}
	if m.clearedreturn_order_line {
		edges = append(edges, returnportalclaim.EdgeReturnOrderLine)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ReturnPortalClaimMutation) EdgeCleared(name string) bool {
	switch name {
	case returnportalclaim.EdgeTenant:
		return m.clearedtenant
	case returnportalclaim.EdgeReturnPortal:
		return m.clearedreturn_portal
	case returnportalclaim.EdgeReturnLocation:
		return m.clearedreturn_location
	case returnportalclaim.EdgeReturnOrderLine:
		return m.clearedreturn_order_line
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ReturnPortalClaimMutation) ClearEdge(name string) error {
	switch name {
	case returnportalclaim.EdgeTenant:
		m.ClearTenant()
		return nil
	case returnportalclaim.EdgeReturnPortal:
		m.ClearReturnPortal()
		return nil
	case returnportalclaim.EdgeReturnLocation:
		m.ClearReturnLocation()
		return nil
	}
	return fmt.Errorf("unknown ReturnPortalClaim unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ReturnPortalClaimMutation) ResetEdge(name string) error {
	switch name {
	case returnportalclaim.EdgeTenant:
		m.ResetTenant()
		return nil
	case returnportalclaim.EdgeReturnPortal:
		m.ResetReturnPortal()
		return nil
	case returnportalclaim.EdgeReturnLocation:
		m.ResetReturnLocation()
		return nil
	case returnportalclaim.EdgeReturnOrderLine:
		m.ResetReturnOrderLine()
		return nil
	}
	return fmt.Errorf("unknown ReturnPortalClaim edge %s", name)
}

// SeatGroupMutation represents an operation that mutates the SeatGroup nodes in the graph.
type SeatGroupMutation struct {
	config
	op                             Op
	typ                            string
	id                             *pulid.ID
	name                           *string
	created_at                     *time.Time
	clearedFields                  map[string]struct{}
	tenant                         *pulid.ID
	clearedtenant                  bool
	user                           map[pulid.ID]struct{}
	removeduser                    map[pulid.ID]struct{}
	cleareduser                    bool
	assigned_access_right          map[pulid.ID]struct{}
	removedassigned_access_right   map[pulid.ID]struct{}
	clearedassigned_access_right   bool
	seat_group_access_right        map[pulid.ID]struct{}
	removedseat_group_access_right map[pulid.ID]struct{}
	clearedseat_group_access_right bool
	done                           bool
	oldValue                       func(context.Context) (*SeatGroup, error)
	predicates                     []predicate.SeatGroup
}

var _ ent.Mutation = (*SeatGroupMutation)(nil)

// seatgroupOption allows management of the mutation configuration using functional options.
type seatgroupOption func(*SeatGroupMutation)

// newSeatGroupMutation creates new mutation for the SeatGroup entity.
func newSeatGroupMutation(c config, op Op, opts ...seatgroupOption) *SeatGroupMutation {
	m := &SeatGroupMutation{
		config:        c,
		op:            op,
		typ:           TypeSeatGroup,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeatGroupID sets the ID field of the mutation.
func withSeatGroupID(id pulid.ID) seatgroupOption {
	return func(m *SeatGroupMutation) {
		var (
			err   error
			once  sync.Once
			value *SeatGroup
		)
		m.oldValue = func(ctx context.Context) (*SeatGroup, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SeatGroup.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeatGroup sets the old SeatGroup of the mutation.
func withSeatGroup(node *SeatGroup) seatgroupOption {
	return func(m *SeatGroupMutation) {
		m.oldValue = func(context.Context) (*SeatGroup, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeatGroupMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeatGroupMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SeatGroup entities.
func (m *SeatGroupMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeatGroupMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeatGroupMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SeatGroup.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SeatGroupMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SeatGroupMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SeatGroup entity.
// If the SeatGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatGroupMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SeatGroupMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *SeatGroupMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SeatGroupMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the SeatGroup entity.
// If the SeatGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatGroupMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SeatGroupMutation) ResetName() {
	m.name = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SeatGroupMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SeatGroupMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SeatGroup entity.
// If the SeatGroup object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatGroupMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SeatGroupMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[seatgroup.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SeatGroupMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[seatgroup.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SeatGroupMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, seatgroup.FieldCreatedAt)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SeatGroupMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[seatgroup.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SeatGroupMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SeatGroupMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SeatGroupMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddUserIDs adds the "user" edge to the User entity by ids.
func (m *SeatGroupMutation) AddUserIDs(ids ...pulid.ID) {
	if m.user == nil {
		m.user = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.user[ids[i]] = struct{}{}
	}
}

// ClearUser clears the "user" edge to the User entity.
func (m *SeatGroupMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SeatGroupMutation) UserCleared() bool {
	return m.cleareduser
}

// RemoveUserIDs removes the "user" edge to the User entity by IDs.
func (m *SeatGroupMutation) RemoveUserIDs(ids ...pulid.ID) {
	if m.removeduser == nil {
		m.removeduser = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.user, ids[i])
		m.removeduser[ids[i]] = struct{}{}
	}
}

// RemovedUser returns the removed IDs of the "user" edge to the User entity.
func (m *SeatGroupMutation) RemovedUserIDs() (ids []pulid.ID) {
	for id := range m.removeduser {
		ids = append(ids, id)
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
func (m *SeatGroupMutation) UserIDs() (ids []pulid.ID) {
	for id := range m.user {
		ids = append(ids, id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SeatGroupMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
	m.removeduser = nil
}

// AddAssignedAccessRightIDs adds the "assigned_access_right" edge to the AccessRight entity by ids.
func (m *SeatGroupMutation) AddAssignedAccessRightIDs(ids ...pulid.ID) {
	if m.assigned_access_right == nil {
		m.assigned_access_right = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.assigned_access_right[ids[i]] = struct{}{}
	}
}

// ClearAssignedAccessRight clears the "assigned_access_right" edge to the AccessRight entity.
func (m *SeatGroupMutation) ClearAssignedAccessRight() {
	m.clearedassigned_access_right = true
}

// AssignedAccessRightCleared reports if the "assigned_access_right" edge to the AccessRight entity was cleared.
func (m *SeatGroupMutation) AssignedAccessRightCleared() bool {
	return m.clearedassigned_access_right
}

// RemoveAssignedAccessRightIDs removes the "assigned_access_right" edge to the AccessRight entity by IDs.
func (m *SeatGroupMutation) RemoveAssignedAccessRightIDs(ids ...pulid.ID) {
	if m.removedassigned_access_right == nil {
		m.removedassigned_access_right = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.assigned_access_right, ids[i])
		m.removedassigned_access_right[ids[i]] = struct{}{}
	}
}

// RemovedAssignedAccessRight returns the removed IDs of the "assigned_access_right" edge to the AccessRight entity.
func (m *SeatGroupMutation) RemovedAssignedAccessRightIDs() (ids []pulid.ID) {
	for id := range m.removedassigned_access_right {
		ids = append(ids, id)
	}
	return
}

// AssignedAccessRightIDs returns the "assigned_access_right" edge IDs in the mutation.
func (m *SeatGroupMutation) AssignedAccessRightIDs() (ids []pulid.ID) {
	for id := range m.assigned_access_right {
		ids = append(ids, id)
	}
	return
}

// ResetAssignedAccessRight resets all changes to the "assigned_access_right" edge.
func (m *SeatGroupMutation) ResetAssignedAccessRight() {
	m.assigned_access_right = nil
	m.clearedassigned_access_right = false
	m.removedassigned_access_right = nil
}

// AddSeatGroupAccessRightIDs adds the "seat_group_access_right" edge to the SeatGroupAccessRight entity by ids.
func (m *SeatGroupMutation) AddSeatGroupAccessRightIDs(ids ...pulid.ID) {
	if m.seat_group_access_right == nil {
		m.seat_group_access_right = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.seat_group_access_right[ids[i]] = struct{}{}
	}
}

// ClearSeatGroupAccessRight clears the "seat_group_access_right" edge to the SeatGroupAccessRight entity.
func (m *SeatGroupMutation) ClearSeatGroupAccessRight() {
	m.clearedseat_group_access_right = true
}

// SeatGroupAccessRightCleared reports if the "seat_group_access_right" edge to the SeatGroupAccessRight entity was cleared.
func (m *SeatGroupMutation) SeatGroupAccessRightCleared() bool {
	return m.clearedseat_group_access_right
}

// RemoveSeatGroupAccessRightIDs removes the "seat_group_access_right" edge to the SeatGroupAccessRight entity by IDs.
func (m *SeatGroupMutation) RemoveSeatGroupAccessRightIDs(ids ...pulid.ID) {
	if m.removedseat_group_access_right == nil {
		m.removedseat_group_access_right = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.seat_group_access_right, ids[i])
		m.removedseat_group_access_right[ids[i]] = struct{}{}
	}
}

// RemovedSeatGroupAccessRight returns the removed IDs of the "seat_group_access_right" edge to the SeatGroupAccessRight entity.
func (m *SeatGroupMutation) RemovedSeatGroupAccessRightIDs() (ids []pulid.ID) {
	for id := range m.removedseat_group_access_right {
		ids = append(ids, id)
	}
	return
}

// SeatGroupAccessRightIDs returns the "seat_group_access_right" edge IDs in the mutation.
func (m *SeatGroupMutation) SeatGroupAccessRightIDs() (ids []pulid.ID) {
	for id := range m.seat_group_access_right {
		ids = append(ids, id)
	}
	return
}

// ResetSeatGroupAccessRight resets all changes to the "seat_group_access_right" edge.
func (m *SeatGroupMutation) ResetSeatGroupAccessRight() {
	m.seat_group_access_right = nil
	m.clearedseat_group_access_right = false
	m.removedseat_group_access_right = nil
}

// Where appends a list predicates to the SeatGroupMutation builder.
func (m *SeatGroupMutation) Where(ps ...predicate.SeatGroup) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeatGroupMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeatGroupMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SeatGroup, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeatGroupMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeatGroupMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SeatGroup).
func (m *SeatGroupMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeatGroupMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.tenant != nil {
		fields = append(fields, seatgroup.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, seatgroup.FieldName)
	}
	if m.created_at != nil {
		fields = append(fields, seatgroup.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeatGroupMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seatgroup.FieldTenantID:
		return m.TenantID()
	case seatgroup.FieldName:
		return m.Name()
	case seatgroup.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeatGroupMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seatgroup.FieldTenantID:
		return m.OldTenantID(ctx)
	case seatgroup.FieldName:
		return m.OldName(ctx)
	case seatgroup.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SeatGroup field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeatGroupMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seatgroup.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case seatgroup.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case seatgroup.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SeatGroup field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeatGroupMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeatGroupMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeatGroupMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SeatGroup numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeatGroupMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(seatgroup.FieldCreatedAt) {
		fields = append(fields, seatgroup.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeatGroupMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeatGroupMutation) ClearField(name string) error {
	switch name {
	case seatgroup.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SeatGroup nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeatGroupMutation) ResetField(name string) error {
	switch name {
	case seatgroup.FieldTenantID:
		m.ResetTenantID()
		return nil
	case seatgroup.FieldName:
		m.ResetName()
		return nil
	case seatgroup.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SeatGroup field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeatGroupMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, seatgroup.EdgeTenant)
	}
	if m.user != nil {
		edges = append(edges, seatgroup.EdgeUser)
	}
	if m.assigned_access_right != nil {
		edges = append(edges, seatgroup.EdgeAssignedAccessRight)
	}
	if m.seat_group_access_right != nil {
		edges = append(edges, seatgroup.EdgeSeatGroupAccessRight)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeatGroupMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seatgroup.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case seatgroup.EdgeUser:
		ids := make([]ent.Value, 0, len(m.user))
		for id := range m.user {
			ids = append(ids, id)
		}
		return ids
	case seatgroup.EdgeAssignedAccessRight:
		ids := make([]ent.Value, 0, len(m.assigned_access_right))
		for id := range m.assigned_access_right {
			ids = append(ids, id)
		}
		return ids
	case seatgroup.EdgeSeatGroupAccessRight:
		ids := make([]ent.Value, 0, len(m.seat_group_access_right))
		for id := range m.seat_group_access_right {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeatGroupMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removeduser != nil {
		edges = append(edges, seatgroup.EdgeUser)
	}
	if m.removedassigned_access_right != nil {
		edges = append(edges, seatgroup.EdgeAssignedAccessRight)
	}
	if m.removedseat_group_access_right != nil {
		edges = append(edges, seatgroup.EdgeSeatGroupAccessRight)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeatGroupMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case seatgroup.EdgeUser:
		ids := make([]ent.Value, 0, len(m.removeduser))
		for id := range m.removeduser {
			ids = append(ids, id)
		}
		return ids
	case seatgroup.EdgeAssignedAccessRight:
		ids := make([]ent.Value, 0, len(m.removedassigned_access_right))
		for id := range m.removedassigned_access_right {
			ids = append(ids, id)
		}
		return ids
	case seatgroup.EdgeSeatGroupAccessRight:
		ids := make([]ent.Value, 0, len(m.removedseat_group_access_right))
		for id := range m.removedseat_group_access_right {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeatGroupMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, seatgroup.EdgeTenant)
	}
	if m.cleareduser {
		edges = append(edges, seatgroup.EdgeUser)
	}
	if m.clearedassigned_access_right {
		edges = append(edges, seatgroup.EdgeAssignedAccessRight)
	}
	if m.clearedseat_group_access_right {
		edges = append(edges, seatgroup.EdgeSeatGroupAccessRight)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeatGroupMutation) EdgeCleared(name string) bool {
	switch name {
	case seatgroup.EdgeTenant:
		return m.clearedtenant
	case seatgroup.EdgeUser:
		return m.cleareduser
	case seatgroup.EdgeAssignedAccessRight:
		return m.clearedassigned_access_right
	case seatgroup.EdgeSeatGroupAccessRight:
		return m.clearedseat_group_access_right
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeatGroupMutation) ClearEdge(name string) error {
	switch name {
	case seatgroup.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SeatGroup unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeatGroupMutation) ResetEdge(name string) error {
	switch name {
	case seatgroup.EdgeTenant:
		m.ResetTenant()
		return nil
	case seatgroup.EdgeUser:
		m.ResetUser()
		return nil
	case seatgroup.EdgeAssignedAccessRight:
		m.ResetAssignedAccessRight()
		return nil
	case seatgroup.EdgeSeatGroupAccessRight:
		m.ResetSeatGroupAccessRight()
		return nil
	}
	return fmt.Errorf("unknown SeatGroup edge %s", name)
}

// SeatGroupAccessRightMutation represents an operation that mutates the SeatGroupAccessRight nodes in the graph.
type SeatGroupAccessRightMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.ID
	level               *seatgroupaccessright.Level
	clearedFields       map[string]struct{}
	tenant              *pulid.ID
	clearedtenant       bool
	access_right        *pulid.ID
	clearedaccess_right bool
	seat_group          *pulid.ID
	clearedseat_group   bool
	done                bool
	oldValue            func(context.Context) (*SeatGroupAccessRight, error)
	predicates          []predicate.SeatGroupAccessRight
}

var _ ent.Mutation = (*SeatGroupAccessRightMutation)(nil)

// seatgroupaccessrightOption allows management of the mutation configuration using functional options.
type seatgroupaccessrightOption func(*SeatGroupAccessRightMutation)

// newSeatGroupAccessRightMutation creates new mutation for the SeatGroupAccessRight entity.
func newSeatGroupAccessRightMutation(c config, op Op, opts ...seatgroupaccessrightOption) *SeatGroupAccessRightMutation {
	m := &SeatGroupAccessRightMutation{
		config:        c,
		op:            op,
		typ:           TypeSeatGroupAccessRight,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSeatGroupAccessRightID sets the ID field of the mutation.
func withSeatGroupAccessRightID(id pulid.ID) seatgroupaccessrightOption {
	return func(m *SeatGroupAccessRightMutation) {
		var (
			err   error
			once  sync.Once
			value *SeatGroupAccessRight
		)
		m.oldValue = func(ctx context.Context) (*SeatGroupAccessRight, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SeatGroupAccessRight.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSeatGroupAccessRight sets the old SeatGroupAccessRight of the mutation.
func withSeatGroupAccessRight(node *SeatGroupAccessRight) seatgroupaccessrightOption {
	return func(m *SeatGroupAccessRightMutation) {
		m.oldValue = func(context.Context) (*SeatGroupAccessRight, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SeatGroupAccessRightMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SeatGroupAccessRightMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SeatGroupAccessRight entities.
func (m *SeatGroupAccessRightMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SeatGroupAccessRightMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SeatGroupAccessRightMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SeatGroupAccessRight.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SeatGroupAccessRightMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SeatGroupAccessRightMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SeatGroupAccessRight entity.
// If the SeatGroupAccessRight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatGroupAccessRightMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SeatGroupAccessRightMutation) ResetTenantID() {
	m.tenant = nil
}

// SetLevel sets the "level" field.
func (m *SeatGroupAccessRightMutation) SetLevel(s seatgroupaccessright.Level) {
	m.level = &s
}

// Level returns the value of the "level" field in the mutation.
func (m *SeatGroupAccessRightMutation) Level() (r seatgroupaccessright.Level, exists bool) {
	v := m.level
	if v == nil {
		return
	}
	return *v, true
}

// OldLevel returns the old "level" field's value of the SeatGroupAccessRight entity.
// If the SeatGroupAccessRight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatGroupAccessRightMutation) OldLevel(ctx context.Context) (v seatgroupaccessright.Level, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLevel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLevel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLevel: %w", err)
	}
	return oldValue.Level, nil
}

// ResetLevel resets all changes to the "level" field.
func (m *SeatGroupAccessRightMutation) ResetLevel() {
	m.level = nil
}

// SetAccessRightID sets the "access_right_id" field.
func (m *SeatGroupAccessRightMutation) SetAccessRightID(pu pulid.ID) {
	m.access_right = &pu
}

// AccessRightID returns the value of the "access_right_id" field in the mutation.
func (m *SeatGroupAccessRightMutation) AccessRightID() (r pulid.ID, exists bool) {
	v := m.access_right
	if v == nil {
		return
	}
	return *v, true
}

// OldAccessRightID returns the old "access_right_id" field's value of the SeatGroupAccessRight entity.
// If the SeatGroupAccessRight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatGroupAccessRightMutation) OldAccessRightID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccessRightID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccessRightID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccessRightID: %w", err)
	}
	return oldValue.AccessRightID, nil
}

// ResetAccessRightID resets all changes to the "access_right_id" field.
func (m *SeatGroupAccessRightMutation) ResetAccessRightID() {
	m.access_right = nil
}

// SetSeatGroupID sets the "seat_group_id" field.
func (m *SeatGroupAccessRightMutation) SetSeatGroupID(pu pulid.ID) {
	m.seat_group = &pu
}

// SeatGroupID returns the value of the "seat_group_id" field in the mutation.
func (m *SeatGroupAccessRightMutation) SeatGroupID() (r pulid.ID, exists bool) {
	v := m.seat_group
	if v == nil {
		return
	}
	return *v, true
}

// OldSeatGroupID returns the old "seat_group_id" field's value of the SeatGroupAccessRight entity.
// If the SeatGroupAccessRight object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SeatGroupAccessRightMutation) OldSeatGroupID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSeatGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSeatGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSeatGroupID: %w", err)
	}
	return oldValue.SeatGroupID, nil
}

// ResetSeatGroupID resets all changes to the "seat_group_id" field.
func (m *SeatGroupAccessRightMutation) ResetSeatGroupID() {
	m.seat_group = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SeatGroupAccessRightMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[seatgroupaccessright.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SeatGroupAccessRightMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SeatGroupAccessRightMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SeatGroupAccessRightMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearAccessRight clears the "access_right" edge to the AccessRight entity.
func (m *SeatGroupAccessRightMutation) ClearAccessRight() {
	m.clearedaccess_right = true
	m.clearedFields[seatgroupaccessright.FieldAccessRightID] = struct{}{}
}

// AccessRightCleared reports if the "access_right" edge to the AccessRight entity was cleared.
func (m *SeatGroupAccessRightMutation) AccessRightCleared() bool {
	return m.clearedaccess_right
}

// AccessRightIDs returns the "access_right" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccessRightID instead. It exists only for internal usage by the builders.
func (m *SeatGroupAccessRightMutation) AccessRightIDs() (ids []pulid.ID) {
	if id := m.access_right; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccessRight resets all changes to the "access_right" edge.
func (m *SeatGroupAccessRightMutation) ResetAccessRight() {
	m.access_right = nil
	m.clearedaccess_right = false
}

// ClearSeatGroup clears the "seat_group" edge to the SeatGroup entity.
func (m *SeatGroupAccessRightMutation) ClearSeatGroup() {
	m.clearedseat_group = true
	m.clearedFields[seatgroupaccessright.FieldSeatGroupID] = struct{}{}
}

// SeatGroupCleared reports if the "seat_group" edge to the SeatGroup entity was cleared.
func (m *SeatGroupAccessRightMutation) SeatGroupCleared() bool {
	return m.clearedseat_group
}

// SeatGroupIDs returns the "seat_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeatGroupID instead. It exists only for internal usage by the builders.
func (m *SeatGroupAccessRightMutation) SeatGroupIDs() (ids []pulid.ID) {
	if id := m.seat_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeatGroup resets all changes to the "seat_group" edge.
func (m *SeatGroupAccessRightMutation) ResetSeatGroup() {
	m.seat_group = nil
	m.clearedseat_group = false
}

// Where appends a list predicates to the SeatGroupAccessRightMutation builder.
func (m *SeatGroupAccessRightMutation) Where(ps ...predicate.SeatGroupAccessRight) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SeatGroupAccessRightMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SeatGroupAccessRightMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SeatGroupAccessRight, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SeatGroupAccessRightMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SeatGroupAccessRightMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SeatGroupAccessRight).
func (m *SeatGroupAccessRightMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SeatGroupAccessRightMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, seatgroupaccessright.FieldTenantID)
	}
	if m.level != nil {
		fields = append(fields, seatgroupaccessright.FieldLevel)
	}
	if m.access_right != nil {
		fields = append(fields, seatgroupaccessright.FieldAccessRightID)
	}
	if m.seat_group != nil {
		fields = append(fields, seatgroupaccessright.FieldSeatGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SeatGroupAccessRightMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case seatgroupaccessright.FieldTenantID:
		return m.TenantID()
	case seatgroupaccessright.FieldLevel:
		return m.Level()
	case seatgroupaccessright.FieldAccessRightID:
		return m.AccessRightID()
	case seatgroupaccessright.FieldSeatGroupID:
		return m.SeatGroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SeatGroupAccessRightMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case seatgroupaccessright.FieldTenantID:
		return m.OldTenantID(ctx)
	case seatgroupaccessright.FieldLevel:
		return m.OldLevel(ctx)
	case seatgroupaccessright.FieldAccessRightID:
		return m.OldAccessRightID(ctx)
	case seatgroupaccessright.FieldSeatGroupID:
		return m.OldSeatGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown SeatGroupAccessRight field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeatGroupAccessRightMutation) SetField(name string, value ent.Value) error {
	switch name {
	case seatgroupaccessright.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case seatgroupaccessright.FieldLevel:
		v, ok := value.(seatgroupaccessright.Level)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLevel(v)
		return nil
	case seatgroupaccessright.FieldAccessRightID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccessRightID(v)
		return nil
	case seatgroupaccessright.FieldSeatGroupID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSeatGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown SeatGroupAccessRight field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SeatGroupAccessRightMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SeatGroupAccessRightMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SeatGroupAccessRightMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SeatGroupAccessRight numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SeatGroupAccessRightMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SeatGroupAccessRightMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SeatGroupAccessRightMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SeatGroupAccessRight nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SeatGroupAccessRightMutation) ResetField(name string) error {
	switch name {
	case seatgroupaccessright.FieldTenantID:
		m.ResetTenantID()
		return nil
	case seatgroupaccessright.FieldLevel:
		m.ResetLevel()
		return nil
	case seatgroupaccessright.FieldAccessRightID:
		m.ResetAccessRightID()
		return nil
	case seatgroupaccessright.FieldSeatGroupID:
		m.ResetSeatGroupID()
		return nil
	}
	return fmt.Errorf("unknown SeatGroupAccessRight field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SeatGroupAccessRightMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, seatgroupaccessright.EdgeTenant)
	}
	if m.access_right != nil {
		edges = append(edges, seatgroupaccessright.EdgeAccessRight)
	}
	if m.seat_group != nil {
		edges = append(edges, seatgroupaccessright.EdgeSeatGroup)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SeatGroupAccessRightMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case seatgroupaccessright.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case seatgroupaccessright.EdgeAccessRight:
		if id := m.access_right; id != nil {
			return []ent.Value{*id}
		}
	case seatgroupaccessright.EdgeSeatGroup:
		if id := m.seat_group; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SeatGroupAccessRightMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SeatGroupAccessRightMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SeatGroupAccessRightMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, seatgroupaccessright.EdgeTenant)
	}
	if m.clearedaccess_right {
		edges = append(edges, seatgroupaccessright.EdgeAccessRight)
	}
	if m.clearedseat_group {
		edges = append(edges, seatgroupaccessright.EdgeSeatGroup)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SeatGroupAccessRightMutation) EdgeCleared(name string) bool {
	switch name {
	case seatgroupaccessright.EdgeTenant:
		return m.clearedtenant
	case seatgroupaccessright.EdgeAccessRight:
		return m.clearedaccess_right
	case seatgroupaccessright.EdgeSeatGroup:
		return m.clearedseat_group
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SeatGroupAccessRightMutation) ClearEdge(name string) error {
	switch name {
	case seatgroupaccessright.EdgeTenant:
		m.ClearTenant()
		return nil
	case seatgroupaccessright.EdgeAccessRight:
		m.ClearAccessRight()
		return nil
	case seatgroupaccessright.EdgeSeatGroup:
		m.ClearSeatGroup()
		return nil
	}
	return fmt.Errorf("unknown SeatGroupAccessRight unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SeatGroupAccessRightMutation) ResetEdge(name string) error {
	switch name {
	case seatgroupaccessright.EdgeTenant:
		m.ResetTenant()
		return nil
	case seatgroupaccessright.EdgeAccessRight:
		m.ResetAccessRight()
		return nil
	case seatgroupaccessright.EdgeSeatGroup:
		m.ResetSeatGroup()
		return nil
	}
	return fmt.Errorf("unknown SeatGroupAccessRight edge %s", name)
}

// ShipmentMutation represents an operation that mutates the Shipment nodes in the graph.
type ShipmentMutation struct {
	config
	op                        Op
	typ                       string
	id                        *pulid.ID
	shipment_public_id        *string
	created_at                *time.Time
	status                    *shipment.Status
	clearedFields             map[string]struct{}
	tenant                    *pulid.ID
	clearedtenant             bool
	carrier                   *pulid.ID
	clearedcarrier            bool
	shipment_history          map[pulid.ID]struct{}
	removedshipment_history   map[pulid.ID]struct{}
	clearedshipment_history   bool
	shipment_bring            *pulid.ID
	clearedshipment_bring     bool
	shipment_dao              *pulid.ID
	clearedshipment_dao       bool
	shipment_df               *pulid.ID
	clearedshipment_df        bool
	shipment_dsv              *pulid.ID
	clearedshipment_dsv       bool
	shipment_easy_post        *pulid.ID
	clearedshipment_easy_post bool
	shipment_post_nord        *pulid.ID
	clearedshipment_post_nord bool
	shipment_gls              *pulid.ID
	clearedshipment_gls       bool
	shipment_usps             *pulid.ID
	clearedshipment_usps      bool
	consolidation             *pulid.ID
	clearedconsolidation      bool
	old_consolidation         map[pulid.ID]struct{}
	removedold_consolidation  map[pulid.ID]struct{}
	clearedold_consolidation  bool
	shipment_parcel           map[pulid.ID]struct{}
	removedshipment_parcel    map[pulid.ID]struct{}
	clearedshipment_parcel    bool
	shipment_pallet           map[pulid.ID]struct{}
	removedshipment_pallet    map[pulid.ID]struct{}
	clearedshipment_pallet    bool
	done                      bool
	oldValue                  func(context.Context) (*Shipment, error)
	predicates                []predicate.Shipment
}

var _ ent.Mutation = (*ShipmentMutation)(nil)

// shipmentOption allows management of the mutation configuration using functional options.
type shipmentOption func(*ShipmentMutation)

// newShipmentMutation creates new mutation for the Shipment entity.
func newShipmentMutation(c config, op Op, opts ...shipmentOption) *ShipmentMutation {
	m := &ShipmentMutation{
		config:        c,
		op:            op,
		typ:           TypeShipment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentID sets the ID field of the mutation.
func withShipmentID(id pulid.ID) shipmentOption {
	return func(m *ShipmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Shipment
		)
		m.oldValue = func(ctx context.Context) (*Shipment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Shipment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipment sets the old Shipment of the mutation.
func withShipment(node *Shipment) shipmentOption {
	return func(m *ShipmentMutation) {
		m.oldValue = func(context.Context) (*Shipment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Shipment entities.
func (m *ShipmentMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Shipment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentMutation) ResetTenantID() {
	m.tenant = nil
}

// SetShipmentPublicID sets the "shipment_public_id" field.
func (m *ShipmentMutation) SetShipmentPublicID(s string) {
	m.shipment_public_id = &s
}

// ShipmentPublicID returns the value of the "shipment_public_id" field in the mutation.
func (m *ShipmentMutation) ShipmentPublicID() (r string, exists bool) {
	v := m.shipment_public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentPublicID returns the old "shipment_public_id" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldShipmentPublicID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentPublicID: %w", err)
	}
	return oldValue.ShipmentPublicID, nil
}

// ResetShipmentPublicID resets all changes to the "shipment_public_id" field.
func (m *ShipmentMutation) ResetShipmentPublicID() {
	m.shipment_public_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ShipmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ShipmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ShipmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetStatus sets the "status" field.
func (m *ShipmentMutation) SetStatus(s shipment.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ShipmentMutation) Status() (r shipment.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Shipment entity.
// If the Shipment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentMutation) OldStatus(ctx context.Context) (v shipment.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ShipmentMutation) ResetStatus() {
	m.status = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipment.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetCarrierID sets the "carrier" edge to the Carrier entity by id.
func (m *ShipmentMutation) SetCarrierID(id pulid.ID) {
	m.carrier = &id
}

// ClearCarrier clears the "carrier" edge to the Carrier entity.
func (m *ShipmentMutation) ClearCarrier() {
	m.clearedcarrier = true
}

// CarrierCleared reports if the "carrier" edge to the Carrier entity was cleared.
func (m *ShipmentMutation) CarrierCleared() bool {
	return m.clearedcarrier
}

// CarrierID returns the "carrier" edge ID in the mutation.
func (m *ShipmentMutation) CarrierID() (id pulid.ID, exists bool) {
	if m.carrier != nil {
		return *m.carrier, true
	}
	return
}

// CarrierIDs returns the "carrier" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CarrierID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) CarrierIDs() (ids []pulid.ID) {
	if id := m.carrier; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCarrier resets all changes to the "carrier" edge.
func (m *ShipmentMutation) ResetCarrier() {
	m.carrier = nil
	m.clearedcarrier = false
}

// AddShipmentHistoryIDs adds the "shipment_history" edge to the ShipmentHistory entity by ids.
func (m *ShipmentMutation) AddShipmentHistoryIDs(ids ...pulid.ID) {
	if m.shipment_history == nil {
		m.shipment_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.shipment_history[ids[i]] = struct{}{}
	}
}

// ClearShipmentHistory clears the "shipment_history" edge to the ShipmentHistory entity.
func (m *ShipmentMutation) ClearShipmentHistory() {
	m.clearedshipment_history = true
}

// ShipmentHistoryCleared reports if the "shipment_history" edge to the ShipmentHistory entity was cleared.
func (m *ShipmentMutation) ShipmentHistoryCleared() bool {
	return m.clearedshipment_history
}

// RemoveShipmentHistoryIDs removes the "shipment_history" edge to the ShipmentHistory entity by IDs.
func (m *ShipmentMutation) RemoveShipmentHistoryIDs(ids ...pulid.ID) {
	if m.removedshipment_history == nil {
		m.removedshipment_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.shipment_history, ids[i])
		m.removedshipment_history[ids[i]] = struct{}{}
	}
}

// RemovedShipmentHistory returns the removed IDs of the "shipment_history" edge to the ShipmentHistory entity.
func (m *ShipmentMutation) RemovedShipmentHistoryIDs() (ids []pulid.ID) {
	for id := range m.removedshipment_history {
		ids = append(ids, id)
	}
	return
}

// ShipmentHistoryIDs returns the "shipment_history" edge IDs in the mutation.
func (m *ShipmentMutation) ShipmentHistoryIDs() (ids []pulid.ID) {
	for id := range m.shipment_history {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentHistory resets all changes to the "shipment_history" edge.
func (m *ShipmentMutation) ResetShipmentHistory() {
	m.shipment_history = nil
	m.clearedshipment_history = false
	m.removedshipment_history = nil
}

// SetShipmentBringID sets the "shipment_bring" edge to the ShipmentBring entity by id.
func (m *ShipmentMutation) SetShipmentBringID(id pulid.ID) {
	m.shipment_bring = &id
}

// ClearShipmentBring clears the "shipment_bring" edge to the ShipmentBring entity.
func (m *ShipmentMutation) ClearShipmentBring() {
	m.clearedshipment_bring = true
}

// ShipmentBringCleared reports if the "shipment_bring" edge to the ShipmentBring entity was cleared.
func (m *ShipmentMutation) ShipmentBringCleared() bool {
	return m.clearedshipment_bring
}

// ShipmentBringID returns the "shipment_bring" edge ID in the mutation.
func (m *ShipmentMutation) ShipmentBringID() (id pulid.ID, exists bool) {
	if m.shipment_bring != nil {
		return *m.shipment_bring, true
	}
	return
}

// ShipmentBringIDs returns the "shipment_bring" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentBringID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ShipmentBringIDs() (ids []pulid.ID) {
	if id := m.shipment_bring; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentBring resets all changes to the "shipment_bring" edge.
func (m *ShipmentMutation) ResetShipmentBring() {
	m.shipment_bring = nil
	m.clearedshipment_bring = false
}

// SetShipmentDAOID sets the "shipment_dao" edge to the ShipmentDAO entity by id.
func (m *ShipmentMutation) SetShipmentDAOID(id pulid.ID) {
	m.shipment_dao = &id
}

// ClearShipmentDAO clears the "shipment_dao" edge to the ShipmentDAO entity.
func (m *ShipmentMutation) ClearShipmentDAO() {
	m.clearedshipment_dao = true
}

// ShipmentDAOCleared reports if the "shipment_dao" edge to the ShipmentDAO entity was cleared.
func (m *ShipmentMutation) ShipmentDAOCleared() bool {
	return m.clearedshipment_dao
}

// ShipmentDAOID returns the "shipment_dao" edge ID in the mutation.
func (m *ShipmentMutation) ShipmentDAOID() (id pulid.ID, exists bool) {
	if m.shipment_dao != nil {
		return *m.shipment_dao, true
	}
	return
}

// ShipmentDAOIDs returns the "shipment_dao" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentDAOID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ShipmentDAOIDs() (ids []pulid.ID) {
	if id := m.shipment_dao; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentDAO resets all changes to the "shipment_dao" edge.
func (m *ShipmentMutation) ResetShipmentDAO() {
	m.shipment_dao = nil
	m.clearedshipment_dao = false
}

// SetShipmentDFID sets the "shipment_df" edge to the ShipmentDF entity by id.
func (m *ShipmentMutation) SetShipmentDFID(id pulid.ID) {
	m.shipment_df = &id
}

// ClearShipmentDF clears the "shipment_df" edge to the ShipmentDF entity.
func (m *ShipmentMutation) ClearShipmentDF() {
	m.clearedshipment_df = true
}

// ShipmentDFCleared reports if the "shipment_df" edge to the ShipmentDF entity was cleared.
func (m *ShipmentMutation) ShipmentDFCleared() bool {
	return m.clearedshipment_df
}

// ShipmentDFID returns the "shipment_df" edge ID in the mutation.
func (m *ShipmentMutation) ShipmentDFID() (id pulid.ID, exists bool) {
	if m.shipment_df != nil {
		return *m.shipment_df, true
	}
	return
}

// ShipmentDFIDs returns the "shipment_df" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentDFID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ShipmentDFIDs() (ids []pulid.ID) {
	if id := m.shipment_df; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentDF resets all changes to the "shipment_df" edge.
func (m *ShipmentMutation) ResetShipmentDF() {
	m.shipment_df = nil
	m.clearedshipment_df = false
}

// SetShipmentDSVID sets the "shipment_dsv" edge to the ShipmentDSV entity by id.
func (m *ShipmentMutation) SetShipmentDSVID(id pulid.ID) {
	m.shipment_dsv = &id
}

// ClearShipmentDSV clears the "shipment_dsv" edge to the ShipmentDSV entity.
func (m *ShipmentMutation) ClearShipmentDSV() {
	m.clearedshipment_dsv = true
}

// ShipmentDSVCleared reports if the "shipment_dsv" edge to the ShipmentDSV entity was cleared.
func (m *ShipmentMutation) ShipmentDSVCleared() bool {
	return m.clearedshipment_dsv
}

// ShipmentDSVID returns the "shipment_dsv" edge ID in the mutation.
func (m *ShipmentMutation) ShipmentDSVID() (id pulid.ID, exists bool) {
	if m.shipment_dsv != nil {
		return *m.shipment_dsv, true
	}
	return
}

// ShipmentDSVIDs returns the "shipment_dsv" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentDSVID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ShipmentDSVIDs() (ids []pulid.ID) {
	if id := m.shipment_dsv; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentDSV resets all changes to the "shipment_dsv" edge.
func (m *ShipmentMutation) ResetShipmentDSV() {
	m.shipment_dsv = nil
	m.clearedshipment_dsv = false
}

// SetShipmentEasyPostID sets the "shipment_easy_post" edge to the ShipmentEasyPost entity by id.
func (m *ShipmentMutation) SetShipmentEasyPostID(id pulid.ID) {
	m.shipment_easy_post = &id
}

// ClearShipmentEasyPost clears the "shipment_easy_post" edge to the ShipmentEasyPost entity.
func (m *ShipmentMutation) ClearShipmentEasyPost() {
	m.clearedshipment_easy_post = true
}

// ShipmentEasyPostCleared reports if the "shipment_easy_post" edge to the ShipmentEasyPost entity was cleared.
func (m *ShipmentMutation) ShipmentEasyPostCleared() bool {
	return m.clearedshipment_easy_post
}

// ShipmentEasyPostID returns the "shipment_easy_post" edge ID in the mutation.
func (m *ShipmentMutation) ShipmentEasyPostID() (id pulid.ID, exists bool) {
	if m.shipment_easy_post != nil {
		return *m.shipment_easy_post, true
	}
	return
}

// ShipmentEasyPostIDs returns the "shipment_easy_post" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentEasyPostID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ShipmentEasyPostIDs() (ids []pulid.ID) {
	if id := m.shipment_easy_post; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentEasyPost resets all changes to the "shipment_easy_post" edge.
func (m *ShipmentMutation) ResetShipmentEasyPost() {
	m.shipment_easy_post = nil
	m.clearedshipment_easy_post = false
}

// SetShipmentPostNordID sets the "shipment_post_nord" edge to the ShipmentPostNord entity by id.
func (m *ShipmentMutation) SetShipmentPostNordID(id pulid.ID) {
	m.shipment_post_nord = &id
}

// ClearShipmentPostNord clears the "shipment_post_nord" edge to the ShipmentPostNord entity.
func (m *ShipmentMutation) ClearShipmentPostNord() {
	m.clearedshipment_post_nord = true
}

// ShipmentPostNordCleared reports if the "shipment_post_nord" edge to the ShipmentPostNord entity was cleared.
func (m *ShipmentMutation) ShipmentPostNordCleared() bool {
	return m.clearedshipment_post_nord
}

// ShipmentPostNordID returns the "shipment_post_nord" edge ID in the mutation.
func (m *ShipmentMutation) ShipmentPostNordID() (id pulid.ID, exists bool) {
	if m.shipment_post_nord != nil {
		return *m.shipment_post_nord, true
	}
	return
}

// ShipmentPostNordIDs returns the "shipment_post_nord" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentPostNordID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ShipmentPostNordIDs() (ids []pulid.ID) {
	if id := m.shipment_post_nord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentPostNord resets all changes to the "shipment_post_nord" edge.
func (m *ShipmentMutation) ResetShipmentPostNord() {
	m.shipment_post_nord = nil
	m.clearedshipment_post_nord = false
}

// SetShipmentGLSID sets the "shipment_gls" edge to the ShipmentGLS entity by id.
func (m *ShipmentMutation) SetShipmentGLSID(id pulid.ID) {
	m.shipment_gls = &id
}

// ClearShipmentGLS clears the "shipment_gls" edge to the ShipmentGLS entity.
func (m *ShipmentMutation) ClearShipmentGLS() {
	m.clearedshipment_gls = true
}

// ShipmentGLSCleared reports if the "shipment_gls" edge to the ShipmentGLS entity was cleared.
func (m *ShipmentMutation) ShipmentGLSCleared() bool {
	return m.clearedshipment_gls
}

// ShipmentGLSID returns the "shipment_gls" edge ID in the mutation.
func (m *ShipmentMutation) ShipmentGLSID() (id pulid.ID, exists bool) {
	if m.shipment_gls != nil {
		return *m.shipment_gls, true
	}
	return
}

// ShipmentGLSIDs returns the "shipment_gls" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentGLSID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ShipmentGLSIDs() (ids []pulid.ID) {
	if id := m.shipment_gls; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentGLS resets all changes to the "shipment_gls" edge.
func (m *ShipmentMutation) ResetShipmentGLS() {
	m.shipment_gls = nil
	m.clearedshipment_gls = false
}

// SetShipmentUSPSID sets the "shipment_usps" edge to the ShipmentUSPS entity by id.
func (m *ShipmentMutation) SetShipmentUSPSID(id pulid.ID) {
	m.shipment_usps = &id
}

// ClearShipmentUSPS clears the "shipment_usps" edge to the ShipmentUSPS entity.
func (m *ShipmentMutation) ClearShipmentUSPS() {
	m.clearedshipment_usps = true
}

// ShipmentUSPSCleared reports if the "shipment_usps" edge to the ShipmentUSPS entity was cleared.
func (m *ShipmentMutation) ShipmentUSPSCleared() bool {
	return m.clearedshipment_usps
}

// ShipmentUSPSID returns the "shipment_usps" edge ID in the mutation.
func (m *ShipmentMutation) ShipmentUSPSID() (id pulid.ID, exists bool) {
	if m.shipment_usps != nil {
		return *m.shipment_usps, true
	}
	return
}

// ShipmentUSPSIDs returns the "shipment_usps" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentUSPSID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ShipmentUSPSIDs() (ids []pulid.ID) {
	if id := m.shipment_usps; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentUSPS resets all changes to the "shipment_usps" edge.
func (m *ShipmentMutation) ResetShipmentUSPS() {
	m.shipment_usps = nil
	m.clearedshipment_usps = false
}

// SetConsolidationID sets the "consolidation" edge to the Consolidation entity by id.
func (m *ShipmentMutation) SetConsolidationID(id pulid.ID) {
	m.consolidation = &id
}

// ClearConsolidation clears the "consolidation" edge to the Consolidation entity.
func (m *ShipmentMutation) ClearConsolidation() {
	m.clearedconsolidation = true
}

// ConsolidationCleared reports if the "consolidation" edge to the Consolidation entity was cleared.
func (m *ShipmentMutation) ConsolidationCleared() bool {
	return m.clearedconsolidation
}

// ConsolidationID returns the "consolidation" edge ID in the mutation.
func (m *ShipmentMutation) ConsolidationID() (id pulid.ID, exists bool) {
	if m.consolidation != nil {
		return *m.consolidation, true
	}
	return
}

// ConsolidationIDs returns the "consolidation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ConsolidationID instead. It exists only for internal usage by the builders.
func (m *ShipmentMutation) ConsolidationIDs() (ids []pulid.ID) {
	if id := m.consolidation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetConsolidation resets all changes to the "consolidation" edge.
func (m *ShipmentMutation) ResetConsolidation() {
	m.consolidation = nil
	m.clearedconsolidation = false
}

// AddOldConsolidationIDs adds the "old_consolidation" edge to the Consolidation entity by ids.
func (m *ShipmentMutation) AddOldConsolidationIDs(ids ...pulid.ID) {
	if m.old_consolidation == nil {
		m.old_consolidation = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.old_consolidation[ids[i]] = struct{}{}
	}
}

// ClearOldConsolidation clears the "old_consolidation" edge to the Consolidation entity.
func (m *ShipmentMutation) ClearOldConsolidation() {
	m.clearedold_consolidation = true
}

// OldConsolidationCleared reports if the "old_consolidation" edge to the Consolidation entity was cleared.
func (m *ShipmentMutation) OldConsolidationCleared() bool {
	return m.clearedold_consolidation
}

// RemoveOldConsolidationIDs removes the "old_consolidation" edge to the Consolidation entity by IDs.
func (m *ShipmentMutation) RemoveOldConsolidationIDs(ids ...pulid.ID) {
	if m.removedold_consolidation == nil {
		m.removedold_consolidation = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.old_consolidation, ids[i])
		m.removedold_consolidation[ids[i]] = struct{}{}
	}
}

// RemovedOldConsolidation returns the removed IDs of the "old_consolidation" edge to the Consolidation entity.
func (m *ShipmentMutation) RemovedOldConsolidationIDs() (ids []pulid.ID) {
	for id := range m.removedold_consolidation {
		ids = append(ids, id)
	}
	return
}

// OldConsolidationIDs returns the "old_consolidation" edge IDs in the mutation.
func (m *ShipmentMutation) OldConsolidationIDs() (ids []pulid.ID) {
	for id := range m.old_consolidation {
		ids = append(ids, id)
	}
	return
}

// ResetOldConsolidation resets all changes to the "old_consolidation" edge.
func (m *ShipmentMutation) ResetOldConsolidation() {
	m.old_consolidation = nil
	m.clearedold_consolidation = false
	m.removedold_consolidation = nil
}

// AddShipmentParcelIDs adds the "shipment_parcel" edge to the ShipmentParcel entity by ids.
func (m *ShipmentMutation) AddShipmentParcelIDs(ids ...pulid.ID) {
	if m.shipment_parcel == nil {
		m.shipment_parcel = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.shipment_parcel[ids[i]] = struct{}{}
	}
}

// ClearShipmentParcel clears the "shipment_parcel" edge to the ShipmentParcel entity.
func (m *ShipmentMutation) ClearShipmentParcel() {
	m.clearedshipment_parcel = true
}

// ShipmentParcelCleared reports if the "shipment_parcel" edge to the ShipmentParcel entity was cleared.
func (m *ShipmentMutation) ShipmentParcelCleared() bool {
	return m.clearedshipment_parcel
}

// RemoveShipmentParcelIDs removes the "shipment_parcel" edge to the ShipmentParcel entity by IDs.
func (m *ShipmentMutation) RemoveShipmentParcelIDs(ids ...pulid.ID) {
	if m.removedshipment_parcel == nil {
		m.removedshipment_parcel = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.shipment_parcel, ids[i])
		m.removedshipment_parcel[ids[i]] = struct{}{}
	}
}

// RemovedShipmentParcel returns the removed IDs of the "shipment_parcel" edge to the ShipmentParcel entity.
func (m *ShipmentMutation) RemovedShipmentParcelIDs() (ids []pulid.ID) {
	for id := range m.removedshipment_parcel {
		ids = append(ids, id)
	}
	return
}

// ShipmentParcelIDs returns the "shipment_parcel" edge IDs in the mutation.
func (m *ShipmentMutation) ShipmentParcelIDs() (ids []pulid.ID) {
	for id := range m.shipment_parcel {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentParcel resets all changes to the "shipment_parcel" edge.
func (m *ShipmentMutation) ResetShipmentParcel() {
	m.shipment_parcel = nil
	m.clearedshipment_parcel = false
	m.removedshipment_parcel = nil
}

// AddShipmentPalletIDs adds the "shipment_pallet" edge to the ShipmentPallet entity by ids.
func (m *ShipmentMutation) AddShipmentPalletIDs(ids ...pulid.ID) {
	if m.shipment_pallet == nil {
		m.shipment_pallet = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.shipment_pallet[ids[i]] = struct{}{}
	}
}

// ClearShipmentPallet clears the "shipment_pallet" edge to the ShipmentPallet entity.
func (m *ShipmentMutation) ClearShipmentPallet() {
	m.clearedshipment_pallet = true
}

// ShipmentPalletCleared reports if the "shipment_pallet" edge to the ShipmentPallet entity was cleared.
func (m *ShipmentMutation) ShipmentPalletCleared() bool {
	return m.clearedshipment_pallet
}

// RemoveShipmentPalletIDs removes the "shipment_pallet" edge to the ShipmentPallet entity by IDs.
func (m *ShipmentMutation) RemoveShipmentPalletIDs(ids ...pulid.ID) {
	if m.removedshipment_pallet == nil {
		m.removedshipment_pallet = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.shipment_pallet, ids[i])
		m.removedshipment_pallet[ids[i]] = struct{}{}
	}
}

// RemovedShipmentPallet returns the removed IDs of the "shipment_pallet" edge to the ShipmentPallet entity.
func (m *ShipmentMutation) RemovedShipmentPalletIDs() (ids []pulid.ID) {
	for id := range m.removedshipment_pallet {
		ids = append(ids, id)
	}
	return
}

// ShipmentPalletIDs returns the "shipment_pallet" edge IDs in the mutation.
func (m *ShipmentMutation) ShipmentPalletIDs() (ids []pulid.ID) {
	for id := range m.shipment_pallet {
		ids = append(ids, id)
	}
	return
}

// ResetShipmentPallet resets all changes to the "shipment_pallet" edge.
func (m *ShipmentMutation) ResetShipmentPallet() {
	m.shipment_pallet = nil
	m.clearedshipment_pallet = false
	m.removedshipment_pallet = nil
}

// Where appends a list predicates to the ShipmentMutation builder.
func (m *ShipmentMutation) Where(ps ...predicate.Shipment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Shipment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Shipment).
func (m *ShipmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, shipment.FieldTenantID)
	}
	if m.shipment_public_id != nil {
		fields = append(fields, shipment.FieldShipmentPublicID)
	}
	if m.created_at != nil {
		fields = append(fields, shipment.FieldCreatedAt)
	}
	if m.status != nil {
		fields = append(fields, shipment.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipment.FieldTenantID:
		return m.TenantID()
	case shipment.FieldShipmentPublicID:
		return m.ShipmentPublicID()
	case shipment.FieldCreatedAt:
		return m.CreatedAt()
	case shipment.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipment.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipment.FieldShipmentPublicID:
		return m.OldShipmentPublicID(ctx)
	case shipment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case shipment.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Shipment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipment.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipment.FieldShipmentPublicID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentPublicID(v)
		return nil
	case shipment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case shipment.FieldStatus:
		v, ok := value.(shipment.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Shipment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Shipment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Shipment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentMutation) ResetField(name string) error {
	switch name {
	case shipment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipment.FieldShipmentPublicID:
		m.ResetShipmentPublicID()
		return nil
	case shipment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case shipment.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Shipment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 15)
	if m.tenant != nil {
		edges = append(edges, shipment.EdgeTenant)
	}
	if m.carrier != nil {
		edges = append(edges, shipment.EdgeCarrier)
	}
	if m.shipment_history != nil {
		edges = append(edges, shipment.EdgeShipmentHistory)
	}
	if m.shipment_bring != nil {
		edges = append(edges, shipment.EdgeShipmentBring)
	}
	if m.shipment_dao != nil {
		edges = append(edges, shipment.EdgeShipmentDAO)
	}
	if m.shipment_df != nil {
		edges = append(edges, shipment.EdgeShipmentDF)
	}
	if m.shipment_dsv != nil {
		edges = append(edges, shipment.EdgeShipmentDSV)
	}
	if m.shipment_easy_post != nil {
		edges = append(edges, shipment.EdgeShipmentEasyPost)
	}
	if m.shipment_post_nord != nil {
		edges = append(edges, shipment.EdgeShipmentPostNord)
	}
	if m.shipment_gls != nil {
		edges = append(edges, shipment.EdgeShipmentGLS)
	}
	if m.shipment_usps != nil {
		edges = append(edges, shipment.EdgeShipmentUSPS)
	}
	if m.consolidation != nil {
		edges = append(edges, shipment.EdgeConsolidation)
	}
	if m.old_consolidation != nil {
		edges = append(edges, shipment.EdgeOldConsolidation)
	}
	if m.shipment_parcel != nil {
		edges = append(edges, shipment.EdgeShipmentParcel)
	}
	if m.shipment_pallet != nil {
		edges = append(edges, shipment.EdgeShipmentPallet)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipment.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeCarrier:
		if id := m.carrier; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentHistory:
		ids := make([]ent.Value, 0, len(m.shipment_history))
		for id := range m.shipment_history {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentBring:
		if id := m.shipment_bring; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentDAO:
		if id := m.shipment_dao; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentDF:
		if id := m.shipment_df; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentDSV:
		if id := m.shipment_dsv; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentEasyPost:
		if id := m.shipment_easy_post; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentPostNord:
		if id := m.shipment_post_nord; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentGLS:
		if id := m.shipment_gls; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeShipmentUSPS:
		if id := m.shipment_usps; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeConsolidation:
		if id := m.consolidation; id != nil {
			return []ent.Value{*id}
		}
	case shipment.EdgeOldConsolidation:
		ids := make([]ent.Value, 0, len(m.old_consolidation))
		for id := range m.old_consolidation {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentParcel:
		ids := make([]ent.Value, 0, len(m.shipment_parcel))
		for id := range m.shipment_parcel {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentPallet:
		ids := make([]ent.Value, 0, len(m.shipment_pallet))
		for id := range m.shipment_pallet {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 15)
	if m.removedshipment_history != nil {
		edges = append(edges, shipment.EdgeShipmentHistory)
	}
	if m.removedold_consolidation != nil {
		edges = append(edges, shipment.EdgeOldConsolidation)
	}
	if m.removedshipment_parcel != nil {
		edges = append(edges, shipment.EdgeShipmentParcel)
	}
	if m.removedshipment_pallet != nil {
		edges = append(edges, shipment.EdgeShipmentPallet)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shipment.EdgeShipmentHistory:
		ids := make([]ent.Value, 0, len(m.removedshipment_history))
		for id := range m.removedshipment_history {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeOldConsolidation:
		ids := make([]ent.Value, 0, len(m.removedold_consolidation))
		for id := range m.removedold_consolidation {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentParcel:
		ids := make([]ent.Value, 0, len(m.removedshipment_parcel))
		for id := range m.removedshipment_parcel {
			ids = append(ids, id)
		}
		return ids
	case shipment.EdgeShipmentPallet:
		ids := make([]ent.Value, 0, len(m.removedshipment_pallet))
		for id := range m.removedshipment_pallet {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 15)
	if m.clearedtenant {
		edges = append(edges, shipment.EdgeTenant)
	}
	if m.clearedcarrier {
		edges = append(edges, shipment.EdgeCarrier)
	}
	if m.clearedshipment_history {
		edges = append(edges, shipment.EdgeShipmentHistory)
	}
	if m.clearedshipment_bring {
		edges = append(edges, shipment.EdgeShipmentBring)
	}
	if m.clearedshipment_dao {
		edges = append(edges, shipment.EdgeShipmentDAO)
	}
	if m.clearedshipment_df {
		edges = append(edges, shipment.EdgeShipmentDF)
	}
	if m.clearedshipment_dsv {
		edges = append(edges, shipment.EdgeShipmentDSV)
	}
	if m.clearedshipment_easy_post {
		edges = append(edges, shipment.EdgeShipmentEasyPost)
	}
	if m.clearedshipment_post_nord {
		edges = append(edges, shipment.EdgeShipmentPostNord)
	}
	if m.clearedshipment_gls {
		edges = append(edges, shipment.EdgeShipmentGLS)
	}
	if m.clearedshipment_usps {
		edges = append(edges, shipment.EdgeShipmentUSPS)
	}
	if m.clearedconsolidation {
		edges = append(edges, shipment.EdgeConsolidation)
	}
	if m.clearedold_consolidation {
		edges = append(edges, shipment.EdgeOldConsolidation)
	}
	if m.clearedshipment_parcel {
		edges = append(edges, shipment.EdgeShipmentParcel)
	}
	if m.clearedshipment_pallet {
		edges = append(edges, shipment.EdgeShipmentPallet)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentMutation) EdgeCleared(name string) bool {
	switch name {
	case shipment.EdgeTenant:
		return m.clearedtenant
	case shipment.EdgeCarrier:
		return m.clearedcarrier
	case shipment.EdgeShipmentHistory:
		return m.clearedshipment_history
	case shipment.EdgeShipmentBring:
		return m.clearedshipment_bring
	case shipment.EdgeShipmentDAO:
		return m.clearedshipment_dao
	case shipment.EdgeShipmentDF:
		return m.clearedshipment_df
	case shipment.EdgeShipmentDSV:
		return m.clearedshipment_dsv
	case shipment.EdgeShipmentEasyPost:
		return m.clearedshipment_easy_post
	case shipment.EdgeShipmentPostNord:
		return m.clearedshipment_post_nord
	case shipment.EdgeShipmentGLS:
		return m.clearedshipment_gls
	case shipment.EdgeShipmentUSPS:
		return m.clearedshipment_usps
	case shipment.EdgeConsolidation:
		return m.clearedconsolidation
	case shipment.EdgeOldConsolidation:
		return m.clearedold_consolidation
	case shipment.EdgeShipmentParcel:
		return m.clearedshipment_parcel
	case shipment.EdgeShipmentPallet:
		return m.clearedshipment_pallet
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentMutation) ClearEdge(name string) error {
	switch name {
	case shipment.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipment.EdgeCarrier:
		m.ClearCarrier()
		return nil
	case shipment.EdgeShipmentBring:
		m.ClearShipmentBring()
		return nil
	case shipment.EdgeShipmentDAO:
		m.ClearShipmentDAO()
		return nil
	case shipment.EdgeShipmentDF:
		m.ClearShipmentDF()
		return nil
	case shipment.EdgeShipmentDSV:
		m.ClearShipmentDSV()
		return nil
	case shipment.EdgeShipmentEasyPost:
		m.ClearShipmentEasyPost()
		return nil
	case shipment.EdgeShipmentPostNord:
		m.ClearShipmentPostNord()
		return nil
	case shipment.EdgeShipmentGLS:
		m.ClearShipmentGLS()
		return nil
	case shipment.EdgeShipmentUSPS:
		m.ClearShipmentUSPS()
		return nil
	case shipment.EdgeConsolidation:
		m.ClearConsolidation()
		return nil
	}
	return fmt.Errorf("unknown Shipment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentMutation) ResetEdge(name string) error {
	switch name {
	case shipment.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipment.EdgeCarrier:
		m.ResetCarrier()
		return nil
	case shipment.EdgeShipmentHistory:
		m.ResetShipmentHistory()
		return nil
	case shipment.EdgeShipmentBring:
		m.ResetShipmentBring()
		return nil
	case shipment.EdgeShipmentDAO:
		m.ResetShipmentDAO()
		return nil
	case shipment.EdgeShipmentDF:
		m.ResetShipmentDF()
		return nil
	case shipment.EdgeShipmentDSV:
		m.ResetShipmentDSV()
		return nil
	case shipment.EdgeShipmentEasyPost:
		m.ResetShipmentEasyPost()
		return nil
	case shipment.EdgeShipmentPostNord:
		m.ResetShipmentPostNord()
		return nil
	case shipment.EdgeShipmentGLS:
		m.ResetShipmentGLS()
		return nil
	case shipment.EdgeShipmentUSPS:
		m.ResetShipmentUSPS()
		return nil
	case shipment.EdgeConsolidation:
		m.ResetConsolidation()
		return nil
	case shipment.EdgeOldConsolidation:
		m.ResetOldConsolidation()
		return nil
	case shipment.EdgeShipmentParcel:
		m.ResetShipmentParcel()
		return nil
	case shipment.EdgeShipmentPallet:
		m.ResetShipmentPallet()
		return nil
	}
	return fmt.Errorf("unknown Shipment edge %s", name)
}

// ShipmentBringMutation represents an operation that mutates the ShipmentBring nodes in the graph.
type ShipmentBringMutation struct {
	config
	op                 Op
	typ                string
	id                 *pulid.ID
	consignment_number *string
	clearedFields      map[string]struct{}
	tenant             *pulid.ID
	clearedtenant      bool
	shipment           *pulid.ID
	clearedshipment    bool
	done               bool
	oldValue           func(context.Context) (*ShipmentBring, error)
	predicates         []predicate.ShipmentBring
}

var _ ent.Mutation = (*ShipmentBringMutation)(nil)

// shipmentbringOption allows management of the mutation configuration using functional options.
type shipmentbringOption func(*ShipmentBringMutation)

// newShipmentBringMutation creates new mutation for the ShipmentBring entity.
func newShipmentBringMutation(c config, op Op, opts ...shipmentbringOption) *ShipmentBringMutation {
	m := &ShipmentBringMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentBring,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentBringID sets the ID field of the mutation.
func withShipmentBringID(id pulid.ID) shipmentbringOption {
	return func(m *ShipmentBringMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentBring
		)
		m.oldValue = func(ctx context.Context) (*ShipmentBring, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentBring.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentBring sets the old ShipmentBring of the mutation.
func withShipmentBring(node *ShipmentBring) shipmentbringOption {
	return func(m *ShipmentBringMutation) {
		m.oldValue = func(context.Context) (*ShipmentBring, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentBringMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentBringMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentBring entities.
func (m *ShipmentBringMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentBringMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentBringMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentBring.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentBringMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentBringMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentBring entity.
// If the ShipmentBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentBringMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentBringMutation) ResetTenantID() {
	m.tenant = nil
}

// SetConsignmentNumber sets the "consignment_number" field.
func (m *ShipmentBringMutation) SetConsignmentNumber(s string) {
	m.consignment_number = &s
}

// ConsignmentNumber returns the value of the "consignment_number" field in the mutation.
func (m *ShipmentBringMutation) ConsignmentNumber() (r string, exists bool) {
	v := m.consignment_number
	if v == nil {
		return
	}
	return *v, true
}

// OldConsignmentNumber returns the old "consignment_number" field's value of the ShipmentBring entity.
// If the ShipmentBring object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentBringMutation) OldConsignmentNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsignmentNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsignmentNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsignmentNumber: %w", err)
	}
	return oldValue.ConsignmentNumber, nil
}

// ResetConsignmentNumber resets all changes to the "consignment_number" field.
func (m *ShipmentBringMutation) ResetConsignmentNumber() {
	m.consignment_number = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentBringMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmentbring.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentBringMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentBringMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentBringMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentBringMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentBringMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentBringMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentBringMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentBringMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentBringMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentBringMutation builder.
func (m *ShipmentBringMutation) Where(ps ...predicate.ShipmentBring) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentBringMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentBringMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentBring, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentBringMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentBringMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentBring).
func (m *ShipmentBringMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentBringMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, shipmentbring.FieldTenantID)
	}
	if m.consignment_number != nil {
		fields = append(fields, shipmentbring.FieldConsignmentNumber)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentBringMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentbring.FieldTenantID:
		return m.TenantID()
	case shipmentbring.FieldConsignmentNumber:
		return m.ConsignmentNumber()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentBringMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentbring.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipmentbring.FieldConsignmentNumber:
		return m.OldConsignmentNumber(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentBring field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentBringMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentbring.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipmentbring.FieldConsignmentNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsignmentNumber(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentBring field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentBringMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentBringMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentBringMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentBring numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentBringMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentBringMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentBringMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentBring nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentBringMutation) ResetField(name string) error {
	switch name {
	case shipmentbring.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipmentbring.FieldConsignmentNumber:
		m.ResetConsignmentNumber()
		return nil
	}
	return fmt.Errorf("unknown ShipmentBring field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentBringMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, shipmentbring.EdgeTenant)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentbring.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentBringMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentbring.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmentbring.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentBringMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentBringMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentBringMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, shipmentbring.EdgeTenant)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentbring.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentBringMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentbring.EdgeTenant:
		return m.clearedtenant
	case shipmentbring.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentBringMutation) ClearEdge(name string) error {
	switch name {
	case shipmentbring.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmentbring.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentBring unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentBringMutation) ResetEdge(name string) error {
	switch name {
	case shipmentbring.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmentbring.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentBring edge %s", name)
}

// ShipmentDAOMutation represents an operation that mutates the ShipmentDAO nodes in the graph.
type ShipmentDAOMutation struct {
	config
	op              Op
	typ             string
	id              *pulid.ID
	barcode_id      *string
	clearedFields   map[string]struct{}
	tenant          *pulid.ID
	clearedtenant   bool
	shipment        *pulid.ID
	clearedshipment bool
	done            bool
	oldValue        func(context.Context) (*ShipmentDAO, error)
	predicates      []predicate.ShipmentDAO
}

var _ ent.Mutation = (*ShipmentDAOMutation)(nil)

// shipmentdaoOption allows management of the mutation configuration using functional options.
type shipmentdaoOption func(*ShipmentDAOMutation)

// newShipmentDAOMutation creates new mutation for the ShipmentDAO entity.
func newShipmentDAOMutation(c config, op Op, opts ...shipmentdaoOption) *ShipmentDAOMutation {
	m := &ShipmentDAOMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentDAO,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentDAOID sets the ID field of the mutation.
func withShipmentDAOID(id pulid.ID) shipmentdaoOption {
	return func(m *ShipmentDAOMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentDAO
		)
		m.oldValue = func(ctx context.Context) (*ShipmentDAO, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentDAO.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentDAO sets the old ShipmentDAO of the mutation.
func withShipmentDAO(node *ShipmentDAO) shipmentdaoOption {
	return func(m *ShipmentDAOMutation) {
		m.oldValue = func(context.Context) (*ShipmentDAO, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentDAOMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentDAOMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentDAO entities.
func (m *ShipmentDAOMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentDAOMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentDAOMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentDAO.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentDAOMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentDAOMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentDAO entity.
// If the ShipmentDAO object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDAOMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentDAOMutation) ResetTenantID() {
	m.tenant = nil
}

// SetBarcodeID sets the "barcode_id" field.
func (m *ShipmentDAOMutation) SetBarcodeID(s string) {
	m.barcode_id = &s
}

// BarcodeID returns the value of the "barcode_id" field in the mutation.
func (m *ShipmentDAOMutation) BarcodeID() (r string, exists bool) {
	v := m.barcode_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcodeID returns the old "barcode_id" field's value of the ShipmentDAO entity.
// If the ShipmentDAO object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDAOMutation) OldBarcodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcodeID: %w", err)
	}
	return oldValue.BarcodeID, nil
}

// ResetBarcodeID resets all changes to the "barcode_id" field.
func (m *ShipmentDAOMutation) ResetBarcodeID() {
	m.barcode_id = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentDAOMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmentdao.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentDAOMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentDAOMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentDAOMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentDAOMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentDAOMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentDAOMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentDAOMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentDAOMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentDAOMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentDAOMutation builder.
func (m *ShipmentDAOMutation) Where(ps ...predicate.ShipmentDAO) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentDAOMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentDAOMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentDAO, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentDAOMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentDAOMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentDAO).
func (m *ShipmentDAOMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentDAOMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, shipmentdao.FieldTenantID)
	}
	if m.barcode_id != nil {
		fields = append(fields, shipmentdao.FieldBarcodeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentDAOMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentdao.FieldTenantID:
		return m.TenantID()
	case shipmentdao.FieldBarcodeID:
		return m.BarcodeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentDAOMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentdao.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipmentdao.FieldBarcodeID:
		return m.OldBarcodeID(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentDAO field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentDAOMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentdao.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipmentdao.FieldBarcodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcodeID(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentDAO field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentDAOMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentDAOMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentDAOMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentDAO numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentDAOMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentDAOMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentDAOMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentDAO nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentDAOMutation) ResetField(name string) error {
	switch name {
	case shipmentdao.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipmentdao.FieldBarcodeID:
		m.ResetBarcodeID()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDAO field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentDAOMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, shipmentdao.EdgeTenant)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentdao.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentDAOMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentdao.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmentdao.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentDAOMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentDAOMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentDAOMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, shipmentdao.EdgeTenant)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentdao.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentDAOMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentdao.EdgeTenant:
		return m.clearedtenant
	case shipmentdao.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentDAOMutation) ClearEdge(name string) error {
	switch name {
	case shipmentdao.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmentdao.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDAO unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentDAOMutation) ResetEdge(name string) error {
	switch name {
	case shipmentdao.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmentdao.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDAO edge %s", name)
}

// ShipmentDFMutation represents an operation that mutates the ShipmentDF nodes in the graph.
type ShipmentDFMutation struct {
	config
	op              Op
	typ             string
	id              *pulid.ID
	clearedFields   map[string]struct{}
	tenant          *pulid.ID
	clearedtenant   bool
	shipment        *pulid.ID
	clearedshipment bool
	done            bool
	oldValue        func(context.Context) (*ShipmentDF, error)
	predicates      []predicate.ShipmentDF
}

var _ ent.Mutation = (*ShipmentDFMutation)(nil)

// shipmentdfOption allows management of the mutation configuration using functional options.
type shipmentdfOption func(*ShipmentDFMutation)

// newShipmentDFMutation creates new mutation for the ShipmentDF entity.
func newShipmentDFMutation(c config, op Op, opts ...shipmentdfOption) *ShipmentDFMutation {
	m := &ShipmentDFMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentDF,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentDFID sets the ID field of the mutation.
func withShipmentDFID(id pulid.ID) shipmentdfOption {
	return func(m *ShipmentDFMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentDF
		)
		m.oldValue = func(ctx context.Context) (*ShipmentDF, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentDF.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentDF sets the old ShipmentDF of the mutation.
func withShipmentDF(node *ShipmentDF) shipmentdfOption {
	return func(m *ShipmentDFMutation) {
		m.oldValue = func(context.Context) (*ShipmentDF, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentDFMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentDFMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentDF entities.
func (m *ShipmentDFMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentDFMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentDFMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentDF.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentDFMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentDFMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentDF entity.
// If the ShipmentDF object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDFMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentDFMutation) ResetTenantID() {
	m.tenant = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentDFMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmentdf.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentDFMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentDFMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentDFMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentDFMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentDFMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentDFMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentDFMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentDFMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentDFMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentDFMutation builder.
func (m *ShipmentDFMutation) Where(ps ...predicate.ShipmentDF) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentDFMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentDFMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentDF, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentDFMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentDFMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentDF).
func (m *ShipmentDFMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentDFMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.tenant != nil {
		fields = append(fields, shipmentdf.FieldTenantID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentDFMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentdf.FieldTenantID:
		return m.TenantID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentDFMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentdf.FieldTenantID:
		return m.OldTenantID(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentDF field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentDFMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentdf.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentDF field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentDFMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentDFMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentDFMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentDF numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentDFMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentDFMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentDFMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentDF nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentDFMutation) ResetField(name string) error {
	switch name {
	case shipmentdf.FieldTenantID:
		m.ResetTenantID()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDF field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentDFMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, shipmentdf.EdgeTenant)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentdf.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentDFMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentdf.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmentdf.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentDFMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentDFMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentDFMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, shipmentdf.EdgeTenant)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentdf.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentDFMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentdf.EdgeTenant:
		return m.clearedtenant
	case shipmentdf.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentDFMutation) ClearEdge(name string) error {
	switch name {
	case shipmentdf.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmentdf.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDF unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentDFMutation) ResetEdge(name string) error {
	switch name {
	case shipmentdf.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmentdf.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDF edge %s", name)
}

// ShipmentDSVMutation represents an operation that mutates the ShipmentDSV nodes in the graph.
type ShipmentDSVMutation struct {
	config
	op              Op
	typ             string
	id              *pulid.ID
	barcode_id      *string
	clearedFields   map[string]struct{}
	tenant          *pulid.ID
	clearedtenant   bool
	shipment        *pulid.ID
	clearedshipment bool
	done            bool
	oldValue        func(context.Context) (*ShipmentDSV, error)
	predicates      []predicate.ShipmentDSV
}

var _ ent.Mutation = (*ShipmentDSVMutation)(nil)

// shipmentdsvOption allows management of the mutation configuration using functional options.
type shipmentdsvOption func(*ShipmentDSVMutation)

// newShipmentDSVMutation creates new mutation for the ShipmentDSV entity.
func newShipmentDSVMutation(c config, op Op, opts ...shipmentdsvOption) *ShipmentDSVMutation {
	m := &ShipmentDSVMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentDSV,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentDSVID sets the ID field of the mutation.
func withShipmentDSVID(id pulid.ID) shipmentdsvOption {
	return func(m *ShipmentDSVMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentDSV
		)
		m.oldValue = func(ctx context.Context) (*ShipmentDSV, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentDSV.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentDSV sets the old ShipmentDSV of the mutation.
func withShipmentDSV(node *ShipmentDSV) shipmentdsvOption {
	return func(m *ShipmentDSVMutation) {
		m.oldValue = func(context.Context) (*ShipmentDSV, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentDSVMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentDSVMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentDSV entities.
func (m *ShipmentDSVMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentDSVMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentDSVMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentDSV.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentDSVMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentDSVMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentDSV entity.
// If the ShipmentDSV object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDSVMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentDSVMutation) ResetTenantID() {
	m.tenant = nil
}

// SetBarcodeID sets the "barcode_id" field.
func (m *ShipmentDSVMutation) SetBarcodeID(s string) {
	m.barcode_id = &s
}

// BarcodeID returns the value of the "barcode_id" field in the mutation.
func (m *ShipmentDSVMutation) BarcodeID() (r string, exists bool) {
	v := m.barcode_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcodeID returns the old "barcode_id" field's value of the ShipmentDSV entity.
// If the ShipmentDSV object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentDSVMutation) OldBarcodeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcodeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcodeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcodeID: %w", err)
	}
	return oldValue.BarcodeID, nil
}

// ResetBarcodeID resets all changes to the "barcode_id" field.
func (m *ShipmentDSVMutation) ResetBarcodeID() {
	m.barcode_id = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentDSVMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmentdsv.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentDSVMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentDSVMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentDSVMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentDSVMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentDSVMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentDSVMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentDSVMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentDSVMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentDSVMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentDSVMutation builder.
func (m *ShipmentDSVMutation) Where(ps ...predicate.ShipmentDSV) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentDSVMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentDSVMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentDSV, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentDSVMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentDSVMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentDSV).
func (m *ShipmentDSVMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentDSVMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, shipmentdsv.FieldTenantID)
	}
	if m.barcode_id != nil {
		fields = append(fields, shipmentdsv.FieldBarcodeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentDSVMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentdsv.FieldTenantID:
		return m.TenantID()
	case shipmentdsv.FieldBarcodeID:
		return m.BarcodeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentDSVMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentdsv.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipmentdsv.FieldBarcodeID:
		return m.OldBarcodeID(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentDSV field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentDSVMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentdsv.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipmentdsv.FieldBarcodeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcodeID(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentDSV field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentDSVMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentDSVMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentDSVMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentDSV numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentDSVMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentDSVMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentDSVMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentDSV nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentDSVMutation) ResetField(name string) error {
	switch name {
	case shipmentdsv.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipmentdsv.FieldBarcodeID:
		m.ResetBarcodeID()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDSV field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentDSVMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, shipmentdsv.EdgeTenant)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentdsv.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentDSVMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentdsv.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmentdsv.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentDSVMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentDSVMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentDSVMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, shipmentdsv.EdgeTenant)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentdsv.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentDSVMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentdsv.EdgeTenant:
		return m.clearedtenant
	case shipmentdsv.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentDSVMutation) ClearEdge(name string) error {
	switch name {
	case shipmentdsv.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmentdsv.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDSV unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentDSVMutation) ResetEdge(name string) error {
	switch name {
	case shipmentdsv.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmentdsv.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentDSV edge %s", name)
}

// ShipmentEasyPostMutation represents an operation that mutates the ShipmentEasyPost nodes in the graph.
type ShipmentEasyPostMutation struct {
	config
	op                Op
	typ               string
	id                *pulid.ID
	tracking_number   *string
	ep_shipment_id    *string
	rate              *float64
	addrate           *float64
	est_delivery_date *time.Time
	clearedFields     map[string]struct{}
	tenant            *pulid.ID
	clearedtenant     bool
	shipment          *pulid.ID
	clearedshipment   bool
	done              bool
	oldValue          func(context.Context) (*ShipmentEasyPost, error)
	predicates        []predicate.ShipmentEasyPost
}

var _ ent.Mutation = (*ShipmentEasyPostMutation)(nil)

// shipmenteasypostOption allows management of the mutation configuration using functional options.
type shipmenteasypostOption func(*ShipmentEasyPostMutation)

// newShipmentEasyPostMutation creates new mutation for the ShipmentEasyPost entity.
func newShipmentEasyPostMutation(c config, op Op, opts ...shipmenteasypostOption) *ShipmentEasyPostMutation {
	m := &ShipmentEasyPostMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentEasyPost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentEasyPostID sets the ID field of the mutation.
func withShipmentEasyPostID(id pulid.ID) shipmenteasypostOption {
	return func(m *ShipmentEasyPostMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentEasyPost
		)
		m.oldValue = func(ctx context.Context) (*ShipmentEasyPost, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentEasyPost.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentEasyPost sets the old ShipmentEasyPost of the mutation.
func withShipmentEasyPost(node *ShipmentEasyPost) shipmenteasypostOption {
	return func(m *ShipmentEasyPostMutation) {
		m.oldValue = func(context.Context) (*ShipmentEasyPost, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentEasyPostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentEasyPostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentEasyPost entities.
func (m *ShipmentEasyPostMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentEasyPostMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentEasyPostMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentEasyPost.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentEasyPostMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentEasyPostMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentEasyPost entity.
// If the ShipmentEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentEasyPostMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentEasyPostMutation) ResetTenantID() {
	m.tenant = nil
}

// SetTrackingNumber sets the "tracking_number" field.
func (m *ShipmentEasyPostMutation) SetTrackingNumber(s string) {
	m.tracking_number = &s
}

// TrackingNumber returns the value of the "tracking_number" field in the mutation.
func (m *ShipmentEasyPostMutation) TrackingNumber() (r string, exists bool) {
	v := m.tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingNumber returns the old "tracking_number" field's value of the ShipmentEasyPost entity.
// If the ShipmentEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentEasyPostMutation) OldTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingNumber: %w", err)
	}
	return oldValue.TrackingNumber, nil
}

// ClearTrackingNumber clears the value of the "tracking_number" field.
func (m *ShipmentEasyPostMutation) ClearTrackingNumber() {
	m.tracking_number = nil
	m.clearedFields[shipmenteasypost.FieldTrackingNumber] = struct{}{}
}

// TrackingNumberCleared returns if the "tracking_number" field was cleared in this mutation.
func (m *ShipmentEasyPostMutation) TrackingNumberCleared() bool {
	_, ok := m.clearedFields[shipmenteasypost.FieldTrackingNumber]
	return ok
}

// ResetTrackingNumber resets all changes to the "tracking_number" field.
func (m *ShipmentEasyPostMutation) ResetTrackingNumber() {
	m.tracking_number = nil
	delete(m.clearedFields, shipmenteasypost.FieldTrackingNumber)
}

// SetEpShipmentID sets the "ep_shipment_id" field.
func (m *ShipmentEasyPostMutation) SetEpShipmentID(s string) {
	m.ep_shipment_id = &s
}

// EpShipmentID returns the value of the "ep_shipment_id" field in the mutation.
func (m *ShipmentEasyPostMutation) EpShipmentID() (r string, exists bool) {
	v := m.ep_shipment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEpShipmentID returns the old "ep_shipment_id" field's value of the ShipmentEasyPost entity.
// If the ShipmentEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentEasyPostMutation) OldEpShipmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEpShipmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEpShipmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEpShipmentID: %w", err)
	}
	return oldValue.EpShipmentID, nil
}

// ClearEpShipmentID clears the value of the "ep_shipment_id" field.
func (m *ShipmentEasyPostMutation) ClearEpShipmentID() {
	m.ep_shipment_id = nil
	m.clearedFields[shipmenteasypost.FieldEpShipmentID] = struct{}{}
}

// EpShipmentIDCleared returns if the "ep_shipment_id" field was cleared in this mutation.
func (m *ShipmentEasyPostMutation) EpShipmentIDCleared() bool {
	_, ok := m.clearedFields[shipmenteasypost.FieldEpShipmentID]
	return ok
}

// ResetEpShipmentID resets all changes to the "ep_shipment_id" field.
func (m *ShipmentEasyPostMutation) ResetEpShipmentID() {
	m.ep_shipment_id = nil
	delete(m.clearedFields, shipmenteasypost.FieldEpShipmentID)
}

// SetRate sets the "rate" field.
func (m *ShipmentEasyPostMutation) SetRate(f float64) {
	m.rate = &f
	m.addrate = nil
}

// Rate returns the value of the "rate" field in the mutation.
func (m *ShipmentEasyPostMutation) Rate() (r float64, exists bool) {
	v := m.rate
	if v == nil {
		return
	}
	return *v, true
}

// OldRate returns the old "rate" field's value of the ShipmentEasyPost entity.
// If the ShipmentEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentEasyPostMutation) OldRate(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRate: %w", err)
	}
	return oldValue.Rate, nil
}

// AddRate adds f to the "rate" field.
func (m *ShipmentEasyPostMutation) AddRate(f float64) {
	if m.addrate != nil {
		*m.addrate += f
	} else {
		m.addrate = &f
	}
}

// AddedRate returns the value that was added to the "rate" field in this mutation.
func (m *ShipmentEasyPostMutation) AddedRate() (r float64, exists bool) {
	v := m.addrate
	if v == nil {
		return
	}
	return *v, true
}

// ClearRate clears the value of the "rate" field.
func (m *ShipmentEasyPostMutation) ClearRate() {
	m.rate = nil
	m.addrate = nil
	m.clearedFields[shipmenteasypost.FieldRate] = struct{}{}
}

// RateCleared returns if the "rate" field was cleared in this mutation.
func (m *ShipmentEasyPostMutation) RateCleared() bool {
	_, ok := m.clearedFields[shipmenteasypost.FieldRate]
	return ok
}

// ResetRate resets all changes to the "rate" field.
func (m *ShipmentEasyPostMutation) ResetRate() {
	m.rate = nil
	m.addrate = nil
	delete(m.clearedFields, shipmenteasypost.FieldRate)
}

// SetEstDeliveryDate sets the "est_delivery_date" field.
func (m *ShipmentEasyPostMutation) SetEstDeliveryDate(t time.Time) {
	m.est_delivery_date = &t
}

// EstDeliveryDate returns the value of the "est_delivery_date" field in the mutation.
func (m *ShipmentEasyPostMutation) EstDeliveryDate() (r time.Time, exists bool) {
	v := m.est_delivery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEstDeliveryDate returns the old "est_delivery_date" field's value of the ShipmentEasyPost entity.
// If the ShipmentEasyPost object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentEasyPostMutation) OldEstDeliveryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEstDeliveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEstDeliveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEstDeliveryDate: %w", err)
	}
	return oldValue.EstDeliveryDate, nil
}

// ClearEstDeliveryDate clears the value of the "est_delivery_date" field.
func (m *ShipmentEasyPostMutation) ClearEstDeliveryDate() {
	m.est_delivery_date = nil
	m.clearedFields[shipmenteasypost.FieldEstDeliveryDate] = struct{}{}
}

// EstDeliveryDateCleared returns if the "est_delivery_date" field was cleared in this mutation.
func (m *ShipmentEasyPostMutation) EstDeliveryDateCleared() bool {
	_, ok := m.clearedFields[shipmenteasypost.FieldEstDeliveryDate]
	return ok
}

// ResetEstDeliveryDate resets all changes to the "est_delivery_date" field.
func (m *ShipmentEasyPostMutation) ResetEstDeliveryDate() {
	m.est_delivery_date = nil
	delete(m.clearedFields, shipmenteasypost.FieldEstDeliveryDate)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentEasyPostMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmenteasypost.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentEasyPostMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentEasyPostMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentEasyPostMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentEasyPostMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentEasyPostMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentEasyPostMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentEasyPostMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentEasyPostMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentEasyPostMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentEasyPostMutation builder.
func (m *ShipmentEasyPostMutation) Where(ps ...predicate.ShipmentEasyPost) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentEasyPostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentEasyPostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentEasyPost, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentEasyPostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentEasyPostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentEasyPost).
func (m *ShipmentEasyPostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentEasyPostMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.tenant != nil {
		fields = append(fields, shipmenteasypost.FieldTenantID)
	}
	if m.tracking_number != nil {
		fields = append(fields, shipmenteasypost.FieldTrackingNumber)
	}
	if m.ep_shipment_id != nil {
		fields = append(fields, shipmenteasypost.FieldEpShipmentID)
	}
	if m.rate != nil {
		fields = append(fields, shipmenteasypost.FieldRate)
	}
	if m.est_delivery_date != nil {
		fields = append(fields, shipmenteasypost.FieldEstDeliveryDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentEasyPostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmenteasypost.FieldTenantID:
		return m.TenantID()
	case shipmenteasypost.FieldTrackingNumber:
		return m.TrackingNumber()
	case shipmenteasypost.FieldEpShipmentID:
		return m.EpShipmentID()
	case shipmenteasypost.FieldRate:
		return m.Rate()
	case shipmenteasypost.FieldEstDeliveryDate:
		return m.EstDeliveryDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentEasyPostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmenteasypost.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipmenteasypost.FieldTrackingNumber:
		return m.OldTrackingNumber(ctx)
	case shipmenteasypost.FieldEpShipmentID:
		return m.OldEpShipmentID(ctx)
	case shipmenteasypost.FieldRate:
		return m.OldRate(ctx)
	case shipmenteasypost.FieldEstDeliveryDate:
		return m.OldEstDeliveryDate(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentEasyPost field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentEasyPostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmenteasypost.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipmenteasypost.FieldTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingNumber(v)
		return nil
	case shipmenteasypost.FieldEpShipmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEpShipmentID(v)
		return nil
	case shipmenteasypost.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRate(v)
		return nil
	case shipmenteasypost.FieldEstDeliveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEstDeliveryDate(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentEasyPost field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentEasyPostMutation) AddedFields() []string {
	var fields []string
	if m.addrate != nil {
		fields = append(fields, shipmenteasypost.FieldRate)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentEasyPostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmenteasypost.FieldRate:
		return m.AddedRate()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentEasyPostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmenteasypost.FieldRate:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRate(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentEasyPost numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentEasyPostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmenteasypost.FieldTrackingNumber) {
		fields = append(fields, shipmenteasypost.FieldTrackingNumber)
	}
	if m.FieldCleared(shipmenteasypost.FieldEpShipmentID) {
		fields = append(fields, shipmenteasypost.FieldEpShipmentID)
	}
	if m.FieldCleared(shipmenteasypost.FieldRate) {
		fields = append(fields, shipmenteasypost.FieldRate)
	}
	if m.FieldCleared(shipmenteasypost.FieldEstDeliveryDate) {
		fields = append(fields, shipmenteasypost.FieldEstDeliveryDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentEasyPostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentEasyPostMutation) ClearField(name string) error {
	switch name {
	case shipmenteasypost.FieldTrackingNumber:
		m.ClearTrackingNumber()
		return nil
	case shipmenteasypost.FieldEpShipmentID:
		m.ClearEpShipmentID()
		return nil
	case shipmenteasypost.FieldRate:
		m.ClearRate()
		return nil
	case shipmenteasypost.FieldEstDeliveryDate:
		m.ClearEstDeliveryDate()
		return nil
	}
	return fmt.Errorf("unknown ShipmentEasyPost nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentEasyPostMutation) ResetField(name string) error {
	switch name {
	case shipmenteasypost.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipmenteasypost.FieldTrackingNumber:
		m.ResetTrackingNumber()
		return nil
	case shipmenteasypost.FieldEpShipmentID:
		m.ResetEpShipmentID()
		return nil
	case shipmenteasypost.FieldRate:
		m.ResetRate()
		return nil
	case shipmenteasypost.FieldEstDeliveryDate:
		m.ResetEstDeliveryDate()
		return nil
	}
	return fmt.Errorf("unknown ShipmentEasyPost field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentEasyPostMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, shipmenteasypost.EdgeTenant)
	}
	if m.shipment != nil {
		edges = append(edges, shipmenteasypost.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentEasyPostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmenteasypost.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmenteasypost.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentEasyPostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentEasyPostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentEasyPostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, shipmenteasypost.EdgeTenant)
	}
	if m.clearedshipment {
		edges = append(edges, shipmenteasypost.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentEasyPostMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmenteasypost.EdgeTenant:
		return m.clearedtenant
	case shipmenteasypost.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentEasyPostMutation) ClearEdge(name string) error {
	switch name {
	case shipmenteasypost.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmenteasypost.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentEasyPost unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentEasyPostMutation) ResetEdge(name string) error {
	switch name {
	case shipmenteasypost.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmenteasypost.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentEasyPost edge %s", name)
}

// ShipmentGLSMutation represents an operation that mutates the ShipmentGLS nodes in the graph.
type ShipmentGLSMutation struct {
	config
	op              Op
	typ             string
	id              *pulid.ID
	consignment_id  *string
	clearedFields   map[string]struct{}
	tenant          *pulid.ID
	clearedtenant   bool
	shipment        *pulid.ID
	clearedshipment bool
	done            bool
	oldValue        func(context.Context) (*ShipmentGLS, error)
	predicates      []predicate.ShipmentGLS
}

var _ ent.Mutation = (*ShipmentGLSMutation)(nil)

// shipmentglsOption allows management of the mutation configuration using functional options.
type shipmentglsOption func(*ShipmentGLSMutation)

// newShipmentGLSMutation creates new mutation for the ShipmentGLS entity.
func newShipmentGLSMutation(c config, op Op, opts ...shipmentglsOption) *ShipmentGLSMutation {
	m := &ShipmentGLSMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentGLS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentGLSID sets the ID field of the mutation.
func withShipmentGLSID(id pulid.ID) shipmentglsOption {
	return func(m *ShipmentGLSMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentGLS
		)
		m.oldValue = func(ctx context.Context) (*ShipmentGLS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentGLS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentGLS sets the old ShipmentGLS of the mutation.
func withShipmentGLS(node *ShipmentGLS) shipmentglsOption {
	return func(m *ShipmentGLSMutation) {
		m.oldValue = func(context.Context) (*ShipmentGLS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentGLSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentGLSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentGLS entities.
func (m *ShipmentGLSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentGLSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentGLSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentGLS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentGLSMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentGLSMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentGLS entity.
// If the ShipmentGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGLSMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentGLSMutation) ResetTenantID() {
	m.tenant = nil
}

// SetConsignmentID sets the "consignment_id" field.
func (m *ShipmentGLSMutation) SetConsignmentID(s string) {
	m.consignment_id = &s
}

// ConsignmentID returns the value of the "consignment_id" field in the mutation.
func (m *ShipmentGLSMutation) ConsignmentID() (r string, exists bool) {
	v := m.consignment_id
	if v == nil {
		return
	}
	return *v, true
}

// OldConsignmentID returns the old "consignment_id" field's value of the ShipmentGLS entity.
// If the ShipmentGLS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentGLSMutation) OldConsignmentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConsignmentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConsignmentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConsignmentID: %w", err)
	}
	return oldValue.ConsignmentID, nil
}

// ResetConsignmentID resets all changes to the "consignment_id" field.
func (m *ShipmentGLSMutation) ResetConsignmentID() {
	m.consignment_id = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentGLSMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmentgls.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentGLSMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentGLSMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentGLSMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentGLSMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentGLSMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentGLSMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentGLSMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentGLSMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentGLSMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentGLSMutation builder.
func (m *ShipmentGLSMutation) Where(ps ...predicate.ShipmentGLS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentGLSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentGLSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentGLS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentGLSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentGLSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentGLS).
func (m *ShipmentGLSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentGLSMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, shipmentgls.FieldTenantID)
	}
	if m.consignment_id != nil {
		fields = append(fields, shipmentgls.FieldConsignmentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentGLSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentgls.FieldTenantID:
		return m.TenantID()
	case shipmentgls.FieldConsignmentID:
		return m.ConsignmentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentGLSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentgls.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipmentgls.FieldConsignmentID:
		return m.OldConsignmentID(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentGLS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGLSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentgls.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipmentgls.FieldConsignmentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConsignmentID(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentGLS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentGLSMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentGLSMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentGLSMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentGLS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentGLSMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentGLSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentGLSMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentGLS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentGLSMutation) ResetField(name string) error {
	switch name {
	case shipmentgls.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipmentgls.FieldConsignmentID:
		m.ResetConsignmentID()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGLS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentGLSMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, shipmentgls.EdgeTenant)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentgls.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentGLSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentgls.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmentgls.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentGLSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentGLSMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentGLSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, shipmentgls.EdgeTenant)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentgls.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentGLSMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentgls.EdgeTenant:
		return m.clearedtenant
	case shipmentgls.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentGLSMutation) ClearEdge(name string) error {
	switch name {
	case shipmentgls.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmentgls.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGLS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentGLSMutation) ResetEdge(name string) error {
	switch name {
	case shipmentgls.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmentgls.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentGLS edge %s", name)
}

// ShipmentHistoryMutation represents an operation that mutates the ShipmentHistory nodes in the graph.
type ShipmentHistoryMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.ID
	_type                 *shipmenthistory.Type
	clearedFields         map[string]struct{}
	change_history        *pulid.ID
	clearedchange_history bool
	tenant                *pulid.ID
	clearedtenant         bool
	shipment              *pulid.ID
	clearedshipment       bool
	done                  bool
	oldValue              func(context.Context) (*ShipmentHistory, error)
	predicates            []predicate.ShipmentHistory
}

var _ ent.Mutation = (*ShipmentHistoryMutation)(nil)

// shipmenthistoryOption allows management of the mutation configuration using functional options.
type shipmenthistoryOption func(*ShipmentHistoryMutation)

// newShipmentHistoryMutation creates new mutation for the ShipmentHistory entity.
func newShipmentHistoryMutation(c config, op Op, opts ...shipmenthistoryOption) *ShipmentHistoryMutation {
	m := &ShipmentHistoryMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentHistory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentHistoryID sets the ID field of the mutation.
func withShipmentHistoryID(id pulid.ID) shipmenthistoryOption {
	return func(m *ShipmentHistoryMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentHistory
		)
		m.oldValue = func(ctx context.Context) (*ShipmentHistory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentHistory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentHistory sets the old ShipmentHistory of the mutation.
func withShipmentHistory(node *ShipmentHistory) shipmenthistoryOption {
	return func(m *ShipmentHistoryMutation) {
		m.oldValue = func(context.Context) (*ShipmentHistory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentHistoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentHistoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentHistory entities.
func (m *ShipmentHistoryMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentHistoryMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentHistoryMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentHistory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentHistoryMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentHistoryMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentHistory entity.
// If the ShipmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentHistoryMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentHistoryMutation) ResetTenantID() {
	m.tenant = nil
}

// SetType sets the "type" field.
func (m *ShipmentHistoryMutation) SetType(s shipmenthistory.Type) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *ShipmentHistoryMutation) GetType() (r shipmenthistory.Type, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the ShipmentHistory entity.
// If the ShipmentHistory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentHistoryMutation) OldType(ctx context.Context) (v shipmenthistory.Type, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *ShipmentHistoryMutation) ResetType() {
	m._type = nil
}

// SetChangeHistoryID sets the "change_history" edge to the ChangeHistory entity by id.
func (m *ShipmentHistoryMutation) SetChangeHistoryID(id pulid.ID) {
	m.change_history = &id
}

// ClearChangeHistory clears the "change_history" edge to the ChangeHistory entity.
func (m *ShipmentHistoryMutation) ClearChangeHistory() {
	m.clearedchange_history = true
}

// ChangeHistoryCleared reports if the "change_history" edge to the ChangeHistory entity was cleared.
func (m *ShipmentHistoryMutation) ChangeHistoryCleared() bool {
	return m.clearedchange_history
}

// ChangeHistoryID returns the "change_history" edge ID in the mutation.
func (m *ShipmentHistoryMutation) ChangeHistoryID() (id pulid.ID, exists bool) {
	if m.change_history != nil {
		return *m.change_history, true
	}
	return
}

// ChangeHistoryIDs returns the "change_history" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ChangeHistoryID instead. It exists only for internal usage by the builders.
func (m *ShipmentHistoryMutation) ChangeHistoryIDs() (ids []pulid.ID) {
	if id := m.change_history; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetChangeHistory resets all changes to the "change_history" edge.
func (m *ShipmentHistoryMutation) ResetChangeHistory() {
	m.change_history = nil
	m.clearedchange_history = false
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentHistoryMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmenthistory.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentHistoryMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentHistoryMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentHistoryMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentHistoryMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentHistoryMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentHistoryMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentHistoryMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentHistoryMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentHistoryMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentHistoryMutation builder.
func (m *ShipmentHistoryMutation) Where(ps ...predicate.ShipmentHistory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentHistoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentHistoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentHistory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentHistoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentHistoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentHistory).
func (m *ShipmentHistoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentHistoryMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, shipmenthistory.FieldTenantID)
	}
	if m._type != nil {
		fields = append(fields, shipmenthistory.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentHistoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmenthistory.FieldTenantID:
		return m.TenantID()
	case shipmenthistory.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentHistoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmenthistory.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipmenthistory.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentHistory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentHistoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmenthistory.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipmenthistory.FieldType:
		v, ok := value.(shipmenthistory.Type)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentHistory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentHistoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentHistoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentHistoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentHistory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentHistoryMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentHistoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentHistoryMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentHistory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentHistoryMutation) ResetField(name string) error {
	switch name {
	case shipmenthistory.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipmenthistory.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown ShipmentHistory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentHistoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.change_history != nil {
		edges = append(edges, shipmenthistory.EdgeChangeHistory)
	}
	if m.tenant != nil {
		edges = append(edges, shipmenthistory.EdgeTenant)
	}
	if m.shipment != nil {
		edges = append(edges, shipmenthistory.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentHistoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmenthistory.EdgeChangeHistory:
		if id := m.change_history; id != nil {
			return []ent.Value{*id}
		}
	case shipmenthistory.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmenthistory.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentHistoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentHistoryMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentHistoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedchange_history {
		edges = append(edges, shipmenthistory.EdgeChangeHistory)
	}
	if m.clearedtenant {
		edges = append(edges, shipmenthistory.EdgeTenant)
	}
	if m.clearedshipment {
		edges = append(edges, shipmenthistory.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentHistoryMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmenthistory.EdgeChangeHistory:
		return m.clearedchange_history
	case shipmenthistory.EdgeTenant:
		return m.clearedtenant
	case shipmenthistory.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentHistoryMutation) ClearEdge(name string) error {
	switch name {
	case shipmenthistory.EdgeChangeHistory:
		m.ClearChangeHistory()
		return nil
	case shipmenthistory.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmenthistory.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentHistory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentHistoryMutation) ResetEdge(name string) error {
	switch name {
	case shipmenthistory.EdgeChangeHistory:
		m.ResetChangeHistory()
		return nil
	case shipmenthistory.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmenthistory.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentHistory edge %s", name)
}

// ShipmentPalletMutation represents an operation that mutates the ShipmentPallet nodes in the graph.
type ShipmentPalletMutation struct {
	config
	op                Op
	typ               string
	id                *pulid.ID
	barcode           *string
	colli_number      *string
	carrier_id        *string
	label_pdf         *string
	label_zpl         *string
	status            *shipmentpallet.Status
	clearedFields     map[string]struct{}
	tenant            *pulid.ID
	clearedtenant     bool
	pallet            *pulid.ID
	clearedpallet     bool
	old_pallet        map[pulid.ID]struct{}
	removedold_pallet map[pulid.ID]struct{}
	clearedold_pallet bool
	shipment          *pulid.ID
	clearedshipment   bool
	done              bool
	oldValue          func(context.Context) (*ShipmentPallet, error)
	predicates        []predicate.ShipmentPallet
}

var _ ent.Mutation = (*ShipmentPalletMutation)(nil)

// shipmentpalletOption allows management of the mutation configuration using functional options.
type shipmentpalletOption func(*ShipmentPalletMutation)

// newShipmentPalletMutation creates new mutation for the ShipmentPallet entity.
func newShipmentPalletMutation(c config, op Op, opts ...shipmentpalletOption) *ShipmentPalletMutation {
	m := &ShipmentPalletMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentPallet,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentPalletID sets the ID field of the mutation.
func withShipmentPalletID(id pulid.ID) shipmentpalletOption {
	return func(m *ShipmentPalletMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentPallet
		)
		m.oldValue = func(ctx context.Context) (*ShipmentPallet, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentPallet.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentPallet sets the old ShipmentPallet of the mutation.
func withShipmentPallet(node *ShipmentPallet) shipmentpalletOption {
	return func(m *ShipmentPalletMutation) {
		m.oldValue = func(context.Context) (*ShipmentPallet, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentPalletMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentPalletMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentPallet entities.
func (m *ShipmentPalletMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentPalletMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentPalletMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentPallet.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentPalletMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentPalletMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentPallet entity.
// If the ShipmentPallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPalletMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentPalletMutation) ResetTenantID() {
	m.tenant = nil
}

// SetBarcode sets the "barcode" field.
func (m *ShipmentPalletMutation) SetBarcode(s string) {
	m.barcode = &s
}

// Barcode returns the value of the "barcode" field in the mutation.
func (m *ShipmentPalletMutation) Barcode() (r string, exists bool) {
	v := m.barcode
	if v == nil {
		return
	}
	return *v, true
}

// OldBarcode returns the old "barcode" field's value of the ShipmentPallet entity.
// If the ShipmentPallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPalletMutation) OldBarcode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBarcode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBarcode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBarcode: %w", err)
	}
	return oldValue.Barcode, nil
}

// ResetBarcode resets all changes to the "barcode" field.
func (m *ShipmentPalletMutation) ResetBarcode() {
	m.barcode = nil
}

// SetColliNumber sets the "colli_number" field.
func (m *ShipmentPalletMutation) SetColliNumber(s string) {
	m.colli_number = &s
}

// ColliNumber returns the value of the "colli_number" field in the mutation.
func (m *ShipmentPalletMutation) ColliNumber() (r string, exists bool) {
	v := m.colli_number
	if v == nil {
		return
	}
	return *v, true
}

// OldColliNumber returns the old "colli_number" field's value of the ShipmentPallet entity.
// If the ShipmentPallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPalletMutation) OldColliNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColliNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColliNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColliNumber: %w", err)
	}
	return oldValue.ColliNumber, nil
}

// ResetColliNumber resets all changes to the "colli_number" field.
func (m *ShipmentPalletMutation) ResetColliNumber() {
	m.colli_number = nil
}

// SetCarrierID sets the "carrier_id" field.
func (m *ShipmentPalletMutation) SetCarrierID(s string) {
	m.carrier_id = &s
}

// CarrierID returns the value of the "carrier_id" field in the mutation.
func (m *ShipmentPalletMutation) CarrierID() (r string, exists bool) {
	v := m.carrier_id
	if v == nil {
		return
	}
	return *v, true
}

// OldCarrierID returns the old "carrier_id" field's value of the ShipmentPallet entity.
// If the ShipmentPallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPalletMutation) OldCarrierID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCarrierID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCarrierID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCarrierID: %w", err)
	}
	return oldValue.CarrierID, nil
}

// ResetCarrierID resets all changes to the "carrier_id" field.
func (m *ShipmentPalletMutation) ResetCarrierID() {
	m.carrier_id = nil
}

// SetLabelPdf sets the "label_pdf" field.
func (m *ShipmentPalletMutation) SetLabelPdf(s string) {
	m.label_pdf = &s
}

// LabelPdf returns the value of the "label_pdf" field in the mutation.
func (m *ShipmentPalletMutation) LabelPdf() (r string, exists bool) {
	v := m.label_pdf
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelPdf returns the old "label_pdf" field's value of the ShipmentPallet entity.
// If the ShipmentPallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPalletMutation) OldLabelPdf(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelPdf is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelPdf requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelPdf: %w", err)
	}
	return oldValue.LabelPdf, nil
}

// ClearLabelPdf clears the value of the "label_pdf" field.
func (m *ShipmentPalletMutation) ClearLabelPdf() {
	m.label_pdf = nil
	m.clearedFields[shipmentpallet.FieldLabelPdf] = struct{}{}
}

// LabelPdfCleared returns if the "label_pdf" field was cleared in this mutation.
func (m *ShipmentPalletMutation) LabelPdfCleared() bool {
	_, ok := m.clearedFields[shipmentpallet.FieldLabelPdf]
	return ok
}

// ResetLabelPdf resets all changes to the "label_pdf" field.
func (m *ShipmentPalletMutation) ResetLabelPdf() {
	m.label_pdf = nil
	delete(m.clearedFields, shipmentpallet.FieldLabelPdf)
}

// SetLabelZpl sets the "label_zpl" field.
func (m *ShipmentPalletMutation) SetLabelZpl(s string) {
	m.label_zpl = &s
}

// LabelZpl returns the value of the "label_zpl" field in the mutation.
func (m *ShipmentPalletMutation) LabelZpl() (r string, exists bool) {
	v := m.label_zpl
	if v == nil {
		return
	}
	return *v, true
}

// OldLabelZpl returns the old "label_zpl" field's value of the ShipmentPallet entity.
// If the ShipmentPallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPalletMutation) OldLabelZpl(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLabelZpl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLabelZpl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLabelZpl: %w", err)
	}
	return oldValue.LabelZpl, nil
}

// ClearLabelZpl clears the value of the "label_zpl" field.
func (m *ShipmentPalletMutation) ClearLabelZpl() {
	m.label_zpl = nil
	m.clearedFields[shipmentpallet.FieldLabelZpl] = struct{}{}
}

// LabelZplCleared returns if the "label_zpl" field was cleared in this mutation.
func (m *ShipmentPalletMutation) LabelZplCleared() bool {
	_, ok := m.clearedFields[shipmentpallet.FieldLabelZpl]
	return ok
}

// ResetLabelZpl resets all changes to the "label_zpl" field.
func (m *ShipmentPalletMutation) ResetLabelZpl() {
	m.label_zpl = nil
	delete(m.clearedFields, shipmentpallet.FieldLabelZpl)
}

// SetStatus sets the "status" field.
func (m *ShipmentPalletMutation) SetStatus(s shipmentpallet.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ShipmentPalletMutation) Status() (r shipmentpallet.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ShipmentPallet entity.
// If the ShipmentPallet object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPalletMutation) OldStatus(ctx context.Context) (v shipmentpallet.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ShipmentPalletMutation) ResetStatus() {
	m.status = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentPalletMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmentpallet.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentPalletMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentPalletMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentPalletMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetPalletID sets the "pallet" edge to the Pallet entity by id.
func (m *ShipmentPalletMutation) SetPalletID(id pulid.ID) {
	m.pallet = &id
}

// ClearPallet clears the "pallet" edge to the Pallet entity.
func (m *ShipmentPalletMutation) ClearPallet() {
	m.clearedpallet = true
}

// PalletCleared reports if the "pallet" edge to the Pallet entity was cleared.
func (m *ShipmentPalletMutation) PalletCleared() bool {
	return m.clearedpallet
}

// PalletID returns the "pallet" edge ID in the mutation.
func (m *ShipmentPalletMutation) PalletID() (id pulid.ID, exists bool) {
	if m.pallet != nil {
		return *m.pallet, true
	}
	return
}

// PalletIDs returns the "pallet" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PalletID instead. It exists only for internal usage by the builders.
func (m *ShipmentPalletMutation) PalletIDs() (ids []pulid.ID) {
	if id := m.pallet; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPallet resets all changes to the "pallet" edge.
func (m *ShipmentPalletMutation) ResetPallet() {
	m.pallet = nil
	m.clearedpallet = false
}

// AddOldPalletIDs adds the "old_pallet" edge to the Pallet entity by ids.
func (m *ShipmentPalletMutation) AddOldPalletIDs(ids ...pulid.ID) {
	if m.old_pallet == nil {
		m.old_pallet = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.old_pallet[ids[i]] = struct{}{}
	}
}

// ClearOldPallet clears the "old_pallet" edge to the Pallet entity.
func (m *ShipmentPalletMutation) ClearOldPallet() {
	m.clearedold_pallet = true
}

// OldPalletCleared reports if the "old_pallet" edge to the Pallet entity was cleared.
func (m *ShipmentPalletMutation) OldPalletCleared() bool {
	return m.clearedold_pallet
}

// RemoveOldPalletIDs removes the "old_pallet" edge to the Pallet entity by IDs.
func (m *ShipmentPalletMutation) RemoveOldPalletIDs(ids ...pulid.ID) {
	if m.removedold_pallet == nil {
		m.removedold_pallet = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.old_pallet, ids[i])
		m.removedold_pallet[ids[i]] = struct{}{}
	}
}

// RemovedOldPallet returns the removed IDs of the "old_pallet" edge to the Pallet entity.
func (m *ShipmentPalletMutation) RemovedOldPalletIDs() (ids []pulid.ID) {
	for id := range m.removedold_pallet {
		ids = append(ids, id)
	}
	return
}

// OldPalletIDs returns the "old_pallet" edge IDs in the mutation.
func (m *ShipmentPalletMutation) OldPalletIDs() (ids []pulid.ID) {
	for id := range m.old_pallet {
		ids = append(ids, id)
	}
	return
}

// ResetOldPallet resets all changes to the "old_pallet" edge.
func (m *ShipmentPalletMutation) ResetOldPallet() {
	m.old_pallet = nil
	m.clearedold_pallet = false
	m.removedold_pallet = nil
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentPalletMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentPalletMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentPalletMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentPalletMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentPalletMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentPalletMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentPalletMutation builder.
func (m *ShipmentPalletMutation) Where(ps ...predicate.ShipmentPallet) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentPalletMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentPalletMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentPallet, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentPalletMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentPalletMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentPallet).
func (m *ShipmentPalletMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentPalletMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, shipmentpallet.FieldTenantID)
	}
	if m.barcode != nil {
		fields = append(fields, shipmentpallet.FieldBarcode)
	}
	if m.colli_number != nil {
		fields = append(fields, shipmentpallet.FieldColliNumber)
	}
	if m.carrier_id != nil {
		fields = append(fields, shipmentpallet.FieldCarrierID)
	}
	if m.label_pdf != nil {
		fields = append(fields, shipmentpallet.FieldLabelPdf)
	}
	if m.label_zpl != nil {
		fields = append(fields, shipmentpallet.FieldLabelZpl)
	}
	if m.status != nil {
		fields = append(fields, shipmentpallet.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentPalletMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentpallet.FieldTenantID:
		return m.TenantID()
	case shipmentpallet.FieldBarcode:
		return m.Barcode()
	case shipmentpallet.FieldColliNumber:
		return m.ColliNumber()
	case shipmentpallet.FieldCarrierID:
		return m.CarrierID()
	case shipmentpallet.FieldLabelPdf:
		return m.LabelPdf()
	case shipmentpallet.FieldLabelZpl:
		return m.LabelZpl()
	case shipmentpallet.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentPalletMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentpallet.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipmentpallet.FieldBarcode:
		return m.OldBarcode(ctx)
	case shipmentpallet.FieldColliNumber:
		return m.OldColliNumber(ctx)
	case shipmentpallet.FieldCarrierID:
		return m.OldCarrierID(ctx)
	case shipmentpallet.FieldLabelPdf:
		return m.OldLabelPdf(ctx)
	case shipmentpallet.FieldLabelZpl:
		return m.OldLabelZpl(ctx)
	case shipmentpallet.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentPallet field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentPalletMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentpallet.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipmentpallet.FieldBarcode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBarcode(v)
		return nil
	case shipmentpallet.FieldColliNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColliNumber(v)
		return nil
	case shipmentpallet.FieldCarrierID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCarrierID(v)
		return nil
	case shipmentpallet.FieldLabelPdf:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelPdf(v)
		return nil
	case shipmentpallet.FieldLabelZpl:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLabelZpl(v)
		return nil
	case shipmentpallet.FieldStatus:
		v, ok := value.(shipmentpallet.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentPallet field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentPalletMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentPalletMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentPalletMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentPallet numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentPalletMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentpallet.FieldLabelPdf) {
		fields = append(fields, shipmentpallet.FieldLabelPdf)
	}
	if m.FieldCleared(shipmentpallet.FieldLabelZpl) {
		fields = append(fields, shipmentpallet.FieldLabelZpl)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentPalletMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentPalletMutation) ClearField(name string) error {
	switch name {
	case shipmentpallet.FieldLabelPdf:
		m.ClearLabelPdf()
		return nil
	case shipmentpallet.FieldLabelZpl:
		m.ClearLabelZpl()
		return nil
	}
	return fmt.Errorf("unknown ShipmentPallet nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentPalletMutation) ResetField(name string) error {
	switch name {
	case shipmentpallet.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipmentpallet.FieldBarcode:
		m.ResetBarcode()
		return nil
	case shipmentpallet.FieldColliNumber:
		m.ResetColliNumber()
		return nil
	case shipmentpallet.FieldCarrierID:
		m.ResetCarrierID()
		return nil
	case shipmentpallet.FieldLabelPdf:
		m.ResetLabelPdf()
		return nil
	case shipmentpallet.FieldLabelZpl:
		m.ResetLabelZpl()
		return nil
	case shipmentpallet.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown ShipmentPallet field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentPalletMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, shipmentpallet.EdgeTenant)
	}
	if m.pallet != nil {
		edges = append(edges, shipmentpallet.EdgePallet)
	}
	if m.old_pallet != nil {
		edges = append(edges, shipmentpallet.EdgeOldPallet)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentpallet.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentPalletMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentpallet.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmentpallet.EdgePallet:
		if id := m.pallet; id != nil {
			return []ent.Value{*id}
		}
	case shipmentpallet.EdgeOldPallet:
		ids := make([]ent.Value, 0, len(m.old_pallet))
		for id := range m.old_pallet {
			ids = append(ids, id)
		}
		return ids
	case shipmentpallet.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentPalletMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedold_pallet != nil {
		edges = append(edges, shipmentpallet.EdgeOldPallet)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentPalletMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shipmentpallet.EdgeOldPallet:
		ids := make([]ent.Value, 0, len(m.removedold_pallet))
		for id := range m.removedold_pallet {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentPalletMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, shipmentpallet.EdgeTenant)
	}
	if m.clearedpallet {
		edges = append(edges, shipmentpallet.EdgePallet)
	}
	if m.clearedold_pallet {
		edges = append(edges, shipmentpallet.EdgeOldPallet)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentpallet.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentPalletMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentpallet.EdgeTenant:
		return m.clearedtenant
	case shipmentpallet.EdgePallet:
		return m.clearedpallet
	case shipmentpallet.EdgeOldPallet:
		return m.clearedold_pallet
	case shipmentpallet.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentPalletMutation) ClearEdge(name string) error {
	switch name {
	case shipmentpallet.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmentpallet.EdgePallet:
		m.ClearPallet()
		return nil
	case shipmentpallet.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentPallet unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentPalletMutation) ResetEdge(name string) error {
	switch name {
	case shipmentpallet.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmentpallet.EdgePallet:
		m.ResetPallet()
		return nil
	case shipmentpallet.EdgeOldPallet:
		m.ResetOldPallet()
		return nil
	case shipmentpallet.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentPallet edge %s", name)
}

// ShipmentParcelMutation represents an operation that mutates the ShipmentParcel nodes in the graph.
type ShipmentParcelMutation struct {
	config
	op                             Op
	typ                            string
	id                             *pulid.ID
	item_id                        *string
	status                         *shipmentparcel.Status
	cc_pickup_signature_urls       *[]string
	appendcc_pickup_signature_urls []string
	expected_at                    *time.Time
	fulfillment_synced_at          *time.Time
	cancel_synced_at               *time.Time
	clearedFields                  map[string]struct{}
	tenant                         *pulid.ID
	clearedtenant                  bool
	shipment                       *pulid.ID
	clearedshipment                bool
	colli                          *pulid.ID
	clearedcolli                   bool
	old_colli                      map[pulid.ID]struct{}
	removedold_colli               map[pulid.ID]struct{}
	clearedold_colli               bool
	workspace_recent_scan          map[pulid.ID]struct{}
	removedworkspace_recent_scan   map[pulid.ID]struct{}
	clearedworkspace_recent_scan   bool
	packaging                      *pulid.ID
	clearedpackaging               bool
	print_job                      map[pulid.ID]struct{}
	removedprint_job               map[pulid.ID]struct{}
	clearedprint_job               bool
	document_file                  *pulid.ID
	cleareddocument_file           bool
	done                           bool
	oldValue                       func(context.Context) (*ShipmentParcel, error)
	predicates                     []predicate.ShipmentParcel
}

var _ ent.Mutation = (*ShipmentParcelMutation)(nil)

// shipmentparcelOption allows management of the mutation configuration using functional options.
type shipmentparcelOption func(*ShipmentParcelMutation)

// newShipmentParcelMutation creates new mutation for the ShipmentParcel entity.
func newShipmentParcelMutation(c config, op Op, opts ...shipmentparcelOption) *ShipmentParcelMutation {
	m := &ShipmentParcelMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentParcel,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentParcelID sets the ID field of the mutation.
func withShipmentParcelID(id pulid.ID) shipmentparcelOption {
	return func(m *ShipmentParcelMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentParcel
		)
		m.oldValue = func(ctx context.Context) (*ShipmentParcel, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentParcel.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentParcel sets the old ShipmentParcel of the mutation.
func withShipmentParcel(node *ShipmentParcel) shipmentparcelOption {
	return func(m *ShipmentParcelMutation) {
		m.oldValue = func(context.Context) (*ShipmentParcel, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentParcelMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentParcelMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentParcel entities.
func (m *ShipmentParcelMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentParcelMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentParcelMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentParcel.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentParcelMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentParcelMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentParcel entity.
// If the ShipmentParcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentParcelMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentParcelMutation) ResetTenantID() {
	m.tenant = nil
}

// SetItemID sets the "item_id" field.
func (m *ShipmentParcelMutation) SetItemID(s string) {
	m.item_id = &s
}

// ItemID returns the value of the "item_id" field in the mutation.
func (m *ShipmentParcelMutation) ItemID() (r string, exists bool) {
	v := m.item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldItemID returns the old "item_id" field's value of the ShipmentParcel entity.
// If the ShipmentParcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentParcelMutation) OldItemID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemID: %w", err)
	}
	return oldValue.ItemID, nil
}

// ClearItemID clears the value of the "item_id" field.
func (m *ShipmentParcelMutation) ClearItemID() {
	m.item_id = nil
	m.clearedFields[shipmentparcel.FieldItemID] = struct{}{}
}

// ItemIDCleared returns if the "item_id" field was cleared in this mutation.
func (m *ShipmentParcelMutation) ItemIDCleared() bool {
	_, ok := m.clearedFields[shipmentparcel.FieldItemID]
	return ok
}

// ResetItemID resets all changes to the "item_id" field.
func (m *ShipmentParcelMutation) ResetItemID() {
	m.item_id = nil
	delete(m.clearedFields, shipmentparcel.FieldItemID)
}

// SetStatus sets the "status" field.
func (m *ShipmentParcelMutation) SetStatus(s shipmentparcel.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *ShipmentParcelMutation) Status() (r shipmentparcel.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the ShipmentParcel entity.
// If the ShipmentParcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentParcelMutation) OldStatus(ctx context.Context) (v shipmentparcel.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *ShipmentParcelMutation) ResetStatus() {
	m.status = nil
}

// SetCcPickupSignatureUrls sets the "cc_pickup_signature_urls" field.
func (m *ShipmentParcelMutation) SetCcPickupSignatureUrls(s []string) {
	m.cc_pickup_signature_urls = &s
	m.appendcc_pickup_signature_urls = nil
}

// CcPickupSignatureUrls returns the value of the "cc_pickup_signature_urls" field in the mutation.
func (m *ShipmentParcelMutation) CcPickupSignatureUrls() (r []string, exists bool) {
	v := m.cc_pickup_signature_urls
	if v == nil {
		return
	}
	return *v, true
}

// OldCcPickupSignatureUrls returns the old "cc_pickup_signature_urls" field's value of the ShipmentParcel entity.
// If the ShipmentParcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentParcelMutation) OldCcPickupSignatureUrls(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCcPickupSignatureUrls is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCcPickupSignatureUrls requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCcPickupSignatureUrls: %w", err)
	}
	return oldValue.CcPickupSignatureUrls, nil
}

// AppendCcPickupSignatureUrls adds s to the "cc_pickup_signature_urls" field.
func (m *ShipmentParcelMutation) AppendCcPickupSignatureUrls(s []string) {
	m.appendcc_pickup_signature_urls = append(m.appendcc_pickup_signature_urls, s...)
}

// AppendedCcPickupSignatureUrls returns the list of values that were appended to the "cc_pickup_signature_urls" field in this mutation.
func (m *ShipmentParcelMutation) AppendedCcPickupSignatureUrls() ([]string, bool) {
	if len(m.appendcc_pickup_signature_urls) == 0 {
		return nil, false
	}
	return m.appendcc_pickup_signature_urls, true
}

// ClearCcPickupSignatureUrls clears the value of the "cc_pickup_signature_urls" field.
func (m *ShipmentParcelMutation) ClearCcPickupSignatureUrls() {
	m.cc_pickup_signature_urls = nil
	m.appendcc_pickup_signature_urls = nil
	m.clearedFields[shipmentparcel.FieldCcPickupSignatureUrls] = struct{}{}
}

// CcPickupSignatureUrlsCleared returns if the "cc_pickup_signature_urls" field was cleared in this mutation.
func (m *ShipmentParcelMutation) CcPickupSignatureUrlsCleared() bool {
	_, ok := m.clearedFields[shipmentparcel.FieldCcPickupSignatureUrls]
	return ok
}

// ResetCcPickupSignatureUrls resets all changes to the "cc_pickup_signature_urls" field.
func (m *ShipmentParcelMutation) ResetCcPickupSignatureUrls() {
	m.cc_pickup_signature_urls = nil
	m.appendcc_pickup_signature_urls = nil
	delete(m.clearedFields, shipmentparcel.FieldCcPickupSignatureUrls)
}

// SetExpectedAt sets the "expected_at" field.
func (m *ShipmentParcelMutation) SetExpectedAt(t time.Time) {
	m.expected_at = &t
}

// ExpectedAt returns the value of the "expected_at" field in the mutation.
func (m *ShipmentParcelMutation) ExpectedAt() (r time.Time, exists bool) {
	v := m.expected_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpectedAt returns the old "expected_at" field's value of the ShipmentParcel entity.
// If the ShipmentParcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentParcelMutation) OldExpectedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpectedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpectedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpectedAt: %w", err)
	}
	return oldValue.ExpectedAt, nil
}

// ClearExpectedAt clears the value of the "expected_at" field.
func (m *ShipmentParcelMutation) ClearExpectedAt() {
	m.expected_at = nil
	m.clearedFields[shipmentparcel.FieldExpectedAt] = struct{}{}
}

// ExpectedAtCleared returns if the "expected_at" field was cleared in this mutation.
func (m *ShipmentParcelMutation) ExpectedAtCleared() bool {
	_, ok := m.clearedFields[shipmentparcel.FieldExpectedAt]
	return ok
}

// ResetExpectedAt resets all changes to the "expected_at" field.
func (m *ShipmentParcelMutation) ResetExpectedAt() {
	m.expected_at = nil
	delete(m.clearedFields, shipmentparcel.FieldExpectedAt)
}

// SetFulfillmentSyncedAt sets the "fulfillment_synced_at" field.
func (m *ShipmentParcelMutation) SetFulfillmentSyncedAt(t time.Time) {
	m.fulfillment_synced_at = &t
}

// FulfillmentSyncedAt returns the value of the "fulfillment_synced_at" field in the mutation.
func (m *ShipmentParcelMutation) FulfillmentSyncedAt() (r time.Time, exists bool) {
	v := m.fulfillment_synced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldFulfillmentSyncedAt returns the old "fulfillment_synced_at" field's value of the ShipmentParcel entity.
// If the ShipmentParcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentParcelMutation) OldFulfillmentSyncedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFulfillmentSyncedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFulfillmentSyncedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFulfillmentSyncedAt: %w", err)
	}
	return oldValue.FulfillmentSyncedAt, nil
}

// ClearFulfillmentSyncedAt clears the value of the "fulfillment_synced_at" field.
func (m *ShipmentParcelMutation) ClearFulfillmentSyncedAt() {
	m.fulfillment_synced_at = nil
	m.clearedFields[shipmentparcel.FieldFulfillmentSyncedAt] = struct{}{}
}

// FulfillmentSyncedAtCleared returns if the "fulfillment_synced_at" field was cleared in this mutation.
func (m *ShipmentParcelMutation) FulfillmentSyncedAtCleared() bool {
	_, ok := m.clearedFields[shipmentparcel.FieldFulfillmentSyncedAt]
	return ok
}

// ResetFulfillmentSyncedAt resets all changes to the "fulfillment_synced_at" field.
func (m *ShipmentParcelMutation) ResetFulfillmentSyncedAt() {
	m.fulfillment_synced_at = nil
	delete(m.clearedFields, shipmentparcel.FieldFulfillmentSyncedAt)
}

// SetCancelSyncedAt sets the "cancel_synced_at" field.
func (m *ShipmentParcelMutation) SetCancelSyncedAt(t time.Time) {
	m.cancel_synced_at = &t
}

// CancelSyncedAt returns the value of the "cancel_synced_at" field in the mutation.
func (m *ShipmentParcelMutation) CancelSyncedAt() (r time.Time, exists bool) {
	v := m.cancel_synced_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCancelSyncedAt returns the old "cancel_synced_at" field's value of the ShipmentParcel entity.
// If the ShipmentParcel object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentParcelMutation) OldCancelSyncedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCancelSyncedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCancelSyncedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCancelSyncedAt: %w", err)
	}
	return oldValue.CancelSyncedAt, nil
}

// ClearCancelSyncedAt clears the value of the "cancel_synced_at" field.
func (m *ShipmentParcelMutation) ClearCancelSyncedAt() {
	m.cancel_synced_at = nil
	m.clearedFields[shipmentparcel.FieldCancelSyncedAt] = struct{}{}
}

// CancelSyncedAtCleared returns if the "cancel_synced_at" field was cleared in this mutation.
func (m *ShipmentParcelMutation) CancelSyncedAtCleared() bool {
	_, ok := m.clearedFields[shipmentparcel.FieldCancelSyncedAt]
	return ok
}

// ResetCancelSyncedAt resets all changes to the "cancel_synced_at" field.
func (m *ShipmentParcelMutation) ResetCancelSyncedAt() {
	m.cancel_synced_at = nil
	delete(m.clearedFields, shipmentparcel.FieldCancelSyncedAt)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentParcelMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmentparcel.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentParcelMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentParcelMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentParcelMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentParcelMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentParcelMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentParcelMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentParcelMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentParcelMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentParcelMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// SetColliID sets the "colli" edge to the Colli entity by id.
func (m *ShipmentParcelMutation) SetColliID(id pulid.ID) {
	m.colli = &id
}

// ClearColli clears the "colli" edge to the Colli entity.
func (m *ShipmentParcelMutation) ClearColli() {
	m.clearedcolli = true
}

// ColliCleared reports if the "colli" edge to the Colli entity was cleared.
func (m *ShipmentParcelMutation) ColliCleared() bool {
	return m.clearedcolli
}

// ColliID returns the "colli" edge ID in the mutation.
func (m *ShipmentParcelMutation) ColliID() (id pulid.ID, exists bool) {
	if m.colli != nil {
		return *m.colli, true
	}
	return
}

// ColliIDs returns the "colli" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ColliID instead. It exists only for internal usage by the builders.
func (m *ShipmentParcelMutation) ColliIDs() (ids []pulid.ID) {
	if id := m.colli; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetColli resets all changes to the "colli" edge.
func (m *ShipmentParcelMutation) ResetColli() {
	m.colli = nil
	m.clearedcolli = false
}

// AddOldColliIDs adds the "old_colli" edge to the Colli entity by ids.
func (m *ShipmentParcelMutation) AddOldColliIDs(ids ...pulid.ID) {
	if m.old_colli == nil {
		m.old_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.old_colli[ids[i]] = struct{}{}
	}
}

// ClearOldColli clears the "old_colli" edge to the Colli entity.
func (m *ShipmentParcelMutation) ClearOldColli() {
	m.clearedold_colli = true
}

// OldColliCleared reports if the "old_colli" edge to the Colli entity was cleared.
func (m *ShipmentParcelMutation) OldColliCleared() bool {
	return m.clearedold_colli
}

// RemoveOldColliIDs removes the "old_colli" edge to the Colli entity by IDs.
func (m *ShipmentParcelMutation) RemoveOldColliIDs(ids ...pulid.ID) {
	if m.removedold_colli == nil {
		m.removedold_colli = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.old_colli, ids[i])
		m.removedold_colli[ids[i]] = struct{}{}
	}
}

// RemovedOldColli returns the removed IDs of the "old_colli" edge to the Colli entity.
func (m *ShipmentParcelMutation) RemovedOldColliIDs() (ids []pulid.ID) {
	for id := range m.removedold_colli {
		ids = append(ids, id)
	}
	return
}

// OldColliIDs returns the "old_colli" edge IDs in the mutation.
func (m *ShipmentParcelMutation) OldColliIDs() (ids []pulid.ID) {
	for id := range m.old_colli {
		ids = append(ids, id)
	}
	return
}

// ResetOldColli resets all changes to the "old_colli" edge.
func (m *ShipmentParcelMutation) ResetOldColli() {
	m.old_colli = nil
	m.clearedold_colli = false
	m.removedold_colli = nil
}

// AddWorkspaceRecentScanIDs adds the "workspace_recent_scan" edge to the WorkspaceRecentScan entity by ids.
func (m *ShipmentParcelMutation) AddWorkspaceRecentScanIDs(ids ...pulid.ID) {
	if m.workspace_recent_scan == nil {
		m.workspace_recent_scan = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.workspace_recent_scan[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceRecentScan clears the "workspace_recent_scan" edge to the WorkspaceRecentScan entity.
func (m *ShipmentParcelMutation) ClearWorkspaceRecentScan() {
	m.clearedworkspace_recent_scan = true
}

// WorkspaceRecentScanCleared reports if the "workspace_recent_scan" edge to the WorkspaceRecentScan entity was cleared.
func (m *ShipmentParcelMutation) WorkspaceRecentScanCleared() bool {
	return m.clearedworkspace_recent_scan
}

// RemoveWorkspaceRecentScanIDs removes the "workspace_recent_scan" edge to the WorkspaceRecentScan entity by IDs.
func (m *ShipmentParcelMutation) RemoveWorkspaceRecentScanIDs(ids ...pulid.ID) {
	if m.removedworkspace_recent_scan == nil {
		m.removedworkspace_recent_scan = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspace_recent_scan, ids[i])
		m.removedworkspace_recent_scan[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceRecentScan returns the removed IDs of the "workspace_recent_scan" edge to the WorkspaceRecentScan entity.
func (m *ShipmentParcelMutation) RemovedWorkspaceRecentScanIDs() (ids []pulid.ID) {
	for id := range m.removedworkspace_recent_scan {
		ids = append(ids, id)
	}
	return
}

// WorkspaceRecentScanIDs returns the "workspace_recent_scan" edge IDs in the mutation.
func (m *ShipmentParcelMutation) WorkspaceRecentScanIDs() (ids []pulid.ID) {
	for id := range m.workspace_recent_scan {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceRecentScan resets all changes to the "workspace_recent_scan" edge.
func (m *ShipmentParcelMutation) ResetWorkspaceRecentScan() {
	m.workspace_recent_scan = nil
	m.clearedworkspace_recent_scan = false
	m.removedworkspace_recent_scan = nil
}

// SetPackagingID sets the "packaging" edge to the Packaging entity by id.
func (m *ShipmentParcelMutation) SetPackagingID(id pulid.ID) {
	m.packaging = &id
}

// ClearPackaging clears the "packaging" edge to the Packaging entity.
func (m *ShipmentParcelMutation) ClearPackaging() {
	m.clearedpackaging = true
}

// PackagingCleared reports if the "packaging" edge to the Packaging entity was cleared.
func (m *ShipmentParcelMutation) PackagingCleared() bool {
	return m.clearedpackaging
}

// PackagingID returns the "packaging" edge ID in the mutation.
func (m *ShipmentParcelMutation) PackagingID() (id pulid.ID, exists bool) {
	if m.packaging != nil {
		return *m.packaging, true
	}
	return
}

// PackagingIDs returns the "packaging" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PackagingID instead. It exists only for internal usage by the builders.
func (m *ShipmentParcelMutation) PackagingIDs() (ids []pulid.ID) {
	if id := m.packaging; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPackaging resets all changes to the "packaging" edge.
func (m *ShipmentParcelMutation) ResetPackaging() {
	m.packaging = nil
	m.clearedpackaging = false
}

// AddPrintJobIDs adds the "print_job" edge to the PrintJob entity by ids.
func (m *ShipmentParcelMutation) AddPrintJobIDs(ids ...pulid.ID) {
	if m.print_job == nil {
		m.print_job = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.print_job[ids[i]] = struct{}{}
	}
}

// ClearPrintJob clears the "print_job" edge to the PrintJob entity.
func (m *ShipmentParcelMutation) ClearPrintJob() {
	m.clearedprint_job = true
}

// PrintJobCleared reports if the "print_job" edge to the PrintJob entity was cleared.
func (m *ShipmentParcelMutation) PrintJobCleared() bool {
	return m.clearedprint_job
}

// RemovePrintJobIDs removes the "print_job" edge to the PrintJob entity by IDs.
func (m *ShipmentParcelMutation) RemovePrintJobIDs(ids ...pulid.ID) {
	if m.removedprint_job == nil {
		m.removedprint_job = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.print_job, ids[i])
		m.removedprint_job[ids[i]] = struct{}{}
	}
}

// RemovedPrintJob returns the removed IDs of the "print_job" edge to the PrintJob entity.
func (m *ShipmentParcelMutation) RemovedPrintJobIDs() (ids []pulid.ID) {
	for id := range m.removedprint_job {
		ids = append(ids, id)
	}
	return
}

// PrintJobIDs returns the "print_job" edge IDs in the mutation.
func (m *ShipmentParcelMutation) PrintJobIDs() (ids []pulid.ID) {
	for id := range m.print_job {
		ids = append(ids, id)
	}
	return
}

// ResetPrintJob resets all changes to the "print_job" edge.
func (m *ShipmentParcelMutation) ResetPrintJob() {
	m.print_job = nil
	m.clearedprint_job = false
	m.removedprint_job = nil
}

// SetDocumentFileID sets the "document_file" edge to the DocumentFile entity by id.
func (m *ShipmentParcelMutation) SetDocumentFileID(id pulid.ID) {
	m.document_file = &id
}

// ClearDocumentFile clears the "document_file" edge to the DocumentFile entity.
func (m *ShipmentParcelMutation) ClearDocumentFile() {
	m.cleareddocument_file = true
}

// DocumentFileCleared reports if the "document_file" edge to the DocumentFile entity was cleared.
func (m *ShipmentParcelMutation) DocumentFileCleared() bool {
	return m.cleareddocument_file
}

// DocumentFileID returns the "document_file" edge ID in the mutation.
func (m *ShipmentParcelMutation) DocumentFileID() (id pulid.ID, exists bool) {
	if m.document_file != nil {
		return *m.document_file, true
	}
	return
}

// DocumentFileIDs returns the "document_file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DocumentFileID instead. It exists only for internal usage by the builders.
func (m *ShipmentParcelMutation) DocumentFileIDs() (ids []pulid.ID) {
	if id := m.document_file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocumentFile resets all changes to the "document_file" edge.
func (m *ShipmentParcelMutation) ResetDocumentFile() {
	m.document_file = nil
	m.cleareddocument_file = false
}

// Where appends a list predicates to the ShipmentParcelMutation builder.
func (m *ShipmentParcelMutation) Where(ps ...predicate.ShipmentParcel) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentParcelMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentParcelMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentParcel, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentParcelMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentParcelMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentParcel).
func (m *ShipmentParcelMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentParcelMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, shipmentparcel.FieldTenantID)
	}
	if m.item_id != nil {
		fields = append(fields, shipmentparcel.FieldItemID)
	}
	if m.status != nil {
		fields = append(fields, shipmentparcel.FieldStatus)
	}
	if m.cc_pickup_signature_urls != nil {
		fields = append(fields, shipmentparcel.FieldCcPickupSignatureUrls)
	}
	if m.expected_at != nil {
		fields = append(fields, shipmentparcel.FieldExpectedAt)
	}
	if m.fulfillment_synced_at != nil {
		fields = append(fields, shipmentparcel.FieldFulfillmentSyncedAt)
	}
	if m.cancel_synced_at != nil {
		fields = append(fields, shipmentparcel.FieldCancelSyncedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentParcelMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentparcel.FieldTenantID:
		return m.TenantID()
	case shipmentparcel.FieldItemID:
		return m.ItemID()
	case shipmentparcel.FieldStatus:
		return m.Status()
	case shipmentparcel.FieldCcPickupSignatureUrls:
		return m.CcPickupSignatureUrls()
	case shipmentparcel.FieldExpectedAt:
		return m.ExpectedAt()
	case shipmentparcel.FieldFulfillmentSyncedAt:
		return m.FulfillmentSyncedAt()
	case shipmentparcel.FieldCancelSyncedAt:
		return m.CancelSyncedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentParcelMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentparcel.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipmentparcel.FieldItemID:
		return m.OldItemID(ctx)
	case shipmentparcel.FieldStatus:
		return m.OldStatus(ctx)
	case shipmentparcel.FieldCcPickupSignatureUrls:
		return m.OldCcPickupSignatureUrls(ctx)
	case shipmentparcel.FieldExpectedAt:
		return m.OldExpectedAt(ctx)
	case shipmentparcel.FieldFulfillmentSyncedAt:
		return m.OldFulfillmentSyncedAt(ctx)
	case shipmentparcel.FieldCancelSyncedAt:
		return m.OldCancelSyncedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentParcel field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentParcelMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentparcel.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipmentparcel.FieldItemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemID(v)
		return nil
	case shipmentparcel.FieldStatus:
		v, ok := value.(shipmentparcel.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case shipmentparcel.FieldCcPickupSignatureUrls:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCcPickupSignatureUrls(v)
		return nil
	case shipmentparcel.FieldExpectedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpectedAt(v)
		return nil
	case shipmentparcel.FieldFulfillmentSyncedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFulfillmentSyncedAt(v)
		return nil
	case shipmentparcel.FieldCancelSyncedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCancelSyncedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentParcel field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentParcelMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentParcelMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentParcelMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentParcel numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentParcelMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentparcel.FieldItemID) {
		fields = append(fields, shipmentparcel.FieldItemID)
	}
	if m.FieldCleared(shipmentparcel.FieldCcPickupSignatureUrls) {
		fields = append(fields, shipmentparcel.FieldCcPickupSignatureUrls)
	}
	if m.FieldCleared(shipmentparcel.FieldExpectedAt) {
		fields = append(fields, shipmentparcel.FieldExpectedAt)
	}
	if m.FieldCleared(shipmentparcel.FieldFulfillmentSyncedAt) {
		fields = append(fields, shipmentparcel.FieldFulfillmentSyncedAt)
	}
	if m.FieldCleared(shipmentparcel.FieldCancelSyncedAt) {
		fields = append(fields, shipmentparcel.FieldCancelSyncedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentParcelMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentParcelMutation) ClearField(name string) error {
	switch name {
	case shipmentparcel.FieldItemID:
		m.ClearItemID()
		return nil
	case shipmentparcel.FieldCcPickupSignatureUrls:
		m.ClearCcPickupSignatureUrls()
		return nil
	case shipmentparcel.FieldExpectedAt:
		m.ClearExpectedAt()
		return nil
	case shipmentparcel.FieldFulfillmentSyncedAt:
		m.ClearFulfillmentSyncedAt()
		return nil
	case shipmentparcel.FieldCancelSyncedAt:
		m.ClearCancelSyncedAt()
		return nil
	}
	return fmt.Errorf("unknown ShipmentParcel nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentParcelMutation) ResetField(name string) error {
	switch name {
	case shipmentparcel.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipmentparcel.FieldItemID:
		m.ResetItemID()
		return nil
	case shipmentparcel.FieldStatus:
		m.ResetStatus()
		return nil
	case shipmentparcel.FieldCcPickupSignatureUrls:
		m.ResetCcPickupSignatureUrls()
		return nil
	case shipmentparcel.FieldExpectedAt:
		m.ResetExpectedAt()
		return nil
	case shipmentparcel.FieldFulfillmentSyncedAt:
		m.ResetFulfillmentSyncedAt()
		return nil
	case shipmentparcel.FieldCancelSyncedAt:
		m.ResetCancelSyncedAt()
		return nil
	}
	return fmt.Errorf("unknown ShipmentParcel field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentParcelMutation) AddedEdges() []string {
	edges := make([]string, 0, 8)
	if m.tenant != nil {
		edges = append(edges, shipmentparcel.EdgeTenant)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentparcel.EdgeShipment)
	}
	if m.colli != nil {
		edges = append(edges, shipmentparcel.EdgeColli)
	}
	if m.old_colli != nil {
		edges = append(edges, shipmentparcel.EdgeOldColli)
	}
	if m.workspace_recent_scan != nil {
		edges = append(edges, shipmentparcel.EdgeWorkspaceRecentScan)
	}
	if m.packaging != nil {
		edges = append(edges, shipmentparcel.EdgePackaging)
	}
	if m.print_job != nil {
		edges = append(edges, shipmentparcel.EdgePrintJob)
	}
	if m.document_file != nil {
		edges = append(edges, shipmentparcel.EdgeDocumentFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentParcelMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentparcel.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmentparcel.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	case shipmentparcel.EdgeColli:
		if id := m.colli; id != nil {
			return []ent.Value{*id}
		}
	case shipmentparcel.EdgeOldColli:
		ids := make([]ent.Value, 0, len(m.old_colli))
		for id := range m.old_colli {
			ids = append(ids, id)
		}
		return ids
	case shipmentparcel.EdgeWorkspaceRecentScan:
		ids := make([]ent.Value, 0, len(m.workspace_recent_scan))
		for id := range m.workspace_recent_scan {
			ids = append(ids, id)
		}
		return ids
	case shipmentparcel.EdgePackaging:
		if id := m.packaging; id != nil {
			return []ent.Value{*id}
		}
	case shipmentparcel.EdgePrintJob:
		ids := make([]ent.Value, 0, len(m.print_job))
		for id := range m.print_job {
			ids = append(ids, id)
		}
		return ids
	case shipmentparcel.EdgeDocumentFile:
		if id := m.document_file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentParcelMutation) RemovedEdges() []string {
	edges := make([]string, 0, 8)
	if m.removedold_colli != nil {
		edges = append(edges, shipmentparcel.EdgeOldColli)
	}
	if m.removedworkspace_recent_scan != nil {
		edges = append(edges, shipmentparcel.EdgeWorkspaceRecentScan)
	}
	if m.removedprint_job != nil {
		edges = append(edges, shipmentparcel.EdgePrintJob)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentParcelMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case shipmentparcel.EdgeOldColli:
		ids := make([]ent.Value, 0, len(m.removedold_colli))
		for id := range m.removedold_colli {
			ids = append(ids, id)
		}
		return ids
	case shipmentparcel.EdgeWorkspaceRecentScan:
		ids := make([]ent.Value, 0, len(m.removedworkspace_recent_scan))
		for id := range m.removedworkspace_recent_scan {
			ids = append(ids, id)
		}
		return ids
	case shipmentparcel.EdgePrintJob:
		ids := make([]ent.Value, 0, len(m.removedprint_job))
		for id := range m.removedprint_job {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentParcelMutation) ClearedEdges() []string {
	edges := make([]string, 0, 8)
	if m.clearedtenant {
		edges = append(edges, shipmentparcel.EdgeTenant)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentparcel.EdgeShipment)
	}
	if m.clearedcolli {
		edges = append(edges, shipmentparcel.EdgeColli)
	}
	if m.clearedold_colli {
		edges = append(edges, shipmentparcel.EdgeOldColli)
	}
	if m.clearedworkspace_recent_scan {
		edges = append(edges, shipmentparcel.EdgeWorkspaceRecentScan)
	}
	if m.clearedpackaging {
		edges = append(edges, shipmentparcel.EdgePackaging)
	}
	if m.clearedprint_job {
		edges = append(edges, shipmentparcel.EdgePrintJob)
	}
	if m.cleareddocument_file {
		edges = append(edges, shipmentparcel.EdgeDocumentFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentParcelMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentparcel.EdgeTenant:
		return m.clearedtenant
	case shipmentparcel.EdgeShipment:
		return m.clearedshipment
	case shipmentparcel.EdgeColli:
		return m.clearedcolli
	case shipmentparcel.EdgeOldColli:
		return m.clearedold_colli
	case shipmentparcel.EdgeWorkspaceRecentScan:
		return m.clearedworkspace_recent_scan
	case shipmentparcel.EdgePackaging:
		return m.clearedpackaging
	case shipmentparcel.EdgePrintJob:
		return m.clearedprint_job
	case shipmentparcel.EdgeDocumentFile:
		return m.cleareddocument_file
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentParcelMutation) ClearEdge(name string) error {
	switch name {
	case shipmentparcel.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmentparcel.EdgeShipment:
		m.ClearShipment()
		return nil
	case shipmentparcel.EdgeColli:
		m.ClearColli()
		return nil
	case shipmentparcel.EdgePackaging:
		m.ClearPackaging()
		return nil
	case shipmentparcel.EdgeDocumentFile:
		m.ClearDocumentFile()
		return nil
	}
	return fmt.Errorf("unknown ShipmentParcel unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentParcelMutation) ResetEdge(name string) error {
	switch name {
	case shipmentparcel.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmentparcel.EdgeShipment:
		m.ResetShipment()
		return nil
	case shipmentparcel.EdgeColli:
		m.ResetColli()
		return nil
	case shipmentparcel.EdgeOldColli:
		m.ResetOldColli()
		return nil
	case shipmentparcel.EdgeWorkspaceRecentScan:
		m.ResetWorkspaceRecentScan()
		return nil
	case shipmentparcel.EdgePackaging:
		m.ResetPackaging()
		return nil
	case shipmentparcel.EdgePrintJob:
		m.ResetPrintJob()
		return nil
	case shipmentparcel.EdgeDocumentFile:
		m.ResetDocumentFile()
		return nil
	}
	return fmt.Errorf("unknown ShipmentParcel edge %s", name)
}

// ShipmentPostNordMutation represents an operation that mutates the ShipmentPostNord nodes in the graph.
type ShipmentPostNordMutation struct {
	config
	op                    Op
	typ                   string
	id                    *pulid.ID
	booking_id            *string
	item_id               *string
	shipment_reference_no *string
	clearedFields         map[string]struct{}
	tenant                *pulid.ID
	clearedtenant         bool
	shipment              *pulid.ID
	clearedshipment       bool
	done                  bool
	oldValue              func(context.Context) (*ShipmentPostNord, error)
	predicates            []predicate.ShipmentPostNord
}

var _ ent.Mutation = (*ShipmentPostNordMutation)(nil)

// shipmentpostnordOption allows management of the mutation configuration using functional options.
type shipmentpostnordOption func(*ShipmentPostNordMutation)

// newShipmentPostNordMutation creates new mutation for the ShipmentPostNord entity.
func newShipmentPostNordMutation(c config, op Op, opts ...shipmentpostnordOption) *ShipmentPostNordMutation {
	m := &ShipmentPostNordMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentPostNord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentPostNordID sets the ID field of the mutation.
func withShipmentPostNordID(id pulid.ID) shipmentpostnordOption {
	return func(m *ShipmentPostNordMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentPostNord
		)
		m.oldValue = func(ctx context.Context) (*ShipmentPostNord, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentPostNord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentPostNord sets the old ShipmentPostNord of the mutation.
func withShipmentPostNord(node *ShipmentPostNord) shipmentpostnordOption {
	return func(m *ShipmentPostNordMutation) {
		m.oldValue = func(context.Context) (*ShipmentPostNord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentPostNordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentPostNordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentPostNord entities.
func (m *ShipmentPostNordMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentPostNordMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentPostNordMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentPostNord.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentPostNordMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentPostNordMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentPostNord entity.
// If the ShipmentPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPostNordMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentPostNordMutation) ResetTenantID() {
	m.tenant = nil
}

// SetBookingID sets the "booking_id" field.
func (m *ShipmentPostNordMutation) SetBookingID(s string) {
	m.booking_id = &s
}

// BookingID returns the value of the "booking_id" field in the mutation.
func (m *ShipmentPostNordMutation) BookingID() (r string, exists bool) {
	v := m.booking_id
	if v == nil {
		return
	}
	return *v, true
}

// OldBookingID returns the old "booking_id" field's value of the ShipmentPostNord entity.
// If the ShipmentPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPostNordMutation) OldBookingID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBookingID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBookingID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBookingID: %w", err)
	}
	return oldValue.BookingID, nil
}

// ResetBookingID resets all changes to the "booking_id" field.
func (m *ShipmentPostNordMutation) ResetBookingID() {
	m.booking_id = nil
}

// SetItemID sets the "item_id" field.
func (m *ShipmentPostNordMutation) SetItemID(s string) {
	m.item_id = &s
}

// ItemID returns the value of the "item_id" field in the mutation.
func (m *ShipmentPostNordMutation) ItemID() (r string, exists bool) {
	v := m.item_id
	if v == nil {
		return
	}
	return *v, true
}

// OldItemID returns the old "item_id" field's value of the ShipmentPostNord entity.
// If the ShipmentPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPostNordMutation) OldItemID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldItemID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldItemID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldItemID: %w", err)
	}
	return oldValue.ItemID, nil
}

// ResetItemID resets all changes to the "item_id" field.
func (m *ShipmentPostNordMutation) ResetItemID() {
	m.item_id = nil
}

// SetShipmentReferenceNo sets the "shipment_reference_no" field.
func (m *ShipmentPostNordMutation) SetShipmentReferenceNo(s string) {
	m.shipment_reference_no = &s
}

// ShipmentReferenceNo returns the value of the "shipment_reference_no" field in the mutation.
func (m *ShipmentPostNordMutation) ShipmentReferenceNo() (r string, exists bool) {
	v := m.shipment_reference_no
	if v == nil {
		return
	}
	return *v, true
}

// OldShipmentReferenceNo returns the old "shipment_reference_no" field's value of the ShipmentPostNord entity.
// If the ShipmentPostNord object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentPostNordMutation) OldShipmentReferenceNo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShipmentReferenceNo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShipmentReferenceNo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShipmentReferenceNo: %w", err)
	}
	return oldValue.ShipmentReferenceNo, nil
}

// ResetShipmentReferenceNo resets all changes to the "shipment_reference_no" field.
func (m *ShipmentPostNordMutation) ResetShipmentReferenceNo() {
	m.shipment_reference_no = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentPostNordMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmentpostnord.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentPostNordMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentPostNordMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentPostNordMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentPostNordMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentPostNordMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentPostNordMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentPostNordMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentPostNordMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentPostNordMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentPostNordMutation builder.
func (m *ShipmentPostNordMutation) Where(ps ...predicate.ShipmentPostNord) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentPostNordMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentPostNordMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentPostNord, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentPostNordMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentPostNordMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentPostNord).
func (m *ShipmentPostNordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentPostNordMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, shipmentpostnord.FieldTenantID)
	}
	if m.booking_id != nil {
		fields = append(fields, shipmentpostnord.FieldBookingID)
	}
	if m.item_id != nil {
		fields = append(fields, shipmentpostnord.FieldItemID)
	}
	if m.shipment_reference_no != nil {
		fields = append(fields, shipmentpostnord.FieldShipmentReferenceNo)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentPostNordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentpostnord.FieldTenantID:
		return m.TenantID()
	case shipmentpostnord.FieldBookingID:
		return m.BookingID()
	case shipmentpostnord.FieldItemID:
		return m.ItemID()
	case shipmentpostnord.FieldShipmentReferenceNo:
		return m.ShipmentReferenceNo()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentPostNordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentpostnord.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipmentpostnord.FieldBookingID:
		return m.OldBookingID(ctx)
	case shipmentpostnord.FieldItemID:
		return m.OldItemID(ctx)
	case shipmentpostnord.FieldShipmentReferenceNo:
		return m.OldShipmentReferenceNo(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentPostNord field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentPostNordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentpostnord.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipmentpostnord.FieldBookingID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBookingID(v)
		return nil
	case shipmentpostnord.FieldItemID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetItemID(v)
		return nil
	case shipmentpostnord.FieldShipmentReferenceNo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShipmentReferenceNo(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentPostNord field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentPostNordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentPostNordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentPostNordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ShipmentPostNord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentPostNordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentPostNordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentPostNordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ShipmentPostNord nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentPostNordMutation) ResetField(name string) error {
	switch name {
	case shipmentpostnord.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipmentpostnord.FieldBookingID:
		m.ResetBookingID()
		return nil
	case shipmentpostnord.FieldItemID:
		m.ResetItemID()
		return nil
	case shipmentpostnord.FieldShipmentReferenceNo:
		m.ResetShipmentReferenceNo()
		return nil
	}
	return fmt.Errorf("unknown ShipmentPostNord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentPostNordMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, shipmentpostnord.EdgeTenant)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentpostnord.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentPostNordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentpostnord.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmentpostnord.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentPostNordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentPostNordMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentPostNordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, shipmentpostnord.EdgeTenant)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentpostnord.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentPostNordMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentpostnord.EdgeTenant:
		return m.clearedtenant
	case shipmentpostnord.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentPostNordMutation) ClearEdge(name string) error {
	switch name {
	case shipmentpostnord.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmentpostnord.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentPostNord unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentPostNordMutation) ResetEdge(name string) error {
	switch name {
	case shipmentpostnord.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmentpostnord.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentPostNord edge %s", name)
}

// ShipmentUSPSMutation represents an operation that mutates the ShipmentUSPS nodes in the graph.
type ShipmentUSPSMutation struct {
	config
	op                      Op
	typ                     string
	id                      *pulid.ID
	tracking_number         *string
	postage                 *float64
	addpostage              *float64
	scheduled_delivery_date *time.Time
	clearedFields           map[string]struct{}
	tenant                  *pulid.ID
	clearedtenant           bool
	shipment                *pulid.ID
	clearedshipment         bool
	done                    bool
	oldValue                func(context.Context) (*ShipmentUSPS, error)
	predicates              []predicate.ShipmentUSPS
}

var _ ent.Mutation = (*ShipmentUSPSMutation)(nil)

// shipmentuspsOption allows management of the mutation configuration using functional options.
type shipmentuspsOption func(*ShipmentUSPSMutation)

// newShipmentUSPSMutation creates new mutation for the ShipmentUSPS entity.
func newShipmentUSPSMutation(c config, op Op, opts ...shipmentuspsOption) *ShipmentUSPSMutation {
	m := &ShipmentUSPSMutation{
		config:        c,
		op:            op,
		typ:           TypeShipmentUSPS,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withShipmentUSPSID sets the ID field of the mutation.
func withShipmentUSPSID(id pulid.ID) shipmentuspsOption {
	return func(m *ShipmentUSPSMutation) {
		var (
			err   error
			once  sync.Once
			value *ShipmentUSPS
		)
		m.oldValue = func(ctx context.Context) (*ShipmentUSPS, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ShipmentUSPS.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withShipmentUSPS sets the old ShipmentUSPS of the mutation.
func withShipmentUSPS(node *ShipmentUSPS) shipmentuspsOption {
	return func(m *ShipmentUSPSMutation) {
		m.oldValue = func(context.Context) (*ShipmentUSPS, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ShipmentUSPSMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ShipmentUSPSMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of ShipmentUSPS entities.
func (m *ShipmentUSPSMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ShipmentUSPSMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *ShipmentUSPSMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().ShipmentUSPS.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *ShipmentUSPSMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *ShipmentUSPSMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the ShipmentUSPS entity.
// If the ShipmentUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentUSPSMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *ShipmentUSPSMutation) ResetTenantID() {
	m.tenant = nil
}

// SetTrackingNumber sets the "tracking_number" field.
func (m *ShipmentUSPSMutation) SetTrackingNumber(s string) {
	m.tracking_number = &s
}

// TrackingNumber returns the value of the "tracking_number" field in the mutation.
func (m *ShipmentUSPSMutation) TrackingNumber() (r string, exists bool) {
	v := m.tracking_number
	if v == nil {
		return
	}
	return *v, true
}

// OldTrackingNumber returns the old "tracking_number" field's value of the ShipmentUSPS entity.
// If the ShipmentUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentUSPSMutation) OldTrackingNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTrackingNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTrackingNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTrackingNumber: %w", err)
	}
	return oldValue.TrackingNumber, nil
}

// ClearTrackingNumber clears the value of the "tracking_number" field.
func (m *ShipmentUSPSMutation) ClearTrackingNumber() {
	m.tracking_number = nil
	m.clearedFields[shipmentusps.FieldTrackingNumber] = struct{}{}
}

// TrackingNumberCleared returns if the "tracking_number" field was cleared in this mutation.
func (m *ShipmentUSPSMutation) TrackingNumberCleared() bool {
	_, ok := m.clearedFields[shipmentusps.FieldTrackingNumber]
	return ok
}

// ResetTrackingNumber resets all changes to the "tracking_number" field.
func (m *ShipmentUSPSMutation) ResetTrackingNumber() {
	m.tracking_number = nil
	delete(m.clearedFields, shipmentusps.FieldTrackingNumber)
}

// SetPostage sets the "postage" field.
func (m *ShipmentUSPSMutation) SetPostage(f float64) {
	m.postage = &f
	m.addpostage = nil
}

// Postage returns the value of the "postage" field in the mutation.
func (m *ShipmentUSPSMutation) Postage() (r float64, exists bool) {
	v := m.postage
	if v == nil {
		return
	}
	return *v, true
}

// OldPostage returns the old "postage" field's value of the ShipmentUSPS entity.
// If the ShipmentUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentUSPSMutation) OldPostage(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostage: %w", err)
	}
	return oldValue.Postage, nil
}

// AddPostage adds f to the "postage" field.
func (m *ShipmentUSPSMutation) AddPostage(f float64) {
	if m.addpostage != nil {
		*m.addpostage += f
	} else {
		m.addpostage = &f
	}
}

// AddedPostage returns the value that was added to the "postage" field in this mutation.
func (m *ShipmentUSPSMutation) AddedPostage() (r float64, exists bool) {
	v := m.addpostage
	if v == nil {
		return
	}
	return *v, true
}

// ClearPostage clears the value of the "postage" field.
func (m *ShipmentUSPSMutation) ClearPostage() {
	m.postage = nil
	m.addpostage = nil
	m.clearedFields[shipmentusps.FieldPostage] = struct{}{}
}

// PostageCleared returns if the "postage" field was cleared in this mutation.
func (m *ShipmentUSPSMutation) PostageCleared() bool {
	_, ok := m.clearedFields[shipmentusps.FieldPostage]
	return ok
}

// ResetPostage resets all changes to the "postage" field.
func (m *ShipmentUSPSMutation) ResetPostage() {
	m.postage = nil
	m.addpostage = nil
	delete(m.clearedFields, shipmentusps.FieldPostage)
}

// SetScheduledDeliveryDate sets the "scheduled_delivery_date" field.
func (m *ShipmentUSPSMutation) SetScheduledDeliveryDate(t time.Time) {
	m.scheduled_delivery_date = &t
}

// ScheduledDeliveryDate returns the value of the "scheduled_delivery_date" field in the mutation.
func (m *ShipmentUSPSMutation) ScheduledDeliveryDate() (r time.Time, exists bool) {
	v := m.scheduled_delivery_date
	if v == nil {
		return
	}
	return *v, true
}

// OldScheduledDeliveryDate returns the old "scheduled_delivery_date" field's value of the ShipmentUSPS entity.
// If the ShipmentUSPS object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ShipmentUSPSMutation) OldScheduledDeliveryDate(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScheduledDeliveryDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScheduledDeliveryDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScheduledDeliveryDate: %w", err)
	}
	return oldValue.ScheduledDeliveryDate, nil
}

// ClearScheduledDeliveryDate clears the value of the "scheduled_delivery_date" field.
func (m *ShipmentUSPSMutation) ClearScheduledDeliveryDate() {
	m.scheduled_delivery_date = nil
	m.clearedFields[shipmentusps.FieldScheduledDeliveryDate] = struct{}{}
}

// ScheduledDeliveryDateCleared returns if the "scheduled_delivery_date" field was cleared in this mutation.
func (m *ShipmentUSPSMutation) ScheduledDeliveryDateCleared() bool {
	_, ok := m.clearedFields[shipmentusps.FieldScheduledDeliveryDate]
	return ok
}

// ResetScheduledDeliveryDate resets all changes to the "scheduled_delivery_date" field.
func (m *ShipmentUSPSMutation) ResetScheduledDeliveryDate() {
	m.scheduled_delivery_date = nil
	delete(m.clearedFields, shipmentusps.FieldScheduledDeliveryDate)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *ShipmentUSPSMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[shipmentusps.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *ShipmentUSPSMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *ShipmentUSPSMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *ShipmentUSPSMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentID sets the "shipment" edge to the Shipment entity by id.
func (m *ShipmentUSPSMutation) SetShipmentID(id pulid.ID) {
	m.shipment = &id
}

// ClearShipment clears the "shipment" edge to the Shipment entity.
func (m *ShipmentUSPSMutation) ClearShipment() {
	m.clearedshipment = true
}

// ShipmentCleared reports if the "shipment" edge to the Shipment entity was cleared.
func (m *ShipmentUSPSMutation) ShipmentCleared() bool {
	return m.clearedshipment
}

// ShipmentID returns the "shipment" edge ID in the mutation.
func (m *ShipmentUSPSMutation) ShipmentID() (id pulid.ID, exists bool) {
	if m.shipment != nil {
		return *m.shipment, true
	}
	return
}

// ShipmentIDs returns the "shipment" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentID instead. It exists only for internal usage by the builders.
func (m *ShipmentUSPSMutation) ShipmentIDs() (ids []pulid.ID) {
	if id := m.shipment; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipment resets all changes to the "shipment" edge.
func (m *ShipmentUSPSMutation) ResetShipment() {
	m.shipment = nil
	m.clearedshipment = false
}

// Where appends a list predicates to the ShipmentUSPSMutation builder.
func (m *ShipmentUSPSMutation) Where(ps ...predicate.ShipmentUSPS) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the ShipmentUSPSMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *ShipmentUSPSMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.ShipmentUSPS, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *ShipmentUSPSMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *ShipmentUSPSMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (ShipmentUSPS).
func (m *ShipmentUSPSMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ShipmentUSPSMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.tenant != nil {
		fields = append(fields, shipmentusps.FieldTenantID)
	}
	if m.tracking_number != nil {
		fields = append(fields, shipmentusps.FieldTrackingNumber)
	}
	if m.postage != nil {
		fields = append(fields, shipmentusps.FieldPostage)
	}
	if m.scheduled_delivery_date != nil {
		fields = append(fields, shipmentusps.FieldScheduledDeliveryDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ShipmentUSPSMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case shipmentusps.FieldTenantID:
		return m.TenantID()
	case shipmentusps.FieldTrackingNumber:
		return m.TrackingNumber()
	case shipmentusps.FieldPostage:
		return m.Postage()
	case shipmentusps.FieldScheduledDeliveryDate:
		return m.ScheduledDeliveryDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ShipmentUSPSMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case shipmentusps.FieldTenantID:
		return m.OldTenantID(ctx)
	case shipmentusps.FieldTrackingNumber:
		return m.OldTrackingNumber(ctx)
	case shipmentusps.FieldPostage:
		return m.OldPostage(ctx)
	case shipmentusps.FieldScheduledDeliveryDate:
		return m.OldScheduledDeliveryDate(ctx)
	}
	return nil, fmt.Errorf("unknown ShipmentUSPS field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentUSPSMutation) SetField(name string, value ent.Value) error {
	switch name {
	case shipmentusps.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case shipmentusps.FieldTrackingNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTrackingNumber(v)
		return nil
	case shipmentusps.FieldPostage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostage(v)
		return nil
	case shipmentusps.FieldScheduledDeliveryDate:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScheduledDeliveryDate(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentUSPS field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ShipmentUSPSMutation) AddedFields() []string {
	var fields []string
	if m.addpostage != nil {
		fields = append(fields, shipmentusps.FieldPostage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ShipmentUSPSMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case shipmentusps.FieldPostage:
		return m.AddedPostage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ShipmentUSPSMutation) AddField(name string, value ent.Value) error {
	switch name {
	case shipmentusps.FieldPostage:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPostage(v)
		return nil
	}
	return fmt.Errorf("unknown ShipmentUSPS numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ShipmentUSPSMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(shipmentusps.FieldTrackingNumber) {
		fields = append(fields, shipmentusps.FieldTrackingNumber)
	}
	if m.FieldCleared(shipmentusps.FieldPostage) {
		fields = append(fields, shipmentusps.FieldPostage)
	}
	if m.FieldCleared(shipmentusps.FieldScheduledDeliveryDate) {
		fields = append(fields, shipmentusps.FieldScheduledDeliveryDate)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ShipmentUSPSMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ShipmentUSPSMutation) ClearField(name string) error {
	switch name {
	case shipmentusps.FieldTrackingNumber:
		m.ClearTrackingNumber()
		return nil
	case shipmentusps.FieldPostage:
		m.ClearPostage()
		return nil
	case shipmentusps.FieldScheduledDeliveryDate:
		m.ClearScheduledDeliveryDate()
		return nil
	}
	return fmt.Errorf("unknown ShipmentUSPS nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ShipmentUSPSMutation) ResetField(name string) error {
	switch name {
	case shipmentusps.FieldTenantID:
		m.ResetTenantID()
		return nil
	case shipmentusps.FieldTrackingNumber:
		m.ResetTrackingNumber()
		return nil
	case shipmentusps.FieldPostage:
		m.ResetPostage()
		return nil
	case shipmentusps.FieldScheduledDeliveryDate:
		m.ResetScheduledDeliveryDate()
		return nil
	}
	return fmt.Errorf("unknown ShipmentUSPS field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ShipmentUSPSMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.tenant != nil {
		edges = append(edges, shipmentusps.EdgeTenant)
	}
	if m.shipment != nil {
		edges = append(edges, shipmentusps.EdgeShipment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ShipmentUSPSMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case shipmentusps.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case shipmentusps.EdgeShipment:
		if id := m.shipment; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ShipmentUSPSMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ShipmentUSPSMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ShipmentUSPSMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedtenant {
		edges = append(edges, shipmentusps.EdgeTenant)
	}
	if m.clearedshipment {
		edges = append(edges, shipmentusps.EdgeShipment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ShipmentUSPSMutation) EdgeCleared(name string) bool {
	switch name {
	case shipmentusps.EdgeTenant:
		return m.clearedtenant
	case shipmentusps.EdgeShipment:
		return m.clearedshipment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ShipmentUSPSMutation) ClearEdge(name string) error {
	switch name {
	case shipmentusps.EdgeTenant:
		m.ClearTenant()
		return nil
	case shipmentusps.EdgeShipment:
		m.ClearShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentUSPS unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ShipmentUSPSMutation) ResetEdge(name string) error {
	switch name {
	case shipmentusps.EdgeTenant:
		m.ResetTenant()
		return nil
	case shipmentusps.EdgeShipment:
		m.ResetShipment()
		return nil
	}
	return fmt.Errorf("unknown ShipmentUSPS edge %s", name)
}

// SignupOptionsMutation represents an operation that mutates the SignupOptions nodes in the graph.
type SignupOptionsMutation struct {
	config
	op                      Op
	typ                     string
	id                      *pulid.ID
	better_delivery_options *bool
	improve_pick_pack       *bool
	shipping_label          *bool
	custom_docs             *bool
	reduced_costs           *bool
	easy_returns            *bool
	click_collect           *bool
	num_shipments           *int
	addnum_shipments        *int
	clearedFields           map[string]struct{}
	users                   *pulid.ID
	clearedusers            bool
	done                    bool
	oldValue                func(context.Context) (*SignupOptions, error)
	predicates              []predicate.SignupOptions
}

var _ ent.Mutation = (*SignupOptionsMutation)(nil)

// signupoptionsOption allows management of the mutation configuration using functional options.
type signupoptionsOption func(*SignupOptionsMutation)

// newSignupOptionsMutation creates new mutation for the SignupOptions entity.
func newSignupOptionsMutation(c config, op Op, opts ...signupoptionsOption) *SignupOptionsMutation {
	m := &SignupOptionsMutation{
		config:        c,
		op:            op,
		typ:           TypeSignupOptions,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSignupOptionsID sets the ID field of the mutation.
func withSignupOptionsID(id pulid.ID) signupoptionsOption {
	return func(m *SignupOptionsMutation) {
		var (
			err   error
			once  sync.Once
			value *SignupOptions
		)
		m.oldValue = func(ctx context.Context) (*SignupOptions, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SignupOptions.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSignupOptions sets the old SignupOptions of the mutation.
func withSignupOptions(node *SignupOptions) signupoptionsOption {
	return func(m *SignupOptionsMutation) {
		m.oldValue = func(context.Context) (*SignupOptions, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SignupOptionsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SignupOptionsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SignupOptions entities.
func (m *SignupOptionsMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SignupOptionsMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SignupOptionsMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SignupOptions.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetBetterDeliveryOptions sets the "better_delivery_options" field.
func (m *SignupOptionsMutation) SetBetterDeliveryOptions(b bool) {
	m.better_delivery_options = &b
}

// BetterDeliveryOptions returns the value of the "better_delivery_options" field in the mutation.
func (m *SignupOptionsMutation) BetterDeliveryOptions() (r bool, exists bool) {
	v := m.better_delivery_options
	if v == nil {
		return
	}
	return *v, true
}

// OldBetterDeliveryOptions returns the old "better_delivery_options" field's value of the SignupOptions entity.
// If the SignupOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignupOptionsMutation) OldBetterDeliveryOptions(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBetterDeliveryOptions is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBetterDeliveryOptions requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBetterDeliveryOptions: %w", err)
	}
	return oldValue.BetterDeliveryOptions, nil
}

// ResetBetterDeliveryOptions resets all changes to the "better_delivery_options" field.
func (m *SignupOptionsMutation) ResetBetterDeliveryOptions() {
	m.better_delivery_options = nil
}

// SetImprovePickPack sets the "improve_pick_pack" field.
func (m *SignupOptionsMutation) SetImprovePickPack(b bool) {
	m.improve_pick_pack = &b
}

// ImprovePickPack returns the value of the "improve_pick_pack" field in the mutation.
func (m *SignupOptionsMutation) ImprovePickPack() (r bool, exists bool) {
	v := m.improve_pick_pack
	if v == nil {
		return
	}
	return *v, true
}

// OldImprovePickPack returns the old "improve_pick_pack" field's value of the SignupOptions entity.
// If the SignupOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignupOptionsMutation) OldImprovePickPack(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldImprovePickPack is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldImprovePickPack requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldImprovePickPack: %w", err)
	}
	return oldValue.ImprovePickPack, nil
}

// ResetImprovePickPack resets all changes to the "improve_pick_pack" field.
func (m *SignupOptionsMutation) ResetImprovePickPack() {
	m.improve_pick_pack = nil
}

// SetShippingLabel sets the "shipping_label" field.
func (m *SignupOptionsMutation) SetShippingLabel(b bool) {
	m.shipping_label = &b
}

// ShippingLabel returns the value of the "shipping_label" field in the mutation.
func (m *SignupOptionsMutation) ShippingLabel() (r bool, exists bool) {
	v := m.shipping_label
	if v == nil {
		return
	}
	return *v, true
}

// OldShippingLabel returns the old "shipping_label" field's value of the SignupOptions entity.
// If the SignupOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignupOptionsMutation) OldShippingLabel(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldShippingLabel is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldShippingLabel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldShippingLabel: %w", err)
	}
	return oldValue.ShippingLabel, nil
}

// ResetShippingLabel resets all changes to the "shipping_label" field.
func (m *SignupOptionsMutation) ResetShippingLabel() {
	m.shipping_label = nil
}

// SetCustomDocs sets the "custom_docs" field.
func (m *SignupOptionsMutation) SetCustomDocs(b bool) {
	m.custom_docs = &b
}

// CustomDocs returns the value of the "custom_docs" field in the mutation.
func (m *SignupOptionsMutation) CustomDocs() (r bool, exists bool) {
	v := m.custom_docs
	if v == nil {
		return
	}
	return *v, true
}

// OldCustomDocs returns the old "custom_docs" field's value of the SignupOptions entity.
// If the SignupOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignupOptionsMutation) OldCustomDocs(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustomDocs is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustomDocs requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustomDocs: %w", err)
	}
	return oldValue.CustomDocs, nil
}

// ResetCustomDocs resets all changes to the "custom_docs" field.
func (m *SignupOptionsMutation) ResetCustomDocs() {
	m.custom_docs = nil
}

// SetReducedCosts sets the "reduced_costs" field.
func (m *SignupOptionsMutation) SetReducedCosts(b bool) {
	m.reduced_costs = &b
}

// ReducedCosts returns the value of the "reduced_costs" field in the mutation.
func (m *SignupOptionsMutation) ReducedCosts() (r bool, exists bool) {
	v := m.reduced_costs
	if v == nil {
		return
	}
	return *v, true
}

// OldReducedCosts returns the old "reduced_costs" field's value of the SignupOptions entity.
// If the SignupOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignupOptionsMutation) OldReducedCosts(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReducedCosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReducedCosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReducedCosts: %w", err)
	}
	return oldValue.ReducedCosts, nil
}

// ResetReducedCosts resets all changes to the "reduced_costs" field.
func (m *SignupOptionsMutation) ResetReducedCosts() {
	m.reduced_costs = nil
}

// SetEasyReturns sets the "easy_returns" field.
func (m *SignupOptionsMutation) SetEasyReturns(b bool) {
	m.easy_returns = &b
}

// EasyReturns returns the value of the "easy_returns" field in the mutation.
func (m *SignupOptionsMutation) EasyReturns() (r bool, exists bool) {
	v := m.easy_returns
	if v == nil {
		return
	}
	return *v, true
}

// OldEasyReturns returns the old "easy_returns" field's value of the SignupOptions entity.
// If the SignupOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignupOptionsMutation) OldEasyReturns(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEasyReturns is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEasyReturns requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEasyReturns: %w", err)
	}
	return oldValue.EasyReturns, nil
}

// ResetEasyReturns resets all changes to the "easy_returns" field.
func (m *SignupOptionsMutation) ResetEasyReturns() {
	m.easy_returns = nil
}

// SetClickCollect sets the "click_collect" field.
func (m *SignupOptionsMutation) SetClickCollect(b bool) {
	m.click_collect = &b
}

// ClickCollect returns the value of the "click_collect" field in the mutation.
func (m *SignupOptionsMutation) ClickCollect() (r bool, exists bool) {
	v := m.click_collect
	if v == nil {
		return
	}
	return *v, true
}

// OldClickCollect returns the old "click_collect" field's value of the SignupOptions entity.
// If the SignupOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignupOptionsMutation) OldClickCollect(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClickCollect is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClickCollect requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClickCollect: %w", err)
	}
	return oldValue.ClickCollect, nil
}

// ResetClickCollect resets all changes to the "click_collect" field.
func (m *SignupOptionsMutation) ResetClickCollect() {
	m.click_collect = nil
}

// SetNumShipments sets the "num_shipments" field.
func (m *SignupOptionsMutation) SetNumShipments(i int) {
	m.num_shipments = &i
	m.addnum_shipments = nil
}

// NumShipments returns the value of the "num_shipments" field in the mutation.
func (m *SignupOptionsMutation) NumShipments() (r int, exists bool) {
	v := m.num_shipments
	if v == nil {
		return
	}
	return *v, true
}

// OldNumShipments returns the old "num_shipments" field's value of the SignupOptions entity.
// If the SignupOptions object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SignupOptionsMutation) OldNumShipments(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumShipments is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumShipments requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumShipments: %w", err)
	}
	return oldValue.NumShipments, nil
}

// AddNumShipments adds i to the "num_shipments" field.
func (m *SignupOptionsMutation) AddNumShipments(i int) {
	if m.addnum_shipments != nil {
		*m.addnum_shipments += i
	} else {
		m.addnum_shipments = &i
	}
}

// AddedNumShipments returns the value that was added to the "num_shipments" field in this mutation.
func (m *SignupOptionsMutation) AddedNumShipments() (r int, exists bool) {
	v := m.addnum_shipments
	if v == nil {
		return
	}
	return *v, true
}

// ResetNumShipments resets all changes to the "num_shipments" field.
func (m *SignupOptionsMutation) ResetNumShipments() {
	m.num_shipments = nil
	m.addnum_shipments = nil
}

// SetUsersID sets the "users" edge to the User entity by id.
func (m *SignupOptionsMutation) SetUsersID(id pulid.ID) {
	m.users = &id
}

// ClearUsers clears the "users" edge to the User entity.
func (m *SignupOptionsMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *SignupOptionsMutation) UsersCleared() bool {
	return m.clearedusers
}

// UsersID returns the "users" edge ID in the mutation.
func (m *SignupOptionsMutation) UsersID() (id pulid.ID, exists bool) {
	if m.users != nil {
		return *m.users, true
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UsersID instead. It exists only for internal usage by the builders.
func (m *SignupOptionsMutation) UsersIDs() (ids []pulid.ID) {
	if id := m.users; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *SignupOptionsMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
}

// Where appends a list predicates to the SignupOptionsMutation builder.
func (m *SignupOptionsMutation) Where(ps ...predicate.SignupOptions) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SignupOptionsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SignupOptionsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SignupOptions, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SignupOptionsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SignupOptionsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SignupOptions).
func (m *SignupOptionsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SignupOptionsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.better_delivery_options != nil {
		fields = append(fields, signupoptions.FieldBetterDeliveryOptions)
	}
	if m.improve_pick_pack != nil {
		fields = append(fields, signupoptions.FieldImprovePickPack)
	}
	if m.shipping_label != nil {
		fields = append(fields, signupoptions.FieldShippingLabel)
	}
	if m.custom_docs != nil {
		fields = append(fields, signupoptions.FieldCustomDocs)
	}
	if m.reduced_costs != nil {
		fields = append(fields, signupoptions.FieldReducedCosts)
	}
	if m.easy_returns != nil {
		fields = append(fields, signupoptions.FieldEasyReturns)
	}
	if m.click_collect != nil {
		fields = append(fields, signupoptions.FieldClickCollect)
	}
	if m.num_shipments != nil {
		fields = append(fields, signupoptions.FieldNumShipments)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SignupOptionsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case signupoptions.FieldBetterDeliveryOptions:
		return m.BetterDeliveryOptions()
	case signupoptions.FieldImprovePickPack:
		return m.ImprovePickPack()
	case signupoptions.FieldShippingLabel:
		return m.ShippingLabel()
	case signupoptions.FieldCustomDocs:
		return m.CustomDocs()
	case signupoptions.FieldReducedCosts:
		return m.ReducedCosts()
	case signupoptions.FieldEasyReturns:
		return m.EasyReturns()
	case signupoptions.FieldClickCollect:
		return m.ClickCollect()
	case signupoptions.FieldNumShipments:
		return m.NumShipments()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SignupOptionsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case signupoptions.FieldBetterDeliveryOptions:
		return m.OldBetterDeliveryOptions(ctx)
	case signupoptions.FieldImprovePickPack:
		return m.OldImprovePickPack(ctx)
	case signupoptions.FieldShippingLabel:
		return m.OldShippingLabel(ctx)
	case signupoptions.FieldCustomDocs:
		return m.OldCustomDocs(ctx)
	case signupoptions.FieldReducedCosts:
		return m.OldReducedCosts(ctx)
	case signupoptions.FieldEasyReturns:
		return m.OldEasyReturns(ctx)
	case signupoptions.FieldClickCollect:
		return m.OldClickCollect(ctx)
	case signupoptions.FieldNumShipments:
		return m.OldNumShipments(ctx)
	}
	return nil, fmt.Errorf("unknown SignupOptions field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignupOptionsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case signupoptions.FieldBetterDeliveryOptions:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBetterDeliveryOptions(v)
		return nil
	case signupoptions.FieldImprovePickPack:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetImprovePickPack(v)
		return nil
	case signupoptions.FieldShippingLabel:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetShippingLabel(v)
		return nil
	case signupoptions.FieldCustomDocs:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustomDocs(v)
		return nil
	case signupoptions.FieldReducedCosts:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReducedCosts(v)
		return nil
	case signupoptions.FieldEasyReturns:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEasyReturns(v)
		return nil
	case signupoptions.FieldClickCollect:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickCollect(v)
		return nil
	case signupoptions.FieldNumShipments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumShipments(v)
		return nil
	}
	return fmt.Errorf("unknown SignupOptions field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SignupOptionsMutation) AddedFields() []string {
	var fields []string
	if m.addnum_shipments != nil {
		fields = append(fields, signupoptions.FieldNumShipments)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SignupOptionsMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case signupoptions.FieldNumShipments:
		return m.AddedNumShipments()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SignupOptionsMutation) AddField(name string, value ent.Value) error {
	switch name {
	case signupoptions.FieldNumShipments:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumShipments(v)
		return nil
	}
	return fmt.Errorf("unknown SignupOptions numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SignupOptionsMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SignupOptionsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SignupOptionsMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SignupOptions nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SignupOptionsMutation) ResetField(name string) error {
	switch name {
	case signupoptions.FieldBetterDeliveryOptions:
		m.ResetBetterDeliveryOptions()
		return nil
	case signupoptions.FieldImprovePickPack:
		m.ResetImprovePickPack()
		return nil
	case signupoptions.FieldShippingLabel:
		m.ResetShippingLabel()
		return nil
	case signupoptions.FieldCustomDocs:
		m.ResetCustomDocs()
		return nil
	case signupoptions.FieldReducedCosts:
		m.ResetReducedCosts()
		return nil
	case signupoptions.FieldEasyReturns:
		m.ResetEasyReturns()
		return nil
	case signupoptions.FieldClickCollect:
		m.ResetClickCollect()
		return nil
	case signupoptions.FieldNumShipments:
		m.ResetNumShipments()
		return nil
	}
	return fmt.Errorf("unknown SignupOptions field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SignupOptionsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.users != nil {
		edges = append(edges, signupoptions.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SignupOptionsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case signupoptions.EdgeUsers:
		if id := m.users; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SignupOptionsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SignupOptionsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SignupOptionsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedusers {
		edges = append(edges, signupoptions.EdgeUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SignupOptionsMutation) EdgeCleared(name string) bool {
	switch name {
	case signupoptions.EdgeUsers:
		return m.clearedusers
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SignupOptionsMutation) ClearEdge(name string) error {
	switch name {
	case signupoptions.EdgeUsers:
		m.ClearUsers()
		return nil
	}
	return fmt.Errorf("unknown SignupOptions unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SignupOptionsMutation) ResetEdge(name string) error {
	switch name {
	case signupoptions.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown SignupOptions edge %s", name)
}

// SystemEventsMutation represents an operation that mutates the SystemEvents nodes in the graph.
type SystemEventsMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.ID
	event_type    *systemevents.EventType
	event_type_id *string
	status        *systemevents.Status
	description   *string
	data          *string
	updated_at    *time.Time
	created_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *pulid.ID
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*SystemEvents, error)
	predicates    []predicate.SystemEvents
}

var _ ent.Mutation = (*SystemEventsMutation)(nil)

// systemeventsOption allows management of the mutation configuration using functional options.
type systemeventsOption func(*SystemEventsMutation)

// newSystemEventsMutation creates new mutation for the SystemEvents entity.
func newSystemEventsMutation(c config, op Op, opts ...systemeventsOption) *SystemEventsMutation {
	m := &SystemEventsMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemEvents,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemEventsID sets the ID field of the mutation.
func withSystemEventsID(id pulid.ID) systemeventsOption {
	return func(m *SystemEventsMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemEvents
		)
		m.oldValue = func(ctx context.Context) (*SystemEvents, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemEvents.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemEvents sets the old SystemEvents of the mutation.
func withSystemEvents(node *SystemEvents) systemeventsOption {
	return func(m *SystemEventsMutation) {
		m.oldValue = func(context.Context) (*SystemEvents, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemEventsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemEventsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemEvents entities.
func (m *SystemEventsMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemEventsMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemEventsMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemEvents.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *SystemEventsMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *SystemEventsMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the SystemEvents entity.
// If the SystemEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEventsMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *SystemEventsMutation) ResetTenantID() {
	m.tenant = nil
}

// SetEventType sets the "event_type" field.
func (m *SystemEventsMutation) SetEventType(st systemevents.EventType) {
	m.event_type = &st
}

// EventType returns the value of the "event_type" field in the mutation.
func (m *SystemEventsMutation) EventType() (r systemevents.EventType, exists bool) {
	v := m.event_type
	if v == nil {
		return
	}
	return *v, true
}

// OldEventType returns the old "event_type" field's value of the SystemEvents entity.
// If the SystemEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEventsMutation) OldEventType(ctx context.Context) (v systemevents.EventType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventType: %w", err)
	}
	return oldValue.EventType, nil
}

// ResetEventType resets all changes to the "event_type" field.
func (m *SystemEventsMutation) ResetEventType() {
	m.event_type = nil
}

// SetEventTypeID sets the "event_type_id" field.
func (m *SystemEventsMutation) SetEventTypeID(s string) {
	m.event_type_id = &s
}

// EventTypeID returns the value of the "event_type_id" field in the mutation.
func (m *SystemEventsMutation) EventTypeID() (r string, exists bool) {
	v := m.event_type_id
	if v == nil {
		return
	}
	return *v, true
}

// OldEventTypeID returns the old "event_type_id" field's value of the SystemEvents entity.
// If the SystemEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEventsMutation) OldEventTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEventTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEventTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEventTypeID: %w", err)
	}
	return oldValue.EventTypeID, nil
}

// ClearEventTypeID clears the value of the "event_type_id" field.
func (m *SystemEventsMutation) ClearEventTypeID() {
	m.event_type_id = nil
	m.clearedFields[systemevents.FieldEventTypeID] = struct{}{}
}

// EventTypeIDCleared returns if the "event_type_id" field was cleared in this mutation.
func (m *SystemEventsMutation) EventTypeIDCleared() bool {
	_, ok := m.clearedFields[systemevents.FieldEventTypeID]
	return ok
}

// ResetEventTypeID resets all changes to the "event_type_id" field.
func (m *SystemEventsMutation) ResetEventTypeID() {
	m.event_type_id = nil
	delete(m.clearedFields, systemevents.FieldEventTypeID)
}

// SetStatus sets the "status" field.
func (m *SystemEventsMutation) SetStatus(s systemevents.Status) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *SystemEventsMutation) Status() (r systemevents.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the SystemEvents entity.
// If the SystemEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEventsMutation) OldStatus(ctx context.Context) (v systemevents.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *SystemEventsMutation) ResetStatus() {
	m.status = nil
}

// SetDescription sets the "description" field.
func (m *SystemEventsMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SystemEventsMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the SystemEvents entity.
// If the SystemEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEventsMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *SystemEventsMutation) ResetDescription() {
	m.description = nil
}

// SetData sets the "data" field.
func (m *SystemEventsMutation) SetData(s string) {
	m.data = &s
}

// Data returns the value of the "data" field in the mutation.
func (m *SystemEventsMutation) Data() (r string, exists bool) {
	v := m.data
	if v == nil {
		return
	}
	return *v, true
}

// OldData returns the old "data" field's value of the SystemEvents entity.
// If the SystemEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEventsMutation) OldData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldData: %w", err)
	}
	return oldValue.Data, nil
}

// ClearData clears the value of the "data" field.
func (m *SystemEventsMutation) ClearData() {
	m.data = nil
	m.clearedFields[systemevents.FieldData] = struct{}{}
}

// DataCleared returns if the "data" field was cleared in this mutation.
func (m *SystemEventsMutation) DataCleared() bool {
	_, ok := m.clearedFields[systemevents.FieldData]
	return ok
}

// ResetData resets all changes to the "data" field.
func (m *SystemEventsMutation) ResetData() {
	m.data = nil
	delete(m.clearedFields, systemevents.FieldData)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemEventsMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemEventsMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemEvents entity.
// If the SystemEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEventsMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemEventsMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemEventsMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemEventsMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemEvents entity.
// If the SystemEvents object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemEventsMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SystemEventsMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[systemevents.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SystemEventsMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[systemevents.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemEventsMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, systemevents.FieldCreatedAt)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *SystemEventsMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[systemevents.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *SystemEventsMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *SystemEventsMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *SystemEventsMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the SystemEventsMutation builder.
func (m *SystemEventsMutation) Where(ps ...predicate.SystemEvents) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemEventsMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemEventsMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemEvents, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemEventsMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemEventsMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemEvents).
func (m *SystemEventsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemEventsMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.tenant != nil {
		fields = append(fields, systemevents.FieldTenantID)
	}
	if m.event_type != nil {
		fields = append(fields, systemevents.FieldEventType)
	}
	if m.event_type_id != nil {
		fields = append(fields, systemevents.FieldEventTypeID)
	}
	if m.status != nil {
		fields = append(fields, systemevents.FieldStatus)
	}
	if m.description != nil {
		fields = append(fields, systemevents.FieldDescription)
	}
	if m.data != nil {
		fields = append(fields, systemevents.FieldData)
	}
	if m.updated_at != nil {
		fields = append(fields, systemevents.FieldUpdatedAt)
	}
	if m.created_at != nil {
		fields = append(fields, systemevents.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemEventsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemevents.FieldTenantID:
		return m.TenantID()
	case systemevents.FieldEventType:
		return m.EventType()
	case systemevents.FieldEventTypeID:
		return m.EventTypeID()
	case systemevents.FieldStatus:
		return m.Status()
	case systemevents.FieldDescription:
		return m.Description()
	case systemevents.FieldData:
		return m.Data()
	case systemevents.FieldUpdatedAt:
		return m.UpdatedAt()
	case systemevents.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemEventsMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemevents.FieldTenantID:
		return m.OldTenantID(ctx)
	case systemevents.FieldEventType:
		return m.OldEventType(ctx)
	case systemevents.FieldEventTypeID:
		return m.OldEventTypeID(ctx)
	case systemevents.FieldStatus:
		return m.OldStatus(ctx)
	case systemevents.FieldDescription:
		return m.OldDescription(ctx)
	case systemevents.FieldData:
		return m.OldData(ctx)
	case systemevents.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case systemevents.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemEvents field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemEventsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemevents.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case systemevents.FieldEventType:
		v, ok := value.(systemevents.EventType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventType(v)
		return nil
	case systemevents.FieldEventTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEventTypeID(v)
		return nil
	case systemevents.FieldStatus:
		v, ok := value.(systemevents.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case systemevents.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case systemevents.FieldData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetData(v)
		return nil
	case systemevents.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case systemevents.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemEvents field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemEventsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemEventsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemEventsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SystemEvents numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemEventsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemevents.FieldEventTypeID) {
		fields = append(fields, systemevents.FieldEventTypeID)
	}
	if m.FieldCleared(systemevents.FieldData) {
		fields = append(fields, systemevents.FieldData)
	}
	if m.FieldCleared(systemevents.FieldCreatedAt) {
		fields = append(fields, systemevents.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemEventsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemEventsMutation) ClearField(name string) error {
	switch name {
	case systemevents.FieldEventTypeID:
		m.ClearEventTypeID()
		return nil
	case systemevents.FieldData:
		m.ClearData()
		return nil
	case systemevents.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemEvents nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemEventsMutation) ResetField(name string) error {
	switch name {
	case systemevents.FieldTenantID:
		m.ResetTenantID()
		return nil
	case systemevents.FieldEventType:
		m.ResetEventType()
		return nil
	case systemevents.FieldEventTypeID:
		m.ResetEventTypeID()
		return nil
	case systemevents.FieldStatus:
		m.ResetStatus()
		return nil
	case systemevents.FieldDescription:
		m.ResetDescription()
		return nil
	case systemevents.FieldData:
		m.ResetData()
		return nil
	case systemevents.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case systemevents.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemEvents field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemEventsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, systemevents.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemEventsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemevents.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemEventsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemEventsMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemEventsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, systemevents.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemEventsMutation) EdgeCleared(name string) bool {
	switch name {
	case systemevents.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemEventsMutation) ClearEdge(name string) error {
	switch name {
	case systemevents.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown SystemEvents unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemEventsMutation) ResetEdge(name string) error {
	switch name {
	case systemevents.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown SystemEvents edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op                              Op
	typ                             string
	id                              *pulid.ID
	name                            *string
	vat_number                      *string
	invoice_reference               *string
	clearedFields                   map[string]struct{}
	connect_option_carriers         map[pulid.ID]struct{}
	removedconnect_option_carriers  map[pulid.ID]struct{}
	clearedconnect_option_carriers  bool
	connect_option_platforms        map[pulid.ID]struct{}
	removedconnect_option_platforms map[pulid.ID]struct{}
	clearedconnect_option_platforms bool
	plan                            *pulid.ID
	clearedplan                     bool
	company_address                 *pulid.ID
	clearedcompany_address          bool
	default_language                *pulid.ID
	cleareddefault_language         bool
	billing_contact                 *pulid.ID
	clearedbilling_contact          bool
	admin_contact                   *pulid.ID
	clearedadmin_contact            bool
	done                            bool
	oldValue                        func(context.Context) (*Tenant, error)
	predicates                      []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id pulid.ID) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tenant entities.
func (m *TenantMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetVatNumber sets the "vat_number" field.
func (m *TenantMutation) SetVatNumber(s string) {
	m.vat_number = &s
}

// VatNumber returns the value of the "vat_number" field in the mutation.
func (m *TenantMutation) VatNumber() (r string, exists bool) {
	v := m.vat_number
	if v == nil {
		return
	}
	return *v, true
}

// OldVatNumber returns the old "vat_number" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldVatNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVatNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVatNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatNumber: %w", err)
	}
	return oldValue.VatNumber, nil
}

// ClearVatNumber clears the value of the "vat_number" field.
func (m *TenantMutation) ClearVatNumber() {
	m.vat_number = nil
	m.clearedFields[tenant.FieldVatNumber] = struct{}{}
}

// VatNumberCleared returns if the "vat_number" field was cleared in this mutation.
func (m *TenantMutation) VatNumberCleared() bool {
	_, ok := m.clearedFields[tenant.FieldVatNumber]
	return ok
}

// ResetVatNumber resets all changes to the "vat_number" field.
func (m *TenantMutation) ResetVatNumber() {
	m.vat_number = nil
	delete(m.clearedFields, tenant.FieldVatNumber)
}

// SetInvoiceReference sets the "invoice_reference" field.
func (m *TenantMutation) SetInvoiceReference(s string) {
	m.invoice_reference = &s
}

// InvoiceReference returns the value of the "invoice_reference" field in the mutation.
func (m *TenantMutation) InvoiceReference() (r string, exists bool) {
	v := m.invoice_reference
	if v == nil {
		return
	}
	return *v, true
}

// OldInvoiceReference returns the old "invoice_reference" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldInvoiceReference(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInvoiceReference is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInvoiceReference requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInvoiceReference: %w", err)
	}
	return oldValue.InvoiceReference, nil
}

// ClearInvoiceReference clears the value of the "invoice_reference" field.
func (m *TenantMutation) ClearInvoiceReference() {
	m.invoice_reference = nil
	m.clearedFields[tenant.FieldInvoiceReference] = struct{}{}
}

// InvoiceReferenceCleared returns if the "invoice_reference" field was cleared in this mutation.
func (m *TenantMutation) InvoiceReferenceCleared() bool {
	_, ok := m.clearedFields[tenant.FieldInvoiceReference]
	return ok
}

// ResetInvoiceReference resets all changes to the "invoice_reference" field.
func (m *TenantMutation) ResetInvoiceReference() {
	m.invoice_reference = nil
	delete(m.clearedFields, tenant.FieldInvoiceReference)
}

// AddConnectOptionCarrierIDs adds the "connect_option_carriers" edge to the ConnectOptionCarrier entity by ids.
func (m *TenantMutation) AddConnectOptionCarrierIDs(ids ...pulid.ID) {
	if m.connect_option_carriers == nil {
		m.connect_option_carriers = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.connect_option_carriers[ids[i]] = struct{}{}
	}
}

// ClearConnectOptionCarriers clears the "connect_option_carriers" edge to the ConnectOptionCarrier entity.
func (m *TenantMutation) ClearConnectOptionCarriers() {
	m.clearedconnect_option_carriers = true
}

// ConnectOptionCarriersCleared reports if the "connect_option_carriers" edge to the ConnectOptionCarrier entity was cleared.
func (m *TenantMutation) ConnectOptionCarriersCleared() bool {
	return m.clearedconnect_option_carriers
}

// RemoveConnectOptionCarrierIDs removes the "connect_option_carriers" edge to the ConnectOptionCarrier entity by IDs.
func (m *TenantMutation) RemoveConnectOptionCarrierIDs(ids ...pulid.ID) {
	if m.removedconnect_option_carriers == nil {
		m.removedconnect_option_carriers = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.connect_option_carriers, ids[i])
		m.removedconnect_option_carriers[ids[i]] = struct{}{}
	}
}

// RemovedConnectOptionCarriers returns the removed IDs of the "connect_option_carriers" edge to the ConnectOptionCarrier entity.
func (m *TenantMutation) RemovedConnectOptionCarriersIDs() (ids []pulid.ID) {
	for id := range m.removedconnect_option_carriers {
		ids = append(ids, id)
	}
	return
}

// ConnectOptionCarriersIDs returns the "connect_option_carriers" edge IDs in the mutation.
func (m *TenantMutation) ConnectOptionCarriersIDs() (ids []pulid.ID) {
	for id := range m.connect_option_carriers {
		ids = append(ids, id)
	}
	return
}

// ResetConnectOptionCarriers resets all changes to the "connect_option_carriers" edge.
func (m *TenantMutation) ResetConnectOptionCarriers() {
	m.connect_option_carriers = nil
	m.clearedconnect_option_carriers = false
	m.removedconnect_option_carriers = nil
}

// AddConnectOptionPlatformIDs adds the "connect_option_platforms" edge to the ConnectOptionPlatform entity by ids.
func (m *TenantMutation) AddConnectOptionPlatformIDs(ids ...pulid.ID) {
	if m.connect_option_platforms == nil {
		m.connect_option_platforms = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.connect_option_platforms[ids[i]] = struct{}{}
	}
}

// ClearConnectOptionPlatforms clears the "connect_option_platforms" edge to the ConnectOptionPlatform entity.
func (m *TenantMutation) ClearConnectOptionPlatforms() {
	m.clearedconnect_option_platforms = true
}

// ConnectOptionPlatformsCleared reports if the "connect_option_platforms" edge to the ConnectOptionPlatform entity was cleared.
func (m *TenantMutation) ConnectOptionPlatformsCleared() bool {
	return m.clearedconnect_option_platforms
}

// RemoveConnectOptionPlatformIDs removes the "connect_option_platforms" edge to the ConnectOptionPlatform entity by IDs.
func (m *TenantMutation) RemoveConnectOptionPlatformIDs(ids ...pulid.ID) {
	if m.removedconnect_option_platforms == nil {
		m.removedconnect_option_platforms = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.connect_option_platforms, ids[i])
		m.removedconnect_option_platforms[ids[i]] = struct{}{}
	}
}

// RemovedConnectOptionPlatforms returns the removed IDs of the "connect_option_platforms" edge to the ConnectOptionPlatform entity.
func (m *TenantMutation) RemovedConnectOptionPlatformsIDs() (ids []pulid.ID) {
	for id := range m.removedconnect_option_platforms {
		ids = append(ids, id)
	}
	return
}

// ConnectOptionPlatformsIDs returns the "connect_option_platforms" edge IDs in the mutation.
func (m *TenantMutation) ConnectOptionPlatformsIDs() (ids []pulid.ID) {
	for id := range m.connect_option_platforms {
		ids = append(ids, id)
	}
	return
}

// ResetConnectOptionPlatforms resets all changes to the "connect_option_platforms" edge.
func (m *TenantMutation) ResetConnectOptionPlatforms() {
	m.connect_option_platforms = nil
	m.clearedconnect_option_platforms = false
	m.removedconnect_option_platforms = nil
}

// SetPlanID sets the "plan" edge to the Plan entity by id.
func (m *TenantMutation) SetPlanID(id pulid.ID) {
	m.plan = &id
}

// ClearPlan clears the "plan" edge to the Plan entity.
func (m *TenantMutation) ClearPlan() {
	m.clearedplan = true
}

// PlanCleared reports if the "plan" edge to the Plan entity was cleared.
func (m *TenantMutation) PlanCleared() bool {
	return m.clearedplan
}

// PlanID returns the "plan" edge ID in the mutation.
func (m *TenantMutation) PlanID() (id pulid.ID, exists bool) {
	if m.plan != nil {
		return *m.plan, true
	}
	return
}

// PlanIDs returns the "plan" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PlanID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) PlanIDs() (ids []pulid.ID) {
	if id := m.plan; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPlan resets all changes to the "plan" edge.
func (m *TenantMutation) ResetPlan() {
	m.plan = nil
	m.clearedplan = false
}

// SetCompanyAddressID sets the "company_address" edge to the Address entity by id.
func (m *TenantMutation) SetCompanyAddressID(id pulid.ID) {
	m.company_address = &id
}

// ClearCompanyAddress clears the "company_address" edge to the Address entity.
func (m *TenantMutation) ClearCompanyAddress() {
	m.clearedcompany_address = true
}

// CompanyAddressCleared reports if the "company_address" edge to the Address entity was cleared.
func (m *TenantMutation) CompanyAddressCleared() bool {
	return m.clearedcompany_address
}

// CompanyAddressID returns the "company_address" edge ID in the mutation.
func (m *TenantMutation) CompanyAddressID() (id pulid.ID, exists bool) {
	if m.company_address != nil {
		return *m.company_address, true
	}
	return
}

// CompanyAddressIDs returns the "company_address" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyAddressID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) CompanyAddressIDs() (ids []pulid.ID) {
	if id := m.company_address; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompanyAddress resets all changes to the "company_address" edge.
func (m *TenantMutation) ResetCompanyAddress() {
	m.company_address = nil
	m.clearedcompany_address = false
}

// SetDefaultLanguageID sets the "default_language" edge to the Language entity by id.
func (m *TenantMutation) SetDefaultLanguageID(id pulid.ID) {
	m.default_language = &id
}

// ClearDefaultLanguage clears the "default_language" edge to the Language entity.
func (m *TenantMutation) ClearDefaultLanguage() {
	m.cleareddefault_language = true
}

// DefaultLanguageCleared reports if the "default_language" edge to the Language entity was cleared.
func (m *TenantMutation) DefaultLanguageCleared() bool {
	return m.cleareddefault_language
}

// DefaultLanguageID returns the "default_language" edge ID in the mutation.
func (m *TenantMutation) DefaultLanguageID() (id pulid.ID, exists bool) {
	if m.default_language != nil {
		return *m.default_language, true
	}
	return
}

// DefaultLanguageIDs returns the "default_language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultLanguageID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) DefaultLanguageIDs() (ids []pulid.ID) {
	if id := m.default_language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultLanguage resets all changes to the "default_language" edge.
func (m *TenantMutation) ResetDefaultLanguage() {
	m.default_language = nil
	m.cleareddefault_language = false
}

// SetBillingContactID sets the "billing_contact" edge to the Contact entity by id.
func (m *TenantMutation) SetBillingContactID(id pulid.ID) {
	m.billing_contact = &id
}

// ClearBillingContact clears the "billing_contact" edge to the Contact entity.
func (m *TenantMutation) ClearBillingContact() {
	m.clearedbilling_contact = true
}

// BillingContactCleared reports if the "billing_contact" edge to the Contact entity was cleared.
func (m *TenantMutation) BillingContactCleared() bool {
	return m.clearedbilling_contact
}

// BillingContactID returns the "billing_contact" edge ID in the mutation.
func (m *TenantMutation) BillingContactID() (id pulid.ID, exists bool) {
	if m.billing_contact != nil {
		return *m.billing_contact, true
	}
	return
}

// BillingContactIDs returns the "billing_contact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// BillingContactID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) BillingContactIDs() (ids []pulid.ID) {
	if id := m.billing_contact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBillingContact resets all changes to the "billing_contact" edge.
func (m *TenantMutation) ResetBillingContact() {
	m.billing_contact = nil
	m.clearedbilling_contact = false
}

// SetAdminContactID sets the "admin_contact" edge to the Contact entity by id.
func (m *TenantMutation) SetAdminContactID(id pulid.ID) {
	m.admin_contact = &id
}

// ClearAdminContact clears the "admin_contact" edge to the Contact entity.
func (m *TenantMutation) ClearAdminContact() {
	m.clearedadmin_contact = true
}

// AdminContactCleared reports if the "admin_contact" edge to the Contact entity was cleared.
func (m *TenantMutation) AdminContactCleared() bool {
	return m.clearedadmin_contact
}

// AdminContactID returns the "admin_contact" edge ID in the mutation.
func (m *TenantMutation) AdminContactID() (id pulid.ID, exists bool) {
	if m.admin_contact != nil {
		return *m.admin_contact, true
	}
	return
}

// AdminContactIDs returns the "admin_contact" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminContactID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) AdminContactIDs() (ids []pulid.ID) {
	if id := m.admin_contact; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdminContact resets all changes to the "admin_contact" edge.
func (m *TenantMutation) ResetAdminContact() {
	m.admin_contact = nil
	m.clearedadmin_contact = false
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.vat_number != nil {
		fields = append(fields, tenant.FieldVatNumber)
	}
	if m.invoice_reference != nil {
		fields = append(fields, tenant.FieldInvoiceReference)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldVatNumber:
		return m.VatNumber()
	case tenant.FieldInvoiceReference:
		return m.InvoiceReference()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldVatNumber:
		return m.OldVatNumber(ctx)
	case tenant.FieldInvoiceReference:
		return m.OldInvoiceReference(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldVatNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatNumber(v)
		return nil
	case tenant.FieldInvoiceReference:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInvoiceReference(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldVatNumber) {
		fields = append(fields, tenant.FieldVatNumber)
	}
	if m.FieldCleared(tenant.FieldInvoiceReference) {
		fields = append(fields, tenant.FieldInvoiceReference)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldVatNumber:
		m.ClearVatNumber()
		return nil
	case tenant.FieldInvoiceReference:
		m.ClearInvoiceReference()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldVatNumber:
		m.ResetVatNumber()
		return nil
	case tenant.FieldInvoiceReference:
		m.ResetInvoiceReference()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.connect_option_carriers != nil {
		edges = append(edges, tenant.EdgeConnectOptionCarriers)
	}
	if m.connect_option_platforms != nil {
		edges = append(edges, tenant.EdgeConnectOptionPlatforms)
	}
	if m.plan != nil {
		edges = append(edges, tenant.EdgePlan)
	}
	if m.company_address != nil {
		edges = append(edges, tenant.EdgeCompanyAddress)
	}
	if m.default_language != nil {
		edges = append(edges, tenant.EdgeDefaultLanguage)
	}
	if m.billing_contact != nil {
		edges = append(edges, tenant.EdgeBillingContact)
	}
	if m.admin_contact != nil {
		edges = append(edges, tenant.EdgeAdminContact)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeConnectOptionCarriers:
		ids := make([]ent.Value, 0, len(m.connect_option_carriers))
		for id := range m.connect_option_carriers {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeConnectOptionPlatforms:
		ids := make([]ent.Value, 0, len(m.connect_option_platforms))
		for id := range m.connect_option_platforms {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgePlan:
		if id := m.plan; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeCompanyAddress:
		if id := m.company_address; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeDefaultLanguage:
		if id := m.default_language; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeBillingContact:
		if id := m.billing_contact; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeAdminContact:
		if id := m.admin_contact; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedconnect_option_carriers != nil {
		edges = append(edges, tenant.EdgeConnectOptionCarriers)
	}
	if m.removedconnect_option_platforms != nil {
		edges = append(edges, tenant.EdgeConnectOptionPlatforms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeConnectOptionCarriers:
		ids := make([]ent.Value, 0, len(m.removedconnect_option_carriers))
		for id := range m.removedconnect_option_carriers {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeConnectOptionPlatforms:
		ids := make([]ent.Value, 0, len(m.removedconnect_option_platforms))
		for id := range m.removedconnect_option_platforms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedconnect_option_carriers {
		edges = append(edges, tenant.EdgeConnectOptionCarriers)
	}
	if m.clearedconnect_option_platforms {
		edges = append(edges, tenant.EdgeConnectOptionPlatforms)
	}
	if m.clearedplan {
		edges = append(edges, tenant.EdgePlan)
	}
	if m.clearedcompany_address {
		edges = append(edges, tenant.EdgeCompanyAddress)
	}
	if m.cleareddefault_language {
		edges = append(edges, tenant.EdgeDefaultLanguage)
	}
	if m.clearedbilling_contact {
		edges = append(edges, tenant.EdgeBillingContact)
	}
	if m.clearedadmin_contact {
		edges = append(edges, tenant.EdgeAdminContact)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	switch name {
	case tenant.EdgeConnectOptionCarriers:
		return m.clearedconnect_option_carriers
	case tenant.EdgeConnectOptionPlatforms:
		return m.clearedconnect_option_platforms
	case tenant.EdgePlan:
		return m.clearedplan
	case tenant.EdgeCompanyAddress:
		return m.clearedcompany_address
	case tenant.EdgeDefaultLanguage:
		return m.cleareddefault_language
	case tenant.EdgeBillingContact:
		return m.clearedbilling_contact
	case tenant.EdgeAdminContact:
		return m.clearedadmin_contact
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	switch name {
	case tenant.EdgePlan:
		m.ClearPlan()
		return nil
	case tenant.EdgeCompanyAddress:
		m.ClearCompanyAddress()
		return nil
	case tenant.EdgeDefaultLanguage:
		m.ClearDefaultLanguage()
		return nil
	case tenant.EdgeBillingContact:
		m.ClearBillingContact()
		return nil
	case tenant.EdgeAdminContact:
		m.ClearAdminContact()
		return nil
	}
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	switch name {
	case tenant.EdgeConnectOptionCarriers:
		m.ResetConnectOptionCarriers()
		return nil
	case tenant.EdgeConnectOptionPlatforms:
		m.ResetConnectOptionPlatforms()
		return nil
	case tenant.EdgePlan:
		m.ResetPlan()
		return nil
	case tenant.EdgeCompanyAddress:
		m.ResetCompanyAddress()
		return nil
	case tenant.EdgeDefaultLanguage:
		m.ResetDefaultLanguage()
		return nil
	case tenant.EdgeBillingContact:
		m.ResetBillingContact()
		return nil
	case tenant.EdgeAdminContact:
		m.ResetAdminContact()
		return nil
	}
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                           Op
	typ                          string
	id                           *pulid.ID
	name                         *string
	surname                      *string
	phone_number                 *string
	email                        *string
	password                     *string
	hash                         *string
	is_account_owner             *bool
	is_global_admin              *bool
	marketing_consent            *bool
	created_at                   *time.Time
	archived_at                  *time.Time
	pickup_day                   *user.PickupDay
	pickup_day_last_changed      *time.Time
	clearedFields                map[string]struct{}
	tenant                       *pulid.ID
	clearedtenant                bool
	otk_requests                 map[pulid.ID]struct{}
	removedotk_requests          map[pulid.ID]struct{}
	clearedotk_requests          bool
	signup_options               *pulid.ID
	clearedsignup_options        bool
	language                     *pulid.ID
	clearedlanguage              bool
	change_history               map[pulid.ID]struct{}
	removedchange_history        map[pulid.ID]struct{}
	clearedchange_history        bool
	plan_history_user            map[pulid.ID]struct{}
	removedplan_history_user     map[pulid.ID]struct{}
	clearedplan_history_user     bool
	api_token                    map[pulid.ID]struct{}
	removedapi_token             map[pulid.ID]struct{}
	clearedapi_token             bool
	selected_workstation         *pulid.ID
	clearedselected_workstation  bool
	seat_group                   *pulid.ID
	clearedseat_group            bool
	workspace_recent_scan        map[pulid.ID]struct{}
	removedworkspace_recent_scan map[pulid.ID]struct{}
	clearedworkspace_recent_scan bool
	done                         bool
	oldValue                     func(context.Context) (*User, error)
	predicates                   []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id pulid.ID) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *UserMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *UserMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserMutation) ClearName() {
	m.name = nil
	m.clearedFields[user.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserMutation) NameCleared() bool {
	_, ok := m.clearedFields[user.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, user.FieldName)
}

// SetSurname sets the "surname" field.
func (m *UserMutation) SetSurname(s string) {
	m.surname = &s
}

// Surname returns the value of the "surname" field in the mutation.
func (m *UserMutation) Surname() (r string, exists bool) {
	v := m.surname
	if v == nil {
		return
	}
	return *v, true
}

// OldSurname returns the old "surname" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSurname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurname: %w", err)
	}
	return oldValue.Surname, nil
}

// ClearSurname clears the value of the "surname" field.
func (m *UserMutation) ClearSurname() {
	m.surname = nil
	m.clearedFields[user.FieldSurname] = struct{}{}
}

// SurnameCleared returns if the "surname" field was cleared in this mutation.
func (m *UserMutation) SurnameCleared() bool {
	_, ok := m.clearedFields[user.FieldSurname]
	return ok
}

// ResetSurname resets all changes to the "surname" field.
func (m *UserMutation) ResetSurname() {
	m.surname = nil
	delete(m.clearedFields, user.FieldSurname)
}

// SetPhoneNumber sets the "phone_number" field.
func (m *UserMutation) SetPhoneNumber(s string) {
	m.phone_number = &s
}

// PhoneNumber returns the value of the "phone_number" field in the mutation.
func (m *UserMutation) PhoneNumber() (r string, exists bool) {
	v := m.phone_number
	if v == nil {
		return
	}
	return *v, true
}

// OldPhoneNumber returns the old "phone_number" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhoneNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhoneNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhoneNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhoneNumber: %w", err)
	}
	return oldValue.PhoneNumber, nil
}

// ClearPhoneNumber clears the value of the "phone_number" field.
func (m *UserMutation) ClearPhoneNumber() {
	m.phone_number = nil
	m.clearedFields[user.FieldPhoneNumber] = struct{}{}
}

// PhoneNumberCleared returns if the "phone_number" field was cleared in this mutation.
func (m *UserMutation) PhoneNumberCleared() bool {
	_, ok := m.clearedFields[user.FieldPhoneNumber]
	return ok
}

// ResetPhoneNumber resets all changes to the "phone_number" field.
func (m *UserMutation) ResetPhoneNumber() {
	m.phone_number = nil
	delete(m.clearedFields, user.FieldPhoneNumber)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetHash sets the "hash" field.
func (m *UserMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *UserMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *UserMutation) ResetHash() {
	m.hash = nil
}

// SetIsAccountOwner sets the "is_account_owner" field.
func (m *UserMutation) SetIsAccountOwner(b bool) {
	m.is_account_owner = &b
}

// IsAccountOwner returns the value of the "is_account_owner" field in the mutation.
func (m *UserMutation) IsAccountOwner() (r bool, exists bool) {
	v := m.is_account_owner
	if v == nil {
		return
	}
	return *v, true
}

// OldIsAccountOwner returns the old "is_account_owner" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsAccountOwner(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsAccountOwner is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsAccountOwner requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsAccountOwner: %w", err)
	}
	return oldValue.IsAccountOwner, nil
}

// ResetIsAccountOwner resets all changes to the "is_account_owner" field.
func (m *UserMutation) ResetIsAccountOwner() {
	m.is_account_owner = nil
}

// SetIsGlobalAdmin sets the "is_global_admin" field.
func (m *UserMutation) SetIsGlobalAdmin(b bool) {
	m.is_global_admin = &b
}

// IsGlobalAdmin returns the value of the "is_global_admin" field in the mutation.
func (m *UserMutation) IsGlobalAdmin() (r bool, exists bool) {
	v := m.is_global_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGlobalAdmin returns the old "is_global_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldIsGlobalAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGlobalAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGlobalAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGlobalAdmin: %w", err)
	}
	return oldValue.IsGlobalAdmin, nil
}

// ResetIsGlobalAdmin resets all changes to the "is_global_admin" field.
func (m *UserMutation) ResetIsGlobalAdmin() {
	m.is_global_admin = nil
}

// SetMarketingConsent sets the "marketing_consent" field.
func (m *UserMutation) SetMarketingConsent(b bool) {
	m.marketing_consent = &b
}

// MarketingConsent returns the value of the "marketing_consent" field in the mutation.
func (m *UserMutation) MarketingConsent() (r bool, exists bool) {
	v := m.marketing_consent
	if v == nil {
		return
	}
	return *v, true
}

// OldMarketingConsent returns the old "marketing_consent" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldMarketingConsent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMarketingConsent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMarketingConsent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMarketingConsent: %w", err)
	}
	return oldValue.MarketingConsent, nil
}

// ClearMarketingConsent clears the value of the "marketing_consent" field.
func (m *UserMutation) ClearMarketingConsent() {
	m.marketing_consent = nil
	m.clearedFields[user.FieldMarketingConsent] = struct{}{}
}

// MarketingConsentCleared returns if the "marketing_consent" field was cleared in this mutation.
func (m *UserMutation) MarketingConsentCleared() bool {
	_, ok := m.clearedFields[user.FieldMarketingConsent]
	return ok
}

// ResetMarketingConsent resets all changes to the "marketing_consent" field.
func (m *UserMutation) ResetMarketingConsent() {
	m.marketing_consent = nil
	delete(m.clearedFields, user.FieldMarketingConsent)
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetArchivedAt sets the "archived_at" field.
func (m *UserMutation) SetArchivedAt(t time.Time) {
	m.archived_at = &t
}

// ArchivedAt returns the value of the "archived_at" field in the mutation.
func (m *UserMutation) ArchivedAt() (r time.Time, exists bool) {
	v := m.archived_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedAt returns the old "archived_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldArchivedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedAt: %w", err)
	}
	return oldValue.ArchivedAt, nil
}

// ClearArchivedAt clears the value of the "archived_at" field.
func (m *UserMutation) ClearArchivedAt() {
	m.archived_at = nil
	m.clearedFields[user.FieldArchivedAt] = struct{}{}
}

// ArchivedAtCleared returns if the "archived_at" field was cleared in this mutation.
func (m *UserMutation) ArchivedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldArchivedAt]
	return ok
}

// ResetArchivedAt resets all changes to the "archived_at" field.
func (m *UserMutation) ResetArchivedAt() {
	m.archived_at = nil
	delete(m.clearedFields, user.FieldArchivedAt)
}

// SetPickupDay sets the "pickup_day" field.
func (m *UserMutation) SetPickupDay(ud user.PickupDay) {
	m.pickup_day = &ud
}

// PickupDay returns the value of the "pickup_day" field in the mutation.
func (m *UserMutation) PickupDay() (r user.PickupDay, exists bool) {
	v := m.pickup_day
	if v == nil {
		return
	}
	return *v, true
}

// OldPickupDay returns the old "pickup_day" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPickupDay(ctx context.Context) (v user.PickupDay, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPickupDay is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPickupDay requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPickupDay: %w", err)
	}
	return oldValue.PickupDay, nil
}

// ResetPickupDay resets all changes to the "pickup_day" field.
func (m *UserMutation) ResetPickupDay() {
	m.pickup_day = nil
}

// SetPickupDayLastChanged sets the "pickup_day_last_changed" field.
func (m *UserMutation) SetPickupDayLastChanged(t time.Time) {
	m.pickup_day_last_changed = &t
}

// PickupDayLastChanged returns the value of the "pickup_day_last_changed" field in the mutation.
func (m *UserMutation) PickupDayLastChanged() (r time.Time, exists bool) {
	v := m.pickup_day_last_changed
	if v == nil {
		return
	}
	return *v, true
}

// OldPickupDayLastChanged returns the old "pickup_day_last_changed" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPickupDayLastChanged(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPickupDayLastChanged is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPickupDayLastChanged requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPickupDayLastChanged: %w", err)
	}
	return oldValue.PickupDayLastChanged, nil
}

// ClearPickupDayLastChanged clears the value of the "pickup_day_last_changed" field.
func (m *UserMutation) ClearPickupDayLastChanged() {
	m.pickup_day_last_changed = nil
	m.clearedFields[user.FieldPickupDayLastChanged] = struct{}{}
}

// PickupDayLastChangedCleared returns if the "pickup_day_last_changed" field was cleared in this mutation.
func (m *UserMutation) PickupDayLastChangedCleared() bool {
	_, ok := m.clearedFields[user.FieldPickupDayLastChanged]
	return ok
}

// ResetPickupDayLastChanged resets all changes to the "pickup_day_last_changed" field.
func (m *UserMutation) ResetPickupDayLastChanged() {
	m.pickup_day_last_changed = nil
	delete(m.clearedFields, user.FieldPickupDayLastChanged)
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *UserMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[user.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *UserMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *UserMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *UserMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddOtkRequestIDs adds the "otk_requests" edge to the OTKRequests entity by ids.
func (m *UserMutation) AddOtkRequestIDs(ids ...pulid.ID) {
	if m.otk_requests == nil {
		m.otk_requests = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.otk_requests[ids[i]] = struct{}{}
	}
}

// ClearOtkRequests clears the "otk_requests" edge to the OTKRequests entity.
func (m *UserMutation) ClearOtkRequests() {
	m.clearedotk_requests = true
}

// OtkRequestsCleared reports if the "otk_requests" edge to the OTKRequests entity was cleared.
func (m *UserMutation) OtkRequestsCleared() bool {
	return m.clearedotk_requests
}

// RemoveOtkRequestIDs removes the "otk_requests" edge to the OTKRequests entity by IDs.
func (m *UserMutation) RemoveOtkRequestIDs(ids ...pulid.ID) {
	if m.removedotk_requests == nil {
		m.removedotk_requests = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.otk_requests, ids[i])
		m.removedotk_requests[ids[i]] = struct{}{}
	}
}

// RemovedOtkRequests returns the removed IDs of the "otk_requests" edge to the OTKRequests entity.
func (m *UserMutation) RemovedOtkRequestsIDs() (ids []pulid.ID) {
	for id := range m.removedotk_requests {
		ids = append(ids, id)
	}
	return
}

// OtkRequestsIDs returns the "otk_requests" edge IDs in the mutation.
func (m *UserMutation) OtkRequestsIDs() (ids []pulid.ID) {
	for id := range m.otk_requests {
		ids = append(ids, id)
	}
	return
}

// ResetOtkRequests resets all changes to the "otk_requests" edge.
func (m *UserMutation) ResetOtkRequests() {
	m.otk_requests = nil
	m.clearedotk_requests = false
	m.removedotk_requests = nil
}

// SetSignupOptionsID sets the "signup_options" edge to the SignupOptions entity by id.
func (m *UserMutation) SetSignupOptionsID(id pulid.ID) {
	m.signup_options = &id
}

// ClearSignupOptions clears the "signup_options" edge to the SignupOptions entity.
func (m *UserMutation) ClearSignupOptions() {
	m.clearedsignup_options = true
}

// SignupOptionsCleared reports if the "signup_options" edge to the SignupOptions entity was cleared.
func (m *UserMutation) SignupOptionsCleared() bool {
	return m.clearedsignup_options
}

// SignupOptionsID returns the "signup_options" edge ID in the mutation.
func (m *UserMutation) SignupOptionsID() (id pulid.ID, exists bool) {
	if m.signup_options != nil {
		return *m.signup_options, true
	}
	return
}

// SignupOptionsIDs returns the "signup_options" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SignupOptionsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) SignupOptionsIDs() (ids []pulid.ID) {
	if id := m.signup_options; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSignupOptions resets all changes to the "signup_options" edge.
func (m *UserMutation) ResetSignupOptions() {
	m.signup_options = nil
	m.clearedsignup_options = false
}

// SetLanguageID sets the "language" edge to the Language entity by id.
func (m *UserMutation) SetLanguageID(id pulid.ID) {
	m.language = &id
}

// ClearLanguage clears the "language" edge to the Language entity.
func (m *UserMutation) ClearLanguage() {
	m.clearedlanguage = true
}

// LanguageCleared reports if the "language" edge to the Language entity was cleared.
func (m *UserMutation) LanguageCleared() bool {
	return m.clearedlanguage
}

// LanguageID returns the "language" edge ID in the mutation.
func (m *UserMutation) LanguageID() (id pulid.ID, exists bool) {
	if m.language != nil {
		return *m.language, true
	}
	return
}

// LanguageIDs returns the "language" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LanguageID instead. It exists only for internal usage by the builders.
func (m *UserMutation) LanguageIDs() (ids []pulid.ID) {
	if id := m.language; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLanguage resets all changes to the "language" edge.
func (m *UserMutation) ResetLanguage() {
	m.language = nil
	m.clearedlanguage = false
}

// AddChangeHistoryIDs adds the "change_history" edge to the ChangeHistory entity by ids.
func (m *UserMutation) AddChangeHistoryIDs(ids ...pulid.ID) {
	if m.change_history == nil {
		m.change_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.change_history[ids[i]] = struct{}{}
	}
}

// ClearChangeHistory clears the "change_history" edge to the ChangeHistory entity.
func (m *UserMutation) ClearChangeHistory() {
	m.clearedchange_history = true
}

// ChangeHistoryCleared reports if the "change_history" edge to the ChangeHistory entity was cleared.
func (m *UserMutation) ChangeHistoryCleared() bool {
	return m.clearedchange_history
}

// RemoveChangeHistoryIDs removes the "change_history" edge to the ChangeHistory entity by IDs.
func (m *UserMutation) RemoveChangeHistoryIDs(ids ...pulid.ID) {
	if m.removedchange_history == nil {
		m.removedchange_history = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.change_history, ids[i])
		m.removedchange_history[ids[i]] = struct{}{}
	}
}

// RemovedChangeHistory returns the removed IDs of the "change_history" edge to the ChangeHistory entity.
func (m *UserMutation) RemovedChangeHistoryIDs() (ids []pulid.ID) {
	for id := range m.removedchange_history {
		ids = append(ids, id)
	}
	return
}

// ChangeHistoryIDs returns the "change_history" edge IDs in the mutation.
func (m *UserMutation) ChangeHistoryIDs() (ids []pulid.ID) {
	for id := range m.change_history {
		ids = append(ids, id)
	}
	return
}

// ResetChangeHistory resets all changes to the "change_history" edge.
func (m *UserMutation) ResetChangeHistory() {
	m.change_history = nil
	m.clearedchange_history = false
	m.removedchange_history = nil
}

// AddPlanHistoryUserIDs adds the "plan_history_user" edge to the PlanHistory entity by ids.
func (m *UserMutation) AddPlanHistoryUserIDs(ids ...pulid.ID) {
	if m.plan_history_user == nil {
		m.plan_history_user = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.plan_history_user[ids[i]] = struct{}{}
	}
}

// ClearPlanHistoryUser clears the "plan_history_user" edge to the PlanHistory entity.
func (m *UserMutation) ClearPlanHistoryUser() {
	m.clearedplan_history_user = true
}

// PlanHistoryUserCleared reports if the "plan_history_user" edge to the PlanHistory entity was cleared.
func (m *UserMutation) PlanHistoryUserCleared() bool {
	return m.clearedplan_history_user
}

// RemovePlanHistoryUserIDs removes the "plan_history_user" edge to the PlanHistory entity by IDs.
func (m *UserMutation) RemovePlanHistoryUserIDs(ids ...pulid.ID) {
	if m.removedplan_history_user == nil {
		m.removedplan_history_user = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.plan_history_user, ids[i])
		m.removedplan_history_user[ids[i]] = struct{}{}
	}
}

// RemovedPlanHistoryUser returns the removed IDs of the "plan_history_user" edge to the PlanHistory entity.
func (m *UserMutation) RemovedPlanHistoryUserIDs() (ids []pulid.ID) {
	for id := range m.removedplan_history_user {
		ids = append(ids, id)
	}
	return
}

// PlanHistoryUserIDs returns the "plan_history_user" edge IDs in the mutation.
func (m *UserMutation) PlanHistoryUserIDs() (ids []pulid.ID) {
	for id := range m.plan_history_user {
		ids = append(ids, id)
	}
	return
}

// ResetPlanHistoryUser resets all changes to the "plan_history_user" edge.
func (m *UserMutation) ResetPlanHistoryUser() {
	m.plan_history_user = nil
	m.clearedplan_history_user = false
	m.removedplan_history_user = nil
}

// AddAPITokenIDs adds the "api_token" edge to the APIToken entity by ids.
func (m *UserMutation) AddAPITokenIDs(ids ...pulid.ID) {
	if m.api_token == nil {
		m.api_token = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.api_token[ids[i]] = struct{}{}
	}
}

// ClearAPIToken clears the "api_token" edge to the APIToken entity.
func (m *UserMutation) ClearAPIToken() {
	m.clearedapi_token = true
}

// APITokenCleared reports if the "api_token" edge to the APIToken entity was cleared.
func (m *UserMutation) APITokenCleared() bool {
	return m.clearedapi_token
}

// RemoveAPITokenIDs removes the "api_token" edge to the APIToken entity by IDs.
func (m *UserMutation) RemoveAPITokenIDs(ids ...pulid.ID) {
	if m.removedapi_token == nil {
		m.removedapi_token = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.api_token, ids[i])
		m.removedapi_token[ids[i]] = struct{}{}
	}
}

// RemovedAPIToken returns the removed IDs of the "api_token" edge to the APIToken entity.
func (m *UserMutation) RemovedAPITokenIDs() (ids []pulid.ID) {
	for id := range m.removedapi_token {
		ids = append(ids, id)
	}
	return
}

// APITokenIDs returns the "api_token" edge IDs in the mutation.
func (m *UserMutation) APITokenIDs() (ids []pulid.ID) {
	for id := range m.api_token {
		ids = append(ids, id)
	}
	return
}

// ResetAPIToken resets all changes to the "api_token" edge.
func (m *UserMutation) ResetAPIToken() {
	m.api_token = nil
	m.clearedapi_token = false
	m.removedapi_token = nil
}

// SetSelectedWorkstationID sets the "selected_workstation" edge to the Workstation entity by id.
func (m *UserMutation) SetSelectedWorkstationID(id pulid.ID) {
	m.selected_workstation = &id
}

// ClearSelectedWorkstation clears the "selected_workstation" edge to the Workstation entity.
func (m *UserMutation) ClearSelectedWorkstation() {
	m.clearedselected_workstation = true
}

// SelectedWorkstationCleared reports if the "selected_workstation" edge to the Workstation entity was cleared.
func (m *UserMutation) SelectedWorkstationCleared() bool {
	return m.clearedselected_workstation
}

// SelectedWorkstationID returns the "selected_workstation" edge ID in the mutation.
func (m *UserMutation) SelectedWorkstationID() (id pulid.ID, exists bool) {
	if m.selected_workstation != nil {
		return *m.selected_workstation, true
	}
	return
}

// SelectedWorkstationIDs returns the "selected_workstation" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SelectedWorkstationID instead. It exists only for internal usage by the builders.
func (m *UserMutation) SelectedWorkstationIDs() (ids []pulid.ID) {
	if id := m.selected_workstation; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSelectedWorkstation resets all changes to the "selected_workstation" edge.
func (m *UserMutation) ResetSelectedWorkstation() {
	m.selected_workstation = nil
	m.clearedselected_workstation = false
}

// SetSeatGroupID sets the "seat_group" edge to the SeatGroup entity by id.
func (m *UserMutation) SetSeatGroupID(id pulid.ID) {
	m.seat_group = &id
}

// ClearSeatGroup clears the "seat_group" edge to the SeatGroup entity.
func (m *UserMutation) ClearSeatGroup() {
	m.clearedseat_group = true
}

// SeatGroupCleared reports if the "seat_group" edge to the SeatGroup entity was cleared.
func (m *UserMutation) SeatGroupCleared() bool {
	return m.clearedseat_group
}

// SeatGroupID returns the "seat_group" edge ID in the mutation.
func (m *UserMutation) SeatGroupID() (id pulid.ID, exists bool) {
	if m.seat_group != nil {
		return *m.seat_group, true
	}
	return
}

// SeatGroupIDs returns the "seat_group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SeatGroupID instead. It exists only for internal usage by the builders.
func (m *UserMutation) SeatGroupIDs() (ids []pulid.ID) {
	if id := m.seat_group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSeatGroup resets all changes to the "seat_group" edge.
func (m *UserMutation) ResetSeatGroup() {
	m.seat_group = nil
	m.clearedseat_group = false
}

// AddWorkspaceRecentScanIDs adds the "workspace_recent_scan" edge to the WorkspaceRecentScan entity by ids.
func (m *UserMutation) AddWorkspaceRecentScanIDs(ids ...pulid.ID) {
	if m.workspace_recent_scan == nil {
		m.workspace_recent_scan = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.workspace_recent_scan[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceRecentScan clears the "workspace_recent_scan" edge to the WorkspaceRecentScan entity.
func (m *UserMutation) ClearWorkspaceRecentScan() {
	m.clearedworkspace_recent_scan = true
}

// WorkspaceRecentScanCleared reports if the "workspace_recent_scan" edge to the WorkspaceRecentScan entity was cleared.
func (m *UserMutation) WorkspaceRecentScanCleared() bool {
	return m.clearedworkspace_recent_scan
}

// RemoveWorkspaceRecentScanIDs removes the "workspace_recent_scan" edge to the WorkspaceRecentScan entity by IDs.
func (m *UserMutation) RemoveWorkspaceRecentScanIDs(ids ...pulid.ID) {
	if m.removedworkspace_recent_scan == nil {
		m.removedworkspace_recent_scan = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.workspace_recent_scan, ids[i])
		m.removedworkspace_recent_scan[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceRecentScan returns the removed IDs of the "workspace_recent_scan" edge to the WorkspaceRecentScan entity.
func (m *UserMutation) RemovedWorkspaceRecentScanIDs() (ids []pulid.ID) {
	for id := range m.removedworkspace_recent_scan {
		ids = append(ids, id)
	}
	return
}

// WorkspaceRecentScanIDs returns the "workspace_recent_scan" edge IDs in the mutation.
func (m *UserMutation) WorkspaceRecentScanIDs() (ids []pulid.ID) {
	for id := range m.workspace_recent_scan {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceRecentScan resets all changes to the "workspace_recent_scan" edge.
func (m *UserMutation) ResetWorkspaceRecentScan() {
	m.workspace_recent_scan = nil
	m.clearedworkspace_recent_scan = false
	m.removedworkspace_recent_scan = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.tenant != nil {
		fields = append(fields, user.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, user.FieldName)
	}
	if m.surname != nil {
		fields = append(fields, user.FieldSurname)
	}
	if m.phone_number != nil {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.hash != nil {
		fields = append(fields, user.FieldHash)
	}
	if m.is_account_owner != nil {
		fields = append(fields, user.FieldIsAccountOwner)
	}
	if m.is_global_admin != nil {
		fields = append(fields, user.FieldIsGlobalAdmin)
	}
	if m.marketing_consent != nil {
		fields = append(fields, user.FieldMarketingConsent)
	}
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.archived_at != nil {
		fields = append(fields, user.FieldArchivedAt)
	}
	if m.pickup_day != nil {
		fields = append(fields, user.FieldPickupDay)
	}
	if m.pickup_day_last_changed != nil {
		fields = append(fields, user.FieldPickupDayLastChanged)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTenantID:
		return m.TenantID()
	case user.FieldName:
		return m.Name()
	case user.FieldSurname:
		return m.Surname()
	case user.FieldPhoneNumber:
		return m.PhoneNumber()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldHash:
		return m.Hash()
	case user.FieldIsAccountOwner:
		return m.IsAccountOwner()
	case user.FieldIsGlobalAdmin:
		return m.IsGlobalAdmin()
	case user.FieldMarketingConsent:
		return m.MarketingConsent()
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldArchivedAt:
		return m.ArchivedAt()
	case user.FieldPickupDay:
		return m.PickupDay()
	case user.FieldPickupDayLastChanged:
		return m.PickupDayLastChanged()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldTenantID:
		return m.OldTenantID(ctx)
	case user.FieldName:
		return m.OldName(ctx)
	case user.FieldSurname:
		return m.OldSurname(ctx)
	case user.FieldPhoneNumber:
		return m.OldPhoneNumber(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldHash:
		return m.OldHash(ctx)
	case user.FieldIsAccountOwner:
		return m.OldIsAccountOwner(ctx)
	case user.FieldIsGlobalAdmin:
		return m.OldIsGlobalAdmin(ctx)
	case user.FieldMarketingConsent:
		return m.OldMarketingConsent(ctx)
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldArchivedAt:
		return m.OldArchivedAt(ctx)
	case user.FieldPickupDay:
		return m.OldPickupDay(ctx)
	case user.FieldPickupDayLastChanged:
		return m.OldPickupDayLastChanged(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case user.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case user.FieldSurname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurname(v)
		return nil
	case user.FieldPhoneNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhoneNumber(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case user.FieldIsAccountOwner:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsAccountOwner(v)
		return nil
	case user.FieldIsGlobalAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGlobalAdmin(v)
		return nil
	case user.FieldMarketingConsent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMarketingConsent(v)
		return nil
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldArchivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedAt(v)
		return nil
	case user.FieldPickupDay:
		v, ok := value.(user.PickupDay)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPickupDay(v)
		return nil
	case user.FieldPickupDayLastChanged:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPickupDayLastChanged(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldName) {
		fields = append(fields, user.FieldName)
	}
	if m.FieldCleared(user.FieldSurname) {
		fields = append(fields, user.FieldSurname)
	}
	if m.FieldCleared(user.FieldPhoneNumber) {
		fields = append(fields, user.FieldPhoneNumber)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldMarketingConsent) {
		fields = append(fields, user.FieldMarketingConsent)
	}
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldArchivedAt) {
		fields = append(fields, user.FieldArchivedAt)
	}
	if m.FieldCleared(user.FieldPickupDayLastChanged) {
		fields = append(fields, user.FieldPickupDayLastChanged)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldName:
		m.ClearName()
		return nil
	case user.FieldSurname:
		m.ClearSurname()
		return nil
	case user.FieldPhoneNumber:
		m.ClearPhoneNumber()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldMarketingConsent:
		m.ClearMarketingConsent()
		return nil
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldArchivedAt:
		m.ClearArchivedAt()
		return nil
	case user.FieldPickupDayLastChanged:
		m.ClearPickupDayLastChanged()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldTenantID:
		m.ResetTenantID()
		return nil
	case user.FieldName:
		m.ResetName()
		return nil
	case user.FieldSurname:
		m.ResetSurname()
		return nil
	case user.FieldPhoneNumber:
		m.ResetPhoneNumber()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldHash:
		m.ResetHash()
		return nil
	case user.FieldIsAccountOwner:
		m.ResetIsAccountOwner()
		return nil
	case user.FieldIsGlobalAdmin:
		m.ResetIsGlobalAdmin()
		return nil
	case user.FieldMarketingConsent:
		m.ResetMarketingConsent()
		return nil
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldArchivedAt:
		m.ResetArchivedAt()
		return nil
	case user.FieldPickupDay:
		m.ResetPickupDay()
		return nil
	case user.FieldPickupDayLastChanged:
		m.ResetPickupDayLastChanged()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 10)
	if m.tenant != nil {
		edges = append(edges, user.EdgeTenant)
	}
	if m.otk_requests != nil {
		edges = append(edges, user.EdgeOtkRequests)
	}
	if m.signup_options != nil {
		edges = append(edges, user.EdgeSignupOptions)
	}
	if m.language != nil {
		edges = append(edges, user.EdgeLanguage)
	}
	if m.change_history != nil {
		edges = append(edges, user.EdgeChangeHistory)
	}
	if m.plan_history_user != nil {
		edges = append(edges, user.EdgePlanHistoryUser)
	}
	if m.api_token != nil {
		edges = append(edges, user.EdgeAPIToken)
	}
	if m.selected_workstation != nil {
		edges = append(edges, user.EdgeSelectedWorkstation)
	}
	if m.seat_group != nil {
		edges = append(edges, user.EdgeSeatGroup)
	}
	if m.workspace_recent_scan != nil {
		edges = append(edges, user.EdgeWorkspaceRecentScan)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeOtkRequests:
		ids := make([]ent.Value, 0, len(m.otk_requests))
		for id := range m.otk_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSignupOptions:
		if id := m.signup_options; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeLanguage:
		if id := m.language; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeChangeHistory:
		ids := make([]ent.Value, 0, len(m.change_history))
		for id := range m.change_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePlanHistoryUser:
		ids := make([]ent.Value, 0, len(m.plan_history_user))
		for id := range m.plan_history_user {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIToken:
		ids := make([]ent.Value, 0, len(m.api_token))
		for id := range m.api_token {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSelectedWorkstation:
		if id := m.selected_workstation; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSeatGroup:
		if id := m.seat_group; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeWorkspaceRecentScan:
		ids := make([]ent.Value, 0, len(m.workspace_recent_scan))
		for id := range m.workspace_recent_scan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 10)
	if m.removedotk_requests != nil {
		edges = append(edges, user.EdgeOtkRequests)
	}
	if m.removedchange_history != nil {
		edges = append(edges, user.EdgeChangeHistory)
	}
	if m.removedplan_history_user != nil {
		edges = append(edges, user.EdgePlanHistoryUser)
	}
	if m.removedapi_token != nil {
		edges = append(edges, user.EdgeAPIToken)
	}
	if m.removedworkspace_recent_scan != nil {
		edges = append(edges, user.EdgeWorkspaceRecentScan)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeOtkRequests:
		ids := make([]ent.Value, 0, len(m.removedotk_requests))
		for id := range m.removedotk_requests {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeChangeHistory:
		ids := make([]ent.Value, 0, len(m.removedchange_history))
		for id := range m.removedchange_history {
			ids = append(ids, id)
		}
		return ids
	case user.EdgePlanHistoryUser:
		ids := make([]ent.Value, 0, len(m.removedplan_history_user))
		for id := range m.removedplan_history_user {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeAPIToken:
		ids := make([]ent.Value, 0, len(m.removedapi_token))
		for id := range m.removedapi_token {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkspaceRecentScan:
		ids := make([]ent.Value, 0, len(m.removedworkspace_recent_scan))
		for id := range m.removedworkspace_recent_scan {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 10)
	if m.clearedtenant {
		edges = append(edges, user.EdgeTenant)
	}
	if m.clearedotk_requests {
		edges = append(edges, user.EdgeOtkRequests)
	}
	if m.clearedsignup_options {
		edges = append(edges, user.EdgeSignupOptions)
	}
	if m.clearedlanguage {
		edges = append(edges, user.EdgeLanguage)
	}
	if m.clearedchange_history {
		edges = append(edges, user.EdgeChangeHistory)
	}
	if m.clearedplan_history_user {
		edges = append(edges, user.EdgePlanHistoryUser)
	}
	if m.clearedapi_token {
		edges = append(edges, user.EdgeAPIToken)
	}
	if m.clearedselected_workstation {
		edges = append(edges, user.EdgeSelectedWorkstation)
	}
	if m.clearedseat_group {
		edges = append(edges, user.EdgeSeatGroup)
	}
	if m.clearedworkspace_recent_scan {
		edges = append(edges, user.EdgeWorkspaceRecentScan)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeTenant:
		return m.clearedtenant
	case user.EdgeOtkRequests:
		return m.clearedotk_requests
	case user.EdgeSignupOptions:
		return m.clearedsignup_options
	case user.EdgeLanguage:
		return m.clearedlanguage
	case user.EdgeChangeHistory:
		return m.clearedchange_history
	case user.EdgePlanHistoryUser:
		return m.clearedplan_history_user
	case user.EdgeAPIToken:
		return m.clearedapi_token
	case user.EdgeSelectedWorkstation:
		return m.clearedselected_workstation
	case user.EdgeSeatGroup:
		return m.clearedseat_group
	case user.EdgeWorkspaceRecentScan:
		return m.clearedworkspace_recent_scan
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ClearTenant()
		return nil
	case user.EdgeSignupOptions:
		m.ClearSignupOptions()
		return nil
	case user.EdgeLanguage:
		m.ClearLanguage()
		return nil
	case user.EdgeSelectedWorkstation:
		m.ClearSelectedWorkstation()
		return nil
	case user.EdgeSeatGroup:
		m.ClearSeatGroup()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeTenant:
		m.ResetTenant()
		return nil
	case user.EdgeOtkRequests:
		m.ResetOtkRequests()
		return nil
	case user.EdgeSignupOptions:
		m.ResetSignupOptions()
		return nil
	case user.EdgeLanguage:
		m.ResetLanguage()
		return nil
	case user.EdgeChangeHistory:
		m.ResetChangeHistory()
		return nil
	case user.EdgePlanHistoryUser:
		m.ResetPlanHistoryUser()
		return nil
	case user.EdgeAPIToken:
		m.ResetAPIToken()
		return nil
	case user.EdgeSelectedWorkstation:
		m.ResetSelectedWorkstation()
		return nil
	case user.EdgeSeatGroup:
		m.ResetSeatGroup()
		return nil
	case user.EdgeWorkspaceRecentScan:
		m.ResetWorkspaceRecentScan()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserSeatMutation represents an operation that mutates the UserSeat nodes in the graph.
type UserSeatMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.ID
	name          *string
	surname       *string
	email         *string
	password      *string
	hash          *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	tenant        *pulid.ID
	clearedtenant bool
	done          bool
	oldValue      func(context.Context) (*UserSeat, error)
	predicates    []predicate.UserSeat
}

var _ ent.Mutation = (*UserSeatMutation)(nil)

// userseatOption allows management of the mutation configuration using functional options.
type userseatOption func(*UserSeatMutation)

// newUserSeatMutation creates new mutation for the UserSeat entity.
func newUserSeatMutation(c config, op Op, opts ...userseatOption) *UserSeatMutation {
	m := &UserSeatMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSeat,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserSeatID sets the ID field of the mutation.
func withUserSeatID(id pulid.ID) userseatOption {
	return func(m *UserSeatMutation) {
		var (
			err   error
			once  sync.Once
			value *UserSeat
		)
		m.oldValue = func(ctx context.Context) (*UserSeat, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UserSeat.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUserSeat sets the old UserSeat of the mutation.
func withUserSeat(node *UserSeat) userseatOption {
	return func(m *UserSeatMutation) {
		m.oldValue = func(context.Context) (*UserSeat, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSeatMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSeatMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UserSeat entities.
func (m *UserSeatMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserSeatMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserSeatMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UserSeat.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *UserSeatMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *UserSeatMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the UserSeat entity.
// If the UserSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSeatMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *UserSeatMutation) ResetTenantID() {
	m.tenant = nil
}

// SetName sets the "name" field.
func (m *UserSeatMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *UserSeatMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the UserSeat entity.
// If the UserSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSeatMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *UserSeatMutation) ClearName() {
	m.name = nil
	m.clearedFields[userseat.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *UserSeatMutation) NameCleared() bool {
	_, ok := m.clearedFields[userseat.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *UserSeatMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, userseat.FieldName)
}

// SetSurname sets the "surname" field.
func (m *UserSeatMutation) SetSurname(s string) {
	m.surname = &s
}

// Surname returns the value of the "surname" field in the mutation.
func (m *UserSeatMutation) Surname() (r string, exists bool) {
	v := m.surname
	if v == nil {
		return
	}
	return *v, true
}

// OldSurname returns the old "surname" field's value of the UserSeat entity.
// If the UserSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSeatMutation) OldSurname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSurname is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSurname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSurname: %w", err)
	}
	return oldValue.Surname, nil
}

// ClearSurname clears the value of the "surname" field.
func (m *UserSeatMutation) ClearSurname() {
	m.surname = nil
	m.clearedFields[userseat.FieldSurname] = struct{}{}
}

// SurnameCleared returns if the "surname" field was cleared in this mutation.
func (m *UserSeatMutation) SurnameCleared() bool {
	_, ok := m.clearedFields[userseat.FieldSurname]
	return ok
}

// ResetSurname resets all changes to the "surname" field.
func (m *UserSeatMutation) ResetSurname() {
	m.surname = nil
	delete(m.clearedFields, userseat.FieldSurname)
}

// SetEmail sets the "email" field.
func (m *UserSeatMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserSeatMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the UserSeat entity.
// If the UserSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSeatMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserSeatMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserSeatMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserSeatMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the UserSeat entity.
// If the UserSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSeatMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserSeatMutation) ResetPassword() {
	m.password = nil
}

// SetHash sets the "hash" field.
func (m *UserSeatMutation) SetHash(s string) {
	m.hash = &s
}

// Hash returns the value of the "hash" field in the mutation.
func (m *UserSeatMutation) Hash() (r string, exists bool) {
	v := m.hash
	if v == nil {
		return
	}
	return *v, true
}

// OldHash returns the old "hash" field's value of the UserSeat entity.
// If the UserSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSeatMutation) OldHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHash: %w", err)
	}
	return oldValue.Hash, nil
}

// ResetHash resets all changes to the "hash" field.
func (m *UserSeatMutation) ResetHash() {
	m.hash = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *UserSeatMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserSeatMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the UserSeat entity.
// If the UserSeat object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserSeatMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserSeatMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *UserSeatMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[userseat.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *UserSeatMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *UserSeatMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *UserSeatMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// Where appends a list predicates to the UserSeatMutation builder.
func (m *UserSeatMutation) Where(ps ...predicate.UserSeat) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserSeatMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserSeatMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UserSeat, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserSeatMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserSeatMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UserSeat).
func (m *UserSeatMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserSeatMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.tenant != nil {
		fields = append(fields, userseat.FieldTenantID)
	}
	if m.name != nil {
		fields = append(fields, userseat.FieldName)
	}
	if m.surname != nil {
		fields = append(fields, userseat.FieldSurname)
	}
	if m.email != nil {
		fields = append(fields, userseat.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, userseat.FieldPassword)
	}
	if m.hash != nil {
		fields = append(fields, userseat.FieldHash)
	}
	if m.created_at != nil {
		fields = append(fields, userseat.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserSeatMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case userseat.FieldTenantID:
		return m.TenantID()
	case userseat.FieldName:
		return m.Name()
	case userseat.FieldSurname:
		return m.Surname()
	case userseat.FieldEmail:
		return m.Email()
	case userseat.FieldPassword:
		return m.Password()
	case userseat.FieldHash:
		return m.Hash()
	case userseat.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserSeatMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case userseat.FieldTenantID:
		return m.OldTenantID(ctx)
	case userseat.FieldName:
		return m.OldName(ctx)
	case userseat.FieldSurname:
		return m.OldSurname(ctx)
	case userseat.FieldEmail:
		return m.OldEmail(ctx)
	case userseat.FieldPassword:
		return m.OldPassword(ctx)
	case userseat.FieldHash:
		return m.OldHash(ctx)
	case userseat.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown UserSeat field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSeatMutation) SetField(name string, value ent.Value) error {
	switch name {
	case userseat.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case userseat.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case userseat.FieldSurname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSurname(v)
		return nil
	case userseat.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case userseat.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case userseat.FieldHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHash(v)
		return nil
	case userseat.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown UserSeat field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserSeatMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserSeatMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserSeatMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSeat numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserSeatMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(userseat.FieldName) {
		fields = append(fields, userseat.FieldName)
	}
	if m.FieldCleared(userseat.FieldSurname) {
		fields = append(fields, userseat.FieldSurname)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserSeatMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSeatMutation) ClearField(name string) error {
	switch name {
	case userseat.FieldName:
		m.ClearName()
		return nil
	case userseat.FieldSurname:
		m.ClearSurname()
		return nil
	}
	return fmt.Errorf("unknown UserSeat nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserSeatMutation) ResetField(name string) error {
	switch name {
	case userseat.FieldTenantID:
		m.ResetTenantID()
		return nil
	case userseat.FieldName:
		m.ResetName()
		return nil
	case userseat.FieldSurname:
		m.ResetSurname()
		return nil
	case userseat.FieldEmail:
		m.ResetEmail()
		return nil
	case userseat.FieldPassword:
		m.ResetPassword()
		return nil
	case userseat.FieldHash:
		m.ResetHash()
		return nil
	case userseat.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown UserSeat field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserSeatMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.tenant != nil {
		edges = append(edges, userseat.EdgeTenant)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserSeatMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case userseat.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserSeatMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserSeatMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserSeatMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedtenant {
		edges = append(edges, userseat.EdgeTenant)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserSeatMutation) EdgeCleared(name string) bool {
	switch name {
	case userseat.EdgeTenant:
		return m.clearedtenant
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserSeatMutation) ClearEdge(name string) error {
	switch name {
	case userseat.EdgeTenant:
		m.ClearTenant()
		return nil
	}
	return fmt.Errorf("unknown UserSeat unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserSeatMutation) ResetEdge(name string) error {
	switch name {
	case userseat.EdgeTenant:
		m.ResetTenant()
		return nil
	}
	return fmt.Errorf("unknown UserSeat edge %s", name)
}

// WorkspaceRecentScanMutation represents an operation that mutates the WorkspaceRecentScan nodes in the graph.
type WorkspaceRecentScanMutation struct {
	config
	op                     Op
	typ                    string
	id                     *pulid.ID
	created_at             *time.Time
	clearedFields          map[string]struct{}
	tenant                 *pulid.ID
	clearedtenant          bool
	shipment_parcel        *pulid.ID
	clearedshipment_parcel bool
	user                   *pulid.ID
	cleareduser            bool
	done                   bool
	oldValue               func(context.Context) (*WorkspaceRecentScan, error)
	predicates             []predicate.WorkspaceRecentScan
}

var _ ent.Mutation = (*WorkspaceRecentScanMutation)(nil)

// workspacerecentscanOption allows management of the mutation configuration using functional options.
type workspacerecentscanOption func(*WorkspaceRecentScanMutation)

// newWorkspaceRecentScanMutation creates new mutation for the WorkspaceRecentScan entity.
func newWorkspaceRecentScanMutation(c config, op Op, opts ...workspacerecentscanOption) *WorkspaceRecentScanMutation {
	m := &WorkspaceRecentScanMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspaceRecentScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceRecentScanID sets the ID field of the mutation.
func withWorkspaceRecentScanID(id pulid.ID) workspacerecentscanOption {
	return func(m *WorkspaceRecentScanMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkspaceRecentScan
		)
		m.oldValue = func(ctx context.Context) (*WorkspaceRecentScan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkspaceRecentScan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspaceRecentScan sets the old WorkspaceRecentScan of the mutation.
func withWorkspaceRecentScan(node *WorkspaceRecentScan) workspacerecentscanOption {
	return func(m *WorkspaceRecentScanMutation) {
		m.oldValue = func(context.Context) (*WorkspaceRecentScan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceRecentScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceRecentScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkspaceRecentScan entities.
func (m *WorkspaceRecentScanMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceRecentScanMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceRecentScanMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkspaceRecentScan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *WorkspaceRecentScanMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *WorkspaceRecentScanMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the WorkspaceRecentScan entity.
// If the WorkspaceRecentScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceRecentScanMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *WorkspaceRecentScanMutation) ResetTenantID() {
	m.tenant = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkspaceRecentScanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkspaceRecentScanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkspaceRecentScan entity.
// If the WorkspaceRecentScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceRecentScanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkspaceRecentScanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *WorkspaceRecentScanMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[workspacerecentscan.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *WorkspaceRecentScanMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *WorkspaceRecentScanMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *WorkspaceRecentScanMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// SetShipmentParcelID sets the "shipment_parcel" edge to the ShipmentParcel entity by id.
func (m *WorkspaceRecentScanMutation) SetShipmentParcelID(id pulid.ID) {
	m.shipment_parcel = &id
}

// ClearShipmentParcel clears the "shipment_parcel" edge to the ShipmentParcel entity.
func (m *WorkspaceRecentScanMutation) ClearShipmentParcel() {
	m.clearedshipment_parcel = true
}

// ShipmentParcelCleared reports if the "shipment_parcel" edge to the ShipmentParcel entity was cleared.
func (m *WorkspaceRecentScanMutation) ShipmentParcelCleared() bool {
	return m.clearedshipment_parcel
}

// ShipmentParcelID returns the "shipment_parcel" edge ID in the mutation.
func (m *WorkspaceRecentScanMutation) ShipmentParcelID() (id pulid.ID, exists bool) {
	if m.shipment_parcel != nil {
		return *m.shipment_parcel, true
	}
	return
}

// ShipmentParcelIDs returns the "shipment_parcel" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ShipmentParcelID instead. It exists only for internal usage by the builders.
func (m *WorkspaceRecentScanMutation) ShipmentParcelIDs() (ids []pulid.ID) {
	if id := m.shipment_parcel; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetShipmentParcel resets all changes to the "shipment_parcel" edge.
func (m *WorkspaceRecentScanMutation) ResetShipmentParcel() {
	m.shipment_parcel = nil
	m.clearedshipment_parcel = false
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WorkspaceRecentScanMutation) SetUserID(id pulid.ID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WorkspaceRecentScanMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WorkspaceRecentScanMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WorkspaceRecentScanMutation) UserID() (id pulid.ID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WorkspaceRecentScanMutation) UserIDs() (ids []pulid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WorkspaceRecentScanMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the WorkspaceRecentScanMutation builder.
func (m *WorkspaceRecentScanMutation) Where(ps ...predicate.WorkspaceRecentScan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkspaceRecentScanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkspaceRecentScanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkspaceRecentScan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkspaceRecentScanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkspaceRecentScanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkspaceRecentScan).
func (m *WorkspaceRecentScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceRecentScanMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.tenant != nil {
		fields = append(fields, workspacerecentscan.FieldTenantID)
	}
	if m.created_at != nil {
		fields = append(fields, workspacerecentscan.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceRecentScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspacerecentscan.FieldTenantID:
		return m.TenantID()
	case workspacerecentscan.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceRecentScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspacerecentscan.FieldTenantID:
		return m.OldTenantID(ctx)
	case workspacerecentscan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown WorkspaceRecentScan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceRecentScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspacerecentscan.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case workspacerecentscan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown WorkspaceRecentScan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceRecentScanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceRecentScanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceRecentScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkspaceRecentScan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceRecentScanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceRecentScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceRecentScanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown WorkspaceRecentScan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceRecentScanMutation) ResetField(name string) error {
	switch name {
	case workspacerecentscan.FieldTenantID:
		m.ResetTenantID()
		return nil
	case workspacerecentscan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceRecentScan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceRecentScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.tenant != nil {
		edges = append(edges, workspacerecentscan.EdgeTenant)
	}
	if m.shipment_parcel != nil {
		edges = append(edges, workspacerecentscan.EdgeShipmentParcel)
	}
	if m.user != nil {
		edges = append(edges, workspacerecentscan.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceRecentScanMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workspacerecentscan.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case workspacerecentscan.EdgeShipmentParcel:
		if id := m.shipment_parcel; id != nil {
			return []ent.Value{*id}
		}
	case workspacerecentscan.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceRecentScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceRecentScanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceRecentScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedtenant {
		edges = append(edges, workspacerecentscan.EdgeTenant)
	}
	if m.clearedshipment_parcel {
		edges = append(edges, workspacerecentscan.EdgeShipmentParcel)
	}
	if m.cleareduser {
		edges = append(edges, workspacerecentscan.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceRecentScanMutation) EdgeCleared(name string) bool {
	switch name {
	case workspacerecentscan.EdgeTenant:
		return m.clearedtenant
	case workspacerecentscan.EdgeShipmentParcel:
		return m.clearedshipment_parcel
	case workspacerecentscan.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceRecentScanMutation) ClearEdge(name string) error {
	switch name {
	case workspacerecentscan.EdgeTenant:
		m.ClearTenant()
		return nil
	case workspacerecentscan.EdgeShipmentParcel:
		m.ClearShipmentParcel()
		return nil
	case workspacerecentscan.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceRecentScan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceRecentScanMutation) ResetEdge(name string) error {
	switch name {
	case workspacerecentscan.EdgeTenant:
		m.ResetTenant()
		return nil
	case workspacerecentscan.EdgeShipmentParcel:
		m.ResetShipmentParcel()
		return nil
	case workspacerecentscan.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceRecentScan edge %s", name)
}

// WorkstationMutation represents an operation that mutates the Workstation nodes in the graph.
type WorkstationMutation struct {
	config
	op                   Op
	typ                  string
	id                   *pulid.ID
	archived_at          *time.Time
	name                 *string
	device_type          *workstation.DeviceType
	registration_code    *string
	workstation_id       *pulid.ID
	created_at           *time.Time
	last_ping            *time.Time
	status               *workstation.Status
	auto_print_receiver  *bool
	clearedFields        map[string]struct{}
	tenant               *pulid.ID
	clearedtenant        bool
	printer              map[pulid.ID]struct{}
	removedprinter       map[pulid.ID]struct{}
	clearedprinter       bool
	user                 *pulid.ID
	cleareduser          bool
	selected_user        *pulid.ID
	clearedselected_user bool
	done                 bool
	oldValue             func(context.Context) (*Workstation, error)
	predicates           []predicate.Workstation
}

var _ ent.Mutation = (*WorkstationMutation)(nil)

// workstationOption allows management of the mutation configuration using functional options.
type workstationOption func(*WorkstationMutation)

// newWorkstationMutation creates new mutation for the Workstation entity.
func newWorkstationMutation(c config, op Op, opts ...workstationOption) *WorkstationMutation {
	m := &WorkstationMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkstation,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkstationID sets the ID field of the mutation.
func withWorkstationID(id pulid.ID) workstationOption {
	return func(m *WorkstationMutation) {
		var (
			err   error
			once  sync.Once
			value *Workstation
		)
		m.oldValue = func(ctx context.Context) (*Workstation, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workstation.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkstation sets the old Workstation of the mutation.
func withWorkstation(node *Workstation) workstationOption {
	return func(m *WorkstationMutation) {
		m.oldValue = func(context.Context) (*Workstation, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkstationMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkstationMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workstation entities.
func (m *WorkstationMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkstationMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkstationMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workstation.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetTenantID sets the "tenant_id" field.
func (m *WorkstationMutation) SetTenantID(pu pulid.ID) {
	m.tenant = &pu
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *WorkstationMutation) TenantID() (r pulid.ID, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the Workstation entity.
// If the Workstation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkstationMutation) OldTenantID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *WorkstationMutation) ResetTenantID() {
	m.tenant = nil
}

// SetArchivedAt sets the "archived_at" field.
func (m *WorkstationMutation) SetArchivedAt(t time.Time) {
	m.archived_at = &t
}

// ArchivedAt returns the value of the "archived_at" field in the mutation.
func (m *WorkstationMutation) ArchivedAt() (r time.Time, exists bool) {
	v := m.archived_at
	if v == nil {
		return
	}
	return *v, true
}

// OldArchivedAt returns the old "archived_at" field's value of the Workstation entity.
// If the Workstation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkstationMutation) OldArchivedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchivedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchivedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchivedAt: %w", err)
	}
	return oldValue.ArchivedAt, nil
}

// ClearArchivedAt clears the value of the "archived_at" field.
func (m *WorkstationMutation) ClearArchivedAt() {
	m.archived_at = nil
	m.clearedFields[workstation.FieldArchivedAt] = struct{}{}
}

// ArchivedAtCleared returns if the "archived_at" field was cleared in this mutation.
func (m *WorkstationMutation) ArchivedAtCleared() bool {
	_, ok := m.clearedFields[workstation.FieldArchivedAt]
	return ok
}

// ResetArchivedAt resets all changes to the "archived_at" field.
func (m *WorkstationMutation) ResetArchivedAt() {
	m.archived_at = nil
	delete(m.clearedFields, workstation.FieldArchivedAt)
}

// SetName sets the "name" field.
func (m *WorkstationMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkstationMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workstation entity.
// If the Workstation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkstationMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *WorkstationMutation) ResetName() {
	m.name = nil
}

// SetDeviceType sets the "device_type" field.
func (m *WorkstationMutation) SetDeviceType(wt workstation.DeviceType) {
	m.device_type = &wt
}

// DeviceType returns the value of the "device_type" field in the mutation.
func (m *WorkstationMutation) DeviceType() (r workstation.DeviceType, exists bool) {
	v := m.device_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDeviceType returns the old "device_type" field's value of the Workstation entity.
// If the Workstation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkstationMutation) OldDeviceType(ctx context.Context) (v workstation.DeviceType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeviceType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeviceType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeviceType: %w", err)
	}
	return oldValue.DeviceType, nil
}

// ResetDeviceType resets all changes to the "device_type" field.
func (m *WorkstationMutation) ResetDeviceType() {
	m.device_type = nil
}

// SetRegistrationCode sets the "registration_code" field.
func (m *WorkstationMutation) SetRegistrationCode(s string) {
	m.registration_code = &s
}

// RegistrationCode returns the value of the "registration_code" field in the mutation.
func (m *WorkstationMutation) RegistrationCode() (r string, exists bool) {
	v := m.registration_code
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationCode returns the old "registration_code" field's value of the Workstation entity.
// If the Workstation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkstationMutation) OldRegistrationCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationCode: %w", err)
	}
	return oldValue.RegistrationCode, nil
}

// ResetRegistrationCode resets all changes to the "registration_code" field.
func (m *WorkstationMutation) ResetRegistrationCode() {
	m.registration_code = nil
}

// SetWorkstationID sets the "workstation_id" field.
func (m *WorkstationMutation) SetWorkstationID(pu pulid.ID) {
	m.workstation_id = &pu
}

// WorkstationID returns the value of the "workstation_id" field in the mutation.
func (m *WorkstationMutation) WorkstationID() (r pulid.ID, exists bool) {
	v := m.workstation_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkstationID returns the old "workstation_id" field's value of the Workstation entity.
// If the Workstation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkstationMutation) OldWorkstationID(ctx context.Context) (v pulid.ID, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkstationID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkstationID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkstationID: %w", err)
	}
	return oldValue.WorkstationID, nil
}

// ResetWorkstationID resets all changes to the "workstation_id" field.
func (m *WorkstationMutation) ResetWorkstationID() {
	m.workstation_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkstationMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkstationMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workstation entity.
// If the Workstation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkstationMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkstationMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLastPing sets the "last_ping" field.
func (m *WorkstationMutation) SetLastPing(t time.Time) {
	m.last_ping = &t
}

// LastPing returns the value of the "last_ping" field in the mutation.
func (m *WorkstationMutation) LastPing() (r time.Time, exists bool) {
	v := m.last_ping
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPing returns the old "last_ping" field's value of the Workstation entity.
// If the Workstation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkstationMutation) OldLastPing(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPing: %w", err)
	}
	return oldValue.LastPing, nil
}

// ClearLastPing clears the value of the "last_ping" field.
func (m *WorkstationMutation) ClearLastPing() {
	m.last_ping = nil
	m.clearedFields[workstation.FieldLastPing] = struct{}{}
}

// LastPingCleared returns if the "last_ping" field was cleared in this mutation.
func (m *WorkstationMutation) LastPingCleared() bool {
	_, ok := m.clearedFields[workstation.FieldLastPing]
	return ok
}

// ResetLastPing resets all changes to the "last_ping" field.
func (m *WorkstationMutation) ResetLastPing() {
	m.last_ping = nil
	delete(m.clearedFields, workstation.FieldLastPing)
}

// SetStatus sets the "status" field.
func (m *WorkstationMutation) SetStatus(w workstation.Status) {
	m.status = &w
}

// Status returns the value of the "status" field in the mutation.
func (m *WorkstationMutation) Status() (r workstation.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Workstation entity.
// If the Workstation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkstationMutation) OldStatus(ctx context.Context) (v workstation.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *WorkstationMutation) ResetStatus() {
	m.status = nil
}

// SetAutoPrintReceiver sets the "auto_print_receiver" field.
func (m *WorkstationMutation) SetAutoPrintReceiver(b bool) {
	m.auto_print_receiver = &b
}

// AutoPrintReceiver returns the value of the "auto_print_receiver" field in the mutation.
func (m *WorkstationMutation) AutoPrintReceiver() (r bool, exists bool) {
	v := m.auto_print_receiver
	if v == nil {
		return
	}
	return *v, true
}

// OldAutoPrintReceiver returns the old "auto_print_receiver" field's value of the Workstation entity.
// If the Workstation object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkstationMutation) OldAutoPrintReceiver(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAutoPrintReceiver is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAutoPrintReceiver requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAutoPrintReceiver: %w", err)
	}
	return oldValue.AutoPrintReceiver, nil
}

// ResetAutoPrintReceiver resets all changes to the "auto_print_receiver" field.
func (m *WorkstationMutation) ResetAutoPrintReceiver() {
	m.auto_print_receiver = nil
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *WorkstationMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[workstation.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *WorkstationMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *WorkstationMutation) TenantIDs() (ids []pulid.ID) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *WorkstationMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// AddPrinterIDs adds the "printer" edge to the Printer entity by ids.
func (m *WorkstationMutation) AddPrinterIDs(ids ...pulid.ID) {
	if m.printer == nil {
		m.printer = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.printer[ids[i]] = struct{}{}
	}
}

// ClearPrinter clears the "printer" edge to the Printer entity.
func (m *WorkstationMutation) ClearPrinter() {
	m.clearedprinter = true
}

// PrinterCleared reports if the "printer" edge to the Printer entity was cleared.
func (m *WorkstationMutation) PrinterCleared() bool {
	return m.clearedprinter
}

// RemovePrinterIDs removes the "printer" edge to the Printer entity by IDs.
func (m *WorkstationMutation) RemovePrinterIDs(ids ...pulid.ID) {
	if m.removedprinter == nil {
		m.removedprinter = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.printer, ids[i])
		m.removedprinter[ids[i]] = struct{}{}
	}
}

// RemovedPrinter returns the removed IDs of the "printer" edge to the Printer entity.
func (m *WorkstationMutation) RemovedPrinterIDs() (ids []pulid.ID) {
	for id := range m.removedprinter {
		ids = append(ids, id)
	}
	return
}

// PrinterIDs returns the "printer" edge IDs in the mutation.
func (m *WorkstationMutation) PrinterIDs() (ids []pulid.ID) {
	for id := range m.printer {
		ids = append(ids, id)
	}
	return
}

// ResetPrinter resets all changes to the "printer" edge.
func (m *WorkstationMutation) ResetPrinter() {
	m.printer = nil
	m.clearedprinter = false
	m.removedprinter = nil
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *WorkstationMutation) SetUserID(id pulid.ID) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *WorkstationMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WorkstationMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *WorkstationMutation) UserID() (id pulid.ID, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WorkstationMutation) UserIDs() (ids []pulid.ID) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WorkstationMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// SetSelectedUserID sets the "selected_user" edge to the User entity by id.
func (m *WorkstationMutation) SetSelectedUserID(id pulid.ID) {
	m.selected_user = &id
}

// ClearSelectedUser clears the "selected_user" edge to the User entity.
func (m *WorkstationMutation) ClearSelectedUser() {
	m.clearedselected_user = true
}

// SelectedUserCleared reports if the "selected_user" edge to the User entity was cleared.
func (m *WorkstationMutation) SelectedUserCleared() bool {
	return m.clearedselected_user
}

// SelectedUserID returns the "selected_user" edge ID in the mutation.
func (m *WorkstationMutation) SelectedUserID() (id pulid.ID, exists bool) {
	if m.selected_user != nil {
		return *m.selected_user, true
	}
	return
}

// SelectedUserIDs returns the "selected_user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SelectedUserID instead. It exists only for internal usage by the builders.
func (m *WorkstationMutation) SelectedUserIDs() (ids []pulid.ID) {
	if id := m.selected_user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSelectedUser resets all changes to the "selected_user" edge.
func (m *WorkstationMutation) ResetSelectedUser() {
	m.selected_user = nil
	m.clearedselected_user = false
}

// Where appends a list predicates to the WorkstationMutation builder.
func (m *WorkstationMutation) Where(ps ...predicate.Workstation) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkstationMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkstationMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workstation, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkstationMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkstationMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workstation).
func (m *WorkstationMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkstationMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.tenant != nil {
		fields = append(fields, workstation.FieldTenantID)
	}
	if m.archived_at != nil {
		fields = append(fields, workstation.FieldArchivedAt)
	}
	if m.name != nil {
		fields = append(fields, workstation.FieldName)
	}
	if m.device_type != nil {
		fields = append(fields, workstation.FieldDeviceType)
	}
	if m.registration_code != nil {
		fields = append(fields, workstation.FieldRegistrationCode)
	}
	if m.workstation_id != nil {
		fields = append(fields, workstation.FieldWorkstationID)
	}
	if m.created_at != nil {
		fields = append(fields, workstation.FieldCreatedAt)
	}
	if m.last_ping != nil {
		fields = append(fields, workstation.FieldLastPing)
	}
	if m.status != nil {
		fields = append(fields, workstation.FieldStatus)
	}
	if m.auto_print_receiver != nil {
		fields = append(fields, workstation.FieldAutoPrintReceiver)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkstationMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workstation.FieldTenantID:
		return m.TenantID()
	case workstation.FieldArchivedAt:
		return m.ArchivedAt()
	case workstation.FieldName:
		return m.Name()
	case workstation.FieldDeviceType:
		return m.DeviceType()
	case workstation.FieldRegistrationCode:
		return m.RegistrationCode()
	case workstation.FieldWorkstationID:
		return m.WorkstationID()
	case workstation.FieldCreatedAt:
		return m.CreatedAt()
	case workstation.FieldLastPing:
		return m.LastPing()
	case workstation.FieldStatus:
		return m.Status()
	case workstation.FieldAutoPrintReceiver:
		return m.AutoPrintReceiver()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkstationMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workstation.FieldTenantID:
		return m.OldTenantID(ctx)
	case workstation.FieldArchivedAt:
		return m.OldArchivedAt(ctx)
	case workstation.FieldName:
		return m.OldName(ctx)
	case workstation.FieldDeviceType:
		return m.OldDeviceType(ctx)
	case workstation.FieldRegistrationCode:
		return m.OldRegistrationCode(ctx)
	case workstation.FieldWorkstationID:
		return m.OldWorkstationID(ctx)
	case workstation.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workstation.FieldLastPing:
		return m.OldLastPing(ctx)
	case workstation.FieldStatus:
		return m.OldStatus(ctx)
	case workstation.FieldAutoPrintReceiver:
		return m.OldAutoPrintReceiver(ctx)
	}
	return nil, fmt.Errorf("unknown Workstation field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkstationMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workstation.FieldTenantID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case workstation.FieldArchivedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchivedAt(v)
		return nil
	case workstation.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workstation.FieldDeviceType:
		v, ok := value.(workstation.DeviceType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeviceType(v)
		return nil
	case workstation.FieldRegistrationCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationCode(v)
		return nil
	case workstation.FieldWorkstationID:
		v, ok := value.(pulid.ID)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkstationID(v)
		return nil
	case workstation.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workstation.FieldLastPing:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPing(v)
		return nil
	case workstation.FieldStatus:
		v, ok := value.(workstation.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case workstation.FieldAutoPrintReceiver:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAutoPrintReceiver(v)
		return nil
	}
	return fmt.Errorf("unknown Workstation field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkstationMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkstationMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkstationMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workstation numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkstationMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workstation.FieldArchivedAt) {
		fields = append(fields, workstation.FieldArchivedAt)
	}
	if m.FieldCleared(workstation.FieldLastPing) {
		fields = append(fields, workstation.FieldLastPing)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkstationMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkstationMutation) ClearField(name string) error {
	switch name {
	case workstation.FieldArchivedAt:
		m.ClearArchivedAt()
		return nil
	case workstation.FieldLastPing:
		m.ClearLastPing()
		return nil
	}
	return fmt.Errorf("unknown Workstation nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkstationMutation) ResetField(name string) error {
	switch name {
	case workstation.FieldTenantID:
		m.ResetTenantID()
		return nil
	case workstation.FieldArchivedAt:
		m.ResetArchivedAt()
		return nil
	case workstation.FieldName:
		m.ResetName()
		return nil
	case workstation.FieldDeviceType:
		m.ResetDeviceType()
		return nil
	case workstation.FieldRegistrationCode:
		m.ResetRegistrationCode()
		return nil
	case workstation.FieldWorkstationID:
		m.ResetWorkstationID()
		return nil
	case workstation.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workstation.FieldLastPing:
		m.ResetLastPing()
		return nil
	case workstation.FieldStatus:
		m.ResetStatus()
		return nil
	case workstation.FieldAutoPrintReceiver:
		m.ResetAutoPrintReceiver()
		return nil
	}
	return fmt.Errorf("unknown Workstation field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkstationMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenant != nil {
		edges = append(edges, workstation.EdgeTenant)
	}
	if m.printer != nil {
		edges = append(edges, workstation.EdgePrinter)
	}
	if m.user != nil {
		edges = append(edges, workstation.EdgeUser)
	}
	if m.selected_user != nil {
		edges = append(edges, workstation.EdgeSelectedUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkstationMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workstation.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case workstation.EdgePrinter:
		ids := make([]ent.Value, 0, len(m.printer))
		for id := range m.printer {
			ids = append(ids, id)
		}
		return ids
	case workstation.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case workstation.EdgeSelectedUser:
		if id := m.selected_user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkstationMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedprinter != nil {
		edges = append(edges, workstation.EdgePrinter)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkstationMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workstation.EdgePrinter:
		ids := make([]ent.Value, 0, len(m.removedprinter))
		for id := range m.removedprinter {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkstationMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenant {
		edges = append(edges, workstation.EdgeTenant)
	}
	if m.clearedprinter {
		edges = append(edges, workstation.EdgePrinter)
	}
	if m.cleareduser {
		edges = append(edges, workstation.EdgeUser)
	}
	if m.clearedselected_user {
		edges = append(edges, workstation.EdgeSelectedUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkstationMutation) EdgeCleared(name string) bool {
	switch name {
	case workstation.EdgeTenant:
		return m.clearedtenant
	case workstation.EdgePrinter:
		return m.clearedprinter
	case workstation.EdgeUser:
		return m.cleareduser
	case workstation.EdgeSelectedUser:
		return m.clearedselected_user
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkstationMutation) ClearEdge(name string) error {
	switch name {
	case workstation.EdgeTenant:
		m.ClearTenant()
		return nil
	case workstation.EdgeUser:
		m.ClearUser()
		return nil
	case workstation.EdgeSelectedUser:
		m.ClearSelectedUser()
		return nil
	}
	return fmt.Errorf("unknown Workstation unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkstationMutation) ResetEdge(name string) error {
	switch name {
	case workstation.EdgeTenant:
		m.ResetTenant()
		return nil
	case workstation.EdgePrinter:
		m.ResetPrinter()
		return nil
	case workstation.EdgeUser:
		m.ResetUser()
		return nil
	case workstation.EdgeSelectedUser:
		m.ResetSelectedUser()
		return nil
	}
	return fmt.Errorf("unknown Workstation edge %s", name)
}
