// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"io"
	"strconv"

	"delivrio.io/go/ent/accessright"
	"delivrio.io/go/ent/address"
	"delivrio.io/go/ent/addressglobal"
	"delivrio.io/go/ent/apitoken"
	"delivrio.io/go/ent/businesshoursperiod"
	"delivrio.io/go/ent/carrier"
	"delivrio.io/go/ent/carrieradditionalservicebring"
	"delivrio.io/go/ent/carrieradditionalservicedao"
	"delivrio.io/go/ent/carrieradditionalservicedf"
	"delivrio.io/go/ent/carrieradditionalservicedsv"
	"delivrio.io/go/ent/carrieradditionalserviceeasypost"
	"delivrio.io/go/ent/carrieradditionalservicegls"
	"delivrio.io/go/ent/carrieradditionalservicepostnord"
	"delivrio.io/go/ent/carrieradditionalserviceusps"
	"delivrio.io/go/ent/carrierbrand"
	"delivrio.io/go/ent/carrierbring"
	"delivrio.io/go/ent/carrierdao"
	"delivrio.io/go/ent/carrierdf"
	"delivrio.io/go/ent/carrierdsv"
	"delivrio.io/go/ent/carriereasypost"
	"delivrio.io/go/ent/carriergls"
	"delivrio.io/go/ent/carrierpostnord"
	"delivrio.io/go/ent/carrierservice"
	"delivrio.io/go/ent/carrierservicebring"
	"delivrio.io/go/ent/carrierservicedao"
	"delivrio.io/go/ent/carrierservicedf"
	"delivrio.io/go/ent/carrierservicedsv"
	"delivrio.io/go/ent/carrierserviceeasypost"
	"delivrio.io/go/ent/carrierservicegls"
	"delivrio.io/go/ent/carrierservicepostnord"
	"delivrio.io/go/ent/carrierserviceusps"
	"delivrio.io/go/ent/carrierusps"
	"delivrio.io/go/ent/changehistory"
	"delivrio.io/go/ent/colli"
	"delivrio.io/go/ent/connection"
	"delivrio.io/go/ent/connectionbrand"
	"delivrio.io/go/ent/connectionlookup"
	"delivrio.io/go/ent/connectionshopify"
	"delivrio.io/go/ent/connectoptioncarrier"
	"delivrio.io/go/ent/connectoptionplatform"
	"delivrio.io/go/ent/consolidation"
	"delivrio.io/go/ent/contact"
	"delivrio.io/go/ent/country"
	"delivrio.io/go/ent/countryharmonizedcode"
	"delivrio.io/go/ent/currency"
	"delivrio.io/go/ent/deliveryoption"
	"delivrio.io/go/ent/deliveryoptionbring"
	"delivrio.io/go/ent/deliveryoptiondao"
	"delivrio.io/go/ent/deliveryoptiondf"
	"delivrio.io/go/ent/deliveryoptiondsv"
	"delivrio.io/go/ent/deliveryoptioneasypost"
	"delivrio.io/go/ent/deliveryoptiongls"
	"delivrio.io/go/ent/deliveryoptionpostnord"
	"delivrio.io/go/ent/deliveryoptionusps"
	"delivrio.io/go/ent/deliveryrule"
	"delivrio.io/go/ent/deliveryruleconstraint"
	"delivrio.io/go/ent/deliveryruleconstraintgroup"
	"delivrio.io/go/ent/document"
	"delivrio.io/go/ent/documentfile"
	"delivrio.io/go/ent/emailtemplate"
	"delivrio.io/go/ent/hypothesistest"
	"delivrio.io/go/ent/hypothesistestdeliveryoption"
	"delivrio.io/go/ent/hypothesistestdeliveryoptionlookup"
	"delivrio.io/go/ent/hypothesistestdeliveryoptionrequest"
	"delivrio.io/go/ent/inventoryitem"
	"delivrio.io/go/ent/language"
	"delivrio.io/go/ent/location"
	"delivrio.io/go/ent/locationtag"
	"delivrio.io/go/ent/notification"
	"delivrio.io/go/ent/order"
	"delivrio.io/go/ent/orderhistory"
	"delivrio.io/go/ent/orderline"
	"delivrio.io/go/ent/ordersender"
	"delivrio.io/go/ent/otkrequests"
	"delivrio.io/go/ent/packaging"
	"delivrio.io/go/ent/packagingdf"
	"delivrio.io/go/ent/packagingusps"
	"delivrio.io/go/ent/packaginguspsprocessingcategory"
	"delivrio.io/go/ent/packaginguspsrateindicator"
	"delivrio.io/go/ent/pallet"
	"delivrio.io/go/ent/parcelshop"
	"delivrio.io/go/ent/parcelshopbring"
	"delivrio.io/go/ent/parcelshopdao"
	"delivrio.io/go/ent/parcelshopgls"
	"delivrio.io/go/ent/parcelshoppostnord"
	"delivrio.io/go/ent/plan"
	"delivrio.io/go/ent/planhistory"
	"delivrio.io/go/ent/printer"
	"delivrio.io/go/ent/printjob"
	"delivrio.io/go/ent/product"
	"delivrio.io/go/ent/productimage"
	"delivrio.io/go/ent/producttag"
	"delivrio.io/go/ent/productvariant"
	"delivrio.io/go/ent/returncolli"
	"delivrio.io/go/ent/returncollihistory"
	"delivrio.io/go/ent/returnorderline"
	"delivrio.io/go/ent/returnportal"
	"delivrio.io/go/ent/returnportalclaim"
	"delivrio.io/go/ent/seatgroup"
	"delivrio.io/go/ent/seatgroupaccessright"
	"delivrio.io/go/ent/shipment"
	"delivrio.io/go/ent/shipmentbring"
	"delivrio.io/go/ent/shipmentdao"
	"delivrio.io/go/ent/shipmentdf"
	"delivrio.io/go/ent/shipmentdsv"
	"delivrio.io/go/ent/shipmenteasypost"
	"delivrio.io/go/ent/shipmentgls"
	"delivrio.io/go/ent/shipmenthistory"
	"delivrio.io/go/ent/shipmentpallet"
	"delivrio.io/go/ent/shipmentparcel"
	"delivrio.io/go/ent/shipmentpostnord"
	"delivrio.io/go/ent/shipmentusps"
	"delivrio.io/go/ent/signupoptions"
	"delivrio.io/go/ent/systemevents"
	"delivrio.io/go/ent/tenant"
	"delivrio.io/go/ent/user"
	"delivrio.io/go/ent/userseat"
	"delivrio.io/go/ent/workspacerecentscan"
	"delivrio.io/go/ent/workstation"
	"delivrio.io/shared-utils/pulid"
	"entgo.io/contrib/entgql"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/errcode"
	"github.com/vektah/gqlparser/v2/gqlerror"
)

// Common entgql types.
type (
	Cursor         = entgql.Cursor[pulid.ID]
	PageInfo       = entgql.PageInfo[pulid.ID]
	OrderDirection = entgql.OrderDirection
)

func orderFunc(o OrderDirection, field string) func(*sql.Selector) {
	if o == entgql.OrderDirectionDesc {
		return Desc(field)
	}
	return Asc(field)
}

const errInvalidPagination = "INVALID_PAGINATION"

func validateFirstLast(first, last *int) (err *gqlerror.Error) {
	switch {
	case first != nil && last != nil:
		err = &gqlerror.Error{
			Message: "Passing both `first` and `last` to paginate a connection is not supported.",
		}
	case first != nil && *first < 0:
		err = &gqlerror.Error{
			Message: "`first` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	case last != nil && *last < 0:
		err = &gqlerror.Error{
			Message: "`last` on a connection cannot be less than zero.",
		}
		errcode.Set(err, errInvalidPagination)
	}
	return err
}

func collectedField(ctx context.Context, path ...string) *graphql.CollectedField {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return nil
	}
	field := fc.Field
	oc := graphql.GetOperationContext(ctx)
walk:
	for _, name := range path {
		for _, f := range graphql.CollectFields(oc, field.Selections, nil) {
			if f.Alias == name {
				field = f
				continue walk
			}
		}
		return nil
	}
	return &field
}

func hasCollectedField(ctx context.Context, path ...string) bool {
	if graphql.GetFieldContext(ctx) == nil {
		return true
	}
	return collectedField(ctx, path...) != nil
}

const (
	edgesField      = "edges"
	nodeField       = "node"
	pageInfoField   = "pageInfo"
	totalCountField = "totalCount"
)

func paginateLimit(first, last *int) int {
	var limit int
	if first != nil {
		limit = *first + 1
	} else if last != nil {
		limit = *last + 1
	}
	return limit
}

// APITokenEdge is the edge representation of APIToken.
type APITokenEdge struct {
	Node   *APIToken `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// APITokenConnection is the connection containing edges to APIToken.
type APITokenConnection struct {
	Edges      []*APITokenEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *APITokenConnection) build(nodes []*APIToken, pager *apitokenPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *APIToken
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *APIToken {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *APIToken {
			return nodes[i]
		}
	}
	c.Edges = make([]*APITokenEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &APITokenEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// APITokenPaginateOption enables pagination customization.
type APITokenPaginateOption func(*apitokenPager) error

// WithAPITokenOrder configures pagination ordering.
func WithAPITokenOrder(order *APITokenOrder) APITokenPaginateOption {
	if order == nil {
		order = DefaultAPITokenOrder
	}
	o := *order
	return func(pager *apitokenPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAPITokenOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAPITokenFilter configures pagination filter.
func WithAPITokenFilter(filter func(*APITokenQuery) (*APITokenQuery, error)) APITokenPaginateOption {
	return func(pager *apitokenPager) error {
		if filter == nil {
			return errors.New("APITokenQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type apitokenPager struct {
	reverse bool
	order   *APITokenOrder
	filter  func(*APITokenQuery) (*APITokenQuery, error)
}

func newAPITokenPager(opts []APITokenPaginateOption, reverse bool) (*apitokenPager, error) {
	pager := &apitokenPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAPITokenOrder
	}
	return pager, nil
}

func (p *apitokenPager) applyFilter(query *APITokenQuery) (*APITokenQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *apitokenPager) toCursor(at *APIToken) Cursor {
	return p.order.Field.toCursor(at)
}

func (p *apitokenPager) applyCursors(query *APITokenQuery, after, before *Cursor) (*APITokenQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAPITokenOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *apitokenPager) applyOrder(query *APITokenQuery) *APITokenQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAPITokenOrder.Field {
		query = query.Order(DefaultAPITokenOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *apitokenPager) orderExpr(query *APITokenQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAPITokenOrder.Field {
			b.Comma().Ident(DefaultAPITokenOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to APIToken.
func (at *APITokenQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...APITokenPaginateOption,
) (*APITokenConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAPITokenPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if at, err = pager.applyFilter(at); err != nil {
		return nil, err
	}
	conn := &APITokenConnection{Edges: []*APITokenEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := at.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if at, err = pager.applyCursors(at, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		at.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := at.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	at = pager.applyOrder(at)
	nodes, err := at.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// APITokenOrderField defines the ordering field of APIToken.
type APITokenOrderField struct {
	// Value extracts the ordering value from the given APIToken.
	Value    func(*APIToken) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) apitoken.OrderOption
	toCursor func(*APIToken) Cursor
}

// APITokenOrder defines the ordering of APIToken.
type APITokenOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *APITokenOrderField `json:"field"`
}

// DefaultAPITokenOrder is the default ordering of APIToken.
var DefaultAPITokenOrder = &APITokenOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &APITokenOrderField{
		Value: func(at *APIToken) (ent.Value, error) {
			return at.ID, nil
		},
		column: apitoken.FieldID,
		toTerm: apitoken.ByID,
		toCursor: func(at *APIToken) Cursor {
			return Cursor{ID: at.ID}
		},
	},
}

// ToEdge converts APIToken into APITokenEdge.
func (at *APIToken) ToEdge(order *APITokenOrder) *APITokenEdge {
	if order == nil {
		order = DefaultAPITokenOrder
	}
	return &APITokenEdge{
		Node:   at,
		Cursor: order.Field.toCursor(at),
	}
}

// AccessRightEdge is the edge representation of AccessRight.
type AccessRightEdge struct {
	Node   *AccessRight `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// AccessRightConnection is the connection containing edges to AccessRight.
type AccessRightConnection struct {
	Edges      []*AccessRightEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *AccessRightConnection) build(nodes []*AccessRight, pager *accessrightPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AccessRight
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AccessRight {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AccessRight {
			return nodes[i]
		}
	}
	c.Edges = make([]*AccessRightEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AccessRightEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AccessRightPaginateOption enables pagination customization.
type AccessRightPaginateOption func(*accessrightPager) error

// WithAccessRightOrder configures pagination ordering.
func WithAccessRightOrder(order *AccessRightOrder) AccessRightPaginateOption {
	if order == nil {
		order = DefaultAccessRightOrder
	}
	o := *order
	return func(pager *accessrightPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAccessRightOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAccessRightFilter configures pagination filter.
func WithAccessRightFilter(filter func(*AccessRightQuery) (*AccessRightQuery, error)) AccessRightPaginateOption {
	return func(pager *accessrightPager) error {
		if filter == nil {
			return errors.New("AccessRightQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type accessrightPager struct {
	reverse bool
	order   *AccessRightOrder
	filter  func(*AccessRightQuery) (*AccessRightQuery, error)
}

func newAccessRightPager(opts []AccessRightPaginateOption, reverse bool) (*accessrightPager, error) {
	pager := &accessrightPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAccessRightOrder
	}
	return pager, nil
}

func (p *accessrightPager) applyFilter(query *AccessRightQuery) (*AccessRightQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *accessrightPager) toCursor(ar *AccessRight) Cursor {
	return p.order.Field.toCursor(ar)
}

func (p *accessrightPager) applyCursors(query *AccessRightQuery, after, before *Cursor) (*AccessRightQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAccessRightOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *accessrightPager) applyOrder(query *AccessRightQuery) *AccessRightQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAccessRightOrder.Field {
		query = query.Order(DefaultAccessRightOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *accessrightPager) orderExpr(query *AccessRightQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAccessRightOrder.Field {
			b.Comma().Ident(DefaultAccessRightOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AccessRight.
func (ar *AccessRightQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AccessRightPaginateOption,
) (*AccessRightConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAccessRightPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ar, err = pager.applyFilter(ar); err != nil {
		return nil, err
	}
	conn := &AccessRightConnection{Edges: []*AccessRightEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ar.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ar, err = pager.applyCursors(ar, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ar.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ar.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ar = pager.applyOrder(ar)
	nodes, err := ar.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AccessRightOrderField defines the ordering field of AccessRight.
type AccessRightOrderField struct {
	// Value extracts the ordering value from the given AccessRight.
	Value    func(*AccessRight) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) accessright.OrderOption
	toCursor func(*AccessRight) Cursor
}

// AccessRightOrder defines the ordering of AccessRight.
type AccessRightOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *AccessRightOrderField `json:"field"`
}

// DefaultAccessRightOrder is the default ordering of AccessRight.
var DefaultAccessRightOrder = &AccessRightOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AccessRightOrderField{
		Value: func(ar *AccessRight) (ent.Value, error) {
			return ar.ID, nil
		},
		column: accessright.FieldID,
		toTerm: accessright.ByID,
		toCursor: func(ar *AccessRight) Cursor {
			return Cursor{ID: ar.ID}
		},
	},
}

// ToEdge converts AccessRight into AccessRightEdge.
func (ar *AccessRight) ToEdge(order *AccessRightOrder) *AccessRightEdge {
	if order == nil {
		order = DefaultAccessRightOrder
	}
	return &AccessRightEdge{
		Node:   ar,
		Cursor: order.Field.toCursor(ar),
	}
}

// AddressEdge is the edge representation of Address.
type AddressEdge struct {
	Node   *Address `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// AddressConnection is the connection containing edges to Address.
type AddressConnection struct {
	Edges      []*AddressEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *AddressConnection) build(nodes []*Address, pager *addressPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Address
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Address {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Address {
			return nodes[i]
		}
	}
	c.Edges = make([]*AddressEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AddressEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AddressPaginateOption enables pagination customization.
type AddressPaginateOption func(*addressPager) error

// WithAddressOrder configures pagination ordering.
func WithAddressOrder(order *AddressOrder) AddressPaginateOption {
	if order == nil {
		order = DefaultAddressOrder
	}
	o := *order
	return func(pager *addressPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAddressOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAddressFilter configures pagination filter.
func WithAddressFilter(filter func(*AddressQuery) (*AddressQuery, error)) AddressPaginateOption {
	return func(pager *addressPager) error {
		if filter == nil {
			return errors.New("AddressQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type addressPager struct {
	reverse bool
	order   *AddressOrder
	filter  func(*AddressQuery) (*AddressQuery, error)
}

func newAddressPager(opts []AddressPaginateOption, reverse bool) (*addressPager, error) {
	pager := &addressPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAddressOrder
	}
	return pager, nil
}

func (p *addressPager) applyFilter(query *AddressQuery) (*AddressQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *addressPager) toCursor(a *Address) Cursor {
	return p.order.Field.toCursor(a)
}

func (p *addressPager) applyCursors(query *AddressQuery, after, before *Cursor) (*AddressQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAddressOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *addressPager) applyOrder(query *AddressQuery) *AddressQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAddressOrder.Field {
		query = query.Order(DefaultAddressOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *addressPager) orderExpr(query *AddressQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAddressOrder.Field {
			b.Comma().Ident(DefaultAddressOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Address.
func (a *AddressQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AddressPaginateOption,
) (*AddressConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAddressPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if a, err = pager.applyFilter(a); err != nil {
		return nil, err
	}
	conn := &AddressConnection{Edges: []*AddressEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := a.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if a, err = pager.applyCursors(a, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		a.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := a.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	a = pager.applyOrder(a)
	nodes, err := a.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AddressOrderField defines the ordering field of Address.
type AddressOrderField struct {
	// Value extracts the ordering value from the given Address.
	Value    func(*Address) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) address.OrderOption
	toCursor func(*Address) Cursor
}

// AddressOrder defines the ordering of Address.
type AddressOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *AddressOrderField `json:"field"`
}

// DefaultAddressOrder is the default ordering of Address.
var DefaultAddressOrder = &AddressOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AddressOrderField{
		Value: func(a *Address) (ent.Value, error) {
			return a.ID, nil
		},
		column: address.FieldID,
		toTerm: address.ByID,
		toCursor: func(a *Address) Cursor {
			return Cursor{ID: a.ID}
		},
	},
}

// ToEdge converts Address into AddressEdge.
func (a *Address) ToEdge(order *AddressOrder) *AddressEdge {
	if order == nil {
		order = DefaultAddressOrder
	}
	return &AddressEdge{
		Node:   a,
		Cursor: order.Field.toCursor(a),
	}
}

// AddressGlobalEdge is the edge representation of AddressGlobal.
type AddressGlobalEdge struct {
	Node   *AddressGlobal `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// AddressGlobalConnection is the connection containing edges to AddressGlobal.
type AddressGlobalConnection struct {
	Edges      []*AddressGlobalEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *AddressGlobalConnection) build(nodes []*AddressGlobal, pager *addressglobalPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *AddressGlobal
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *AddressGlobal {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *AddressGlobal {
			return nodes[i]
		}
	}
	c.Edges = make([]*AddressGlobalEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &AddressGlobalEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// AddressGlobalPaginateOption enables pagination customization.
type AddressGlobalPaginateOption func(*addressglobalPager) error

// WithAddressGlobalOrder configures pagination ordering.
func WithAddressGlobalOrder(order *AddressGlobalOrder) AddressGlobalPaginateOption {
	if order == nil {
		order = DefaultAddressGlobalOrder
	}
	o := *order
	return func(pager *addressglobalPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultAddressGlobalOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithAddressGlobalFilter configures pagination filter.
func WithAddressGlobalFilter(filter func(*AddressGlobalQuery) (*AddressGlobalQuery, error)) AddressGlobalPaginateOption {
	return func(pager *addressglobalPager) error {
		if filter == nil {
			return errors.New("AddressGlobalQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type addressglobalPager struct {
	reverse bool
	order   *AddressGlobalOrder
	filter  func(*AddressGlobalQuery) (*AddressGlobalQuery, error)
}

func newAddressGlobalPager(opts []AddressGlobalPaginateOption, reverse bool) (*addressglobalPager, error) {
	pager := &addressglobalPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultAddressGlobalOrder
	}
	return pager, nil
}

func (p *addressglobalPager) applyFilter(query *AddressGlobalQuery) (*AddressGlobalQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *addressglobalPager) toCursor(ag *AddressGlobal) Cursor {
	return p.order.Field.toCursor(ag)
}

func (p *addressglobalPager) applyCursors(query *AddressGlobalQuery, after, before *Cursor) (*AddressGlobalQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultAddressGlobalOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *addressglobalPager) applyOrder(query *AddressGlobalQuery) *AddressGlobalQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultAddressGlobalOrder.Field {
		query = query.Order(DefaultAddressGlobalOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *addressglobalPager) orderExpr(query *AddressGlobalQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultAddressGlobalOrder.Field {
			b.Comma().Ident(DefaultAddressGlobalOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to AddressGlobal.
func (ag *AddressGlobalQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...AddressGlobalPaginateOption,
) (*AddressGlobalConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newAddressGlobalPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ag, err = pager.applyFilter(ag); err != nil {
		return nil, err
	}
	conn := &AddressGlobalConnection{Edges: []*AddressGlobalEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ag.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ag, err = pager.applyCursors(ag, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ag.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ag.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ag = pager.applyOrder(ag)
	nodes, err := ag.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// AddressGlobalOrderField defines the ordering field of AddressGlobal.
type AddressGlobalOrderField struct {
	// Value extracts the ordering value from the given AddressGlobal.
	Value    func(*AddressGlobal) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) addressglobal.OrderOption
	toCursor func(*AddressGlobal) Cursor
}

// AddressGlobalOrder defines the ordering of AddressGlobal.
type AddressGlobalOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *AddressGlobalOrderField `json:"field"`
}

// DefaultAddressGlobalOrder is the default ordering of AddressGlobal.
var DefaultAddressGlobalOrder = &AddressGlobalOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &AddressGlobalOrderField{
		Value: func(ag *AddressGlobal) (ent.Value, error) {
			return ag.ID, nil
		},
		column: addressglobal.FieldID,
		toTerm: addressglobal.ByID,
		toCursor: func(ag *AddressGlobal) Cursor {
			return Cursor{ID: ag.ID}
		},
	},
}

// ToEdge converts AddressGlobal into AddressGlobalEdge.
func (ag *AddressGlobal) ToEdge(order *AddressGlobalOrder) *AddressGlobalEdge {
	if order == nil {
		order = DefaultAddressGlobalOrder
	}
	return &AddressGlobalEdge{
		Node:   ag,
		Cursor: order.Field.toCursor(ag),
	}
}

// BusinessHoursPeriodEdge is the edge representation of BusinessHoursPeriod.
type BusinessHoursPeriodEdge struct {
	Node   *BusinessHoursPeriod `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// BusinessHoursPeriodConnection is the connection containing edges to BusinessHoursPeriod.
type BusinessHoursPeriodConnection struct {
	Edges      []*BusinessHoursPeriodEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *BusinessHoursPeriodConnection) build(nodes []*BusinessHoursPeriod, pager *businesshoursperiodPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *BusinessHoursPeriod
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *BusinessHoursPeriod {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *BusinessHoursPeriod {
			return nodes[i]
		}
	}
	c.Edges = make([]*BusinessHoursPeriodEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &BusinessHoursPeriodEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// BusinessHoursPeriodPaginateOption enables pagination customization.
type BusinessHoursPeriodPaginateOption func(*businesshoursperiodPager) error

// WithBusinessHoursPeriodOrder configures pagination ordering.
func WithBusinessHoursPeriodOrder(order *BusinessHoursPeriodOrder) BusinessHoursPeriodPaginateOption {
	if order == nil {
		order = DefaultBusinessHoursPeriodOrder
	}
	o := *order
	return func(pager *businesshoursperiodPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultBusinessHoursPeriodOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithBusinessHoursPeriodFilter configures pagination filter.
func WithBusinessHoursPeriodFilter(filter func(*BusinessHoursPeriodQuery) (*BusinessHoursPeriodQuery, error)) BusinessHoursPeriodPaginateOption {
	return func(pager *businesshoursperiodPager) error {
		if filter == nil {
			return errors.New("BusinessHoursPeriodQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type businesshoursperiodPager struct {
	reverse bool
	order   *BusinessHoursPeriodOrder
	filter  func(*BusinessHoursPeriodQuery) (*BusinessHoursPeriodQuery, error)
}

func newBusinessHoursPeriodPager(opts []BusinessHoursPeriodPaginateOption, reverse bool) (*businesshoursperiodPager, error) {
	pager := &businesshoursperiodPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultBusinessHoursPeriodOrder
	}
	return pager, nil
}

func (p *businesshoursperiodPager) applyFilter(query *BusinessHoursPeriodQuery) (*BusinessHoursPeriodQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *businesshoursperiodPager) toCursor(bhp *BusinessHoursPeriod) Cursor {
	return p.order.Field.toCursor(bhp)
}

func (p *businesshoursperiodPager) applyCursors(query *BusinessHoursPeriodQuery, after, before *Cursor) (*BusinessHoursPeriodQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultBusinessHoursPeriodOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *businesshoursperiodPager) applyOrder(query *BusinessHoursPeriodQuery) *BusinessHoursPeriodQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultBusinessHoursPeriodOrder.Field {
		query = query.Order(DefaultBusinessHoursPeriodOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *businesshoursperiodPager) orderExpr(query *BusinessHoursPeriodQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultBusinessHoursPeriodOrder.Field {
			b.Comma().Ident(DefaultBusinessHoursPeriodOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to BusinessHoursPeriod.
func (bhp *BusinessHoursPeriodQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...BusinessHoursPeriodPaginateOption,
) (*BusinessHoursPeriodConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newBusinessHoursPeriodPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if bhp, err = pager.applyFilter(bhp); err != nil {
		return nil, err
	}
	conn := &BusinessHoursPeriodConnection{Edges: []*BusinessHoursPeriodEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := bhp.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if bhp, err = pager.applyCursors(bhp, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		bhp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := bhp.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	bhp = pager.applyOrder(bhp)
	nodes, err := bhp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// BusinessHoursPeriodOrderField defines the ordering field of BusinessHoursPeriod.
type BusinessHoursPeriodOrderField struct {
	// Value extracts the ordering value from the given BusinessHoursPeriod.
	Value    func(*BusinessHoursPeriod) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) businesshoursperiod.OrderOption
	toCursor func(*BusinessHoursPeriod) Cursor
}

// BusinessHoursPeriodOrder defines the ordering of BusinessHoursPeriod.
type BusinessHoursPeriodOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *BusinessHoursPeriodOrderField `json:"field"`
}

// DefaultBusinessHoursPeriodOrder is the default ordering of BusinessHoursPeriod.
var DefaultBusinessHoursPeriodOrder = &BusinessHoursPeriodOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &BusinessHoursPeriodOrderField{
		Value: func(bhp *BusinessHoursPeriod) (ent.Value, error) {
			return bhp.ID, nil
		},
		column: businesshoursperiod.FieldID,
		toTerm: businesshoursperiod.ByID,
		toCursor: func(bhp *BusinessHoursPeriod) Cursor {
			return Cursor{ID: bhp.ID}
		},
	},
}

// ToEdge converts BusinessHoursPeriod into BusinessHoursPeriodEdge.
func (bhp *BusinessHoursPeriod) ToEdge(order *BusinessHoursPeriodOrder) *BusinessHoursPeriodEdge {
	if order == nil {
		order = DefaultBusinessHoursPeriodOrder
	}
	return &BusinessHoursPeriodEdge{
		Node:   bhp,
		Cursor: order.Field.toCursor(bhp),
	}
}

// CarrierEdge is the edge representation of Carrier.
type CarrierEdge struct {
	Node   *Carrier `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CarrierConnection is the connection containing edges to Carrier.
type CarrierConnection struct {
	Edges      []*CarrierEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CarrierConnection) build(nodes []*Carrier, pager *carrierPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Carrier
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Carrier {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Carrier {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierPaginateOption enables pagination customization.
type CarrierPaginateOption func(*carrierPager) error

// WithCarrierOrder configures pagination ordering.
func WithCarrierOrder(order *CarrierOrder) CarrierPaginateOption {
	if order == nil {
		order = DefaultCarrierOrder
	}
	o := *order
	return func(pager *carrierPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierFilter configures pagination filter.
func WithCarrierFilter(filter func(*CarrierQuery) (*CarrierQuery, error)) CarrierPaginateOption {
	return func(pager *carrierPager) error {
		if filter == nil {
			return errors.New("CarrierQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierPager struct {
	reverse bool
	order   *CarrierOrder
	filter  func(*CarrierQuery) (*CarrierQuery, error)
}

func newCarrierPager(opts []CarrierPaginateOption, reverse bool) (*carrierPager, error) {
	pager := &carrierPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierOrder
	}
	return pager, nil
}

func (p *carrierPager) applyFilter(query *CarrierQuery) (*CarrierQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierPager) toCursor(c *Carrier) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *carrierPager) applyCursors(query *CarrierQuery, after, before *Cursor) (*CarrierQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierPager) applyOrder(query *CarrierQuery) *CarrierQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierOrder.Field {
		query = query.Order(DefaultCarrierOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierPager) orderExpr(query *CarrierQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierOrder.Field {
			b.Comma().Ident(DefaultCarrierOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Carrier.
func (c *CarrierQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierPaginateOption,
) (*CarrierConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CarrierConnection{Edges: []*CarrierEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierOrderField defines the ordering field of Carrier.
type CarrierOrderField struct {
	// Value extracts the ordering value from the given Carrier.
	Value    func(*Carrier) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrier.OrderOption
	toCursor func(*Carrier) Cursor
}

// CarrierOrder defines the ordering of Carrier.
type CarrierOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CarrierOrderField `json:"field"`
}

// DefaultCarrierOrder is the default ordering of Carrier.
var DefaultCarrierOrder = &CarrierOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierOrderField{
		Value: func(c *Carrier) (ent.Value, error) {
			return c.ID, nil
		},
		column: carrier.FieldID,
		toTerm: carrier.ByID,
		toCursor: func(c *Carrier) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Carrier into CarrierEdge.
func (c *Carrier) ToEdge(order *CarrierOrder) *CarrierEdge {
	if order == nil {
		order = DefaultCarrierOrder
	}
	return &CarrierEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CarrierAdditionalServiceBringEdge is the edge representation of CarrierAdditionalServiceBring.
type CarrierAdditionalServiceBringEdge struct {
	Node   *CarrierAdditionalServiceBring `json:"node"`
	Cursor Cursor                         `json:"cursor"`
}

// CarrierAdditionalServiceBringConnection is the connection containing edges to CarrierAdditionalServiceBring.
type CarrierAdditionalServiceBringConnection struct {
	Edges      []*CarrierAdditionalServiceBringEdge `json:"edges"`
	PageInfo   PageInfo                             `json:"pageInfo"`
	TotalCount int                                  `json:"totalCount"`
}

func (c *CarrierAdditionalServiceBringConnection) build(nodes []*CarrierAdditionalServiceBring, pager *carrieradditionalservicebringPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierAdditionalServiceBring
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierAdditionalServiceBring {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierAdditionalServiceBring {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierAdditionalServiceBringEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierAdditionalServiceBringEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierAdditionalServiceBringPaginateOption enables pagination customization.
type CarrierAdditionalServiceBringPaginateOption func(*carrieradditionalservicebringPager) error

// WithCarrierAdditionalServiceBringOrder configures pagination ordering.
func WithCarrierAdditionalServiceBringOrder(order *CarrierAdditionalServiceBringOrder) CarrierAdditionalServiceBringPaginateOption {
	if order == nil {
		order = DefaultCarrierAdditionalServiceBringOrder
	}
	o := *order
	return func(pager *carrieradditionalservicebringPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierAdditionalServiceBringOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierAdditionalServiceBringFilter configures pagination filter.
func WithCarrierAdditionalServiceBringFilter(filter func(*CarrierAdditionalServiceBringQuery) (*CarrierAdditionalServiceBringQuery, error)) CarrierAdditionalServiceBringPaginateOption {
	return func(pager *carrieradditionalservicebringPager) error {
		if filter == nil {
			return errors.New("CarrierAdditionalServiceBringQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrieradditionalservicebringPager struct {
	reverse bool
	order   *CarrierAdditionalServiceBringOrder
	filter  func(*CarrierAdditionalServiceBringQuery) (*CarrierAdditionalServiceBringQuery, error)
}

func newCarrierAdditionalServiceBringPager(opts []CarrierAdditionalServiceBringPaginateOption, reverse bool) (*carrieradditionalservicebringPager, error) {
	pager := &carrieradditionalservicebringPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierAdditionalServiceBringOrder
	}
	return pager, nil
}

func (p *carrieradditionalservicebringPager) applyFilter(query *CarrierAdditionalServiceBringQuery) (*CarrierAdditionalServiceBringQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrieradditionalservicebringPager) toCursor(casb *CarrierAdditionalServiceBring) Cursor {
	return p.order.Field.toCursor(casb)
}

func (p *carrieradditionalservicebringPager) applyCursors(query *CarrierAdditionalServiceBringQuery, after, before *Cursor) (*CarrierAdditionalServiceBringQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierAdditionalServiceBringOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrieradditionalservicebringPager) applyOrder(query *CarrierAdditionalServiceBringQuery) *CarrierAdditionalServiceBringQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierAdditionalServiceBringOrder.Field {
		query = query.Order(DefaultCarrierAdditionalServiceBringOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrieradditionalservicebringPager) orderExpr(query *CarrierAdditionalServiceBringQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierAdditionalServiceBringOrder.Field {
			b.Comma().Ident(DefaultCarrierAdditionalServiceBringOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierAdditionalServiceBring.
func (casb *CarrierAdditionalServiceBringQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierAdditionalServiceBringPaginateOption,
) (*CarrierAdditionalServiceBringConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierAdditionalServiceBringPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if casb, err = pager.applyFilter(casb); err != nil {
		return nil, err
	}
	conn := &CarrierAdditionalServiceBringConnection{Edges: []*CarrierAdditionalServiceBringEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := casb.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if casb, err = pager.applyCursors(casb, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		casb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := casb.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	casb = pager.applyOrder(casb)
	nodes, err := casb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierAdditionalServiceBringOrderField defines the ordering field of CarrierAdditionalServiceBring.
type CarrierAdditionalServiceBringOrderField struct {
	// Value extracts the ordering value from the given CarrierAdditionalServiceBring.
	Value    func(*CarrierAdditionalServiceBring) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrieradditionalservicebring.OrderOption
	toCursor func(*CarrierAdditionalServiceBring) Cursor
}

// CarrierAdditionalServiceBringOrder defines the ordering of CarrierAdditionalServiceBring.
type CarrierAdditionalServiceBringOrder struct {
	Direction OrderDirection                           `json:"direction"`
	Field     *CarrierAdditionalServiceBringOrderField `json:"field"`
}

// DefaultCarrierAdditionalServiceBringOrder is the default ordering of CarrierAdditionalServiceBring.
var DefaultCarrierAdditionalServiceBringOrder = &CarrierAdditionalServiceBringOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierAdditionalServiceBringOrderField{
		Value: func(casb *CarrierAdditionalServiceBring) (ent.Value, error) {
			return casb.ID, nil
		},
		column: carrieradditionalservicebring.FieldID,
		toTerm: carrieradditionalservicebring.ByID,
		toCursor: func(casb *CarrierAdditionalServiceBring) Cursor {
			return Cursor{ID: casb.ID}
		},
	},
}

// ToEdge converts CarrierAdditionalServiceBring into CarrierAdditionalServiceBringEdge.
func (casb *CarrierAdditionalServiceBring) ToEdge(order *CarrierAdditionalServiceBringOrder) *CarrierAdditionalServiceBringEdge {
	if order == nil {
		order = DefaultCarrierAdditionalServiceBringOrder
	}
	return &CarrierAdditionalServiceBringEdge{
		Node:   casb,
		Cursor: order.Field.toCursor(casb),
	}
}

// CarrierAdditionalServiceDAOEdge is the edge representation of CarrierAdditionalServiceDAO.
type CarrierAdditionalServiceDAOEdge struct {
	Node   *CarrierAdditionalServiceDAO `json:"node"`
	Cursor Cursor                       `json:"cursor"`
}

// CarrierAdditionalServiceDAOConnection is the connection containing edges to CarrierAdditionalServiceDAO.
type CarrierAdditionalServiceDAOConnection struct {
	Edges      []*CarrierAdditionalServiceDAOEdge `json:"edges"`
	PageInfo   PageInfo                           `json:"pageInfo"`
	TotalCount int                                `json:"totalCount"`
}

func (c *CarrierAdditionalServiceDAOConnection) build(nodes []*CarrierAdditionalServiceDAO, pager *carrieradditionalservicedaoPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierAdditionalServiceDAO
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierAdditionalServiceDAO {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierAdditionalServiceDAO {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierAdditionalServiceDAOEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierAdditionalServiceDAOEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierAdditionalServiceDAOPaginateOption enables pagination customization.
type CarrierAdditionalServiceDAOPaginateOption func(*carrieradditionalservicedaoPager) error

// WithCarrierAdditionalServiceDAOOrder configures pagination ordering.
func WithCarrierAdditionalServiceDAOOrder(order *CarrierAdditionalServiceDAOOrder) CarrierAdditionalServiceDAOPaginateOption {
	if order == nil {
		order = DefaultCarrierAdditionalServiceDAOOrder
	}
	o := *order
	return func(pager *carrieradditionalservicedaoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierAdditionalServiceDAOOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierAdditionalServiceDAOFilter configures pagination filter.
func WithCarrierAdditionalServiceDAOFilter(filter func(*CarrierAdditionalServiceDAOQuery) (*CarrierAdditionalServiceDAOQuery, error)) CarrierAdditionalServiceDAOPaginateOption {
	return func(pager *carrieradditionalservicedaoPager) error {
		if filter == nil {
			return errors.New("CarrierAdditionalServiceDAOQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrieradditionalservicedaoPager struct {
	reverse bool
	order   *CarrierAdditionalServiceDAOOrder
	filter  func(*CarrierAdditionalServiceDAOQuery) (*CarrierAdditionalServiceDAOQuery, error)
}

func newCarrierAdditionalServiceDAOPager(opts []CarrierAdditionalServiceDAOPaginateOption, reverse bool) (*carrieradditionalservicedaoPager, error) {
	pager := &carrieradditionalservicedaoPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierAdditionalServiceDAOOrder
	}
	return pager, nil
}

func (p *carrieradditionalservicedaoPager) applyFilter(query *CarrierAdditionalServiceDAOQuery) (*CarrierAdditionalServiceDAOQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrieradditionalservicedaoPager) toCursor(casd *CarrierAdditionalServiceDAO) Cursor {
	return p.order.Field.toCursor(casd)
}

func (p *carrieradditionalservicedaoPager) applyCursors(query *CarrierAdditionalServiceDAOQuery, after, before *Cursor) (*CarrierAdditionalServiceDAOQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierAdditionalServiceDAOOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrieradditionalservicedaoPager) applyOrder(query *CarrierAdditionalServiceDAOQuery) *CarrierAdditionalServiceDAOQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierAdditionalServiceDAOOrder.Field {
		query = query.Order(DefaultCarrierAdditionalServiceDAOOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrieradditionalservicedaoPager) orderExpr(query *CarrierAdditionalServiceDAOQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierAdditionalServiceDAOOrder.Field {
			b.Comma().Ident(DefaultCarrierAdditionalServiceDAOOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierAdditionalServiceDAO.
func (casd *CarrierAdditionalServiceDAOQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierAdditionalServiceDAOPaginateOption,
) (*CarrierAdditionalServiceDAOConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierAdditionalServiceDAOPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if casd, err = pager.applyFilter(casd); err != nil {
		return nil, err
	}
	conn := &CarrierAdditionalServiceDAOConnection{Edges: []*CarrierAdditionalServiceDAOEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := casd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if casd, err = pager.applyCursors(casd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		casd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := casd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	casd = pager.applyOrder(casd)
	nodes, err := casd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierAdditionalServiceDAOOrderField defines the ordering field of CarrierAdditionalServiceDAO.
type CarrierAdditionalServiceDAOOrderField struct {
	// Value extracts the ordering value from the given CarrierAdditionalServiceDAO.
	Value    func(*CarrierAdditionalServiceDAO) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrieradditionalservicedao.OrderOption
	toCursor func(*CarrierAdditionalServiceDAO) Cursor
}

// CarrierAdditionalServiceDAOOrder defines the ordering of CarrierAdditionalServiceDAO.
type CarrierAdditionalServiceDAOOrder struct {
	Direction OrderDirection                         `json:"direction"`
	Field     *CarrierAdditionalServiceDAOOrderField `json:"field"`
}

// DefaultCarrierAdditionalServiceDAOOrder is the default ordering of CarrierAdditionalServiceDAO.
var DefaultCarrierAdditionalServiceDAOOrder = &CarrierAdditionalServiceDAOOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierAdditionalServiceDAOOrderField{
		Value: func(casd *CarrierAdditionalServiceDAO) (ent.Value, error) {
			return casd.ID, nil
		},
		column: carrieradditionalservicedao.FieldID,
		toTerm: carrieradditionalservicedao.ByID,
		toCursor: func(casd *CarrierAdditionalServiceDAO) Cursor {
			return Cursor{ID: casd.ID}
		},
	},
}

// ToEdge converts CarrierAdditionalServiceDAO into CarrierAdditionalServiceDAOEdge.
func (casd *CarrierAdditionalServiceDAO) ToEdge(order *CarrierAdditionalServiceDAOOrder) *CarrierAdditionalServiceDAOEdge {
	if order == nil {
		order = DefaultCarrierAdditionalServiceDAOOrder
	}
	return &CarrierAdditionalServiceDAOEdge{
		Node:   casd,
		Cursor: order.Field.toCursor(casd),
	}
}

// CarrierAdditionalServiceDFEdge is the edge representation of CarrierAdditionalServiceDF.
type CarrierAdditionalServiceDFEdge struct {
	Node   *CarrierAdditionalServiceDF `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// CarrierAdditionalServiceDFConnection is the connection containing edges to CarrierAdditionalServiceDF.
type CarrierAdditionalServiceDFConnection struct {
	Edges      []*CarrierAdditionalServiceDFEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *CarrierAdditionalServiceDFConnection) build(nodes []*CarrierAdditionalServiceDF, pager *carrieradditionalservicedfPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierAdditionalServiceDF
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierAdditionalServiceDF {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierAdditionalServiceDF {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierAdditionalServiceDFEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierAdditionalServiceDFEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierAdditionalServiceDFPaginateOption enables pagination customization.
type CarrierAdditionalServiceDFPaginateOption func(*carrieradditionalservicedfPager) error

// WithCarrierAdditionalServiceDFOrder configures pagination ordering.
func WithCarrierAdditionalServiceDFOrder(order *CarrierAdditionalServiceDFOrder) CarrierAdditionalServiceDFPaginateOption {
	if order == nil {
		order = DefaultCarrierAdditionalServiceDFOrder
	}
	o := *order
	return func(pager *carrieradditionalservicedfPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierAdditionalServiceDFOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierAdditionalServiceDFFilter configures pagination filter.
func WithCarrierAdditionalServiceDFFilter(filter func(*CarrierAdditionalServiceDFQuery) (*CarrierAdditionalServiceDFQuery, error)) CarrierAdditionalServiceDFPaginateOption {
	return func(pager *carrieradditionalservicedfPager) error {
		if filter == nil {
			return errors.New("CarrierAdditionalServiceDFQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrieradditionalservicedfPager struct {
	reverse bool
	order   *CarrierAdditionalServiceDFOrder
	filter  func(*CarrierAdditionalServiceDFQuery) (*CarrierAdditionalServiceDFQuery, error)
}

func newCarrierAdditionalServiceDFPager(opts []CarrierAdditionalServiceDFPaginateOption, reverse bool) (*carrieradditionalservicedfPager, error) {
	pager := &carrieradditionalservicedfPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierAdditionalServiceDFOrder
	}
	return pager, nil
}

func (p *carrieradditionalservicedfPager) applyFilter(query *CarrierAdditionalServiceDFQuery) (*CarrierAdditionalServiceDFQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrieradditionalservicedfPager) toCursor(casd *CarrierAdditionalServiceDF) Cursor {
	return p.order.Field.toCursor(casd)
}

func (p *carrieradditionalservicedfPager) applyCursors(query *CarrierAdditionalServiceDFQuery, after, before *Cursor) (*CarrierAdditionalServiceDFQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierAdditionalServiceDFOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrieradditionalservicedfPager) applyOrder(query *CarrierAdditionalServiceDFQuery) *CarrierAdditionalServiceDFQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierAdditionalServiceDFOrder.Field {
		query = query.Order(DefaultCarrierAdditionalServiceDFOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrieradditionalservicedfPager) orderExpr(query *CarrierAdditionalServiceDFQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierAdditionalServiceDFOrder.Field {
			b.Comma().Ident(DefaultCarrierAdditionalServiceDFOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierAdditionalServiceDF.
func (casd *CarrierAdditionalServiceDFQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierAdditionalServiceDFPaginateOption,
) (*CarrierAdditionalServiceDFConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierAdditionalServiceDFPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if casd, err = pager.applyFilter(casd); err != nil {
		return nil, err
	}
	conn := &CarrierAdditionalServiceDFConnection{Edges: []*CarrierAdditionalServiceDFEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := casd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if casd, err = pager.applyCursors(casd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		casd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := casd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	casd = pager.applyOrder(casd)
	nodes, err := casd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierAdditionalServiceDFOrderField defines the ordering field of CarrierAdditionalServiceDF.
type CarrierAdditionalServiceDFOrderField struct {
	// Value extracts the ordering value from the given CarrierAdditionalServiceDF.
	Value    func(*CarrierAdditionalServiceDF) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrieradditionalservicedf.OrderOption
	toCursor func(*CarrierAdditionalServiceDF) Cursor
}

// CarrierAdditionalServiceDFOrder defines the ordering of CarrierAdditionalServiceDF.
type CarrierAdditionalServiceDFOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *CarrierAdditionalServiceDFOrderField `json:"field"`
}

// DefaultCarrierAdditionalServiceDFOrder is the default ordering of CarrierAdditionalServiceDF.
var DefaultCarrierAdditionalServiceDFOrder = &CarrierAdditionalServiceDFOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierAdditionalServiceDFOrderField{
		Value: func(casd *CarrierAdditionalServiceDF) (ent.Value, error) {
			return casd.ID, nil
		},
		column: carrieradditionalservicedf.FieldID,
		toTerm: carrieradditionalservicedf.ByID,
		toCursor: func(casd *CarrierAdditionalServiceDF) Cursor {
			return Cursor{ID: casd.ID}
		},
	},
}

// ToEdge converts CarrierAdditionalServiceDF into CarrierAdditionalServiceDFEdge.
func (casd *CarrierAdditionalServiceDF) ToEdge(order *CarrierAdditionalServiceDFOrder) *CarrierAdditionalServiceDFEdge {
	if order == nil {
		order = DefaultCarrierAdditionalServiceDFOrder
	}
	return &CarrierAdditionalServiceDFEdge{
		Node:   casd,
		Cursor: order.Field.toCursor(casd),
	}
}

// CarrierAdditionalServiceDSVEdge is the edge representation of CarrierAdditionalServiceDSV.
type CarrierAdditionalServiceDSVEdge struct {
	Node   *CarrierAdditionalServiceDSV `json:"node"`
	Cursor Cursor                       `json:"cursor"`
}

// CarrierAdditionalServiceDSVConnection is the connection containing edges to CarrierAdditionalServiceDSV.
type CarrierAdditionalServiceDSVConnection struct {
	Edges      []*CarrierAdditionalServiceDSVEdge `json:"edges"`
	PageInfo   PageInfo                           `json:"pageInfo"`
	TotalCount int                                `json:"totalCount"`
}

func (c *CarrierAdditionalServiceDSVConnection) build(nodes []*CarrierAdditionalServiceDSV, pager *carrieradditionalservicedsvPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierAdditionalServiceDSV
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierAdditionalServiceDSV {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierAdditionalServiceDSV {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierAdditionalServiceDSVEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierAdditionalServiceDSVEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierAdditionalServiceDSVPaginateOption enables pagination customization.
type CarrierAdditionalServiceDSVPaginateOption func(*carrieradditionalservicedsvPager) error

// WithCarrierAdditionalServiceDSVOrder configures pagination ordering.
func WithCarrierAdditionalServiceDSVOrder(order *CarrierAdditionalServiceDSVOrder) CarrierAdditionalServiceDSVPaginateOption {
	if order == nil {
		order = DefaultCarrierAdditionalServiceDSVOrder
	}
	o := *order
	return func(pager *carrieradditionalservicedsvPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierAdditionalServiceDSVOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierAdditionalServiceDSVFilter configures pagination filter.
func WithCarrierAdditionalServiceDSVFilter(filter func(*CarrierAdditionalServiceDSVQuery) (*CarrierAdditionalServiceDSVQuery, error)) CarrierAdditionalServiceDSVPaginateOption {
	return func(pager *carrieradditionalservicedsvPager) error {
		if filter == nil {
			return errors.New("CarrierAdditionalServiceDSVQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrieradditionalservicedsvPager struct {
	reverse bool
	order   *CarrierAdditionalServiceDSVOrder
	filter  func(*CarrierAdditionalServiceDSVQuery) (*CarrierAdditionalServiceDSVQuery, error)
}

func newCarrierAdditionalServiceDSVPager(opts []CarrierAdditionalServiceDSVPaginateOption, reverse bool) (*carrieradditionalservicedsvPager, error) {
	pager := &carrieradditionalservicedsvPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierAdditionalServiceDSVOrder
	}
	return pager, nil
}

func (p *carrieradditionalservicedsvPager) applyFilter(query *CarrierAdditionalServiceDSVQuery) (*CarrierAdditionalServiceDSVQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrieradditionalservicedsvPager) toCursor(casd *CarrierAdditionalServiceDSV) Cursor {
	return p.order.Field.toCursor(casd)
}

func (p *carrieradditionalservicedsvPager) applyCursors(query *CarrierAdditionalServiceDSVQuery, after, before *Cursor) (*CarrierAdditionalServiceDSVQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierAdditionalServiceDSVOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrieradditionalservicedsvPager) applyOrder(query *CarrierAdditionalServiceDSVQuery) *CarrierAdditionalServiceDSVQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierAdditionalServiceDSVOrder.Field {
		query = query.Order(DefaultCarrierAdditionalServiceDSVOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrieradditionalservicedsvPager) orderExpr(query *CarrierAdditionalServiceDSVQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierAdditionalServiceDSVOrder.Field {
			b.Comma().Ident(DefaultCarrierAdditionalServiceDSVOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierAdditionalServiceDSV.
func (casd *CarrierAdditionalServiceDSVQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierAdditionalServiceDSVPaginateOption,
) (*CarrierAdditionalServiceDSVConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierAdditionalServiceDSVPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if casd, err = pager.applyFilter(casd); err != nil {
		return nil, err
	}
	conn := &CarrierAdditionalServiceDSVConnection{Edges: []*CarrierAdditionalServiceDSVEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := casd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if casd, err = pager.applyCursors(casd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		casd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := casd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	casd = pager.applyOrder(casd)
	nodes, err := casd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierAdditionalServiceDSVOrderField defines the ordering field of CarrierAdditionalServiceDSV.
type CarrierAdditionalServiceDSVOrderField struct {
	// Value extracts the ordering value from the given CarrierAdditionalServiceDSV.
	Value    func(*CarrierAdditionalServiceDSV) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrieradditionalservicedsv.OrderOption
	toCursor func(*CarrierAdditionalServiceDSV) Cursor
}

// CarrierAdditionalServiceDSVOrder defines the ordering of CarrierAdditionalServiceDSV.
type CarrierAdditionalServiceDSVOrder struct {
	Direction OrderDirection                         `json:"direction"`
	Field     *CarrierAdditionalServiceDSVOrderField `json:"field"`
}

// DefaultCarrierAdditionalServiceDSVOrder is the default ordering of CarrierAdditionalServiceDSV.
var DefaultCarrierAdditionalServiceDSVOrder = &CarrierAdditionalServiceDSVOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierAdditionalServiceDSVOrderField{
		Value: func(casd *CarrierAdditionalServiceDSV) (ent.Value, error) {
			return casd.ID, nil
		},
		column: carrieradditionalservicedsv.FieldID,
		toTerm: carrieradditionalservicedsv.ByID,
		toCursor: func(casd *CarrierAdditionalServiceDSV) Cursor {
			return Cursor{ID: casd.ID}
		},
	},
}

// ToEdge converts CarrierAdditionalServiceDSV into CarrierAdditionalServiceDSVEdge.
func (casd *CarrierAdditionalServiceDSV) ToEdge(order *CarrierAdditionalServiceDSVOrder) *CarrierAdditionalServiceDSVEdge {
	if order == nil {
		order = DefaultCarrierAdditionalServiceDSVOrder
	}
	return &CarrierAdditionalServiceDSVEdge{
		Node:   casd,
		Cursor: order.Field.toCursor(casd),
	}
}

// CarrierAdditionalServiceEasyPostEdge is the edge representation of CarrierAdditionalServiceEasyPost.
type CarrierAdditionalServiceEasyPostEdge struct {
	Node   *CarrierAdditionalServiceEasyPost `json:"node"`
	Cursor Cursor                            `json:"cursor"`
}

// CarrierAdditionalServiceEasyPostConnection is the connection containing edges to CarrierAdditionalServiceEasyPost.
type CarrierAdditionalServiceEasyPostConnection struct {
	Edges      []*CarrierAdditionalServiceEasyPostEdge `json:"edges"`
	PageInfo   PageInfo                                `json:"pageInfo"`
	TotalCount int                                     `json:"totalCount"`
}

func (c *CarrierAdditionalServiceEasyPostConnection) build(nodes []*CarrierAdditionalServiceEasyPost, pager *carrieradditionalserviceeasypostPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierAdditionalServiceEasyPost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierAdditionalServiceEasyPost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierAdditionalServiceEasyPost {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierAdditionalServiceEasyPostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierAdditionalServiceEasyPostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierAdditionalServiceEasyPostPaginateOption enables pagination customization.
type CarrierAdditionalServiceEasyPostPaginateOption func(*carrieradditionalserviceeasypostPager) error

// WithCarrierAdditionalServiceEasyPostOrder configures pagination ordering.
func WithCarrierAdditionalServiceEasyPostOrder(order *CarrierAdditionalServiceEasyPostOrder) CarrierAdditionalServiceEasyPostPaginateOption {
	if order == nil {
		order = DefaultCarrierAdditionalServiceEasyPostOrder
	}
	o := *order
	return func(pager *carrieradditionalserviceeasypostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierAdditionalServiceEasyPostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierAdditionalServiceEasyPostFilter configures pagination filter.
func WithCarrierAdditionalServiceEasyPostFilter(filter func(*CarrierAdditionalServiceEasyPostQuery) (*CarrierAdditionalServiceEasyPostQuery, error)) CarrierAdditionalServiceEasyPostPaginateOption {
	return func(pager *carrieradditionalserviceeasypostPager) error {
		if filter == nil {
			return errors.New("CarrierAdditionalServiceEasyPostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrieradditionalserviceeasypostPager struct {
	reverse bool
	order   *CarrierAdditionalServiceEasyPostOrder
	filter  func(*CarrierAdditionalServiceEasyPostQuery) (*CarrierAdditionalServiceEasyPostQuery, error)
}

func newCarrierAdditionalServiceEasyPostPager(opts []CarrierAdditionalServiceEasyPostPaginateOption, reverse bool) (*carrieradditionalserviceeasypostPager, error) {
	pager := &carrieradditionalserviceeasypostPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierAdditionalServiceEasyPostOrder
	}
	return pager, nil
}

func (p *carrieradditionalserviceeasypostPager) applyFilter(query *CarrierAdditionalServiceEasyPostQuery) (*CarrierAdditionalServiceEasyPostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrieradditionalserviceeasypostPager) toCursor(casep *CarrierAdditionalServiceEasyPost) Cursor {
	return p.order.Field.toCursor(casep)
}

func (p *carrieradditionalserviceeasypostPager) applyCursors(query *CarrierAdditionalServiceEasyPostQuery, after, before *Cursor) (*CarrierAdditionalServiceEasyPostQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierAdditionalServiceEasyPostOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrieradditionalserviceeasypostPager) applyOrder(query *CarrierAdditionalServiceEasyPostQuery) *CarrierAdditionalServiceEasyPostQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierAdditionalServiceEasyPostOrder.Field {
		query = query.Order(DefaultCarrierAdditionalServiceEasyPostOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrieradditionalserviceeasypostPager) orderExpr(query *CarrierAdditionalServiceEasyPostQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierAdditionalServiceEasyPostOrder.Field {
			b.Comma().Ident(DefaultCarrierAdditionalServiceEasyPostOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierAdditionalServiceEasyPost.
func (casep *CarrierAdditionalServiceEasyPostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierAdditionalServiceEasyPostPaginateOption,
) (*CarrierAdditionalServiceEasyPostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierAdditionalServiceEasyPostPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if casep, err = pager.applyFilter(casep); err != nil {
		return nil, err
	}
	conn := &CarrierAdditionalServiceEasyPostConnection{Edges: []*CarrierAdditionalServiceEasyPostEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := casep.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if casep, err = pager.applyCursors(casep, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		casep.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := casep.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	casep = pager.applyOrder(casep)
	nodes, err := casep.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierAdditionalServiceEasyPostOrderField defines the ordering field of CarrierAdditionalServiceEasyPost.
type CarrierAdditionalServiceEasyPostOrderField struct {
	// Value extracts the ordering value from the given CarrierAdditionalServiceEasyPost.
	Value    func(*CarrierAdditionalServiceEasyPost) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrieradditionalserviceeasypost.OrderOption
	toCursor func(*CarrierAdditionalServiceEasyPost) Cursor
}

// CarrierAdditionalServiceEasyPostOrder defines the ordering of CarrierAdditionalServiceEasyPost.
type CarrierAdditionalServiceEasyPostOrder struct {
	Direction OrderDirection                              `json:"direction"`
	Field     *CarrierAdditionalServiceEasyPostOrderField `json:"field"`
}

// DefaultCarrierAdditionalServiceEasyPostOrder is the default ordering of CarrierAdditionalServiceEasyPost.
var DefaultCarrierAdditionalServiceEasyPostOrder = &CarrierAdditionalServiceEasyPostOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierAdditionalServiceEasyPostOrderField{
		Value: func(casep *CarrierAdditionalServiceEasyPost) (ent.Value, error) {
			return casep.ID, nil
		},
		column: carrieradditionalserviceeasypost.FieldID,
		toTerm: carrieradditionalserviceeasypost.ByID,
		toCursor: func(casep *CarrierAdditionalServiceEasyPost) Cursor {
			return Cursor{ID: casep.ID}
		},
	},
}

// ToEdge converts CarrierAdditionalServiceEasyPost into CarrierAdditionalServiceEasyPostEdge.
func (casep *CarrierAdditionalServiceEasyPost) ToEdge(order *CarrierAdditionalServiceEasyPostOrder) *CarrierAdditionalServiceEasyPostEdge {
	if order == nil {
		order = DefaultCarrierAdditionalServiceEasyPostOrder
	}
	return &CarrierAdditionalServiceEasyPostEdge{
		Node:   casep,
		Cursor: order.Field.toCursor(casep),
	}
}

// CarrierAdditionalServiceGLSEdge is the edge representation of CarrierAdditionalServiceGLS.
type CarrierAdditionalServiceGLSEdge struct {
	Node   *CarrierAdditionalServiceGLS `json:"node"`
	Cursor Cursor                       `json:"cursor"`
}

// CarrierAdditionalServiceGLSConnection is the connection containing edges to CarrierAdditionalServiceGLS.
type CarrierAdditionalServiceGLSConnection struct {
	Edges      []*CarrierAdditionalServiceGLSEdge `json:"edges"`
	PageInfo   PageInfo                           `json:"pageInfo"`
	TotalCount int                                `json:"totalCount"`
}

func (c *CarrierAdditionalServiceGLSConnection) build(nodes []*CarrierAdditionalServiceGLS, pager *carrieradditionalserviceglsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierAdditionalServiceGLS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierAdditionalServiceGLS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierAdditionalServiceGLS {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierAdditionalServiceGLSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierAdditionalServiceGLSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierAdditionalServiceGLSPaginateOption enables pagination customization.
type CarrierAdditionalServiceGLSPaginateOption func(*carrieradditionalserviceglsPager) error

// WithCarrierAdditionalServiceGLSOrder configures pagination ordering.
func WithCarrierAdditionalServiceGLSOrder(order *CarrierAdditionalServiceGLSOrder) CarrierAdditionalServiceGLSPaginateOption {
	if order == nil {
		order = DefaultCarrierAdditionalServiceGLSOrder
	}
	o := *order
	return func(pager *carrieradditionalserviceglsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierAdditionalServiceGLSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierAdditionalServiceGLSFilter configures pagination filter.
func WithCarrierAdditionalServiceGLSFilter(filter func(*CarrierAdditionalServiceGLSQuery) (*CarrierAdditionalServiceGLSQuery, error)) CarrierAdditionalServiceGLSPaginateOption {
	return func(pager *carrieradditionalserviceglsPager) error {
		if filter == nil {
			return errors.New("CarrierAdditionalServiceGLSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrieradditionalserviceglsPager struct {
	reverse bool
	order   *CarrierAdditionalServiceGLSOrder
	filter  func(*CarrierAdditionalServiceGLSQuery) (*CarrierAdditionalServiceGLSQuery, error)
}

func newCarrierAdditionalServiceGLSPager(opts []CarrierAdditionalServiceGLSPaginateOption, reverse bool) (*carrieradditionalserviceglsPager, error) {
	pager := &carrieradditionalserviceglsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierAdditionalServiceGLSOrder
	}
	return pager, nil
}

func (p *carrieradditionalserviceglsPager) applyFilter(query *CarrierAdditionalServiceGLSQuery) (*CarrierAdditionalServiceGLSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrieradditionalserviceglsPager) toCursor(casg *CarrierAdditionalServiceGLS) Cursor {
	return p.order.Field.toCursor(casg)
}

func (p *carrieradditionalserviceglsPager) applyCursors(query *CarrierAdditionalServiceGLSQuery, after, before *Cursor) (*CarrierAdditionalServiceGLSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierAdditionalServiceGLSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrieradditionalserviceglsPager) applyOrder(query *CarrierAdditionalServiceGLSQuery) *CarrierAdditionalServiceGLSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierAdditionalServiceGLSOrder.Field {
		query = query.Order(DefaultCarrierAdditionalServiceGLSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrieradditionalserviceglsPager) orderExpr(query *CarrierAdditionalServiceGLSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierAdditionalServiceGLSOrder.Field {
			b.Comma().Ident(DefaultCarrierAdditionalServiceGLSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierAdditionalServiceGLS.
func (casg *CarrierAdditionalServiceGLSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierAdditionalServiceGLSPaginateOption,
) (*CarrierAdditionalServiceGLSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierAdditionalServiceGLSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if casg, err = pager.applyFilter(casg); err != nil {
		return nil, err
	}
	conn := &CarrierAdditionalServiceGLSConnection{Edges: []*CarrierAdditionalServiceGLSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := casg.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if casg, err = pager.applyCursors(casg, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		casg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := casg.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	casg = pager.applyOrder(casg)
	nodes, err := casg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierAdditionalServiceGLSOrderField defines the ordering field of CarrierAdditionalServiceGLS.
type CarrierAdditionalServiceGLSOrderField struct {
	// Value extracts the ordering value from the given CarrierAdditionalServiceGLS.
	Value    func(*CarrierAdditionalServiceGLS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrieradditionalservicegls.OrderOption
	toCursor func(*CarrierAdditionalServiceGLS) Cursor
}

// CarrierAdditionalServiceGLSOrder defines the ordering of CarrierAdditionalServiceGLS.
type CarrierAdditionalServiceGLSOrder struct {
	Direction OrderDirection                         `json:"direction"`
	Field     *CarrierAdditionalServiceGLSOrderField `json:"field"`
}

// DefaultCarrierAdditionalServiceGLSOrder is the default ordering of CarrierAdditionalServiceGLS.
var DefaultCarrierAdditionalServiceGLSOrder = &CarrierAdditionalServiceGLSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierAdditionalServiceGLSOrderField{
		Value: func(casg *CarrierAdditionalServiceGLS) (ent.Value, error) {
			return casg.ID, nil
		},
		column: carrieradditionalservicegls.FieldID,
		toTerm: carrieradditionalservicegls.ByID,
		toCursor: func(casg *CarrierAdditionalServiceGLS) Cursor {
			return Cursor{ID: casg.ID}
		},
	},
}

// ToEdge converts CarrierAdditionalServiceGLS into CarrierAdditionalServiceGLSEdge.
func (casg *CarrierAdditionalServiceGLS) ToEdge(order *CarrierAdditionalServiceGLSOrder) *CarrierAdditionalServiceGLSEdge {
	if order == nil {
		order = DefaultCarrierAdditionalServiceGLSOrder
	}
	return &CarrierAdditionalServiceGLSEdge{
		Node:   casg,
		Cursor: order.Field.toCursor(casg),
	}
}

// CarrierAdditionalServicePostNordEdge is the edge representation of CarrierAdditionalServicePostNord.
type CarrierAdditionalServicePostNordEdge struct {
	Node   *CarrierAdditionalServicePostNord `json:"node"`
	Cursor Cursor                            `json:"cursor"`
}

// CarrierAdditionalServicePostNordConnection is the connection containing edges to CarrierAdditionalServicePostNord.
type CarrierAdditionalServicePostNordConnection struct {
	Edges      []*CarrierAdditionalServicePostNordEdge `json:"edges"`
	PageInfo   PageInfo                                `json:"pageInfo"`
	TotalCount int                                     `json:"totalCount"`
}

func (c *CarrierAdditionalServicePostNordConnection) build(nodes []*CarrierAdditionalServicePostNord, pager *carrieradditionalservicepostnordPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierAdditionalServicePostNord
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierAdditionalServicePostNord {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierAdditionalServicePostNord {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierAdditionalServicePostNordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierAdditionalServicePostNordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierAdditionalServicePostNordPaginateOption enables pagination customization.
type CarrierAdditionalServicePostNordPaginateOption func(*carrieradditionalservicepostnordPager) error

// WithCarrierAdditionalServicePostNordOrder configures pagination ordering.
func WithCarrierAdditionalServicePostNordOrder(order *CarrierAdditionalServicePostNordOrder) CarrierAdditionalServicePostNordPaginateOption {
	if order == nil {
		order = DefaultCarrierAdditionalServicePostNordOrder
	}
	o := *order
	return func(pager *carrieradditionalservicepostnordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierAdditionalServicePostNordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierAdditionalServicePostNordFilter configures pagination filter.
func WithCarrierAdditionalServicePostNordFilter(filter func(*CarrierAdditionalServicePostNordQuery) (*CarrierAdditionalServicePostNordQuery, error)) CarrierAdditionalServicePostNordPaginateOption {
	return func(pager *carrieradditionalservicepostnordPager) error {
		if filter == nil {
			return errors.New("CarrierAdditionalServicePostNordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrieradditionalservicepostnordPager struct {
	reverse bool
	order   *CarrierAdditionalServicePostNordOrder
	filter  func(*CarrierAdditionalServicePostNordQuery) (*CarrierAdditionalServicePostNordQuery, error)
}

func newCarrierAdditionalServicePostNordPager(opts []CarrierAdditionalServicePostNordPaginateOption, reverse bool) (*carrieradditionalservicepostnordPager, error) {
	pager := &carrieradditionalservicepostnordPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierAdditionalServicePostNordOrder
	}
	return pager, nil
}

func (p *carrieradditionalservicepostnordPager) applyFilter(query *CarrierAdditionalServicePostNordQuery) (*CarrierAdditionalServicePostNordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrieradditionalservicepostnordPager) toCursor(caspn *CarrierAdditionalServicePostNord) Cursor {
	return p.order.Field.toCursor(caspn)
}

func (p *carrieradditionalservicepostnordPager) applyCursors(query *CarrierAdditionalServicePostNordQuery, after, before *Cursor) (*CarrierAdditionalServicePostNordQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierAdditionalServicePostNordOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrieradditionalservicepostnordPager) applyOrder(query *CarrierAdditionalServicePostNordQuery) *CarrierAdditionalServicePostNordQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierAdditionalServicePostNordOrder.Field {
		query = query.Order(DefaultCarrierAdditionalServicePostNordOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrieradditionalservicepostnordPager) orderExpr(query *CarrierAdditionalServicePostNordQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierAdditionalServicePostNordOrder.Field {
			b.Comma().Ident(DefaultCarrierAdditionalServicePostNordOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierAdditionalServicePostNord.
func (caspn *CarrierAdditionalServicePostNordQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierAdditionalServicePostNordPaginateOption,
) (*CarrierAdditionalServicePostNordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierAdditionalServicePostNordPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if caspn, err = pager.applyFilter(caspn); err != nil {
		return nil, err
	}
	conn := &CarrierAdditionalServicePostNordConnection{Edges: []*CarrierAdditionalServicePostNordEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := caspn.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if caspn, err = pager.applyCursors(caspn, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		caspn.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := caspn.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	caspn = pager.applyOrder(caspn)
	nodes, err := caspn.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierAdditionalServicePostNordOrderField defines the ordering field of CarrierAdditionalServicePostNord.
type CarrierAdditionalServicePostNordOrderField struct {
	// Value extracts the ordering value from the given CarrierAdditionalServicePostNord.
	Value    func(*CarrierAdditionalServicePostNord) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrieradditionalservicepostnord.OrderOption
	toCursor func(*CarrierAdditionalServicePostNord) Cursor
}

// CarrierAdditionalServicePostNordOrder defines the ordering of CarrierAdditionalServicePostNord.
type CarrierAdditionalServicePostNordOrder struct {
	Direction OrderDirection                              `json:"direction"`
	Field     *CarrierAdditionalServicePostNordOrderField `json:"field"`
}

// DefaultCarrierAdditionalServicePostNordOrder is the default ordering of CarrierAdditionalServicePostNord.
var DefaultCarrierAdditionalServicePostNordOrder = &CarrierAdditionalServicePostNordOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierAdditionalServicePostNordOrderField{
		Value: func(caspn *CarrierAdditionalServicePostNord) (ent.Value, error) {
			return caspn.ID, nil
		},
		column: carrieradditionalservicepostnord.FieldID,
		toTerm: carrieradditionalservicepostnord.ByID,
		toCursor: func(caspn *CarrierAdditionalServicePostNord) Cursor {
			return Cursor{ID: caspn.ID}
		},
	},
}

// ToEdge converts CarrierAdditionalServicePostNord into CarrierAdditionalServicePostNordEdge.
func (caspn *CarrierAdditionalServicePostNord) ToEdge(order *CarrierAdditionalServicePostNordOrder) *CarrierAdditionalServicePostNordEdge {
	if order == nil {
		order = DefaultCarrierAdditionalServicePostNordOrder
	}
	return &CarrierAdditionalServicePostNordEdge{
		Node:   caspn,
		Cursor: order.Field.toCursor(caspn),
	}
}

// CarrierAdditionalServiceUSPSEdge is the edge representation of CarrierAdditionalServiceUSPS.
type CarrierAdditionalServiceUSPSEdge struct {
	Node   *CarrierAdditionalServiceUSPS `json:"node"`
	Cursor Cursor                        `json:"cursor"`
}

// CarrierAdditionalServiceUSPSConnection is the connection containing edges to CarrierAdditionalServiceUSPS.
type CarrierAdditionalServiceUSPSConnection struct {
	Edges      []*CarrierAdditionalServiceUSPSEdge `json:"edges"`
	PageInfo   PageInfo                            `json:"pageInfo"`
	TotalCount int                                 `json:"totalCount"`
}

func (c *CarrierAdditionalServiceUSPSConnection) build(nodes []*CarrierAdditionalServiceUSPS, pager *carrieradditionalserviceuspsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierAdditionalServiceUSPS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierAdditionalServiceUSPS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierAdditionalServiceUSPS {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierAdditionalServiceUSPSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierAdditionalServiceUSPSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierAdditionalServiceUSPSPaginateOption enables pagination customization.
type CarrierAdditionalServiceUSPSPaginateOption func(*carrieradditionalserviceuspsPager) error

// WithCarrierAdditionalServiceUSPSOrder configures pagination ordering.
func WithCarrierAdditionalServiceUSPSOrder(order *CarrierAdditionalServiceUSPSOrder) CarrierAdditionalServiceUSPSPaginateOption {
	if order == nil {
		order = DefaultCarrierAdditionalServiceUSPSOrder
	}
	o := *order
	return func(pager *carrieradditionalserviceuspsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierAdditionalServiceUSPSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierAdditionalServiceUSPSFilter configures pagination filter.
func WithCarrierAdditionalServiceUSPSFilter(filter func(*CarrierAdditionalServiceUSPSQuery) (*CarrierAdditionalServiceUSPSQuery, error)) CarrierAdditionalServiceUSPSPaginateOption {
	return func(pager *carrieradditionalserviceuspsPager) error {
		if filter == nil {
			return errors.New("CarrierAdditionalServiceUSPSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrieradditionalserviceuspsPager struct {
	reverse bool
	order   *CarrierAdditionalServiceUSPSOrder
	filter  func(*CarrierAdditionalServiceUSPSQuery) (*CarrierAdditionalServiceUSPSQuery, error)
}

func newCarrierAdditionalServiceUSPSPager(opts []CarrierAdditionalServiceUSPSPaginateOption, reverse bool) (*carrieradditionalserviceuspsPager, error) {
	pager := &carrieradditionalserviceuspsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierAdditionalServiceUSPSOrder
	}
	return pager, nil
}

func (p *carrieradditionalserviceuspsPager) applyFilter(query *CarrierAdditionalServiceUSPSQuery) (*CarrierAdditionalServiceUSPSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrieradditionalserviceuspsPager) toCursor(casu *CarrierAdditionalServiceUSPS) Cursor {
	return p.order.Field.toCursor(casu)
}

func (p *carrieradditionalserviceuspsPager) applyCursors(query *CarrierAdditionalServiceUSPSQuery, after, before *Cursor) (*CarrierAdditionalServiceUSPSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierAdditionalServiceUSPSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrieradditionalserviceuspsPager) applyOrder(query *CarrierAdditionalServiceUSPSQuery) *CarrierAdditionalServiceUSPSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierAdditionalServiceUSPSOrder.Field {
		query = query.Order(DefaultCarrierAdditionalServiceUSPSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrieradditionalserviceuspsPager) orderExpr(query *CarrierAdditionalServiceUSPSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierAdditionalServiceUSPSOrder.Field {
			b.Comma().Ident(DefaultCarrierAdditionalServiceUSPSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierAdditionalServiceUSPS.
func (casu *CarrierAdditionalServiceUSPSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierAdditionalServiceUSPSPaginateOption,
) (*CarrierAdditionalServiceUSPSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierAdditionalServiceUSPSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if casu, err = pager.applyFilter(casu); err != nil {
		return nil, err
	}
	conn := &CarrierAdditionalServiceUSPSConnection{Edges: []*CarrierAdditionalServiceUSPSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := casu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if casu, err = pager.applyCursors(casu, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		casu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := casu.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	casu = pager.applyOrder(casu)
	nodes, err := casu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierAdditionalServiceUSPSOrderField defines the ordering field of CarrierAdditionalServiceUSPS.
type CarrierAdditionalServiceUSPSOrderField struct {
	// Value extracts the ordering value from the given CarrierAdditionalServiceUSPS.
	Value    func(*CarrierAdditionalServiceUSPS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrieradditionalserviceusps.OrderOption
	toCursor func(*CarrierAdditionalServiceUSPS) Cursor
}

// CarrierAdditionalServiceUSPSOrder defines the ordering of CarrierAdditionalServiceUSPS.
type CarrierAdditionalServiceUSPSOrder struct {
	Direction OrderDirection                          `json:"direction"`
	Field     *CarrierAdditionalServiceUSPSOrderField `json:"field"`
}

// DefaultCarrierAdditionalServiceUSPSOrder is the default ordering of CarrierAdditionalServiceUSPS.
var DefaultCarrierAdditionalServiceUSPSOrder = &CarrierAdditionalServiceUSPSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierAdditionalServiceUSPSOrderField{
		Value: func(casu *CarrierAdditionalServiceUSPS) (ent.Value, error) {
			return casu.ID, nil
		},
		column: carrieradditionalserviceusps.FieldID,
		toTerm: carrieradditionalserviceusps.ByID,
		toCursor: func(casu *CarrierAdditionalServiceUSPS) Cursor {
			return Cursor{ID: casu.ID}
		},
	},
}

// ToEdge converts CarrierAdditionalServiceUSPS into CarrierAdditionalServiceUSPSEdge.
func (casu *CarrierAdditionalServiceUSPS) ToEdge(order *CarrierAdditionalServiceUSPSOrder) *CarrierAdditionalServiceUSPSEdge {
	if order == nil {
		order = DefaultCarrierAdditionalServiceUSPSOrder
	}
	return &CarrierAdditionalServiceUSPSEdge{
		Node:   casu,
		Cursor: order.Field.toCursor(casu),
	}
}

// CarrierBrandEdge is the edge representation of CarrierBrand.
type CarrierBrandEdge struct {
	Node   *CarrierBrand `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// CarrierBrandConnection is the connection containing edges to CarrierBrand.
type CarrierBrandConnection struct {
	Edges      []*CarrierBrandEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *CarrierBrandConnection) build(nodes []*CarrierBrand, pager *carrierbrandPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierBrand
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierBrand {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierBrand {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierBrandEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierBrandEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierBrandPaginateOption enables pagination customization.
type CarrierBrandPaginateOption func(*carrierbrandPager) error

// WithCarrierBrandOrder configures pagination ordering.
func WithCarrierBrandOrder(order *CarrierBrandOrder) CarrierBrandPaginateOption {
	if order == nil {
		order = DefaultCarrierBrandOrder
	}
	o := *order
	return func(pager *carrierbrandPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierBrandOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierBrandFilter configures pagination filter.
func WithCarrierBrandFilter(filter func(*CarrierBrandQuery) (*CarrierBrandQuery, error)) CarrierBrandPaginateOption {
	return func(pager *carrierbrandPager) error {
		if filter == nil {
			return errors.New("CarrierBrandQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierbrandPager struct {
	reverse bool
	order   *CarrierBrandOrder
	filter  func(*CarrierBrandQuery) (*CarrierBrandQuery, error)
}

func newCarrierBrandPager(opts []CarrierBrandPaginateOption, reverse bool) (*carrierbrandPager, error) {
	pager := &carrierbrandPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierBrandOrder
	}
	return pager, nil
}

func (p *carrierbrandPager) applyFilter(query *CarrierBrandQuery) (*CarrierBrandQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierbrandPager) toCursor(cb *CarrierBrand) Cursor {
	return p.order.Field.toCursor(cb)
}

func (p *carrierbrandPager) applyCursors(query *CarrierBrandQuery, after, before *Cursor) (*CarrierBrandQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierBrandOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierbrandPager) applyOrder(query *CarrierBrandQuery) *CarrierBrandQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierBrandOrder.Field {
		query = query.Order(DefaultCarrierBrandOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierbrandPager) orderExpr(query *CarrierBrandQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierBrandOrder.Field {
			b.Comma().Ident(DefaultCarrierBrandOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierBrand.
func (cb *CarrierBrandQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierBrandPaginateOption,
) (*CarrierBrandConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierBrandPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cb, err = pager.applyFilter(cb); err != nil {
		return nil, err
	}
	conn := &CarrierBrandConnection{Edges: []*CarrierBrandEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cb.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cb, err = pager.applyCursors(cb, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cb.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cb = pager.applyOrder(cb)
	nodes, err := cb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierBrandOrderField defines the ordering field of CarrierBrand.
type CarrierBrandOrderField struct {
	// Value extracts the ordering value from the given CarrierBrand.
	Value    func(*CarrierBrand) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierbrand.OrderOption
	toCursor func(*CarrierBrand) Cursor
}

// CarrierBrandOrder defines the ordering of CarrierBrand.
type CarrierBrandOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *CarrierBrandOrderField `json:"field"`
}

// DefaultCarrierBrandOrder is the default ordering of CarrierBrand.
var DefaultCarrierBrandOrder = &CarrierBrandOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierBrandOrderField{
		Value: func(cb *CarrierBrand) (ent.Value, error) {
			return cb.ID, nil
		},
		column: carrierbrand.FieldID,
		toTerm: carrierbrand.ByID,
		toCursor: func(cb *CarrierBrand) Cursor {
			return Cursor{ID: cb.ID}
		},
	},
}

// ToEdge converts CarrierBrand into CarrierBrandEdge.
func (cb *CarrierBrand) ToEdge(order *CarrierBrandOrder) *CarrierBrandEdge {
	if order == nil {
		order = DefaultCarrierBrandOrder
	}
	return &CarrierBrandEdge{
		Node:   cb,
		Cursor: order.Field.toCursor(cb),
	}
}

// CarrierBringEdge is the edge representation of CarrierBring.
type CarrierBringEdge struct {
	Node   *CarrierBring `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// CarrierBringConnection is the connection containing edges to CarrierBring.
type CarrierBringConnection struct {
	Edges      []*CarrierBringEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *CarrierBringConnection) build(nodes []*CarrierBring, pager *carrierbringPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierBring
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierBring {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierBring {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierBringEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierBringEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierBringPaginateOption enables pagination customization.
type CarrierBringPaginateOption func(*carrierbringPager) error

// WithCarrierBringOrder configures pagination ordering.
func WithCarrierBringOrder(order *CarrierBringOrder) CarrierBringPaginateOption {
	if order == nil {
		order = DefaultCarrierBringOrder
	}
	o := *order
	return func(pager *carrierbringPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierBringOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierBringFilter configures pagination filter.
func WithCarrierBringFilter(filter func(*CarrierBringQuery) (*CarrierBringQuery, error)) CarrierBringPaginateOption {
	return func(pager *carrierbringPager) error {
		if filter == nil {
			return errors.New("CarrierBringQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierbringPager struct {
	reverse bool
	order   *CarrierBringOrder
	filter  func(*CarrierBringQuery) (*CarrierBringQuery, error)
}

func newCarrierBringPager(opts []CarrierBringPaginateOption, reverse bool) (*carrierbringPager, error) {
	pager := &carrierbringPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierBringOrder
	}
	return pager, nil
}

func (p *carrierbringPager) applyFilter(query *CarrierBringQuery) (*CarrierBringQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierbringPager) toCursor(cb *CarrierBring) Cursor {
	return p.order.Field.toCursor(cb)
}

func (p *carrierbringPager) applyCursors(query *CarrierBringQuery, after, before *Cursor) (*CarrierBringQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierBringOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierbringPager) applyOrder(query *CarrierBringQuery) *CarrierBringQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierBringOrder.Field {
		query = query.Order(DefaultCarrierBringOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierbringPager) orderExpr(query *CarrierBringQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierBringOrder.Field {
			b.Comma().Ident(DefaultCarrierBringOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierBring.
func (cb *CarrierBringQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierBringPaginateOption,
) (*CarrierBringConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierBringPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cb, err = pager.applyFilter(cb); err != nil {
		return nil, err
	}
	conn := &CarrierBringConnection{Edges: []*CarrierBringEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cb.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cb, err = pager.applyCursors(cb, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cb.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cb = pager.applyOrder(cb)
	nodes, err := cb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierBringOrderField defines the ordering field of CarrierBring.
type CarrierBringOrderField struct {
	// Value extracts the ordering value from the given CarrierBring.
	Value    func(*CarrierBring) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierbring.OrderOption
	toCursor func(*CarrierBring) Cursor
}

// CarrierBringOrder defines the ordering of CarrierBring.
type CarrierBringOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *CarrierBringOrderField `json:"field"`
}

// DefaultCarrierBringOrder is the default ordering of CarrierBring.
var DefaultCarrierBringOrder = &CarrierBringOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierBringOrderField{
		Value: func(cb *CarrierBring) (ent.Value, error) {
			return cb.ID, nil
		},
		column: carrierbring.FieldID,
		toTerm: carrierbring.ByID,
		toCursor: func(cb *CarrierBring) Cursor {
			return Cursor{ID: cb.ID}
		},
	},
}

// ToEdge converts CarrierBring into CarrierBringEdge.
func (cb *CarrierBring) ToEdge(order *CarrierBringOrder) *CarrierBringEdge {
	if order == nil {
		order = DefaultCarrierBringOrder
	}
	return &CarrierBringEdge{
		Node:   cb,
		Cursor: order.Field.toCursor(cb),
	}
}

// CarrierDAOEdge is the edge representation of CarrierDAO.
type CarrierDAOEdge struct {
	Node   *CarrierDAO `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// CarrierDAOConnection is the connection containing edges to CarrierDAO.
type CarrierDAOConnection struct {
	Edges      []*CarrierDAOEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *CarrierDAOConnection) build(nodes []*CarrierDAO, pager *carrierdaoPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierDAO
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierDAO {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierDAO {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierDAOEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierDAOEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierDAOPaginateOption enables pagination customization.
type CarrierDAOPaginateOption func(*carrierdaoPager) error

// WithCarrierDAOOrder configures pagination ordering.
func WithCarrierDAOOrder(order *CarrierDAOOrder) CarrierDAOPaginateOption {
	if order == nil {
		order = DefaultCarrierDAOOrder
	}
	o := *order
	return func(pager *carrierdaoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierDAOOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierDAOFilter configures pagination filter.
func WithCarrierDAOFilter(filter func(*CarrierDAOQuery) (*CarrierDAOQuery, error)) CarrierDAOPaginateOption {
	return func(pager *carrierdaoPager) error {
		if filter == nil {
			return errors.New("CarrierDAOQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierdaoPager struct {
	reverse bool
	order   *CarrierDAOOrder
	filter  func(*CarrierDAOQuery) (*CarrierDAOQuery, error)
}

func newCarrierDAOPager(opts []CarrierDAOPaginateOption, reverse bool) (*carrierdaoPager, error) {
	pager := &carrierdaoPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierDAOOrder
	}
	return pager, nil
}

func (p *carrierdaoPager) applyFilter(query *CarrierDAOQuery) (*CarrierDAOQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierdaoPager) toCursor(cd *CarrierDAO) Cursor {
	return p.order.Field.toCursor(cd)
}

func (p *carrierdaoPager) applyCursors(query *CarrierDAOQuery, after, before *Cursor) (*CarrierDAOQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierDAOOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierdaoPager) applyOrder(query *CarrierDAOQuery) *CarrierDAOQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierDAOOrder.Field {
		query = query.Order(DefaultCarrierDAOOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierdaoPager) orderExpr(query *CarrierDAOQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierDAOOrder.Field {
			b.Comma().Ident(DefaultCarrierDAOOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierDAO.
func (cd *CarrierDAOQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierDAOPaginateOption,
) (*CarrierDAOConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierDAOPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cd, err = pager.applyFilter(cd); err != nil {
		return nil, err
	}
	conn := &CarrierDAOConnection{Edges: []*CarrierDAOEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cd, err = pager.applyCursors(cd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cd = pager.applyOrder(cd)
	nodes, err := cd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierDAOOrderField defines the ordering field of CarrierDAO.
type CarrierDAOOrderField struct {
	// Value extracts the ordering value from the given CarrierDAO.
	Value    func(*CarrierDAO) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierdao.OrderOption
	toCursor func(*CarrierDAO) Cursor
}

// CarrierDAOOrder defines the ordering of CarrierDAO.
type CarrierDAOOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *CarrierDAOOrderField `json:"field"`
}

// DefaultCarrierDAOOrder is the default ordering of CarrierDAO.
var DefaultCarrierDAOOrder = &CarrierDAOOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierDAOOrderField{
		Value: func(cd *CarrierDAO) (ent.Value, error) {
			return cd.ID, nil
		},
		column: carrierdao.FieldID,
		toTerm: carrierdao.ByID,
		toCursor: func(cd *CarrierDAO) Cursor {
			return Cursor{ID: cd.ID}
		},
	},
}

// ToEdge converts CarrierDAO into CarrierDAOEdge.
func (cd *CarrierDAO) ToEdge(order *CarrierDAOOrder) *CarrierDAOEdge {
	if order == nil {
		order = DefaultCarrierDAOOrder
	}
	return &CarrierDAOEdge{
		Node:   cd,
		Cursor: order.Field.toCursor(cd),
	}
}

// CarrierDFEdge is the edge representation of CarrierDF.
type CarrierDFEdge struct {
	Node   *CarrierDF `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// CarrierDFConnection is the connection containing edges to CarrierDF.
type CarrierDFConnection struct {
	Edges      []*CarrierDFEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *CarrierDFConnection) build(nodes []*CarrierDF, pager *carrierdfPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierDF
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierDF {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierDF {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierDFEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierDFEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierDFPaginateOption enables pagination customization.
type CarrierDFPaginateOption func(*carrierdfPager) error

// WithCarrierDFOrder configures pagination ordering.
func WithCarrierDFOrder(order *CarrierDFOrder) CarrierDFPaginateOption {
	if order == nil {
		order = DefaultCarrierDFOrder
	}
	o := *order
	return func(pager *carrierdfPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierDFOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierDFFilter configures pagination filter.
func WithCarrierDFFilter(filter func(*CarrierDFQuery) (*CarrierDFQuery, error)) CarrierDFPaginateOption {
	return func(pager *carrierdfPager) error {
		if filter == nil {
			return errors.New("CarrierDFQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierdfPager struct {
	reverse bool
	order   *CarrierDFOrder
	filter  func(*CarrierDFQuery) (*CarrierDFQuery, error)
}

func newCarrierDFPager(opts []CarrierDFPaginateOption, reverse bool) (*carrierdfPager, error) {
	pager := &carrierdfPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierDFOrder
	}
	return pager, nil
}

func (p *carrierdfPager) applyFilter(query *CarrierDFQuery) (*CarrierDFQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierdfPager) toCursor(cd *CarrierDF) Cursor {
	return p.order.Field.toCursor(cd)
}

func (p *carrierdfPager) applyCursors(query *CarrierDFQuery, after, before *Cursor) (*CarrierDFQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierDFOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierdfPager) applyOrder(query *CarrierDFQuery) *CarrierDFQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierDFOrder.Field {
		query = query.Order(DefaultCarrierDFOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierdfPager) orderExpr(query *CarrierDFQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierDFOrder.Field {
			b.Comma().Ident(DefaultCarrierDFOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierDF.
func (cd *CarrierDFQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierDFPaginateOption,
) (*CarrierDFConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierDFPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cd, err = pager.applyFilter(cd); err != nil {
		return nil, err
	}
	conn := &CarrierDFConnection{Edges: []*CarrierDFEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cd, err = pager.applyCursors(cd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cd = pager.applyOrder(cd)
	nodes, err := cd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierDFOrderField defines the ordering field of CarrierDF.
type CarrierDFOrderField struct {
	// Value extracts the ordering value from the given CarrierDF.
	Value    func(*CarrierDF) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierdf.OrderOption
	toCursor func(*CarrierDF) Cursor
}

// CarrierDFOrder defines the ordering of CarrierDF.
type CarrierDFOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *CarrierDFOrderField `json:"field"`
}

// DefaultCarrierDFOrder is the default ordering of CarrierDF.
var DefaultCarrierDFOrder = &CarrierDFOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierDFOrderField{
		Value: func(cd *CarrierDF) (ent.Value, error) {
			return cd.ID, nil
		},
		column: carrierdf.FieldID,
		toTerm: carrierdf.ByID,
		toCursor: func(cd *CarrierDF) Cursor {
			return Cursor{ID: cd.ID}
		},
	},
}

// ToEdge converts CarrierDF into CarrierDFEdge.
func (cd *CarrierDF) ToEdge(order *CarrierDFOrder) *CarrierDFEdge {
	if order == nil {
		order = DefaultCarrierDFOrder
	}
	return &CarrierDFEdge{
		Node:   cd,
		Cursor: order.Field.toCursor(cd),
	}
}

// CarrierDSVEdge is the edge representation of CarrierDSV.
type CarrierDSVEdge struct {
	Node   *CarrierDSV `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// CarrierDSVConnection is the connection containing edges to CarrierDSV.
type CarrierDSVConnection struct {
	Edges      []*CarrierDSVEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *CarrierDSVConnection) build(nodes []*CarrierDSV, pager *carrierdsvPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierDSV
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierDSV {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierDSV {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierDSVEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierDSVEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierDSVPaginateOption enables pagination customization.
type CarrierDSVPaginateOption func(*carrierdsvPager) error

// WithCarrierDSVOrder configures pagination ordering.
func WithCarrierDSVOrder(order *CarrierDSVOrder) CarrierDSVPaginateOption {
	if order == nil {
		order = DefaultCarrierDSVOrder
	}
	o := *order
	return func(pager *carrierdsvPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierDSVOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierDSVFilter configures pagination filter.
func WithCarrierDSVFilter(filter func(*CarrierDSVQuery) (*CarrierDSVQuery, error)) CarrierDSVPaginateOption {
	return func(pager *carrierdsvPager) error {
		if filter == nil {
			return errors.New("CarrierDSVQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierdsvPager struct {
	reverse bool
	order   *CarrierDSVOrder
	filter  func(*CarrierDSVQuery) (*CarrierDSVQuery, error)
}

func newCarrierDSVPager(opts []CarrierDSVPaginateOption, reverse bool) (*carrierdsvPager, error) {
	pager := &carrierdsvPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierDSVOrder
	}
	return pager, nil
}

func (p *carrierdsvPager) applyFilter(query *CarrierDSVQuery) (*CarrierDSVQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierdsvPager) toCursor(cd *CarrierDSV) Cursor {
	return p.order.Field.toCursor(cd)
}

func (p *carrierdsvPager) applyCursors(query *CarrierDSVQuery, after, before *Cursor) (*CarrierDSVQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierDSVOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierdsvPager) applyOrder(query *CarrierDSVQuery) *CarrierDSVQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierDSVOrder.Field {
		query = query.Order(DefaultCarrierDSVOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierdsvPager) orderExpr(query *CarrierDSVQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierDSVOrder.Field {
			b.Comma().Ident(DefaultCarrierDSVOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierDSV.
func (cd *CarrierDSVQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierDSVPaginateOption,
) (*CarrierDSVConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierDSVPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cd, err = pager.applyFilter(cd); err != nil {
		return nil, err
	}
	conn := &CarrierDSVConnection{Edges: []*CarrierDSVEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cd, err = pager.applyCursors(cd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cd = pager.applyOrder(cd)
	nodes, err := cd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierDSVOrderField defines the ordering field of CarrierDSV.
type CarrierDSVOrderField struct {
	// Value extracts the ordering value from the given CarrierDSV.
	Value    func(*CarrierDSV) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierdsv.OrderOption
	toCursor func(*CarrierDSV) Cursor
}

// CarrierDSVOrder defines the ordering of CarrierDSV.
type CarrierDSVOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *CarrierDSVOrderField `json:"field"`
}

// DefaultCarrierDSVOrder is the default ordering of CarrierDSV.
var DefaultCarrierDSVOrder = &CarrierDSVOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierDSVOrderField{
		Value: func(cd *CarrierDSV) (ent.Value, error) {
			return cd.ID, nil
		},
		column: carrierdsv.FieldID,
		toTerm: carrierdsv.ByID,
		toCursor: func(cd *CarrierDSV) Cursor {
			return Cursor{ID: cd.ID}
		},
	},
}

// ToEdge converts CarrierDSV into CarrierDSVEdge.
func (cd *CarrierDSV) ToEdge(order *CarrierDSVOrder) *CarrierDSVEdge {
	if order == nil {
		order = DefaultCarrierDSVOrder
	}
	return &CarrierDSVEdge{
		Node:   cd,
		Cursor: order.Field.toCursor(cd),
	}
}

// CarrierEasyPostEdge is the edge representation of CarrierEasyPost.
type CarrierEasyPostEdge struct {
	Node   *CarrierEasyPost `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CarrierEasyPostConnection is the connection containing edges to CarrierEasyPost.
type CarrierEasyPostConnection struct {
	Edges      []*CarrierEasyPostEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *CarrierEasyPostConnection) build(nodes []*CarrierEasyPost, pager *carriereasypostPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierEasyPost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierEasyPost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierEasyPost {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierEasyPostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierEasyPostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierEasyPostPaginateOption enables pagination customization.
type CarrierEasyPostPaginateOption func(*carriereasypostPager) error

// WithCarrierEasyPostOrder configures pagination ordering.
func WithCarrierEasyPostOrder(order *CarrierEasyPostOrder) CarrierEasyPostPaginateOption {
	if order == nil {
		order = DefaultCarrierEasyPostOrder
	}
	o := *order
	return func(pager *carriereasypostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierEasyPostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierEasyPostFilter configures pagination filter.
func WithCarrierEasyPostFilter(filter func(*CarrierEasyPostQuery) (*CarrierEasyPostQuery, error)) CarrierEasyPostPaginateOption {
	return func(pager *carriereasypostPager) error {
		if filter == nil {
			return errors.New("CarrierEasyPostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carriereasypostPager struct {
	reverse bool
	order   *CarrierEasyPostOrder
	filter  func(*CarrierEasyPostQuery) (*CarrierEasyPostQuery, error)
}

func newCarrierEasyPostPager(opts []CarrierEasyPostPaginateOption, reverse bool) (*carriereasypostPager, error) {
	pager := &carriereasypostPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierEasyPostOrder
	}
	return pager, nil
}

func (p *carriereasypostPager) applyFilter(query *CarrierEasyPostQuery) (*CarrierEasyPostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carriereasypostPager) toCursor(cep *CarrierEasyPost) Cursor {
	return p.order.Field.toCursor(cep)
}

func (p *carriereasypostPager) applyCursors(query *CarrierEasyPostQuery, after, before *Cursor) (*CarrierEasyPostQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierEasyPostOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carriereasypostPager) applyOrder(query *CarrierEasyPostQuery) *CarrierEasyPostQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierEasyPostOrder.Field {
		query = query.Order(DefaultCarrierEasyPostOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carriereasypostPager) orderExpr(query *CarrierEasyPostQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierEasyPostOrder.Field {
			b.Comma().Ident(DefaultCarrierEasyPostOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierEasyPost.
func (cep *CarrierEasyPostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierEasyPostPaginateOption,
) (*CarrierEasyPostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierEasyPostPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cep, err = pager.applyFilter(cep); err != nil {
		return nil, err
	}
	conn := &CarrierEasyPostConnection{Edges: []*CarrierEasyPostEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cep.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cep, err = pager.applyCursors(cep, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cep.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cep.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cep = pager.applyOrder(cep)
	nodes, err := cep.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierEasyPostOrderField defines the ordering field of CarrierEasyPost.
type CarrierEasyPostOrderField struct {
	// Value extracts the ordering value from the given CarrierEasyPost.
	Value    func(*CarrierEasyPost) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carriereasypost.OrderOption
	toCursor func(*CarrierEasyPost) Cursor
}

// CarrierEasyPostOrder defines the ordering of CarrierEasyPost.
type CarrierEasyPostOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CarrierEasyPostOrderField `json:"field"`
}

// DefaultCarrierEasyPostOrder is the default ordering of CarrierEasyPost.
var DefaultCarrierEasyPostOrder = &CarrierEasyPostOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierEasyPostOrderField{
		Value: func(cep *CarrierEasyPost) (ent.Value, error) {
			return cep.ID, nil
		},
		column: carriereasypost.FieldID,
		toTerm: carriereasypost.ByID,
		toCursor: func(cep *CarrierEasyPost) Cursor {
			return Cursor{ID: cep.ID}
		},
	},
}

// ToEdge converts CarrierEasyPost into CarrierEasyPostEdge.
func (cep *CarrierEasyPost) ToEdge(order *CarrierEasyPostOrder) *CarrierEasyPostEdge {
	if order == nil {
		order = DefaultCarrierEasyPostOrder
	}
	return &CarrierEasyPostEdge{
		Node:   cep,
		Cursor: order.Field.toCursor(cep),
	}
}

// CarrierGLSEdge is the edge representation of CarrierGLS.
type CarrierGLSEdge struct {
	Node   *CarrierGLS `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// CarrierGLSConnection is the connection containing edges to CarrierGLS.
type CarrierGLSConnection struct {
	Edges      []*CarrierGLSEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *CarrierGLSConnection) build(nodes []*CarrierGLS, pager *carrierglsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierGLS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierGLS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierGLS {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierGLSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierGLSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierGLSPaginateOption enables pagination customization.
type CarrierGLSPaginateOption func(*carrierglsPager) error

// WithCarrierGLSOrder configures pagination ordering.
func WithCarrierGLSOrder(order *CarrierGLSOrder) CarrierGLSPaginateOption {
	if order == nil {
		order = DefaultCarrierGLSOrder
	}
	o := *order
	return func(pager *carrierglsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierGLSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierGLSFilter configures pagination filter.
func WithCarrierGLSFilter(filter func(*CarrierGLSQuery) (*CarrierGLSQuery, error)) CarrierGLSPaginateOption {
	return func(pager *carrierglsPager) error {
		if filter == nil {
			return errors.New("CarrierGLSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierglsPager struct {
	reverse bool
	order   *CarrierGLSOrder
	filter  func(*CarrierGLSQuery) (*CarrierGLSQuery, error)
}

func newCarrierGLSPager(opts []CarrierGLSPaginateOption, reverse bool) (*carrierglsPager, error) {
	pager := &carrierglsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierGLSOrder
	}
	return pager, nil
}

func (p *carrierglsPager) applyFilter(query *CarrierGLSQuery) (*CarrierGLSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierglsPager) toCursor(cg *CarrierGLS) Cursor {
	return p.order.Field.toCursor(cg)
}

func (p *carrierglsPager) applyCursors(query *CarrierGLSQuery, after, before *Cursor) (*CarrierGLSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierGLSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierglsPager) applyOrder(query *CarrierGLSQuery) *CarrierGLSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierGLSOrder.Field {
		query = query.Order(DefaultCarrierGLSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierglsPager) orderExpr(query *CarrierGLSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierGLSOrder.Field {
			b.Comma().Ident(DefaultCarrierGLSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierGLS.
func (cg *CarrierGLSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierGLSPaginateOption,
) (*CarrierGLSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierGLSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cg, err = pager.applyFilter(cg); err != nil {
		return nil, err
	}
	conn := &CarrierGLSConnection{Edges: []*CarrierGLSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cg.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cg, err = pager.applyCursors(cg, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cg.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cg = pager.applyOrder(cg)
	nodes, err := cg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierGLSOrderField defines the ordering field of CarrierGLS.
type CarrierGLSOrderField struct {
	// Value extracts the ordering value from the given CarrierGLS.
	Value    func(*CarrierGLS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carriergls.OrderOption
	toCursor func(*CarrierGLS) Cursor
}

// CarrierGLSOrder defines the ordering of CarrierGLS.
type CarrierGLSOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *CarrierGLSOrderField `json:"field"`
}

// DefaultCarrierGLSOrder is the default ordering of CarrierGLS.
var DefaultCarrierGLSOrder = &CarrierGLSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierGLSOrderField{
		Value: func(cg *CarrierGLS) (ent.Value, error) {
			return cg.ID, nil
		},
		column: carriergls.FieldID,
		toTerm: carriergls.ByID,
		toCursor: func(cg *CarrierGLS) Cursor {
			return Cursor{ID: cg.ID}
		},
	},
}

// ToEdge converts CarrierGLS into CarrierGLSEdge.
func (cg *CarrierGLS) ToEdge(order *CarrierGLSOrder) *CarrierGLSEdge {
	if order == nil {
		order = DefaultCarrierGLSOrder
	}
	return &CarrierGLSEdge{
		Node:   cg,
		Cursor: order.Field.toCursor(cg),
	}
}

// CarrierPostNordEdge is the edge representation of CarrierPostNord.
type CarrierPostNordEdge struct {
	Node   *CarrierPostNord `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// CarrierPostNordConnection is the connection containing edges to CarrierPostNord.
type CarrierPostNordConnection struct {
	Edges      []*CarrierPostNordEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *CarrierPostNordConnection) build(nodes []*CarrierPostNord, pager *carrierpostnordPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierPostNord
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierPostNord {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierPostNord {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierPostNordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierPostNordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierPostNordPaginateOption enables pagination customization.
type CarrierPostNordPaginateOption func(*carrierpostnordPager) error

// WithCarrierPostNordOrder configures pagination ordering.
func WithCarrierPostNordOrder(order *CarrierPostNordOrder) CarrierPostNordPaginateOption {
	if order == nil {
		order = DefaultCarrierPostNordOrder
	}
	o := *order
	return func(pager *carrierpostnordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierPostNordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierPostNordFilter configures pagination filter.
func WithCarrierPostNordFilter(filter func(*CarrierPostNordQuery) (*CarrierPostNordQuery, error)) CarrierPostNordPaginateOption {
	return func(pager *carrierpostnordPager) error {
		if filter == nil {
			return errors.New("CarrierPostNordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierpostnordPager struct {
	reverse bool
	order   *CarrierPostNordOrder
	filter  func(*CarrierPostNordQuery) (*CarrierPostNordQuery, error)
}

func newCarrierPostNordPager(opts []CarrierPostNordPaginateOption, reverse bool) (*carrierpostnordPager, error) {
	pager := &carrierpostnordPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierPostNordOrder
	}
	return pager, nil
}

func (p *carrierpostnordPager) applyFilter(query *CarrierPostNordQuery) (*CarrierPostNordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierpostnordPager) toCursor(cpn *CarrierPostNord) Cursor {
	return p.order.Field.toCursor(cpn)
}

func (p *carrierpostnordPager) applyCursors(query *CarrierPostNordQuery, after, before *Cursor) (*CarrierPostNordQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierPostNordOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierpostnordPager) applyOrder(query *CarrierPostNordQuery) *CarrierPostNordQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierPostNordOrder.Field {
		query = query.Order(DefaultCarrierPostNordOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierpostnordPager) orderExpr(query *CarrierPostNordQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierPostNordOrder.Field {
			b.Comma().Ident(DefaultCarrierPostNordOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierPostNord.
func (cpn *CarrierPostNordQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierPostNordPaginateOption,
) (*CarrierPostNordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierPostNordPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cpn, err = pager.applyFilter(cpn); err != nil {
		return nil, err
	}
	conn := &CarrierPostNordConnection{Edges: []*CarrierPostNordEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cpn.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cpn, err = pager.applyCursors(cpn, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cpn.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cpn.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cpn = pager.applyOrder(cpn)
	nodes, err := cpn.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierPostNordOrderField defines the ordering field of CarrierPostNord.
type CarrierPostNordOrderField struct {
	// Value extracts the ordering value from the given CarrierPostNord.
	Value    func(*CarrierPostNord) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierpostnord.OrderOption
	toCursor func(*CarrierPostNord) Cursor
}

// CarrierPostNordOrder defines the ordering of CarrierPostNord.
type CarrierPostNordOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *CarrierPostNordOrderField `json:"field"`
}

// DefaultCarrierPostNordOrder is the default ordering of CarrierPostNord.
var DefaultCarrierPostNordOrder = &CarrierPostNordOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierPostNordOrderField{
		Value: func(cpn *CarrierPostNord) (ent.Value, error) {
			return cpn.ID, nil
		},
		column: carrierpostnord.FieldID,
		toTerm: carrierpostnord.ByID,
		toCursor: func(cpn *CarrierPostNord) Cursor {
			return Cursor{ID: cpn.ID}
		},
	},
}

// ToEdge converts CarrierPostNord into CarrierPostNordEdge.
func (cpn *CarrierPostNord) ToEdge(order *CarrierPostNordOrder) *CarrierPostNordEdge {
	if order == nil {
		order = DefaultCarrierPostNordOrder
	}
	return &CarrierPostNordEdge{
		Node:   cpn,
		Cursor: order.Field.toCursor(cpn),
	}
}

// CarrierServiceEdge is the edge representation of CarrierService.
type CarrierServiceEdge struct {
	Node   *CarrierService `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// CarrierServiceConnection is the connection containing edges to CarrierService.
type CarrierServiceConnection struct {
	Edges      []*CarrierServiceEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *CarrierServiceConnection) build(nodes []*CarrierService, pager *carrierservicePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierService
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierService {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierService {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierServiceEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierServiceEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierServicePaginateOption enables pagination customization.
type CarrierServicePaginateOption func(*carrierservicePager) error

// WithCarrierServiceOrder configures pagination ordering.
func WithCarrierServiceOrder(order *CarrierServiceOrder) CarrierServicePaginateOption {
	if order == nil {
		order = DefaultCarrierServiceOrder
	}
	o := *order
	return func(pager *carrierservicePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierServiceOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierServiceFilter configures pagination filter.
func WithCarrierServiceFilter(filter func(*CarrierServiceQuery) (*CarrierServiceQuery, error)) CarrierServicePaginateOption {
	return func(pager *carrierservicePager) error {
		if filter == nil {
			return errors.New("CarrierServiceQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierservicePager struct {
	reverse bool
	order   *CarrierServiceOrder
	filter  func(*CarrierServiceQuery) (*CarrierServiceQuery, error)
}

func newCarrierServicePager(opts []CarrierServicePaginateOption, reverse bool) (*carrierservicePager, error) {
	pager := &carrierservicePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierServiceOrder
	}
	return pager, nil
}

func (p *carrierservicePager) applyFilter(query *CarrierServiceQuery) (*CarrierServiceQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierservicePager) toCursor(cs *CarrierService) Cursor {
	return p.order.Field.toCursor(cs)
}

func (p *carrierservicePager) applyCursors(query *CarrierServiceQuery, after, before *Cursor) (*CarrierServiceQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierServiceOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierservicePager) applyOrder(query *CarrierServiceQuery) *CarrierServiceQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierServiceOrder.Field {
		query = query.Order(DefaultCarrierServiceOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierservicePager) orderExpr(query *CarrierServiceQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierServiceOrder.Field {
			b.Comma().Ident(DefaultCarrierServiceOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierService.
func (cs *CarrierServiceQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierServicePaginateOption,
) (*CarrierServiceConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierServicePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cs, err = pager.applyFilter(cs); err != nil {
		return nil, err
	}
	conn := &CarrierServiceConnection{Edges: []*CarrierServiceEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cs.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cs, err = pager.applyCursors(cs, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cs.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cs = pager.applyOrder(cs)
	nodes, err := cs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierServiceOrderField defines the ordering field of CarrierService.
type CarrierServiceOrderField struct {
	// Value extracts the ordering value from the given CarrierService.
	Value    func(*CarrierService) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierservice.OrderOption
	toCursor func(*CarrierService) Cursor
}

// CarrierServiceOrder defines the ordering of CarrierService.
type CarrierServiceOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *CarrierServiceOrderField `json:"field"`
}

// DefaultCarrierServiceOrder is the default ordering of CarrierService.
var DefaultCarrierServiceOrder = &CarrierServiceOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierServiceOrderField{
		Value: func(cs *CarrierService) (ent.Value, error) {
			return cs.ID, nil
		},
		column: carrierservice.FieldID,
		toTerm: carrierservice.ByID,
		toCursor: func(cs *CarrierService) Cursor {
			return Cursor{ID: cs.ID}
		},
	},
}

// ToEdge converts CarrierService into CarrierServiceEdge.
func (cs *CarrierService) ToEdge(order *CarrierServiceOrder) *CarrierServiceEdge {
	if order == nil {
		order = DefaultCarrierServiceOrder
	}
	return &CarrierServiceEdge{
		Node:   cs,
		Cursor: order.Field.toCursor(cs),
	}
}

// CarrierServiceBringEdge is the edge representation of CarrierServiceBring.
type CarrierServiceBringEdge struct {
	Node   *CarrierServiceBring `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// CarrierServiceBringConnection is the connection containing edges to CarrierServiceBring.
type CarrierServiceBringConnection struct {
	Edges      []*CarrierServiceBringEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *CarrierServiceBringConnection) build(nodes []*CarrierServiceBring, pager *carrierservicebringPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierServiceBring
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierServiceBring {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierServiceBring {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierServiceBringEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierServiceBringEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierServiceBringPaginateOption enables pagination customization.
type CarrierServiceBringPaginateOption func(*carrierservicebringPager) error

// WithCarrierServiceBringOrder configures pagination ordering.
func WithCarrierServiceBringOrder(order *CarrierServiceBringOrder) CarrierServiceBringPaginateOption {
	if order == nil {
		order = DefaultCarrierServiceBringOrder
	}
	o := *order
	return func(pager *carrierservicebringPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierServiceBringOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierServiceBringFilter configures pagination filter.
func WithCarrierServiceBringFilter(filter func(*CarrierServiceBringQuery) (*CarrierServiceBringQuery, error)) CarrierServiceBringPaginateOption {
	return func(pager *carrierservicebringPager) error {
		if filter == nil {
			return errors.New("CarrierServiceBringQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierservicebringPager struct {
	reverse bool
	order   *CarrierServiceBringOrder
	filter  func(*CarrierServiceBringQuery) (*CarrierServiceBringQuery, error)
}

func newCarrierServiceBringPager(opts []CarrierServiceBringPaginateOption, reverse bool) (*carrierservicebringPager, error) {
	pager := &carrierservicebringPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierServiceBringOrder
	}
	return pager, nil
}

func (p *carrierservicebringPager) applyFilter(query *CarrierServiceBringQuery) (*CarrierServiceBringQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierservicebringPager) toCursor(csb *CarrierServiceBring) Cursor {
	return p.order.Field.toCursor(csb)
}

func (p *carrierservicebringPager) applyCursors(query *CarrierServiceBringQuery, after, before *Cursor) (*CarrierServiceBringQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierServiceBringOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierservicebringPager) applyOrder(query *CarrierServiceBringQuery) *CarrierServiceBringQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierServiceBringOrder.Field {
		query = query.Order(DefaultCarrierServiceBringOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierservicebringPager) orderExpr(query *CarrierServiceBringQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierServiceBringOrder.Field {
			b.Comma().Ident(DefaultCarrierServiceBringOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierServiceBring.
func (csb *CarrierServiceBringQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierServiceBringPaginateOption,
) (*CarrierServiceBringConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierServiceBringPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if csb, err = pager.applyFilter(csb); err != nil {
		return nil, err
	}
	conn := &CarrierServiceBringConnection{Edges: []*CarrierServiceBringEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := csb.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if csb, err = pager.applyCursors(csb, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		csb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := csb.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	csb = pager.applyOrder(csb)
	nodes, err := csb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierServiceBringOrderField defines the ordering field of CarrierServiceBring.
type CarrierServiceBringOrderField struct {
	// Value extracts the ordering value from the given CarrierServiceBring.
	Value    func(*CarrierServiceBring) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierservicebring.OrderOption
	toCursor func(*CarrierServiceBring) Cursor
}

// CarrierServiceBringOrder defines the ordering of CarrierServiceBring.
type CarrierServiceBringOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *CarrierServiceBringOrderField `json:"field"`
}

// DefaultCarrierServiceBringOrder is the default ordering of CarrierServiceBring.
var DefaultCarrierServiceBringOrder = &CarrierServiceBringOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierServiceBringOrderField{
		Value: func(csb *CarrierServiceBring) (ent.Value, error) {
			return csb.ID, nil
		},
		column: carrierservicebring.FieldID,
		toTerm: carrierservicebring.ByID,
		toCursor: func(csb *CarrierServiceBring) Cursor {
			return Cursor{ID: csb.ID}
		},
	},
}

// ToEdge converts CarrierServiceBring into CarrierServiceBringEdge.
func (csb *CarrierServiceBring) ToEdge(order *CarrierServiceBringOrder) *CarrierServiceBringEdge {
	if order == nil {
		order = DefaultCarrierServiceBringOrder
	}
	return &CarrierServiceBringEdge{
		Node:   csb,
		Cursor: order.Field.toCursor(csb),
	}
}

// CarrierServiceDAOEdge is the edge representation of CarrierServiceDAO.
type CarrierServiceDAOEdge struct {
	Node   *CarrierServiceDAO `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// CarrierServiceDAOConnection is the connection containing edges to CarrierServiceDAO.
type CarrierServiceDAOConnection struct {
	Edges      []*CarrierServiceDAOEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *CarrierServiceDAOConnection) build(nodes []*CarrierServiceDAO, pager *carrierservicedaoPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierServiceDAO
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierServiceDAO {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierServiceDAO {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierServiceDAOEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierServiceDAOEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierServiceDAOPaginateOption enables pagination customization.
type CarrierServiceDAOPaginateOption func(*carrierservicedaoPager) error

// WithCarrierServiceDAOOrder configures pagination ordering.
func WithCarrierServiceDAOOrder(order *CarrierServiceDAOOrder) CarrierServiceDAOPaginateOption {
	if order == nil {
		order = DefaultCarrierServiceDAOOrder
	}
	o := *order
	return func(pager *carrierservicedaoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierServiceDAOOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierServiceDAOFilter configures pagination filter.
func WithCarrierServiceDAOFilter(filter func(*CarrierServiceDAOQuery) (*CarrierServiceDAOQuery, error)) CarrierServiceDAOPaginateOption {
	return func(pager *carrierservicedaoPager) error {
		if filter == nil {
			return errors.New("CarrierServiceDAOQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierservicedaoPager struct {
	reverse bool
	order   *CarrierServiceDAOOrder
	filter  func(*CarrierServiceDAOQuery) (*CarrierServiceDAOQuery, error)
}

func newCarrierServiceDAOPager(opts []CarrierServiceDAOPaginateOption, reverse bool) (*carrierservicedaoPager, error) {
	pager := &carrierservicedaoPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierServiceDAOOrder
	}
	return pager, nil
}

func (p *carrierservicedaoPager) applyFilter(query *CarrierServiceDAOQuery) (*CarrierServiceDAOQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierservicedaoPager) toCursor(csd *CarrierServiceDAO) Cursor {
	return p.order.Field.toCursor(csd)
}

func (p *carrierservicedaoPager) applyCursors(query *CarrierServiceDAOQuery, after, before *Cursor) (*CarrierServiceDAOQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierServiceDAOOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierservicedaoPager) applyOrder(query *CarrierServiceDAOQuery) *CarrierServiceDAOQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierServiceDAOOrder.Field {
		query = query.Order(DefaultCarrierServiceDAOOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierservicedaoPager) orderExpr(query *CarrierServiceDAOQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierServiceDAOOrder.Field {
			b.Comma().Ident(DefaultCarrierServiceDAOOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierServiceDAO.
func (csd *CarrierServiceDAOQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierServiceDAOPaginateOption,
) (*CarrierServiceDAOConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierServiceDAOPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if csd, err = pager.applyFilter(csd); err != nil {
		return nil, err
	}
	conn := &CarrierServiceDAOConnection{Edges: []*CarrierServiceDAOEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := csd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if csd, err = pager.applyCursors(csd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		csd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := csd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	csd = pager.applyOrder(csd)
	nodes, err := csd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierServiceDAOOrderField defines the ordering field of CarrierServiceDAO.
type CarrierServiceDAOOrderField struct {
	// Value extracts the ordering value from the given CarrierServiceDAO.
	Value    func(*CarrierServiceDAO) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierservicedao.OrderOption
	toCursor func(*CarrierServiceDAO) Cursor
}

// CarrierServiceDAOOrder defines the ordering of CarrierServiceDAO.
type CarrierServiceDAOOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *CarrierServiceDAOOrderField `json:"field"`
}

// DefaultCarrierServiceDAOOrder is the default ordering of CarrierServiceDAO.
var DefaultCarrierServiceDAOOrder = &CarrierServiceDAOOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierServiceDAOOrderField{
		Value: func(csd *CarrierServiceDAO) (ent.Value, error) {
			return csd.ID, nil
		},
		column: carrierservicedao.FieldID,
		toTerm: carrierservicedao.ByID,
		toCursor: func(csd *CarrierServiceDAO) Cursor {
			return Cursor{ID: csd.ID}
		},
	},
}

// ToEdge converts CarrierServiceDAO into CarrierServiceDAOEdge.
func (csd *CarrierServiceDAO) ToEdge(order *CarrierServiceDAOOrder) *CarrierServiceDAOEdge {
	if order == nil {
		order = DefaultCarrierServiceDAOOrder
	}
	return &CarrierServiceDAOEdge{
		Node:   csd,
		Cursor: order.Field.toCursor(csd),
	}
}

// CarrierServiceDFEdge is the edge representation of CarrierServiceDF.
type CarrierServiceDFEdge struct {
	Node   *CarrierServiceDF `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// CarrierServiceDFConnection is the connection containing edges to CarrierServiceDF.
type CarrierServiceDFConnection struct {
	Edges      []*CarrierServiceDFEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *CarrierServiceDFConnection) build(nodes []*CarrierServiceDF, pager *carrierservicedfPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierServiceDF
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierServiceDF {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierServiceDF {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierServiceDFEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierServiceDFEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierServiceDFPaginateOption enables pagination customization.
type CarrierServiceDFPaginateOption func(*carrierservicedfPager) error

// WithCarrierServiceDFOrder configures pagination ordering.
func WithCarrierServiceDFOrder(order *CarrierServiceDFOrder) CarrierServiceDFPaginateOption {
	if order == nil {
		order = DefaultCarrierServiceDFOrder
	}
	o := *order
	return func(pager *carrierservicedfPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierServiceDFOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierServiceDFFilter configures pagination filter.
func WithCarrierServiceDFFilter(filter func(*CarrierServiceDFQuery) (*CarrierServiceDFQuery, error)) CarrierServiceDFPaginateOption {
	return func(pager *carrierservicedfPager) error {
		if filter == nil {
			return errors.New("CarrierServiceDFQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierservicedfPager struct {
	reverse bool
	order   *CarrierServiceDFOrder
	filter  func(*CarrierServiceDFQuery) (*CarrierServiceDFQuery, error)
}

func newCarrierServiceDFPager(opts []CarrierServiceDFPaginateOption, reverse bool) (*carrierservicedfPager, error) {
	pager := &carrierservicedfPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierServiceDFOrder
	}
	return pager, nil
}

func (p *carrierservicedfPager) applyFilter(query *CarrierServiceDFQuery) (*CarrierServiceDFQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierservicedfPager) toCursor(csd *CarrierServiceDF) Cursor {
	return p.order.Field.toCursor(csd)
}

func (p *carrierservicedfPager) applyCursors(query *CarrierServiceDFQuery, after, before *Cursor) (*CarrierServiceDFQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierServiceDFOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierservicedfPager) applyOrder(query *CarrierServiceDFQuery) *CarrierServiceDFQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierServiceDFOrder.Field {
		query = query.Order(DefaultCarrierServiceDFOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierservicedfPager) orderExpr(query *CarrierServiceDFQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierServiceDFOrder.Field {
			b.Comma().Ident(DefaultCarrierServiceDFOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierServiceDF.
func (csd *CarrierServiceDFQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierServiceDFPaginateOption,
) (*CarrierServiceDFConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierServiceDFPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if csd, err = pager.applyFilter(csd); err != nil {
		return nil, err
	}
	conn := &CarrierServiceDFConnection{Edges: []*CarrierServiceDFEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := csd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if csd, err = pager.applyCursors(csd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		csd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := csd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	csd = pager.applyOrder(csd)
	nodes, err := csd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierServiceDFOrderField defines the ordering field of CarrierServiceDF.
type CarrierServiceDFOrderField struct {
	// Value extracts the ordering value from the given CarrierServiceDF.
	Value    func(*CarrierServiceDF) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierservicedf.OrderOption
	toCursor func(*CarrierServiceDF) Cursor
}

// CarrierServiceDFOrder defines the ordering of CarrierServiceDF.
type CarrierServiceDFOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *CarrierServiceDFOrderField `json:"field"`
}

// DefaultCarrierServiceDFOrder is the default ordering of CarrierServiceDF.
var DefaultCarrierServiceDFOrder = &CarrierServiceDFOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierServiceDFOrderField{
		Value: func(csd *CarrierServiceDF) (ent.Value, error) {
			return csd.ID, nil
		},
		column: carrierservicedf.FieldID,
		toTerm: carrierservicedf.ByID,
		toCursor: func(csd *CarrierServiceDF) Cursor {
			return Cursor{ID: csd.ID}
		},
	},
}

// ToEdge converts CarrierServiceDF into CarrierServiceDFEdge.
func (csd *CarrierServiceDF) ToEdge(order *CarrierServiceDFOrder) *CarrierServiceDFEdge {
	if order == nil {
		order = DefaultCarrierServiceDFOrder
	}
	return &CarrierServiceDFEdge{
		Node:   csd,
		Cursor: order.Field.toCursor(csd),
	}
}

// CarrierServiceDSVEdge is the edge representation of CarrierServiceDSV.
type CarrierServiceDSVEdge struct {
	Node   *CarrierServiceDSV `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// CarrierServiceDSVConnection is the connection containing edges to CarrierServiceDSV.
type CarrierServiceDSVConnection struct {
	Edges      []*CarrierServiceDSVEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *CarrierServiceDSVConnection) build(nodes []*CarrierServiceDSV, pager *carrierservicedsvPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierServiceDSV
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierServiceDSV {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierServiceDSV {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierServiceDSVEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierServiceDSVEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierServiceDSVPaginateOption enables pagination customization.
type CarrierServiceDSVPaginateOption func(*carrierservicedsvPager) error

// WithCarrierServiceDSVOrder configures pagination ordering.
func WithCarrierServiceDSVOrder(order *CarrierServiceDSVOrder) CarrierServiceDSVPaginateOption {
	if order == nil {
		order = DefaultCarrierServiceDSVOrder
	}
	o := *order
	return func(pager *carrierservicedsvPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierServiceDSVOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierServiceDSVFilter configures pagination filter.
func WithCarrierServiceDSVFilter(filter func(*CarrierServiceDSVQuery) (*CarrierServiceDSVQuery, error)) CarrierServiceDSVPaginateOption {
	return func(pager *carrierservicedsvPager) error {
		if filter == nil {
			return errors.New("CarrierServiceDSVQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierservicedsvPager struct {
	reverse bool
	order   *CarrierServiceDSVOrder
	filter  func(*CarrierServiceDSVQuery) (*CarrierServiceDSVQuery, error)
}

func newCarrierServiceDSVPager(opts []CarrierServiceDSVPaginateOption, reverse bool) (*carrierservicedsvPager, error) {
	pager := &carrierservicedsvPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierServiceDSVOrder
	}
	return pager, nil
}

func (p *carrierservicedsvPager) applyFilter(query *CarrierServiceDSVQuery) (*CarrierServiceDSVQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierservicedsvPager) toCursor(csd *CarrierServiceDSV) Cursor {
	return p.order.Field.toCursor(csd)
}

func (p *carrierservicedsvPager) applyCursors(query *CarrierServiceDSVQuery, after, before *Cursor) (*CarrierServiceDSVQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierServiceDSVOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierservicedsvPager) applyOrder(query *CarrierServiceDSVQuery) *CarrierServiceDSVQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierServiceDSVOrder.Field {
		query = query.Order(DefaultCarrierServiceDSVOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierservicedsvPager) orderExpr(query *CarrierServiceDSVQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierServiceDSVOrder.Field {
			b.Comma().Ident(DefaultCarrierServiceDSVOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierServiceDSV.
func (csd *CarrierServiceDSVQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierServiceDSVPaginateOption,
) (*CarrierServiceDSVConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierServiceDSVPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if csd, err = pager.applyFilter(csd); err != nil {
		return nil, err
	}
	conn := &CarrierServiceDSVConnection{Edges: []*CarrierServiceDSVEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := csd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if csd, err = pager.applyCursors(csd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		csd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := csd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	csd = pager.applyOrder(csd)
	nodes, err := csd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierServiceDSVOrderField defines the ordering field of CarrierServiceDSV.
type CarrierServiceDSVOrderField struct {
	// Value extracts the ordering value from the given CarrierServiceDSV.
	Value    func(*CarrierServiceDSV) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierservicedsv.OrderOption
	toCursor func(*CarrierServiceDSV) Cursor
}

// CarrierServiceDSVOrder defines the ordering of CarrierServiceDSV.
type CarrierServiceDSVOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *CarrierServiceDSVOrderField `json:"field"`
}

// DefaultCarrierServiceDSVOrder is the default ordering of CarrierServiceDSV.
var DefaultCarrierServiceDSVOrder = &CarrierServiceDSVOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierServiceDSVOrderField{
		Value: func(csd *CarrierServiceDSV) (ent.Value, error) {
			return csd.ID, nil
		},
		column: carrierservicedsv.FieldID,
		toTerm: carrierservicedsv.ByID,
		toCursor: func(csd *CarrierServiceDSV) Cursor {
			return Cursor{ID: csd.ID}
		},
	},
}

// ToEdge converts CarrierServiceDSV into CarrierServiceDSVEdge.
func (csd *CarrierServiceDSV) ToEdge(order *CarrierServiceDSVOrder) *CarrierServiceDSVEdge {
	if order == nil {
		order = DefaultCarrierServiceDSVOrder
	}
	return &CarrierServiceDSVEdge{
		Node:   csd,
		Cursor: order.Field.toCursor(csd),
	}
}

// CarrierServiceEasyPostEdge is the edge representation of CarrierServiceEasyPost.
type CarrierServiceEasyPostEdge struct {
	Node   *CarrierServiceEasyPost `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// CarrierServiceEasyPostConnection is the connection containing edges to CarrierServiceEasyPost.
type CarrierServiceEasyPostConnection struct {
	Edges      []*CarrierServiceEasyPostEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *CarrierServiceEasyPostConnection) build(nodes []*CarrierServiceEasyPost, pager *carrierserviceeasypostPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierServiceEasyPost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierServiceEasyPost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierServiceEasyPost {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierServiceEasyPostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierServiceEasyPostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierServiceEasyPostPaginateOption enables pagination customization.
type CarrierServiceEasyPostPaginateOption func(*carrierserviceeasypostPager) error

// WithCarrierServiceEasyPostOrder configures pagination ordering.
func WithCarrierServiceEasyPostOrder(order *CarrierServiceEasyPostOrder) CarrierServiceEasyPostPaginateOption {
	if order == nil {
		order = DefaultCarrierServiceEasyPostOrder
	}
	o := *order
	return func(pager *carrierserviceeasypostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierServiceEasyPostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierServiceEasyPostFilter configures pagination filter.
func WithCarrierServiceEasyPostFilter(filter func(*CarrierServiceEasyPostQuery) (*CarrierServiceEasyPostQuery, error)) CarrierServiceEasyPostPaginateOption {
	return func(pager *carrierserviceeasypostPager) error {
		if filter == nil {
			return errors.New("CarrierServiceEasyPostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierserviceeasypostPager struct {
	reverse bool
	order   *CarrierServiceEasyPostOrder
	filter  func(*CarrierServiceEasyPostQuery) (*CarrierServiceEasyPostQuery, error)
}

func newCarrierServiceEasyPostPager(opts []CarrierServiceEasyPostPaginateOption, reverse bool) (*carrierserviceeasypostPager, error) {
	pager := &carrierserviceeasypostPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierServiceEasyPostOrder
	}
	return pager, nil
}

func (p *carrierserviceeasypostPager) applyFilter(query *CarrierServiceEasyPostQuery) (*CarrierServiceEasyPostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierserviceeasypostPager) toCursor(csep *CarrierServiceEasyPost) Cursor {
	return p.order.Field.toCursor(csep)
}

func (p *carrierserviceeasypostPager) applyCursors(query *CarrierServiceEasyPostQuery, after, before *Cursor) (*CarrierServiceEasyPostQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierServiceEasyPostOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierserviceeasypostPager) applyOrder(query *CarrierServiceEasyPostQuery) *CarrierServiceEasyPostQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierServiceEasyPostOrder.Field {
		query = query.Order(DefaultCarrierServiceEasyPostOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierserviceeasypostPager) orderExpr(query *CarrierServiceEasyPostQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierServiceEasyPostOrder.Field {
			b.Comma().Ident(DefaultCarrierServiceEasyPostOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierServiceEasyPost.
func (csep *CarrierServiceEasyPostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierServiceEasyPostPaginateOption,
) (*CarrierServiceEasyPostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierServiceEasyPostPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if csep, err = pager.applyFilter(csep); err != nil {
		return nil, err
	}
	conn := &CarrierServiceEasyPostConnection{Edges: []*CarrierServiceEasyPostEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := csep.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if csep, err = pager.applyCursors(csep, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		csep.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := csep.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	csep = pager.applyOrder(csep)
	nodes, err := csep.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierServiceEasyPostOrderField defines the ordering field of CarrierServiceEasyPost.
type CarrierServiceEasyPostOrderField struct {
	// Value extracts the ordering value from the given CarrierServiceEasyPost.
	Value    func(*CarrierServiceEasyPost) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierserviceeasypost.OrderOption
	toCursor func(*CarrierServiceEasyPost) Cursor
}

// CarrierServiceEasyPostOrder defines the ordering of CarrierServiceEasyPost.
type CarrierServiceEasyPostOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *CarrierServiceEasyPostOrderField `json:"field"`
}

// DefaultCarrierServiceEasyPostOrder is the default ordering of CarrierServiceEasyPost.
var DefaultCarrierServiceEasyPostOrder = &CarrierServiceEasyPostOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierServiceEasyPostOrderField{
		Value: func(csep *CarrierServiceEasyPost) (ent.Value, error) {
			return csep.ID, nil
		},
		column: carrierserviceeasypost.FieldID,
		toTerm: carrierserviceeasypost.ByID,
		toCursor: func(csep *CarrierServiceEasyPost) Cursor {
			return Cursor{ID: csep.ID}
		},
	},
}

// ToEdge converts CarrierServiceEasyPost into CarrierServiceEasyPostEdge.
func (csep *CarrierServiceEasyPost) ToEdge(order *CarrierServiceEasyPostOrder) *CarrierServiceEasyPostEdge {
	if order == nil {
		order = DefaultCarrierServiceEasyPostOrder
	}
	return &CarrierServiceEasyPostEdge{
		Node:   csep,
		Cursor: order.Field.toCursor(csep),
	}
}

// CarrierServiceGLSEdge is the edge representation of CarrierServiceGLS.
type CarrierServiceGLSEdge struct {
	Node   *CarrierServiceGLS `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// CarrierServiceGLSConnection is the connection containing edges to CarrierServiceGLS.
type CarrierServiceGLSConnection struct {
	Edges      []*CarrierServiceGLSEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *CarrierServiceGLSConnection) build(nodes []*CarrierServiceGLS, pager *carrierserviceglsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierServiceGLS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierServiceGLS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierServiceGLS {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierServiceGLSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierServiceGLSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierServiceGLSPaginateOption enables pagination customization.
type CarrierServiceGLSPaginateOption func(*carrierserviceglsPager) error

// WithCarrierServiceGLSOrder configures pagination ordering.
func WithCarrierServiceGLSOrder(order *CarrierServiceGLSOrder) CarrierServiceGLSPaginateOption {
	if order == nil {
		order = DefaultCarrierServiceGLSOrder
	}
	o := *order
	return func(pager *carrierserviceglsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierServiceGLSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierServiceGLSFilter configures pagination filter.
func WithCarrierServiceGLSFilter(filter func(*CarrierServiceGLSQuery) (*CarrierServiceGLSQuery, error)) CarrierServiceGLSPaginateOption {
	return func(pager *carrierserviceglsPager) error {
		if filter == nil {
			return errors.New("CarrierServiceGLSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierserviceglsPager struct {
	reverse bool
	order   *CarrierServiceGLSOrder
	filter  func(*CarrierServiceGLSQuery) (*CarrierServiceGLSQuery, error)
}

func newCarrierServiceGLSPager(opts []CarrierServiceGLSPaginateOption, reverse bool) (*carrierserviceglsPager, error) {
	pager := &carrierserviceglsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierServiceGLSOrder
	}
	return pager, nil
}

func (p *carrierserviceglsPager) applyFilter(query *CarrierServiceGLSQuery) (*CarrierServiceGLSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierserviceglsPager) toCursor(csg *CarrierServiceGLS) Cursor {
	return p.order.Field.toCursor(csg)
}

func (p *carrierserviceglsPager) applyCursors(query *CarrierServiceGLSQuery, after, before *Cursor) (*CarrierServiceGLSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierServiceGLSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierserviceglsPager) applyOrder(query *CarrierServiceGLSQuery) *CarrierServiceGLSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierServiceGLSOrder.Field {
		query = query.Order(DefaultCarrierServiceGLSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierserviceglsPager) orderExpr(query *CarrierServiceGLSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierServiceGLSOrder.Field {
			b.Comma().Ident(DefaultCarrierServiceGLSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierServiceGLS.
func (csg *CarrierServiceGLSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierServiceGLSPaginateOption,
) (*CarrierServiceGLSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierServiceGLSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if csg, err = pager.applyFilter(csg); err != nil {
		return nil, err
	}
	conn := &CarrierServiceGLSConnection{Edges: []*CarrierServiceGLSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := csg.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if csg, err = pager.applyCursors(csg, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		csg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := csg.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	csg = pager.applyOrder(csg)
	nodes, err := csg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierServiceGLSOrderField defines the ordering field of CarrierServiceGLS.
type CarrierServiceGLSOrderField struct {
	// Value extracts the ordering value from the given CarrierServiceGLS.
	Value    func(*CarrierServiceGLS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierservicegls.OrderOption
	toCursor func(*CarrierServiceGLS) Cursor
}

// CarrierServiceGLSOrder defines the ordering of CarrierServiceGLS.
type CarrierServiceGLSOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *CarrierServiceGLSOrderField `json:"field"`
}

// DefaultCarrierServiceGLSOrder is the default ordering of CarrierServiceGLS.
var DefaultCarrierServiceGLSOrder = &CarrierServiceGLSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierServiceGLSOrderField{
		Value: func(csg *CarrierServiceGLS) (ent.Value, error) {
			return csg.ID, nil
		},
		column: carrierservicegls.FieldID,
		toTerm: carrierservicegls.ByID,
		toCursor: func(csg *CarrierServiceGLS) Cursor {
			return Cursor{ID: csg.ID}
		},
	},
}

// ToEdge converts CarrierServiceGLS into CarrierServiceGLSEdge.
func (csg *CarrierServiceGLS) ToEdge(order *CarrierServiceGLSOrder) *CarrierServiceGLSEdge {
	if order == nil {
		order = DefaultCarrierServiceGLSOrder
	}
	return &CarrierServiceGLSEdge{
		Node:   csg,
		Cursor: order.Field.toCursor(csg),
	}
}

// CarrierServicePostNordEdge is the edge representation of CarrierServicePostNord.
type CarrierServicePostNordEdge struct {
	Node   *CarrierServicePostNord `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// CarrierServicePostNordConnection is the connection containing edges to CarrierServicePostNord.
type CarrierServicePostNordConnection struct {
	Edges      []*CarrierServicePostNordEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *CarrierServicePostNordConnection) build(nodes []*CarrierServicePostNord, pager *carrierservicepostnordPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierServicePostNord
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierServicePostNord {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierServicePostNord {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierServicePostNordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierServicePostNordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierServicePostNordPaginateOption enables pagination customization.
type CarrierServicePostNordPaginateOption func(*carrierservicepostnordPager) error

// WithCarrierServicePostNordOrder configures pagination ordering.
func WithCarrierServicePostNordOrder(order *CarrierServicePostNordOrder) CarrierServicePostNordPaginateOption {
	if order == nil {
		order = DefaultCarrierServicePostNordOrder
	}
	o := *order
	return func(pager *carrierservicepostnordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierServicePostNordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierServicePostNordFilter configures pagination filter.
func WithCarrierServicePostNordFilter(filter func(*CarrierServicePostNordQuery) (*CarrierServicePostNordQuery, error)) CarrierServicePostNordPaginateOption {
	return func(pager *carrierservicepostnordPager) error {
		if filter == nil {
			return errors.New("CarrierServicePostNordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierservicepostnordPager struct {
	reverse bool
	order   *CarrierServicePostNordOrder
	filter  func(*CarrierServicePostNordQuery) (*CarrierServicePostNordQuery, error)
}

func newCarrierServicePostNordPager(opts []CarrierServicePostNordPaginateOption, reverse bool) (*carrierservicepostnordPager, error) {
	pager := &carrierservicepostnordPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierServicePostNordOrder
	}
	return pager, nil
}

func (p *carrierservicepostnordPager) applyFilter(query *CarrierServicePostNordQuery) (*CarrierServicePostNordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierservicepostnordPager) toCursor(cspn *CarrierServicePostNord) Cursor {
	return p.order.Field.toCursor(cspn)
}

func (p *carrierservicepostnordPager) applyCursors(query *CarrierServicePostNordQuery, after, before *Cursor) (*CarrierServicePostNordQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierServicePostNordOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierservicepostnordPager) applyOrder(query *CarrierServicePostNordQuery) *CarrierServicePostNordQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierServicePostNordOrder.Field {
		query = query.Order(DefaultCarrierServicePostNordOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierservicepostnordPager) orderExpr(query *CarrierServicePostNordQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierServicePostNordOrder.Field {
			b.Comma().Ident(DefaultCarrierServicePostNordOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierServicePostNord.
func (cspn *CarrierServicePostNordQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierServicePostNordPaginateOption,
) (*CarrierServicePostNordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierServicePostNordPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cspn, err = pager.applyFilter(cspn); err != nil {
		return nil, err
	}
	conn := &CarrierServicePostNordConnection{Edges: []*CarrierServicePostNordEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cspn.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cspn, err = pager.applyCursors(cspn, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cspn.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cspn.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cspn = pager.applyOrder(cspn)
	nodes, err := cspn.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierServicePostNordOrderField defines the ordering field of CarrierServicePostNord.
type CarrierServicePostNordOrderField struct {
	// Value extracts the ordering value from the given CarrierServicePostNord.
	Value    func(*CarrierServicePostNord) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierservicepostnord.OrderOption
	toCursor func(*CarrierServicePostNord) Cursor
}

// CarrierServicePostNordOrder defines the ordering of CarrierServicePostNord.
type CarrierServicePostNordOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *CarrierServicePostNordOrderField `json:"field"`
}

// DefaultCarrierServicePostNordOrder is the default ordering of CarrierServicePostNord.
var DefaultCarrierServicePostNordOrder = &CarrierServicePostNordOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierServicePostNordOrderField{
		Value: func(cspn *CarrierServicePostNord) (ent.Value, error) {
			return cspn.ID, nil
		},
		column: carrierservicepostnord.FieldID,
		toTerm: carrierservicepostnord.ByID,
		toCursor: func(cspn *CarrierServicePostNord) Cursor {
			return Cursor{ID: cspn.ID}
		},
	},
}

// ToEdge converts CarrierServicePostNord into CarrierServicePostNordEdge.
func (cspn *CarrierServicePostNord) ToEdge(order *CarrierServicePostNordOrder) *CarrierServicePostNordEdge {
	if order == nil {
		order = DefaultCarrierServicePostNordOrder
	}
	return &CarrierServicePostNordEdge{
		Node:   cspn,
		Cursor: order.Field.toCursor(cspn),
	}
}

// CarrierServiceUSPSEdge is the edge representation of CarrierServiceUSPS.
type CarrierServiceUSPSEdge struct {
	Node   *CarrierServiceUSPS `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// CarrierServiceUSPSConnection is the connection containing edges to CarrierServiceUSPS.
type CarrierServiceUSPSConnection struct {
	Edges      []*CarrierServiceUSPSEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *CarrierServiceUSPSConnection) build(nodes []*CarrierServiceUSPS, pager *carrierserviceuspsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierServiceUSPS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierServiceUSPS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierServiceUSPS {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierServiceUSPSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierServiceUSPSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierServiceUSPSPaginateOption enables pagination customization.
type CarrierServiceUSPSPaginateOption func(*carrierserviceuspsPager) error

// WithCarrierServiceUSPSOrder configures pagination ordering.
func WithCarrierServiceUSPSOrder(order *CarrierServiceUSPSOrder) CarrierServiceUSPSPaginateOption {
	if order == nil {
		order = DefaultCarrierServiceUSPSOrder
	}
	o := *order
	return func(pager *carrierserviceuspsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierServiceUSPSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierServiceUSPSFilter configures pagination filter.
func WithCarrierServiceUSPSFilter(filter func(*CarrierServiceUSPSQuery) (*CarrierServiceUSPSQuery, error)) CarrierServiceUSPSPaginateOption {
	return func(pager *carrierserviceuspsPager) error {
		if filter == nil {
			return errors.New("CarrierServiceUSPSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrierserviceuspsPager struct {
	reverse bool
	order   *CarrierServiceUSPSOrder
	filter  func(*CarrierServiceUSPSQuery) (*CarrierServiceUSPSQuery, error)
}

func newCarrierServiceUSPSPager(opts []CarrierServiceUSPSPaginateOption, reverse bool) (*carrierserviceuspsPager, error) {
	pager := &carrierserviceuspsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierServiceUSPSOrder
	}
	return pager, nil
}

func (p *carrierserviceuspsPager) applyFilter(query *CarrierServiceUSPSQuery) (*CarrierServiceUSPSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrierserviceuspsPager) toCursor(csu *CarrierServiceUSPS) Cursor {
	return p.order.Field.toCursor(csu)
}

func (p *carrierserviceuspsPager) applyCursors(query *CarrierServiceUSPSQuery, after, before *Cursor) (*CarrierServiceUSPSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierServiceUSPSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrierserviceuspsPager) applyOrder(query *CarrierServiceUSPSQuery) *CarrierServiceUSPSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierServiceUSPSOrder.Field {
		query = query.Order(DefaultCarrierServiceUSPSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrierserviceuspsPager) orderExpr(query *CarrierServiceUSPSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierServiceUSPSOrder.Field {
			b.Comma().Ident(DefaultCarrierServiceUSPSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierServiceUSPS.
func (csu *CarrierServiceUSPSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierServiceUSPSPaginateOption,
) (*CarrierServiceUSPSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierServiceUSPSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if csu, err = pager.applyFilter(csu); err != nil {
		return nil, err
	}
	conn := &CarrierServiceUSPSConnection{Edges: []*CarrierServiceUSPSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := csu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if csu, err = pager.applyCursors(csu, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		csu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := csu.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	csu = pager.applyOrder(csu)
	nodes, err := csu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierServiceUSPSOrderField defines the ordering field of CarrierServiceUSPS.
type CarrierServiceUSPSOrderField struct {
	// Value extracts the ordering value from the given CarrierServiceUSPS.
	Value    func(*CarrierServiceUSPS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierserviceusps.OrderOption
	toCursor func(*CarrierServiceUSPS) Cursor
}

// CarrierServiceUSPSOrder defines the ordering of CarrierServiceUSPS.
type CarrierServiceUSPSOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *CarrierServiceUSPSOrderField `json:"field"`
}

// DefaultCarrierServiceUSPSOrder is the default ordering of CarrierServiceUSPS.
var DefaultCarrierServiceUSPSOrder = &CarrierServiceUSPSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierServiceUSPSOrderField{
		Value: func(csu *CarrierServiceUSPS) (ent.Value, error) {
			return csu.ID, nil
		},
		column: carrierserviceusps.FieldID,
		toTerm: carrierserviceusps.ByID,
		toCursor: func(csu *CarrierServiceUSPS) Cursor {
			return Cursor{ID: csu.ID}
		},
	},
}

// ToEdge converts CarrierServiceUSPS into CarrierServiceUSPSEdge.
func (csu *CarrierServiceUSPS) ToEdge(order *CarrierServiceUSPSOrder) *CarrierServiceUSPSEdge {
	if order == nil {
		order = DefaultCarrierServiceUSPSOrder
	}
	return &CarrierServiceUSPSEdge{
		Node:   csu,
		Cursor: order.Field.toCursor(csu),
	}
}

// CarrierUSPSEdge is the edge representation of CarrierUSPS.
type CarrierUSPSEdge struct {
	Node   *CarrierUSPS `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// CarrierUSPSConnection is the connection containing edges to CarrierUSPS.
type CarrierUSPSConnection struct {
	Edges      []*CarrierUSPSEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *CarrierUSPSConnection) build(nodes []*CarrierUSPS, pager *carrieruspsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CarrierUSPS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CarrierUSPS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CarrierUSPS {
			return nodes[i]
		}
	}
	c.Edges = make([]*CarrierUSPSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CarrierUSPSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CarrierUSPSPaginateOption enables pagination customization.
type CarrierUSPSPaginateOption func(*carrieruspsPager) error

// WithCarrierUSPSOrder configures pagination ordering.
func WithCarrierUSPSOrder(order *CarrierUSPSOrder) CarrierUSPSPaginateOption {
	if order == nil {
		order = DefaultCarrierUSPSOrder
	}
	o := *order
	return func(pager *carrieruspsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCarrierUSPSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCarrierUSPSFilter configures pagination filter.
func WithCarrierUSPSFilter(filter func(*CarrierUSPSQuery) (*CarrierUSPSQuery, error)) CarrierUSPSPaginateOption {
	return func(pager *carrieruspsPager) error {
		if filter == nil {
			return errors.New("CarrierUSPSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type carrieruspsPager struct {
	reverse bool
	order   *CarrierUSPSOrder
	filter  func(*CarrierUSPSQuery) (*CarrierUSPSQuery, error)
}

func newCarrierUSPSPager(opts []CarrierUSPSPaginateOption, reverse bool) (*carrieruspsPager, error) {
	pager := &carrieruspsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCarrierUSPSOrder
	}
	return pager, nil
}

func (p *carrieruspsPager) applyFilter(query *CarrierUSPSQuery) (*CarrierUSPSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *carrieruspsPager) toCursor(cu *CarrierUSPS) Cursor {
	return p.order.Field.toCursor(cu)
}

func (p *carrieruspsPager) applyCursors(query *CarrierUSPSQuery, after, before *Cursor) (*CarrierUSPSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCarrierUSPSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *carrieruspsPager) applyOrder(query *CarrierUSPSQuery) *CarrierUSPSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCarrierUSPSOrder.Field {
		query = query.Order(DefaultCarrierUSPSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *carrieruspsPager) orderExpr(query *CarrierUSPSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCarrierUSPSOrder.Field {
			b.Comma().Ident(DefaultCarrierUSPSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CarrierUSPS.
func (cu *CarrierUSPSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CarrierUSPSPaginateOption,
) (*CarrierUSPSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCarrierUSPSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cu, err = pager.applyFilter(cu); err != nil {
		return nil, err
	}
	conn := &CarrierUSPSConnection{Edges: []*CarrierUSPSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cu, err = pager.applyCursors(cu, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cu.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cu = pager.applyOrder(cu)
	nodes, err := cu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CarrierUSPSOrderField defines the ordering field of CarrierUSPS.
type CarrierUSPSOrderField struct {
	// Value extracts the ordering value from the given CarrierUSPS.
	Value    func(*CarrierUSPS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) carrierusps.OrderOption
	toCursor func(*CarrierUSPS) Cursor
}

// CarrierUSPSOrder defines the ordering of CarrierUSPS.
type CarrierUSPSOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *CarrierUSPSOrderField `json:"field"`
}

// DefaultCarrierUSPSOrder is the default ordering of CarrierUSPS.
var DefaultCarrierUSPSOrder = &CarrierUSPSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CarrierUSPSOrderField{
		Value: func(cu *CarrierUSPS) (ent.Value, error) {
			return cu.ID, nil
		},
		column: carrierusps.FieldID,
		toTerm: carrierusps.ByID,
		toCursor: func(cu *CarrierUSPS) Cursor {
			return Cursor{ID: cu.ID}
		},
	},
}

// ToEdge converts CarrierUSPS into CarrierUSPSEdge.
func (cu *CarrierUSPS) ToEdge(order *CarrierUSPSOrder) *CarrierUSPSEdge {
	if order == nil {
		order = DefaultCarrierUSPSOrder
	}
	return &CarrierUSPSEdge{
		Node:   cu,
		Cursor: order.Field.toCursor(cu),
	}
}

// ChangeHistoryEdge is the edge representation of ChangeHistory.
type ChangeHistoryEdge struct {
	Node   *ChangeHistory `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ChangeHistoryConnection is the connection containing edges to ChangeHistory.
type ChangeHistoryConnection struct {
	Edges      []*ChangeHistoryEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *ChangeHistoryConnection) build(nodes []*ChangeHistory, pager *changehistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ChangeHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ChangeHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ChangeHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ChangeHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ChangeHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ChangeHistoryPaginateOption enables pagination customization.
type ChangeHistoryPaginateOption func(*changehistoryPager) error

// WithChangeHistoryOrder configures pagination ordering.
func WithChangeHistoryOrder(order *ChangeHistoryOrder) ChangeHistoryPaginateOption {
	if order == nil {
		order = DefaultChangeHistoryOrder
	}
	o := *order
	return func(pager *changehistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultChangeHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithChangeHistoryFilter configures pagination filter.
func WithChangeHistoryFilter(filter func(*ChangeHistoryQuery) (*ChangeHistoryQuery, error)) ChangeHistoryPaginateOption {
	return func(pager *changehistoryPager) error {
		if filter == nil {
			return errors.New("ChangeHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type changehistoryPager struct {
	reverse bool
	order   *ChangeHistoryOrder
	filter  func(*ChangeHistoryQuery) (*ChangeHistoryQuery, error)
}

func newChangeHistoryPager(opts []ChangeHistoryPaginateOption, reverse bool) (*changehistoryPager, error) {
	pager := &changehistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultChangeHistoryOrder
	}
	return pager, nil
}

func (p *changehistoryPager) applyFilter(query *ChangeHistoryQuery) (*ChangeHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *changehistoryPager) toCursor(ch *ChangeHistory) Cursor {
	return p.order.Field.toCursor(ch)
}

func (p *changehistoryPager) applyCursors(query *ChangeHistoryQuery, after, before *Cursor) (*ChangeHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultChangeHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *changehistoryPager) applyOrder(query *ChangeHistoryQuery) *ChangeHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultChangeHistoryOrder.Field {
		query = query.Order(DefaultChangeHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *changehistoryPager) orderExpr(query *ChangeHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultChangeHistoryOrder.Field {
			b.Comma().Ident(DefaultChangeHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ChangeHistory.
func (ch *ChangeHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ChangeHistoryPaginateOption,
) (*ChangeHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newChangeHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ch, err = pager.applyFilter(ch); err != nil {
		return nil, err
	}
	conn := &ChangeHistoryConnection{Edges: []*ChangeHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ch.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ch, err = pager.applyCursors(ch, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ch.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ch.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ch = pager.applyOrder(ch)
	nodes, err := ch.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ChangeHistoryOrderFieldCreatedAt orders ChangeHistory by created_at.
	ChangeHistoryOrderFieldCreatedAt = &ChangeHistoryOrderField{
		Value: func(ch *ChangeHistory) (ent.Value, error) {
			return ch.CreatedAt, nil
		},
		column: changehistory.FieldCreatedAt,
		toTerm: changehistory.ByCreatedAt,
		toCursor: func(ch *ChangeHistory) Cursor {
			return Cursor{
				ID:    ch.ID,
				Value: ch.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ChangeHistoryOrderField) String() string {
	var str string
	switch f.column {
	case ChangeHistoryOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ChangeHistoryOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ChangeHistoryOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ChangeHistoryOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ChangeHistoryOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid ChangeHistoryOrderField", str)
	}
	return nil
}

// ChangeHistoryOrderField defines the ordering field of ChangeHistory.
type ChangeHistoryOrderField struct {
	// Value extracts the ordering value from the given ChangeHistory.
	Value    func(*ChangeHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) changehistory.OrderOption
	toCursor func(*ChangeHistory) Cursor
}

// ChangeHistoryOrder defines the ordering of ChangeHistory.
type ChangeHistoryOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ChangeHistoryOrderField `json:"field"`
}

// DefaultChangeHistoryOrder is the default ordering of ChangeHistory.
var DefaultChangeHistoryOrder = &ChangeHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ChangeHistoryOrderField{
		Value: func(ch *ChangeHistory) (ent.Value, error) {
			return ch.ID, nil
		},
		column: changehistory.FieldID,
		toTerm: changehistory.ByID,
		toCursor: func(ch *ChangeHistory) Cursor {
			return Cursor{ID: ch.ID}
		},
	},
}

// ToEdge converts ChangeHistory into ChangeHistoryEdge.
func (ch *ChangeHistory) ToEdge(order *ChangeHistoryOrder) *ChangeHistoryEdge {
	if order == nil {
		order = DefaultChangeHistoryOrder
	}
	return &ChangeHistoryEdge{
		Node:   ch,
		Cursor: order.Field.toCursor(ch),
	}
}

// ColliEdge is the edge representation of Colli.
type ColliEdge struct {
	Node   *Colli `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// ColliConnection is the connection containing edges to Colli.
type ColliConnection struct {
	Edges      []*ColliEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *ColliConnection) build(nodes []*Colli, pager *colliPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Colli
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Colli {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Colli {
			return nodes[i]
		}
	}
	c.Edges = make([]*ColliEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ColliEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ColliPaginateOption enables pagination customization.
type ColliPaginateOption func(*colliPager) error

// WithColliOrder configures pagination ordering.
func WithColliOrder(order *ColliOrder) ColliPaginateOption {
	if order == nil {
		order = DefaultColliOrder
	}
	o := *order
	return func(pager *colliPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultColliOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithColliFilter configures pagination filter.
func WithColliFilter(filter func(*ColliQuery) (*ColliQuery, error)) ColliPaginateOption {
	return func(pager *colliPager) error {
		if filter == nil {
			return errors.New("ColliQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type colliPager struct {
	reverse bool
	order   *ColliOrder
	filter  func(*ColliQuery) (*ColliQuery, error)
}

func newColliPager(opts []ColliPaginateOption, reverse bool) (*colliPager, error) {
	pager := &colliPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultColliOrder
	}
	return pager, nil
}

func (p *colliPager) applyFilter(query *ColliQuery) (*ColliQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *colliPager) toCursor(c *Colli) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *colliPager) applyCursors(query *ColliQuery, after, before *Cursor) (*ColliQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultColliOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *colliPager) applyOrder(query *ColliQuery) *ColliQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultColliOrder.Field {
		query = query.Order(DefaultColliOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *colliPager) orderExpr(query *ColliQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultColliOrder.Field {
			b.Comma().Ident(DefaultColliOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Colli.
func (c *ColliQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ColliPaginateOption,
) (*ColliConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newColliPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ColliConnection{Edges: []*ColliEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ColliOrderField defines the ordering field of Colli.
type ColliOrderField struct {
	// Value extracts the ordering value from the given Colli.
	Value    func(*Colli) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) colli.OrderOption
	toCursor func(*Colli) Cursor
}

// ColliOrder defines the ordering of Colli.
type ColliOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *ColliOrderField `json:"field"`
}

// DefaultColliOrder is the default ordering of Colli.
var DefaultColliOrder = &ColliOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ColliOrderField{
		Value: func(c *Colli) (ent.Value, error) {
			return c.ID, nil
		},
		column: colli.FieldID,
		toTerm: colli.ByID,
		toCursor: func(c *Colli) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Colli into ColliEdge.
func (c *Colli) ToEdge(order *ColliOrder) *ColliEdge {
	if order == nil {
		order = DefaultColliOrder
	}
	return &ColliEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// ConnectOptionCarrierEdge is the edge representation of ConnectOptionCarrier.
type ConnectOptionCarrierEdge struct {
	Node   *ConnectOptionCarrier `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// ConnectOptionCarrierConnection is the connection containing edges to ConnectOptionCarrier.
type ConnectOptionCarrierConnection struct {
	Edges      []*ConnectOptionCarrierEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *ConnectOptionCarrierConnection) build(nodes []*ConnectOptionCarrier, pager *connectoptioncarrierPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ConnectOptionCarrier
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ConnectOptionCarrier {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ConnectOptionCarrier {
			return nodes[i]
		}
	}
	c.Edges = make([]*ConnectOptionCarrierEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ConnectOptionCarrierEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ConnectOptionCarrierPaginateOption enables pagination customization.
type ConnectOptionCarrierPaginateOption func(*connectoptioncarrierPager) error

// WithConnectOptionCarrierOrder configures pagination ordering.
func WithConnectOptionCarrierOrder(order *ConnectOptionCarrierOrder) ConnectOptionCarrierPaginateOption {
	if order == nil {
		order = DefaultConnectOptionCarrierOrder
	}
	o := *order
	return func(pager *connectoptioncarrierPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultConnectOptionCarrierOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithConnectOptionCarrierFilter configures pagination filter.
func WithConnectOptionCarrierFilter(filter func(*ConnectOptionCarrierQuery) (*ConnectOptionCarrierQuery, error)) ConnectOptionCarrierPaginateOption {
	return func(pager *connectoptioncarrierPager) error {
		if filter == nil {
			return errors.New("ConnectOptionCarrierQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type connectoptioncarrierPager struct {
	reverse bool
	order   *ConnectOptionCarrierOrder
	filter  func(*ConnectOptionCarrierQuery) (*ConnectOptionCarrierQuery, error)
}

func newConnectOptionCarrierPager(opts []ConnectOptionCarrierPaginateOption, reverse bool) (*connectoptioncarrierPager, error) {
	pager := &connectoptioncarrierPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultConnectOptionCarrierOrder
	}
	return pager, nil
}

func (p *connectoptioncarrierPager) applyFilter(query *ConnectOptionCarrierQuery) (*ConnectOptionCarrierQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *connectoptioncarrierPager) toCursor(coc *ConnectOptionCarrier) Cursor {
	return p.order.Field.toCursor(coc)
}

func (p *connectoptioncarrierPager) applyCursors(query *ConnectOptionCarrierQuery, after, before *Cursor) (*ConnectOptionCarrierQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultConnectOptionCarrierOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *connectoptioncarrierPager) applyOrder(query *ConnectOptionCarrierQuery) *ConnectOptionCarrierQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultConnectOptionCarrierOrder.Field {
		query = query.Order(DefaultConnectOptionCarrierOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *connectoptioncarrierPager) orderExpr(query *ConnectOptionCarrierQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultConnectOptionCarrierOrder.Field {
			b.Comma().Ident(DefaultConnectOptionCarrierOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ConnectOptionCarrier.
func (coc *ConnectOptionCarrierQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ConnectOptionCarrierPaginateOption,
) (*ConnectOptionCarrierConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newConnectOptionCarrierPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if coc, err = pager.applyFilter(coc); err != nil {
		return nil, err
	}
	conn := &ConnectOptionCarrierConnection{Edges: []*ConnectOptionCarrierEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := coc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if coc, err = pager.applyCursors(coc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		coc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := coc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	coc = pager.applyOrder(coc)
	nodes, err := coc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ConnectOptionCarrierOrderField defines the ordering field of ConnectOptionCarrier.
type ConnectOptionCarrierOrderField struct {
	// Value extracts the ordering value from the given ConnectOptionCarrier.
	Value    func(*ConnectOptionCarrier) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) connectoptioncarrier.OrderOption
	toCursor func(*ConnectOptionCarrier) Cursor
}

// ConnectOptionCarrierOrder defines the ordering of ConnectOptionCarrier.
type ConnectOptionCarrierOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *ConnectOptionCarrierOrderField `json:"field"`
}

// DefaultConnectOptionCarrierOrder is the default ordering of ConnectOptionCarrier.
var DefaultConnectOptionCarrierOrder = &ConnectOptionCarrierOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ConnectOptionCarrierOrderField{
		Value: func(coc *ConnectOptionCarrier) (ent.Value, error) {
			return coc.ID, nil
		},
		column: connectoptioncarrier.FieldID,
		toTerm: connectoptioncarrier.ByID,
		toCursor: func(coc *ConnectOptionCarrier) Cursor {
			return Cursor{ID: coc.ID}
		},
	},
}

// ToEdge converts ConnectOptionCarrier into ConnectOptionCarrierEdge.
func (coc *ConnectOptionCarrier) ToEdge(order *ConnectOptionCarrierOrder) *ConnectOptionCarrierEdge {
	if order == nil {
		order = DefaultConnectOptionCarrierOrder
	}
	return &ConnectOptionCarrierEdge{
		Node:   coc,
		Cursor: order.Field.toCursor(coc),
	}
}

// ConnectOptionPlatformEdge is the edge representation of ConnectOptionPlatform.
type ConnectOptionPlatformEdge struct {
	Node   *ConnectOptionPlatform `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// ConnectOptionPlatformConnection is the connection containing edges to ConnectOptionPlatform.
type ConnectOptionPlatformConnection struct {
	Edges      []*ConnectOptionPlatformEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *ConnectOptionPlatformConnection) build(nodes []*ConnectOptionPlatform, pager *connectoptionplatformPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ConnectOptionPlatform
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ConnectOptionPlatform {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ConnectOptionPlatform {
			return nodes[i]
		}
	}
	c.Edges = make([]*ConnectOptionPlatformEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ConnectOptionPlatformEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ConnectOptionPlatformPaginateOption enables pagination customization.
type ConnectOptionPlatformPaginateOption func(*connectoptionplatformPager) error

// WithConnectOptionPlatformOrder configures pagination ordering.
func WithConnectOptionPlatformOrder(order *ConnectOptionPlatformOrder) ConnectOptionPlatformPaginateOption {
	if order == nil {
		order = DefaultConnectOptionPlatformOrder
	}
	o := *order
	return func(pager *connectoptionplatformPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultConnectOptionPlatformOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithConnectOptionPlatformFilter configures pagination filter.
func WithConnectOptionPlatformFilter(filter func(*ConnectOptionPlatformQuery) (*ConnectOptionPlatformQuery, error)) ConnectOptionPlatformPaginateOption {
	return func(pager *connectoptionplatformPager) error {
		if filter == nil {
			return errors.New("ConnectOptionPlatformQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type connectoptionplatformPager struct {
	reverse bool
	order   *ConnectOptionPlatformOrder
	filter  func(*ConnectOptionPlatformQuery) (*ConnectOptionPlatformQuery, error)
}

func newConnectOptionPlatformPager(opts []ConnectOptionPlatformPaginateOption, reverse bool) (*connectoptionplatformPager, error) {
	pager := &connectoptionplatformPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultConnectOptionPlatformOrder
	}
	return pager, nil
}

func (p *connectoptionplatformPager) applyFilter(query *ConnectOptionPlatformQuery) (*ConnectOptionPlatformQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *connectoptionplatformPager) toCursor(cop *ConnectOptionPlatform) Cursor {
	return p.order.Field.toCursor(cop)
}

func (p *connectoptionplatformPager) applyCursors(query *ConnectOptionPlatformQuery, after, before *Cursor) (*ConnectOptionPlatformQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultConnectOptionPlatformOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *connectoptionplatformPager) applyOrder(query *ConnectOptionPlatformQuery) *ConnectOptionPlatformQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultConnectOptionPlatformOrder.Field {
		query = query.Order(DefaultConnectOptionPlatformOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *connectoptionplatformPager) orderExpr(query *ConnectOptionPlatformQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultConnectOptionPlatformOrder.Field {
			b.Comma().Ident(DefaultConnectOptionPlatformOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ConnectOptionPlatform.
func (cop *ConnectOptionPlatformQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ConnectOptionPlatformPaginateOption,
) (*ConnectOptionPlatformConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newConnectOptionPlatformPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cop, err = pager.applyFilter(cop); err != nil {
		return nil, err
	}
	conn := &ConnectOptionPlatformConnection{Edges: []*ConnectOptionPlatformEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cop.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cop, err = pager.applyCursors(cop, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cop.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cop.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cop = pager.applyOrder(cop)
	nodes, err := cop.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ConnectOptionPlatformOrderField defines the ordering field of ConnectOptionPlatform.
type ConnectOptionPlatformOrderField struct {
	// Value extracts the ordering value from the given ConnectOptionPlatform.
	Value    func(*ConnectOptionPlatform) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) connectoptionplatform.OrderOption
	toCursor func(*ConnectOptionPlatform) Cursor
}

// ConnectOptionPlatformOrder defines the ordering of ConnectOptionPlatform.
type ConnectOptionPlatformOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *ConnectOptionPlatformOrderField `json:"field"`
}

// DefaultConnectOptionPlatformOrder is the default ordering of ConnectOptionPlatform.
var DefaultConnectOptionPlatformOrder = &ConnectOptionPlatformOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ConnectOptionPlatformOrderField{
		Value: func(cop *ConnectOptionPlatform) (ent.Value, error) {
			return cop.ID, nil
		},
		column: connectoptionplatform.FieldID,
		toTerm: connectoptionplatform.ByID,
		toCursor: func(cop *ConnectOptionPlatform) Cursor {
			return Cursor{ID: cop.ID}
		},
	},
}

// ToEdge converts ConnectOptionPlatform into ConnectOptionPlatformEdge.
func (cop *ConnectOptionPlatform) ToEdge(order *ConnectOptionPlatformOrder) *ConnectOptionPlatformEdge {
	if order == nil {
		order = DefaultConnectOptionPlatformOrder
	}
	return &ConnectOptionPlatformEdge{
		Node:   cop,
		Cursor: order.Field.toCursor(cop),
	}
}

// ConnectionEdge is the edge representation of Connection.
type ConnectionEdge struct {
	Node   *Connection `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ConnectionConnection is the connection containing edges to Connection.
type ConnectionConnection struct {
	Edges      []*ConnectionEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ConnectionConnection) build(nodes []*Connection, pager *connectionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Connection
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Connection {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Connection {
			return nodes[i]
		}
	}
	c.Edges = make([]*ConnectionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ConnectionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ConnectionPaginateOption enables pagination customization.
type ConnectionPaginateOption func(*connectionPager) error

// WithConnectionOrder configures pagination ordering.
func WithConnectionOrder(order *ConnectionOrder) ConnectionPaginateOption {
	if order == nil {
		order = DefaultConnectionOrder
	}
	o := *order
	return func(pager *connectionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultConnectionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithConnectionFilter configures pagination filter.
func WithConnectionFilter(filter func(*ConnectionQuery) (*ConnectionQuery, error)) ConnectionPaginateOption {
	return func(pager *connectionPager) error {
		if filter == nil {
			return errors.New("ConnectionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type connectionPager struct {
	reverse bool
	order   *ConnectionOrder
	filter  func(*ConnectionQuery) (*ConnectionQuery, error)
}

func newConnectionPager(opts []ConnectionPaginateOption, reverse bool) (*connectionPager, error) {
	pager := &connectionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultConnectionOrder
	}
	return pager, nil
}

func (p *connectionPager) applyFilter(query *ConnectionQuery) (*ConnectionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *connectionPager) toCursor(c *Connection) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *connectionPager) applyCursors(query *ConnectionQuery, after, before *Cursor) (*ConnectionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultConnectionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *connectionPager) applyOrder(query *ConnectionQuery) *ConnectionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultConnectionOrder.Field {
		query = query.Order(DefaultConnectionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *connectionPager) orderExpr(query *ConnectionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultConnectionOrder.Field {
			b.Comma().Ident(DefaultConnectionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Connection.
func (c *ConnectionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ConnectionPaginateOption,
) (*ConnectionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newConnectionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ConnectionConnection{Edges: []*ConnectionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ConnectionOrderField defines the ordering field of Connection.
type ConnectionOrderField struct {
	// Value extracts the ordering value from the given Connection.
	Value    func(*Connection) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) connection.OrderOption
	toCursor func(*Connection) Cursor
}

// ConnectionOrder defines the ordering of Connection.
type ConnectionOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ConnectionOrderField `json:"field"`
}

// DefaultConnectionOrder is the default ordering of Connection.
var DefaultConnectionOrder = &ConnectionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ConnectionOrderField{
		Value: func(c *Connection) (ent.Value, error) {
			return c.ID, nil
		},
		column: connection.FieldID,
		toTerm: connection.ByID,
		toCursor: func(c *Connection) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Connection into ConnectionEdge.
func (c *Connection) ToEdge(order *ConnectionOrder) *ConnectionEdge {
	if order == nil {
		order = DefaultConnectionOrder
	}
	return &ConnectionEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// ConnectionBrandEdge is the edge representation of ConnectionBrand.
type ConnectionBrandEdge struct {
	Node   *ConnectionBrand `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ConnectionBrandConnection is the connection containing edges to ConnectionBrand.
type ConnectionBrandConnection struct {
	Edges      []*ConnectionBrandEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ConnectionBrandConnection) build(nodes []*ConnectionBrand, pager *connectionbrandPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ConnectionBrand
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ConnectionBrand {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ConnectionBrand {
			return nodes[i]
		}
	}
	c.Edges = make([]*ConnectionBrandEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ConnectionBrandEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ConnectionBrandPaginateOption enables pagination customization.
type ConnectionBrandPaginateOption func(*connectionbrandPager) error

// WithConnectionBrandOrder configures pagination ordering.
func WithConnectionBrandOrder(order *ConnectionBrandOrder) ConnectionBrandPaginateOption {
	if order == nil {
		order = DefaultConnectionBrandOrder
	}
	o := *order
	return func(pager *connectionbrandPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultConnectionBrandOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithConnectionBrandFilter configures pagination filter.
func WithConnectionBrandFilter(filter func(*ConnectionBrandQuery) (*ConnectionBrandQuery, error)) ConnectionBrandPaginateOption {
	return func(pager *connectionbrandPager) error {
		if filter == nil {
			return errors.New("ConnectionBrandQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type connectionbrandPager struct {
	reverse bool
	order   *ConnectionBrandOrder
	filter  func(*ConnectionBrandQuery) (*ConnectionBrandQuery, error)
}

func newConnectionBrandPager(opts []ConnectionBrandPaginateOption, reverse bool) (*connectionbrandPager, error) {
	pager := &connectionbrandPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultConnectionBrandOrder
	}
	return pager, nil
}

func (p *connectionbrandPager) applyFilter(query *ConnectionBrandQuery) (*ConnectionBrandQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *connectionbrandPager) toCursor(cb *ConnectionBrand) Cursor {
	return p.order.Field.toCursor(cb)
}

func (p *connectionbrandPager) applyCursors(query *ConnectionBrandQuery, after, before *Cursor) (*ConnectionBrandQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultConnectionBrandOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *connectionbrandPager) applyOrder(query *ConnectionBrandQuery) *ConnectionBrandQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultConnectionBrandOrder.Field {
		query = query.Order(DefaultConnectionBrandOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *connectionbrandPager) orderExpr(query *ConnectionBrandQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultConnectionBrandOrder.Field {
			b.Comma().Ident(DefaultConnectionBrandOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ConnectionBrand.
func (cb *ConnectionBrandQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ConnectionBrandPaginateOption,
) (*ConnectionBrandConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newConnectionBrandPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cb, err = pager.applyFilter(cb); err != nil {
		return nil, err
	}
	conn := &ConnectionBrandConnection{Edges: []*ConnectionBrandEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cb.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cb, err = pager.applyCursors(cb, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cb.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cb = pager.applyOrder(cb)
	nodes, err := cb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ConnectionBrandOrderField defines the ordering field of ConnectionBrand.
type ConnectionBrandOrderField struct {
	// Value extracts the ordering value from the given ConnectionBrand.
	Value    func(*ConnectionBrand) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) connectionbrand.OrderOption
	toCursor func(*ConnectionBrand) Cursor
}

// ConnectionBrandOrder defines the ordering of ConnectionBrand.
type ConnectionBrandOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ConnectionBrandOrderField `json:"field"`
}

// DefaultConnectionBrandOrder is the default ordering of ConnectionBrand.
var DefaultConnectionBrandOrder = &ConnectionBrandOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ConnectionBrandOrderField{
		Value: func(cb *ConnectionBrand) (ent.Value, error) {
			return cb.ID, nil
		},
		column: connectionbrand.FieldID,
		toTerm: connectionbrand.ByID,
		toCursor: func(cb *ConnectionBrand) Cursor {
			return Cursor{ID: cb.ID}
		},
	},
}

// ToEdge converts ConnectionBrand into ConnectionBrandEdge.
func (cb *ConnectionBrand) ToEdge(order *ConnectionBrandOrder) *ConnectionBrandEdge {
	if order == nil {
		order = DefaultConnectionBrandOrder
	}
	return &ConnectionBrandEdge{
		Node:   cb,
		Cursor: order.Field.toCursor(cb),
	}
}

// ConnectionLookupEdge is the edge representation of ConnectionLookup.
type ConnectionLookupEdge struct {
	Node   *ConnectionLookup `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ConnectionLookupConnection is the connection containing edges to ConnectionLookup.
type ConnectionLookupConnection struct {
	Edges      []*ConnectionLookupEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ConnectionLookupConnection) build(nodes []*ConnectionLookup, pager *connectionlookupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ConnectionLookup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ConnectionLookup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ConnectionLookup {
			return nodes[i]
		}
	}
	c.Edges = make([]*ConnectionLookupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ConnectionLookupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ConnectionLookupPaginateOption enables pagination customization.
type ConnectionLookupPaginateOption func(*connectionlookupPager) error

// WithConnectionLookupOrder configures pagination ordering.
func WithConnectionLookupOrder(order *ConnectionLookupOrder) ConnectionLookupPaginateOption {
	if order == nil {
		order = DefaultConnectionLookupOrder
	}
	o := *order
	return func(pager *connectionlookupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultConnectionLookupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithConnectionLookupFilter configures pagination filter.
func WithConnectionLookupFilter(filter func(*ConnectionLookupQuery) (*ConnectionLookupQuery, error)) ConnectionLookupPaginateOption {
	return func(pager *connectionlookupPager) error {
		if filter == nil {
			return errors.New("ConnectionLookupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type connectionlookupPager struct {
	reverse bool
	order   *ConnectionLookupOrder
	filter  func(*ConnectionLookupQuery) (*ConnectionLookupQuery, error)
}

func newConnectionLookupPager(opts []ConnectionLookupPaginateOption, reverse bool) (*connectionlookupPager, error) {
	pager := &connectionlookupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultConnectionLookupOrder
	}
	return pager, nil
}

func (p *connectionlookupPager) applyFilter(query *ConnectionLookupQuery) (*ConnectionLookupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *connectionlookupPager) toCursor(cl *ConnectionLookup) Cursor {
	return p.order.Field.toCursor(cl)
}

func (p *connectionlookupPager) applyCursors(query *ConnectionLookupQuery, after, before *Cursor) (*ConnectionLookupQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultConnectionLookupOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *connectionlookupPager) applyOrder(query *ConnectionLookupQuery) *ConnectionLookupQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultConnectionLookupOrder.Field {
		query = query.Order(DefaultConnectionLookupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *connectionlookupPager) orderExpr(query *ConnectionLookupQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultConnectionLookupOrder.Field {
			b.Comma().Ident(DefaultConnectionLookupOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ConnectionLookup.
func (cl *ConnectionLookupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ConnectionLookupPaginateOption,
) (*ConnectionLookupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newConnectionLookupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cl, err = pager.applyFilter(cl); err != nil {
		return nil, err
	}
	conn := &ConnectionLookupConnection{Edges: []*ConnectionLookupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cl.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cl, err = pager.applyCursors(cl, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cl.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cl = pager.applyOrder(cl)
	nodes, err := cl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ConnectionLookupOrderFieldCreatedAt orders ConnectionLookup by created_at.
	ConnectionLookupOrderFieldCreatedAt = &ConnectionLookupOrderField{
		Value: func(cl *ConnectionLookup) (ent.Value, error) {
			return cl.CreatedAt, nil
		},
		column: connectionlookup.FieldCreatedAt,
		toTerm: connectionlookup.ByCreatedAt,
		toCursor: func(cl *ConnectionLookup) Cursor {
			return Cursor{
				ID:    cl.ID,
				Value: cl.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ConnectionLookupOrderField) String() string {
	var str string
	switch f.column {
	case ConnectionLookupOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ConnectionLookupOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ConnectionLookupOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ConnectionLookupOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ConnectionLookupOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid ConnectionLookupOrderField", str)
	}
	return nil
}

// ConnectionLookupOrderField defines the ordering field of ConnectionLookup.
type ConnectionLookupOrderField struct {
	// Value extracts the ordering value from the given ConnectionLookup.
	Value    func(*ConnectionLookup) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) connectionlookup.OrderOption
	toCursor func(*ConnectionLookup) Cursor
}

// ConnectionLookupOrder defines the ordering of ConnectionLookup.
type ConnectionLookupOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ConnectionLookupOrderField `json:"field"`
}

// DefaultConnectionLookupOrder is the default ordering of ConnectionLookup.
var DefaultConnectionLookupOrder = &ConnectionLookupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ConnectionLookupOrderField{
		Value: func(cl *ConnectionLookup) (ent.Value, error) {
			return cl.ID, nil
		},
		column: connectionlookup.FieldID,
		toTerm: connectionlookup.ByID,
		toCursor: func(cl *ConnectionLookup) Cursor {
			return Cursor{ID: cl.ID}
		},
	},
}

// ToEdge converts ConnectionLookup into ConnectionLookupEdge.
func (cl *ConnectionLookup) ToEdge(order *ConnectionLookupOrder) *ConnectionLookupEdge {
	if order == nil {
		order = DefaultConnectionLookupOrder
	}
	return &ConnectionLookupEdge{
		Node:   cl,
		Cursor: order.Field.toCursor(cl),
	}
}

// ConnectionShopifyEdge is the edge representation of ConnectionShopify.
type ConnectionShopifyEdge struct {
	Node   *ConnectionShopify `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ConnectionShopifyConnection is the connection containing edges to ConnectionShopify.
type ConnectionShopifyConnection struct {
	Edges      []*ConnectionShopifyEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *ConnectionShopifyConnection) build(nodes []*ConnectionShopify, pager *connectionshopifyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ConnectionShopify
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ConnectionShopify {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ConnectionShopify {
			return nodes[i]
		}
	}
	c.Edges = make([]*ConnectionShopifyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ConnectionShopifyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ConnectionShopifyPaginateOption enables pagination customization.
type ConnectionShopifyPaginateOption func(*connectionshopifyPager) error

// WithConnectionShopifyOrder configures pagination ordering.
func WithConnectionShopifyOrder(order *ConnectionShopifyOrder) ConnectionShopifyPaginateOption {
	if order == nil {
		order = DefaultConnectionShopifyOrder
	}
	o := *order
	return func(pager *connectionshopifyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultConnectionShopifyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithConnectionShopifyFilter configures pagination filter.
func WithConnectionShopifyFilter(filter func(*ConnectionShopifyQuery) (*ConnectionShopifyQuery, error)) ConnectionShopifyPaginateOption {
	return func(pager *connectionshopifyPager) error {
		if filter == nil {
			return errors.New("ConnectionShopifyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type connectionshopifyPager struct {
	reverse bool
	order   *ConnectionShopifyOrder
	filter  func(*ConnectionShopifyQuery) (*ConnectionShopifyQuery, error)
}

func newConnectionShopifyPager(opts []ConnectionShopifyPaginateOption, reverse bool) (*connectionshopifyPager, error) {
	pager := &connectionshopifyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultConnectionShopifyOrder
	}
	return pager, nil
}

func (p *connectionshopifyPager) applyFilter(query *ConnectionShopifyQuery) (*ConnectionShopifyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *connectionshopifyPager) toCursor(cs *ConnectionShopify) Cursor {
	return p.order.Field.toCursor(cs)
}

func (p *connectionshopifyPager) applyCursors(query *ConnectionShopifyQuery, after, before *Cursor) (*ConnectionShopifyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultConnectionShopifyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *connectionshopifyPager) applyOrder(query *ConnectionShopifyQuery) *ConnectionShopifyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultConnectionShopifyOrder.Field {
		query = query.Order(DefaultConnectionShopifyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *connectionshopifyPager) orderExpr(query *ConnectionShopifyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultConnectionShopifyOrder.Field {
			b.Comma().Ident(DefaultConnectionShopifyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ConnectionShopify.
func (cs *ConnectionShopifyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ConnectionShopifyPaginateOption,
) (*ConnectionShopifyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newConnectionShopifyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if cs, err = pager.applyFilter(cs); err != nil {
		return nil, err
	}
	conn := &ConnectionShopifyConnection{Edges: []*ConnectionShopifyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := cs.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if cs, err = pager.applyCursors(cs, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		cs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := cs.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	cs = pager.applyOrder(cs)
	nodes, err := cs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ConnectionShopifyOrderField defines the ordering field of ConnectionShopify.
type ConnectionShopifyOrderField struct {
	// Value extracts the ordering value from the given ConnectionShopify.
	Value    func(*ConnectionShopify) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) connectionshopify.OrderOption
	toCursor func(*ConnectionShopify) Cursor
}

// ConnectionShopifyOrder defines the ordering of ConnectionShopify.
type ConnectionShopifyOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ConnectionShopifyOrderField `json:"field"`
}

// DefaultConnectionShopifyOrder is the default ordering of ConnectionShopify.
var DefaultConnectionShopifyOrder = &ConnectionShopifyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ConnectionShopifyOrderField{
		Value: func(cs *ConnectionShopify) (ent.Value, error) {
			return cs.ID, nil
		},
		column: connectionshopify.FieldID,
		toTerm: connectionshopify.ByID,
		toCursor: func(cs *ConnectionShopify) Cursor {
			return Cursor{ID: cs.ID}
		},
	},
}

// ToEdge converts ConnectionShopify into ConnectionShopifyEdge.
func (cs *ConnectionShopify) ToEdge(order *ConnectionShopifyOrder) *ConnectionShopifyEdge {
	if order == nil {
		order = DefaultConnectionShopifyOrder
	}
	return &ConnectionShopifyEdge{
		Node:   cs,
		Cursor: order.Field.toCursor(cs),
	}
}

// ConsolidationEdge is the edge representation of Consolidation.
type ConsolidationEdge struct {
	Node   *Consolidation `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ConsolidationConnection is the connection containing edges to Consolidation.
type ConsolidationConnection struct {
	Edges      []*ConsolidationEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *ConsolidationConnection) build(nodes []*Consolidation, pager *consolidationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Consolidation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Consolidation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Consolidation {
			return nodes[i]
		}
	}
	c.Edges = make([]*ConsolidationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ConsolidationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ConsolidationPaginateOption enables pagination customization.
type ConsolidationPaginateOption func(*consolidationPager) error

// WithConsolidationOrder configures pagination ordering.
func WithConsolidationOrder(order *ConsolidationOrder) ConsolidationPaginateOption {
	if order == nil {
		order = DefaultConsolidationOrder
	}
	o := *order
	return func(pager *consolidationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultConsolidationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithConsolidationFilter configures pagination filter.
func WithConsolidationFilter(filter func(*ConsolidationQuery) (*ConsolidationQuery, error)) ConsolidationPaginateOption {
	return func(pager *consolidationPager) error {
		if filter == nil {
			return errors.New("ConsolidationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type consolidationPager struct {
	reverse bool
	order   *ConsolidationOrder
	filter  func(*ConsolidationQuery) (*ConsolidationQuery, error)
}

func newConsolidationPager(opts []ConsolidationPaginateOption, reverse bool) (*consolidationPager, error) {
	pager := &consolidationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultConsolidationOrder
	}
	return pager, nil
}

func (p *consolidationPager) applyFilter(query *ConsolidationQuery) (*ConsolidationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *consolidationPager) toCursor(c *Consolidation) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *consolidationPager) applyCursors(query *ConsolidationQuery, after, before *Cursor) (*ConsolidationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultConsolidationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *consolidationPager) applyOrder(query *ConsolidationQuery) *ConsolidationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultConsolidationOrder.Field {
		query = query.Order(DefaultConsolidationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *consolidationPager) orderExpr(query *ConsolidationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultConsolidationOrder.Field {
			b.Comma().Ident(DefaultConsolidationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Consolidation.
func (c *ConsolidationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ConsolidationPaginateOption,
) (*ConsolidationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newConsolidationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ConsolidationConnection{Edges: []*ConsolidationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ConsolidationOrderFieldCreatedAt orders Consolidation by created_at.
	ConsolidationOrderFieldCreatedAt = &ConsolidationOrderField{
		Value: func(c *Consolidation) (ent.Value, error) {
			return c.CreatedAt, nil
		},
		column: consolidation.FieldCreatedAt,
		toTerm: consolidation.ByCreatedAt,
		toCursor: func(c *Consolidation) Cursor {
			return Cursor{
				ID:    c.ID,
				Value: c.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ConsolidationOrderField) String() string {
	var str string
	switch f.column {
	case ConsolidationOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ConsolidationOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ConsolidationOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ConsolidationOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ConsolidationOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid ConsolidationOrderField", str)
	}
	return nil
}

// ConsolidationOrderField defines the ordering field of Consolidation.
type ConsolidationOrderField struct {
	// Value extracts the ordering value from the given Consolidation.
	Value    func(*Consolidation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) consolidation.OrderOption
	toCursor func(*Consolidation) Cursor
}

// ConsolidationOrder defines the ordering of Consolidation.
type ConsolidationOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ConsolidationOrderField `json:"field"`
}

// DefaultConsolidationOrder is the default ordering of Consolidation.
var DefaultConsolidationOrder = &ConsolidationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ConsolidationOrderField{
		Value: func(c *Consolidation) (ent.Value, error) {
			return c.ID, nil
		},
		column: consolidation.FieldID,
		toTerm: consolidation.ByID,
		toCursor: func(c *Consolidation) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Consolidation into ConsolidationEdge.
func (c *Consolidation) ToEdge(order *ConsolidationOrder) *ConsolidationEdge {
	if order == nil {
		order = DefaultConsolidationOrder
	}
	return &ConsolidationEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// ContactEdge is the edge representation of Contact.
type ContactEdge struct {
	Node   *Contact `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ContactConnection is the connection containing edges to Contact.
type ContactConnection struct {
	Edges      []*ContactEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ContactConnection) build(nodes []*Contact, pager *contactPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Contact
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Contact {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Contact {
			return nodes[i]
		}
	}
	c.Edges = make([]*ContactEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ContactEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ContactPaginateOption enables pagination customization.
type ContactPaginateOption func(*contactPager) error

// WithContactOrder configures pagination ordering.
func WithContactOrder(order *ContactOrder) ContactPaginateOption {
	if order == nil {
		order = DefaultContactOrder
	}
	o := *order
	return func(pager *contactPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultContactOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithContactFilter configures pagination filter.
func WithContactFilter(filter func(*ContactQuery) (*ContactQuery, error)) ContactPaginateOption {
	return func(pager *contactPager) error {
		if filter == nil {
			return errors.New("ContactQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type contactPager struct {
	reverse bool
	order   *ContactOrder
	filter  func(*ContactQuery) (*ContactQuery, error)
}

func newContactPager(opts []ContactPaginateOption, reverse bool) (*contactPager, error) {
	pager := &contactPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultContactOrder
	}
	return pager, nil
}

func (p *contactPager) applyFilter(query *ContactQuery) (*ContactQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *contactPager) toCursor(c *Contact) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *contactPager) applyCursors(query *ContactQuery, after, before *Cursor) (*ContactQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultContactOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *contactPager) applyOrder(query *ContactQuery) *ContactQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultContactOrder.Field {
		query = query.Order(DefaultContactOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *contactPager) orderExpr(query *ContactQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultContactOrder.Field {
			b.Comma().Ident(DefaultContactOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Contact.
func (c *ContactQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ContactPaginateOption,
) (*ContactConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newContactPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &ContactConnection{Edges: []*ContactEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ContactOrderField defines the ordering field of Contact.
type ContactOrderField struct {
	// Value extracts the ordering value from the given Contact.
	Value    func(*Contact) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) contact.OrderOption
	toCursor func(*Contact) Cursor
}

// ContactOrder defines the ordering of Contact.
type ContactOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ContactOrderField `json:"field"`
}

// DefaultContactOrder is the default ordering of Contact.
var DefaultContactOrder = &ContactOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ContactOrderField{
		Value: func(c *Contact) (ent.Value, error) {
			return c.ID, nil
		},
		column: contact.FieldID,
		toTerm: contact.ByID,
		toCursor: func(c *Contact) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Contact into ContactEdge.
func (c *Contact) ToEdge(order *ContactOrder) *ContactEdge {
	if order == nil {
		order = DefaultContactOrder
	}
	return &ContactEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CountryEdge is the edge representation of Country.
type CountryEdge struct {
	Node   *Country `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// CountryConnection is the connection containing edges to Country.
type CountryConnection struct {
	Edges      []*CountryEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *CountryConnection) build(nodes []*Country, pager *countryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Country
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Country {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Country {
			return nodes[i]
		}
	}
	c.Edges = make([]*CountryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CountryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CountryPaginateOption enables pagination customization.
type CountryPaginateOption func(*countryPager) error

// WithCountryOrder configures pagination ordering.
func WithCountryOrder(order *CountryOrder) CountryPaginateOption {
	if order == nil {
		order = DefaultCountryOrder
	}
	o := *order
	return func(pager *countryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCountryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCountryFilter configures pagination filter.
func WithCountryFilter(filter func(*CountryQuery) (*CountryQuery, error)) CountryPaginateOption {
	return func(pager *countryPager) error {
		if filter == nil {
			return errors.New("CountryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type countryPager struct {
	reverse bool
	order   *CountryOrder
	filter  func(*CountryQuery) (*CountryQuery, error)
}

func newCountryPager(opts []CountryPaginateOption, reverse bool) (*countryPager, error) {
	pager := &countryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCountryOrder
	}
	return pager, nil
}

func (p *countryPager) applyFilter(query *CountryQuery) (*CountryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *countryPager) toCursor(c *Country) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *countryPager) applyCursors(query *CountryQuery, after, before *Cursor) (*CountryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCountryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *countryPager) applyOrder(query *CountryQuery) *CountryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCountryOrder.Field {
		query = query.Order(DefaultCountryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *countryPager) orderExpr(query *CountryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCountryOrder.Field {
			b.Comma().Ident(DefaultCountryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Country.
func (c *CountryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CountryPaginateOption,
) (*CountryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCountryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CountryConnection{Edges: []*CountryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CountryOrderField defines the ordering field of Country.
type CountryOrderField struct {
	// Value extracts the ordering value from the given Country.
	Value    func(*Country) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) country.OrderOption
	toCursor func(*Country) Cursor
}

// CountryOrder defines the ordering of Country.
type CountryOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *CountryOrderField `json:"field"`
}

// DefaultCountryOrder is the default ordering of Country.
var DefaultCountryOrder = &CountryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CountryOrderField{
		Value: func(c *Country) (ent.Value, error) {
			return c.ID, nil
		},
		column: country.FieldID,
		toTerm: country.ByID,
		toCursor: func(c *Country) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Country into CountryEdge.
func (c *Country) ToEdge(order *CountryOrder) *CountryEdge {
	if order == nil {
		order = DefaultCountryOrder
	}
	return &CountryEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// CountryHarmonizedCodeEdge is the edge representation of CountryHarmonizedCode.
type CountryHarmonizedCodeEdge struct {
	Node   *CountryHarmonizedCode `json:"node"`
	Cursor Cursor                 `json:"cursor"`
}

// CountryHarmonizedCodeConnection is the connection containing edges to CountryHarmonizedCode.
type CountryHarmonizedCodeConnection struct {
	Edges      []*CountryHarmonizedCodeEdge `json:"edges"`
	PageInfo   PageInfo                     `json:"pageInfo"`
	TotalCount int                          `json:"totalCount"`
}

func (c *CountryHarmonizedCodeConnection) build(nodes []*CountryHarmonizedCode, pager *countryharmonizedcodePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *CountryHarmonizedCode
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *CountryHarmonizedCode {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *CountryHarmonizedCode {
			return nodes[i]
		}
	}
	c.Edges = make([]*CountryHarmonizedCodeEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CountryHarmonizedCodeEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CountryHarmonizedCodePaginateOption enables pagination customization.
type CountryHarmonizedCodePaginateOption func(*countryharmonizedcodePager) error

// WithCountryHarmonizedCodeOrder configures pagination ordering.
func WithCountryHarmonizedCodeOrder(order *CountryHarmonizedCodeOrder) CountryHarmonizedCodePaginateOption {
	if order == nil {
		order = DefaultCountryHarmonizedCodeOrder
	}
	o := *order
	return func(pager *countryharmonizedcodePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCountryHarmonizedCodeOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCountryHarmonizedCodeFilter configures pagination filter.
func WithCountryHarmonizedCodeFilter(filter func(*CountryHarmonizedCodeQuery) (*CountryHarmonizedCodeQuery, error)) CountryHarmonizedCodePaginateOption {
	return func(pager *countryharmonizedcodePager) error {
		if filter == nil {
			return errors.New("CountryHarmonizedCodeQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type countryharmonizedcodePager struct {
	reverse bool
	order   *CountryHarmonizedCodeOrder
	filter  func(*CountryHarmonizedCodeQuery) (*CountryHarmonizedCodeQuery, error)
}

func newCountryHarmonizedCodePager(opts []CountryHarmonizedCodePaginateOption, reverse bool) (*countryharmonizedcodePager, error) {
	pager := &countryharmonizedcodePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCountryHarmonizedCodeOrder
	}
	return pager, nil
}

func (p *countryharmonizedcodePager) applyFilter(query *CountryHarmonizedCodeQuery) (*CountryHarmonizedCodeQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *countryharmonizedcodePager) toCursor(chc *CountryHarmonizedCode) Cursor {
	return p.order.Field.toCursor(chc)
}

func (p *countryharmonizedcodePager) applyCursors(query *CountryHarmonizedCodeQuery, after, before *Cursor) (*CountryHarmonizedCodeQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCountryHarmonizedCodeOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *countryharmonizedcodePager) applyOrder(query *CountryHarmonizedCodeQuery) *CountryHarmonizedCodeQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCountryHarmonizedCodeOrder.Field {
		query = query.Order(DefaultCountryHarmonizedCodeOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *countryharmonizedcodePager) orderExpr(query *CountryHarmonizedCodeQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCountryHarmonizedCodeOrder.Field {
			b.Comma().Ident(DefaultCountryHarmonizedCodeOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to CountryHarmonizedCode.
func (chc *CountryHarmonizedCodeQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CountryHarmonizedCodePaginateOption,
) (*CountryHarmonizedCodeConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCountryHarmonizedCodePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if chc, err = pager.applyFilter(chc); err != nil {
		return nil, err
	}
	conn := &CountryHarmonizedCodeConnection{Edges: []*CountryHarmonizedCodeEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := chc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if chc, err = pager.applyCursors(chc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		chc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := chc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	chc = pager.applyOrder(chc)
	nodes, err := chc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CountryHarmonizedCodeOrderField defines the ordering field of CountryHarmonizedCode.
type CountryHarmonizedCodeOrderField struct {
	// Value extracts the ordering value from the given CountryHarmonizedCode.
	Value    func(*CountryHarmonizedCode) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) countryharmonizedcode.OrderOption
	toCursor func(*CountryHarmonizedCode) Cursor
}

// CountryHarmonizedCodeOrder defines the ordering of CountryHarmonizedCode.
type CountryHarmonizedCodeOrder struct {
	Direction OrderDirection                   `json:"direction"`
	Field     *CountryHarmonizedCodeOrderField `json:"field"`
}

// DefaultCountryHarmonizedCodeOrder is the default ordering of CountryHarmonizedCode.
var DefaultCountryHarmonizedCodeOrder = &CountryHarmonizedCodeOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CountryHarmonizedCodeOrderField{
		Value: func(chc *CountryHarmonizedCode) (ent.Value, error) {
			return chc.ID, nil
		},
		column: countryharmonizedcode.FieldID,
		toTerm: countryharmonizedcode.ByID,
		toCursor: func(chc *CountryHarmonizedCode) Cursor {
			return Cursor{ID: chc.ID}
		},
	},
}

// ToEdge converts CountryHarmonizedCode into CountryHarmonizedCodeEdge.
func (chc *CountryHarmonizedCode) ToEdge(order *CountryHarmonizedCodeOrder) *CountryHarmonizedCodeEdge {
	if order == nil {
		order = DefaultCountryHarmonizedCodeOrder
	}
	return &CountryHarmonizedCodeEdge{
		Node:   chc,
		Cursor: order.Field.toCursor(chc),
	}
}

// CurrencyEdge is the edge representation of Currency.
type CurrencyEdge struct {
	Node   *Currency `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// CurrencyConnection is the connection containing edges to Currency.
type CurrencyConnection struct {
	Edges      []*CurrencyEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *CurrencyConnection) build(nodes []*Currency, pager *currencyPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Currency
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Currency {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Currency {
			return nodes[i]
		}
	}
	c.Edges = make([]*CurrencyEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &CurrencyEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// CurrencyPaginateOption enables pagination customization.
type CurrencyPaginateOption func(*currencyPager) error

// WithCurrencyOrder configures pagination ordering.
func WithCurrencyOrder(order *CurrencyOrder) CurrencyPaginateOption {
	if order == nil {
		order = DefaultCurrencyOrder
	}
	o := *order
	return func(pager *currencyPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultCurrencyOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithCurrencyFilter configures pagination filter.
func WithCurrencyFilter(filter func(*CurrencyQuery) (*CurrencyQuery, error)) CurrencyPaginateOption {
	return func(pager *currencyPager) error {
		if filter == nil {
			return errors.New("CurrencyQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type currencyPager struct {
	reverse bool
	order   *CurrencyOrder
	filter  func(*CurrencyQuery) (*CurrencyQuery, error)
}

func newCurrencyPager(opts []CurrencyPaginateOption, reverse bool) (*currencyPager, error) {
	pager := &currencyPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultCurrencyOrder
	}
	return pager, nil
}

func (p *currencyPager) applyFilter(query *CurrencyQuery) (*CurrencyQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *currencyPager) toCursor(c *Currency) Cursor {
	return p.order.Field.toCursor(c)
}

func (p *currencyPager) applyCursors(query *CurrencyQuery, after, before *Cursor) (*CurrencyQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultCurrencyOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *currencyPager) applyOrder(query *CurrencyQuery) *CurrencyQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultCurrencyOrder.Field {
		query = query.Order(DefaultCurrencyOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *currencyPager) orderExpr(query *CurrencyQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultCurrencyOrder.Field {
			b.Comma().Ident(DefaultCurrencyOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Currency.
func (c *CurrencyQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...CurrencyPaginateOption,
) (*CurrencyConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newCurrencyPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if c, err = pager.applyFilter(c); err != nil {
		return nil, err
	}
	conn := &CurrencyConnection{Edges: []*CurrencyEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := c.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if c, err = pager.applyCursors(c, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		c.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := c.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	c = pager.applyOrder(c)
	nodes, err := c.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// CurrencyOrderField defines the ordering field of Currency.
type CurrencyOrderField struct {
	// Value extracts the ordering value from the given Currency.
	Value    func(*Currency) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) currency.OrderOption
	toCursor func(*Currency) Cursor
}

// CurrencyOrder defines the ordering of Currency.
type CurrencyOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *CurrencyOrderField `json:"field"`
}

// DefaultCurrencyOrder is the default ordering of Currency.
var DefaultCurrencyOrder = &CurrencyOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &CurrencyOrderField{
		Value: func(c *Currency) (ent.Value, error) {
			return c.ID, nil
		},
		column: currency.FieldID,
		toTerm: currency.ByID,
		toCursor: func(c *Currency) Cursor {
			return Cursor{ID: c.ID}
		},
	},
}

// ToEdge converts Currency into CurrencyEdge.
func (c *Currency) ToEdge(order *CurrencyOrder) *CurrencyEdge {
	if order == nil {
		order = DefaultCurrencyOrder
	}
	return &CurrencyEdge{
		Node:   c,
		Cursor: order.Field.toCursor(c),
	}
}

// DeliveryOptionEdge is the edge representation of DeliveryOption.
type DeliveryOptionEdge struct {
	Node   *DeliveryOption `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// DeliveryOptionConnection is the connection containing edges to DeliveryOption.
type DeliveryOptionConnection struct {
	Edges      []*DeliveryOptionEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *DeliveryOptionConnection) build(nodes []*DeliveryOption, pager *deliveryoptionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryOption
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryOption {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryOption {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryOptionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryOptionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryOptionPaginateOption enables pagination customization.
type DeliveryOptionPaginateOption func(*deliveryoptionPager) error

// WithDeliveryOptionOrder configures pagination ordering.
func WithDeliveryOptionOrder(order *DeliveryOptionOrder) DeliveryOptionPaginateOption {
	if order == nil {
		order = DefaultDeliveryOptionOrder
	}
	o := *order
	return func(pager *deliveryoptionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryOptionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryOptionFilter configures pagination filter.
func WithDeliveryOptionFilter(filter func(*DeliveryOptionQuery) (*DeliveryOptionQuery, error)) DeliveryOptionPaginateOption {
	return func(pager *deliveryoptionPager) error {
		if filter == nil {
			return errors.New("DeliveryOptionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryoptionPager struct {
	reverse bool
	order   *DeliveryOptionOrder
	filter  func(*DeliveryOptionQuery) (*DeliveryOptionQuery, error)
}

func newDeliveryOptionPager(opts []DeliveryOptionPaginateOption, reverse bool) (*deliveryoptionPager, error) {
	pager := &deliveryoptionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryOptionOrder
	}
	return pager, nil
}

func (p *deliveryoptionPager) applyFilter(query *DeliveryOptionQuery) (*DeliveryOptionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryoptionPager) toCursor(do *DeliveryOption) Cursor {
	return p.order.Field.toCursor(do)
}

func (p *deliveryoptionPager) applyCursors(query *DeliveryOptionQuery, after, before *Cursor) (*DeliveryOptionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryOptionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryoptionPager) applyOrder(query *DeliveryOptionQuery) *DeliveryOptionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryOptionOrder.Field {
		query = query.Order(DefaultDeliveryOptionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryoptionPager) orderExpr(query *DeliveryOptionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryOptionOrder.Field {
			b.Comma().Ident(DefaultDeliveryOptionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryOption.
func (do *DeliveryOptionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryOptionPaginateOption,
) (*DeliveryOptionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryOptionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if do, err = pager.applyFilter(do); err != nil {
		return nil, err
	}
	conn := &DeliveryOptionConnection{Edges: []*DeliveryOptionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := do.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if do, err = pager.applyCursors(do, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		do.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := do.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	do = pager.applyOrder(do)
	nodes, err := do.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryOptionOrderField defines the ordering field of DeliveryOption.
type DeliveryOptionOrderField struct {
	// Value extracts the ordering value from the given DeliveryOption.
	Value    func(*DeliveryOption) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryoption.OrderOption
	toCursor func(*DeliveryOption) Cursor
}

// DeliveryOptionOrder defines the ordering of DeliveryOption.
type DeliveryOptionOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *DeliveryOptionOrderField `json:"field"`
}

// DefaultDeliveryOptionOrder is the default ordering of DeliveryOption.
var DefaultDeliveryOptionOrder = &DeliveryOptionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryOptionOrderField{
		Value: func(do *DeliveryOption) (ent.Value, error) {
			return do.ID, nil
		},
		column: deliveryoption.FieldID,
		toTerm: deliveryoption.ByID,
		toCursor: func(do *DeliveryOption) Cursor {
			return Cursor{ID: do.ID}
		},
	},
}

// ToEdge converts DeliveryOption into DeliveryOptionEdge.
func (do *DeliveryOption) ToEdge(order *DeliveryOptionOrder) *DeliveryOptionEdge {
	if order == nil {
		order = DefaultDeliveryOptionOrder
	}
	return &DeliveryOptionEdge{
		Node:   do,
		Cursor: order.Field.toCursor(do),
	}
}

// DeliveryOptionBringEdge is the edge representation of DeliveryOptionBring.
type DeliveryOptionBringEdge struct {
	Node   *DeliveryOptionBring `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// DeliveryOptionBringConnection is the connection containing edges to DeliveryOptionBring.
type DeliveryOptionBringConnection struct {
	Edges      []*DeliveryOptionBringEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *DeliveryOptionBringConnection) build(nodes []*DeliveryOptionBring, pager *deliveryoptionbringPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryOptionBring
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryOptionBring {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryOptionBring {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryOptionBringEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryOptionBringEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryOptionBringPaginateOption enables pagination customization.
type DeliveryOptionBringPaginateOption func(*deliveryoptionbringPager) error

// WithDeliveryOptionBringOrder configures pagination ordering.
func WithDeliveryOptionBringOrder(order *DeliveryOptionBringOrder) DeliveryOptionBringPaginateOption {
	if order == nil {
		order = DefaultDeliveryOptionBringOrder
	}
	o := *order
	return func(pager *deliveryoptionbringPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryOptionBringOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryOptionBringFilter configures pagination filter.
func WithDeliveryOptionBringFilter(filter func(*DeliveryOptionBringQuery) (*DeliveryOptionBringQuery, error)) DeliveryOptionBringPaginateOption {
	return func(pager *deliveryoptionbringPager) error {
		if filter == nil {
			return errors.New("DeliveryOptionBringQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryoptionbringPager struct {
	reverse bool
	order   *DeliveryOptionBringOrder
	filter  func(*DeliveryOptionBringQuery) (*DeliveryOptionBringQuery, error)
}

func newDeliveryOptionBringPager(opts []DeliveryOptionBringPaginateOption, reverse bool) (*deliveryoptionbringPager, error) {
	pager := &deliveryoptionbringPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryOptionBringOrder
	}
	return pager, nil
}

func (p *deliveryoptionbringPager) applyFilter(query *DeliveryOptionBringQuery) (*DeliveryOptionBringQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryoptionbringPager) toCursor(dob *DeliveryOptionBring) Cursor {
	return p.order.Field.toCursor(dob)
}

func (p *deliveryoptionbringPager) applyCursors(query *DeliveryOptionBringQuery, after, before *Cursor) (*DeliveryOptionBringQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryOptionBringOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryoptionbringPager) applyOrder(query *DeliveryOptionBringQuery) *DeliveryOptionBringQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryOptionBringOrder.Field {
		query = query.Order(DefaultDeliveryOptionBringOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryoptionbringPager) orderExpr(query *DeliveryOptionBringQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryOptionBringOrder.Field {
			b.Comma().Ident(DefaultDeliveryOptionBringOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryOptionBring.
func (dob *DeliveryOptionBringQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryOptionBringPaginateOption,
) (*DeliveryOptionBringConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryOptionBringPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dob, err = pager.applyFilter(dob); err != nil {
		return nil, err
	}
	conn := &DeliveryOptionBringConnection{Edges: []*DeliveryOptionBringEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dob.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dob, err = pager.applyCursors(dob, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dob.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dob.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dob = pager.applyOrder(dob)
	nodes, err := dob.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryOptionBringOrderField defines the ordering field of DeliveryOptionBring.
type DeliveryOptionBringOrderField struct {
	// Value extracts the ordering value from the given DeliveryOptionBring.
	Value    func(*DeliveryOptionBring) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryoptionbring.OrderOption
	toCursor func(*DeliveryOptionBring) Cursor
}

// DeliveryOptionBringOrder defines the ordering of DeliveryOptionBring.
type DeliveryOptionBringOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *DeliveryOptionBringOrderField `json:"field"`
}

// DefaultDeliveryOptionBringOrder is the default ordering of DeliveryOptionBring.
var DefaultDeliveryOptionBringOrder = &DeliveryOptionBringOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryOptionBringOrderField{
		Value: func(dob *DeliveryOptionBring) (ent.Value, error) {
			return dob.ID, nil
		},
		column: deliveryoptionbring.FieldID,
		toTerm: deliveryoptionbring.ByID,
		toCursor: func(dob *DeliveryOptionBring) Cursor {
			return Cursor{ID: dob.ID}
		},
	},
}

// ToEdge converts DeliveryOptionBring into DeliveryOptionBringEdge.
func (dob *DeliveryOptionBring) ToEdge(order *DeliveryOptionBringOrder) *DeliveryOptionBringEdge {
	if order == nil {
		order = DefaultDeliveryOptionBringOrder
	}
	return &DeliveryOptionBringEdge{
		Node:   dob,
		Cursor: order.Field.toCursor(dob),
	}
}

// DeliveryOptionDAOEdge is the edge representation of DeliveryOptionDAO.
type DeliveryOptionDAOEdge struct {
	Node   *DeliveryOptionDAO `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// DeliveryOptionDAOConnection is the connection containing edges to DeliveryOptionDAO.
type DeliveryOptionDAOConnection struct {
	Edges      []*DeliveryOptionDAOEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *DeliveryOptionDAOConnection) build(nodes []*DeliveryOptionDAO, pager *deliveryoptiondaoPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryOptionDAO
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryOptionDAO {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryOptionDAO {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryOptionDAOEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryOptionDAOEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryOptionDAOPaginateOption enables pagination customization.
type DeliveryOptionDAOPaginateOption func(*deliveryoptiondaoPager) error

// WithDeliveryOptionDAOOrder configures pagination ordering.
func WithDeliveryOptionDAOOrder(order *DeliveryOptionDAOOrder) DeliveryOptionDAOPaginateOption {
	if order == nil {
		order = DefaultDeliveryOptionDAOOrder
	}
	o := *order
	return func(pager *deliveryoptiondaoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryOptionDAOOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryOptionDAOFilter configures pagination filter.
func WithDeliveryOptionDAOFilter(filter func(*DeliveryOptionDAOQuery) (*DeliveryOptionDAOQuery, error)) DeliveryOptionDAOPaginateOption {
	return func(pager *deliveryoptiondaoPager) error {
		if filter == nil {
			return errors.New("DeliveryOptionDAOQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryoptiondaoPager struct {
	reverse bool
	order   *DeliveryOptionDAOOrder
	filter  func(*DeliveryOptionDAOQuery) (*DeliveryOptionDAOQuery, error)
}

func newDeliveryOptionDAOPager(opts []DeliveryOptionDAOPaginateOption, reverse bool) (*deliveryoptiondaoPager, error) {
	pager := &deliveryoptiondaoPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryOptionDAOOrder
	}
	return pager, nil
}

func (p *deliveryoptiondaoPager) applyFilter(query *DeliveryOptionDAOQuery) (*DeliveryOptionDAOQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryoptiondaoPager) toCursor(dod *DeliveryOptionDAO) Cursor {
	return p.order.Field.toCursor(dod)
}

func (p *deliveryoptiondaoPager) applyCursors(query *DeliveryOptionDAOQuery, after, before *Cursor) (*DeliveryOptionDAOQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryOptionDAOOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryoptiondaoPager) applyOrder(query *DeliveryOptionDAOQuery) *DeliveryOptionDAOQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryOptionDAOOrder.Field {
		query = query.Order(DefaultDeliveryOptionDAOOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryoptiondaoPager) orderExpr(query *DeliveryOptionDAOQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryOptionDAOOrder.Field {
			b.Comma().Ident(DefaultDeliveryOptionDAOOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryOptionDAO.
func (dod *DeliveryOptionDAOQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryOptionDAOPaginateOption,
) (*DeliveryOptionDAOConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryOptionDAOPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dod, err = pager.applyFilter(dod); err != nil {
		return nil, err
	}
	conn := &DeliveryOptionDAOConnection{Edges: []*DeliveryOptionDAOEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dod.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dod, err = pager.applyCursors(dod, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dod.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dod.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dod = pager.applyOrder(dod)
	nodes, err := dod.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryOptionDAOOrderField defines the ordering field of DeliveryOptionDAO.
type DeliveryOptionDAOOrderField struct {
	// Value extracts the ordering value from the given DeliveryOptionDAO.
	Value    func(*DeliveryOptionDAO) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryoptiondao.OrderOption
	toCursor func(*DeliveryOptionDAO) Cursor
}

// DeliveryOptionDAOOrder defines the ordering of DeliveryOptionDAO.
type DeliveryOptionDAOOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *DeliveryOptionDAOOrderField `json:"field"`
}

// DefaultDeliveryOptionDAOOrder is the default ordering of DeliveryOptionDAO.
var DefaultDeliveryOptionDAOOrder = &DeliveryOptionDAOOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryOptionDAOOrderField{
		Value: func(dod *DeliveryOptionDAO) (ent.Value, error) {
			return dod.ID, nil
		},
		column: deliveryoptiondao.FieldID,
		toTerm: deliveryoptiondao.ByID,
		toCursor: func(dod *DeliveryOptionDAO) Cursor {
			return Cursor{ID: dod.ID}
		},
	},
}

// ToEdge converts DeliveryOptionDAO into DeliveryOptionDAOEdge.
func (dod *DeliveryOptionDAO) ToEdge(order *DeliveryOptionDAOOrder) *DeliveryOptionDAOEdge {
	if order == nil {
		order = DefaultDeliveryOptionDAOOrder
	}
	return &DeliveryOptionDAOEdge{
		Node:   dod,
		Cursor: order.Field.toCursor(dod),
	}
}

// DeliveryOptionDFEdge is the edge representation of DeliveryOptionDF.
type DeliveryOptionDFEdge struct {
	Node   *DeliveryOptionDF `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// DeliveryOptionDFConnection is the connection containing edges to DeliveryOptionDF.
type DeliveryOptionDFConnection struct {
	Edges      []*DeliveryOptionDFEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *DeliveryOptionDFConnection) build(nodes []*DeliveryOptionDF, pager *deliveryoptiondfPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryOptionDF
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryOptionDF {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryOptionDF {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryOptionDFEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryOptionDFEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryOptionDFPaginateOption enables pagination customization.
type DeliveryOptionDFPaginateOption func(*deliveryoptiondfPager) error

// WithDeliveryOptionDFOrder configures pagination ordering.
func WithDeliveryOptionDFOrder(order *DeliveryOptionDFOrder) DeliveryOptionDFPaginateOption {
	if order == nil {
		order = DefaultDeliveryOptionDFOrder
	}
	o := *order
	return func(pager *deliveryoptiondfPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryOptionDFOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryOptionDFFilter configures pagination filter.
func WithDeliveryOptionDFFilter(filter func(*DeliveryOptionDFQuery) (*DeliveryOptionDFQuery, error)) DeliveryOptionDFPaginateOption {
	return func(pager *deliveryoptiondfPager) error {
		if filter == nil {
			return errors.New("DeliveryOptionDFQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryoptiondfPager struct {
	reverse bool
	order   *DeliveryOptionDFOrder
	filter  func(*DeliveryOptionDFQuery) (*DeliveryOptionDFQuery, error)
}

func newDeliveryOptionDFPager(opts []DeliveryOptionDFPaginateOption, reverse bool) (*deliveryoptiondfPager, error) {
	pager := &deliveryoptiondfPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryOptionDFOrder
	}
	return pager, nil
}

func (p *deliveryoptiondfPager) applyFilter(query *DeliveryOptionDFQuery) (*DeliveryOptionDFQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryoptiondfPager) toCursor(dod *DeliveryOptionDF) Cursor {
	return p.order.Field.toCursor(dod)
}

func (p *deliveryoptiondfPager) applyCursors(query *DeliveryOptionDFQuery, after, before *Cursor) (*DeliveryOptionDFQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryOptionDFOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryoptiondfPager) applyOrder(query *DeliveryOptionDFQuery) *DeliveryOptionDFQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryOptionDFOrder.Field {
		query = query.Order(DefaultDeliveryOptionDFOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryoptiondfPager) orderExpr(query *DeliveryOptionDFQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryOptionDFOrder.Field {
			b.Comma().Ident(DefaultDeliveryOptionDFOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryOptionDF.
func (dod *DeliveryOptionDFQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryOptionDFPaginateOption,
) (*DeliveryOptionDFConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryOptionDFPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dod, err = pager.applyFilter(dod); err != nil {
		return nil, err
	}
	conn := &DeliveryOptionDFConnection{Edges: []*DeliveryOptionDFEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dod.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dod, err = pager.applyCursors(dod, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dod.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dod.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dod = pager.applyOrder(dod)
	nodes, err := dod.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryOptionDFOrderField defines the ordering field of DeliveryOptionDF.
type DeliveryOptionDFOrderField struct {
	// Value extracts the ordering value from the given DeliveryOptionDF.
	Value    func(*DeliveryOptionDF) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryoptiondf.OrderOption
	toCursor func(*DeliveryOptionDF) Cursor
}

// DeliveryOptionDFOrder defines the ordering of DeliveryOptionDF.
type DeliveryOptionDFOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *DeliveryOptionDFOrderField `json:"field"`
}

// DefaultDeliveryOptionDFOrder is the default ordering of DeliveryOptionDF.
var DefaultDeliveryOptionDFOrder = &DeliveryOptionDFOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryOptionDFOrderField{
		Value: func(dod *DeliveryOptionDF) (ent.Value, error) {
			return dod.ID, nil
		},
		column: deliveryoptiondf.FieldID,
		toTerm: deliveryoptiondf.ByID,
		toCursor: func(dod *DeliveryOptionDF) Cursor {
			return Cursor{ID: dod.ID}
		},
	},
}

// ToEdge converts DeliveryOptionDF into DeliveryOptionDFEdge.
func (dod *DeliveryOptionDF) ToEdge(order *DeliveryOptionDFOrder) *DeliveryOptionDFEdge {
	if order == nil {
		order = DefaultDeliveryOptionDFOrder
	}
	return &DeliveryOptionDFEdge{
		Node:   dod,
		Cursor: order.Field.toCursor(dod),
	}
}

// DeliveryOptionDSVEdge is the edge representation of DeliveryOptionDSV.
type DeliveryOptionDSVEdge struct {
	Node   *DeliveryOptionDSV `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// DeliveryOptionDSVConnection is the connection containing edges to DeliveryOptionDSV.
type DeliveryOptionDSVConnection struct {
	Edges      []*DeliveryOptionDSVEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *DeliveryOptionDSVConnection) build(nodes []*DeliveryOptionDSV, pager *deliveryoptiondsvPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryOptionDSV
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryOptionDSV {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryOptionDSV {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryOptionDSVEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryOptionDSVEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryOptionDSVPaginateOption enables pagination customization.
type DeliveryOptionDSVPaginateOption func(*deliveryoptiondsvPager) error

// WithDeliveryOptionDSVOrder configures pagination ordering.
func WithDeliveryOptionDSVOrder(order *DeliveryOptionDSVOrder) DeliveryOptionDSVPaginateOption {
	if order == nil {
		order = DefaultDeliveryOptionDSVOrder
	}
	o := *order
	return func(pager *deliveryoptiondsvPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryOptionDSVOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryOptionDSVFilter configures pagination filter.
func WithDeliveryOptionDSVFilter(filter func(*DeliveryOptionDSVQuery) (*DeliveryOptionDSVQuery, error)) DeliveryOptionDSVPaginateOption {
	return func(pager *deliveryoptiondsvPager) error {
		if filter == nil {
			return errors.New("DeliveryOptionDSVQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryoptiondsvPager struct {
	reverse bool
	order   *DeliveryOptionDSVOrder
	filter  func(*DeliveryOptionDSVQuery) (*DeliveryOptionDSVQuery, error)
}

func newDeliveryOptionDSVPager(opts []DeliveryOptionDSVPaginateOption, reverse bool) (*deliveryoptiondsvPager, error) {
	pager := &deliveryoptiondsvPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryOptionDSVOrder
	}
	return pager, nil
}

func (p *deliveryoptiondsvPager) applyFilter(query *DeliveryOptionDSVQuery) (*DeliveryOptionDSVQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryoptiondsvPager) toCursor(dod *DeliveryOptionDSV) Cursor {
	return p.order.Field.toCursor(dod)
}

func (p *deliveryoptiondsvPager) applyCursors(query *DeliveryOptionDSVQuery, after, before *Cursor) (*DeliveryOptionDSVQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryOptionDSVOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryoptiondsvPager) applyOrder(query *DeliveryOptionDSVQuery) *DeliveryOptionDSVQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryOptionDSVOrder.Field {
		query = query.Order(DefaultDeliveryOptionDSVOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryoptiondsvPager) orderExpr(query *DeliveryOptionDSVQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryOptionDSVOrder.Field {
			b.Comma().Ident(DefaultDeliveryOptionDSVOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryOptionDSV.
func (dod *DeliveryOptionDSVQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryOptionDSVPaginateOption,
) (*DeliveryOptionDSVConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryOptionDSVPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dod, err = pager.applyFilter(dod); err != nil {
		return nil, err
	}
	conn := &DeliveryOptionDSVConnection{Edges: []*DeliveryOptionDSVEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dod.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dod, err = pager.applyCursors(dod, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dod.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dod.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dod = pager.applyOrder(dod)
	nodes, err := dod.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryOptionDSVOrderField defines the ordering field of DeliveryOptionDSV.
type DeliveryOptionDSVOrderField struct {
	// Value extracts the ordering value from the given DeliveryOptionDSV.
	Value    func(*DeliveryOptionDSV) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryoptiondsv.OrderOption
	toCursor func(*DeliveryOptionDSV) Cursor
}

// DeliveryOptionDSVOrder defines the ordering of DeliveryOptionDSV.
type DeliveryOptionDSVOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *DeliveryOptionDSVOrderField `json:"field"`
}

// DefaultDeliveryOptionDSVOrder is the default ordering of DeliveryOptionDSV.
var DefaultDeliveryOptionDSVOrder = &DeliveryOptionDSVOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryOptionDSVOrderField{
		Value: func(dod *DeliveryOptionDSV) (ent.Value, error) {
			return dod.ID, nil
		},
		column: deliveryoptiondsv.FieldID,
		toTerm: deliveryoptiondsv.ByID,
		toCursor: func(dod *DeliveryOptionDSV) Cursor {
			return Cursor{ID: dod.ID}
		},
	},
}

// ToEdge converts DeliveryOptionDSV into DeliveryOptionDSVEdge.
func (dod *DeliveryOptionDSV) ToEdge(order *DeliveryOptionDSVOrder) *DeliveryOptionDSVEdge {
	if order == nil {
		order = DefaultDeliveryOptionDSVOrder
	}
	return &DeliveryOptionDSVEdge{
		Node:   dod,
		Cursor: order.Field.toCursor(dod),
	}
}

// DeliveryOptionEasyPostEdge is the edge representation of DeliveryOptionEasyPost.
type DeliveryOptionEasyPostEdge struct {
	Node   *DeliveryOptionEasyPost `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// DeliveryOptionEasyPostConnection is the connection containing edges to DeliveryOptionEasyPost.
type DeliveryOptionEasyPostConnection struct {
	Edges      []*DeliveryOptionEasyPostEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *DeliveryOptionEasyPostConnection) build(nodes []*DeliveryOptionEasyPost, pager *deliveryoptioneasypostPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryOptionEasyPost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryOptionEasyPost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryOptionEasyPost {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryOptionEasyPostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryOptionEasyPostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryOptionEasyPostPaginateOption enables pagination customization.
type DeliveryOptionEasyPostPaginateOption func(*deliveryoptioneasypostPager) error

// WithDeliveryOptionEasyPostOrder configures pagination ordering.
func WithDeliveryOptionEasyPostOrder(order *DeliveryOptionEasyPostOrder) DeliveryOptionEasyPostPaginateOption {
	if order == nil {
		order = DefaultDeliveryOptionEasyPostOrder
	}
	o := *order
	return func(pager *deliveryoptioneasypostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryOptionEasyPostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryOptionEasyPostFilter configures pagination filter.
func WithDeliveryOptionEasyPostFilter(filter func(*DeliveryOptionEasyPostQuery) (*DeliveryOptionEasyPostQuery, error)) DeliveryOptionEasyPostPaginateOption {
	return func(pager *deliveryoptioneasypostPager) error {
		if filter == nil {
			return errors.New("DeliveryOptionEasyPostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryoptioneasypostPager struct {
	reverse bool
	order   *DeliveryOptionEasyPostOrder
	filter  func(*DeliveryOptionEasyPostQuery) (*DeliveryOptionEasyPostQuery, error)
}

func newDeliveryOptionEasyPostPager(opts []DeliveryOptionEasyPostPaginateOption, reverse bool) (*deliveryoptioneasypostPager, error) {
	pager := &deliveryoptioneasypostPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryOptionEasyPostOrder
	}
	return pager, nil
}

func (p *deliveryoptioneasypostPager) applyFilter(query *DeliveryOptionEasyPostQuery) (*DeliveryOptionEasyPostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryoptioneasypostPager) toCursor(doep *DeliveryOptionEasyPost) Cursor {
	return p.order.Field.toCursor(doep)
}

func (p *deliveryoptioneasypostPager) applyCursors(query *DeliveryOptionEasyPostQuery, after, before *Cursor) (*DeliveryOptionEasyPostQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryOptionEasyPostOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryoptioneasypostPager) applyOrder(query *DeliveryOptionEasyPostQuery) *DeliveryOptionEasyPostQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryOptionEasyPostOrder.Field {
		query = query.Order(DefaultDeliveryOptionEasyPostOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryoptioneasypostPager) orderExpr(query *DeliveryOptionEasyPostQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryOptionEasyPostOrder.Field {
			b.Comma().Ident(DefaultDeliveryOptionEasyPostOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryOptionEasyPost.
func (doep *DeliveryOptionEasyPostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryOptionEasyPostPaginateOption,
) (*DeliveryOptionEasyPostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryOptionEasyPostPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if doep, err = pager.applyFilter(doep); err != nil {
		return nil, err
	}
	conn := &DeliveryOptionEasyPostConnection{Edges: []*DeliveryOptionEasyPostEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := doep.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if doep, err = pager.applyCursors(doep, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		doep.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := doep.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	doep = pager.applyOrder(doep)
	nodes, err := doep.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryOptionEasyPostOrderField defines the ordering field of DeliveryOptionEasyPost.
type DeliveryOptionEasyPostOrderField struct {
	// Value extracts the ordering value from the given DeliveryOptionEasyPost.
	Value    func(*DeliveryOptionEasyPost) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryoptioneasypost.OrderOption
	toCursor func(*DeliveryOptionEasyPost) Cursor
}

// DeliveryOptionEasyPostOrder defines the ordering of DeliveryOptionEasyPost.
type DeliveryOptionEasyPostOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *DeliveryOptionEasyPostOrderField `json:"field"`
}

// DefaultDeliveryOptionEasyPostOrder is the default ordering of DeliveryOptionEasyPost.
var DefaultDeliveryOptionEasyPostOrder = &DeliveryOptionEasyPostOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryOptionEasyPostOrderField{
		Value: func(doep *DeliveryOptionEasyPost) (ent.Value, error) {
			return doep.ID, nil
		},
		column: deliveryoptioneasypost.FieldID,
		toTerm: deliveryoptioneasypost.ByID,
		toCursor: func(doep *DeliveryOptionEasyPost) Cursor {
			return Cursor{ID: doep.ID}
		},
	},
}

// ToEdge converts DeliveryOptionEasyPost into DeliveryOptionEasyPostEdge.
func (doep *DeliveryOptionEasyPost) ToEdge(order *DeliveryOptionEasyPostOrder) *DeliveryOptionEasyPostEdge {
	if order == nil {
		order = DefaultDeliveryOptionEasyPostOrder
	}
	return &DeliveryOptionEasyPostEdge{
		Node:   doep,
		Cursor: order.Field.toCursor(doep),
	}
}

// DeliveryOptionGLSEdge is the edge representation of DeliveryOptionGLS.
type DeliveryOptionGLSEdge struct {
	Node   *DeliveryOptionGLS `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// DeliveryOptionGLSConnection is the connection containing edges to DeliveryOptionGLS.
type DeliveryOptionGLSConnection struct {
	Edges      []*DeliveryOptionGLSEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *DeliveryOptionGLSConnection) build(nodes []*DeliveryOptionGLS, pager *deliveryoptionglsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryOptionGLS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryOptionGLS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryOptionGLS {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryOptionGLSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryOptionGLSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryOptionGLSPaginateOption enables pagination customization.
type DeliveryOptionGLSPaginateOption func(*deliveryoptionglsPager) error

// WithDeliveryOptionGLSOrder configures pagination ordering.
func WithDeliveryOptionGLSOrder(order *DeliveryOptionGLSOrder) DeliveryOptionGLSPaginateOption {
	if order == nil {
		order = DefaultDeliveryOptionGLSOrder
	}
	o := *order
	return func(pager *deliveryoptionglsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryOptionGLSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryOptionGLSFilter configures pagination filter.
func WithDeliveryOptionGLSFilter(filter func(*DeliveryOptionGLSQuery) (*DeliveryOptionGLSQuery, error)) DeliveryOptionGLSPaginateOption {
	return func(pager *deliveryoptionglsPager) error {
		if filter == nil {
			return errors.New("DeliveryOptionGLSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryoptionglsPager struct {
	reverse bool
	order   *DeliveryOptionGLSOrder
	filter  func(*DeliveryOptionGLSQuery) (*DeliveryOptionGLSQuery, error)
}

func newDeliveryOptionGLSPager(opts []DeliveryOptionGLSPaginateOption, reverse bool) (*deliveryoptionglsPager, error) {
	pager := &deliveryoptionglsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryOptionGLSOrder
	}
	return pager, nil
}

func (p *deliveryoptionglsPager) applyFilter(query *DeliveryOptionGLSQuery) (*DeliveryOptionGLSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryoptionglsPager) toCursor(dog *DeliveryOptionGLS) Cursor {
	return p.order.Field.toCursor(dog)
}

func (p *deliveryoptionglsPager) applyCursors(query *DeliveryOptionGLSQuery, after, before *Cursor) (*DeliveryOptionGLSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryOptionGLSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryoptionglsPager) applyOrder(query *DeliveryOptionGLSQuery) *DeliveryOptionGLSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryOptionGLSOrder.Field {
		query = query.Order(DefaultDeliveryOptionGLSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryoptionglsPager) orderExpr(query *DeliveryOptionGLSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryOptionGLSOrder.Field {
			b.Comma().Ident(DefaultDeliveryOptionGLSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryOptionGLS.
func (dog *DeliveryOptionGLSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryOptionGLSPaginateOption,
) (*DeliveryOptionGLSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryOptionGLSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dog, err = pager.applyFilter(dog); err != nil {
		return nil, err
	}
	conn := &DeliveryOptionGLSConnection{Edges: []*DeliveryOptionGLSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dog.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dog, err = pager.applyCursors(dog, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dog.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dog.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dog = pager.applyOrder(dog)
	nodes, err := dog.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryOptionGLSOrderField defines the ordering field of DeliveryOptionGLS.
type DeliveryOptionGLSOrderField struct {
	// Value extracts the ordering value from the given DeliveryOptionGLS.
	Value    func(*DeliveryOptionGLS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryoptiongls.OrderOption
	toCursor func(*DeliveryOptionGLS) Cursor
}

// DeliveryOptionGLSOrder defines the ordering of DeliveryOptionGLS.
type DeliveryOptionGLSOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *DeliveryOptionGLSOrderField `json:"field"`
}

// DefaultDeliveryOptionGLSOrder is the default ordering of DeliveryOptionGLS.
var DefaultDeliveryOptionGLSOrder = &DeliveryOptionGLSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryOptionGLSOrderField{
		Value: func(dog *DeliveryOptionGLS) (ent.Value, error) {
			return dog.ID, nil
		},
		column: deliveryoptiongls.FieldID,
		toTerm: deliveryoptiongls.ByID,
		toCursor: func(dog *DeliveryOptionGLS) Cursor {
			return Cursor{ID: dog.ID}
		},
	},
}

// ToEdge converts DeliveryOptionGLS into DeliveryOptionGLSEdge.
func (dog *DeliveryOptionGLS) ToEdge(order *DeliveryOptionGLSOrder) *DeliveryOptionGLSEdge {
	if order == nil {
		order = DefaultDeliveryOptionGLSOrder
	}
	return &DeliveryOptionGLSEdge{
		Node:   dog,
		Cursor: order.Field.toCursor(dog),
	}
}

// DeliveryOptionPostNordEdge is the edge representation of DeliveryOptionPostNord.
type DeliveryOptionPostNordEdge struct {
	Node   *DeliveryOptionPostNord `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// DeliveryOptionPostNordConnection is the connection containing edges to DeliveryOptionPostNord.
type DeliveryOptionPostNordConnection struct {
	Edges      []*DeliveryOptionPostNordEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *DeliveryOptionPostNordConnection) build(nodes []*DeliveryOptionPostNord, pager *deliveryoptionpostnordPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryOptionPostNord
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryOptionPostNord {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryOptionPostNord {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryOptionPostNordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryOptionPostNordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryOptionPostNordPaginateOption enables pagination customization.
type DeliveryOptionPostNordPaginateOption func(*deliveryoptionpostnordPager) error

// WithDeliveryOptionPostNordOrder configures pagination ordering.
func WithDeliveryOptionPostNordOrder(order *DeliveryOptionPostNordOrder) DeliveryOptionPostNordPaginateOption {
	if order == nil {
		order = DefaultDeliveryOptionPostNordOrder
	}
	o := *order
	return func(pager *deliveryoptionpostnordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryOptionPostNordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryOptionPostNordFilter configures pagination filter.
func WithDeliveryOptionPostNordFilter(filter func(*DeliveryOptionPostNordQuery) (*DeliveryOptionPostNordQuery, error)) DeliveryOptionPostNordPaginateOption {
	return func(pager *deliveryoptionpostnordPager) error {
		if filter == nil {
			return errors.New("DeliveryOptionPostNordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryoptionpostnordPager struct {
	reverse bool
	order   *DeliveryOptionPostNordOrder
	filter  func(*DeliveryOptionPostNordQuery) (*DeliveryOptionPostNordQuery, error)
}

func newDeliveryOptionPostNordPager(opts []DeliveryOptionPostNordPaginateOption, reverse bool) (*deliveryoptionpostnordPager, error) {
	pager := &deliveryoptionpostnordPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryOptionPostNordOrder
	}
	return pager, nil
}

func (p *deliveryoptionpostnordPager) applyFilter(query *DeliveryOptionPostNordQuery) (*DeliveryOptionPostNordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryoptionpostnordPager) toCursor(dopn *DeliveryOptionPostNord) Cursor {
	return p.order.Field.toCursor(dopn)
}

func (p *deliveryoptionpostnordPager) applyCursors(query *DeliveryOptionPostNordQuery, after, before *Cursor) (*DeliveryOptionPostNordQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryOptionPostNordOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryoptionpostnordPager) applyOrder(query *DeliveryOptionPostNordQuery) *DeliveryOptionPostNordQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryOptionPostNordOrder.Field {
		query = query.Order(DefaultDeliveryOptionPostNordOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryoptionpostnordPager) orderExpr(query *DeliveryOptionPostNordQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryOptionPostNordOrder.Field {
			b.Comma().Ident(DefaultDeliveryOptionPostNordOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryOptionPostNord.
func (dopn *DeliveryOptionPostNordQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryOptionPostNordPaginateOption,
) (*DeliveryOptionPostNordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryOptionPostNordPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dopn, err = pager.applyFilter(dopn); err != nil {
		return nil, err
	}
	conn := &DeliveryOptionPostNordConnection{Edges: []*DeliveryOptionPostNordEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dopn.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dopn, err = pager.applyCursors(dopn, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dopn.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dopn.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dopn = pager.applyOrder(dopn)
	nodes, err := dopn.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryOptionPostNordOrderField defines the ordering field of DeliveryOptionPostNord.
type DeliveryOptionPostNordOrderField struct {
	// Value extracts the ordering value from the given DeliveryOptionPostNord.
	Value    func(*DeliveryOptionPostNord) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryoptionpostnord.OrderOption
	toCursor func(*DeliveryOptionPostNord) Cursor
}

// DeliveryOptionPostNordOrder defines the ordering of DeliveryOptionPostNord.
type DeliveryOptionPostNordOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *DeliveryOptionPostNordOrderField `json:"field"`
}

// DefaultDeliveryOptionPostNordOrder is the default ordering of DeliveryOptionPostNord.
var DefaultDeliveryOptionPostNordOrder = &DeliveryOptionPostNordOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryOptionPostNordOrderField{
		Value: func(dopn *DeliveryOptionPostNord) (ent.Value, error) {
			return dopn.ID, nil
		},
		column: deliveryoptionpostnord.FieldID,
		toTerm: deliveryoptionpostnord.ByID,
		toCursor: func(dopn *DeliveryOptionPostNord) Cursor {
			return Cursor{ID: dopn.ID}
		},
	},
}

// ToEdge converts DeliveryOptionPostNord into DeliveryOptionPostNordEdge.
func (dopn *DeliveryOptionPostNord) ToEdge(order *DeliveryOptionPostNordOrder) *DeliveryOptionPostNordEdge {
	if order == nil {
		order = DefaultDeliveryOptionPostNordOrder
	}
	return &DeliveryOptionPostNordEdge{
		Node:   dopn,
		Cursor: order.Field.toCursor(dopn),
	}
}

// DeliveryOptionUSPSEdge is the edge representation of DeliveryOptionUSPS.
type DeliveryOptionUSPSEdge struct {
	Node   *DeliveryOptionUSPS `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// DeliveryOptionUSPSConnection is the connection containing edges to DeliveryOptionUSPS.
type DeliveryOptionUSPSConnection struct {
	Edges      []*DeliveryOptionUSPSEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *DeliveryOptionUSPSConnection) build(nodes []*DeliveryOptionUSPS, pager *deliveryoptionuspsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryOptionUSPS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryOptionUSPS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryOptionUSPS {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryOptionUSPSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryOptionUSPSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryOptionUSPSPaginateOption enables pagination customization.
type DeliveryOptionUSPSPaginateOption func(*deliveryoptionuspsPager) error

// WithDeliveryOptionUSPSOrder configures pagination ordering.
func WithDeliveryOptionUSPSOrder(order *DeliveryOptionUSPSOrder) DeliveryOptionUSPSPaginateOption {
	if order == nil {
		order = DefaultDeliveryOptionUSPSOrder
	}
	o := *order
	return func(pager *deliveryoptionuspsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryOptionUSPSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryOptionUSPSFilter configures pagination filter.
func WithDeliveryOptionUSPSFilter(filter func(*DeliveryOptionUSPSQuery) (*DeliveryOptionUSPSQuery, error)) DeliveryOptionUSPSPaginateOption {
	return func(pager *deliveryoptionuspsPager) error {
		if filter == nil {
			return errors.New("DeliveryOptionUSPSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryoptionuspsPager struct {
	reverse bool
	order   *DeliveryOptionUSPSOrder
	filter  func(*DeliveryOptionUSPSQuery) (*DeliveryOptionUSPSQuery, error)
}

func newDeliveryOptionUSPSPager(opts []DeliveryOptionUSPSPaginateOption, reverse bool) (*deliveryoptionuspsPager, error) {
	pager := &deliveryoptionuspsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryOptionUSPSOrder
	}
	return pager, nil
}

func (p *deliveryoptionuspsPager) applyFilter(query *DeliveryOptionUSPSQuery) (*DeliveryOptionUSPSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryoptionuspsPager) toCursor(dou *DeliveryOptionUSPS) Cursor {
	return p.order.Field.toCursor(dou)
}

func (p *deliveryoptionuspsPager) applyCursors(query *DeliveryOptionUSPSQuery, after, before *Cursor) (*DeliveryOptionUSPSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryOptionUSPSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryoptionuspsPager) applyOrder(query *DeliveryOptionUSPSQuery) *DeliveryOptionUSPSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryOptionUSPSOrder.Field {
		query = query.Order(DefaultDeliveryOptionUSPSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryoptionuspsPager) orderExpr(query *DeliveryOptionUSPSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryOptionUSPSOrder.Field {
			b.Comma().Ident(DefaultDeliveryOptionUSPSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryOptionUSPS.
func (dou *DeliveryOptionUSPSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryOptionUSPSPaginateOption,
) (*DeliveryOptionUSPSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryOptionUSPSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dou, err = pager.applyFilter(dou); err != nil {
		return nil, err
	}
	conn := &DeliveryOptionUSPSConnection{Edges: []*DeliveryOptionUSPSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dou.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dou, err = pager.applyCursors(dou, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dou.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dou.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dou = pager.applyOrder(dou)
	nodes, err := dou.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryOptionUSPSOrderField defines the ordering field of DeliveryOptionUSPS.
type DeliveryOptionUSPSOrderField struct {
	// Value extracts the ordering value from the given DeliveryOptionUSPS.
	Value    func(*DeliveryOptionUSPS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryoptionusps.OrderOption
	toCursor func(*DeliveryOptionUSPS) Cursor
}

// DeliveryOptionUSPSOrder defines the ordering of DeliveryOptionUSPS.
type DeliveryOptionUSPSOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *DeliveryOptionUSPSOrderField `json:"field"`
}

// DefaultDeliveryOptionUSPSOrder is the default ordering of DeliveryOptionUSPS.
var DefaultDeliveryOptionUSPSOrder = &DeliveryOptionUSPSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryOptionUSPSOrderField{
		Value: func(dou *DeliveryOptionUSPS) (ent.Value, error) {
			return dou.ID, nil
		},
		column: deliveryoptionusps.FieldID,
		toTerm: deliveryoptionusps.ByID,
		toCursor: func(dou *DeliveryOptionUSPS) Cursor {
			return Cursor{ID: dou.ID}
		},
	},
}

// ToEdge converts DeliveryOptionUSPS into DeliveryOptionUSPSEdge.
func (dou *DeliveryOptionUSPS) ToEdge(order *DeliveryOptionUSPSOrder) *DeliveryOptionUSPSEdge {
	if order == nil {
		order = DefaultDeliveryOptionUSPSOrder
	}
	return &DeliveryOptionUSPSEdge{
		Node:   dou,
		Cursor: order.Field.toCursor(dou),
	}
}

// DeliveryRuleEdge is the edge representation of DeliveryRule.
type DeliveryRuleEdge struct {
	Node   *DeliveryRule `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// DeliveryRuleConnection is the connection containing edges to DeliveryRule.
type DeliveryRuleConnection struct {
	Edges      []*DeliveryRuleEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *DeliveryRuleConnection) build(nodes []*DeliveryRule, pager *deliveryrulePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryRule
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryRule {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryRule {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryRuleEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryRuleEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryRulePaginateOption enables pagination customization.
type DeliveryRulePaginateOption func(*deliveryrulePager) error

// WithDeliveryRuleOrder configures pagination ordering.
func WithDeliveryRuleOrder(order *DeliveryRuleOrder) DeliveryRulePaginateOption {
	if order == nil {
		order = DefaultDeliveryRuleOrder
	}
	o := *order
	return func(pager *deliveryrulePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryRuleOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryRuleFilter configures pagination filter.
func WithDeliveryRuleFilter(filter func(*DeliveryRuleQuery) (*DeliveryRuleQuery, error)) DeliveryRulePaginateOption {
	return func(pager *deliveryrulePager) error {
		if filter == nil {
			return errors.New("DeliveryRuleQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryrulePager struct {
	reverse bool
	order   *DeliveryRuleOrder
	filter  func(*DeliveryRuleQuery) (*DeliveryRuleQuery, error)
}

func newDeliveryRulePager(opts []DeliveryRulePaginateOption, reverse bool) (*deliveryrulePager, error) {
	pager := &deliveryrulePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryRuleOrder
	}
	return pager, nil
}

func (p *deliveryrulePager) applyFilter(query *DeliveryRuleQuery) (*DeliveryRuleQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryrulePager) toCursor(dr *DeliveryRule) Cursor {
	return p.order.Field.toCursor(dr)
}

func (p *deliveryrulePager) applyCursors(query *DeliveryRuleQuery, after, before *Cursor) (*DeliveryRuleQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryRuleOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryrulePager) applyOrder(query *DeliveryRuleQuery) *DeliveryRuleQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryRuleOrder.Field {
		query = query.Order(DefaultDeliveryRuleOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryrulePager) orderExpr(query *DeliveryRuleQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryRuleOrder.Field {
			b.Comma().Ident(DefaultDeliveryRuleOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryRule.
func (dr *DeliveryRuleQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryRulePaginateOption,
) (*DeliveryRuleConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryRulePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if dr, err = pager.applyFilter(dr); err != nil {
		return nil, err
	}
	conn := &DeliveryRuleConnection{Edges: []*DeliveryRuleEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := dr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if dr, err = pager.applyCursors(dr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		dr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := dr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	dr = pager.applyOrder(dr)
	nodes, err := dr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryRuleOrderField defines the ordering field of DeliveryRule.
type DeliveryRuleOrderField struct {
	// Value extracts the ordering value from the given DeliveryRule.
	Value    func(*DeliveryRule) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryrule.OrderOption
	toCursor func(*DeliveryRule) Cursor
}

// DeliveryRuleOrder defines the ordering of DeliveryRule.
type DeliveryRuleOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *DeliveryRuleOrderField `json:"field"`
}

// DefaultDeliveryRuleOrder is the default ordering of DeliveryRule.
var DefaultDeliveryRuleOrder = &DeliveryRuleOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryRuleOrderField{
		Value: func(dr *DeliveryRule) (ent.Value, error) {
			return dr.ID, nil
		},
		column: deliveryrule.FieldID,
		toTerm: deliveryrule.ByID,
		toCursor: func(dr *DeliveryRule) Cursor {
			return Cursor{ID: dr.ID}
		},
	},
}

// ToEdge converts DeliveryRule into DeliveryRuleEdge.
func (dr *DeliveryRule) ToEdge(order *DeliveryRuleOrder) *DeliveryRuleEdge {
	if order == nil {
		order = DefaultDeliveryRuleOrder
	}
	return &DeliveryRuleEdge{
		Node:   dr,
		Cursor: order.Field.toCursor(dr),
	}
}

// DeliveryRuleConstraintEdge is the edge representation of DeliveryRuleConstraint.
type DeliveryRuleConstraintEdge struct {
	Node   *DeliveryRuleConstraint `json:"node"`
	Cursor Cursor                  `json:"cursor"`
}

// DeliveryRuleConstraintConnection is the connection containing edges to DeliveryRuleConstraint.
type DeliveryRuleConstraintConnection struct {
	Edges      []*DeliveryRuleConstraintEdge `json:"edges"`
	PageInfo   PageInfo                      `json:"pageInfo"`
	TotalCount int                           `json:"totalCount"`
}

func (c *DeliveryRuleConstraintConnection) build(nodes []*DeliveryRuleConstraint, pager *deliveryruleconstraintPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryRuleConstraint
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryRuleConstraint {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryRuleConstraint {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryRuleConstraintEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryRuleConstraintEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryRuleConstraintPaginateOption enables pagination customization.
type DeliveryRuleConstraintPaginateOption func(*deliveryruleconstraintPager) error

// WithDeliveryRuleConstraintOrder configures pagination ordering.
func WithDeliveryRuleConstraintOrder(order *DeliveryRuleConstraintOrder) DeliveryRuleConstraintPaginateOption {
	if order == nil {
		order = DefaultDeliveryRuleConstraintOrder
	}
	o := *order
	return func(pager *deliveryruleconstraintPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryRuleConstraintOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryRuleConstraintFilter configures pagination filter.
func WithDeliveryRuleConstraintFilter(filter func(*DeliveryRuleConstraintQuery) (*DeliveryRuleConstraintQuery, error)) DeliveryRuleConstraintPaginateOption {
	return func(pager *deliveryruleconstraintPager) error {
		if filter == nil {
			return errors.New("DeliveryRuleConstraintQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryruleconstraintPager struct {
	reverse bool
	order   *DeliveryRuleConstraintOrder
	filter  func(*DeliveryRuleConstraintQuery) (*DeliveryRuleConstraintQuery, error)
}

func newDeliveryRuleConstraintPager(opts []DeliveryRuleConstraintPaginateOption, reverse bool) (*deliveryruleconstraintPager, error) {
	pager := &deliveryruleconstraintPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryRuleConstraintOrder
	}
	return pager, nil
}

func (p *deliveryruleconstraintPager) applyFilter(query *DeliveryRuleConstraintQuery) (*DeliveryRuleConstraintQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryruleconstraintPager) toCursor(drc *DeliveryRuleConstraint) Cursor {
	return p.order.Field.toCursor(drc)
}

func (p *deliveryruleconstraintPager) applyCursors(query *DeliveryRuleConstraintQuery, after, before *Cursor) (*DeliveryRuleConstraintQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryRuleConstraintOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryruleconstraintPager) applyOrder(query *DeliveryRuleConstraintQuery) *DeliveryRuleConstraintQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryRuleConstraintOrder.Field {
		query = query.Order(DefaultDeliveryRuleConstraintOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryruleconstraintPager) orderExpr(query *DeliveryRuleConstraintQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryRuleConstraintOrder.Field {
			b.Comma().Ident(DefaultDeliveryRuleConstraintOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryRuleConstraint.
func (drc *DeliveryRuleConstraintQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryRuleConstraintPaginateOption,
) (*DeliveryRuleConstraintConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryRuleConstraintPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if drc, err = pager.applyFilter(drc); err != nil {
		return nil, err
	}
	conn := &DeliveryRuleConstraintConnection{Edges: []*DeliveryRuleConstraintEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := drc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if drc, err = pager.applyCursors(drc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		drc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := drc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	drc = pager.applyOrder(drc)
	nodes, err := drc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryRuleConstraintOrderField defines the ordering field of DeliveryRuleConstraint.
type DeliveryRuleConstraintOrderField struct {
	// Value extracts the ordering value from the given DeliveryRuleConstraint.
	Value    func(*DeliveryRuleConstraint) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryruleconstraint.OrderOption
	toCursor func(*DeliveryRuleConstraint) Cursor
}

// DeliveryRuleConstraintOrder defines the ordering of DeliveryRuleConstraint.
type DeliveryRuleConstraintOrder struct {
	Direction OrderDirection                    `json:"direction"`
	Field     *DeliveryRuleConstraintOrderField `json:"field"`
}

// DefaultDeliveryRuleConstraintOrder is the default ordering of DeliveryRuleConstraint.
var DefaultDeliveryRuleConstraintOrder = &DeliveryRuleConstraintOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryRuleConstraintOrderField{
		Value: func(drc *DeliveryRuleConstraint) (ent.Value, error) {
			return drc.ID, nil
		},
		column: deliveryruleconstraint.FieldID,
		toTerm: deliveryruleconstraint.ByID,
		toCursor: func(drc *DeliveryRuleConstraint) Cursor {
			return Cursor{ID: drc.ID}
		},
	},
}

// ToEdge converts DeliveryRuleConstraint into DeliveryRuleConstraintEdge.
func (drc *DeliveryRuleConstraint) ToEdge(order *DeliveryRuleConstraintOrder) *DeliveryRuleConstraintEdge {
	if order == nil {
		order = DefaultDeliveryRuleConstraintOrder
	}
	return &DeliveryRuleConstraintEdge{
		Node:   drc,
		Cursor: order.Field.toCursor(drc),
	}
}

// DeliveryRuleConstraintGroupEdge is the edge representation of DeliveryRuleConstraintGroup.
type DeliveryRuleConstraintGroupEdge struct {
	Node   *DeliveryRuleConstraintGroup `json:"node"`
	Cursor Cursor                       `json:"cursor"`
}

// DeliveryRuleConstraintGroupConnection is the connection containing edges to DeliveryRuleConstraintGroup.
type DeliveryRuleConstraintGroupConnection struct {
	Edges      []*DeliveryRuleConstraintGroupEdge `json:"edges"`
	PageInfo   PageInfo                           `json:"pageInfo"`
	TotalCount int                                `json:"totalCount"`
}

func (c *DeliveryRuleConstraintGroupConnection) build(nodes []*DeliveryRuleConstraintGroup, pager *deliveryruleconstraintgroupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DeliveryRuleConstraintGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DeliveryRuleConstraintGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DeliveryRuleConstraintGroup {
			return nodes[i]
		}
	}
	c.Edges = make([]*DeliveryRuleConstraintGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DeliveryRuleConstraintGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DeliveryRuleConstraintGroupPaginateOption enables pagination customization.
type DeliveryRuleConstraintGroupPaginateOption func(*deliveryruleconstraintgroupPager) error

// WithDeliveryRuleConstraintGroupOrder configures pagination ordering.
func WithDeliveryRuleConstraintGroupOrder(order *DeliveryRuleConstraintGroupOrder) DeliveryRuleConstraintGroupPaginateOption {
	if order == nil {
		order = DefaultDeliveryRuleConstraintGroupOrder
	}
	o := *order
	return func(pager *deliveryruleconstraintgroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDeliveryRuleConstraintGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDeliveryRuleConstraintGroupFilter configures pagination filter.
func WithDeliveryRuleConstraintGroupFilter(filter func(*DeliveryRuleConstraintGroupQuery) (*DeliveryRuleConstraintGroupQuery, error)) DeliveryRuleConstraintGroupPaginateOption {
	return func(pager *deliveryruleconstraintgroupPager) error {
		if filter == nil {
			return errors.New("DeliveryRuleConstraintGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type deliveryruleconstraintgroupPager struct {
	reverse bool
	order   *DeliveryRuleConstraintGroupOrder
	filter  func(*DeliveryRuleConstraintGroupQuery) (*DeliveryRuleConstraintGroupQuery, error)
}

func newDeliveryRuleConstraintGroupPager(opts []DeliveryRuleConstraintGroupPaginateOption, reverse bool) (*deliveryruleconstraintgroupPager, error) {
	pager := &deliveryruleconstraintgroupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDeliveryRuleConstraintGroupOrder
	}
	return pager, nil
}

func (p *deliveryruleconstraintgroupPager) applyFilter(query *DeliveryRuleConstraintGroupQuery) (*DeliveryRuleConstraintGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *deliveryruleconstraintgroupPager) toCursor(drcg *DeliveryRuleConstraintGroup) Cursor {
	return p.order.Field.toCursor(drcg)
}

func (p *deliveryruleconstraintgroupPager) applyCursors(query *DeliveryRuleConstraintGroupQuery, after, before *Cursor) (*DeliveryRuleConstraintGroupQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDeliveryRuleConstraintGroupOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *deliveryruleconstraintgroupPager) applyOrder(query *DeliveryRuleConstraintGroupQuery) *DeliveryRuleConstraintGroupQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDeliveryRuleConstraintGroupOrder.Field {
		query = query.Order(DefaultDeliveryRuleConstraintGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *deliveryruleconstraintgroupPager) orderExpr(query *DeliveryRuleConstraintGroupQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDeliveryRuleConstraintGroupOrder.Field {
			b.Comma().Ident(DefaultDeliveryRuleConstraintGroupOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DeliveryRuleConstraintGroup.
func (drcg *DeliveryRuleConstraintGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DeliveryRuleConstraintGroupPaginateOption,
) (*DeliveryRuleConstraintGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDeliveryRuleConstraintGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if drcg, err = pager.applyFilter(drcg); err != nil {
		return nil, err
	}
	conn := &DeliveryRuleConstraintGroupConnection{Edges: []*DeliveryRuleConstraintGroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := drcg.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if drcg, err = pager.applyCursors(drcg, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		drcg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := drcg.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	drcg = pager.applyOrder(drcg)
	nodes, err := drcg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DeliveryRuleConstraintGroupOrderField defines the ordering field of DeliveryRuleConstraintGroup.
type DeliveryRuleConstraintGroupOrderField struct {
	// Value extracts the ordering value from the given DeliveryRuleConstraintGroup.
	Value    func(*DeliveryRuleConstraintGroup) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) deliveryruleconstraintgroup.OrderOption
	toCursor func(*DeliveryRuleConstraintGroup) Cursor
}

// DeliveryRuleConstraintGroupOrder defines the ordering of DeliveryRuleConstraintGroup.
type DeliveryRuleConstraintGroupOrder struct {
	Direction OrderDirection                         `json:"direction"`
	Field     *DeliveryRuleConstraintGroupOrderField `json:"field"`
}

// DefaultDeliveryRuleConstraintGroupOrder is the default ordering of DeliveryRuleConstraintGroup.
var DefaultDeliveryRuleConstraintGroupOrder = &DeliveryRuleConstraintGroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DeliveryRuleConstraintGroupOrderField{
		Value: func(drcg *DeliveryRuleConstraintGroup) (ent.Value, error) {
			return drcg.ID, nil
		},
		column: deliveryruleconstraintgroup.FieldID,
		toTerm: deliveryruleconstraintgroup.ByID,
		toCursor: func(drcg *DeliveryRuleConstraintGroup) Cursor {
			return Cursor{ID: drcg.ID}
		},
	},
}

// ToEdge converts DeliveryRuleConstraintGroup into DeliveryRuleConstraintGroupEdge.
func (drcg *DeliveryRuleConstraintGroup) ToEdge(order *DeliveryRuleConstraintGroupOrder) *DeliveryRuleConstraintGroupEdge {
	if order == nil {
		order = DefaultDeliveryRuleConstraintGroupOrder
	}
	return &DeliveryRuleConstraintGroupEdge{
		Node:   drcg,
		Cursor: order.Field.toCursor(drcg),
	}
}

// DocumentEdge is the edge representation of Document.
type DocumentEdge struct {
	Node   *Document `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// DocumentConnection is the connection containing edges to Document.
type DocumentConnection struct {
	Edges      []*DocumentEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *DocumentConnection) build(nodes []*Document, pager *documentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Document
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Document {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Document {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentPaginateOption enables pagination customization.
type DocumentPaginateOption func(*documentPager) error

// WithDocumentOrder configures pagination ordering.
func WithDocumentOrder(order *DocumentOrder) DocumentPaginateOption {
	if order == nil {
		order = DefaultDocumentOrder
	}
	o := *order
	return func(pager *documentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDocumentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDocumentFilter configures pagination filter.
func WithDocumentFilter(filter func(*DocumentQuery) (*DocumentQuery, error)) DocumentPaginateOption {
	return func(pager *documentPager) error {
		if filter == nil {
			return errors.New("DocumentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentPager struct {
	reverse bool
	order   *DocumentOrder
	filter  func(*DocumentQuery) (*DocumentQuery, error)
}

func newDocumentPager(opts []DocumentPaginateOption, reverse bool) (*documentPager, error) {
	pager := &documentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDocumentOrder
	}
	return pager, nil
}

func (p *documentPager) applyFilter(query *DocumentQuery) (*DocumentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentPager) toCursor(d *Document) Cursor {
	return p.order.Field.toCursor(d)
}

func (p *documentPager) applyCursors(query *DocumentQuery, after, before *Cursor) (*DocumentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDocumentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *documentPager) applyOrder(query *DocumentQuery) *DocumentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDocumentOrder.Field {
		query = query.Order(DefaultDocumentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *documentPager) orderExpr(query *DocumentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDocumentOrder.Field {
			b.Comma().Ident(DefaultDocumentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Document.
func (d *DocumentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentPaginateOption,
) (*DocumentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if d, err = pager.applyFilter(d); err != nil {
		return nil, err
	}
	conn := &DocumentConnection{Edges: []*DocumentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := d.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if d, err = pager.applyCursors(d, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		d.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := d.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	d = pager.applyOrder(d)
	nodes, err := d.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DocumentOrderField defines the ordering field of Document.
type DocumentOrderField struct {
	// Value extracts the ordering value from the given Document.
	Value    func(*Document) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) document.OrderOption
	toCursor func(*Document) Cursor
}

// DocumentOrder defines the ordering of Document.
type DocumentOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *DocumentOrderField `json:"field"`
}

// DefaultDocumentOrder is the default ordering of Document.
var DefaultDocumentOrder = &DocumentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentOrderField{
		Value: func(d *Document) (ent.Value, error) {
			return d.ID, nil
		},
		column: document.FieldID,
		toTerm: document.ByID,
		toCursor: func(d *Document) Cursor {
			return Cursor{ID: d.ID}
		},
	},
}

// ToEdge converts Document into DocumentEdge.
func (d *Document) ToEdge(order *DocumentOrder) *DocumentEdge {
	if order == nil {
		order = DefaultDocumentOrder
	}
	return &DocumentEdge{
		Node:   d,
		Cursor: order.Field.toCursor(d),
	}
}

// DocumentFileEdge is the edge representation of DocumentFile.
type DocumentFileEdge struct {
	Node   *DocumentFile `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// DocumentFileConnection is the connection containing edges to DocumentFile.
type DocumentFileConnection struct {
	Edges      []*DocumentFileEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *DocumentFileConnection) build(nodes []*DocumentFile, pager *documentfilePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *DocumentFile
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *DocumentFile {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *DocumentFile {
			return nodes[i]
		}
	}
	c.Edges = make([]*DocumentFileEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &DocumentFileEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// DocumentFilePaginateOption enables pagination customization.
type DocumentFilePaginateOption func(*documentfilePager) error

// WithDocumentFileOrder configures pagination ordering.
func WithDocumentFileOrder(order *DocumentFileOrder) DocumentFilePaginateOption {
	if order == nil {
		order = DefaultDocumentFileOrder
	}
	o := *order
	return func(pager *documentfilePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultDocumentFileOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithDocumentFileFilter configures pagination filter.
func WithDocumentFileFilter(filter func(*DocumentFileQuery) (*DocumentFileQuery, error)) DocumentFilePaginateOption {
	return func(pager *documentfilePager) error {
		if filter == nil {
			return errors.New("DocumentFileQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type documentfilePager struct {
	reverse bool
	order   *DocumentFileOrder
	filter  func(*DocumentFileQuery) (*DocumentFileQuery, error)
}

func newDocumentFilePager(opts []DocumentFilePaginateOption, reverse bool) (*documentfilePager, error) {
	pager := &documentfilePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultDocumentFileOrder
	}
	return pager, nil
}

func (p *documentfilePager) applyFilter(query *DocumentFileQuery) (*DocumentFileQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *documentfilePager) toCursor(df *DocumentFile) Cursor {
	return p.order.Field.toCursor(df)
}

func (p *documentfilePager) applyCursors(query *DocumentFileQuery, after, before *Cursor) (*DocumentFileQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultDocumentFileOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *documentfilePager) applyOrder(query *DocumentFileQuery) *DocumentFileQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultDocumentFileOrder.Field {
		query = query.Order(DefaultDocumentFileOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *documentfilePager) orderExpr(query *DocumentFileQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultDocumentFileOrder.Field {
			b.Comma().Ident(DefaultDocumentFileOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to DocumentFile.
func (df *DocumentFileQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...DocumentFilePaginateOption,
) (*DocumentFileConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newDocumentFilePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if df, err = pager.applyFilter(df); err != nil {
		return nil, err
	}
	conn := &DocumentFileConnection{Edges: []*DocumentFileEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := df.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if df, err = pager.applyCursors(df, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		df.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := df.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	df = pager.applyOrder(df)
	nodes, err := df.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// DocumentFileOrderField defines the ordering field of DocumentFile.
type DocumentFileOrderField struct {
	// Value extracts the ordering value from the given DocumentFile.
	Value    func(*DocumentFile) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) documentfile.OrderOption
	toCursor func(*DocumentFile) Cursor
}

// DocumentFileOrder defines the ordering of DocumentFile.
type DocumentFileOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *DocumentFileOrderField `json:"field"`
}

// DefaultDocumentFileOrder is the default ordering of DocumentFile.
var DefaultDocumentFileOrder = &DocumentFileOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &DocumentFileOrderField{
		Value: func(df *DocumentFile) (ent.Value, error) {
			return df.ID, nil
		},
		column: documentfile.FieldID,
		toTerm: documentfile.ByID,
		toCursor: func(df *DocumentFile) Cursor {
			return Cursor{ID: df.ID}
		},
	},
}

// ToEdge converts DocumentFile into DocumentFileEdge.
func (df *DocumentFile) ToEdge(order *DocumentFileOrder) *DocumentFileEdge {
	if order == nil {
		order = DefaultDocumentFileOrder
	}
	return &DocumentFileEdge{
		Node:   df,
		Cursor: order.Field.toCursor(df),
	}
}

// EmailTemplateEdge is the edge representation of EmailTemplate.
type EmailTemplateEdge struct {
	Node   *EmailTemplate `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// EmailTemplateConnection is the connection containing edges to EmailTemplate.
type EmailTemplateConnection struct {
	Edges      []*EmailTemplateEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *EmailTemplateConnection) build(nodes []*EmailTemplate, pager *emailtemplatePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *EmailTemplate
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *EmailTemplate {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *EmailTemplate {
			return nodes[i]
		}
	}
	c.Edges = make([]*EmailTemplateEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &EmailTemplateEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// EmailTemplatePaginateOption enables pagination customization.
type EmailTemplatePaginateOption func(*emailtemplatePager) error

// WithEmailTemplateOrder configures pagination ordering.
func WithEmailTemplateOrder(order *EmailTemplateOrder) EmailTemplatePaginateOption {
	if order == nil {
		order = DefaultEmailTemplateOrder
	}
	o := *order
	return func(pager *emailtemplatePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultEmailTemplateOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithEmailTemplateFilter configures pagination filter.
func WithEmailTemplateFilter(filter func(*EmailTemplateQuery) (*EmailTemplateQuery, error)) EmailTemplatePaginateOption {
	return func(pager *emailtemplatePager) error {
		if filter == nil {
			return errors.New("EmailTemplateQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type emailtemplatePager struct {
	reverse bool
	order   *EmailTemplateOrder
	filter  func(*EmailTemplateQuery) (*EmailTemplateQuery, error)
}

func newEmailTemplatePager(opts []EmailTemplatePaginateOption, reverse bool) (*emailtemplatePager, error) {
	pager := &emailtemplatePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultEmailTemplateOrder
	}
	return pager, nil
}

func (p *emailtemplatePager) applyFilter(query *EmailTemplateQuery) (*EmailTemplateQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *emailtemplatePager) toCursor(et *EmailTemplate) Cursor {
	return p.order.Field.toCursor(et)
}

func (p *emailtemplatePager) applyCursors(query *EmailTemplateQuery, after, before *Cursor) (*EmailTemplateQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultEmailTemplateOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *emailtemplatePager) applyOrder(query *EmailTemplateQuery) *EmailTemplateQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultEmailTemplateOrder.Field {
		query = query.Order(DefaultEmailTemplateOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *emailtemplatePager) orderExpr(query *EmailTemplateQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultEmailTemplateOrder.Field {
			b.Comma().Ident(DefaultEmailTemplateOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to EmailTemplate.
func (et *EmailTemplateQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...EmailTemplatePaginateOption,
) (*EmailTemplateConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newEmailTemplatePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if et, err = pager.applyFilter(et); err != nil {
		return nil, err
	}
	conn := &EmailTemplateConnection{Edges: []*EmailTemplateEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := et.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if et, err = pager.applyCursors(et, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		et.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := et.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	et = pager.applyOrder(et)
	nodes, err := et.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// EmailTemplateOrderField defines the ordering field of EmailTemplate.
type EmailTemplateOrderField struct {
	// Value extracts the ordering value from the given EmailTemplate.
	Value    func(*EmailTemplate) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) emailtemplate.OrderOption
	toCursor func(*EmailTemplate) Cursor
}

// EmailTemplateOrder defines the ordering of EmailTemplate.
type EmailTemplateOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *EmailTemplateOrderField `json:"field"`
}

// DefaultEmailTemplateOrder is the default ordering of EmailTemplate.
var DefaultEmailTemplateOrder = &EmailTemplateOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &EmailTemplateOrderField{
		Value: func(et *EmailTemplate) (ent.Value, error) {
			return et.ID, nil
		},
		column: emailtemplate.FieldID,
		toTerm: emailtemplate.ByID,
		toCursor: func(et *EmailTemplate) Cursor {
			return Cursor{ID: et.ID}
		},
	},
}

// ToEdge converts EmailTemplate into EmailTemplateEdge.
func (et *EmailTemplate) ToEdge(order *EmailTemplateOrder) *EmailTemplateEdge {
	if order == nil {
		order = DefaultEmailTemplateOrder
	}
	return &EmailTemplateEdge{
		Node:   et,
		Cursor: order.Field.toCursor(et),
	}
}

// HypothesisTestEdge is the edge representation of HypothesisTest.
type HypothesisTestEdge struct {
	Node   *HypothesisTest `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// HypothesisTestConnection is the connection containing edges to HypothesisTest.
type HypothesisTestConnection struct {
	Edges      []*HypothesisTestEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *HypothesisTestConnection) build(nodes []*HypothesisTest, pager *hypothesistestPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HypothesisTest
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HypothesisTest {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HypothesisTest {
			return nodes[i]
		}
	}
	c.Edges = make([]*HypothesisTestEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HypothesisTestEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HypothesisTestPaginateOption enables pagination customization.
type HypothesisTestPaginateOption func(*hypothesistestPager) error

// WithHypothesisTestOrder configures pagination ordering.
func WithHypothesisTestOrder(order *HypothesisTestOrder) HypothesisTestPaginateOption {
	if order == nil {
		order = DefaultHypothesisTestOrder
	}
	o := *order
	return func(pager *hypothesistestPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHypothesisTestOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHypothesisTestFilter configures pagination filter.
func WithHypothesisTestFilter(filter func(*HypothesisTestQuery) (*HypothesisTestQuery, error)) HypothesisTestPaginateOption {
	return func(pager *hypothesistestPager) error {
		if filter == nil {
			return errors.New("HypothesisTestQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hypothesistestPager struct {
	reverse bool
	order   *HypothesisTestOrder
	filter  func(*HypothesisTestQuery) (*HypothesisTestQuery, error)
}

func newHypothesisTestPager(opts []HypothesisTestPaginateOption, reverse bool) (*hypothesistestPager, error) {
	pager := &hypothesistestPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHypothesisTestOrder
	}
	return pager, nil
}

func (p *hypothesistestPager) applyFilter(query *HypothesisTestQuery) (*HypothesisTestQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hypothesistestPager) toCursor(ht *HypothesisTest) Cursor {
	return p.order.Field.toCursor(ht)
}

func (p *hypothesistestPager) applyCursors(query *HypothesisTestQuery, after, before *Cursor) (*HypothesisTestQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHypothesisTestOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hypothesistestPager) applyOrder(query *HypothesisTestQuery) *HypothesisTestQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHypothesisTestOrder.Field {
		query = query.Order(DefaultHypothesisTestOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hypothesistestPager) orderExpr(query *HypothesisTestQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHypothesisTestOrder.Field {
			b.Comma().Ident(DefaultHypothesisTestOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HypothesisTest.
func (ht *HypothesisTestQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HypothesisTestPaginateOption,
) (*HypothesisTestConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHypothesisTestPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ht, err = pager.applyFilter(ht); err != nil {
		return nil, err
	}
	conn := &HypothesisTestConnection{Edges: []*HypothesisTestEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ht.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ht, err = pager.applyCursors(ht, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ht.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ht.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ht = pager.applyOrder(ht)
	nodes, err := ht.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// HypothesisTestOrderField defines the ordering field of HypothesisTest.
type HypothesisTestOrderField struct {
	// Value extracts the ordering value from the given HypothesisTest.
	Value    func(*HypothesisTest) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hypothesistest.OrderOption
	toCursor func(*HypothesisTest) Cursor
}

// HypothesisTestOrder defines the ordering of HypothesisTest.
type HypothesisTestOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *HypothesisTestOrderField `json:"field"`
}

// DefaultHypothesisTestOrder is the default ordering of HypothesisTest.
var DefaultHypothesisTestOrder = &HypothesisTestOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HypothesisTestOrderField{
		Value: func(ht *HypothesisTest) (ent.Value, error) {
			return ht.ID, nil
		},
		column: hypothesistest.FieldID,
		toTerm: hypothesistest.ByID,
		toCursor: func(ht *HypothesisTest) Cursor {
			return Cursor{ID: ht.ID}
		},
	},
}

// ToEdge converts HypothesisTest into HypothesisTestEdge.
func (ht *HypothesisTest) ToEdge(order *HypothesisTestOrder) *HypothesisTestEdge {
	if order == nil {
		order = DefaultHypothesisTestOrder
	}
	return &HypothesisTestEdge{
		Node:   ht,
		Cursor: order.Field.toCursor(ht),
	}
}

// HypothesisTestDeliveryOptionEdge is the edge representation of HypothesisTestDeliveryOption.
type HypothesisTestDeliveryOptionEdge struct {
	Node   *HypothesisTestDeliveryOption `json:"node"`
	Cursor Cursor                        `json:"cursor"`
}

// HypothesisTestDeliveryOptionConnection is the connection containing edges to HypothesisTestDeliveryOption.
type HypothesisTestDeliveryOptionConnection struct {
	Edges      []*HypothesisTestDeliveryOptionEdge `json:"edges"`
	PageInfo   PageInfo                            `json:"pageInfo"`
	TotalCount int                                 `json:"totalCount"`
}

func (c *HypothesisTestDeliveryOptionConnection) build(nodes []*HypothesisTestDeliveryOption, pager *hypothesistestdeliveryoptionPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HypothesisTestDeliveryOption
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HypothesisTestDeliveryOption {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HypothesisTestDeliveryOption {
			return nodes[i]
		}
	}
	c.Edges = make([]*HypothesisTestDeliveryOptionEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HypothesisTestDeliveryOptionEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HypothesisTestDeliveryOptionPaginateOption enables pagination customization.
type HypothesisTestDeliveryOptionPaginateOption func(*hypothesistestdeliveryoptionPager) error

// WithHypothesisTestDeliveryOptionOrder configures pagination ordering.
func WithHypothesisTestDeliveryOptionOrder(order *HypothesisTestDeliveryOptionOrder) HypothesisTestDeliveryOptionPaginateOption {
	if order == nil {
		order = DefaultHypothesisTestDeliveryOptionOrder
	}
	o := *order
	return func(pager *hypothesistestdeliveryoptionPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHypothesisTestDeliveryOptionOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHypothesisTestDeliveryOptionFilter configures pagination filter.
func WithHypothesisTestDeliveryOptionFilter(filter func(*HypothesisTestDeliveryOptionQuery) (*HypothesisTestDeliveryOptionQuery, error)) HypothesisTestDeliveryOptionPaginateOption {
	return func(pager *hypothesistestdeliveryoptionPager) error {
		if filter == nil {
			return errors.New("HypothesisTestDeliveryOptionQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hypothesistestdeliveryoptionPager struct {
	reverse bool
	order   *HypothesisTestDeliveryOptionOrder
	filter  func(*HypothesisTestDeliveryOptionQuery) (*HypothesisTestDeliveryOptionQuery, error)
}

func newHypothesisTestDeliveryOptionPager(opts []HypothesisTestDeliveryOptionPaginateOption, reverse bool) (*hypothesistestdeliveryoptionPager, error) {
	pager := &hypothesistestdeliveryoptionPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHypothesisTestDeliveryOptionOrder
	}
	return pager, nil
}

func (p *hypothesistestdeliveryoptionPager) applyFilter(query *HypothesisTestDeliveryOptionQuery) (*HypothesisTestDeliveryOptionQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hypothesistestdeliveryoptionPager) toCursor(htdo *HypothesisTestDeliveryOption) Cursor {
	return p.order.Field.toCursor(htdo)
}

func (p *hypothesistestdeliveryoptionPager) applyCursors(query *HypothesisTestDeliveryOptionQuery, after, before *Cursor) (*HypothesisTestDeliveryOptionQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHypothesisTestDeliveryOptionOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hypothesistestdeliveryoptionPager) applyOrder(query *HypothesisTestDeliveryOptionQuery) *HypothesisTestDeliveryOptionQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHypothesisTestDeliveryOptionOrder.Field {
		query = query.Order(DefaultHypothesisTestDeliveryOptionOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hypothesistestdeliveryoptionPager) orderExpr(query *HypothesisTestDeliveryOptionQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHypothesisTestDeliveryOptionOrder.Field {
			b.Comma().Ident(DefaultHypothesisTestDeliveryOptionOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HypothesisTestDeliveryOption.
func (htdo *HypothesisTestDeliveryOptionQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HypothesisTestDeliveryOptionPaginateOption,
) (*HypothesisTestDeliveryOptionConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHypothesisTestDeliveryOptionPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if htdo, err = pager.applyFilter(htdo); err != nil {
		return nil, err
	}
	conn := &HypothesisTestDeliveryOptionConnection{Edges: []*HypothesisTestDeliveryOptionEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := htdo.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if htdo, err = pager.applyCursors(htdo, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		htdo.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := htdo.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	htdo = pager.applyOrder(htdo)
	nodes, err := htdo.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// HypothesisTestDeliveryOptionOrderField defines the ordering field of HypothesisTestDeliveryOption.
type HypothesisTestDeliveryOptionOrderField struct {
	// Value extracts the ordering value from the given HypothesisTestDeliveryOption.
	Value    func(*HypothesisTestDeliveryOption) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hypothesistestdeliveryoption.OrderOption
	toCursor func(*HypothesisTestDeliveryOption) Cursor
}

// HypothesisTestDeliveryOptionOrder defines the ordering of HypothesisTestDeliveryOption.
type HypothesisTestDeliveryOptionOrder struct {
	Direction OrderDirection                          `json:"direction"`
	Field     *HypothesisTestDeliveryOptionOrderField `json:"field"`
}

// DefaultHypothesisTestDeliveryOptionOrder is the default ordering of HypothesisTestDeliveryOption.
var DefaultHypothesisTestDeliveryOptionOrder = &HypothesisTestDeliveryOptionOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HypothesisTestDeliveryOptionOrderField{
		Value: func(htdo *HypothesisTestDeliveryOption) (ent.Value, error) {
			return htdo.ID, nil
		},
		column: hypothesistestdeliveryoption.FieldID,
		toTerm: hypothesistestdeliveryoption.ByID,
		toCursor: func(htdo *HypothesisTestDeliveryOption) Cursor {
			return Cursor{ID: htdo.ID}
		},
	},
}

// ToEdge converts HypothesisTestDeliveryOption into HypothesisTestDeliveryOptionEdge.
func (htdo *HypothesisTestDeliveryOption) ToEdge(order *HypothesisTestDeliveryOptionOrder) *HypothesisTestDeliveryOptionEdge {
	if order == nil {
		order = DefaultHypothesisTestDeliveryOptionOrder
	}
	return &HypothesisTestDeliveryOptionEdge{
		Node:   htdo,
		Cursor: order.Field.toCursor(htdo),
	}
}

// HypothesisTestDeliveryOptionLookupEdge is the edge representation of HypothesisTestDeliveryOptionLookup.
type HypothesisTestDeliveryOptionLookupEdge struct {
	Node   *HypothesisTestDeliveryOptionLookup `json:"node"`
	Cursor Cursor                              `json:"cursor"`
}

// HypothesisTestDeliveryOptionLookupConnection is the connection containing edges to HypothesisTestDeliveryOptionLookup.
type HypothesisTestDeliveryOptionLookupConnection struct {
	Edges      []*HypothesisTestDeliveryOptionLookupEdge `json:"edges"`
	PageInfo   PageInfo                                  `json:"pageInfo"`
	TotalCount int                                       `json:"totalCount"`
}

func (c *HypothesisTestDeliveryOptionLookupConnection) build(nodes []*HypothesisTestDeliveryOptionLookup, pager *hypothesistestdeliveryoptionlookupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HypothesisTestDeliveryOptionLookup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HypothesisTestDeliveryOptionLookup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HypothesisTestDeliveryOptionLookup {
			return nodes[i]
		}
	}
	c.Edges = make([]*HypothesisTestDeliveryOptionLookupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HypothesisTestDeliveryOptionLookupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HypothesisTestDeliveryOptionLookupPaginateOption enables pagination customization.
type HypothesisTestDeliveryOptionLookupPaginateOption func(*hypothesistestdeliveryoptionlookupPager) error

// WithHypothesisTestDeliveryOptionLookupOrder configures pagination ordering.
func WithHypothesisTestDeliveryOptionLookupOrder(order *HypothesisTestDeliveryOptionLookupOrder) HypothesisTestDeliveryOptionLookupPaginateOption {
	if order == nil {
		order = DefaultHypothesisTestDeliveryOptionLookupOrder
	}
	o := *order
	return func(pager *hypothesistestdeliveryoptionlookupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHypothesisTestDeliveryOptionLookupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHypothesisTestDeliveryOptionLookupFilter configures pagination filter.
func WithHypothesisTestDeliveryOptionLookupFilter(filter func(*HypothesisTestDeliveryOptionLookupQuery) (*HypothesisTestDeliveryOptionLookupQuery, error)) HypothesisTestDeliveryOptionLookupPaginateOption {
	return func(pager *hypothesistestdeliveryoptionlookupPager) error {
		if filter == nil {
			return errors.New("HypothesisTestDeliveryOptionLookupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hypothesistestdeliveryoptionlookupPager struct {
	reverse bool
	order   *HypothesisTestDeliveryOptionLookupOrder
	filter  func(*HypothesisTestDeliveryOptionLookupQuery) (*HypothesisTestDeliveryOptionLookupQuery, error)
}

func newHypothesisTestDeliveryOptionLookupPager(opts []HypothesisTestDeliveryOptionLookupPaginateOption, reverse bool) (*hypothesistestdeliveryoptionlookupPager, error) {
	pager := &hypothesistestdeliveryoptionlookupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHypothesisTestDeliveryOptionLookupOrder
	}
	return pager, nil
}

func (p *hypothesistestdeliveryoptionlookupPager) applyFilter(query *HypothesisTestDeliveryOptionLookupQuery) (*HypothesisTestDeliveryOptionLookupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hypothesistestdeliveryoptionlookupPager) toCursor(htdol *HypothesisTestDeliveryOptionLookup) Cursor {
	return p.order.Field.toCursor(htdol)
}

func (p *hypothesistestdeliveryoptionlookupPager) applyCursors(query *HypothesisTestDeliveryOptionLookupQuery, after, before *Cursor) (*HypothesisTestDeliveryOptionLookupQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHypothesisTestDeliveryOptionLookupOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hypothesistestdeliveryoptionlookupPager) applyOrder(query *HypothesisTestDeliveryOptionLookupQuery) *HypothesisTestDeliveryOptionLookupQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHypothesisTestDeliveryOptionLookupOrder.Field {
		query = query.Order(DefaultHypothesisTestDeliveryOptionLookupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hypothesistestdeliveryoptionlookupPager) orderExpr(query *HypothesisTestDeliveryOptionLookupQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHypothesisTestDeliveryOptionLookupOrder.Field {
			b.Comma().Ident(DefaultHypothesisTestDeliveryOptionLookupOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HypothesisTestDeliveryOptionLookup.
func (htdol *HypothesisTestDeliveryOptionLookupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HypothesisTestDeliveryOptionLookupPaginateOption,
) (*HypothesisTestDeliveryOptionLookupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHypothesisTestDeliveryOptionLookupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if htdol, err = pager.applyFilter(htdol); err != nil {
		return nil, err
	}
	conn := &HypothesisTestDeliveryOptionLookupConnection{Edges: []*HypothesisTestDeliveryOptionLookupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := htdol.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if htdol, err = pager.applyCursors(htdol, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		htdol.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := htdol.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	htdol = pager.applyOrder(htdol)
	nodes, err := htdol.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// HypothesisTestDeliveryOptionLookupOrderField defines the ordering field of HypothesisTestDeliveryOptionLookup.
type HypothesisTestDeliveryOptionLookupOrderField struct {
	// Value extracts the ordering value from the given HypothesisTestDeliveryOptionLookup.
	Value    func(*HypothesisTestDeliveryOptionLookup) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hypothesistestdeliveryoptionlookup.OrderOption
	toCursor func(*HypothesisTestDeliveryOptionLookup) Cursor
}

// HypothesisTestDeliveryOptionLookupOrder defines the ordering of HypothesisTestDeliveryOptionLookup.
type HypothesisTestDeliveryOptionLookupOrder struct {
	Direction OrderDirection                                `json:"direction"`
	Field     *HypothesisTestDeliveryOptionLookupOrderField `json:"field"`
}

// DefaultHypothesisTestDeliveryOptionLookupOrder is the default ordering of HypothesisTestDeliveryOptionLookup.
var DefaultHypothesisTestDeliveryOptionLookupOrder = &HypothesisTestDeliveryOptionLookupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HypothesisTestDeliveryOptionLookupOrderField{
		Value: func(htdol *HypothesisTestDeliveryOptionLookup) (ent.Value, error) {
			return htdol.ID, nil
		},
		column: hypothesistestdeliveryoptionlookup.FieldID,
		toTerm: hypothesistestdeliveryoptionlookup.ByID,
		toCursor: func(htdol *HypothesisTestDeliveryOptionLookup) Cursor {
			return Cursor{ID: htdol.ID}
		},
	},
}

// ToEdge converts HypothesisTestDeliveryOptionLookup into HypothesisTestDeliveryOptionLookupEdge.
func (htdol *HypothesisTestDeliveryOptionLookup) ToEdge(order *HypothesisTestDeliveryOptionLookupOrder) *HypothesisTestDeliveryOptionLookupEdge {
	if order == nil {
		order = DefaultHypothesisTestDeliveryOptionLookupOrder
	}
	return &HypothesisTestDeliveryOptionLookupEdge{
		Node:   htdol,
		Cursor: order.Field.toCursor(htdol),
	}
}

// HypothesisTestDeliveryOptionRequestEdge is the edge representation of HypothesisTestDeliveryOptionRequest.
type HypothesisTestDeliveryOptionRequestEdge struct {
	Node   *HypothesisTestDeliveryOptionRequest `json:"node"`
	Cursor Cursor                               `json:"cursor"`
}

// HypothesisTestDeliveryOptionRequestConnection is the connection containing edges to HypothesisTestDeliveryOptionRequest.
type HypothesisTestDeliveryOptionRequestConnection struct {
	Edges      []*HypothesisTestDeliveryOptionRequestEdge `json:"edges"`
	PageInfo   PageInfo                                   `json:"pageInfo"`
	TotalCount int                                        `json:"totalCount"`
}

func (c *HypothesisTestDeliveryOptionRequestConnection) build(nodes []*HypothesisTestDeliveryOptionRequest, pager *hypothesistestdeliveryoptionrequestPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *HypothesisTestDeliveryOptionRequest
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *HypothesisTestDeliveryOptionRequest {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *HypothesisTestDeliveryOptionRequest {
			return nodes[i]
		}
	}
	c.Edges = make([]*HypothesisTestDeliveryOptionRequestEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &HypothesisTestDeliveryOptionRequestEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// HypothesisTestDeliveryOptionRequestPaginateOption enables pagination customization.
type HypothesisTestDeliveryOptionRequestPaginateOption func(*hypothesistestdeliveryoptionrequestPager) error

// WithHypothesisTestDeliveryOptionRequestOrder configures pagination ordering.
func WithHypothesisTestDeliveryOptionRequestOrder(order *HypothesisTestDeliveryOptionRequestOrder) HypothesisTestDeliveryOptionRequestPaginateOption {
	if order == nil {
		order = DefaultHypothesisTestDeliveryOptionRequestOrder
	}
	o := *order
	return func(pager *hypothesistestdeliveryoptionrequestPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultHypothesisTestDeliveryOptionRequestOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithHypothesisTestDeliveryOptionRequestFilter configures pagination filter.
func WithHypothesisTestDeliveryOptionRequestFilter(filter func(*HypothesisTestDeliveryOptionRequestQuery) (*HypothesisTestDeliveryOptionRequestQuery, error)) HypothesisTestDeliveryOptionRequestPaginateOption {
	return func(pager *hypothesistestdeliveryoptionrequestPager) error {
		if filter == nil {
			return errors.New("HypothesisTestDeliveryOptionRequestQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type hypothesistestdeliveryoptionrequestPager struct {
	reverse bool
	order   *HypothesisTestDeliveryOptionRequestOrder
	filter  func(*HypothesisTestDeliveryOptionRequestQuery) (*HypothesisTestDeliveryOptionRequestQuery, error)
}

func newHypothesisTestDeliveryOptionRequestPager(opts []HypothesisTestDeliveryOptionRequestPaginateOption, reverse bool) (*hypothesistestdeliveryoptionrequestPager, error) {
	pager := &hypothesistestdeliveryoptionrequestPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultHypothesisTestDeliveryOptionRequestOrder
	}
	return pager, nil
}

func (p *hypothesistestdeliveryoptionrequestPager) applyFilter(query *HypothesisTestDeliveryOptionRequestQuery) (*HypothesisTestDeliveryOptionRequestQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *hypothesistestdeliveryoptionrequestPager) toCursor(htdor *HypothesisTestDeliveryOptionRequest) Cursor {
	return p.order.Field.toCursor(htdor)
}

func (p *hypothesistestdeliveryoptionrequestPager) applyCursors(query *HypothesisTestDeliveryOptionRequestQuery, after, before *Cursor) (*HypothesisTestDeliveryOptionRequestQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultHypothesisTestDeliveryOptionRequestOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *hypothesistestdeliveryoptionrequestPager) applyOrder(query *HypothesisTestDeliveryOptionRequestQuery) *HypothesisTestDeliveryOptionRequestQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultHypothesisTestDeliveryOptionRequestOrder.Field {
		query = query.Order(DefaultHypothesisTestDeliveryOptionRequestOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *hypothesistestdeliveryoptionrequestPager) orderExpr(query *HypothesisTestDeliveryOptionRequestQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultHypothesisTestDeliveryOptionRequestOrder.Field {
			b.Comma().Ident(DefaultHypothesisTestDeliveryOptionRequestOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to HypothesisTestDeliveryOptionRequest.
func (htdor *HypothesisTestDeliveryOptionRequestQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...HypothesisTestDeliveryOptionRequestPaginateOption,
) (*HypothesisTestDeliveryOptionRequestConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newHypothesisTestDeliveryOptionRequestPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if htdor, err = pager.applyFilter(htdor); err != nil {
		return nil, err
	}
	conn := &HypothesisTestDeliveryOptionRequestConnection{Edges: []*HypothesisTestDeliveryOptionRequestEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := htdor.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if htdor, err = pager.applyCursors(htdor, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		htdor.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := htdor.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	htdor = pager.applyOrder(htdor)
	nodes, err := htdor.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// HypothesisTestDeliveryOptionRequestOrderField defines the ordering field of HypothesisTestDeliveryOptionRequest.
type HypothesisTestDeliveryOptionRequestOrderField struct {
	// Value extracts the ordering value from the given HypothesisTestDeliveryOptionRequest.
	Value    func(*HypothesisTestDeliveryOptionRequest) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) hypothesistestdeliveryoptionrequest.OrderOption
	toCursor func(*HypothesisTestDeliveryOptionRequest) Cursor
}

// HypothesisTestDeliveryOptionRequestOrder defines the ordering of HypothesisTestDeliveryOptionRequest.
type HypothesisTestDeliveryOptionRequestOrder struct {
	Direction OrderDirection                                 `json:"direction"`
	Field     *HypothesisTestDeliveryOptionRequestOrderField `json:"field"`
}

// DefaultHypothesisTestDeliveryOptionRequestOrder is the default ordering of HypothesisTestDeliveryOptionRequest.
var DefaultHypothesisTestDeliveryOptionRequestOrder = &HypothesisTestDeliveryOptionRequestOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &HypothesisTestDeliveryOptionRequestOrderField{
		Value: func(htdor *HypothesisTestDeliveryOptionRequest) (ent.Value, error) {
			return htdor.ID, nil
		},
		column: hypothesistestdeliveryoptionrequest.FieldID,
		toTerm: hypothesistestdeliveryoptionrequest.ByID,
		toCursor: func(htdor *HypothesisTestDeliveryOptionRequest) Cursor {
			return Cursor{ID: htdor.ID}
		},
	},
}

// ToEdge converts HypothesisTestDeliveryOptionRequest into HypothesisTestDeliveryOptionRequestEdge.
func (htdor *HypothesisTestDeliveryOptionRequest) ToEdge(order *HypothesisTestDeliveryOptionRequestOrder) *HypothesisTestDeliveryOptionRequestEdge {
	if order == nil {
		order = DefaultHypothesisTestDeliveryOptionRequestOrder
	}
	return &HypothesisTestDeliveryOptionRequestEdge{
		Node:   htdor,
		Cursor: order.Field.toCursor(htdor),
	}
}

// InventoryItemEdge is the edge representation of InventoryItem.
type InventoryItemEdge struct {
	Node   *InventoryItem `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// InventoryItemConnection is the connection containing edges to InventoryItem.
type InventoryItemConnection struct {
	Edges      []*InventoryItemEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *InventoryItemConnection) build(nodes []*InventoryItem, pager *inventoryitemPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *InventoryItem
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *InventoryItem {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *InventoryItem {
			return nodes[i]
		}
	}
	c.Edges = make([]*InventoryItemEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &InventoryItemEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// InventoryItemPaginateOption enables pagination customization.
type InventoryItemPaginateOption func(*inventoryitemPager) error

// WithInventoryItemOrder configures pagination ordering.
func WithInventoryItemOrder(order *InventoryItemOrder) InventoryItemPaginateOption {
	if order == nil {
		order = DefaultInventoryItemOrder
	}
	o := *order
	return func(pager *inventoryitemPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultInventoryItemOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithInventoryItemFilter configures pagination filter.
func WithInventoryItemFilter(filter func(*InventoryItemQuery) (*InventoryItemQuery, error)) InventoryItemPaginateOption {
	return func(pager *inventoryitemPager) error {
		if filter == nil {
			return errors.New("InventoryItemQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type inventoryitemPager struct {
	reverse bool
	order   *InventoryItemOrder
	filter  func(*InventoryItemQuery) (*InventoryItemQuery, error)
}

func newInventoryItemPager(opts []InventoryItemPaginateOption, reverse bool) (*inventoryitemPager, error) {
	pager := &inventoryitemPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultInventoryItemOrder
	}
	return pager, nil
}

func (p *inventoryitemPager) applyFilter(query *InventoryItemQuery) (*InventoryItemQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *inventoryitemPager) toCursor(ii *InventoryItem) Cursor {
	return p.order.Field.toCursor(ii)
}

func (p *inventoryitemPager) applyCursors(query *InventoryItemQuery, after, before *Cursor) (*InventoryItemQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultInventoryItemOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *inventoryitemPager) applyOrder(query *InventoryItemQuery) *InventoryItemQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultInventoryItemOrder.Field {
		query = query.Order(DefaultInventoryItemOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *inventoryitemPager) orderExpr(query *InventoryItemQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultInventoryItemOrder.Field {
			b.Comma().Ident(DefaultInventoryItemOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to InventoryItem.
func (ii *InventoryItemQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...InventoryItemPaginateOption,
) (*InventoryItemConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newInventoryItemPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ii, err = pager.applyFilter(ii); err != nil {
		return nil, err
	}
	conn := &InventoryItemConnection{Edges: []*InventoryItemEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ii.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ii, err = pager.applyCursors(ii, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ii.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ii.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ii = pager.applyOrder(ii)
	nodes, err := ii.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// InventoryItemOrderField defines the ordering field of InventoryItem.
type InventoryItemOrderField struct {
	// Value extracts the ordering value from the given InventoryItem.
	Value    func(*InventoryItem) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) inventoryitem.OrderOption
	toCursor func(*InventoryItem) Cursor
}

// InventoryItemOrder defines the ordering of InventoryItem.
type InventoryItemOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *InventoryItemOrderField `json:"field"`
}

// DefaultInventoryItemOrder is the default ordering of InventoryItem.
var DefaultInventoryItemOrder = &InventoryItemOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &InventoryItemOrderField{
		Value: func(ii *InventoryItem) (ent.Value, error) {
			return ii.ID, nil
		},
		column: inventoryitem.FieldID,
		toTerm: inventoryitem.ByID,
		toCursor: func(ii *InventoryItem) Cursor {
			return Cursor{ID: ii.ID}
		},
	},
}

// ToEdge converts InventoryItem into InventoryItemEdge.
func (ii *InventoryItem) ToEdge(order *InventoryItemOrder) *InventoryItemEdge {
	if order == nil {
		order = DefaultInventoryItemOrder
	}
	return &InventoryItemEdge{
		Node:   ii,
		Cursor: order.Field.toCursor(ii),
	}
}

// LanguageEdge is the edge representation of Language.
type LanguageEdge struct {
	Node   *Language `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// LanguageConnection is the connection containing edges to Language.
type LanguageConnection struct {
	Edges      []*LanguageEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *LanguageConnection) build(nodes []*Language, pager *languagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Language
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Language {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Language {
			return nodes[i]
		}
	}
	c.Edges = make([]*LanguageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LanguageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LanguagePaginateOption enables pagination customization.
type LanguagePaginateOption func(*languagePager) error

// WithLanguageOrder configures pagination ordering.
func WithLanguageOrder(order *LanguageOrder) LanguagePaginateOption {
	if order == nil {
		order = DefaultLanguageOrder
	}
	o := *order
	return func(pager *languagePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLanguageOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLanguageFilter configures pagination filter.
func WithLanguageFilter(filter func(*LanguageQuery) (*LanguageQuery, error)) LanguagePaginateOption {
	return func(pager *languagePager) error {
		if filter == nil {
			return errors.New("LanguageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type languagePager struct {
	reverse bool
	order   *LanguageOrder
	filter  func(*LanguageQuery) (*LanguageQuery, error)
}

func newLanguagePager(opts []LanguagePaginateOption, reverse bool) (*languagePager, error) {
	pager := &languagePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLanguageOrder
	}
	return pager, nil
}

func (p *languagePager) applyFilter(query *LanguageQuery) (*LanguageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *languagePager) toCursor(l *Language) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *languagePager) applyCursors(query *LanguageQuery, after, before *Cursor) (*LanguageQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLanguageOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *languagePager) applyOrder(query *LanguageQuery) *LanguageQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLanguageOrder.Field {
		query = query.Order(DefaultLanguageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *languagePager) orderExpr(query *LanguageQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLanguageOrder.Field {
			b.Comma().Ident(DefaultLanguageOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Language.
func (l *LanguageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LanguagePaginateOption,
) (*LanguageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLanguagePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LanguageConnection{Edges: []*LanguageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := l.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if l, err = pager.applyCursors(l, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	l = pager.applyOrder(l)
	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// LanguageOrderField defines the ordering field of Language.
type LanguageOrderField struct {
	// Value extracts the ordering value from the given Language.
	Value    func(*Language) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) language.OrderOption
	toCursor func(*Language) Cursor
}

// LanguageOrder defines the ordering of Language.
type LanguageOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *LanguageOrderField `json:"field"`
}

// DefaultLanguageOrder is the default ordering of Language.
var DefaultLanguageOrder = &LanguageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LanguageOrderField{
		Value: func(l *Language) (ent.Value, error) {
			return l.ID, nil
		},
		column: language.FieldID,
		toTerm: language.ByID,
		toCursor: func(l *Language) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts Language into LanguageEdge.
func (l *Language) ToEdge(order *LanguageOrder) *LanguageEdge {
	if order == nil {
		order = DefaultLanguageOrder
	}
	return &LanguageEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// LocationEdge is the edge representation of Location.
type LocationEdge struct {
	Node   *Location `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// LocationConnection is the connection containing edges to Location.
type LocationConnection struct {
	Edges      []*LocationEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *LocationConnection) build(nodes []*Location, pager *locationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Location
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Location {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Location {
			return nodes[i]
		}
	}
	c.Edges = make([]*LocationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LocationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LocationPaginateOption enables pagination customization.
type LocationPaginateOption func(*locationPager) error

// WithLocationOrder configures pagination ordering.
func WithLocationOrder(order *LocationOrder) LocationPaginateOption {
	if order == nil {
		order = DefaultLocationOrder
	}
	o := *order
	return func(pager *locationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLocationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLocationFilter configures pagination filter.
func WithLocationFilter(filter func(*LocationQuery) (*LocationQuery, error)) LocationPaginateOption {
	return func(pager *locationPager) error {
		if filter == nil {
			return errors.New("LocationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type locationPager struct {
	reverse bool
	order   *LocationOrder
	filter  func(*LocationQuery) (*LocationQuery, error)
}

func newLocationPager(opts []LocationPaginateOption, reverse bool) (*locationPager, error) {
	pager := &locationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLocationOrder
	}
	return pager, nil
}

func (p *locationPager) applyFilter(query *LocationQuery) (*LocationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *locationPager) toCursor(l *Location) Cursor {
	return p.order.Field.toCursor(l)
}

func (p *locationPager) applyCursors(query *LocationQuery, after, before *Cursor) (*LocationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLocationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *locationPager) applyOrder(query *LocationQuery) *LocationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLocationOrder.Field {
		query = query.Order(DefaultLocationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *locationPager) orderExpr(query *LocationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLocationOrder.Field {
			b.Comma().Ident(DefaultLocationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Location.
func (l *LocationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LocationPaginateOption,
) (*LocationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLocationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if l, err = pager.applyFilter(l); err != nil {
		return nil, err
	}
	conn := &LocationConnection{Edges: []*LocationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := l.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if l, err = pager.applyCursors(l, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		l.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := l.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	l = pager.applyOrder(l)
	nodes, err := l.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// LocationOrderField defines the ordering field of Location.
type LocationOrderField struct {
	// Value extracts the ordering value from the given Location.
	Value    func(*Location) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) location.OrderOption
	toCursor func(*Location) Cursor
}

// LocationOrder defines the ordering of Location.
type LocationOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *LocationOrderField `json:"field"`
}

// DefaultLocationOrder is the default ordering of Location.
var DefaultLocationOrder = &LocationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LocationOrderField{
		Value: func(l *Location) (ent.Value, error) {
			return l.ID, nil
		},
		column: location.FieldID,
		toTerm: location.ByID,
		toCursor: func(l *Location) Cursor {
			return Cursor{ID: l.ID}
		},
	},
}

// ToEdge converts Location into LocationEdge.
func (l *Location) ToEdge(order *LocationOrder) *LocationEdge {
	if order == nil {
		order = DefaultLocationOrder
	}
	return &LocationEdge{
		Node:   l,
		Cursor: order.Field.toCursor(l),
	}
}

// LocationTagEdge is the edge representation of LocationTag.
type LocationTagEdge struct {
	Node   *LocationTag `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// LocationTagConnection is the connection containing edges to LocationTag.
type LocationTagConnection struct {
	Edges      []*LocationTagEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *LocationTagConnection) build(nodes []*LocationTag, pager *locationtagPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *LocationTag
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *LocationTag {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *LocationTag {
			return nodes[i]
		}
	}
	c.Edges = make([]*LocationTagEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &LocationTagEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// LocationTagPaginateOption enables pagination customization.
type LocationTagPaginateOption func(*locationtagPager) error

// WithLocationTagOrder configures pagination ordering.
func WithLocationTagOrder(order *LocationTagOrder) LocationTagPaginateOption {
	if order == nil {
		order = DefaultLocationTagOrder
	}
	o := *order
	return func(pager *locationtagPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultLocationTagOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithLocationTagFilter configures pagination filter.
func WithLocationTagFilter(filter func(*LocationTagQuery) (*LocationTagQuery, error)) LocationTagPaginateOption {
	return func(pager *locationtagPager) error {
		if filter == nil {
			return errors.New("LocationTagQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type locationtagPager struct {
	reverse bool
	order   *LocationTagOrder
	filter  func(*LocationTagQuery) (*LocationTagQuery, error)
}

func newLocationTagPager(opts []LocationTagPaginateOption, reverse bool) (*locationtagPager, error) {
	pager := &locationtagPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultLocationTagOrder
	}
	return pager, nil
}

func (p *locationtagPager) applyFilter(query *LocationTagQuery) (*LocationTagQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *locationtagPager) toCursor(lt *LocationTag) Cursor {
	return p.order.Field.toCursor(lt)
}

func (p *locationtagPager) applyCursors(query *LocationTagQuery, after, before *Cursor) (*LocationTagQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultLocationTagOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *locationtagPager) applyOrder(query *LocationTagQuery) *LocationTagQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultLocationTagOrder.Field {
		query = query.Order(DefaultLocationTagOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *locationtagPager) orderExpr(query *LocationTagQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultLocationTagOrder.Field {
			b.Comma().Ident(DefaultLocationTagOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to LocationTag.
func (lt *LocationTagQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...LocationTagPaginateOption,
) (*LocationTagConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newLocationTagPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if lt, err = pager.applyFilter(lt); err != nil {
		return nil, err
	}
	conn := &LocationTagConnection{Edges: []*LocationTagEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := lt.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if lt, err = pager.applyCursors(lt, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		lt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := lt.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	lt = pager.applyOrder(lt)
	nodes, err := lt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// LocationTagOrderField defines the ordering field of LocationTag.
type LocationTagOrderField struct {
	// Value extracts the ordering value from the given LocationTag.
	Value    func(*LocationTag) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) locationtag.OrderOption
	toCursor func(*LocationTag) Cursor
}

// LocationTagOrder defines the ordering of LocationTag.
type LocationTagOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *LocationTagOrderField `json:"field"`
}

// DefaultLocationTagOrder is the default ordering of LocationTag.
var DefaultLocationTagOrder = &LocationTagOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &LocationTagOrderField{
		Value: func(lt *LocationTag) (ent.Value, error) {
			return lt.ID, nil
		},
		column: locationtag.FieldID,
		toTerm: locationtag.ByID,
		toCursor: func(lt *LocationTag) Cursor {
			return Cursor{ID: lt.ID}
		},
	},
}

// ToEdge converts LocationTag into LocationTagEdge.
func (lt *LocationTag) ToEdge(order *LocationTagOrder) *LocationTagEdge {
	if order == nil {
		order = DefaultLocationTagOrder
	}
	return &LocationTagEdge{
		Node:   lt,
		Cursor: order.Field.toCursor(lt),
	}
}

// NotificationEdge is the edge representation of Notification.
type NotificationEdge struct {
	Node   *Notification `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// NotificationConnection is the connection containing edges to Notification.
type NotificationConnection struct {
	Edges      []*NotificationEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *NotificationConnection) build(nodes []*Notification, pager *notificationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Notification
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Notification {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Notification {
			return nodes[i]
		}
	}
	c.Edges = make([]*NotificationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &NotificationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// NotificationPaginateOption enables pagination customization.
type NotificationPaginateOption func(*notificationPager) error

// WithNotificationOrder configures pagination ordering.
func WithNotificationOrder(order *NotificationOrder) NotificationPaginateOption {
	if order == nil {
		order = DefaultNotificationOrder
	}
	o := *order
	return func(pager *notificationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultNotificationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithNotificationFilter configures pagination filter.
func WithNotificationFilter(filter func(*NotificationQuery) (*NotificationQuery, error)) NotificationPaginateOption {
	return func(pager *notificationPager) error {
		if filter == nil {
			return errors.New("NotificationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type notificationPager struct {
	reverse bool
	order   *NotificationOrder
	filter  func(*NotificationQuery) (*NotificationQuery, error)
}

func newNotificationPager(opts []NotificationPaginateOption, reverse bool) (*notificationPager, error) {
	pager := &notificationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultNotificationOrder
	}
	return pager, nil
}

func (p *notificationPager) applyFilter(query *NotificationQuery) (*NotificationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *notificationPager) toCursor(n *Notification) Cursor {
	return p.order.Field.toCursor(n)
}

func (p *notificationPager) applyCursors(query *NotificationQuery, after, before *Cursor) (*NotificationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultNotificationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *notificationPager) applyOrder(query *NotificationQuery) *NotificationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultNotificationOrder.Field {
		query = query.Order(DefaultNotificationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *notificationPager) orderExpr(query *NotificationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultNotificationOrder.Field {
			b.Comma().Ident(DefaultNotificationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Notification.
func (n *NotificationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...NotificationPaginateOption,
) (*NotificationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newNotificationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if n, err = pager.applyFilter(n); err != nil {
		return nil, err
	}
	conn := &NotificationConnection{Edges: []*NotificationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := n.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if n, err = pager.applyCursors(n, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		n.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := n.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	n = pager.applyOrder(n)
	nodes, err := n.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// NotificationOrderField defines the ordering field of Notification.
type NotificationOrderField struct {
	// Value extracts the ordering value from the given Notification.
	Value    func(*Notification) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) notification.OrderOption
	toCursor func(*Notification) Cursor
}

// NotificationOrder defines the ordering of Notification.
type NotificationOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *NotificationOrderField `json:"field"`
}

// DefaultNotificationOrder is the default ordering of Notification.
var DefaultNotificationOrder = &NotificationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &NotificationOrderField{
		Value: func(n *Notification) (ent.Value, error) {
			return n.ID, nil
		},
		column: notification.FieldID,
		toTerm: notification.ByID,
		toCursor: func(n *Notification) Cursor {
			return Cursor{ID: n.ID}
		},
	},
}

// ToEdge converts Notification into NotificationEdge.
func (n *Notification) ToEdge(order *NotificationOrder) *NotificationEdge {
	if order == nil {
		order = DefaultNotificationOrder
	}
	return &NotificationEdge{
		Node:   n,
		Cursor: order.Field.toCursor(n),
	}
}

// OTKRequestsEdge is the edge representation of OTKRequests.
type OTKRequestsEdge struct {
	Node   *OTKRequests `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// OTKRequestsConnection is the connection containing edges to OTKRequests.
type OTKRequestsConnection struct {
	Edges      []*OTKRequestsEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *OTKRequestsConnection) build(nodes []*OTKRequests, pager *otkrequestsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OTKRequests
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OTKRequests {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OTKRequests {
			return nodes[i]
		}
	}
	c.Edges = make([]*OTKRequestsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OTKRequestsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OTKRequestsPaginateOption enables pagination customization.
type OTKRequestsPaginateOption func(*otkrequestsPager) error

// WithOTKRequestsOrder configures pagination ordering.
func WithOTKRequestsOrder(order *OTKRequestsOrder) OTKRequestsPaginateOption {
	if order == nil {
		order = DefaultOTKRequestsOrder
	}
	o := *order
	return func(pager *otkrequestsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOTKRequestsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOTKRequestsFilter configures pagination filter.
func WithOTKRequestsFilter(filter func(*OTKRequestsQuery) (*OTKRequestsQuery, error)) OTKRequestsPaginateOption {
	return func(pager *otkrequestsPager) error {
		if filter == nil {
			return errors.New("OTKRequestsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type otkrequestsPager struct {
	reverse bool
	order   *OTKRequestsOrder
	filter  func(*OTKRequestsQuery) (*OTKRequestsQuery, error)
}

func newOTKRequestsPager(opts []OTKRequestsPaginateOption, reverse bool) (*otkrequestsPager, error) {
	pager := &otkrequestsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOTKRequestsOrder
	}
	return pager, nil
}

func (p *otkrequestsPager) applyFilter(query *OTKRequestsQuery) (*OTKRequestsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *otkrequestsPager) toCursor(or *OTKRequests) Cursor {
	return p.order.Field.toCursor(or)
}

func (p *otkrequestsPager) applyCursors(query *OTKRequestsQuery, after, before *Cursor) (*OTKRequestsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOTKRequestsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *otkrequestsPager) applyOrder(query *OTKRequestsQuery) *OTKRequestsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOTKRequestsOrder.Field {
		query = query.Order(DefaultOTKRequestsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *otkrequestsPager) orderExpr(query *OTKRequestsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOTKRequestsOrder.Field {
			b.Comma().Ident(DefaultOTKRequestsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OTKRequests.
func (or *OTKRequestsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OTKRequestsPaginateOption,
) (*OTKRequestsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOTKRequestsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if or, err = pager.applyFilter(or); err != nil {
		return nil, err
	}
	conn := &OTKRequestsConnection{Edges: []*OTKRequestsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := or.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if or, err = pager.applyCursors(or, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		or.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := or.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	or = pager.applyOrder(or)
	nodes, err := or.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OTKRequestsOrderField defines the ordering field of OTKRequests.
type OTKRequestsOrderField struct {
	// Value extracts the ordering value from the given OTKRequests.
	Value    func(*OTKRequests) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) otkrequests.OrderOption
	toCursor func(*OTKRequests) Cursor
}

// OTKRequestsOrder defines the ordering of OTKRequests.
type OTKRequestsOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *OTKRequestsOrderField `json:"field"`
}

// DefaultOTKRequestsOrder is the default ordering of OTKRequests.
var DefaultOTKRequestsOrder = &OTKRequestsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OTKRequestsOrderField{
		Value: func(or *OTKRequests) (ent.Value, error) {
			return or.ID, nil
		},
		column: otkrequests.FieldID,
		toTerm: otkrequests.ByID,
		toCursor: func(or *OTKRequests) Cursor {
			return Cursor{ID: or.ID}
		},
	},
}

// ToEdge converts OTKRequests into OTKRequestsEdge.
func (or *OTKRequests) ToEdge(order *OTKRequestsOrder) *OTKRequestsEdge {
	if order == nil {
		order = DefaultOTKRequestsOrder
	}
	return &OTKRequestsEdge{
		Node:   or,
		Cursor: order.Field.toCursor(or),
	}
}

// OrderEdge is the edge representation of Order.
type OrderEdge struct {
	Node   *Order `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// OrderConnection is the connection containing edges to Order.
type OrderConnection struct {
	Edges      []*OrderEdge `json:"edges"`
	PageInfo   PageInfo     `json:"pageInfo"`
	TotalCount int          `json:"totalCount"`
}

func (c *OrderConnection) build(nodes []*Order, pager *orderPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Order
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Order {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Order {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrderEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrderEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrderPaginateOption enables pagination customization.
type OrderPaginateOption func(*orderPager) error

// WithOrderOrder configures pagination ordering.
func WithOrderOrder(order *OrderOrder) OrderPaginateOption {
	if order == nil {
		order = DefaultOrderOrder
	}
	o := *order
	return func(pager *orderPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrderOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrderFilter configures pagination filter.
func WithOrderFilter(filter func(*OrderQuery) (*OrderQuery, error)) OrderPaginateOption {
	return func(pager *orderPager) error {
		if filter == nil {
			return errors.New("OrderQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orderPager struct {
	reverse bool
	order   *OrderOrder
	filter  func(*OrderQuery) (*OrderQuery, error)
}

func newOrderPager(opts []OrderPaginateOption, reverse bool) (*orderPager, error) {
	pager := &orderPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrderOrder
	}
	return pager, nil
}

func (p *orderPager) applyFilter(query *OrderQuery) (*OrderQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orderPager) toCursor(o *Order) Cursor {
	return p.order.Field.toCursor(o)
}

func (p *orderPager) applyCursors(query *OrderQuery, after, before *Cursor) (*OrderQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrderOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orderPager) applyOrder(query *OrderQuery) *OrderQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrderOrder.Field {
		query = query.Order(DefaultOrderOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orderPager) orderExpr(query *OrderQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrderOrder.Field {
			b.Comma().Ident(DefaultOrderOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Order.
func (o *OrderQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrderPaginateOption,
) (*OrderConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrderPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if o, err = pager.applyFilter(o); err != nil {
		return nil, err
	}
	conn := &OrderConnection{Edges: []*OrderEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := o.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if o, err = pager.applyCursors(o, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		o.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := o.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	o = pager.applyOrder(o)
	nodes, err := o.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// OrderOrderFieldCreatedAt orders Order by created_at.
	OrderOrderFieldCreatedAt = &OrderOrderField{
		Value: func(o *Order) (ent.Value, error) {
			return o.CreatedAt, nil
		},
		column: order.FieldCreatedAt,
		toTerm: order.ByCreatedAt,
		toCursor: func(o *Order) Cursor {
			return Cursor{
				ID:    o.ID,
				Value: o.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f OrderOrderField) String() string {
	var str string
	switch f.column {
	case OrderOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f OrderOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *OrderOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("OrderOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *OrderOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid OrderOrderField", str)
	}
	return nil
}

// OrderOrderField defines the ordering field of Order.
type OrderOrderField struct {
	// Value extracts the ordering value from the given Order.
	Value    func(*Order) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) order.OrderOption
	toCursor func(*Order) Cursor
}

// OrderOrder defines the ordering of Order.
type OrderOrder struct {
	Direction OrderDirection   `json:"direction"`
	Field     *OrderOrderField `json:"field"`
}

// DefaultOrderOrder is the default ordering of Order.
var DefaultOrderOrder = &OrderOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrderOrderField{
		Value: func(o *Order) (ent.Value, error) {
			return o.ID, nil
		},
		column: order.FieldID,
		toTerm: order.ByID,
		toCursor: func(o *Order) Cursor {
			return Cursor{ID: o.ID}
		},
	},
}

// ToEdge converts Order into OrderEdge.
func (o *Order) ToEdge(order *OrderOrder) *OrderEdge {
	if order == nil {
		order = DefaultOrderOrder
	}
	return &OrderEdge{
		Node:   o,
		Cursor: order.Field.toCursor(o),
	}
}

// OrderHistoryEdge is the edge representation of OrderHistory.
type OrderHistoryEdge struct {
	Node   *OrderHistory `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// OrderHistoryConnection is the connection containing edges to OrderHistory.
type OrderHistoryConnection struct {
	Edges      []*OrderHistoryEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *OrderHistoryConnection) build(nodes []*OrderHistory, pager *orderhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrderHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrderHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrderHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrderHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrderHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrderHistoryPaginateOption enables pagination customization.
type OrderHistoryPaginateOption func(*orderhistoryPager) error

// WithOrderHistoryOrder configures pagination ordering.
func WithOrderHistoryOrder(order *OrderHistoryOrder) OrderHistoryPaginateOption {
	if order == nil {
		order = DefaultOrderHistoryOrder
	}
	o := *order
	return func(pager *orderhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrderHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrderHistoryFilter configures pagination filter.
func WithOrderHistoryFilter(filter func(*OrderHistoryQuery) (*OrderHistoryQuery, error)) OrderHistoryPaginateOption {
	return func(pager *orderhistoryPager) error {
		if filter == nil {
			return errors.New("OrderHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orderhistoryPager struct {
	reverse bool
	order   *OrderHistoryOrder
	filter  func(*OrderHistoryQuery) (*OrderHistoryQuery, error)
}

func newOrderHistoryPager(opts []OrderHistoryPaginateOption, reverse bool) (*orderhistoryPager, error) {
	pager := &orderhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrderHistoryOrder
	}
	return pager, nil
}

func (p *orderhistoryPager) applyFilter(query *OrderHistoryQuery) (*OrderHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orderhistoryPager) toCursor(oh *OrderHistory) Cursor {
	return p.order.Field.toCursor(oh)
}

func (p *orderhistoryPager) applyCursors(query *OrderHistoryQuery, after, before *Cursor) (*OrderHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrderHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orderhistoryPager) applyOrder(query *OrderHistoryQuery) *OrderHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrderHistoryOrder.Field {
		query = query.Order(DefaultOrderHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orderhistoryPager) orderExpr(query *OrderHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrderHistoryOrder.Field {
			b.Comma().Ident(DefaultOrderHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrderHistory.
func (oh *OrderHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrderHistoryPaginateOption,
) (*OrderHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrderHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if oh, err = pager.applyFilter(oh); err != nil {
		return nil, err
	}
	conn := &OrderHistoryConnection{Edges: []*OrderHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := oh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if oh, err = pager.applyCursors(oh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		oh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := oh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	oh = pager.applyOrder(oh)
	nodes, err := oh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrderHistoryOrderField defines the ordering field of OrderHistory.
type OrderHistoryOrderField struct {
	// Value extracts the ordering value from the given OrderHistory.
	Value    func(*OrderHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orderhistory.OrderOption
	toCursor func(*OrderHistory) Cursor
}

// OrderHistoryOrder defines the ordering of OrderHistory.
type OrderHistoryOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *OrderHistoryOrderField `json:"field"`
}

// DefaultOrderHistoryOrder is the default ordering of OrderHistory.
var DefaultOrderHistoryOrder = &OrderHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrderHistoryOrderField{
		Value: func(oh *OrderHistory) (ent.Value, error) {
			return oh.ID, nil
		},
		column: orderhistory.FieldID,
		toTerm: orderhistory.ByID,
		toCursor: func(oh *OrderHistory) Cursor {
			return Cursor{ID: oh.ID}
		},
	},
}

// ToEdge converts OrderHistory into OrderHistoryEdge.
func (oh *OrderHistory) ToEdge(order *OrderHistoryOrder) *OrderHistoryEdge {
	if order == nil {
		order = DefaultOrderHistoryOrder
	}
	return &OrderHistoryEdge{
		Node:   oh,
		Cursor: order.Field.toCursor(oh),
	}
}

// OrderLineEdge is the edge representation of OrderLine.
type OrderLineEdge struct {
	Node   *OrderLine `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// OrderLineConnection is the connection containing edges to OrderLine.
type OrderLineConnection struct {
	Edges      []*OrderLineEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *OrderLineConnection) build(nodes []*OrderLine, pager *orderlinePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrderLine
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrderLine {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrderLine {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrderLineEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrderLineEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrderLinePaginateOption enables pagination customization.
type OrderLinePaginateOption func(*orderlinePager) error

// WithOrderLineOrder configures pagination ordering.
func WithOrderLineOrder(order *OrderLineOrder) OrderLinePaginateOption {
	if order == nil {
		order = DefaultOrderLineOrder
	}
	o := *order
	return func(pager *orderlinePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrderLineOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrderLineFilter configures pagination filter.
func WithOrderLineFilter(filter func(*OrderLineQuery) (*OrderLineQuery, error)) OrderLinePaginateOption {
	return func(pager *orderlinePager) error {
		if filter == nil {
			return errors.New("OrderLineQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type orderlinePager struct {
	reverse bool
	order   *OrderLineOrder
	filter  func(*OrderLineQuery) (*OrderLineQuery, error)
}

func newOrderLinePager(opts []OrderLinePaginateOption, reverse bool) (*orderlinePager, error) {
	pager := &orderlinePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrderLineOrder
	}
	return pager, nil
}

func (p *orderlinePager) applyFilter(query *OrderLineQuery) (*OrderLineQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *orderlinePager) toCursor(ol *OrderLine) Cursor {
	return p.order.Field.toCursor(ol)
}

func (p *orderlinePager) applyCursors(query *OrderLineQuery, after, before *Cursor) (*OrderLineQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrderLineOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *orderlinePager) applyOrder(query *OrderLineQuery) *OrderLineQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrderLineOrder.Field {
		query = query.Order(DefaultOrderLineOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *orderlinePager) orderExpr(query *OrderLineQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrderLineOrder.Field {
			b.Comma().Ident(DefaultOrderLineOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrderLine.
func (ol *OrderLineQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrderLinePaginateOption,
) (*OrderLineConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrderLinePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ol, err = pager.applyFilter(ol); err != nil {
		return nil, err
	}
	conn := &OrderLineConnection{Edges: []*OrderLineEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ol.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ol, err = pager.applyCursors(ol, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ol.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ol.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ol = pager.applyOrder(ol)
	nodes, err := ol.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrderLineOrderField defines the ordering field of OrderLine.
type OrderLineOrderField struct {
	// Value extracts the ordering value from the given OrderLine.
	Value    func(*OrderLine) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) orderline.OrderOption
	toCursor func(*OrderLine) Cursor
}

// OrderLineOrder defines the ordering of OrderLine.
type OrderLineOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *OrderLineOrderField `json:"field"`
}

// DefaultOrderLineOrder is the default ordering of OrderLine.
var DefaultOrderLineOrder = &OrderLineOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrderLineOrderField{
		Value: func(ol *OrderLine) (ent.Value, error) {
			return ol.ID, nil
		},
		column: orderline.FieldID,
		toTerm: orderline.ByID,
		toCursor: func(ol *OrderLine) Cursor {
			return Cursor{ID: ol.ID}
		},
	},
}

// ToEdge converts OrderLine into OrderLineEdge.
func (ol *OrderLine) ToEdge(order *OrderLineOrder) *OrderLineEdge {
	if order == nil {
		order = DefaultOrderLineOrder
	}
	return &OrderLineEdge{
		Node:   ol,
		Cursor: order.Field.toCursor(ol),
	}
}

// OrderSenderEdge is the edge representation of OrderSender.
type OrderSenderEdge struct {
	Node   *OrderSender `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// OrderSenderConnection is the connection containing edges to OrderSender.
type OrderSenderConnection struct {
	Edges      []*OrderSenderEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *OrderSenderConnection) build(nodes []*OrderSender, pager *ordersenderPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *OrderSender
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *OrderSender {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *OrderSender {
			return nodes[i]
		}
	}
	c.Edges = make([]*OrderSenderEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &OrderSenderEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// OrderSenderPaginateOption enables pagination customization.
type OrderSenderPaginateOption func(*ordersenderPager) error

// WithOrderSenderOrder configures pagination ordering.
func WithOrderSenderOrder(order *OrderSenderOrder) OrderSenderPaginateOption {
	if order == nil {
		order = DefaultOrderSenderOrder
	}
	o := *order
	return func(pager *ordersenderPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultOrderSenderOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithOrderSenderFilter configures pagination filter.
func WithOrderSenderFilter(filter func(*OrderSenderQuery) (*OrderSenderQuery, error)) OrderSenderPaginateOption {
	return func(pager *ordersenderPager) error {
		if filter == nil {
			return errors.New("OrderSenderQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type ordersenderPager struct {
	reverse bool
	order   *OrderSenderOrder
	filter  func(*OrderSenderQuery) (*OrderSenderQuery, error)
}

func newOrderSenderPager(opts []OrderSenderPaginateOption, reverse bool) (*ordersenderPager, error) {
	pager := &ordersenderPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultOrderSenderOrder
	}
	return pager, nil
}

func (p *ordersenderPager) applyFilter(query *OrderSenderQuery) (*OrderSenderQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *ordersenderPager) toCursor(os *OrderSender) Cursor {
	return p.order.Field.toCursor(os)
}

func (p *ordersenderPager) applyCursors(query *OrderSenderQuery, after, before *Cursor) (*OrderSenderQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultOrderSenderOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *ordersenderPager) applyOrder(query *OrderSenderQuery) *OrderSenderQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultOrderSenderOrder.Field {
		query = query.Order(DefaultOrderSenderOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *ordersenderPager) orderExpr(query *OrderSenderQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultOrderSenderOrder.Field {
			b.Comma().Ident(DefaultOrderSenderOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to OrderSender.
func (os *OrderSenderQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...OrderSenderPaginateOption,
) (*OrderSenderConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newOrderSenderPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if os, err = pager.applyFilter(os); err != nil {
		return nil, err
	}
	conn := &OrderSenderConnection{Edges: []*OrderSenderEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := os.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if os, err = pager.applyCursors(os, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		os.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := os.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	os = pager.applyOrder(os)
	nodes, err := os.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// OrderSenderOrderField defines the ordering field of OrderSender.
type OrderSenderOrderField struct {
	// Value extracts the ordering value from the given OrderSender.
	Value    func(*OrderSender) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) ordersender.OrderOption
	toCursor func(*OrderSender) Cursor
}

// OrderSenderOrder defines the ordering of OrderSender.
type OrderSenderOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *OrderSenderOrderField `json:"field"`
}

// DefaultOrderSenderOrder is the default ordering of OrderSender.
var DefaultOrderSenderOrder = &OrderSenderOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &OrderSenderOrderField{
		Value: func(os *OrderSender) (ent.Value, error) {
			return os.ID, nil
		},
		column: ordersender.FieldID,
		toTerm: ordersender.ByID,
		toCursor: func(os *OrderSender) Cursor {
			return Cursor{ID: os.ID}
		},
	},
}

// ToEdge converts OrderSender into OrderSenderEdge.
func (os *OrderSender) ToEdge(order *OrderSenderOrder) *OrderSenderEdge {
	if order == nil {
		order = DefaultOrderSenderOrder
	}
	return &OrderSenderEdge{
		Node:   os,
		Cursor: order.Field.toCursor(os),
	}
}

// PackagingEdge is the edge representation of Packaging.
type PackagingEdge struct {
	Node   *Packaging `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// PackagingConnection is the connection containing edges to Packaging.
type PackagingConnection struct {
	Edges      []*PackagingEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *PackagingConnection) build(nodes []*Packaging, pager *packagingPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Packaging
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Packaging {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Packaging {
			return nodes[i]
		}
	}
	c.Edges = make([]*PackagingEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PackagingEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PackagingPaginateOption enables pagination customization.
type PackagingPaginateOption func(*packagingPager) error

// WithPackagingOrder configures pagination ordering.
func WithPackagingOrder(order *PackagingOrder) PackagingPaginateOption {
	if order == nil {
		order = DefaultPackagingOrder
	}
	o := *order
	return func(pager *packagingPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPackagingOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPackagingFilter configures pagination filter.
func WithPackagingFilter(filter func(*PackagingQuery) (*PackagingQuery, error)) PackagingPaginateOption {
	return func(pager *packagingPager) error {
		if filter == nil {
			return errors.New("PackagingQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type packagingPager struct {
	reverse bool
	order   *PackagingOrder
	filter  func(*PackagingQuery) (*PackagingQuery, error)
}

func newPackagingPager(opts []PackagingPaginateOption, reverse bool) (*packagingPager, error) {
	pager := &packagingPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPackagingOrder
	}
	return pager, nil
}

func (p *packagingPager) applyFilter(query *PackagingQuery) (*PackagingQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *packagingPager) toCursor(pa *Packaging) Cursor {
	return p.order.Field.toCursor(pa)
}

func (p *packagingPager) applyCursors(query *PackagingQuery, after, before *Cursor) (*PackagingQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPackagingOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *packagingPager) applyOrder(query *PackagingQuery) *PackagingQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPackagingOrder.Field {
		query = query.Order(DefaultPackagingOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *packagingPager) orderExpr(query *PackagingQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPackagingOrder.Field {
			b.Comma().Ident(DefaultPackagingOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Packaging.
func (pa *PackagingQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PackagingPaginateOption,
) (*PackagingConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPackagingPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &PackagingConnection{Edges: []*PackagingEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pa.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pa, err = pager.applyCursors(pa, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pa = pager.applyOrder(pa)
	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PackagingOrderField defines the ordering field of Packaging.
type PackagingOrderField struct {
	// Value extracts the ordering value from the given Packaging.
	Value    func(*Packaging) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) packaging.OrderOption
	toCursor func(*Packaging) Cursor
}

// PackagingOrder defines the ordering of Packaging.
type PackagingOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *PackagingOrderField `json:"field"`
}

// DefaultPackagingOrder is the default ordering of Packaging.
var DefaultPackagingOrder = &PackagingOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PackagingOrderField{
		Value: func(pa *Packaging) (ent.Value, error) {
			return pa.ID, nil
		},
		column: packaging.FieldID,
		toTerm: packaging.ByID,
		toCursor: func(pa *Packaging) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts Packaging into PackagingEdge.
func (pa *Packaging) ToEdge(order *PackagingOrder) *PackagingEdge {
	if order == nil {
		order = DefaultPackagingOrder
	}
	return &PackagingEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// PackagingDFEdge is the edge representation of PackagingDF.
type PackagingDFEdge struct {
	Node   *PackagingDF `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// PackagingDFConnection is the connection containing edges to PackagingDF.
type PackagingDFConnection struct {
	Edges      []*PackagingDFEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *PackagingDFConnection) build(nodes []*PackagingDF, pager *packagingdfPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PackagingDF
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PackagingDF {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PackagingDF {
			return nodes[i]
		}
	}
	c.Edges = make([]*PackagingDFEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PackagingDFEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PackagingDFPaginateOption enables pagination customization.
type PackagingDFPaginateOption func(*packagingdfPager) error

// WithPackagingDFOrder configures pagination ordering.
func WithPackagingDFOrder(order *PackagingDFOrder) PackagingDFPaginateOption {
	if order == nil {
		order = DefaultPackagingDFOrder
	}
	o := *order
	return func(pager *packagingdfPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPackagingDFOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPackagingDFFilter configures pagination filter.
func WithPackagingDFFilter(filter func(*PackagingDFQuery) (*PackagingDFQuery, error)) PackagingDFPaginateOption {
	return func(pager *packagingdfPager) error {
		if filter == nil {
			return errors.New("PackagingDFQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type packagingdfPager struct {
	reverse bool
	order   *PackagingDFOrder
	filter  func(*PackagingDFQuery) (*PackagingDFQuery, error)
}

func newPackagingDFPager(opts []PackagingDFPaginateOption, reverse bool) (*packagingdfPager, error) {
	pager := &packagingdfPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPackagingDFOrder
	}
	return pager, nil
}

func (p *packagingdfPager) applyFilter(query *PackagingDFQuery) (*PackagingDFQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *packagingdfPager) toCursor(pd *PackagingDF) Cursor {
	return p.order.Field.toCursor(pd)
}

func (p *packagingdfPager) applyCursors(query *PackagingDFQuery, after, before *Cursor) (*PackagingDFQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPackagingDFOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *packagingdfPager) applyOrder(query *PackagingDFQuery) *PackagingDFQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPackagingDFOrder.Field {
		query = query.Order(DefaultPackagingDFOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *packagingdfPager) orderExpr(query *PackagingDFQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPackagingDFOrder.Field {
			b.Comma().Ident(DefaultPackagingDFOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PackagingDF.
func (pd *PackagingDFQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PackagingDFPaginateOption,
) (*PackagingDFConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPackagingDFPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pd, err = pager.applyFilter(pd); err != nil {
		return nil, err
	}
	conn := &PackagingDFConnection{Edges: []*PackagingDFEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pd, err = pager.applyCursors(pd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pd = pager.applyOrder(pd)
	nodes, err := pd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PackagingDFOrderField defines the ordering field of PackagingDF.
type PackagingDFOrderField struct {
	// Value extracts the ordering value from the given PackagingDF.
	Value    func(*PackagingDF) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) packagingdf.OrderOption
	toCursor func(*PackagingDF) Cursor
}

// PackagingDFOrder defines the ordering of PackagingDF.
type PackagingDFOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *PackagingDFOrderField `json:"field"`
}

// DefaultPackagingDFOrder is the default ordering of PackagingDF.
var DefaultPackagingDFOrder = &PackagingDFOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PackagingDFOrderField{
		Value: func(pd *PackagingDF) (ent.Value, error) {
			return pd.ID, nil
		},
		column: packagingdf.FieldID,
		toTerm: packagingdf.ByID,
		toCursor: func(pd *PackagingDF) Cursor {
			return Cursor{ID: pd.ID}
		},
	},
}

// ToEdge converts PackagingDF into PackagingDFEdge.
func (pd *PackagingDF) ToEdge(order *PackagingDFOrder) *PackagingDFEdge {
	if order == nil {
		order = DefaultPackagingDFOrder
	}
	return &PackagingDFEdge{
		Node:   pd,
		Cursor: order.Field.toCursor(pd),
	}
}

// PackagingUSPSEdge is the edge representation of PackagingUSPS.
type PackagingUSPSEdge struct {
	Node   *PackagingUSPS `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// PackagingUSPSConnection is the connection containing edges to PackagingUSPS.
type PackagingUSPSConnection struct {
	Edges      []*PackagingUSPSEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *PackagingUSPSConnection) build(nodes []*PackagingUSPS, pager *packaginguspsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PackagingUSPS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PackagingUSPS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PackagingUSPS {
			return nodes[i]
		}
	}
	c.Edges = make([]*PackagingUSPSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PackagingUSPSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PackagingUSPSPaginateOption enables pagination customization.
type PackagingUSPSPaginateOption func(*packaginguspsPager) error

// WithPackagingUSPSOrder configures pagination ordering.
func WithPackagingUSPSOrder(order *PackagingUSPSOrder) PackagingUSPSPaginateOption {
	if order == nil {
		order = DefaultPackagingUSPSOrder
	}
	o := *order
	return func(pager *packaginguspsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPackagingUSPSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPackagingUSPSFilter configures pagination filter.
func WithPackagingUSPSFilter(filter func(*PackagingUSPSQuery) (*PackagingUSPSQuery, error)) PackagingUSPSPaginateOption {
	return func(pager *packaginguspsPager) error {
		if filter == nil {
			return errors.New("PackagingUSPSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type packaginguspsPager struct {
	reverse bool
	order   *PackagingUSPSOrder
	filter  func(*PackagingUSPSQuery) (*PackagingUSPSQuery, error)
}

func newPackagingUSPSPager(opts []PackagingUSPSPaginateOption, reverse bool) (*packaginguspsPager, error) {
	pager := &packaginguspsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPackagingUSPSOrder
	}
	return pager, nil
}

func (p *packaginguspsPager) applyFilter(query *PackagingUSPSQuery) (*PackagingUSPSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *packaginguspsPager) toCursor(pu *PackagingUSPS) Cursor {
	return p.order.Field.toCursor(pu)
}

func (p *packaginguspsPager) applyCursors(query *PackagingUSPSQuery, after, before *Cursor) (*PackagingUSPSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPackagingUSPSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *packaginguspsPager) applyOrder(query *PackagingUSPSQuery) *PackagingUSPSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPackagingUSPSOrder.Field {
		query = query.Order(DefaultPackagingUSPSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *packaginguspsPager) orderExpr(query *PackagingUSPSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPackagingUSPSOrder.Field {
			b.Comma().Ident(DefaultPackagingUSPSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PackagingUSPS.
func (pu *PackagingUSPSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PackagingUSPSPaginateOption,
) (*PackagingUSPSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPackagingUSPSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pu, err = pager.applyFilter(pu); err != nil {
		return nil, err
	}
	conn := &PackagingUSPSConnection{Edges: []*PackagingUSPSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pu.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pu, err = pager.applyCursors(pu, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pu.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pu.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pu = pager.applyOrder(pu)
	nodes, err := pu.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PackagingUSPSOrderField defines the ordering field of PackagingUSPS.
type PackagingUSPSOrderField struct {
	// Value extracts the ordering value from the given PackagingUSPS.
	Value    func(*PackagingUSPS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) packagingusps.OrderOption
	toCursor func(*PackagingUSPS) Cursor
}

// PackagingUSPSOrder defines the ordering of PackagingUSPS.
type PackagingUSPSOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *PackagingUSPSOrderField `json:"field"`
}

// DefaultPackagingUSPSOrder is the default ordering of PackagingUSPS.
var DefaultPackagingUSPSOrder = &PackagingUSPSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PackagingUSPSOrderField{
		Value: func(pu *PackagingUSPS) (ent.Value, error) {
			return pu.ID, nil
		},
		column: packagingusps.FieldID,
		toTerm: packagingusps.ByID,
		toCursor: func(pu *PackagingUSPS) Cursor {
			return Cursor{ID: pu.ID}
		},
	},
}

// ToEdge converts PackagingUSPS into PackagingUSPSEdge.
func (pu *PackagingUSPS) ToEdge(order *PackagingUSPSOrder) *PackagingUSPSEdge {
	if order == nil {
		order = DefaultPackagingUSPSOrder
	}
	return &PackagingUSPSEdge{
		Node:   pu,
		Cursor: order.Field.toCursor(pu),
	}
}

// PackagingUSPSProcessingCategoryEdge is the edge representation of PackagingUSPSProcessingCategory.
type PackagingUSPSProcessingCategoryEdge struct {
	Node   *PackagingUSPSProcessingCategory `json:"node"`
	Cursor Cursor                           `json:"cursor"`
}

// PackagingUSPSProcessingCategoryConnection is the connection containing edges to PackagingUSPSProcessingCategory.
type PackagingUSPSProcessingCategoryConnection struct {
	Edges      []*PackagingUSPSProcessingCategoryEdge `json:"edges"`
	PageInfo   PageInfo                               `json:"pageInfo"`
	TotalCount int                                    `json:"totalCount"`
}

func (c *PackagingUSPSProcessingCategoryConnection) build(nodes []*PackagingUSPSProcessingCategory, pager *packaginguspsprocessingcategoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PackagingUSPSProcessingCategory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PackagingUSPSProcessingCategory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PackagingUSPSProcessingCategory {
			return nodes[i]
		}
	}
	c.Edges = make([]*PackagingUSPSProcessingCategoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PackagingUSPSProcessingCategoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PackagingUSPSProcessingCategoryPaginateOption enables pagination customization.
type PackagingUSPSProcessingCategoryPaginateOption func(*packaginguspsprocessingcategoryPager) error

// WithPackagingUSPSProcessingCategoryOrder configures pagination ordering.
func WithPackagingUSPSProcessingCategoryOrder(order *PackagingUSPSProcessingCategoryOrder) PackagingUSPSProcessingCategoryPaginateOption {
	if order == nil {
		order = DefaultPackagingUSPSProcessingCategoryOrder
	}
	o := *order
	return func(pager *packaginguspsprocessingcategoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPackagingUSPSProcessingCategoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPackagingUSPSProcessingCategoryFilter configures pagination filter.
func WithPackagingUSPSProcessingCategoryFilter(filter func(*PackagingUSPSProcessingCategoryQuery) (*PackagingUSPSProcessingCategoryQuery, error)) PackagingUSPSProcessingCategoryPaginateOption {
	return func(pager *packaginguspsprocessingcategoryPager) error {
		if filter == nil {
			return errors.New("PackagingUSPSProcessingCategoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type packaginguspsprocessingcategoryPager struct {
	reverse bool
	order   *PackagingUSPSProcessingCategoryOrder
	filter  func(*PackagingUSPSProcessingCategoryQuery) (*PackagingUSPSProcessingCategoryQuery, error)
}

func newPackagingUSPSProcessingCategoryPager(opts []PackagingUSPSProcessingCategoryPaginateOption, reverse bool) (*packaginguspsprocessingcategoryPager, error) {
	pager := &packaginguspsprocessingcategoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPackagingUSPSProcessingCategoryOrder
	}
	return pager, nil
}

func (p *packaginguspsprocessingcategoryPager) applyFilter(query *PackagingUSPSProcessingCategoryQuery) (*PackagingUSPSProcessingCategoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *packaginguspsprocessingcategoryPager) toCursor(pupc *PackagingUSPSProcessingCategory) Cursor {
	return p.order.Field.toCursor(pupc)
}

func (p *packaginguspsprocessingcategoryPager) applyCursors(query *PackagingUSPSProcessingCategoryQuery, after, before *Cursor) (*PackagingUSPSProcessingCategoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPackagingUSPSProcessingCategoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *packaginguspsprocessingcategoryPager) applyOrder(query *PackagingUSPSProcessingCategoryQuery) *PackagingUSPSProcessingCategoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPackagingUSPSProcessingCategoryOrder.Field {
		query = query.Order(DefaultPackagingUSPSProcessingCategoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *packaginguspsprocessingcategoryPager) orderExpr(query *PackagingUSPSProcessingCategoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPackagingUSPSProcessingCategoryOrder.Field {
			b.Comma().Ident(DefaultPackagingUSPSProcessingCategoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PackagingUSPSProcessingCategory.
func (pupc *PackagingUSPSProcessingCategoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PackagingUSPSProcessingCategoryPaginateOption,
) (*PackagingUSPSProcessingCategoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPackagingUSPSProcessingCategoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pupc, err = pager.applyFilter(pupc); err != nil {
		return nil, err
	}
	conn := &PackagingUSPSProcessingCategoryConnection{Edges: []*PackagingUSPSProcessingCategoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pupc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pupc, err = pager.applyCursors(pupc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pupc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pupc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pupc = pager.applyOrder(pupc)
	nodes, err := pupc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PackagingUSPSProcessingCategoryOrderField defines the ordering field of PackagingUSPSProcessingCategory.
type PackagingUSPSProcessingCategoryOrderField struct {
	// Value extracts the ordering value from the given PackagingUSPSProcessingCategory.
	Value    func(*PackagingUSPSProcessingCategory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) packaginguspsprocessingcategory.OrderOption
	toCursor func(*PackagingUSPSProcessingCategory) Cursor
}

// PackagingUSPSProcessingCategoryOrder defines the ordering of PackagingUSPSProcessingCategory.
type PackagingUSPSProcessingCategoryOrder struct {
	Direction OrderDirection                             `json:"direction"`
	Field     *PackagingUSPSProcessingCategoryOrderField `json:"field"`
}

// DefaultPackagingUSPSProcessingCategoryOrder is the default ordering of PackagingUSPSProcessingCategory.
var DefaultPackagingUSPSProcessingCategoryOrder = &PackagingUSPSProcessingCategoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PackagingUSPSProcessingCategoryOrderField{
		Value: func(pupc *PackagingUSPSProcessingCategory) (ent.Value, error) {
			return pupc.ID, nil
		},
		column: packaginguspsprocessingcategory.FieldID,
		toTerm: packaginguspsprocessingcategory.ByID,
		toCursor: func(pupc *PackagingUSPSProcessingCategory) Cursor {
			return Cursor{ID: pupc.ID}
		},
	},
}

// ToEdge converts PackagingUSPSProcessingCategory into PackagingUSPSProcessingCategoryEdge.
func (pupc *PackagingUSPSProcessingCategory) ToEdge(order *PackagingUSPSProcessingCategoryOrder) *PackagingUSPSProcessingCategoryEdge {
	if order == nil {
		order = DefaultPackagingUSPSProcessingCategoryOrder
	}
	return &PackagingUSPSProcessingCategoryEdge{
		Node:   pupc,
		Cursor: order.Field.toCursor(pupc),
	}
}

// PackagingUSPSRateIndicatorEdge is the edge representation of PackagingUSPSRateIndicator.
type PackagingUSPSRateIndicatorEdge struct {
	Node   *PackagingUSPSRateIndicator `json:"node"`
	Cursor Cursor                      `json:"cursor"`
}

// PackagingUSPSRateIndicatorConnection is the connection containing edges to PackagingUSPSRateIndicator.
type PackagingUSPSRateIndicatorConnection struct {
	Edges      []*PackagingUSPSRateIndicatorEdge `json:"edges"`
	PageInfo   PageInfo                          `json:"pageInfo"`
	TotalCount int                               `json:"totalCount"`
}

func (c *PackagingUSPSRateIndicatorConnection) build(nodes []*PackagingUSPSRateIndicator, pager *packaginguspsrateindicatorPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PackagingUSPSRateIndicator
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PackagingUSPSRateIndicator {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PackagingUSPSRateIndicator {
			return nodes[i]
		}
	}
	c.Edges = make([]*PackagingUSPSRateIndicatorEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PackagingUSPSRateIndicatorEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PackagingUSPSRateIndicatorPaginateOption enables pagination customization.
type PackagingUSPSRateIndicatorPaginateOption func(*packaginguspsrateindicatorPager) error

// WithPackagingUSPSRateIndicatorOrder configures pagination ordering.
func WithPackagingUSPSRateIndicatorOrder(order *PackagingUSPSRateIndicatorOrder) PackagingUSPSRateIndicatorPaginateOption {
	if order == nil {
		order = DefaultPackagingUSPSRateIndicatorOrder
	}
	o := *order
	return func(pager *packaginguspsrateindicatorPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPackagingUSPSRateIndicatorOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPackagingUSPSRateIndicatorFilter configures pagination filter.
func WithPackagingUSPSRateIndicatorFilter(filter func(*PackagingUSPSRateIndicatorQuery) (*PackagingUSPSRateIndicatorQuery, error)) PackagingUSPSRateIndicatorPaginateOption {
	return func(pager *packaginguspsrateindicatorPager) error {
		if filter == nil {
			return errors.New("PackagingUSPSRateIndicatorQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type packaginguspsrateindicatorPager struct {
	reverse bool
	order   *PackagingUSPSRateIndicatorOrder
	filter  func(*PackagingUSPSRateIndicatorQuery) (*PackagingUSPSRateIndicatorQuery, error)
}

func newPackagingUSPSRateIndicatorPager(opts []PackagingUSPSRateIndicatorPaginateOption, reverse bool) (*packaginguspsrateindicatorPager, error) {
	pager := &packaginguspsrateindicatorPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPackagingUSPSRateIndicatorOrder
	}
	return pager, nil
}

func (p *packaginguspsrateindicatorPager) applyFilter(query *PackagingUSPSRateIndicatorQuery) (*PackagingUSPSRateIndicatorQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *packaginguspsrateindicatorPager) toCursor(puri *PackagingUSPSRateIndicator) Cursor {
	return p.order.Field.toCursor(puri)
}

func (p *packaginguspsrateindicatorPager) applyCursors(query *PackagingUSPSRateIndicatorQuery, after, before *Cursor) (*PackagingUSPSRateIndicatorQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPackagingUSPSRateIndicatorOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *packaginguspsrateindicatorPager) applyOrder(query *PackagingUSPSRateIndicatorQuery) *PackagingUSPSRateIndicatorQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPackagingUSPSRateIndicatorOrder.Field {
		query = query.Order(DefaultPackagingUSPSRateIndicatorOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *packaginguspsrateindicatorPager) orderExpr(query *PackagingUSPSRateIndicatorQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPackagingUSPSRateIndicatorOrder.Field {
			b.Comma().Ident(DefaultPackagingUSPSRateIndicatorOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PackagingUSPSRateIndicator.
func (puri *PackagingUSPSRateIndicatorQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PackagingUSPSRateIndicatorPaginateOption,
) (*PackagingUSPSRateIndicatorConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPackagingUSPSRateIndicatorPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if puri, err = pager.applyFilter(puri); err != nil {
		return nil, err
	}
	conn := &PackagingUSPSRateIndicatorConnection{Edges: []*PackagingUSPSRateIndicatorEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := puri.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if puri, err = pager.applyCursors(puri, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		puri.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := puri.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	puri = pager.applyOrder(puri)
	nodes, err := puri.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PackagingUSPSRateIndicatorOrderField defines the ordering field of PackagingUSPSRateIndicator.
type PackagingUSPSRateIndicatorOrderField struct {
	// Value extracts the ordering value from the given PackagingUSPSRateIndicator.
	Value    func(*PackagingUSPSRateIndicator) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) packaginguspsrateindicator.OrderOption
	toCursor func(*PackagingUSPSRateIndicator) Cursor
}

// PackagingUSPSRateIndicatorOrder defines the ordering of PackagingUSPSRateIndicator.
type PackagingUSPSRateIndicatorOrder struct {
	Direction OrderDirection                        `json:"direction"`
	Field     *PackagingUSPSRateIndicatorOrderField `json:"field"`
}

// DefaultPackagingUSPSRateIndicatorOrder is the default ordering of PackagingUSPSRateIndicator.
var DefaultPackagingUSPSRateIndicatorOrder = &PackagingUSPSRateIndicatorOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PackagingUSPSRateIndicatorOrderField{
		Value: func(puri *PackagingUSPSRateIndicator) (ent.Value, error) {
			return puri.ID, nil
		},
		column: packaginguspsrateindicator.FieldID,
		toTerm: packaginguspsrateindicator.ByID,
		toCursor: func(puri *PackagingUSPSRateIndicator) Cursor {
			return Cursor{ID: puri.ID}
		},
	},
}

// ToEdge converts PackagingUSPSRateIndicator into PackagingUSPSRateIndicatorEdge.
func (puri *PackagingUSPSRateIndicator) ToEdge(order *PackagingUSPSRateIndicatorOrder) *PackagingUSPSRateIndicatorEdge {
	if order == nil {
		order = DefaultPackagingUSPSRateIndicatorOrder
	}
	return &PackagingUSPSRateIndicatorEdge{
		Node:   puri,
		Cursor: order.Field.toCursor(puri),
	}
}

// PalletEdge is the edge representation of Pallet.
type PalletEdge struct {
	Node   *Pallet `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// PalletConnection is the connection containing edges to Pallet.
type PalletConnection struct {
	Edges      []*PalletEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *PalletConnection) build(nodes []*Pallet, pager *palletPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Pallet
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Pallet {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Pallet {
			return nodes[i]
		}
	}
	c.Edges = make([]*PalletEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PalletEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PalletPaginateOption enables pagination customization.
type PalletPaginateOption func(*palletPager) error

// WithPalletOrder configures pagination ordering.
func WithPalletOrder(order *PalletOrder) PalletPaginateOption {
	if order == nil {
		order = DefaultPalletOrder
	}
	o := *order
	return func(pager *palletPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPalletOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPalletFilter configures pagination filter.
func WithPalletFilter(filter func(*PalletQuery) (*PalletQuery, error)) PalletPaginateOption {
	return func(pager *palletPager) error {
		if filter == nil {
			return errors.New("PalletQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type palletPager struct {
	reverse bool
	order   *PalletOrder
	filter  func(*PalletQuery) (*PalletQuery, error)
}

func newPalletPager(opts []PalletPaginateOption, reverse bool) (*palletPager, error) {
	pager := &palletPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPalletOrder
	}
	return pager, nil
}

func (p *palletPager) applyFilter(query *PalletQuery) (*PalletQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *palletPager) toCursor(pa *Pallet) Cursor {
	return p.order.Field.toCursor(pa)
}

func (p *palletPager) applyCursors(query *PalletQuery, after, before *Cursor) (*PalletQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPalletOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *palletPager) applyOrder(query *PalletQuery) *PalletQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPalletOrder.Field {
		query = query.Order(DefaultPalletOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *palletPager) orderExpr(query *PalletQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPalletOrder.Field {
			b.Comma().Ident(DefaultPalletOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Pallet.
func (pa *PalletQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PalletPaginateOption,
) (*PalletConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPalletPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pa, err = pager.applyFilter(pa); err != nil {
		return nil, err
	}
	conn := &PalletConnection{Edges: []*PalletEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pa.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pa, err = pager.applyCursors(pa, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pa.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pa.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pa = pager.applyOrder(pa)
	nodes, err := pa.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PalletOrderField defines the ordering field of Pallet.
type PalletOrderField struct {
	// Value extracts the ordering value from the given Pallet.
	Value    func(*Pallet) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) pallet.OrderOption
	toCursor func(*Pallet) Cursor
}

// PalletOrder defines the ordering of Pallet.
type PalletOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *PalletOrderField `json:"field"`
}

// DefaultPalletOrder is the default ordering of Pallet.
var DefaultPalletOrder = &PalletOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PalletOrderField{
		Value: func(pa *Pallet) (ent.Value, error) {
			return pa.ID, nil
		},
		column: pallet.FieldID,
		toTerm: pallet.ByID,
		toCursor: func(pa *Pallet) Cursor {
			return Cursor{ID: pa.ID}
		},
	},
}

// ToEdge converts Pallet into PalletEdge.
func (pa *Pallet) ToEdge(order *PalletOrder) *PalletEdge {
	if order == nil {
		order = DefaultPalletOrder
	}
	return &PalletEdge{
		Node:   pa,
		Cursor: order.Field.toCursor(pa),
	}
}

// ParcelShopEdge is the edge representation of ParcelShop.
type ParcelShopEdge struct {
	Node   *ParcelShop `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ParcelShopConnection is the connection containing edges to ParcelShop.
type ParcelShopConnection struct {
	Edges      []*ParcelShopEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ParcelShopConnection) build(nodes []*ParcelShop, pager *parcelshopPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ParcelShop
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ParcelShop {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ParcelShop {
			return nodes[i]
		}
	}
	c.Edges = make([]*ParcelShopEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ParcelShopEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ParcelShopPaginateOption enables pagination customization.
type ParcelShopPaginateOption func(*parcelshopPager) error

// WithParcelShopOrder configures pagination ordering.
func WithParcelShopOrder(order *ParcelShopOrder) ParcelShopPaginateOption {
	if order == nil {
		order = DefaultParcelShopOrder
	}
	o := *order
	return func(pager *parcelshopPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultParcelShopOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithParcelShopFilter configures pagination filter.
func WithParcelShopFilter(filter func(*ParcelShopQuery) (*ParcelShopQuery, error)) ParcelShopPaginateOption {
	return func(pager *parcelshopPager) error {
		if filter == nil {
			return errors.New("ParcelShopQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type parcelshopPager struct {
	reverse bool
	order   *ParcelShopOrder
	filter  func(*ParcelShopQuery) (*ParcelShopQuery, error)
}

func newParcelShopPager(opts []ParcelShopPaginateOption, reverse bool) (*parcelshopPager, error) {
	pager := &parcelshopPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultParcelShopOrder
	}
	return pager, nil
}

func (p *parcelshopPager) applyFilter(query *ParcelShopQuery) (*ParcelShopQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *parcelshopPager) toCursor(ps *ParcelShop) Cursor {
	return p.order.Field.toCursor(ps)
}

func (p *parcelshopPager) applyCursors(query *ParcelShopQuery, after, before *Cursor) (*ParcelShopQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultParcelShopOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *parcelshopPager) applyOrder(query *ParcelShopQuery) *ParcelShopQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultParcelShopOrder.Field {
		query = query.Order(DefaultParcelShopOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *parcelshopPager) orderExpr(query *ParcelShopQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultParcelShopOrder.Field {
			b.Comma().Ident(DefaultParcelShopOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ParcelShop.
func (ps *ParcelShopQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ParcelShopPaginateOption,
) (*ParcelShopConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newParcelShopPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ps, err = pager.applyFilter(ps); err != nil {
		return nil, err
	}
	conn := &ParcelShopConnection{Edges: []*ParcelShopEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ps.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ps, err = pager.applyCursors(ps, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ps.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ps.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ps = pager.applyOrder(ps)
	nodes, err := ps.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ParcelShopOrderField defines the ordering field of ParcelShop.
type ParcelShopOrderField struct {
	// Value extracts the ordering value from the given ParcelShop.
	Value    func(*ParcelShop) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) parcelshop.OrderOption
	toCursor func(*ParcelShop) Cursor
}

// ParcelShopOrder defines the ordering of ParcelShop.
type ParcelShopOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ParcelShopOrderField `json:"field"`
}

// DefaultParcelShopOrder is the default ordering of ParcelShop.
var DefaultParcelShopOrder = &ParcelShopOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ParcelShopOrderField{
		Value: func(ps *ParcelShop) (ent.Value, error) {
			return ps.ID, nil
		},
		column: parcelshop.FieldID,
		toTerm: parcelshop.ByID,
		toCursor: func(ps *ParcelShop) Cursor {
			return Cursor{ID: ps.ID}
		},
	},
}

// ToEdge converts ParcelShop into ParcelShopEdge.
func (ps *ParcelShop) ToEdge(order *ParcelShopOrder) *ParcelShopEdge {
	if order == nil {
		order = DefaultParcelShopOrder
	}
	return &ParcelShopEdge{
		Node:   ps,
		Cursor: order.Field.toCursor(ps),
	}
}

// ParcelShopBringEdge is the edge representation of ParcelShopBring.
type ParcelShopBringEdge struct {
	Node   *ParcelShopBring `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ParcelShopBringConnection is the connection containing edges to ParcelShopBring.
type ParcelShopBringConnection struct {
	Edges      []*ParcelShopBringEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ParcelShopBringConnection) build(nodes []*ParcelShopBring, pager *parcelshopbringPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ParcelShopBring
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ParcelShopBring {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ParcelShopBring {
			return nodes[i]
		}
	}
	c.Edges = make([]*ParcelShopBringEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ParcelShopBringEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ParcelShopBringPaginateOption enables pagination customization.
type ParcelShopBringPaginateOption func(*parcelshopbringPager) error

// WithParcelShopBringOrder configures pagination ordering.
func WithParcelShopBringOrder(order *ParcelShopBringOrder) ParcelShopBringPaginateOption {
	if order == nil {
		order = DefaultParcelShopBringOrder
	}
	o := *order
	return func(pager *parcelshopbringPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultParcelShopBringOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithParcelShopBringFilter configures pagination filter.
func WithParcelShopBringFilter(filter func(*ParcelShopBringQuery) (*ParcelShopBringQuery, error)) ParcelShopBringPaginateOption {
	return func(pager *parcelshopbringPager) error {
		if filter == nil {
			return errors.New("ParcelShopBringQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type parcelshopbringPager struct {
	reverse bool
	order   *ParcelShopBringOrder
	filter  func(*ParcelShopBringQuery) (*ParcelShopBringQuery, error)
}

func newParcelShopBringPager(opts []ParcelShopBringPaginateOption, reverse bool) (*parcelshopbringPager, error) {
	pager := &parcelshopbringPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultParcelShopBringOrder
	}
	return pager, nil
}

func (p *parcelshopbringPager) applyFilter(query *ParcelShopBringQuery) (*ParcelShopBringQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *parcelshopbringPager) toCursor(psb *ParcelShopBring) Cursor {
	return p.order.Field.toCursor(psb)
}

func (p *parcelshopbringPager) applyCursors(query *ParcelShopBringQuery, after, before *Cursor) (*ParcelShopBringQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultParcelShopBringOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *parcelshopbringPager) applyOrder(query *ParcelShopBringQuery) *ParcelShopBringQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultParcelShopBringOrder.Field {
		query = query.Order(DefaultParcelShopBringOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *parcelshopbringPager) orderExpr(query *ParcelShopBringQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultParcelShopBringOrder.Field {
			b.Comma().Ident(DefaultParcelShopBringOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ParcelShopBring.
func (psb *ParcelShopBringQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ParcelShopBringPaginateOption,
) (*ParcelShopBringConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newParcelShopBringPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if psb, err = pager.applyFilter(psb); err != nil {
		return nil, err
	}
	conn := &ParcelShopBringConnection{Edges: []*ParcelShopBringEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := psb.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if psb, err = pager.applyCursors(psb, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		psb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := psb.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	psb = pager.applyOrder(psb)
	nodes, err := psb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ParcelShopBringOrderField defines the ordering field of ParcelShopBring.
type ParcelShopBringOrderField struct {
	// Value extracts the ordering value from the given ParcelShopBring.
	Value    func(*ParcelShopBring) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) parcelshopbring.OrderOption
	toCursor func(*ParcelShopBring) Cursor
}

// ParcelShopBringOrder defines the ordering of ParcelShopBring.
type ParcelShopBringOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ParcelShopBringOrderField `json:"field"`
}

// DefaultParcelShopBringOrder is the default ordering of ParcelShopBring.
var DefaultParcelShopBringOrder = &ParcelShopBringOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ParcelShopBringOrderField{
		Value: func(psb *ParcelShopBring) (ent.Value, error) {
			return psb.ID, nil
		},
		column: parcelshopbring.FieldID,
		toTerm: parcelshopbring.ByID,
		toCursor: func(psb *ParcelShopBring) Cursor {
			return Cursor{ID: psb.ID}
		},
	},
}

// ToEdge converts ParcelShopBring into ParcelShopBringEdge.
func (psb *ParcelShopBring) ToEdge(order *ParcelShopBringOrder) *ParcelShopBringEdge {
	if order == nil {
		order = DefaultParcelShopBringOrder
	}
	return &ParcelShopBringEdge{
		Node:   psb,
		Cursor: order.Field.toCursor(psb),
	}
}

// ParcelShopDAOEdge is the edge representation of ParcelShopDAO.
type ParcelShopDAOEdge struct {
	Node   *ParcelShopDAO `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ParcelShopDAOConnection is the connection containing edges to ParcelShopDAO.
type ParcelShopDAOConnection struct {
	Edges      []*ParcelShopDAOEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *ParcelShopDAOConnection) build(nodes []*ParcelShopDAO, pager *parcelshopdaoPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ParcelShopDAO
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ParcelShopDAO {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ParcelShopDAO {
			return nodes[i]
		}
	}
	c.Edges = make([]*ParcelShopDAOEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ParcelShopDAOEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ParcelShopDAOPaginateOption enables pagination customization.
type ParcelShopDAOPaginateOption func(*parcelshopdaoPager) error

// WithParcelShopDAOOrder configures pagination ordering.
func WithParcelShopDAOOrder(order *ParcelShopDAOOrder) ParcelShopDAOPaginateOption {
	if order == nil {
		order = DefaultParcelShopDAOOrder
	}
	o := *order
	return func(pager *parcelshopdaoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultParcelShopDAOOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithParcelShopDAOFilter configures pagination filter.
func WithParcelShopDAOFilter(filter func(*ParcelShopDAOQuery) (*ParcelShopDAOQuery, error)) ParcelShopDAOPaginateOption {
	return func(pager *parcelshopdaoPager) error {
		if filter == nil {
			return errors.New("ParcelShopDAOQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type parcelshopdaoPager struct {
	reverse bool
	order   *ParcelShopDAOOrder
	filter  func(*ParcelShopDAOQuery) (*ParcelShopDAOQuery, error)
}

func newParcelShopDAOPager(opts []ParcelShopDAOPaginateOption, reverse bool) (*parcelshopdaoPager, error) {
	pager := &parcelshopdaoPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultParcelShopDAOOrder
	}
	return pager, nil
}

func (p *parcelshopdaoPager) applyFilter(query *ParcelShopDAOQuery) (*ParcelShopDAOQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *parcelshopdaoPager) toCursor(psd *ParcelShopDAO) Cursor {
	return p.order.Field.toCursor(psd)
}

func (p *parcelshopdaoPager) applyCursors(query *ParcelShopDAOQuery, after, before *Cursor) (*ParcelShopDAOQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultParcelShopDAOOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *parcelshopdaoPager) applyOrder(query *ParcelShopDAOQuery) *ParcelShopDAOQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultParcelShopDAOOrder.Field {
		query = query.Order(DefaultParcelShopDAOOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *parcelshopdaoPager) orderExpr(query *ParcelShopDAOQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultParcelShopDAOOrder.Field {
			b.Comma().Ident(DefaultParcelShopDAOOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ParcelShopDAO.
func (psd *ParcelShopDAOQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ParcelShopDAOPaginateOption,
) (*ParcelShopDAOConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newParcelShopDAOPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if psd, err = pager.applyFilter(psd); err != nil {
		return nil, err
	}
	conn := &ParcelShopDAOConnection{Edges: []*ParcelShopDAOEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := psd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if psd, err = pager.applyCursors(psd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		psd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := psd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	psd = pager.applyOrder(psd)
	nodes, err := psd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ParcelShopDAOOrderField defines the ordering field of ParcelShopDAO.
type ParcelShopDAOOrderField struct {
	// Value extracts the ordering value from the given ParcelShopDAO.
	Value    func(*ParcelShopDAO) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) parcelshopdao.OrderOption
	toCursor func(*ParcelShopDAO) Cursor
}

// ParcelShopDAOOrder defines the ordering of ParcelShopDAO.
type ParcelShopDAOOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ParcelShopDAOOrderField `json:"field"`
}

// DefaultParcelShopDAOOrder is the default ordering of ParcelShopDAO.
var DefaultParcelShopDAOOrder = &ParcelShopDAOOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ParcelShopDAOOrderField{
		Value: func(psd *ParcelShopDAO) (ent.Value, error) {
			return psd.ID, nil
		},
		column: parcelshopdao.FieldID,
		toTerm: parcelshopdao.ByID,
		toCursor: func(psd *ParcelShopDAO) Cursor {
			return Cursor{ID: psd.ID}
		},
	},
}

// ToEdge converts ParcelShopDAO into ParcelShopDAOEdge.
func (psd *ParcelShopDAO) ToEdge(order *ParcelShopDAOOrder) *ParcelShopDAOEdge {
	if order == nil {
		order = DefaultParcelShopDAOOrder
	}
	return &ParcelShopDAOEdge{
		Node:   psd,
		Cursor: order.Field.toCursor(psd),
	}
}

// ParcelShopGLSEdge is the edge representation of ParcelShopGLS.
type ParcelShopGLSEdge struct {
	Node   *ParcelShopGLS `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ParcelShopGLSConnection is the connection containing edges to ParcelShopGLS.
type ParcelShopGLSConnection struct {
	Edges      []*ParcelShopGLSEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *ParcelShopGLSConnection) build(nodes []*ParcelShopGLS, pager *parcelshopglsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ParcelShopGLS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ParcelShopGLS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ParcelShopGLS {
			return nodes[i]
		}
	}
	c.Edges = make([]*ParcelShopGLSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ParcelShopGLSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ParcelShopGLSPaginateOption enables pagination customization.
type ParcelShopGLSPaginateOption func(*parcelshopglsPager) error

// WithParcelShopGLSOrder configures pagination ordering.
func WithParcelShopGLSOrder(order *ParcelShopGLSOrder) ParcelShopGLSPaginateOption {
	if order == nil {
		order = DefaultParcelShopGLSOrder
	}
	o := *order
	return func(pager *parcelshopglsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultParcelShopGLSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithParcelShopGLSFilter configures pagination filter.
func WithParcelShopGLSFilter(filter func(*ParcelShopGLSQuery) (*ParcelShopGLSQuery, error)) ParcelShopGLSPaginateOption {
	return func(pager *parcelshopglsPager) error {
		if filter == nil {
			return errors.New("ParcelShopGLSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type parcelshopglsPager struct {
	reverse bool
	order   *ParcelShopGLSOrder
	filter  func(*ParcelShopGLSQuery) (*ParcelShopGLSQuery, error)
}

func newParcelShopGLSPager(opts []ParcelShopGLSPaginateOption, reverse bool) (*parcelshopglsPager, error) {
	pager := &parcelshopglsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultParcelShopGLSOrder
	}
	return pager, nil
}

func (p *parcelshopglsPager) applyFilter(query *ParcelShopGLSQuery) (*ParcelShopGLSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *parcelshopglsPager) toCursor(psg *ParcelShopGLS) Cursor {
	return p.order.Field.toCursor(psg)
}

func (p *parcelshopglsPager) applyCursors(query *ParcelShopGLSQuery, after, before *Cursor) (*ParcelShopGLSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultParcelShopGLSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *parcelshopglsPager) applyOrder(query *ParcelShopGLSQuery) *ParcelShopGLSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultParcelShopGLSOrder.Field {
		query = query.Order(DefaultParcelShopGLSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *parcelshopglsPager) orderExpr(query *ParcelShopGLSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultParcelShopGLSOrder.Field {
			b.Comma().Ident(DefaultParcelShopGLSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ParcelShopGLS.
func (psg *ParcelShopGLSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ParcelShopGLSPaginateOption,
) (*ParcelShopGLSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newParcelShopGLSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if psg, err = pager.applyFilter(psg); err != nil {
		return nil, err
	}
	conn := &ParcelShopGLSConnection{Edges: []*ParcelShopGLSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := psg.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if psg, err = pager.applyCursors(psg, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		psg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := psg.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	psg = pager.applyOrder(psg)
	nodes, err := psg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ParcelShopGLSOrderField defines the ordering field of ParcelShopGLS.
type ParcelShopGLSOrderField struct {
	// Value extracts the ordering value from the given ParcelShopGLS.
	Value    func(*ParcelShopGLS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) parcelshopgls.OrderOption
	toCursor func(*ParcelShopGLS) Cursor
}

// ParcelShopGLSOrder defines the ordering of ParcelShopGLS.
type ParcelShopGLSOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ParcelShopGLSOrderField `json:"field"`
}

// DefaultParcelShopGLSOrder is the default ordering of ParcelShopGLS.
var DefaultParcelShopGLSOrder = &ParcelShopGLSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ParcelShopGLSOrderField{
		Value: func(psg *ParcelShopGLS) (ent.Value, error) {
			return psg.ID, nil
		},
		column: parcelshopgls.FieldID,
		toTerm: parcelshopgls.ByID,
		toCursor: func(psg *ParcelShopGLS) Cursor {
			return Cursor{ID: psg.ID}
		},
	},
}

// ToEdge converts ParcelShopGLS into ParcelShopGLSEdge.
func (psg *ParcelShopGLS) ToEdge(order *ParcelShopGLSOrder) *ParcelShopGLSEdge {
	if order == nil {
		order = DefaultParcelShopGLSOrder
	}
	return &ParcelShopGLSEdge{
		Node:   psg,
		Cursor: order.Field.toCursor(psg),
	}
}

// ParcelShopPostNordEdge is the edge representation of ParcelShopPostNord.
type ParcelShopPostNordEdge struct {
	Node   *ParcelShopPostNord `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// ParcelShopPostNordConnection is the connection containing edges to ParcelShopPostNord.
type ParcelShopPostNordConnection struct {
	Edges      []*ParcelShopPostNordEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *ParcelShopPostNordConnection) build(nodes []*ParcelShopPostNord, pager *parcelshoppostnordPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ParcelShopPostNord
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ParcelShopPostNord {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ParcelShopPostNord {
			return nodes[i]
		}
	}
	c.Edges = make([]*ParcelShopPostNordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ParcelShopPostNordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ParcelShopPostNordPaginateOption enables pagination customization.
type ParcelShopPostNordPaginateOption func(*parcelshoppostnordPager) error

// WithParcelShopPostNordOrder configures pagination ordering.
func WithParcelShopPostNordOrder(order *ParcelShopPostNordOrder) ParcelShopPostNordPaginateOption {
	if order == nil {
		order = DefaultParcelShopPostNordOrder
	}
	o := *order
	return func(pager *parcelshoppostnordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultParcelShopPostNordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithParcelShopPostNordFilter configures pagination filter.
func WithParcelShopPostNordFilter(filter func(*ParcelShopPostNordQuery) (*ParcelShopPostNordQuery, error)) ParcelShopPostNordPaginateOption {
	return func(pager *parcelshoppostnordPager) error {
		if filter == nil {
			return errors.New("ParcelShopPostNordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type parcelshoppostnordPager struct {
	reverse bool
	order   *ParcelShopPostNordOrder
	filter  func(*ParcelShopPostNordQuery) (*ParcelShopPostNordQuery, error)
}

func newParcelShopPostNordPager(opts []ParcelShopPostNordPaginateOption, reverse bool) (*parcelshoppostnordPager, error) {
	pager := &parcelshoppostnordPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultParcelShopPostNordOrder
	}
	return pager, nil
}

func (p *parcelshoppostnordPager) applyFilter(query *ParcelShopPostNordQuery) (*ParcelShopPostNordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *parcelshoppostnordPager) toCursor(pspn *ParcelShopPostNord) Cursor {
	return p.order.Field.toCursor(pspn)
}

func (p *parcelshoppostnordPager) applyCursors(query *ParcelShopPostNordQuery, after, before *Cursor) (*ParcelShopPostNordQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultParcelShopPostNordOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *parcelshoppostnordPager) applyOrder(query *ParcelShopPostNordQuery) *ParcelShopPostNordQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultParcelShopPostNordOrder.Field {
		query = query.Order(DefaultParcelShopPostNordOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *parcelshoppostnordPager) orderExpr(query *ParcelShopPostNordQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultParcelShopPostNordOrder.Field {
			b.Comma().Ident(DefaultParcelShopPostNordOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ParcelShopPostNord.
func (pspn *ParcelShopPostNordQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ParcelShopPostNordPaginateOption,
) (*ParcelShopPostNordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newParcelShopPostNordPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pspn, err = pager.applyFilter(pspn); err != nil {
		return nil, err
	}
	conn := &ParcelShopPostNordConnection{Edges: []*ParcelShopPostNordEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pspn.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pspn, err = pager.applyCursors(pspn, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pspn.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pspn.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pspn = pager.applyOrder(pspn)
	nodes, err := pspn.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ParcelShopPostNordOrderField defines the ordering field of ParcelShopPostNord.
type ParcelShopPostNordOrderField struct {
	// Value extracts the ordering value from the given ParcelShopPostNord.
	Value    func(*ParcelShopPostNord) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) parcelshoppostnord.OrderOption
	toCursor func(*ParcelShopPostNord) Cursor
}

// ParcelShopPostNordOrder defines the ordering of ParcelShopPostNord.
type ParcelShopPostNordOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *ParcelShopPostNordOrderField `json:"field"`
}

// DefaultParcelShopPostNordOrder is the default ordering of ParcelShopPostNord.
var DefaultParcelShopPostNordOrder = &ParcelShopPostNordOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ParcelShopPostNordOrderField{
		Value: func(pspn *ParcelShopPostNord) (ent.Value, error) {
			return pspn.ID, nil
		},
		column: parcelshoppostnord.FieldID,
		toTerm: parcelshoppostnord.ByID,
		toCursor: func(pspn *ParcelShopPostNord) Cursor {
			return Cursor{ID: pspn.ID}
		},
	},
}

// ToEdge converts ParcelShopPostNord into ParcelShopPostNordEdge.
func (pspn *ParcelShopPostNord) ToEdge(order *ParcelShopPostNordOrder) *ParcelShopPostNordEdge {
	if order == nil {
		order = DefaultParcelShopPostNordOrder
	}
	return &ParcelShopPostNordEdge{
		Node:   pspn,
		Cursor: order.Field.toCursor(pspn),
	}
}

// PlanEdge is the edge representation of Plan.
type PlanEdge struct {
	Node   *Plan  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// PlanConnection is the connection containing edges to Plan.
type PlanConnection struct {
	Edges      []*PlanEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *PlanConnection) build(nodes []*Plan, pager *planPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Plan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Plan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Plan {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlanPaginateOption enables pagination customization.
type PlanPaginateOption func(*planPager) error

// WithPlanOrder configures pagination ordering.
func WithPlanOrder(order *PlanOrder) PlanPaginateOption {
	if order == nil {
		order = DefaultPlanOrder
	}
	o := *order
	return func(pager *planPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlanFilter configures pagination filter.
func WithPlanFilter(filter func(*PlanQuery) (*PlanQuery, error)) PlanPaginateOption {
	return func(pager *planPager) error {
		if filter == nil {
			return errors.New("PlanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type planPager struct {
	reverse bool
	order   *PlanOrder
	filter  func(*PlanQuery) (*PlanQuery, error)
}

func newPlanPager(opts []PlanPaginateOption, reverse bool) (*planPager, error) {
	pager := &planPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlanOrder
	}
	return pager, nil
}

func (p *planPager) applyFilter(query *PlanQuery) (*PlanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *planPager) toCursor(pl *Plan) Cursor {
	return p.order.Field.toCursor(pl)
}

func (p *planPager) applyCursors(query *PlanQuery, after, before *Cursor) (*PlanQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPlanOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *planPager) applyOrder(query *PlanQuery) *PlanQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPlanOrder.Field {
		query = query.Order(DefaultPlanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *planPager) orderExpr(query *PlanQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlanOrder.Field {
			b.Comma().Ident(DefaultPlanOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Plan.
func (pl *PlanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlanPaginateOption,
) (*PlanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pl, err = pager.applyFilter(pl); err != nil {
		return nil, err
	}
	conn := &PlanConnection{Edges: []*PlanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pl.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pl, err = pager.applyCursors(pl, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pl.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pl.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pl = pager.applyOrder(pl)
	nodes, err := pl.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PlanOrderField defines the ordering field of Plan.
type PlanOrderField struct {
	// Value extracts the ordering value from the given Plan.
	Value    func(*Plan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) plan.OrderOption
	toCursor func(*Plan) Cursor
}

// PlanOrder defines the ordering of Plan.
type PlanOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *PlanOrderField `json:"field"`
}

// DefaultPlanOrder is the default ordering of Plan.
var DefaultPlanOrder = &PlanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PlanOrderField{
		Value: func(pl *Plan) (ent.Value, error) {
			return pl.ID, nil
		},
		column: plan.FieldID,
		toTerm: plan.ByID,
		toCursor: func(pl *Plan) Cursor {
			return Cursor{ID: pl.ID}
		},
	},
}

// ToEdge converts Plan into PlanEdge.
func (pl *Plan) ToEdge(order *PlanOrder) *PlanEdge {
	if order == nil {
		order = DefaultPlanOrder
	}
	return &PlanEdge{
		Node:   pl,
		Cursor: order.Field.toCursor(pl),
	}
}

// PlanHistoryEdge is the edge representation of PlanHistory.
type PlanHistoryEdge struct {
	Node   *PlanHistory `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// PlanHistoryConnection is the connection containing edges to PlanHistory.
type PlanHistoryConnection struct {
	Edges      []*PlanHistoryEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *PlanHistoryConnection) build(nodes []*PlanHistory, pager *planhistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PlanHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PlanHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PlanHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*PlanHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PlanHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PlanHistoryPaginateOption enables pagination customization.
type PlanHistoryPaginateOption func(*planhistoryPager) error

// WithPlanHistoryOrder configures pagination ordering.
func WithPlanHistoryOrder(order *PlanHistoryOrder) PlanHistoryPaginateOption {
	if order == nil {
		order = DefaultPlanHistoryOrder
	}
	o := *order
	return func(pager *planhistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPlanHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPlanHistoryFilter configures pagination filter.
func WithPlanHistoryFilter(filter func(*PlanHistoryQuery) (*PlanHistoryQuery, error)) PlanHistoryPaginateOption {
	return func(pager *planhistoryPager) error {
		if filter == nil {
			return errors.New("PlanHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type planhistoryPager struct {
	reverse bool
	order   *PlanHistoryOrder
	filter  func(*PlanHistoryQuery) (*PlanHistoryQuery, error)
}

func newPlanHistoryPager(opts []PlanHistoryPaginateOption, reverse bool) (*planhistoryPager, error) {
	pager := &planhistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPlanHistoryOrder
	}
	return pager, nil
}

func (p *planhistoryPager) applyFilter(query *PlanHistoryQuery) (*PlanHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *planhistoryPager) toCursor(ph *PlanHistory) Cursor {
	return p.order.Field.toCursor(ph)
}

func (p *planhistoryPager) applyCursors(query *PlanHistoryQuery, after, before *Cursor) (*PlanHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPlanHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *planhistoryPager) applyOrder(query *PlanHistoryQuery) *PlanHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPlanHistoryOrder.Field {
		query = query.Order(DefaultPlanHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *planhistoryPager) orderExpr(query *PlanHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPlanHistoryOrder.Field {
			b.Comma().Ident(DefaultPlanHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PlanHistory.
func (ph *PlanHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PlanHistoryPaginateOption,
) (*PlanHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPlanHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if ph, err = pager.applyFilter(ph); err != nil {
		return nil, err
	}
	conn := &PlanHistoryConnection{Edges: []*PlanHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := ph.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if ph, err = pager.applyCursors(ph, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		ph.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := ph.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	ph = pager.applyOrder(ph)
	nodes, err := ph.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PlanHistoryOrderField defines the ordering field of PlanHistory.
type PlanHistoryOrderField struct {
	// Value extracts the ordering value from the given PlanHistory.
	Value    func(*PlanHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) planhistory.OrderOption
	toCursor func(*PlanHistory) Cursor
}

// PlanHistoryOrder defines the ordering of PlanHistory.
type PlanHistoryOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *PlanHistoryOrderField `json:"field"`
}

// DefaultPlanHistoryOrder is the default ordering of PlanHistory.
var DefaultPlanHistoryOrder = &PlanHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PlanHistoryOrderField{
		Value: func(ph *PlanHistory) (ent.Value, error) {
			return ph.ID, nil
		},
		column: planhistory.FieldID,
		toTerm: planhistory.ByID,
		toCursor: func(ph *PlanHistory) Cursor {
			return Cursor{ID: ph.ID}
		},
	},
}

// ToEdge converts PlanHistory into PlanHistoryEdge.
func (ph *PlanHistory) ToEdge(order *PlanHistoryOrder) *PlanHistoryEdge {
	if order == nil {
		order = DefaultPlanHistoryOrder
	}
	return &PlanHistoryEdge{
		Node:   ph,
		Cursor: order.Field.toCursor(ph),
	}
}

// PrintJobEdge is the edge representation of PrintJob.
type PrintJobEdge struct {
	Node   *PrintJob `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// PrintJobConnection is the connection containing edges to PrintJob.
type PrintJobConnection struct {
	Edges      []*PrintJobEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *PrintJobConnection) build(nodes []*PrintJob, pager *printjobPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *PrintJob
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *PrintJob {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *PrintJob {
			return nodes[i]
		}
	}
	c.Edges = make([]*PrintJobEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PrintJobEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PrintJobPaginateOption enables pagination customization.
type PrintJobPaginateOption func(*printjobPager) error

// WithPrintJobOrder configures pagination ordering.
func WithPrintJobOrder(order *PrintJobOrder) PrintJobPaginateOption {
	if order == nil {
		order = DefaultPrintJobOrder
	}
	o := *order
	return func(pager *printjobPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPrintJobOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPrintJobFilter configures pagination filter.
func WithPrintJobFilter(filter func(*PrintJobQuery) (*PrintJobQuery, error)) PrintJobPaginateOption {
	return func(pager *printjobPager) error {
		if filter == nil {
			return errors.New("PrintJobQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type printjobPager struct {
	reverse bool
	order   *PrintJobOrder
	filter  func(*PrintJobQuery) (*PrintJobQuery, error)
}

func newPrintJobPager(opts []PrintJobPaginateOption, reverse bool) (*printjobPager, error) {
	pager := &printjobPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPrintJobOrder
	}
	return pager, nil
}

func (p *printjobPager) applyFilter(query *PrintJobQuery) (*PrintJobQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *printjobPager) toCursor(pj *PrintJob) Cursor {
	return p.order.Field.toCursor(pj)
}

func (p *printjobPager) applyCursors(query *PrintJobQuery, after, before *Cursor) (*PrintJobQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPrintJobOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *printjobPager) applyOrder(query *PrintJobQuery) *PrintJobQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPrintJobOrder.Field {
		query = query.Order(DefaultPrintJobOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *printjobPager) orderExpr(query *PrintJobQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPrintJobOrder.Field {
			b.Comma().Ident(DefaultPrintJobOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to PrintJob.
func (pj *PrintJobQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PrintJobPaginateOption,
) (*PrintJobConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPrintJobPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pj, err = pager.applyFilter(pj); err != nil {
		return nil, err
	}
	conn := &PrintJobConnection{Edges: []*PrintJobEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pj.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pj, err = pager.applyCursors(pj, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pj.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pj.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pj = pager.applyOrder(pj)
	nodes, err := pj.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PrintJobOrderField defines the ordering field of PrintJob.
type PrintJobOrderField struct {
	// Value extracts the ordering value from the given PrintJob.
	Value    func(*PrintJob) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) printjob.OrderOption
	toCursor func(*PrintJob) Cursor
}

// PrintJobOrder defines the ordering of PrintJob.
type PrintJobOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *PrintJobOrderField `json:"field"`
}

// DefaultPrintJobOrder is the default ordering of PrintJob.
var DefaultPrintJobOrder = &PrintJobOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PrintJobOrderField{
		Value: func(pj *PrintJob) (ent.Value, error) {
			return pj.ID, nil
		},
		column: printjob.FieldID,
		toTerm: printjob.ByID,
		toCursor: func(pj *PrintJob) Cursor {
			return Cursor{ID: pj.ID}
		},
	},
}

// ToEdge converts PrintJob into PrintJobEdge.
func (pj *PrintJob) ToEdge(order *PrintJobOrder) *PrintJobEdge {
	if order == nil {
		order = DefaultPrintJobOrder
	}
	return &PrintJobEdge{
		Node:   pj,
		Cursor: order.Field.toCursor(pj),
	}
}

// PrinterEdge is the edge representation of Printer.
type PrinterEdge struct {
	Node   *Printer `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// PrinterConnection is the connection containing edges to Printer.
type PrinterConnection struct {
	Edges      []*PrinterEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *PrinterConnection) build(nodes []*Printer, pager *printerPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Printer
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Printer {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Printer {
			return nodes[i]
		}
	}
	c.Edges = make([]*PrinterEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &PrinterEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// PrinterPaginateOption enables pagination customization.
type PrinterPaginateOption func(*printerPager) error

// WithPrinterOrder configures pagination ordering.
func WithPrinterOrder(order *PrinterOrder) PrinterPaginateOption {
	if order == nil {
		order = DefaultPrinterOrder
	}
	o := *order
	return func(pager *printerPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultPrinterOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithPrinterFilter configures pagination filter.
func WithPrinterFilter(filter func(*PrinterQuery) (*PrinterQuery, error)) PrinterPaginateOption {
	return func(pager *printerPager) error {
		if filter == nil {
			return errors.New("PrinterQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type printerPager struct {
	reverse bool
	order   *PrinterOrder
	filter  func(*PrinterQuery) (*PrinterQuery, error)
}

func newPrinterPager(opts []PrinterPaginateOption, reverse bool) (*printerPager, error) {
	pager := &printerPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultPrinterOrder
	}
	return pager, nil
}

func (p *printerPager) applyFilter(query *PrinterQuery) (*PrinterQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *printerPager) toCursor(pr *Printer) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *printerPager) applyCursors(query *PrinterQuery, after, before *Cursor) (*PrinterQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultPrinterOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *printerPager) applyOrder(query *PrinterQuery) *PrinterQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultPrinterOrder.Field {
		query = query.Order(DefaultPrinterOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *printerPager) orderExpr(query *PrinterQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultPrinterOrder.Field {
			b.Comma().Ident(DefaultPrinterOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Printer.
func (pr *PrinterQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...PrinterPaginateOption,
) (*PrinterConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newPrinterPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &PrinterConnection{Edges: []*PrinterEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// PrinterOrderField defines the ordering field of Printer.
type PrinterOrderField struct {
	// Value extracts the ordering value from the given Printer.
	Value    func(*Printer) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) printer.OrderOption
	toCursor func(*Printer) Cursor
}

// PrinterOrder defines the ordering of Printer.
type PrinterOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *PrinterOrderField `json:"field"`
}

// DefaultPrinterOrder is the default ordering of Printer.
var DefaultPrinterOrder = &PrinterOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &PrinterOrderField{
		Value: func(pr *Printer) (ent.Value, error) {
			return pr.ID, nil
		},
		column: printer.FieldID,
		toTerm: printer.ByID,
		toCursor: func(pr *Printer) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Printer into PrinterEdge.
func (pr *Printer) ToEdge(order *PrinterOrder) *PrinterEdge {
	if order == nil {
		order = DefaultPrinterOrder
	}
	return &PrinterEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProductEdge is the edge representation of Product.
type ProductEdge struct {
	Node   *Product `json:"node"`
	Cursor Cursor   `json:"cursor"`
}

// ProductConnection is the connection containing edges to Product.
type ProductConnection struct {
	Edges      []*ProductEdge `json:"edges"`
	PageInfo   PageInfo       `json:"pageInfo"`
	TotalCount int            `json:"totalCount"`
}

func (c *ProductConnection) build(nodes []*Product, pager *productPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Product
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Product {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Product {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductPaginateOption enables pagination customization.
type ProductPaginateOption func(*productPager) error

// WithProductOrder configures pagination ordering.
func WithProductOrder(order *ProductOrder) ProductPaginateOption {
	if order == nil {
		order = DefaultProductOrder
	}
	o := *order
	return func(pager *productPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductFilter configures pagination filter.
func WithProductFilter(filter func(*ProductQuery) (*ProductQuery, error)) ProductPaginateOption {
	return func(pager *productPager) error {
		if filter == nil {
			return errors.New("ProductQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productPager struct {
	reverse bool
	order   *ProductOrder
	filter  func(*ProductQuery) (*ProductQuery, error)
}

func newProductPager(opts []ProductPaginateOption, reverse bool) (*productPager, error) {
	pager := &productPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductOrder
	}
	return pager, nil
}

func (p *productPager) applyFilter(query *ProductQuery) (*ProductQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productPager) toCursor(pr *Product) Cursor {
	return p.order.Field.toCursor(pr)
}

func (p *productPager) applyCursors(query *ProductQuery, after, before *Cursor) (*ProductQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productPager) applyOrder(query *ProductQuery) *ProductQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductOrder.Field {
		query = query.Order(DefaultProductOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *productPager) orderExpr(query *ProductQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductOrder.Field {
			b.Comma().Ident(DefaultProductOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Product.
func (pr *ProductQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductPaginateOption,
) (*ProductConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pr, err = pager.applyFilter(pr); err != nil {
		return nil, err
	}
	conn := &ProductConnection{Edges: []*ProductEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pr.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pr, err = pager.applyCursors(pr, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pr.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pr.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pr = pager.applyOrder(pr)
	nodes, err := pr.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProductOrderField defines the ordering field of Product.
type ProductOrderField struct {
	// Value extracts the ordering value from the given Product.
	Value    func(*Product) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) product.OrderOption
	toCursor func(*Product) Cursor
}

// ProductOrder defines the ordering of Product.
type ProductOrder struct {
	Direction OrderDirection     `json:"direction"`
	Field     *ProductOrderField `json:"field"`
}

// DefaultProductOrder is the default ordering of Product.
var DefaultProductOrder = &ProductOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductOrderField{
		Value: func(pr *Product) (ent.Value, error) {
			return pr.ID, nil
		},
		column: product.FieldID,
		toTerm: product.ByID,
		toCursor: func(pr *Product) Cursor {
			return Cursor{ID: pr.ID}
		},
	},
}

// ToEdge converts Product into ProductEdge.
func (pr *Product) ToEdge(order *ProductOrder) *ProductEdge {
	if order == nil {
		order = DefaultProductOrder
	}
	return &ProductEdge{
		Node:   pr,
		Cursor: order.Field.toCursor(pr),
	}
}

// ProductImageEdge is the edge representation of ProductImage.
type ProductImageEdge struct {
	Node   *ProductImage `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ProductImageConnection is the connection containing edges to ProductImage.
type ProductImageConnection struct {
	Edges      []*ProductImageEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ProductImageConnection) build(nodes []*ProductImage, pager *productimagePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProductImage
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProductImage {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProductImage {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductImageEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductImageEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductImagePaginateOption enables pagination customization.
type ProductImagePaginateOption func(*productimagePager) error

// WithProductImageOrder configures pagination ordering.
func WithProductImageOrder(order *ProductImageOrder) ProductImagePaginateOption {
	if order == nil {
		order = DefaultProductImageOrder
	}
	o := *order
	return func(pager *productimagePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductImageOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductImageFilter configures pagination filter.
func WithProductImageFilter(filter func(*ProductImageQuery) (*ProductImageQuery, error)) ProductImagePaginateOption {
	return func(pager *productimagePager) error {
		if filter == nil {
			return errors.New("ProductImageQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productimagePager struct {
	reverse bool
	order   *ProductImageOrder
	filter  func(*ProductImageQuery) (*ProductImageQuery, error)
}

func newProductImagePager(opts []ProductImagePaginateOption, reverse bool) (*productimagePager, error) {
	pager := &productimagePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductImageOrder
	}
	return pager, nil
}

func (p *productimagePager) applyFilter(query *ProductImageQuery) (*ProductImageQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productimagePager) toCursor(pi *ProductImage) Cursor {
	return p.order.Field.toCursor(pi)
}

func (p *productimagePager) applyCursors(query *ProductImageQuery, after, before *Cursor) (*ProductImageQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductImageOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productimagePager) applyOrder(query *ProductImageQuery) *ProductImageQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductImageOrder.Field {
		query = query.Order(DefaultProductImageOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *productimagePager) orderExpr(query *ProductImageQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductImageOrder.Field {
			b.Comma().Ident(DefaultProductImageOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProductImage.
func (pi *ProductImageQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductImagePaginateOption,
) (*ProductImageConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductImagePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pi, err = pager.applyFilter(pi); err != nil {
		return nil, err
	}
	conn := &ProductImageConnection{Edges: []*ProductImageEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pi.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pi, err = pager.applyCursors(pi, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pi.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pi.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pi = pager.applyOrder(pi)
	nodes, err := pi.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProductImageOrderField defines the ordering field of ProductImage.
type ProductImageOrderField struct {
	// Value extracts the ordering value from the given ProductImage.
	Value    func(*ProductImage) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) productimage.OrderOption
	toCursor func(*ProductImage) Cursor
}

// ProductImageOrder defines the ordering of ProductImage.
type ProductImageOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ProductImageOrderField `json:"field"`
}

// DefaultProductImageOrder is the default ordering of ProductImage.
var DefaultProductImageOrder = &ProductImageOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductImageOrderField{
		Value: func(pi *ProductImage) (ent.Value, error) {
			return pi.ID, nil
		},
		column: productimage.FieldID,
		toTerm: productimage.ByID,
		toCursor: func(pi *ProductImage) Cursor {
			return Cursor{ID: pi.ID}
		},
	},
}

// ToEdge converts ProductImage into ProductImageEdge.
func (pi *ProductImage) ToEdge(order *ProductImageOrder) *ProductImageEdge {
	if order == nil {
		order = DefaultProductImageOrder
	}
	return &ProductImageEdge{
		Node:   pi,
		Cursor: order.Field.toCursor(pi),
	}
}

// ProductTagEdge is the edge representation of ProductTag.
type ProductTagEdge struct {
	Node   *ProductTag `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ProductTagConnection is the connection containing edges to ProductTag.
type ProductTagConnection struct {
	Edges      []*ProductTagEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ProductTagConnection) build(nodes []*ProductTag, pager *producttagPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProductTag
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProductTag {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProductTag {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductTagEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductTagEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductTagPaginateOption enables pagination customization.
type ProductTagPaginateOption func(*producttagPager) error

// WithProductTagOrder configures pagination ordering.
func WithProductTagOrder(order *ProductTagOrder) ProductTagPaginateOption {
	if order == nil {
		order = DefaultProductTagOrder
	}
	o := *order
	return func(pager *producttagPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductTagOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductTagFilter configures pagination filter.
func WithProductTagFilter(filter func(*ProductTagQuery) (*ProductTagQuery, error)) ProductTagPaginateOption {
	return func(pager *producttagPager) error {
		if filter == nil {
			return errors.New("ProductTagQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type producttagPager struct {
	reverse bool
	order   *ProductTagOrder
	filter  func(*ProductTagQuery) (*ProductTagQuery, error)
}

func newProductTagPager(opts []ProductTagPaginateOption, reverse bool) (*producttagPager, error) {
	pager := &producttagPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductTagOrder
	}
	return pager, nil
}

func (p *producttagPager) applyFilter(query *ProductTagQuery) (*ProductTagQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *producttagPager) toCursor(pt *ProductTag) Cursor {
	return p.order.Field.toCursor(pt)
}

func (p *producttagPager) applyCursors(query *ProductTagQuery, after, before *Cursor) (*ProductTagQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductTagOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *producttagPager) applyOrder(query *ProductTagQuery) *ProductTagQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductTagOrder.Field {
		query = query.Order(DefaultProductTagOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *producttagPager) orderExpr(query *ProductTagQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductTagOrder.Field {
			b.Comma().Ident(DefaultProductTagOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProductTag.
func (pt *ProductTagQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductTagPaginateOption,
) (*ProductTagConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductTagPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pt, err = pager.applyFilter(pt); err != nil {
		return nil, err
	}
	conn := &ProductTagConnection{Edges: []*ProductTagEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pt.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pt, err = pager.applyCursors(pt, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pt.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pt.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pt = pager.applyOrder(pt)
	nodes, err := pt.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProductTagOrderField defines the ordering field of ProductTag.
type ProductTagOrderField struct {
	// Value extracts the ordering value from the given ProductTag.
	Value    func(*ProductTag) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) producttag.OrderOption
	toCursor func(*ProductTag) Cursor
}

// ProductTagOrder defines the ordering of ProductTag.
type ProductTagOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ProductTagOrderField `json:"field"`
}

// DefaultProductTagOrder is the default ordering of ProductTag.
var DefaultProductTagOrder = &ProductTagOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductTagOrderField{
		Value: func(pt *ProductTag) (ent.Value, error) {
			return pt.ID, nil
		},
		column: producttag.FieldID,
		toTerm: producttag.ByID,
		toCursor: func(pt *ProductTag) Cursor {
			return Cursor{ID: pt.ID}
		},
	},
}

// ToEdge converts ProductTag into ProductTagEdge.
func (pt *ProductTag) ToEdge(order *ProductTagOrder) *ProductTagEdge {
	if order == nil {
		order = DefaultProductTagOrder
	}
	return &ProductTagEdge{
		Node:   pt,
		Cursor: order.Field.toCursor(pt),
	}
}

// ProductVariantEdge is the edge representation of ProductVariant.
type ProductVariantEdge struct {
	Node   *ProductVariant `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ProductVariantConnection is the connection containing edges to ProductVariant.
type ProductVariantConnection struct {
	Edges      []*ProductVariantEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ProductVariantConnection) build(nodes []*ProductVariant, pager *productvariantPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ProductVariant
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ProductVariant {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ProductVariant {
			return nodes[i]
		}
	}
	c.Edges = make([]*ProductVariantEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ProductVariantEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ProductVariantPaginateOption enables pagination customization.
type ProductVariantPaginateOption func(*productvariantPager) error

// WithProductVariantOrder configures pagination ordering.
func WithProductVariantOrder(order *ProductVariantOrder) ProductVariantPaginateOption {
	if order == nil {
		order = DefaultProductVariantOrder
	}
	o := *order
	return func(pager *productvariantPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultProductVariantOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithProductVariantFilter configures pagination filter.
func WithProductVariantFilter(filter func(*ProductVariantQuery) (*ProductVariantQuery, error)) ProductVariantPaginateOption {
	return func(pager *productvariantPager) error {
		if filter == nil {
			return errors.New("ProductVariantQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type productvariantPager struct {
	reverse bool
	order   *ProductVariantOrder
	filter  func(*ProductVariantQuery) (*ProductVariantQuery, error)
}

func newProductVariantPager(opts []ProductVariantPaginateOption, reverse bool) (*productvariantPager, error) {
	pager := &productvariantPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultProductVariantOrder
	}
	return pager, nil
}

func (p *productvariantPager) applyFilter(query *ProductVariantQuery) (*ProductVariantQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *productvariantPager) toCursor(pv *ProductVariant) Cursor {
	return p.order.Field.toCursor(pv)
}

func (p *productvariantPager) applyCursors(query *ProductVariantQuery, after, before *Cursor) (*ProductVariantQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultProductVariantOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *productvariantPager) applyOrder(query *ProductVariantQuery) *ProductVariantQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultProductVariantOrder.Field {
		query = query.Order(DefaultProductVariantOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *productvariantPager) orderExpr(query *ProductVariantQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultProductVariantOrder.Field {
			b.Comma().Ident(DefaultProductVariantOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ProductVariant.
func (pv *ProductVariantQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ProductVariantPaginateOption,
) (*ProductVariantConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newProductVariantPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if pv, err = pager.applyFilter(pv); err != nil {
		return nil, err
	}
	conn := &ProductVariantConnection{Edges: []*ProductVariantEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := pv.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if pv, err = pager.applyCursors(pv, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		pv.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := pv.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	pv = pager.applyOrder(pv)
	nodes, err := pv.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ProductVariantOrderField defines the ordering field of ProductVariant.
type ProductVariantOrderField struct {
	// Value extracts the ordering value from the given ProductVariant.
	Value    func(*ProductVariant) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) productvariant.OrderOption
	toCursor func(*ProductVariant) Cursor
}

// ProductVariantOrder defines the ordering of ProductVariant.
type ProductVariantOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ProductVariantOrderField `json:"field"`
}

// DefaultProductVariantOrder is the default ordering of ProductVariant.
var DefaultProductVariantOrder = &ProductVariantOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ProductVariantOrderField{
		Value: func(pv *ProductVariant) (ent.Value, error) {
			return pv.ID, nil
		},
		column: productvariant.FieldID,
		toTerm: productvariant.ByID,
		toCursor: func(pv *ProductVariant) Cursor {
			return Cursor{ID: pv.ID}
		},
	},
}

// ToEdge converts ProductVariant into ProductVariantEdge.
func (pv *ProductVariant) ToEdge(order *ProductVariantOrder) *ProductVariantEdge {
	if order == nil {
		order = DefaultProductVariantOrder
	}
	return &ProductVariantEdge{
		Node:   pv,
		Cursor: order.Field.toCursor(pv),
	}
}

// ReturnColliEdge is the edge representation of ReturnColli.
type ReturnColliEdge struct {
	Node   *ReturnColli `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ReturnColliConnection is the connection containing edges to ReturnColli.
type ReturnColliConnection struct {
	Edges      []*ReturnColliEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ReturnColliConnection) build(nodes []*ReturnColli, pager *returncolliPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ReturnColli
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReturnColli {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReturnColli {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReturnColliEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReturnColliEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReturnColliPaginateOption enables pagination customization.
type ReturnColliPaginateOption func(*returncolliPager) error

// WithReturnColliOrder configures pagination ordering.
func WithReturnColliOrder(order *ReturnColliOrder) ReturnColliPaginateOption {
	if order == nil {
		order = DefaultReturnColliOrder
	}
	o := *order
	return func(pager *returncolliPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReturnColliOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReturnColliFilter configures pagination filter.
func WithReturnColliFilter(filter func(*ReturnColliQuery) (*ReturnColliQuery, error)) ReturnColliPaginateOption {
	return func(pager *returncolliPager) error {
		if filter == nil {
			return errors.New("ReturnColliQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type returncolliPager struct {
	reverse bool
	order   *ReturnColliOrder
	filter  func(*ReturnColliQuery) (*ReturnColliQuery, error)
}

func newReturnColliPager(opts []ReturnColliPaginateOption, reverse bool) (*returncolliPager, error) {
	pager := &returncolliPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReturnColliOrder
	}
	return pager, nil
}

func (p *returncolliPager) applyFilter(query *ReturnColliQuery) (*ReturnColliQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *returncolliPager) toCursor(rc *ReturnColli) Cursor {
	return p.order.Field.toCursor(rc)
}

func (p *returncolliPager) applyCursors(query *ReturnColliQuery, after, before *Cursor) (*ReturnColliQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultReturnColliOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *returncolliPager) applyOrder(query *ReturnColliQuery) *ReturnColliQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultReturnColliOrder.Field {
		query = query.Order(DefaultReturnColliOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *returncolliPager) orderExpr(query *ReturnColliQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultReturnColliOrder.Field {
			b.Comma().Ident(DefaultReturnColliOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ReturnColli.
func (rc *ReturnColliQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReturnColliPaginateOption,
) (*ReturnColliConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReturnColliPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rc, err = pager.applyFilter(rc); err != nil {
		return nil, err
	}
	conn := &ReturnColliConnection{Edges: []*ReturnColliEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := rc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rc, err = pager.applyCursors(rc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		rc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rc = pager.applyOrder(rc)
	nodes, err := rc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ReturnColliOrderFieldCreatedAt orders ReturnColli by created_at.
	ReturnColliOrderFieldCreatedAt = &ReturnColliOrderField{
		Value: func(rc *ReturnColli) (ent.Value, error) {
			return rc.CreatedAt, nil
		},
		column: returncolli.FieldCreatedAt,
		toTerm: returncolli.ByCreatedAt,
		toCursor: func(rc *ReturnColli) Cursor {
			return Cursor{
				ID:    rc.ID,
				Value: rc.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ReturnColliOrderField) String() string {
	var str string
	switch f.column {
	case ReturnColliOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ReturnColliOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ReturnColliOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ReturnColliOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ReturnColliOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid ReturnColliOrderField", str)
	}
	return nil
}

// ReturnColliOrderField defines the ordering field of ReturnColli.
type ReturnColliOrderField struct {
	// Value extracts the ordering value from the given ReturnColli.
	Value    func(*ReturnColli) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) returncolli.OrderOption
	toCursor func(*ReturnColli) Cursor
}

// ReturnColliOrder defines the ordering of ReturnColli.
type ReturnColliOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ReturnColliOrderField `json:"field"`
}

// DefaultReturnColliOrder is the default ordering of ReturnColli.
var DefaultReturnColliOrder = &ReturnColliOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReturnColliOrderField{
		Value: func(rc *ReturnColli) (ent.Value, error) {
			return rc.ID, nil
		},
		column: returncolli.FieldID,
		toTerm: returncolli.ByID,
		toCursor: func(rc *ReturnColli) Cursor {
			return Cursor{ID: rc.ID}
		},
	},
}

// ToEdge converts ReturnColli into ReturnColliEdge.
func (rc *ReturnColli) ToEdge(order *ReturnColliOrder) *ReturnColliEdge {
	if order == nil {
		order = DefaultReturnColliOrder
	}
	return &ReturnColliEdge{
		Node:   rc,
		Cursor: order.Field.toCursor(rc),
	}
}

// ReturnColliHistoryEdge is the edge representation of ReturnColliHistory.
type ReturnColliHistoryEdge struct {
	Node   *ReturnColliHistory `json:"node"`
	Cursor Cursor              `json:"cursor"`
}

// ReturnColliHistoryConnection is the connection containing edges to ReturnColliHistory.
type ReturnColliHistoryConnection struct {
	Edges      []*ReturnColliHistoryEdge `json:"edges"`
	PageInfo   PageInfo                  `json:"pageInfo"`
	TotalCount int                       `json:"totalCount"`
}

func (c *ReturnColliHistoryConnection) build(nodes []*ReturnColliHistory, pager *returncollihistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ReturnColliHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReturnColliHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReturnColliHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReturnColliHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReturnColliHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReturnColliHistoryPaginateOption enables pagination customization.
type ReturnColliHistoryPaginateOption func(*returncollihistoryPager) error

// WithReturnColliHistoryOrder configures pagination ordering.
func WithReturnColliHistoryOrder(order *ReturnColliHistoryOrder) ReturnColliHistoryPaginateOption {
	if order == nil {
		order = DefaultReturnColliHistoryOrder
	}
	o := *order
	return func(pager *returncollihistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReturnColliHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReturnColliHistoryFilter configures pagination filter.
func WithReturnColliHistoryFilter(filter func(*ReturnColliHistoryQuery) (*ReturnColliHistoryQuery, error)) ReturnColliHistoryPaginateOption {
	return func(pager *returncollihistoryPager) error {
		if filter == nil {
			return errors.New("ReturnColliHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type returncollihistoryPager struct {
	reverse bool
	order   *ReturnColliHistoryOrder
	filter  func(*ReturnColliHistoryQuery) (*ReturnColliHistoryQuery, error)
}

func newReturnColliHistoryPager(opts []ReturnColliHistoryPaginateOption, reverse bool) (*returncollihistoryPager, error) {
	pager := &returncollihistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReturnColliHistoryOrder
	}
	return pager, nil
}

func (p *returncollihistoryPager) applyFilter(query *ReturnColliHistoryQuery) (*ReturnColliHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *returncollihistoryPager) toCursor(rch *ReturnColliHistory) Cursor {
	return p.order.Field.toCursor(rch)
}

func (p *returncollihistoryPager) applyCursors(query *ReturnColliHistoryQuery, after, before *Cursor) (*ReturnColliHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultReturnColliHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *returncollihistoryPager) applyOrder(query *ReturnColliHistoryQuery) *ReturnColliHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultReturnColliHistoryOrder.Field {
		query = query.Order(DefaultReturnColliHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *returncollihistoryPager) orderExpr(query *ReturnColliHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultReturnColliHistoryOrder.Field {
			b.Comma().Ident(DefaultReturnColliHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ReturnColliHistory.
func (rch *ReturnColliHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReturnColliHistoryPaginateOption,
) (*ReturnColliHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReturnColliHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rch, err = pager.applyFilter(rch); err != nil {
		return nil, err
	}
	conn := &ReturnColliHistoryConnection{Edges: []*ReturnColliHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := rch.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rch, err = pager.applyCursors(rch, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		rch.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rch.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rch = pager.applyOrder(rch)
	nodes, err := rch.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ReturnColliHistoryOrderField defines the ordering field of ReturnColliHistory.
type ReturnColliHistoryOrderField struct {
	// Value extracts the ordering value from the given ReturnColliHistory.
	Value    func(*ReturnColliHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) returncollihistory.OrderOption
	toCursor func(*ReturnColliHistory) Cursor
}

// ReturnColliHistoryOrder defines the ordering of ReturnColliHistory.
type ReturnColliHistoryOrder struct {
	Direction OrderDirection                `json:"direction"`
	Field     *ReturnColliHistoryOrderField `json:"field"`
}

// DefaultReturnColliHistoryOrder is the default ordering of ReturnColliHistory.
var DefaultReturnColliHistoryOrder = &ReturnColliHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReturnColliHistoryOrderField{
		Value: func(rch *ReturnColliHistory) (ent.Value, error) {
			return rch.ID, nil
		},
		column: returncollihistory.FieldID,
		toTerm: returncollihistory.ByID,
		toCursor: func(rch *ReturnColliHistory) Cursor {
			return Cursor{ID: rch.ID}
		},
	},
}

// ToEdge converts ReturnColliHistory into ReturnColliHistoryEdge.
func (rch *ReturnColliHistory) ToEdge(order *ReturnColliHistoryOrder) *ReturnColliHistoryEdge {
	if order == nil {
		order = DefaultReturnColliHistoryOrder
	}
	return &ReturnColliHistoryEdge{
		Node:   rch,
		Cursor: order.Field.toCursor(rch),
	}
}

// ReturnOrderLineEdge is the edge representation of ReturnOrderLine.
type ReturnOrderLineEdge struct {
	Node   *ReturnOrderLine `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ReturnOrderLineConnection is the connection containing edges to ReturnOrderLine.
type ReturnOrderLineConnection struct {
	Edges      []*ReturnOrderLineEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ReturnOrderLineConnection) build(nodes []*ReturnOrderLine, pager *returnorderlinePager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ReturnOrderLine
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReturnOrderLine {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReturnOrderLine {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReturnOrderLineEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReturnOrderLineEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReturnOrderLinePaginateOption enables pagination customization.
type ReturnOrderLinePaginateOption func(*returnorderlinePager) error

// WithReturnOrderLineOrder configures pagination ordering.
func WithReturnOrderLineOrder(order *ReturnOrderLineOrder) ReturnOrderLinePaginateOption {
	if order == nil {
		order = DefaultReturnOrderLineOrder
	}
	o := *order
	return func(pager *returnorderlinePager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReturnOrderLineOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReturnOrderLineFilter configures pagination filter.
func WithReturnOrderLineFilter(filter func(*ReturnOrderLineQuery) (*ReturnOrderLineQuery, error)) ReturnOrderLinePaginateOption {
	return func(pager *returnorderlinePager) error {
		if filter == nil {
			return errors.New("ReturnOrderLineQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type returnorderlinePager struct {
	reverse bool
	order   *ReturnOrderLineOrder
	filter  func(*ReturnOrderLineQuery) (*ReturnOrderLineQuery, error)
}

func newReturnOrderLinePager(opts []ReturnOrderLinePaginateOption, reverse bool) (*returnorderlinePager, error) {
	pager := &returnorderlinePager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReturnOrderLineOrder
	}
	return pager, nil
}

func (p *returnorderlinePager) applyFilter(query *ReturnOrderLineQuery) (*ReturnOrderLineQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *returnorderlinePager) toCursor(rol *ReturnOrderLine) Cursor {
	return p.order.Field.toCursor(rol)
}

func (p *returnorderlinePager) applyCursors(query *ReturnOrderLineQuery, after, before *Cursor) (*ReturnOrderLineQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultReturnOrderLineOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *returnorderlinePager) applyOrder(query *ReturnOrderLineQuery) *ReturnOrderLineQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultReturnOrderLineOrder.Field {
		query = query.Order(DefaultReturnOrderLineOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *returnorderlinePager) orderExpr(query *ReturnOrderLineQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultReturnOrderLineOrder.Field {
			b.Comma().Ident(DefaultReturnOrderLineOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ReturnOrderLine.
func (rol *ReturnOrderLineQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReturnOrderLinePaginateOption,
) (*ReturnOrderLineConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReturnOrderLinePager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rol, err = pager.applyFilter(rol); err != nil {
		return nil, err
	}
	conn := &ReturnOrderLineConnection{Edges: []*ReturnOrderLineEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := rol.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rol, err = pager.applyCursors(rol, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		rol.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rol.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rol = pager.applyOrder(rol)
	nodes, err := rol.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ReturnOrderLineOrderField defines the ordering field of ReturnOrderLine.
type ReturnOrderLineOrderField struct {
	// Value extracts the ordering value from the given ReturnOrderLine.
	Value    func(*ReturnOrderLine) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) returnorderline.OrderOption
	toCursor func(*ReturnOrderLine) Cursor
}

// ReturnOrderLineOrder defines the ordering of ReturnOrderLine.
type ReturnOrderLineOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ReturnOrderLineOrderField `json:"field"`
}

// DefaultReturnOrderLineOrder is the default ordering of ReturnOrderLine.
var DefaultReturnOrderLineOrder = &ReturnOrderLineOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReturnOrderLineOrderField{
		Value: func(rol *ReturnOrderLine) (ent.Value, error) {
			return rol.ID, nil
		},
		column: returnorderline.FieldID,
		toTerm: returnorderline.ByID,
		toCursor: func(rol *ReturnOrderLine) Cursor {
			return Cursor{ID: rol.ID}
		},
	},
}

// ToEdge converts ReturnOrderLine into ReturnOrderLineEdge.
func (rol *ReturnOrderLine) ToEdge(order *ReturnOrderLineOrder) *ReturnOrderLineEdge {
	if order == nil {
		order = DefaultReturnOrderLineOrder
	}
	return &ReturnOrderLineEdge{
		Node:   rol,
		Cursor: order.Field.toCursor(rol),
	}
}

// ReturnPortalEdge is the edge representation of ReturnPortal.
type ReturnPortalEdge struct {
	Node   *ReturnPortal `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ReturnPortalConnection is the connection containing edges to ReturnPortal.
type ReturnPortalConnection struct {
	Edges      []*ReturnPortalEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ReturnPortalConnection) build(nodes []*ReturnPortal, pager *returnportalPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ReturnPortal
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReturnPortal {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReturnPortal {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReturnPortalEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReturnPortalEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReturnPortalPaginateOption enables pagination customization.
type ReturnPortalPaginateOption func(*returnportalPager) error

// WithReturnPortalOrder configures pagination ordering.
func WithReturnPortalOrder(order *ReturnPortalOrder) ReturnPortalPaginateOption {
	if order == nil {
		order = DefaultReturnPortalOrder
	}
	o := *order
	return func(pager *returnportalPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReturnPortalOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReturnPortalFilter configures pagination filter.
func WithReturnPortalFilter(filter func(*ReturnPortalQuery) (*ReturnPortalQuery, error)) ReturnPortalPaginateOption {
	return func(pager *returnportalPager) error {
		if filter == nil {
			return errors.New("ReturnPortalQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type returnportalPager struct {
	reverse bool
	order   *ReturnPortalOrder
	filter  func(*ReturnPortalQuery) (*ReturnPortalQuery, error)
}

func newReturnPortalPager(opts []ReturnPortalPaginateOption, reverse bool) (*returnportalPager, error) {
	pager := &returnportalPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReturnPortalOrder
	}
	return pager, nil
}

func (p *returnportalPager) applyFilter(query *ReturnPortalQuery) (*ReturnPortalQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *returnportalPager) toCursor(rp *ReturnPortal) Cursor {
	return p.order.Field.toCursor(rp)
}

func (p *returnportalPager) applyCursors(query *ReturnPortalQuery, after, before *Cursor) (*ReturnPortalQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultReturnPortalOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *returnportalPager) applyOrder(query *ReturnPortalQuery) *ReturnPortalQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultReturnPortalOrder.Field {
		query = query.Order(DefaultReturnPortalOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *returnportalPager) orderExpr(query *ReturnPortalQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultReturnPortalOrder.Field {
			b.Comma().Ident(DefaultReturnPortalOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ReturnPortal.
func (rp *ReturnPortalQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReturnPortalPaginateOption,
) (*ReturnPortalConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReturnPortalPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rp, err = pager.applyFilter(rp); err != nil {
		return nil, err
	}
	conn := &ReturnPortalConnection{Edges: []*ReturnPortalEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := rp.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rp, err = pager.applyCursors(rp, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		rp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rp.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rp = pager.applyOrder(rp)
	nodes, err := rp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ReturnPortalOrderField defines the ordering field of ReturnPortal.
type ReturnPortalOrderField struct {
	// Value extracts the ordering value from the given ReturnPortal.
	Value    func(*ReturnPortal) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) returnportal.OrderOption
	toCursor func(*ReturnPortal) Cursor
}

// ReturnPortalOrder defines the ordering of ReturnPortal.
type ReturnPortalOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ReturnPortalOrderField `json:"field"`
}

// DefaultReturnPortalOrder is the default ordering of ReturnPortal.
var DefaultReturnPortalOrder = &ReturnPortalOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReturnPortalOrderField{
		Value: func(rp *ReturnPortal) (ent.Value, error) {
			return rp.ID, nil
		},
		column: returnportal.FieldID,
		toTerm: returnportal.ByID,
		toCursor: func(rp *ReturnPortal) Cursor {
			return Cursor{ID: rp.ID}
		},
	},
}

// ToEdge converts ReturnPortal into ReturnPortalEdge.
func (rp *ReturnPortal) ToEdge(order *ReturnPortalOrder) *ReturnPortalEdge {
	if order == nil {
		order = DefaultReturnPortalOrder
	}
	return &ReturnPortalEdge{
		Node:   rp,
		Cursor: order.Field.toCursor(rp),
	}
}

// ReturnPortalClaimEdge is the edge representation of ReturnPortalClaim.
type ReturnPortalClaimEdge struct {
	Node   *ReturnPortalClaim `json:"node"`
	Cursor Cursor             `json:"cursor"`
}

// ReturnPortalClaimConnection is the connection containing edges to ReturnPortalClaim.
type ReturnPortalClaimConnection struct {
	Edges      []*ReturnPortalClaimEdge `json:"edges"`
	PageInfo   PageInfo                 `json:"pageInfo"`
	TotalCount int                      `json:"totalCount"`
}

func (c *ReturnPortalClaimConnection) build(nodes []*ReturnPortalClaim, pager *returnportalclaimPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ReturnPortalClaim
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ReturnPortalClaim {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ReturnPortalClaim {
			return nodes[i]
		}
	}
	c.Edges = make([]*ReturnPortalClaimEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ReturnPortalClaimEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ReturnPortalClaimPaginateOption enables pagination customization.
type ReturnPortalClaimPaginateOption func(*returnportalclaimPager) error

// WithReturnPortalClaimOrder configures pagination ordering.
func WithReturnPortalClaimOrder(order *ReturnPortalClaimOrder) ReturnPortalClaimPaginateOption {
	if order == nil {
		order = DefaultReturnPortalClaimOrder
	}
	o := *order
	return func(pager *returnportalclaimPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultReturnPortalClaimOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithReturnPortalClaimFilter configures pagination filter.
func WithReturnPortalClaimFilter(filter func(*ReturnPortalClaimQuery) (*ReturnPortalClaimQuery, error)) ReturnPortalClaimPaginateOption {
	return func(pager *returnportalclaimPager) error {
		if filter == nil {
			return errors.New("ReturnPortalClaimQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type returnportalclaimPager struct {
	reverse bool
	order   *ReturnPortalClaimOrder
	filter  func(*ReturnPortalClaimQuery) (*ReturnPortalClaimQuery, error)
}

func newReturnPortalClaimPager(opts []ReturnPortalClaimPaginateOption, reverse bool) (*returnportalclaimPager, error) {
	pager := &returnportalclaimPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultReturnPortalClaimOrder
	}
	return pager, nil
}

func (p *returnportalclaimPager) applyFilter(query *ReturnPortalClaimQuery) (*ReturnPortalClaimQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *returnportalclaimPager) toCursor(rpc *ReturnPortalClaim) Cursor {
	return p.order.Field.toCursor(rpc)
}

func (p *returnportalclaimPager) applyCursors(query *ReturnPortalClaimQuery, after, before *Cursor) (*ReturnPortalClaimQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultReturnPortalClaimOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *returnportalclaimPager) applyOrder(query *ReturnPortalClaimQuery) *ReturnPortalClaimQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultReturnPortalClaimOrder.Field {
		query = query.Order(DefaultReturnPortalClaimOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *returnportalclaimPager) orderExpr(query *ReturnPortalClaimQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultReturnPortalClaimOrder.Field {
			b.Comma().Ident(DefaultReturnPortalClaimOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ReturnPortalClaim.
func (rpc *ReturnPortalClaimQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ReturnPortalClaimPaginateOption,
) (*ReturnPortalClaimConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newReturnPortalClaimPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if rpc, err = pager.applyFilter(rpc); err != nil {
		return nil, err
	}
	conn := &ReturnPortalClaimConnection{Edges: []*ReturnPortalClaimEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := rpc.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if rpc, err = pager.applyCursors(rpc, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		rpc.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := rpc.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	rpc = pager.applyOrder(rpc)
	nodes, err := rpc.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ReturnPortalClaimOrderField defines the ordering field of ReturnPortalClaim.
type ReturnPortalClaimOrderField struct {
	// Value extracts the ordering value from the given ReturnPortalClaim.
	Value    func(*ReturnPortalClaim) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) returnportalclaim.OrderOption
	toCursor func(*ReturnPortalClaim) Cursor
}

// ReturnPortalClaimOrder defines the ordering of ReturnPortalClaim.
type ReturnPortalClaimOrder struct {
	Direction OrderDirection               `json:"direction"`
	Field     *ReturnPortalClaimOrderField `json:"field"`
}

// DefaultReturnPortalClaimOrder is the default ordering of ReturnPortalClaim.
var DefaultReturnPortalClaimOrder = &ReturnPortalClaimOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ReturnPortalClaimOrderField{
		Value: func(rpc *ReturnPortalClaim) (ent.Value, error) {
			return rpc.ID, nil
		},
		column: returnportalclaim.FieldID,
		toTerm: returnportalclaim.ByID,
		toCursor: func(rpc *ReturnPortalClaim) Cursor {
			return Cursor{ID: rpc.ID}
		},
	},
}

// ToEdge converts ReturnPortalClaim into ReturnPortalClaimEdge.
func (rpc *ReturnPortalClaim) ToEdge(order *ReturnPortalClaimOrder) *ReturnPortalClaimEdge {
	if order == nil {
		order = DefaultReturnPortalClaimOrder
	}
	return &ReturnPortalClaimEdge{
		Node:   rpc,
		Cursor: order.Field.toCursor(rpc),
	}
}

// SeatGroupEdge is the edge representation of SeatGroup.
type SeatGroupEdge struct {
	Node   *SeatGroup `json:"node"`
	Cursor Cursor     `json:"cursor"`
}

// SeatGroupConnection is the connection containing edges to SeatGroup.
type SeatGroupConnection struct {
	Edges      []*SeatGroupEdge `json:"edges"`
	PageInfo   PageInfo         `json:"pageInfo"`
	TotalCount int              `json:"totalCount"`
}

func (c *SeatGroupConnection) build(nodes []*SeatGroup, pager *seatgroupPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SeatGroup
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SeatGroup {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SeatGroup {
			return nodes[i]
		}
	}
	c.Edges = make([]*SeatGroupEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SeatGroupEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SeatGroupPaginateOption enables pagination customization.
type SeatGroupPaginateOption func(*seatgroupPager) error

// WithSeatGroupOrder configures pagination ordering.
func WithSeatGroupOrder(order *SeatGroupOrder) SeatGroupPaginateOption {
	if order == nil {
		order = DefaultSeatGroupOrder
	}
	o := *order
	return func(pager *seatgroupPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSeatGroupOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSeatGroupFilter configures pagination filter.
func WithSeatGroupFilter(filter func(*SeatGroupQuery) (*SeatGroupQuery, error)) SeatGroupPaginateOption {
	return func(pager *seatgroupPager) error {
		if filter == nil {
			return errors.New("SeatGroupQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type seatgroupPager struct {
	reverse bool
	order   *SeatGroupOrder
	filter  func(*SeatGroupQuery) (*SeatGroupQuery, error)
}

func newSeatGroupPager(opts []SeatGroupPaginateOption, reverse bool) (*seatgroupPager, error) {
	pager := &seatgroupPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSeatGroupOrder
	}
	return pager, nil
}

func (p *seatgroupPager) applyFilter(query *SeatGroupQuery) (*SeatGroupQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *seatgroupPager) toCursor(sg *SeatGroup) Cursor {
	return p.order.Field.toCursor(sg)
}

func (p *seatgroupPager) applyCursors(query *SeatGroupQuery, after, before *Cursor) (*SeatGroupQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSeatGroupOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *seatgroupPager) applyOrder(query *SeatGroupQuery) *SeatGroupQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSeatGroupOrder.Field {
		query = query.Order(DefaultSeatGroupOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *seatgroupPager) orderExpr(query *SeatGroupQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSeatGroupOrder.Field {
			b.Comma().Ident(DefaultSeatGroupOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SeatGroup.
func (sg *SeatGroupQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SeatGroupPaginateOption,
) (*SeatGroupConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSeatGroupPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sg, err = pager.applyFilter(sg); err != nil {
		return nil, err
	}
	conn := &SeatGroupConnection{Edges: []*SeatGroupEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sg.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sg, err = pager.applyCursors(sg, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sg.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sg = pager.applyOrder(sg)
	nodes, err := sg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SeatGroupOrderField defines the ordering field of SeatGroup.
type SeatGroupOrderField struct {
	// Value extracts the ordering value from the given SeatGroup.
	Value    func(*SeatGroup) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) seatgroup.OrderOption
	toCursor func(*SeatGroup) Cursor
}

// SeatGroupOrder defines the ordering of SeatGroup.
type SeatGroupOrder struct {
	Direction OrderDirection       `json:"direction"`
	Field     *SeatGroupOrderField `json:"field"`
}

// DefaultSeatGroupOrder is the default ordering of SeatGroup.
var DefaultSeatGroupOrder = &SeatGroupOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SeatGroupOrderField{
		Value: func(sg *SeatGroup) (ent.Value, error) {
			return sg.ID, nil
		},
		column: seatgroup.FieldID,
		toTerm: seatgroup.ByID,
		toCursor: func(sg *SeatGroup) Cursor {
			return Cursor{ID: sg.ID}
		},
	},
}

// ToEdge converts SeatGroup into SeatGroupEdge.
func (sg *SeatGroup) ToEdge(order *SeatGroupOrder) *SeatGroupEdge {
	if order == nil {
		order = DefaultSeatGroupOrder
	}
	return &SeatGroupEdge{
		Node:   sg,
		Cursor: order.Field.toCursor(sg),
	}
}

// SeatGroupAccessRightEdge is the edge representation of SeatGroupAccessRight.
type SeatGroupAccessRightEdge struct {
	Node   *SeatGroupAccessRight `json:"node"`
	Cursor Cursor                `json:"cursor"`
}

// SeatGroupAccessRightConnection is the connection containing edges to SeatGroupAccessRight.
type SeatGroupAccessRightConnection struct {
	Edges      []*SeatGroupAccessRightEdge `json:"edges"`
	PageInfo   PageInfo                    `json:"pageInfo"`
	TotalCount int                         `json:"totalCount"`
}

func (c *SeatGroupAccessRightConnection) build(nodes []*SeatGroupAccessRight, pager *seatgroupaccessrightPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SeatGroupAccessRight
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SeatGroupAccessRight {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SeatGroupAccessRight {
			return nodes[i]
		}
	}
	c.Edges = make([]*SeatGroupAccessRightEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SeatGroupAccessRightEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SeatGroupAccessRightPaginateOption enables pagination customization.
type SeatGroupAccessRightPaginateOption func(*seatgroupaccessrightPager) error

// WithSeatGroupAccessRightOrder configures pagination ordering.
func WithSeatGroupAccessRightOrder(order *SeatGroupAccessRightOrder) SeatGroupAccessRightPaginateOption {
	if order == nil {
		order = DefaultSeatGroupAccessRightOrder
	}
	o := *order
	return func(pager *seatgroupaccessrightPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSeatGroupAccessRightOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSeatGroupAccessRightFilter configures pagination filter.
func WithSeatGroupAccessRightFilter(filter func(*SeatGroupAccessRightQuery) (*SeatGroupAccessRightQuery, error)) SeatGroupAccessRightPaginateOption {
	return func(pager *seatgroupaccessrightPager) error {
		if filter == nil {
			return errors.New("SeatGroupAccessRightQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type seatgroupaccessrightPager struct {
	reverse bool
	order   *SeatGroupAccessRightOrder
	filter  func(*SeatGroupAccessRightQuery) (*SeatGroupAccessRightQuery, error)
}

func newSeatGroupAccessRightPager(opts []SeatGroupAccessRightPaginateOption, reverse bool) (*seatgroupaccessrightPager, error) {
	pager := &seatgroupaccessrightPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSeatGroupAccessRightOrder
	}
	return pager, nil
}

func (p *seatgroupaccessrightPager) applyFilter(query *SeatGroupAccessRightQuery) (*SeatGroupAccessRightQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *seatgroupaccessrightPager) toCursor(sgar *SeatGroupAccessRight) Cursor {
	return p.order.Field.toCursor(sgar)
}

func (p *seatgroupaccessrightPager) applyCursors(query *SeatGroupAccessRightQuery, after, before *Cursor) (*SeatGroupAccessRightQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSeatGroupAccessRightOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *seatgroupaccessrightPager) applyOrder(query *SeatGroupAccessRightQuery) *SeatGroupAccessRightQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSeatGroupAccessRightOrder.Field {
		query = query.Order(DefaultSeatGroupAccessRightOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *seatgroupaccessrightPager) orderExpr(query *SeatGroupAccessRightQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSeatGroupAccessRightOrder.Field {
			b.Comma().Ident(DefaultSeatGroupAccessRightOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SeatGroupAccessRight.
func (sgar *SeatGroupAccessRightQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SeatGroupAccessRightPaginateOption,
) (*SeatGroupAccessRightConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSeatGroupAccessRightPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sgar, err = pager.applyFilter(sgar); err != nil {
		return nil, err
	}
	conn := &SeatGroupAccessRightConnection{Edges: []*SeatGroupAccessRightEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sgar.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sgar, err = pager.applyCursors(sgar, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sgar.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sgar.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sgar = pager.applyOrder(sgar)
	nodes, err := sgar.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SeatGroupAccessRightOrderField defines the ordering field of SeatGroupAccessRight.
type SeatGroupAccessRightOrderField struct {
	// Value extracts the ordering value from the given SeatGroupAccessRight.
	Value    func(*SeatGroupAccessRight) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) seatgroupaccessright.OrderOption
	toCursor func(*SeatGroupAccessRight) Cursor
}

// SeatGroupAccessRightOrder defines the ordering of SeatGroupAccessRight.
type SeatGroupAccessRightOrder struct {
	Direction OrderDirection                  `json:"direction"`
	Field     *SeatGroupAccessRightOrderField `json:"field"`
}

// DefaultSeatGroupAccessRightOrder is the default ordering of SeatGroupAccessRight.
var DefaultSeatGroupAccessRightOrder = &SeatGroupAccessRightOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SeatGroupAccessRightOrderField{
		Value: func(sgar *SeatGroupAccessRight) (ent.Value, error) {
			return sgar.ID, nil
		},
		column: seatgroupaccessright.FieldID,
		toTerm: seatgroupaccessright.ByID,
		toCursor: func(sgar *SeatGroupAccessRight) Cursor {
			return Cursor{ID: sgar.ID}
		},
	},
}

// ToEdge converts SeatGroupAccessRight into SeatGroupAccessRightEdge.
func (sgar *SeatGroupAccessRight) ToEdge(order *SeatGroupAccessRightOrder) *SeatGroupAccessRightEdge {
	if order == nil {
		order = DefaultSeatGroupAccessRightOrder
	}
	return &SeatGroupAccessRightEdge{
		Node:   sgar,
		Cursor: order.Field.toCursor(sgar),
	}
}

// ShipmentEdge is the edge representation of Shipment.
type ShipmentEdge struct {
	Node   *Shipment `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// ShipmentConnection is the connection containing edges to Shipment.
type ShipmentConnection struct {
	Edges      []*ShipmentEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *ShipmentConnection) build(nodes []*Shipment, pager *shipmentPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Shipment
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Shipment {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Shipment {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentPaginateOption enables pagination customization.
type ShipmentPaginateOption func(*shipmentPager) error

// WithShipmentOrder configures pagination ordering.
func WithShipmentOrder(order *ShipmentOrder) ShipmentPaginateOption {
	if order == nil {
		order = DefaultShipmentOrder
	}
	o := *order
	return func(pager *shipmentPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentFilter configures pagination filter.
func WithShipmentFilter(filter func(*ShipmentQuery) (*ShipmentQuery, error)) ShipmentPaginateOption {
	return func(pager *shipmentPager) error {
		if filter == nil {
			return errors.New("ShipmentQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentPager struct {
	reverse bool
	order   *ShipmentOrder
	filter  func(*ShipmentQuery) (*ShipmentQuery, error)
}

func newShipmentPager(opts []ShipmentPaginateOption, reverse bool) (*shipmentPager, error) {
	pager := &shipmentPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentOrder
	}
	return pager, nil
}

func (p *shipmentPager) applyFilter(query *ShipmentQuery) (*ShipmentQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentPager) toCursor(s *Shipment) Cursor {
	return p.order.Field.toCursor(s)
}

func (p *shipmentPager) applyCursors(query *ShipmentQuery, after, before *Cursor) (*ShipmentQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentPager) applyOrder(query *ShipmentQuery) *ShipmentQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentOrder.Field {
		query = query.Order(DefaultShipmentOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmentPager) orderExpr(query *ShipmentQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentOrder.Field {
			b.Comma().Ident(DefaultShipmentOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Shipment.
func (s *ShipmentQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentPaginateOption,
) (*ShipmentConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if s, err = pager.applyFilter(s); err != nil {
		return nil, err
	}
	conn := &ShipmentConnection{Edges: []*ShipmentEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := s.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if s, err = pager.applyCursors(s, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		s.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := s.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	s = pager.applyOrder(s)
	nodes, err := s.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ShipmentOrderFieldCreatedAt orders Shipment by created_at.
	ShipmentOrderFieldCreatedAt = &ShipmentOrderField{
		Value: func(s *Shipment) (ent.Value, error) {
			return s.CreatedAt, nil
		},
		column: shipment.FieldCreatedAt,
		toTerm: shipment.ByCreatedAt,
		toCursor: func(s *Shipment) Cursor {
			return Cursor{
				ID:    s.ID,
				Value: s.CreatedAt,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ShipmentOrderField) String() string {
	var str string
	switch f.column {
	case ShipmentOrderFieldCreatedAt.column:
		str = "CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ShipmentOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ShipmentOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ShipmentOrderField %T must be a string", v)
	}
	switch str {
	case "CREATED_AT":
		*f = *ShipmentOrderFieldCreatedAt
	default:
		return fmt.Errorf("%s is not a valid ShipmentOrderField", str)
	}
	return nil
}

// ShipmentOrderField defines the ordering field of Shipment.
type ShipmentOrderField struct {
	// Value extracts the ordering value from the given Shipment.
	Value    func(*Shipment) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipment.OrderOption
	toCursor func(*Shipment) Cursor
}

// ShipmentOrder defines the ordering of Shipment.
type ShipmentOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *ShipmentOrderField `json:"field"`
}

// DefaultShipmentOrder is the default ordering of Shipment.
var DefaultShipmentOrder = &ShipmentOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentOrderField{
		Value: func(s *Shipment) (ent.Value, error) {
			return s.ID, nil
		},
		column: shipment.FieldID,
		toTerm: shipment.ByID,
		toCursor: func(s *Shipment) Cursor {
			return Cursor{ID: s.ID}
		},
	},
}

// ToEdge converts Shipment into ShipmentEdge.
func (s *Shipment) ToEdge(order *ShipmentOrder) *ShipmentEdge {
	if order == nil {
		order = DefaultShipmentOrder
	}
	return &ShipmentEdge{
		Node:   s,
		Cursor: order.Field.toCursor(s),
	}
}

// ShipmentBringEdge is the edge representation of ShipmentBring.
type ShipmentBringEdge struct {
	Node   *ShipmentBring `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// ShipmentBringConnection is the connection containing edges to ShipmentBring.
type ShipmentBringConnection struct {
	Edges      []*ShipmentBringEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *ShipmentBringConnection) build(nodes []*ShipmentBring, pager *shipmentbringPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentBring
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentBring {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentBring {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentBringEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentBringEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentBringPaginateOption enables pagination customization.
type ShipmentBringPaginateOption func(*shipmentbringPager) error

// WithShipmentBringOrder configures pagination ordering.
func WithShipmentBringOrder(order *ShipmentBringOrder) ShipmentBringPaginateOption {
	if order == nil {
		order = DefaultShipmentBringOrder
	}
	o := *order
	return func(pager *shipmentbringPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentBringOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentBringFilter configures pagination filter.
func WithShipmentBringFilter(filter func(*ShipmentBringQuery) (*ShipmentBringQuery, error)) ShipmentBringPaginateOption {
	return func(pager *shipmentbringPager) error {
		if filter == nil {
			return errors.New("ShipmentBringQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentbringPager struct {
	reverse bool
	order   *ShipmentBringOrder
	filter  func(*ShipmentBringQuery) (*ShipmentBringQuery, error)
}

func newShipmentBringPager(opts []ShipmentBringPaginateOption, reverse bool) (*shipmentbringPager, error) {
	pager := &shipmentbringPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentBringOrder
	}
	return pager, nil
}

func (p *shipmentbringPager) applyFilter(query *ShipmentBringQuery) (*ShipmentBringQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentbringPager) toCursor(sb *ShipmentBring) Cursor {
	return p.order.Field.toCursor(sb)
}

func (p *shipmentbringPager) applyCursors(query *ShipmentBringQuery, after, before *Cursor) (*ShipmentBringQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentBringOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentbringPager) applyOrder(query *ShipmentBringQuery) *ShipmentBringQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentBringOrder.Field {
		query = query.Order(DefaultShipmentBringOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmentbringPager) orderExpr(query *ShipmentBringQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentBringOrder.Field {
			b.Comma().Ident(DefaultShipmentBringOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentBring.
func (sb *ShipmentBringQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentBringPaginateOption,
) (*ShipmentBringConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentBringPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sb, err = pager.applyFilter(sb); err != nil {
		return nil, err
	}
	conn := &ShipmentBringConnection{Edges: []*ShipmentBringEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sb.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sb, err = pager.applyCursors(sb, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sb.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sb.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sb = pager.applyOrder(sb)
	nodes, err := sb.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentBringOrderField defines the ordering field of ShipmentBring.
type ShipmentBringOrderField struct {
	// Value extracts the ordering value from the given ShipmentBring.
	Value    func(*ShipmentBring) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmentbring.OrderOption
	toCursor func(*ShipmentBring) Cursor
}

// ShipmentBringOrder defines the ordering of ShipmentBring.
type ShipmentBringOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *ShipmentBringOrderField `json:"field"`
}

// DefaultShipmentBringOrder is the default ordering of ShipmentBring.
var DefaultShipmentBringOrder = &ShipmentBringOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentBringOrderField{
		Value: func(sb *ShipmentBring) (ent.Value, error) {
			return sb.ID, nil
		},
		column: shipmentbring.FieldID,
		toTerm: shipmentbring.ByID,
		toCursor: func(sb *ShipmentBring) Cursor {
			return Cursor{ID: sb.ID}
		},
	},
}

// ToEdge converts ShipmentBring into ShipmentBringEdge.
func (sb *ShipmentBring) ToEdge(order *ShipmentBringOrder) *ShipmentBringEdge {
	if order == nil {
		order = DefaultShipmentBringOrder
	}
	return &ShipmentBringEdge{
		Node:   sb,
		Cursor: order.Field.toCursor(sb),
	}
}

// ShipmentDAOEdge is the edge representation of ShipmentDAO.
type ShipmentDAOEdge struct {
	Node   *ShipmentDAO `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ShipmentDAOConnection is the connection containing edges to ShipmentDAO.
type ShipmentDAOConnection struct {
	Edges      []*ShipmentDAOEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ShipmentDAOConnection) build(nodes []*ShipmentDAO, pager *shipmentdaoPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentDAO
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentDAO {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentDAO {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentDAOEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentDAOEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentDAOPaginateOption enables pagination customization.
type ShipmentDAOPaginateOption func(*shipmentdaoPager) error

// WithShipmentDAOOrder configures pagination ordering.
func WithShipmentDAOOrder(order *ShipmentDAOOrder) ShipmentDAOPaginateOption {
	if order == nil {
		order = DefaultShipmentDAOOrder
	}
	o := *order
	return func(pager *shipmentdaoPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentDAOOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentDAOFilter configures pagination filter.
func WithShipmentDAOFilter(filter func(*ShipmentDAOQuery) (*ShipmentDAOQuery, error)) ShipmentDAOPaginateOption {
	return func(pager *shipmentdaoPager) error {
		if filter == nil {
			return errors.New("ShipmentDAOQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentdaoPager struct {
	reverse bool
	order   *ShipmentDAOOrder
	filter  func(*ShipmentDAOQuery) (*ShipmentDAOQuery, error)
}

func newShipmentDAOPager(opts []ShipmentDAOPaginateOption, reverse bool) (*shipmentdaoPager, error) {
	pager := &shipmentdaoPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentDAOOrder
	}
	return pager, nil
}

func (p *shipmentdaoPager) applyFilter(query *ShipmentDAOQuery) (*ShipmentDAOQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentdaoPager) toCursor(sd *ShipmentDAO) Cursor {
	return p.order.Field.toCursor(sd)
}

func (p *shipmentdaoPager) applyCursors(query *ShipmentDAOQuery, after, before *Cursor) (*ShipmentDAOQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentDAOOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentdaoPager) applyOrder(query *ShipmentDAOQuery) *ShipmentDAOQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentDAOOrder.Field {
		query = query.Order(DefaultShipmentDAOOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmentdaoPager) orderExpr(query *ShipmentDAOQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentDAOOrder.Field {
			b.Comma().Ident(DefaultShipmentDAOOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentDAO.
func (sd *ShipmentDAOQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentDAOPaginateOption,
) (*ShipmentDAOConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentDAOPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sd, err = pager.applyFilter(sd); err != nil {
		return nil, err
	}
	conn := &ShipmentDAOConnection{Edges: []*ShipmentDAOEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sd, err = pager.applyCursors(sd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sd = pager.applyOrder(sd)
	nodes, err := sd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentDAOOrderField defines the ordering field of ShipmentDAO.
type ShipmentDAOOrderField struct {
	// Value extracts the ordering value from the given ShipmentDAO.
	Value    func(*ShipmentDAO) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmentdao.OrderOption
	toCursor func(*ShipmentDAO) Cursor
}

// ShipmentDAOOrder defines the ordering of ShipmentDAO.
type ShipmentDAOOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ShipmentDAOOrderField `json:"field"`
}

// DefaultShipmentDAOOrder is the default ordering of ShipmentDAO.
var DefaultShipmentDAOOrder = &ShipmentDAOOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentDAOOrderField{
		Value: func(sd *ShipmentDAO) (ent.Value, error) {
			return sd.ID, nil
		},
		column: shipmentdao.FieldID,
		toTerm: shipmentdao.ByID,
		toCursor: func(sd *ShipmentDAO) Cursor {
			return Cursor{ID: sd.ID}
		},
	},
}

// ToEdge converts ShipmentDAO into ShipmentDAOEdge.
func (sd *ShipmentDAO) ToEdge(order *ShipmentDAOOrder) *ShipmentDAOEdge {
	if order == nil {
		order = DefaultShipmentDAOOrder
	}
	return &ShipmentDAOEdge{
		Node:   sd,
		Cursor: order.Field.toCursor(sd),
	}
}

// ShipmentDFEdge is the edge representation of ShipmentDF.
type ShipmentDFEdge struct {
	Node   *ShipmentDF `json:"node"`
	Cursor Cursor      `json:"cursor"`
}

// ShipmentDFConnection is the connection containing edges to ShipmentDF.
type ShipmentDFConnection struct {
	Edges      []*ShipmentDFEdge `json:"edges"`
	PageInfo   PageInfo          `json:"pageInfo"`
	TotalCount int               `json:"totalCount"`
}

func (c *ShipmentDFConnection) build(nodes []*ShipmentDF, pager *shipmentdfPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentDF
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentDF {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentDF {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentDFEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentDFEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentDFPaginateOption enables pagination customization.
type ShipmentDFPaginateOption func(*shipmentdfPager) error

// WithShipmentDFOrder configures pagination ordering.
func WithShipmentDFOrder(order *ShipmentDFOrder) ShipmentDFPaginateOption {
	if order == nil {
		order = DefaultShipmentDFOrder
	}
	o := *order
	return func(pager *shipmentdfPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentDFOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentDFFilter configures pagination filter.
func WithShipmentDFFilter(filter func(*ShipmentDFQuery) (*ShipmentDFQuery, error)) ShipmentDFPaginateOption {
	return func(pager *shipmentdfPager) error {
		if filter == nil {
			return errors.New("ShipmentDFQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentdfPager struct {
	reverse bool
	order   *ShipmentDFOrder
	filter  func(*ShipmentDFQuery) (*ShipmentDFQuery, error)
}

func newShipmentDFPager(opts []ShipmentDFPaginateOption, reverse bool) (*shipmentdfPager, error) {
	pager := &shipmentdfPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentDFOrder
	}
	return pager, nil
}

func (p *shipmentdfPager) applyFilter(query *ShipmentDFQuery) (*ShipmentDFQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentdfPager) toCursor(sd *ShipmentDF) Cursor {
	return p.order.Field.toCursor(sd)
}

func (p *shipmentdfPager) applyCursors(query *ShipmentDFQuery, after, before *Cursor) (*ShipmentDFQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentDFOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentdfPager) applyOrder(query *ShipmentDFQuery) *ShipmentDFQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentDFOrder.Field {
		query = query.Order(DefaultShipmentDFOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmentdfPager) orderExpr(query *ShipmentDFQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentDFOrder.Field {
			b.Comma().Ident(DefaultShipmentDFOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentDF.
func (sd *ShipmentDFQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentDFPaginateOption,
) (*ShipmentDFConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentDFPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sd, err = pager.applyFilter(sd); err != nil {
		return nil, err
	}
	conn := &ShipmentDFConnection{Edges: []*ShipmentDFEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sd, err = pager.applyCursors(sd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sd = pager.applyOrder(sd)
	nodes, err := sd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentDFOrderField defines the ordering field of ShipmentDF.
type ShipmentDFOrderField struct {
	// Value extracts the ordering value from the given ShipmentDF.
	Value    func(*ShipmentDF) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmentdf.OrderOption
	toCursor func(*ShipmentDF) Cursor
}

// ShipmentDFOrder defines the ordering of ShipmentDF.
type ShipmentDFOrder struct {
	Direction OrderDirection        `json:"direction"`
	Field     *ShipmentDFOrderField `json:"field"`
}

// DefaultShipmentDFOrder is the default ordering of ShipmentDF.
var DefaultShipmentDFOrder = &ShipmentDFOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentDFOrderField{
		Value: func(sd *ShipmentDF) (ent.Value, error) {
			return sd.ID, nil
		},
		column: shipmentdf.FieldID,
		toTerm: shipmentdf.ByID,
		toCursor: func(sd *ShipmentDF) Cursor {
			return Cursor{ID: sd.ID}
		},
	},
}

// ToEdge converts ShipmentDF into ShipmentDFEdge.
func (sd *ShipmentDF) ToEdge(order *ShipmentDFOrder) *ShipmentDFEdge {
	if order == nil {
		order = DefaultShipmentDFOrder
	}
	return &ShipmentDFEdge{
		Node:   sd,
		Cursor: order.Field.toCursor(sd),
	}
}

// ShipmentDSVEdge is the edge representation of ShipmentDSV.
type ShipmentDSVEdge struct {
	Node   *ShipmentDSV `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ShipmentDSVConnection is the connection containing edges to ShipmentDSV.
type ShipmentDSVConnection struct {
	Edges      []*ShipmentDSVEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ShipmentDSVConnection) build(nodes []*ShipmentDSV, pager *shipmentdsvPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentDSV
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentDSV {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentDSV {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentDSVEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentDSVEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentDSVPaginateOption enables pagination customization.
type ShipmentDSVPaginateOption func(*shipmentdsvPager) error

// WithShipmentDSVOrder configures pagination ordering.
func WithShipmentDSVOrder(order *ShipmentDSVOrder) ShipmentDSVPaginateOption {
	if order == nil {
		order = DefaultShipmentDSVOrder
	}
	o := *order
	return func(pager *shipmentdsvPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentDSVOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentDSVFilter configures pagination filter.
func WithShipmentDSVFilter(filter func(*ShipmentDSVQuery) (*ShipmentDSVQuery, error)) ShipmentDSVPaginateOption {
	return func(pager *shipmentdsvPager) error {
		if filter == nil {
			return errors.New("ShipmentDSVQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentdsvPager struct {
	reverse bool
	order   *ShipmentDSVOrder
	filter  func(*ShipmentDSVQuery) (*ShipmentDSVQuery, error)
}

func newShipmentDSVPager(opts []ShipmentDSVPaginateOption, reverse bool) (*shipmentdsvPager, error) {
	pager := &shipmentdsvPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentDSVOrder
	}
	return pager, nil
}

func (p *shipmentdsvPager) applyFilter(query *ShipmentDSVQuery) (*ShipmentDSVQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentdsvPager) toCursor(sd *ShipmentDSV) Cursor {
	return p.order.Field.toCursor(sd)
}

func (p *shipmentdsvPager) applyCursors(query *ShipmentDSVQuery, after, before *Cursor) (*ShipmentDSVQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentDSVOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentdsvPager) applyOrder(query *ShipmentDSVQuery) *ShipmentDSVQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentDSVOrder.Field {
		query = query.Order(DefaultShipmentDSVOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmentdsvPager) orderExpr(query *ShipmentDSVQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentDSVOrder.Field {
			b.Comma().Ident(DefaultShipmentDSVOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentDSV.
func (sd *ShipmentDSVQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentDSVPaginateOption,
) (*ShipmentDSVConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentDSVPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sd, err = pager.applyFilter(sd); err != nil {
		return nil, err
	}
	conn := &ShipmentDSVConnection{Edges: []*ShipmentDSVEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sd.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sd, err = pager.applyCursors(sd, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sd.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sd.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sd = pager.applyOrder(sd)
	nodes, err := sd.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentDSVOrderField defines the ordering field of ShipmentDSV.
type ShipmentDSVOrderField struct {
	// Value extracts the ordering value from the given ShipmentDSV.
	Value    func(*ShipmentDSV) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmentdsv.OrderOption
	toCursor func(*ShipmentDSV) Cursor
}

// ShipmentDSVOrder defines the ordering of ShipmentDSV.
type ShipmentDSVOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ShipmentDSVOrderField `json:"field"`
}

// DefaultShipmentDSVOrder is the default ordering of ShipmentDSV.
var DefaultShipmentDSVOrder = &ShipmentDSVOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentDSVOrderField{
		Value: func(sd *ShipmentDSV) (ent.Value, error) {
			return sd.ID, nil
		},
		column: shipmentdsv.FieldID,
		toTerm: shipmentdsv.ByID,
		toCursor: func(sd *ShipmentDSV) Cursor {
			return Cursor{ID: sd.ID}
		},
	},
}

// ToEdge converts ShipmentDSV into ShipmentDSVEdge.
func (sd *ShipmentDSV) ToEdge(order *ShipmentDSVOrder) *ShipmentDSVEdge {
	if order == nil {
		order = DefaultShipmentDSVOrder
	}
	return &ShipmentDSVEdge{
		Node:   sd,
		Cursor: order.Field.toCursor(sd),
	}
}

// ShipmentEasyPostEdge is the edge representation of ShipmentEasyPost.
type ShipmentEasyPostEdge struct {
	Node   *ShipmentEasyPost `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ShipmentEasyPostConnection is the connection containing edges to ShipmentEasyPost.
type ShipmentEasyPostConnection struct {
	Edges      []*ShipmentEasyPostEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ShipmentEasyPostConnection) build(nodes []*ShipmentEasyPost, pager *shipmenteasypostPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentEasyPost
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentEasyPost {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentEasyPost {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentEasyPostEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentEasyPostEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentEasyPostPaginateOption enables pagination customization.
type ShipmentEasyPostPaginateOption func(*shipmenteasypostPager) error

// WithShipmentEasyPostOrder configures pagination ordering.
func WithShipmentEasyPostOrder(order *ShipmentEasyPostOrder) ShipmentEasyPostPaginateOption {
	if order == nil {
		order = DefaultShipmentEasyPostOrder
	}
	o := *order
	return func(pager *shipmenteasypostPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentEasyPostOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentEasyPostFilter configures pagination filter.
func WithShipmentEasyPostFilter(filter func(*ShipmentEasyPostQuery) (*ShipmentEasyPostQuery, error)) ShipmentEasyPostPaginateOption {
	return func(pager *shipmenteasypostPager) error {
		if filter == nil {
			return errors.New("ShipmentEasyPostQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmenteasypostPager struct {
	reverse bool
	order   *ShipmentEasyPostOrder
	filter  func(*ShipmentEasyPostQuery) (*ShipmentEasyPostQuery, error)
}

func newShipmentEasyPostPager(opts []ShipmentEasyPostPaginateOption, reverse bool) (*shipmenteasypostPager, error) {
	pager := &shipmenteasypostPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentEasyPostOrder
	}
	return pager, nil
}

func (p *shipmenteasypostPager) applyFilter(query *ShipmentEasyPostQuery) (*ShipmentEasyPostQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmenteasypostPager) toCursor(sep *ShipmentEasyPost) Cursor {
	return p.order.Field.toCursor(sep)
}

func (p *shipmenteasypostPager) applyCursors(query *ShipmentEasyPostQuery, after, before *Cursor) (*ShipmentEasyPostQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentEasyPostOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmenteasypostPager) applyOrder(query *ShipmentEasyPostQuery) *ShipmentEasyPostQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentEasyPostOrder.Field {
		query = query.Order(DefaultShipmentEasyPostOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmenteasypostPager) orderExpr(query *ShipmentEasyPostQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentEasyPostOrder.Field {
			b.Comma().Ident(DefaultShipmentEasyPostOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentEasyPost.
func (sep *ShipmentEasyPostQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentEasyPostPaginateOption,
) (*ShipmentEasyPostConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentEasyPostPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sep, err = pager.applyFilter(sep); err != nil {
		return nil, err
	}
	conn := &ShipmentEasyPostConnection{Edges: []*ShipmentEasyPostEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sep.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sep, err = pager.applyCursors(sep, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sep.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sep.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sep = pager.applyOrder(sep)
	nodes, err := sep.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentEasyPostOrderField defines the ordering field of ShipmentEasyPost.
type ShipmentEasyPostOrderField struct {
	// Value extracts the ordering value from the given ShipmentEasyPost.
	Value    func(*ShipmentEasyPost) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmenteasypost.OrderOption
	toCursor func(*ShipmentEasyPost) Cursor
}

// ShipmentEasyPostOrder defines the ordering of ShipmentEasyPost.
type ShipmentEasyPostOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ShipmentEasyPostOrderField `json:"field"`
}

// DefaultShipmentEasyPostOrder is the default ordering of ShipmentEasyPost.
var DefaultShipmentEasyPostOrder = &ShipmentEasyPostOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentEasyPostOrderField{
		Value: func(sep *ShipmentEasyPost) (ent.Value, error) {
			return sep.ID, nil
		},
		column: shipmenteasypost.FieldID,
		toTerm: shipmenteasypost.ByID,
		toCursor: func(sep *ShipmentEasyPost) Cursor {
			return Cursor{ID: sep.ID}
		},
	},
}

// ToEdge converts ShipmentEasyPost into ShipmentEasyPostEdge.
func (sep *ShipmentEasyPost) ToEdge(order *ShipmentEasyPostOrder) *ShipmentEasyPostEdge {
	if order == nil {
		order = DefaultShipmentEasyPostOrder
	}
	return &ShipmentEasyPostEdge{
		Node:   sep,
		Cursor: order.Field.toCursor(sep),
	}
}

// ShipmentGLSEdge is the edge representation of ShipmentGLS.
type ShipmentGLSEdge struct {
	Node   *ShipmentGLS `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// ShipmentGLSConnection is the connection containing edges to ShipmentGLS.
type ShipmentGLSConnection struct {
	Edges      []*ShipmentGLSEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *ShipmentGLSConnection) build(nodes []*ShipmentGLS, pager *shipmentglsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentGLS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentGLS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentGLS {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentGLSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentGLSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentGLSPaginateOption enables pagination customization.
type ShipmentGLSPaginateOption func(*shipmentglsPager) error

// WithShipmentGLSOrder configures pagination ordering.
func WithShipmentGLSOrder(order *ShipmentGLSOrder) ShipmentGLSPaginateOption {
	if order == nil {
		order = DefaultShipmentGLSOrder
	}
	o := *order
	return func(pager *shipmentglsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentGLSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentGLSFilter configures pagination filter.
func WithShipmentGLSFilter(filter func(*ShipmentGLSQuery) (*ShipmentGLSQuery, error)) ShipmentGLSPaginateOption {
	return func(pager *shipmentglsPager) error {
		if filter == nil {
			return errors.New("ShipmentGLSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentglsPager struct {
	reverse bool
	order   *ShipmentGLSOrder
	filter  func(*ShipmentGLSQuery) (*ShipmentGLSQuery, error)
}

func newShipmentGLSPager(opts []ShipmentGLSPaginateOption, reverse bool) (*shipmentglsPager, error) {
	pager := &shipmentglsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentGLSOrder
	}
	return pager, nil
}

func (p *shipmentglsPager) applyFilter(query *ShipmentGLSQuery) (*ShipmentGLSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentglsPager) toCursor(sg *ShipmentGLS) Cursor {
	return p.order.Field.toCursor(sg)
}

func (p *shipmentglsPager) applyCursors(query *ShipmentGLSQuery, after, before *Cursor) (*ShipmentGLSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentGLSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentglsPager) applyOrder(query *ShipmentGLSQuery) *ShipmentGLSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentGLSOrder.Field {
		query = query.Order(DefaultShipmentGLSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmentglsPager) orderExpr(query *ShipmentGLSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentGLSOrder.Field {
			b.Comma().Ident(DefaultShipmentGLSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentGLS.
func (sg *ShipmentGLSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentGLSPaginateOption,
) (*ShipmentGLSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentGLSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sg, err = pager.applyFilter(sg); err != nil {
		return nil, err
	}
	conn := &ShipmentGLSConnection{Edges: []*ShipmentGLSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sg.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sg, err = pager.applyCursors(sg, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sg.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sg.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sg = pager.applyOrder(sg)
	nodes, err := sg.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentGLSOrderField defines the ordering field of ShipmentGLS.
type ShipmentGLSOrderField struct {
	// Value extracts the ordering value from the given ShipmentGLS.
	Value    func(*ShipmentGLS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmentgls.OrderOption
	toCursor func(*ShipmentGLS) Cursor
}

// ShipmentGLSOrder defines the ordering of ShipmentGLS.
type ShipmentGLSOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *ShipmentGLSOrderField `json:"field"`
}

// DefaultShipmentGLSOrder is the default ordering of ShipmentGLS.
var DefaultShipmentGLSOrder = &ShipmentGLSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentGLSOrderField{
		Value: func(sg *ShipmentGLS) (ent.Value, error) {
			return sg.ID, nil
		},
		column: shipmentgls.FieldID,
		toTerm: shipmentgls.ByID,
		toCursor: func(sg *ShipmentGLS) Cursor {
			return Cursor{ID: sg.ID}
		},
	},
}

// ToEdge converts ShipmentGLS into ShipmentGLSEdge.
func (sg *ShipmentGLS) ToEdge(order *ShipmentGLSOrder) *ShipmentGLSEdge {
	if order == nil {
		order = DefaultShipmentGLSOrder
	}
	return &ShipmentGLSEdge{
		Node:   sg,
		Cursor: order.Field.toCursor(sg),
	}
}

// ShipmentHistoryEdge is the edge representation of ShipmentHistory.
type ShipmentHistoryEdge struct {
	Node   *ShipmentHistory `json:"node"`
	Cursor Cursor           `json:"cursor"`
}

// ShipmentHistoryConnection is the connection containing edges to ShipmentHistory.
type ShipmentHistoryConnection struct {
	Edges      []*ShipmentHistoryEdge `json:"edges"`
	PageInfo   PageInfo               `json:"pageInfo"`
	TotalCount int                    `json:"totalCount"`
}

func (c *ShipmentHistoryConnection) build(nodes []*ShipmentHistory, pager *shipmenthistoryPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentHistory
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentHistory {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentHistory {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentHistoryEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentHistoryEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentHistoryPaginateOption enables pagination customization.
type ShipmentHistoryPaginateOption func(*shipmenthistoryPager) error

// WithShipmentHistoryOrder configures pagination ordering.
func WithShipmentHistoryOrder(order *ShipmentHistoryOrder) ShipmentHistoryPaginateOption {
	if order == nil {
		order = DefaultShipmentHistoryOrder
	}
	o := *order
	return func(pager *shipmenthistoryPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentHistoryOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentHistoryFilter configures pagination filter.
func WithShipmentHistoryFilter(filter func(*ShipmentHistoryQuery) (*ShipmentHistoryQuery, error)) ShipmentHistoryPaginateOption {
	return func(pager *shipmenthistoryPager) error {
		if filter == nil {
			return errors.New("ShipmentHistoryQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmenthistoryPager struct {
	reverse bool
	order   *ShipmentHistoryOrder
	filter  func(*ShipmentHistoryQuery) (*ShipmentHistoryQuery, error)
}

func newShipmentHistoryPager(opts []ShipmentHistoryPaginateOption, reverse bool) (*shipmenthistoryPager, error) {
	pager := &shipmenthistoryPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentHistoryOrder
	}
	return pager, nil
}

func (p *shipmenthistoryPager) applyFilter(query *ShipmentHistoryQuery) (*ShipmentHistoryQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmenthistoryPager) toCursor(sh *ShipmentHistory) Cursor {
	return p.order.Field.toCursor(sh)
}

func (p *shipmenthistoryPager) applyCursors(query *ShipmentHistoryQuery, after, before *Cursor) (*ShipmentHistoryQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentHistoryOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmenthistoryPager) applyOrder(query *ShipmentHistoryQuery) *ShipmentHistoryQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentHistoryOrder.Field {
		query = query.Order(DefaultShipmentHistoryOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmenthistoryPager) orderExpr(query *ShipmentHistoryQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentHistoryOrder.Field {
			b.Comma().Ident(DefaultShipmentHistoryOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentHistory.
func (sh *ShipmentHistoryQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentHistoryPaginateOption,
) (*ShipmentHistoryConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentHistoryPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sh, err = pager.applyFilter(sh); err != nil {
		return nil, err
	}
	conn := &ShipmentHistoryConnection{Edges: []*ShipmentHistoryEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sh.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sh, err = pager.applyCursors(sh, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sh.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sh.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sh = pager.applyOrder(sh)
	nodes, err := sh.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentHistoryOrderField defines the ordering field of ShipmentHistory.
type ShipmentHistoryOrderField struct {
	// Value extracts the ordering value from the given ShipmentHistory.
	Value    func(*ShipmentHistory) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmenthistory.OrderOption
	toCursor func(*ShipmentHistory) Cursor
}

// ShipmentHistoryOrder defines the ordering of ShipmentHistory.
type ShipmentHistoryOrder struct {
	Direction OrderDirection             `json:"direction"`
	Field     *ShipmentHistoryOrderField `json:"field"`
}

// DefaultShipmentHistoryOrder is the default ordering of ShipmentHistory.
var DefaultShipmentHistoryOrder = &ShipmentHistoryOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentHistoryOrderField{
		Value: func(sh *ShipmentHistory) (ent.Value, error) {
			return sh.ID, nil
		},
		column: shipmenthistory.FieldID,
		toTerm: shipmenthistory.ByID,
		toCursor: func(sh *ShipmentHistory) Cursor {
			return Cursor{ID: sh.ID}
		},
	},
}

// ToEdge converts ShipmentHistory into ShipmentHistoryEdge.
func (sh *ShipmentHistory) ToEdge(order *ShipmentHistoryOrder) *ShipmentHistoryEdge {
	if order == nil {
		order = DefaultShipmentHistoryOrder
	}
	return &ShipmentHistoryEdge{
		Node:   sh,
		Cursor: order.Field.toCursor(sh),
	}
}

// ShipmentPalletEdge is the edge representation of ShipmentPallet.
type ShipmentPalletEdge struct {
	Node   *ShipmentPallet `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ShipmentPalletConnection is the connection containing edges to ShipmentPallet.
type ShipmentPalletConnection struct {
	Edges      []*ShipmentPalletEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ShipmentPalletConnection) build(nodes []*ShipmentPallet, pager *shipmentpalletPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentPallet
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentPallet {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentPallet {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentPalletEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentPalletEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentPalletPaginateOption enables pagination customization.
type ShipmentPalletPaginateOption func(*shipmentpalletPager) error

// WithShipmentPalletOrder configures pagination ordering.
func WithShipmentPalletOrder(order *ShipmentPalletOrder) ShipmentPalletPaginateOption {
	if order == nil {
		order = DefaultShipmentPalletOrder
	}
	o := *order
	return func(pager *shipmentpalletPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentPalletOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentPalletFilter configures pagination filter.
func WithShipmentPalletFilter(filter func(*ShipmentPalletQuery) (*ShipmentPalletQuery, error)) ShipmentPalletPaginateOption {
	return func(pager *shipmentpalletPager) error {
		if filter == nil {
			return errors.New("ShipmentPalletQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentpalletPager struct {
	reverse bool
	order   *ShipmentPalletOrder
	filter  func(*ShipmentPalletQuery) (*ShipmentPalletQuery, error)
}

func newShipmentPalletPager(opts []ShipmentPalletPaginateOption, reverse bool) (*shipmentpalletPager, error) {
	pager := &shipmentpalletPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentPalletOrder
	}
	return pager, nil
}

func (p *shipmentpalletPager) applyFilter(query *ShipmentPalletQuery) (*ShipmentPalletQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentpalletPager) toCursor(sp *ShipmentPallet) Cursor {
	return p.order.Field.toCursor(sp)
}

func (p *shipmentpalletPager) applyCursors(query *ShipmentPalletQuery, after, before *Cursor) (*ShipmentPalletQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentPalletOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentpalletPager) applyOrder(query *ShipmentPalletQuery) *ShipmentPalletQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentPalletOrder.Field {
		query = query.Order(DefaultShipmentPalletOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmentpalletPager) orderExpr(query *ShipmentPalletQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentPalletOrder.Field {
			b.Comma().Ident(DefaultShipmentPalletOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentPallet.
func (sp *ShipmentPalletQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentPalletPaginateOption,
) (*ShipmentPalletConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentPalletPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sp, err = pager.applyFilter(sp); err != nil {
		return nil, err
	}
	conn := &ShipmentPalletConnection{Edges: []*ShipmentPalletEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sp.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sp, err = pager.applyCursors(sp, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sp.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sp = pager.applyOrder(sp)
	nodes, err := sp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentPalletOrderField defines the ordering field of ShipmentPallet.
type ShipmentPalletOrderField struct {
	// Value extracts the ordering value from the given ShipmentPallet.
	Value    func(*ShipmentPallet) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmentpallet.OrderOption
	toCursor func(*ShipmentPallet) Cursor
}

// ShipmentPalletOrder defines the ordering of ShipmentPallet.
type ShipmentPalletOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ShipmentPalletOrderField `json:"field"`
}

// DefaultShipmentPalletOrder is the default ordering of ShipmentPallet.
var DefaultShipmentPalletOrder = &ShipmentPalletOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentPalletOrderField{
		Value: func(sp *ShipmentPallet) (ent.Value, error) {
			return sp.ID, nil
		},
		column: shipmentpallet.FieldID,
		toTerm: shipmentpallet.ByID,
		toCursor: func(sp *ShipmentPallet) Cursor {
			return Cursor{ID: sp.ID}
		},
	},
}

// ToEdge converts ShipmentPallet into ShipmentPalletEdge.
func (sp *ShipmentPallet) ToEdge(order *ShipmentPalletOrder) *ShipmentPalletEdge {
	if order == nil {
		order = DefaultShipmentPalletOrder
	}
	return &ShipmentPalletEdge{
		Node:   sp,
		Cursor: order.Field.toCursor(sp),
	}
}

// ShipmentParcelEdge is the edge representation of ShipmentParcel.
type ShipmentParcelEdge struct {
	Node   *ShipmentParcel `json:"node"`
	Cursor Cursor          `json:"cursor"`
}

// ShipmentParcelConnection is the connection containing edges to ShipmentParcel.
type ShipmentParcelConnection struct {
	Edges      []*ShipmentParcelEdge `json:"edges"`
	PageInfo   PageInfo              `json:"pageInfo"`
	TotalCount int                   `json:"totalCount"`
}

func (c *ShipmentParcelConnection) build(nodes []*ShipmentParcel, pager *shipmentparcelPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentParcel
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentParcel {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentParcel {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentParcelEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentParcelEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentParcelPaginateOption enables pagination customization.
type ShipmentParcelPaginateOption func(*shipmentparcelPager) error

// WithShipmentParcelOrder configures pagination ordering.
func WithShipmentParcelOrder(order *ShipmentParcelOrder) ShipmentParcelPaginateOption {
	if order == nil {
		order = DefaultShipmentParcelOrder
	}
	o := *order
	return func(pager *shipmentparcelPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentParcelOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentParcelFilter configures pagination filter.
func WithShipmentParcelFilter(filter func(*ShipmentParcelQuery) (*ShipmentParcelQuery, error)) ShipmentParcelPaginateOption {
	return func(pager *shipmentparcelPager) error {
		if filter == nil {
			return errors.New("ShipmentParcelQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentparcelPager struct {
	reverse bool
	order   *ShipmentParcelOrder
	filter  func(*ShipmentParcelQuery) (*ShipmentParcelQuery, error)
}

func newShipmentParcelPager(opts []ShipmentParcelPaginateOption, reverse bool) (*shipmentparcelPager, error) {
	pager := &shipmentparcelPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentParcelOrder
	}
	return pager, nil
}

func (p *shipmentparcelPager) applyFilter(query *ShipmentParcelQuery) (*ShipmentParcelQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentparcelPager) toCursor(sp *ShipmentParcel) Cursor {
	return p.order.Field.toCursor(sp)
}

func (p *shipmentparcelPager) applyCursors(query *ShipmentParcelQuery, after, before *Cursor) (*ShipmentParcelQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentParcelOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentparcelPager) applyOrder(query *ShipmentParcelQuery) *ShipmentParcelQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentParcelOrder.Field {
		query = query.Order(DefaultShipmentParcelOrder.Field.toTerm(direction.OrderTermOption()))
	}
	switch p.order.Field.column {
	case ShipmentParcelOrderFieldShipmentCreatedAt.column:
	default:
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(p.order.Field.column)
		}
	}
	return query
}

func (p *shipmentparcelPager) orderExpr(query *ShipmentParcelQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	switch p.order.Field.column {
	case ShipmentParcelOrderFieldShipmentCreatedAt.column:
		query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	default:
		if len(query.ctx.Fields) > 0 {
			query.ctx.AppendFieldOnce(p.order.Field.column)
		}
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentParcelOrder.Field {
			b.Comma().Ident(DefaultShipmentParcelOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentParcel.
func (sp *ShipmentParcelQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentParcelPaginateOption,
) (*ShipmentParcelConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentParcelPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if sp, err = pager.applyFilter(sp); err != nil {
		return nil, err
	}
	conn := &ShipmentParcelConnection{Edges: []*ShipmentParcelEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := sp.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if sp, err = pager.applyCursors(sp, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		sp.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := sp.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	sp = pager.applyOrder(sp)
	nodes, err := sp.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

var (
	// ShipmentParcelOrderFieldExpectedAt orders ShipmentParcel by expected_at.
	ShipmentParcelOrderFieldExpectedAt = &ShipmentParcelOrderField{
		Value: func(sp *ShipmentParcel) (ent.Value, error) {
			return sp.ExpectedAt, nil
		},
		column: shipmentparcel.FieldExpectedAt,
		toTerm: shipmentparcel.ByExpectedAt,
		toCursor: func(sp *ShipmentParcel) Cursor {
			return Cursor{
				ID:    sp.ID,
				Value: sp.ExpectedAt,
			}
		},
	}
	// ShipmentParcelOrderFieldCancelSyncedAt orders ShipmentParcel by cancel_synced_at.
	ShipmentParcelOrderFieldCancelSyncedAt = &ShipmentParcelOrderField{
		Value: func(sp *ShipmentParcel) (ent.Value, error) {
			return sp.CancelSyncedAt, nil
		},
		column: shipmentparcel.FieldCancelSyncedAt,
		toTerm: shipmentparcel.ByCancelSyncedAt,
		toCursor: func(sp *ShipmentParcel) Cursor {
			return Cursor{
				ID:    sp.ID,
				Value: sp.CancelSyncedAt,
			}
		},
	}
	// ShipmentParcelOrderFieldShipmentCreatedAt orders by SHIPMENT_CREATED_AT.
	ShipmentParcelOrderFieldShipmentCreatedAt = &ShipmentParcelOrderField{
		Value: func(sp *ShipmentParcel) (ent.Value, error) {
			return sp.Value("shipment_created_at")
		},
		column: "shipment_created_at",
		toTerm: func(opts ...sql.OrderTermOption) shipmentparcel.OrderOption {
			return shipmentparcel.ByShipmentField(
				shipment.FieldCreatedAt,
				append(opts, sql.OrderSelectAs("shipment_created_at"))...,
			)
		},
		toCursor: func(sp *ShipmentParcel) Cursor {
			cv, _ := sp.Value("shipment_created_at")
			return Cursor{
				ID:    sp.ID,
				Value: cv,
			}
		},
	}
)

// String implement fmt.Stringer interface.
func (f ShipmentParcelOrderField) String() string {
	var str string
	switch f.column {
	case ShipmentParcelOrderFieldExpectedAt.column:
		str = "EXPECTED_AT"
	case ShipmentParcelOrderFieldCancelSyncedAt.column:
		str = "CANCEL_SYNCED_AT"
	case ShipmentParcelOrderFieldShipmentCreatedAt.column:
		str = "SHIPMENT_CREATED_AT"
	}
	return str
}

// MarshalGQL implements graphql.Marshaler interface.
func (f ShipmentParcelOrderField) MarshalGQL(w io.Writer) {
	io.WriteString(w, strconv.Quote(f.String()))
}

// UnmarshalGQL implements graphql.Unmarshaler interface.
func (f *ShipmentParcelOrderField) UnmarshalGQL(v interface{}) error {
	str, ok := v.(string)
	if !ok {
		return fmt.Errorf("ShipmentParcelOrderField %T must be a string", v)
	}
	switch str {
	case "EXPECTED_AT":
		*f = *ShipmentParcelOrderFieldExpectedAt
	case "CANCEL_SYNCED_AT":
		*f = *ShipmentParcelOrderFieldCancelSyncedAt
	case "SHIPMENT_CREATED_AT":
		*f = *ShipmentParcelOrderFieldShipmentCreatedAt
	default:
		return fmt.Errorf("%s is not a valid ShipmentParcelOrderField", str)
	}
	return nil
}

// ShipmentParcelOrderField defines the ordering field of ShipmentParcel.
type ShipmentParcelOrderField struct {
	// Value extracts the ordering value from the given ShipmentParcel.
	Value    func(*ShipmentParcel) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmentparcel.OrderOption
	toCursor func(*ShipmentParcel) Cursor
}

// ShipmentParcelOrder defines the ordering of ShipmentParcel.
type ShipmentParcelOrder struct {
	Direction OrderDirection            `json:"direction"`
	Field     *ShipmentParcelOrderField `json:"field"`
}

// DefaultShipmentParcelOrder is the default ordering of ShipmentParcel.
var DefaultShipmentParcelOrder = &ShipmentParcelOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentParcelOrderField{
		Value: func(sp *ShipmentParcel) (ent.Value, error) {
			return sp.ID, nil
		},
		column: shipmentparcel.FieldID,
		toTerm: shipmentparcel.ByID,
		toCursor: func(sp *ShipmentParcel) Cursor {
			return Cursor{ID: sp.ID}
		},
	},
}

// ToEdge converts ShipmentParcel into ShipmentParcelEdge.
func (sp *ShipmentParcel) ToEdge(order *ShipmentParcelOrder) *ShipmentParcelEdge {
	if order == nil {
		order = DefaultShipmentParcelOrder
	}
	return &ShipmentParcelEdge{
		Node:   sp,
		Cursor: order.Field.toCursor(sp),
	}
}

// ShipmentPostNordEdge is the edge representation of ShipmentPostNord.
type ShipmentPostNordEdge struct {
	Node   *ShipmentPostNord `json:"node"`
	Cursor Cursor            `json:"cursor"`
}

// ShipmentPostNordConnection is the connection containing edges to ShipmentPostNord.
type ShipmentPostNordConnection struct {
	Edges      []*ShipmentPostNordEdge `json:"edges"`
	PageInfo   PageInfo                `json:"pageInfo"`
	TotalCount int                     `json:"totalCount"`
}

func (c *ShipmentPostNordConnection) build(nodes []*ShipmentPostNord, pager *shipmentpostnordPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentPostNord
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentPostNord {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentPostNord {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentPostNordEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentPostNordEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentPostNordPaginateOption enables pagination customization.
type ShipmentPostNordPaginateOption func(*shipmentpostnordPager) error

// WithShipmentPostNordOrder configures pagination ordering.
func WithShipmentPostNordOrder(order *ShipmentPostNordOrder) ShipmentPostNordPaginateOption {
	if order == nil {
		order = DefaultShipmentPostNordOrder
	}
	o := *order
	return func(pager *shipmentpostnordPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentPostNordOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentPostNordFilter configures pagination filter.
func WithShipmentPostNordFilter(filter func(*ShipmentPostNordQuery) (*ShipmentPostNordQuery, error)) ShipmentPostNordPaginateOption {
	return func(pager *shipmentpostnordPager) error {
		if filter == nil {
			return errors.New("ShipmentPostNordQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentpostnordPager struct {
	reverse bool
	order   *ShipmentPostNordOrder
	filter  func(*ShipmentPostNordQuery) (*ShipmentPostNordQuery, error)
}

func newShipmentPostNordPager(opts []ShipmentPostNordPaginateOption, reverse bool) (*shipmentpostnordPager, error) {
	pager := &shipmentpostnordPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentPostNordOrder
	}
	return pager, nil
}

func (p *shipmentpostnordPager) applyFilter(query *ShipmentPostNordQuery) (*ShipmentPostNordQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentpostnordPager) toCursor(spn *ShipmentPostNord) Cursor {
	return p.order.Field.toCursor(spn)
}

func (p *shipmentpostnordPager) applyCursors(query *ShipmentPostNordQuery, after, before *Cursor) (*ShipmentPostNordQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentPostNordOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentpostnordPager) applyOrder(query *ShipmentPostNordQuery) *ShipmentPostNordQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentPostNordOrder.Field {
		query = query.Order(DefaultShipmentPostNordOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmentpostnordPager) orderExpr(query *ShipmentPostNordQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentPostNordOrder.Field {
			b.Comma().Ident(DefaultShipmentPostNordOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentPostNord.
func (spn *ShipmentPostNordQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentPostNordPaginateOption,
) (*ShipmentPostNordConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentPostNordPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if spn, err = pager.applyFilter(spn); err != nil {
		return nil, err
	}
	conn := &ShipmentPostNordConnection{Edges: []*ShipmentPostNordEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := spn.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if spn, err = pager.applyCursors(spn, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		spn.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := spn.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	spn = pager.applyOrder(spn)
	nodes, err := spn.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentPostNordOrderField defines the ordering field of ShipmentPostNord.
type ShipmentPostNordOrderField struct {
	// Value extracts the ordering value from the given ShipmentPostNord.
	Value    func(*ShipmentPostNord) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmentpostnord.OrderOption
	toCursor func(*ShipmentPostNord) Cursor
}

// ShipmentPostNordOrder defines the ordering of ShipmentPostNord.
type ShipmentPostNordOrder struct {
	Direction OrderDirection              `json:"direction"`
	Field     *ShipmentPostNordOrderField `json:"field"`
}

// DefaultShipmentPostNordOrder is the default ordering of ShipmentPostNord.
var DefaultShipmentPostNordOrder = &ShipmentPostNordOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentPostNordOrderField{
		Value: func(spn *ShipmentPostNord) (ent.Value, error) {
			return spn.ID, nil
		},
		column: shipmentpostnord.FieldID,
		toTerm: shipmentpostnord.ByID,
		toCursor: func(spn *ShipmentPostNord) Cursor {
			return Cursor{ID: spn.ID}
		},
	},
}

// ToEdge converts ShipmentPostNord into ShipmentPostNordEdge.
func (spn *ShipmentPostNord) ToEdge(order *ShipmentPostNordOrder) *ShipmentPostNordEdge {
	if order == nil {
		order = DefaultShipmentPostNordOrder
	}
	return &ShipmentPostNordEdge{
		Node:   spn,
		Cursor: order.Field.toCursor(spn),
	}
}

// ShipmentUSPSEdge is the edge representation of ShipmentUSPS.
type ShipmentUSPSEdge struct {
	Node   *ShipmentUSPS `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// ShipmentUSPSConnection is the connection containing edges to ShipmentUSPS.
type ShipmentUSPSConnection struct {
	Edges      []*ShipmentUSPSEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *ShipmentUSPSConnection) build(nodes []*ShipmentUSPS, pager *shipmentuspsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *ShipmentUSPS
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *ShipmentUSPS {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *ShipmentUSPS {
			return nodes[i]
		}
	}
	c.Edges = make([]*ShipmentUSPSEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &ShipmentUSPSEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// ShipmentUSPSPaginateOption enables pagination customization.
type ShipmentUSPSPaginateOption func(*shipmentuspsPager) error

// WithShipmentUSPSOrder configures pagination ordering.
func WithShipmentUSPSOrder(order *ShipmentUSPSOrder) ShipmentUSPSPaginateOption {
	if order == nil {
		order = DefaultShipmentUSPSOrder
	}
	o := *order
	return func(pager *shipmentuspsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultShipmentUSPSOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithShipmentUSPSFilter configures pagination filter.
func WithShipmentUSPSFilter(filter func(*ShipmentUSPSQuery) (*ShipmentUSPSQuery, error)) ShipmentUSPSPaginateOption {
	return func(pager *shipmentuspsPager) error {
		if filter == nil {
			return errors.New("ShipmentUSPSQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type shipmentuspsPager struct {
	reverse bool
	order   *ShipmentUSPSOrder
	filter  func(*ShipmentUSPSQuery) (*ShipmentUSPSQuery, error)
}

func newShipmentUSPSPager(opts []ShipmentUSPSPaginateOption, reverse bool) (*shipmentuspsPager, error) {
	pager := &shipmentuspsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultShipmentUSPSOrder
	}
	return pager, nil
}

func (p *shipmentuspsPager) applyFilter(query *ShipmentUSPSQuery) (*ShipmentUSPSQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *shipmentuspsPager) toCursor(su *ShipmentUSPS) Cursor {
	return p.order.Field.toCursor(su)
}

func (p *shipmentuspsPager) applyCursors(query *ShipmentUSPSQuery, after, before *Cursor) (*ShipmentUSPSQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultShipmentUSPSOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *shipmentuspsPager) applyOrder(query *ShipmentUSPSQuery) *ShipmentUSPSQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultShipmentUSPSOrder.Field {
		query = query.Order(DefaultShipmentUSPSOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *shipmentuspsPager) orderExpr(query *ShipmentUSPSQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultShipmentUSPSOrder.Field {
			b.Comma().Ident(DefaultShipmentUSPSOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to ShipmentUSPS.
func (su *ShipmentUSPSQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...ShipmentUSPSPaginateOption,
) (*ShipmentUSPSConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newShipmentUSPSPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if su, err = pager.applyFilter(su); err != nil {
		return nil, err
	}
	conn := &ShipmentUSPSConnection{Edges: []*ShipmentUSPSEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := su.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if su, err = pager.applyCursors(su, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		su.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := su.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	su = pager.applyOrder(su)
	nodes, err := su.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// ShipmentUSPSOrderField defines the ordering field of ShipmentUSPS.
type ShipmentUSPSOrderField struct {
	// Value extracts the ordering value from the given ShipmentUSPS.
	Value    func(*ShipmentUSPS) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) shipmentusps.OrderOption
	toCursor func(*ShipmentUSPS) Cursor
}

// ShipmentUSPSOrder defines the ordering of ShipmentUSPS.
type ShipmentUSPSOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *ShipmentUSPSOrderField `json:"field"`
}

// DefaultShipmentUSPSOrder is the default ordering of ShipmentUSPS.
var DefaultShipmentUSPSOrder = &ShipmentUSPSOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &ShipmentUSPSOrderField{
		Value: func(su *ShipmentUSPS) (ent.Value, error) {
			return su.ID, nil
		},
		column: shipmentusps.FieldID,
		toTerm: shipmentusps.ByID,
		toCursor: func(su *ShipmentUSPS) Cursor {
			return Cursor{ID: su.ID}
		},
	},
}

// ToEdge converts ShipmentUSPS into ShipmentUSPSEdge.
func (su *ShipmentUSPS) ToEdge(order *ShipmentUSPSOrder) *ShipmentUSPSEdge {
	if order == nil {
		order = DefaultShipmentUSPSOrder
	}
	return &ShipmentUSPSEdge{
		Node:   su,
		Cursor: order.Field.toCursor(su),
	}
}

// SignupOptionsEdge is the edge representation of SignupOptions.
type SignupOptionsEdge struct {
	Node   *SignupOptions `json:"node"`
	Cursor Cursor         `json:"cursor"`
}

// SignupOptionsConnection is the connection containing edges to SignupOptions.
type SignupOptionsConnection struct {
	Edges      []*SignupOptionsEdge `json:"edges"`
	PageInfo   PageInfo             `json:"pageInfo"`
	TotalCount int                  `json:"totalCount"`
}

func (c *SignupOptionsConnection) build(nodes []*SignupOptions, pager *signupoptionsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SignupOptions
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SignupOptions {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SignupOptions {
			return nodes[i]
		}
	}
	c.Edges = make([]*SignupOptionsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SignupOptionsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SignupOptionsPaginateOption enables pagination customization.
type SignupOptionsPaginateOption func(*signupoptionsPager) error

// WithSignupOptionsOrder configures pagination ordering.
func WithSignupOptionsOrder(order *SignupOptionsOrder) SignupOptionsPaginateOption {
	if order == nil {
		order = DefaultSignupOptionsOrder
	}
	o := *order
	return func(pager *signupoptionsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSignupOptionsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSignupOptionsFilter configures pagination filter.
func WithSignupOptionsFilter(filter func(*SignupOptionsQuery) (*SignupOptionsQuery, error)) SignupOptionsPaginateOption {
	return func(pager *signupoptionsPager) error {
		if filter == nil {
			return errors.New("SignupOptionsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type signupoptionsPager struct {
	reverse bool
	order   *SignupOptionsOrder
	filter  func(*SignupOptionsQuery) (*SignupOptionsQuery, error)
}

func newSignupOptionsPager(opts []SignupOptionsPaginateOption, reverse bool) (*signupoptionsPager, error) {
	pager := &signupoptionsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSignupOptionsOrder
	}
	return pager, nil
}

func (p *signupoptionsPager) applyFilter(query *SignupOptionsQuery) (*SignupOptionsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *signupoptionsPager) toCursor(so *SignupOptions) Cursor {
	return p.order.Field.toCursor(so)
}

func (p *signupoptionsPager) applyCursors(query *SignupOptionsQuery, after, before *Cursor) (*SignupOptionsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSignupOptionsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *signupoptionsPager) applyOrder(query *SignupOptionsQuery) *SignupOptionsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSignupOptionsOrder.Field {
		query = query.Order(DefaultSignupOptionsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *signupoptionsPager) orderExpr(query *SignupOptionsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSignupOptionsOrder.Field {
			b.Comma().Ident(DefaultSignupOptionsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SignupOptions.
func (so *SignupOptionsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SignupOptionsPaginateOption,
) (*SignupOptionsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSignupOptionsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if so, err = pager.applyFilter(so); err != nil {
		return nil, err
	}
	conn := &SignupOptionsConnection{Edges: []*SignupOptionsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := so.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if so, err = pager.applyCursors(so, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		so.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := so.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	so = pager.applyOrder(so)
	nodes, err := so.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SignupOptionsOrderField defines the ordering field of SignupOptions.
type SignupOptionsOrderField struct {
	// Value extracts the ordering value from the given SignupOptions.
	Value    func(*SignupOptions) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) signupoptions.OrderOption
	toCursor func(*SignupOptions) Cursor
}

// SignupOptionsOrder defines the ordering of SignupOptions.
type SignupOptionsOrder struct {
	Direction OrderDirection           `json:"direction"`
	Field     *SignupOptionsOrderField `json:"field"`
}

// DefaultSignupOptionsOrder is the default ordering of SignupOptions.
var DefaultSignupOptionsOrder = &SignupOptionsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SignupOptionsOrderField{
		Value: func(so *SignupOptions) (ent.Value, error) {
			return so.ID, nil
		},
		column: signupoptions.FieldID,
		toTerm: signupoptions.ByID,
		toCursor: func(so *SignupOptions) Cursor {
			return Cursor{ID: so.ID}
		},
	},
}

// ToEdge converts SignupOptions into SignupOptionsEdge.
func (so *SignupOptions) ToEdge(order *SignupOptionsOrder) *SignupOptionsEdge {
	if order == nil {
		order = DefaultSignupOptionsOrder
	}
	return &SignupOptionsEdge{
		Node:   so,
		Cursor: order.Field.toCursor(so),
	}
}

// SystemEventsEdge is the edge representation of SystemEvents.
type SystemEventsEdge struct {
	Node   *SystemEvents `json:"node"`
	Cursor Cursor        `json:"cursor"`
}

// SystemEventsConnection is the connection containing edges to SystemEvents.
type SystemEventsConnection struct {
	Edges      []*SystemEventsEdge `json:"edges"`
	PageInfo   PageInfo            `json:"pageInfo"`
	TotalCount int                 `json:"totalCount"`
}

func (c *SystemEventsConnection) build(nodes []*SystemEvents, pager *systemeventsPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *SystemEvents
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *SystemEvents {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *SystemEvents {
			return nodes[i]
		}
	}
	c.Edges = make([]*SystemEventsEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &SystemEventsEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// SystemEventsPaginateOption enables pagination customization.
type SystemEventsPaginateOption func(*systemeventsPager) error

// WithSystemEventsOrder configures pagination ordering.
func WithSystemEventsOrder(order *SystemEventsOrder) SystemEventsPaginateOption {
	if order == nil {
		order = DefaultSystemEventsOrder
	}
	o := *order
	return func(pager *systemeventsPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultSystemEventsOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithSystemEventsFilter configures pagination filter.
func WithSystemEventsFilter(filter func(*SystemEventsQuery) (*SystemEventsQuery, error)) SystemEventsPaginateOption {
	return func(pager *systemeventsPager) error {
		if filter == nil {
			return errors.New("SystemEventsQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type systemeventsPager struct {
	reverse bool
	order   *SystemEventsOrder
	filter  func(*SystemEventsQuery) (*SystemEventsQuery, error)
}

func newSystemEventsPager(opts []SystemEventsPaginateOption, reverse bool) (*systemeventsPager, error) {
	pager := &systemeventsPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultSystemEventsOrder
	}
	return pager, nil
}

func (p *systemeventsPager) applyFilter(query *SystemEventsQuery) (*SystemEventsQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *systemeventsPager) toCursor(se *SystemEvents) Cursor {
	return p.order.Field.toCursor(se)
}

func (p *systemeventsPager) applyCursors(query *SystemEventsQuery, after, before *Cursor) (*SystemEventsQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultSystemEventsOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *systemeventsPager) applyOrder(query *SystemEventsQuery) *SystemEventsQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultSystemEventsOrder.Field {
		query = query.Order(DefaultSystemEventsOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *systemeventsPager) orderExpr(query *SystemEventsQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultSystemEventsOrder.Field {
			b.Comma().Ident(DefaultSystemEventsOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to SystemEvents.
func (se *SystemEventsQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...SystemEventsPaginateOption,
) (*SystemEventsConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newSystemEventsPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if se, err = pager.applyFilter(se); err != nil {
		return nil, err
	}
	conn := &SystemEventsConnection{Edges: []*SystemEventsEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := se.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if se, err = pager.applyCursors(se, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		se.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := se.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	se = pager.applyOrder(se)
	nodes, err := se.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// SystemEventsOrderField defines the ordering field of SystemEvents.
type SystemEventsOrderField struct {
	// Value extracts the ordering value from the given SystemEvents.
	Value    func(*SystemEvents) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) systemevents.OrderOption
	toCursor func(*SystemEvents) Cursor
}

// SystemEventsOrder defines the ordering of SystemEvents.
type SystemEventsOrder struct {
	Direction OrderDirection          `json:"direction"`
	Field     *SystemEventsOrderField `json:"field"`
}

// DefaultSystemEventsOrder is the default ordering of SystemEvents.
var DefaultSystemEventsOrder = &SystemEventsOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &SystemEventsOrderField{
		Value: func(se *SystemEvents) (ent.Value, error) {
			return se.ID, nil
		},
		column: systemevents.FieldID,
		toTerm: systemevents.ByID,
		toCursor: func(se *SystemEvents) Cursor {
			return Cursor{ID: se.ID}
		},
	},
}

// ToEdge converts SystemEvents into SystemEventsEdge.
func (se *SystemEvents) ToEdge(order *SystemEventsOrder) *SystemEventsEdge {
	if order == nil {
		order = DefaultSystemEventsOrder
	}
	return &SystemEventsEdge{
		Node:   se,
		Cursor: order.Field.toCursor(se),
	}
}

// TenantEdge is the edge representation of Tenant.
type TenantEdge struct {
	Node   *Tenant `json:"node"`
	Cursor Cursor  `json:"cursor"`
}

// TenantConnection is the connection containing edges to Tenant.
type TenantConnection struct {
	Edges      []*TenantEdge `json:"edges"`
	PageInfo   PageInfo      `json:"pageInfo"`
	TotalCount int           `json:"totalCount"`
}

func (c *TenantConnection) build(nodes []*Tenant, pager *tenantPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Tenant
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Tenant {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Tenant {
			return nodes[i]
		}
	}
	c.Edges = make([]*TenantEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &TenantEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// TenantPaginateOption enables pagination customization.
type TenantPaginateOption func(*tenantPager) error

// WithTenantOrder configures pagination ordering.
func WithTenantOrder(order *TenantOrder) TenantPaginateOption {
	if order == nil {
		order = DefaultTenantOrder
	}
	o := *order
	return func(pager *tenantPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultTenantOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithTenantFilter configures pagination filter.
func WithTenantFilter(filter func(*TenantQuery) (*TenantQuery, error)) TenantPaginateOption {
	return func(pager *tenantPager) error {
		if filter == nil {
			return errors.New("TenantQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type tenantPager struct {
	reverse bool
	order   *TenantOrder
	filter  func(*TenantQuery) (*TenantQuery, error)
}

func newTenantPager(opts []TenantPaginateOption, reverse bool) (*tenantPager, error) {
	pager := &tenantPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultTenantOrder
	}
	return pager, nil
}

func (p *tenantPager) applyFilter(query *TenantQuery) (*TenantQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *tenantPager) toCursor(t *Tenant) Cursor {
	return p.order.Field.toCursor(t)
}

func (p *tenantPager) applyCursors(query *TenantQuery, after, before *Cursor) (*TenantQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultTenantOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *tenantPager) applyOrder(query *TenantQuery) *TenantQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultTenantOrder.Field {
		query = query.Order(DefaultTenantOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *tenantPager) orderExpr(query *TenantQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultTenantOrder.Field {
			b.Comma().Ident(DefaultTenantOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Tenant.
func (t *TenantQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...TenantPaginateOption,
) (*TenantConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newTenantPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if t, err = pager.applyFilter(t); err != nil {
		return nil, err
	}
	conn := &TenantConnection{Edges: []*TenantEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := t.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if t, err = pager.applyCursors(t, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		t.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := t.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	t = pager.applyOrder(t)
	nodes, err := t.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// TenantOrderField defines the ordering field of Tenant.
type TenantOrderField struct {
	// Value extracts the ordering value from the given Tenant.
	Value    func(*Tenant) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) tenant.OrderOption
	toCursor func(*Tenant) Cursor
}

// TenantOrder defines the ordering of Tenant.
type TenantOrder struct {
	Direction OrderDirection    `json:"direction"`
	Field     *TenantOrderField `json:"field"`
}

// DefaultTenantOrder is the default ordering of Tenant.
var DefaultTenantOrder = &TenantOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &TenantOrderField{
		Value: func(t *Tenant) (ent.Value, error) {
			return t.ID, nil
		},
		column: tenant.FieldID,
		toTerm: tenant.ByID,
		toCursor: func(t *Tenant) Cursor {
			return Cursor{ID: t.ID}
		},
	},
}

// ToEdge converts Tenant into TenantEdge.
func (t *Tenant) ToEdge(order *TenantOrder) *TenantEdge {
	if order == nil {
		order = DefaultTenantOrder
	}
	return &TenantEdge{
		Node:   t,
		Cursor: order.Field.toCursor(t),
	}
}

// UserEdge is the edge representation of User.
type UserEdge struct {
	Node   *User  `json:"node"`
	Cursor Cursor `json:"cursor"`
}

// UserConnection is the connection containing edges to User.
type UserConnection struct {
	Edges      []*UserEdge `json:"edges"`
	PageInfo   PageInfo    `json:"pageInfo"`
	TotalCount int         `json:"totalCount"`
}

func (c *UserConnection) build(nodes []*User, pager *userPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *User
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *User {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *User {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserPaginateOption enables pagination customization.
type UserPaginateOption func(*userPager) error

// WithUserOrder configures pagination ordering.
func WithUserOrder(order *UserOrder) UserPaginateOption {
	if order == nil {
		order = DefaultUserOrder
	}
	o := *order
	return func(pager *userPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserFilter configures pagination filter.
func WithUserFilter(filter func(*UserQuery) (*UserQuery, error)) UserPaginateOption {
	return func(pager *userPager) error {
		if filter == nil {
			return errors.New("UserQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userPager struct {
	reverse bool
	order   *UserOrder
	filter  func(*UserQuery) (*UserQuery, error)
}

func newUserPager(opts []UserPaginateOption, reverse bool) (*userPager, error) {
	pager := &userPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserOrder
	}
	return pager, nil
}

func (p *userPager) applyFilter(query *UserQuery) (*UserQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userPager) toCursor(u *User) Cursor {
	return p.order.Field.toCursor(u)
}

func (p *userPager) applyCursors(query *UserQuery, after, before *Cursor) (*UserQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userPager) applyOrder(query *UserQuery) *UserQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserOrder.Field {
		query = query.Order(DefaultUserOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userPager) orderExpr(query *UserQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserOrder.Field {
			b.Comma().Ident(DefaultUserOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to User.
func (u *UserQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserPaginateOption,
) (*UserConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if u, err = pager.applyFilter(u); err != nil {
		return nil, err
	}
	conn := &UserConnection{Edges: []*UserEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := u.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if u, err = pager.applyCursors(u, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		u.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := u.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	u = pager.applyOrder(u)
	nodes, err := u.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserOrderField defines the ordering field of User.
type UserOrderField struct {
	// Value extracts the ordering value from the given User.
	Value    func(*User) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) user.OrderOption
	toCursor func(*User) Cursor
}

// UserOrder defines the ordering of User.
type UserOrder struct {
	Direction OrderDirection  `json:"direction"`
	Field     *UserOrderField `json:"field"`
}

// DefaultUserOrder is the default ordering of User.
var DefaultUserOrder = &UserOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserOrderField{
		Value: func(u *User) (ent.Value, error) {
			return u.ID, nil
		},
		column: user.FieldID,
		toTerm: user.ByID,
		toCursor: func(u *User) Cursor {
			return Cursor{ID: u.ID}
		},
	},
}

// ToEdge converts User into UserEdge.
func (u *User) ToEdge(order *UserOrder) *UserEdge {
	if order == nil {
		order = DefaultUserOrder
	}
	return &UserEdge{
		Node:   u,
		Cursor: order.Field.toCursor(u),
	}
}

// UserSeatEdge is the edge representation of UserSeat.
type UserSeatEdge struct {
	Node   *UserSeat `json:"node"`
	Cursor Cursor    `json:"cursor"`
}

// UserSeatConnection is the connection containing edges to UserSeat.
type UserSeatConnection struct {
	Edges      []*UserSeatEdge `json:"edges"`
	PageInfo   PageInfo        `json:"pageInfo"`
	TotalCount int             `json:"totalCount"`
}

func (c *UserSeatConnection) build(nodes []*UserSeat, pager *userseatPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *UserSeat
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *UserSeat {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *UserSeat {
			return nodes[i]
		}
	}
	c.Edges = make([]*UserSeatEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &UserSeatEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// UserSeatPaginateOption enables pagination customization.
type UserSeatPaginateOption func(*userseatPager) error

// WithUserSeatOrder configures pagination ordering.
func WithUserSeatOrder(order *UserSeatOrder) UserSeatPaginateOption {
	if order == nil {
		order = DefaultUserSeatOrder
	}
	o := *order
	return func(pager *userseatPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultUserSeatOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithUserSeatFilter configures pagination filter.
func WithUserSeatFilter(filter func(*UserSeatQuery) (*UserSeatQuery, error)) UserSeatPaginateOption {
	return func(pager *userseatPager) error {
		if filter == nil {
			return errors.New("UserSeatQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type userseatPager struct {
	reverse bool
	order   *UserSeatOrder
	filter  func(*UserSeatQuery) (*UserSeatQuery, error)
}

func newUserSeatPager(opts []UserSeatPaginateOption, reverse bool) (*userseatPager, error) {
	pager := &userseatPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultUserSeatOrder
	}
	return pager, nil
}

func (p *userseatPager) applyFilter(query *UserSeatQuery) (*UserSeatQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *userseatPager) toCursor(us *UserSeat) Cursor {
	return p.order.Field.toCursor(us)
}

func (p *userseatPager) applyCursors(query *UserSeatQuery, after, before *Cursor) (*UserSeatQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultUserSeatOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *userseatPager) applyOrder(query *UserSeatQuery) *UserSeatQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultUserSeatOrder.Field {
		query = query.Order(DefaultUserSeatOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *userseatPager) orderExpr(query *UserSeatQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultUserSeatOrder.Field {
			b.Comma().Ident(DefaultUserSeatOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to UserSeat.
func (us *UserSeatQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...UserSeatPaginateOption,
) (*UserSeatConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newUserSeatPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if us, err = pager.applyFilter(us); err != nil {
		return nil, err
	}
	conn := &UserSeatConnection{Edges: []*UserSeatEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := us.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if us, err = pager.applyCursors(us, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		us.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := us.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	us = pager.applyOrder(us)
	nodes, err := us.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// UserSeatOrderField defines the ordering field of UserSeat.
type UserSeatOrderField struct {
	// Value extracts the ordering value from the given UserSeat.
	Value    func(*UserSeat) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) userseat.OrderOption
	toCursor func(*UserSeat) Cursor
}

// UserSeatOrder defines the ordering of UserSeat.
type UserSeatOrder struct {
	Direction OrderDirection      `json:"direction"`
	Field     *UserSeatOrderField `json:"field"`
}

// DefaultUserSeatOrder is the default ordering of UserSeat.
var DefaultUserSeatOrder = &UserSeatOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &UserSeatOrderField{
		Value: func(us *UserSeat) (ent.Value, error) {
			return us.ID, nil
		},
		column: userseat.FieldID,
		toTerm: userseat.ByID,
		toCursor: func(us *UserSeat) Cursor {
			return Cursor{ID: us.ID}
		},
	},
}

// ToEdge converts UserSeat into UserSeatEdge.
func (us *UserSeat) ToEdge(order *UserSeatOrder) *UserSeatEdge {
	if order == nil {
		order = DefaultUserSeatOrder
	}
	return &UserSeatEdge{
		Node:   us,
		Cursor: order.Field.toCursor(us),
	}
}

// WorkspaceRecentScanEdge is the edge representation of WorkspaceRecentScan.
type WorkspaceRecentScanEdge struct {
	Node   *WorkspaceRecentScan `json:"node"`
	Cursor Cursor               `json:"cursor"`
}

// WorkspaceRecentScanConnection is the connection containing edges to WorkspaceRecentScan.
type WorkspaceRecentScanConnection struct {
	Edges      []*WorkspaceRecentScanEdge `json:"edges"`
	PageInfo   PageInfo                   `json:"pageInfo"`
	TotalCount int                        `json:"totalCount"`
}

func (c *WorkspaceRecentScanConnection) build(nodes []*WorkspaceRecentScan, pager *workspacerecentscanPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *WorkspaceRecentScan
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *WorkspaceRecentScan {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *WorkspaceRecentScan {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkspaceRecentScanEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkspaceRecentScanEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkspaceRecentScanPaginateOption enables pagination customization.
type WorkspaceRecentScanPaginateOption func(*workspacerecentscanPager) error

// WithWorkspaceRecentScanOrder configures pagination ordering.
func WithWorkspaceRecentScanOrder(order *WorkspaceRecentScanOrder) WorkspaceRecentScanPaginateOption {
	if order == nil {
		order = DefaultWorkspaceRecentScanOrder
	}
	o := *order
	return func(pager *workspacerecentscanPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkspaceRecentScanOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkspaceRecentScanFilter configures pagination filter.
func WithWorkspaceRecentScanFilter(filter func(*WorkspaceRecentScanQuery) (*WorkspaceRecentScanQuery, error)) WorkspaceRecentScanPaginateOption {
	return func(pager *workspacerecentscanPager) error {
		if filter == nil {
			return errors.New("WorkspaceRecentScanQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workspacerecentscanPager struct {
	reverse bool
	order   *WorkspaceRecentScanOrder
	filter  func(*WorkspaceRecentScanQuery) (*WorkspaceRecentScanQuery, error)
}

func newWorkspaceRecentScanPager(opts []WorkspaceRecentScanPaginateOption, reverse bool) (*workspacerecentscanPager, error) {
	pager := &workspacerecentscanPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkspaceRecentScanOrder
	}
	return pager, nil
}

func (p *workspacerecentscanPager) applyFilter(query *WorkspaceRecentScanQuery) (*WorkspaceRecentScanQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workspacerecentscanPager) toCursor(wrs *WorkspaceRecentScan) Cursor {
	return p.order.Field.toCursor(wrs)
}

func (p *workspacerecentscanPager) applyCursors(query *WorkspaceRecentScanQuery, after, before *Cursor) (*WorkspaceRecentScanQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkspaceRecentScanOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workspacerecentscanPager) applyOrder(query *WorkspaceRecentScanQuery) *WorkspaceRecentScanQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkspaceRecentScanOrder.Field {
		query = query.Order(DefaultWorkspaceRecentScanOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workspacerecentscanPager) orderExpr(query *WorkspaceRecentScanQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkspaceRecentScanOrder.Field {
			b.Comma().Ident(DefaultWorkspaceRecentScanOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to WorkspaceRecentScan.
func (wrs *WorkspaceRecentScanQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkspaceRecentScanPaginateOption,
) (*WorkspaceRecentScanConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkspaceRecentScanPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if wrs, err = pager.applyFilter(wrs); err != nil {
		return nil, err
	}
	conn := &WorkspaceRecentScanConnection{Edges: []*WorkspaceRecentScanEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := wrs.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if wrs, err = pager.applyCursors(wrs, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		wrs.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := wrs.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	wrs = pager.applyOrder(wrs)
	nodes, err := wrs.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WorkspaceRecentScanOrderField defines the ordering field of WorkspaceRecentScan.
type WorkspaceRecentScanOrderField struct {
	// Value extracts the ordering value from the given WorkspaceRecentScan.
	Value    func(*WorkspaceRecentScan) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workspacerecentscan.OrderOption
	toCursor func(*WorkspaceRecentScan) Cursor
}

// WorkspaceRecentScanOrder defines the ordering of WorkspaceRecentScan.
type WorkspaceRecentScanOrder struct {
	Direction OrderDirection                 `json:"direction"`
	Field     *WorkspaceRecentScanOrderField `json:"field"`
}

// DefaultWorkspaceRecentScanOrder is the default ordering of WorkspaceRecentScan.
var DefaultWorkspaceRecentScanOrder = &WorkspaceRecentScanOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkspaceRecentScanOrderField{
		Value: func(wrs *WorkspaceRecentScan) (ent.Value, error) {
			return wrs.ID, nil
		},
		column: workspacerecentscan.FieldID,
		toTerm: workspacerecentscan.ByID,
		toCursor: func(wrs *WorkspaceRecentScan) Cursor {
			return Cursor{ID: wrs.ID}
		},
	},
}

// ToEdge converts WorkspaceRecentScan into WorkspaceRecentScanEdge.
func (wrs *WorkspaceRecentScan) ToEdge(order *WorkspaceRecentScanOrder) *WorkspaceRecentScanEdge {
	if order == nil {
		order = DefaultWorkspaceRecentScanOrder
	}
	return &WorkspaceRecentScanEdge{
		Node:   wrs,
		Cursor: order.Field.toCursor(wrs),
	}
}

// WorkstationEdge is the edge representation of Workstation.
type WorkstationEdge struct {
	Node   *Workstation `json:"node"`
	Cursor Cursor       `json:"cursor"`
}

// WorkstationConnection is the connection containing edges to Workstation.
type WorkstationConnection struct {
	Edges      []*WorkstationEdge `json:"edges"`
	PageInfo   PageInfo           `json:"pageInfo"`
	TotalCount int                `json:"totalCount"`
}

func (c *WorkstationConnection) build(nodes []*Workstation, pager *workstationPager, after *Cursor, first *int, before *Cursor, last *int) {
	c.PageInfo.HasNextPage = before != nil
	c.PageInfo.HasPreviousPage = after != nil
	if first != nil && *first+1 == len(nodes) {
		c.PageInfo.HasNextPage = true
		nodes = nodes[:len(nodes)-1]
	} else if last != nil && *last+1 == len(nodes) {
		c.PageInfo.HasPreviousPage = true
		nodes = nodes[:len(nodes)-1]
	}
	var nodeAt func(int) *Workstation
	if last != nil {
		n := len(nodes) - 1
		nodeAt = func(i int) *Workstation {
			return nodes[n-i]
		}
	} else {
		nodeAt = func(i int) *Workstation {
			return nodes[i]
		}
	}
	c.Edges = make([]*WorkstationEdge, len(nodes))
	for i := range nodes {
		node := nodeAt(i)
		c.Edges[i] = &WorkstationEdge{
			Node:   node,
			Cursor: pager.toCursor(node),
		}
	}
	if l := len(c.Edges); l > 0 {
		c.PageInfo.StartCursor = &c.Edges[0].Cursor
		c.PageInfo.EndCursor = &c.Edges[l-1].Cursor
	}
	if c.TotalCount == 0 {
		c.TotalCount = len(nodes)
	}
}

// WorkstationPaginateOption enables pagination customization.
type WorkstationPaginateOption func(*workstationPager) error

// WithWorkstationOrder configures pagination ordering.
func WithWorkstationOrder(order *WorkstationOrder) WorkstationPaginateOption {
	if order == nil {
		order = DefaultWorkstationOrder
	}
	o := *order
	return func(pager *workstationPager) error {
		if err := o.Direction.Validate(); err != nil {
			return err
		}
		if o.Field == nil {
			o.Field = DefaultWorkstationOrder.Field
		}
		pager.order = &o
		return nil
	}
}

// WithWorkstationFilter configures pagination filter.
func WithWorkstationFilter(filter func(*WorkstationQuery) (*WorkstationQuery, error)) WorkstationPaginateOption {
	return func(pager *workstationPager) error {
		if filter == nil {
			return errors.New("WorkstationQuery filter cannot be nil")
		}
		pager.filter = filter
		return nil
	}
}

type workstationPager struct {
	reverse bool
	order   *WorkstationOrder
	filter  func(*WorkstationQuery) (*WorkstationQuery, error)
}

func newWorkstationPager(opts []WorkstationPaginateOption, reverse bool) (*workstationPager, error) {
	pager := &workstationPager{reverse: reverse}
	for _, opt := range opts {
		if err := opt(pager); err != nil {
			return nil, err
		}
	}
	if pager.order == nil {
		pager.order = DefaultWorkstationOrder
	}
	return pager, nil
}

func (p *workstationPager) applyFilter(query *WorkstationQuery) (*WorkstationQuery, error) {
	if p.filter != nil {
		return p.filter(query)
	}
	return query, nil
}

func (p *workstationPager) toCursor(w *Workstation) Cursor {
	return p.order.Field.toCursor(w)
}

func (p *workstationPager) applyCursors(query *WorkstationQuery, after, before *Cursor) (*WorkstationQuery, error) {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	for _, predicate := range entgql.CursorsPredicate(after, before, DefaultWorkstationOrder.Field.column, p.order.Field.column, direction) {
		query = query.Where(predicate)
	}
	return query, nil
}

func (p *workstationPager) applyOrder(query *WorkstationQuery) *WorkstationQuery {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	query = query.Order(p.order.Field.toTerm(direction.OrderTermOption()))
	if p.order.Field != DefaultWorkstationOrder.Field {
		query = query.Order(DefaultWorkstationOrder.Field.toTerm(direction.OrderTermOption()))
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return query
}

func (p *workstationPager) orderExpr(query *WorkstationQuery) sql.Querier {
	direction := p.order.Direction
	if p.reverse {
		direction = direction.Reverse()
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(p.order.Field.column)
	}
	return sql.ExprFunc(func(b *sql.Builder) {
		b.Ident(p.order.Field.column).Pad().WriteString(string(direction))
		if p.order.Field != DefaultWorkstationOrder.Field {
			b.Comma().Ident(DefaultWorkstationOrder.Field.column).Pad().WriteString(string(direction))
		}
	})
}

// Paginate executes the query and returns a relay based cursor connection to Workstation.
func (w *WorkstationQuery) Paginate(
	ctx context.Context, after *Cursor, first *int,
	before *Cursor, last *int, opts ...WorkstationPaginateOption,
) (*WorkstationConnection, error) {
	if err := validateFirstLast(first, last); err != nil {
		return nil, err
	}
	pager, err := newWorkstationPager(opts, last != nil)
	if err != nil {
		return nil, err
	}
	if w, err = pager.applyFilter(w); err != nil {
		return nil, err
	}
	conn := &WorkstationConnection{Edges: []*WorkstationEdge{}}
	ignoredEdges := !hasCollectedField(ctx, edgesField)
	if hasCollectedField(ctx, totalCountField) || hasCollectedField(ctx, pageInfoField) {
		hasPagination := after != nil || first != nil || before != nil || last != nil
		if hasPagination || ignoredEdges {
			c := w.Clone()
			c.ctx.Fields = nil
			if conn.TotalCount, err = c.Count(ctx); err != nil {
				return nil, err
			}
			conn.PageInfo.HasNextPage = first != nil && conn.TotalCount > 0
			conn.PageInfo.HasPreviousPage = last != nil && conn.TotalCount > 0
		}
	}
	if ignoredEdges || (first != nil && *first == 0) || (last != nil && *last == 0) {
		return conn, nil
	}
	if w, err = pager.applyCursors(w, after, before); err != nil {
		return nil, err
	}
	limit := paginateLimit(first, last)
	if limit != 0 {
		w.Limit(limit)
	}
	if field := collectedField(ctx, edgesField, nodeField); field != nil {
		if err := w.collectField(ctx, limit == 1, graphql.GetOperationContext(ctx), *field, []string{edgesField, nodeField}); err != nil {
			return nil, err
		}
	}
	w = pager.applyOrder(w)
	nodes, err := w.All(ctx)
	if err != nil {
		return nil, err
	}
	conn.build(nodes, pager, after, first, before, last)
	return conn, nil
}

// WorkstationOrderField defines the ordering field of Workstation.
type WorkstationOrderField struct {
	// Value extracts the ordering value from the given Workstation.
	Value    func(*Workstation) (ent.Value, error)
	column   string // field or computed.
	toTerm   func(...sql.OrderTermOption) workstation.OrderOption
	toCursor func(*Workstation) Cursor
}

// WorkstationOrder defines the ordering of Workstation.
type WorkstationOrder struct {
	Direction OrderDirection         `json:"direction"`
	Field     *WorkstationOrderField `json:"field"`
}

// DefaultWorkstationOrder is the default ordering of Workstation.
var DefaultWorkstationOrder = &WorkstationOrder{
	Direction: entgql.OrderDirectionAsc,
	Field: &WorkstationOrderField{
		Value: func(w *Workstation) (ent.Value, error) {
			return w.ID, nil
		},
		column: workstation.FieldID,
		toTerm: workstation.ByID,
		toCursor: func(w *Workstation) Cursor {
			return Cursor{ID: w.ID}
		},
	},
}

// ToEdge converts Workstation into WorkstationEdge.
func (w *Workstation) ToEdge(order *WorkstationOrder) *WorkstationEdge {
	if order == nil {
		order = DefaultWorkstationOrder
	}
	return &WorkstationEdge{
		Node:   w,
		Cursor: order.Field.toCursor(w),
	}
}
