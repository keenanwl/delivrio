// Code generated by ent, DO NOT EDIT.

package ent

import (
	"encoding/json"
	"fmt"
	"strings"
	"time"

	"delivrio.io/go/ent/connection"
	"delivrio.io/go/ent/consolidation"
	"delivrio.io/go/ent/hypothesistestdeliveryoptionrequest"
	"delivrio.io/go/ent/order"
	"delivrio.io/go/ent/pallet"
	"delivrio.io/go/ent/tenant"
	"delivrio.io/go/schema/fieldjson"
	"delivrio.io/shared-utils/pulid"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Order is the model entity for the Order schema.
type Order struct {
	config `json:"-"`
	// ID of the ent.
	ID pulid.ID `json:"id,omitempty"`
	// TenantID holds the value of the "tenant_id" field.
	TenantID pulid.ID `json:"tenant_id,omitempty"`
	// OrderPublicID holds the value of the "order_public_id" field.
	OrderPublicID string `json:"order_public_id,omitempty"`
	// ExternalID holds the value of the "external_id" field.
	ExternalID string `json:"external_id,omitempty"`
	// CommentInternal holds the value of the "comment_internal" field.
	CommentInternal string `json:"comment_internal,omitempty"`
	// CommentExternal holds the value of the "comment_external" field.
	CommentExternal string `json:"comment_external,omitempty"`
	// CreatedAt holds the value of the "created_at" field.
	CreatedAt time.Time `json:"created_at,omitempty"`
	// EmailSyncConfirmationAt holds the value of the "email_sync_confirmation_at" field.
	EmailSyncConfirmationAt time.Time `json:"email_sync_confirmation_at,omitempty"`
	// Status holds the value of the "status" field.
	Status order.Status `json:"status,omitempty"`
	// NoteAttributes holds the value of the "note_attributes" field.
	NoteAttributes fieldjson.NoteAttributes `json:"note_attributes,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the OrderQuery when eager-loading is set.
	Edges                                         OrderEdges `json:"edges"`
	connection_orders                             *pulid.ID
	consolidation_orders                          *pulid.ID
	hypothesis_test_delivery_option_request_order *pulid.ID
	pallet_orders                                 *pulid.ID
	selectValues                                  sql.SelectValues
}

// OrderEdges holds the relations/edges for other nodes in the graph.
type OrderEdges struct {
	// Tenant holds the value of the tenant edge.
	Tenant *Tenant `json:"tenant,omitempty"`
	// OrderHistory holds the value of the order_history edge.
	OrderHistory []*OrderHistory `json:"order_history,omitempty"`
	// Connection holds the value of the connection edge.
	Connection *Connection `json:"connection,omitempty"`
	// Colli holds the value of the colli edge.
	Colli []*Colli `json:"colli,omitempty"`
	// ReturnColli holds the value of the return_colli edge.
	ReturnColli []*ReturnColli `json:"return_colli,omitempty"`
	// HypothesisTestDeliveryOptionRequest holds the value of the hypothesis_test_delivery_option_request edge.
	HypothesisTestDeliveryOptionRequest *HypothesisTestDeliveryOptionRequest `json:"hypothesis_test_delivery_option_request,omitempty"`
	// Orders may be added to consolidation either through a pallet or directly
	Pallet *Pallet `json:"pallet,omitempty"`
	// Orders may be added to consolidation either through a pallet or directly
	Consolidation *Consolidation `json:"consolidation,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [8]bool
	// totalCount holds the count of the edges above.
	totalCount [8]map[string]int

	namedOrderHistory map[string][]*OrderHistory
	namedColli        map[string][]*Colli
	namedReturnColli  map[string][]*ReturnColli
}

// TenantOrErr returns the Tenant value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e OrderEdges) TenantOrErr() (*Tenant, error) {
	if e.Tenant != nil {
		return e.Tenant, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: tenant.Label}
	}
	return nil, &NotLoadedError{edge: "tenant"}
}

// OrderHistoryOrErr returns the OrderHistory value or an error if the edge
// was not loaded in eager-loading.
func (e OrderEdges) OrderHistoryOrErr() ([]*OrderHistory, error) {
	if e.loadedTypes[1] {
		return e.OrderHistory, nil
	}
	return nil, &NotLoadedError{edge: "order_history"}
}

// ConnectionOrErr returns the Connection value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e OrderEdges) ConnectionOrErr() (*Connection, error) {
	if e.Connection != nil {
		return e.Connection, nil
	} else if e.loadedTypes[2] {
		return nil, &NotFoundError{label: connection.Label}
	}
	return nil, &NotLoadedError{edge: "connection"}
}

// ColliOrErr returns the Colli value or an error if the edge
// was not loaded in eager-loading.
func (e OrderEdges) ColliOrErr() ([]*Colli, error) {
	if e.loadedTypes[3] {
		return e.Colli, nil
	}
	return nil, &NotLoadedError{edge: "colli"}
}

// ReturnColliOrErr returns the ReturnColli value or an error if the edge
// was not loaded in eager-loading.
func (e OrderEdges) ReturnColliOrErr() ([]*ReturnColli, error) {
	if e.loadedTypes[4] {
		return e.ReturnColli, nil
	}
	return nil, &NotLoadedError{edge: "return_colli"}
}

// HypothesisTestDeliveryOptionRequestOrErr returns the HypothesisTestDeliveryOptionRequest value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e OrderEdges) HypothesisTestDeliveryOptionRequestOrErr() (*HypothesisTestDeliveryOptionRequest, error) {
	if e.HypothesisTestDeliveryOptionRequest != nil {
		return e.HypothesisTestDeliveryOptionRequest, nil
	} else if e.loadedTypes[5] {
		return nil, &NotFoundError{label: hypothesistestdeliveryoptionrequest.Label}
	}
	return nil, &NotLoadedError{edge: "hypothesis_test_delivery_option_request"}
}

// PalletOrErr returns the Pallet value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e OrderEdges) PalletOrErr() (*Pallet, error) {
	if e.Pallet != nil {
		return e.Pallet, nil
	} else if e.loadedTypes[6] {
		return nil, &NotFoundError{label: pallet.Label}
	}
	return nil, &NotLoadedError{edge: "pallet"}
}

// ConsolidationOrErr returns the Consolidation value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e OrderEdges) ConsolidationOrErr() (*Consolidation, error) {
	if e.Consolidation != nil {
		return e.Consolidation, nil
	} else if e.loadedTypes[7] {
		return nil, &NotFoundError{label: consolidation.Label}
	}
	return nil, &NotLoadedError{edge: "consolidation"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Order) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case order.FieldNoteAttributes:
			values[i] = new([]byte)
		case order.FieldID, order.FieldTenantID:
			values[i] = new(pulid.ID)
		case order.FieldOrderPublicID, order.FieldExternalID, order.FieldCommentInternal, order.FieldCommentExternal, order.FieldStatus:
			values[i] = new(sql.NullString)
		case order.FieldCreatedAt, order.FieldEmailSyncConfirmationAt:
			values[i] = new(sql.NullTime)
		case order.ForeignKeys[0]: // connection_orders
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		case order.ForeignKeys[1]: // consolidation_orders
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		case order.ForeignKeys[2]: // hypothesis_test_delivery_option_request_order
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		case order.ForeignKeys[3]: // pallet_orders
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Order fields.
func (o *Order) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case order.FieldID:
			if value, ok := values[i].(*pulid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				o.ID = *value
			}
		case order.FieldTenantID:
			if value, ok := values[i].(*pulid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value != nil {
				o.TenantID = *value
			}
		case order.FieldOrderPublicID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field order_public_id", values[i])
			} else if value.Valid {
				o.OrderPublicID = value.String
			}
		case order.FieldExternalID:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field external_id", values[i])
			} else if value.Valid {
				o.ExternalID = value.String
			}
		case order.FieldCommentInternal:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field comment_internal", values[i])
			} else if value.Valid {
				o.CommentInternal = value.String
			}
		case order.FieldCommentExternal:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field comment_external", values[i])
			} else if value.Valid {
				o.CommentExternal = value.String
			}
		case order.FieldCreatedAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field created_at", values[i])
			} else if value.Valid {
				o.CreatedAt = value.Time
			}
		case order.FieldEmailSyncConfirmationAt:
			if value, ok := values[i].(*sql.NullTime); !ok {
				return fmt.Errorf("unexpected type %T for field email_sync_confirmation_at", values[i])
			} else if value.Valid {
				o.EmailSyncConfirmationAt = value.Time
			}
		case order.FieldStatus:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field status", values[i])
			} else if value.Valid {
				o.Status = order.Status(value.String)
			}
		case order.FieldNoteAttributes:
			if value, ok := values[i].(*[]byte); !ok {
				return fmt.Errorf("unexpected type %T for field note_attributes", values[i])
			} else if value != nil && len(*value) > 0 {
				if err := json.Unmarshal(*value, &o.NoteAttributes); err != nil {
					return fmt.Errorf("unmarshal field note_attributes: %w", err)
				}
			}
		case order.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field connection_orders", values[i])
			} else if value.Valid {
				o.connection_orders = new(pulid.ID)
				*o.connection_orders = *value.S.(*pulid.ID)
			}
		case order.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field consolidation_orders", values[i])
			} else if value.Valid {
				o.consolidation_orders = new(pulid.ID)
				*o.consolidation_orders = *value.S.(*pulid.ID)
			}
		case order.ForeignKeys[2]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field hypothesis_test_delivery_option_request_order", values[i])
			} else if value.Valid {
				o.hypothesis_test_delivery_option_request_order = new(pulid.ID)
				*o.hypothesis_test_delivery_option_request_order = *value.S.(*pulid.ID)
			}
		case order.ForeignKeys[3]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field pallet_orders", values[i])
			} else if value.Valid {
				o.pallet_orders = new(pulid.ID)
				*o.pallet_orders = *value.S.(*pulid.ID)
			}
		default:
			o.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Order.
// This includes values selected through modifiers, order, etc.
func (o *Order) Value(name string) (ent.Value, error) {
	return o.selectValues.Get(name)
}

// QueryTenant queries the "tenant" edge of the Order entity.
func (o *Order) QueryTenant() *TenantQuery {
	return NewOrderClient(o.config).QueryTenant(o)
}

// QueryOrderHistory queries the "order_history" edge of the Order entity.
func (o *Order) QueryOrderHistory() *OrderHistoryQuery {
	return NewOrderClient(o.config).QueryOrderHistory(o)
}

// QueryConnection queries the "connection" edge of the Order entity.
func (o *Order) QueryConnection() *ConnectionQuery {
	return NewOrderClient(o.config).QueryConnection(o)
}

// QueryColli queries the "colli" edge of the Order entity.
func (o *Order) QueryColli() *ColliQuery {
	return NewOrderClient(o.config).QueryColli(o)
}

// QueryReturnColli queries the "return_colli" edge of the Order entity.
func (o *Order) QueryReturnColli() *ReturnColliQuery {
	return NewOrderClient(o.config).QueryReturnColli(o)
}

// QueryHypothesisTestDeliveryOptionRequest queries the "hypothesis_test_delivery_option_request" edge of the Order entity.
func (o *Order) QueryHypothesisTestDeliveryOptionRequest() *HypothesisTestDeliveryOptionRequestQuery {
	return NewOrderClient(o.config).QueryHypothesisTestDeliveryOptionRequest(o)
}

// QueryPallet queries the "pallet" edge of the Order entity.
func (o *Order) QueryPallet() *PalletQuery {
	return NewOrderClient(o.config).QueryPallet(o)
}

// QueryConsolidation queries the "consolidation" edge of the Order entity.
func (o *Order) QueryConsolidation() *ConsolidationQuery {
	return NewOrderClient(o.config).QueryConsolidation(o)
}

// Update returns a builder for updating this Order.
// Note that you need to call Order.Unwrap() before calling this method if this Order
// was returned from a transaction, and the transaction was committed or rolled back.
func (o *Order) Update() *OrderUpdateOne {
	return NewOrderClient(o.config).UpdateOne(o)
}

// Unwrap unwraps the Order entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (o *Order) Unwrap() *Order {
	_tx, ok := o.config.driver.(*txDriver)
	if !ok {
		panic("ent: Order is not a transactional entity")
	}
	o.config.driver = _tx.drv
	return o
}

// String implements the fmt.Stringer.
func (o *Order) String() string {
	var builder strings.Builder
	builder.WriteString("Order(")
	builder.WriteString(fmt.Sprintf("id=%v, ", o.ID))
	builder.WriteString("tenant_id=")
	builder.WriteString(fmt.Sprintf("%v", o.TenantID))
	builder.WriteString(", ")
	builder.WriteString("order_public_id=")
	builder.WriteString(o.OrderPublicID)
	builder.WriteString(", ")
	builder.WriteString("external_id=")
	builder.WriteString(o.ExternalID)
	builder.WriteString(", ")
	builder.WriteString("comment_internal=")
	builder.WriteString(o.CommentInternal)
	builder.WriteString(", ")
	builder.WriteString("comment_external=")
	builder.WriteString(o.CommentExternal)
	builder.WriteString(", ")
	builder.WriteString("created_at=")
	builder.WriteString(o.CreatedAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("email_sync_confirmation_at=")
	builder.WriteString(o.EmailSyncConfirmationAt.Format(time.ANSIC))
	builder.WriteString(", ")
	builder.WriteString("status=")
	builder.WriteString(fmt.Sprintf("%v", o.Status))
	builder.WriteString(", ")
	builder.WriteString("note_attributes=")
	builder.WriteString(fmt.Sprintf("%v", o.NoteAttributes))
	builder.WriteByte(')')
	return builder.String()
}

// NamedOrderHistory returns the OrderHistory named value or an error if the edge was not
// loaded in eager-loading with this name.
func (o *Order) NamedOrderHistory(name string) ([]*OrderHistory, error) {
	if o.Edges.namedOrderHistory == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := o.Edges.namedOrderHistory[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (o *Order) appendNamedOrderHistory(name string, edges ...*OrderHistory) {
	if o.Edges.namedOrderHistory == nil {
		o.Edges.namedOrderHistory = make(map[string][]*OrderHistory)
	}
	if len(edges) == 0 {
		o.Edges.namedOrderHistory[name] = []*OrderHistory{}
	} else {
		o.Edges.namedOrderHistory[name] = append(o.Edges.namedOrderHistory[name], edges...)
	}
}

// NamedColli returns the Colli named value or an error if the edge was not
// loaded in eager-loading with this name.
func (o *Order) NamedColli(name string) ([]*Colli, error) {
	if o.Edges.namedColli == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := o.Edges.namedColli[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (o *Order) appendNamedColli(name string, edges ...*Colli) {
	if o.Edges.namedColli == nil {
		o.Edges.namedColli = make(map[string][]*Colli)
	}
	if len(edges) == 0 {
		o.Edges.namedColli[name] = []*Colli{}
	} else {
		o.Edges.namedColli[name] = append(o.Edges.namedColli[name], edges...)
	}
}

// NamedReturnColli returns the ReturnColli named value or an error if the edge was not
// loaded in eager-loading with this name.
func (o *Order) NamedReturnColli(name string) ([]*ReturnColli, error) {
	if o.Edges.namedReturnColli == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := o.Edges.namedReturnColli[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (o *Order) appendNamedReturnColli(name string, edges ...*ReturnColli) {
	if o.Edges.namedReturnColli == nil {
		o.Edges.namedReturnColli = make(map[string][]*ReturnColli)
	}
	if len(edges) == 0 {
		o.Edges.namedReturnColli[name] = []*ReturnColli{}
	} else {
		o.Edges.namedReturnColli[name] = append(o.Edges.namedReturnColli[name], edges...)
	}
}

// Orders is a parsable slice of Order.
type Orders []*Order
