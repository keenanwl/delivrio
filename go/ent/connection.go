// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"delivrio.io/go/ent/connection"
	"delivrio.io/go/ent/connectionbrand"
	"delivrio.io/go/ent/connectionshopify"
	"delivrio.io/go/ent/currency"
	"delivrio.io/go/ent/deliveryoption"
	"delivrio.io/go/ent/document"
	"delivrio.io/go/ent/location"
	"delivrio.io/go/ent/returnportal"
	"delivrio.io/go/ent/tenant"
	"delivrio.io/shared-utils/pulid"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Connection is the model entity for the Connection schema.
type Connection struct {
	config `json:"-"`
	// ID of the ent.
	ID pulid.ID `json:"id,omitempty"`
	// TenantID holds the value of the "tenant_id" field.
	TenantID pulid.ID `json:"tenant_id,omitempty"`
	// Name holds the value of the "name" field.
	Name string `json:"name,omitempty"`
	// SyncOrders holds the value of the "sync_orders" field.
	SyncOrders bool `json:"sync_orders,omitempty"`
	// SyncProducts holds the value of the "sync_products" field.
	SyncProducts bool `json:"sync_products,omitempty"`
	// FulfillAutomatically holds the value of the "fulfill_automatically" field.
	FulfillAutomatically bool `json:"fulfill_automatically,omitempty"`
	// DispatchAutomatically holds the value of the "dispatch_automatically" field.
	DispatchAutomatically bool `json:"dispatch_automatically,omitempty"`
	// ConvertCurrency holds the value of the "convert_currency" field.
	ConvertCurrency bool `json:"convert_currency,omitempty"`
	// AutoPrintParcelSlip holds the value of the "auto_print_parcel_slip" field.
	AutoPrintParcelSlip bool `json:"auto_print_parcel_slip,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the ConnectionQuery when eager-loading is set.
	Edges                            ConnectionEdges `json:"edges"`
	connection_connection_brand      *pulid.ID
	connection_sender_location       *pulid.ID
	connection_pickup_location       *pulid.ID
	connection_return_location       *pulid.ID
	connection_seller_location       *pulid.ID
	connection_currency              *pulid.ID
	connection_packing_slip_template *pulid.ID
	return_portal_connection         *pulid.ID
	selectValues                     sql.SelectValues
}

// ConnectionEdges holds the relations/edges for other nodes in the graph.
type ConnectionEdges struct {
	// Tenant holds the value of the tenant edge.
	Tenant *Tenant `json:"tenant,omitempty"`
	// ConnectionBrand holds the value of the connection_brand edge.
	ConnectionBrand *ConnectionBrand `json:"connection_brand,omitempty"`
	// ConnectionShopify holds the value of the connection_shopify edge.
	ConnectionShopify *ConnectionShopify `json:"connection_shopify,omitempty"`
	// Orders holds the value of the orders edge.
	Orders []*Order `json:"orders,omitempty"`
	// SenderLocation holds the value of the sender_location edge.
	SenderLocation *Location `json:"sender_location,omitempty"`
	// PickupLocation holds the value of the pickup_location edge.
	PickupLocation *Location `json:"pickup_location,omitempty"`
	// ReturnLocation holds the value of the return_location edge.
	ReturnLocation *Location `json:"return_location,omitempty"`
	// SellerLocation holds the value of the seller_location edge.
	SellerLocation *Location `json:"seller_location,omitempty"`
	// DeliveryOption holds the value of the delivery_option edge.
	DeliveryOption []*DeliveryOption `json:"delivery_option,omitempty"`
	// Delivery option to be set when none specified via sync or API
	DefaultDeliveryOption *DeliveryOption `json:"default_delivery_option,omitempty"`
	// ReturnPortal holds the value of the return_portal edge.
	ReturnPortal *ReturnPortal `json:"return_portal,omitempty"`
	// HypothesisTest holds the value of the hypothesis_test edge.
	HypothesisTest []*HypothesisTest `json:"hypothesis_test,omitempty"`
	// Notifications holds the value of the notifications edge.
	Notifications []*Notification `json:"notifications,omitempty"`
	// Currency holds the value of the currency edge.
	Currency *Currency `json:"currency,omitempty"`
	// PackingSlipTemplate holds the value of the packing_slip_template edge.
	PackingSlipTemplate *Document `json:"packing_slip_template,omitempty"`
	// ConnectionLookup holds the value of the connection_lookup edge.
	ConnectionLookup []*ConnectionLookup `json:"connection_lookup,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [16]bool
	// totalCount holds the count of the edges above.
	totalCount [16]map[string]int

	namedOrders           map[string][]*Order
	namedDeliveryOption   map[string][]*DeliveryOption
	namedHypothesisTest   map[string][]*HypothesisTest
	namedNotifications    map[string][]*Notification
	namedConnectionLookup map[string][]*ConnectionLookup
}

// TenantOrErr returns the Tenant value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) TenantOrErr() (*Tenant, error) {
	if e.Tenant != nil {
		return e.Tenant, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: tenant.Label}
	}
	return nil, &NotLoadedError{edge: "tenant"}
}

// ConnectionBrandOrErr returns the ConnectionBrand value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) ConnectionBrandOrErr() (*ConnectionBrand, error) {
	if e.ConnectionBrand != nil {
		return e.ConnectionBrand, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: connectionbrand.Label}
	}
	return nil, &NotLoadedError{edge: "connection_brand"}
}

// ConnectionShopifyOrErr returns the ConnectionShopify value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) ConnectionShopifyOrErr() (*ConnectionShopify, error) {
	if e.ConnectionShopify != nil {
		return e.ConnectionShopify, nil
	} else if e.loadedTypes[2] {
		return nil, &NotFoundError{label: connectionshopify.Label}
	}
	return nil, &NotLoadedError{edge: "connection_shopify"}
}

// OrdersOrErr returns the Orders value or an error if the edge
// was not loaded in eager-loading.
func (e ConnectionEdges) OrdersOrErr() ([]*Order, error) {
	if e.loadedTypes[3] {
		return e.Orders, nil
	}
	return nil, &NotLoadedError{edge: "orders"}
}

// SenderLocationOrErr returns the SenderLocation value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) SenderLocationOrErr() (*Location, error) {
	if e.SenderLocation != nil {
		return e.SenderLocation, nil
	} else if e.loadedTypes[4] {
		return nil, &NotFoundError{label: location.Label}
	}
	return nil, &NotLoadedError{edge: "sender_location"}
}

// PickupLocationOrErr returns the PickupLocation value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) PickupLocationOrErr() (*Location, error) {
	if e.PickupLocation != nil {
		return e.PickupLocation, nil
	} else if e.loadedTypes[5] {
		return nil, &NotFoundError{label: location.Label}
	}
	return nil, &NotLoadedError{edge: "pickup_location"}
}

// ReturnLocationOrErr returns the ReturnLocation value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) ReturnLocationOrErr() (*Location, error) {
	if e.ReturnLocation != nil {
		return e.ReturnLocation, nil
	} else if e.loadedTypes[6] {
		return nil, &NotFoundError{label: location.Label}
	}
	return nil, &NotLoadedError{edge: "return_location"}
}

// SellerLocationOrErr returns the SellerLocation value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) SellerLocationOrErr() (*Location, error) {
	if e.SellerLocation != nil {
		return e.SellerLocation, nil
	} else if e.loadedTypes[7] {
		return nil, &NotFoundError{label: location.Label}
	}
	return nil, &NotLoadedError{edge: "seller_location"}
}

// DeliveryOptionOrErr returns the DeliveryOption value or an error if the edge
// was not loaded in eager-loading.
func (e ConnectionEdges) DeliveryOptionOrErr() ([]*DeliveryOption, error) {
	if e.loadedTypes[8] {
		return e.DeliveryOption, nil
	}
	return nil, &NotLoadedError{edge: "delivery_option"}
}

// DefaultDeliveryOptionOrErr returns the DefaultDeliveryOption value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) DefaultDeliveryOptionOrErr() (*DeliveryOption, error) {
	if e.DefaultDeliveryOption != nil {
		return e.DefaultDeliveryOption, nil
	} else if e.loadedTypes[9] {
		return nil, &NotFoundError{label: deliveryoption.Label}
	}
	return nil, &NotLoadedError{edge: "default_delivery_option"}
}

// ReturnPortalOrErr returns the ReturnPortal value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) ReturnPortalOrErr() (*ReturnPortal, error) {
	if e.ReturnPortal != nil {
		return e.ReturnPortal, nil
	} else if e.loadedTypes[10] {
		return nil, &NotFoundError{label: returnportal.Label}
	}
	return nil, &NotLoadedError{edge: "return_portal"}
}

// HypothesisTestOrErr returns the HypothesisTest value or an error if the edge
// was not loaded in eager-loading.
func (e ConnectionEdges) HypothesisTestOrErr() ([]*HypothesisTest, error) {
	if e.loadedTypes[11] {
		return e.HypothesisTest, nil
	}
	return nil, &NotLoadedError{edge: "hypothesis_test"}
}

// NotificationsOrErr returns the Notifications value or an error if the edge
// was not loaded in eager-loading.
func (e ConnectionEdges) NotificationsOrErr() ([]*Notification, error) {
	if e.loadedTypes[12] {
		return e.Notifications, nil
	}
	return nil, &NotLoadedError{edge: "notifications"}
}

// CurrencyOrErr returns the Currency value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) CurrencyOrErr() (*Currency, error) {
	if e.Currency != nil {
		return e.Currency, nil
	} else if e.loadedTypes[13] {
		return nil, &NotFoundError{label: currency.Label}
	}
	return nil, &NotLoadedError{edge: "currency"}
}

// PackingSlipTemplateOrErr returns the PackingSlipTemplate value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e ConnectionEdges) PackingSlipTemplateOrErr() (*Document, error) {
	if e.PackingSlipTemplate != nil {
		return e.PackingSlipTemplate, nil
	} else if e.loadedTypes[14] {
		return nil, &NotFoundError{label: document.Label}
	}
	return nil, &NotLoadedError{edge: "packing_slip_template"}
}

// ConnectionLookupOrErr returns the ConnectionLookup value or an error if the edge
// was not loaded in eager-loading.
func (e ConnectionEdges) ConnectionLookupOrErr() ([]*ConnectionLookup, error) {
	if e.loadedTypes[15] {
		return e.ConnectionLookup, nil
	}
	return nil, &NotLoadedError{edge: "connection_lookup"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Connection) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case connection.FieldID, connection.FieldTenantID:
			values[i] = new(pulid.ID)
		case connection.FieldSyncOrders, connection.FieldSyncProducts, connection.FieldFulfillAutomatically, connection.FieldDispatchAutomatically, connection.FieldConvertCurrency, connection.FieldAutoPrintParcelSlip:
			values[i] = new(sql.NullBool)
		case connection.FieldName:
			values[i] = new(sql.NullString)
		case connection.ForeignKeys[0]: // connection_connection_brand
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		case connection.ForeignKeys[1]: // connection_sender_location
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		case connection.ForeignKeys[2]: // connection_pickup_location
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		case connection.ForeignKeys[3]: // connection_return_location
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		case connection.ForeignKeys[4]: // connection_seller_location
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		case connection.ForeignKeys[5]: // connection_currency
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		case connection.ForeignKeys[6]: // connection_packing_slip_template
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		case connection.ForeignKeys[7]: // return_portal_connection
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Connection fields.
func (c *Connection) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case connection.FieldID:
			if value, ok := values[i].(*pulid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				c.ID = *value
			}
		case connection.FieldTenantID:
			if value, ok := values[i].(*pulid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value != nil {
				c.TenantID = *value
			}
		case connection.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				c.Name = value.String
			}
		case connection.FieldSyncOrders:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field sync_orders", values[i])
			} else if value.Valid {
				c.SyncOrders = value.Bool
			}
		case connection.FieldSyncProducts:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field sync_products", values[i])
			} else if value.Valid {
				c.SyncProducts = value.Bool
			}
		case connection.FieldFulfillAutomatically:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field fulfill_automatically", values[i])
			} else if value.Valid {
				c.FulfillAutomatically = value.Bool
			}
		case connection.FieldDispatchAutomatically:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field dispatch_automatically", values[i])
			} else if value.Valid {
				c.DispatchAutomatically = value.Bool
			}
		case connection.FieldConvertCurrency:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field convert_currency", values[i])
			} else if value.Valid {
				c.ConvertCurrency = value.Bool
			}
		case connection.FieldAutoPrintParcelSlip:
			if value, ok := values[i].(*sql.NullBool); !ok {
				return fmt.Errorf("unexpected type %T for field auto_print_parcel_slip", values[i])
			} else if value.Valid {
				c.AutoPrintParcelSlip = value.Bool
			}
		case connection.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field connection_connection_brand", values[i])
			} else if value.Valid {
				c.connection_connection_brand = new(pulid.ID)
				*c.connection_connection_brand = *value.S.(*pulid.ID)
			}
		case connection.ForeignKeys[1]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field connection_sender_location", values[i])
			} else if value.Valid {
				c.connection_sender_location = new(pulid.ID)
				*c.connection_sender_location = *value.S.(*pulid.ID)
			}
		case connection.ForeignKeys[2]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field connection_pickup_location", values[i])
			} else if value.Valid {
				c.connection_pickup_location = new(pulid.ID)
				*c.connection_pickup_location = *value.S.(*pulid.ID)
			}
		case connection.ForeignKeys[3]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field connection_return_location", values[i])
			} else if value.Valid {
				c.connection_return_location = new(pulid.ID)
				*c.connection_return_location = *value.S.(*pulid.ID)
			}
		case connection.ForeignKeys[4]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field connection_seller_location", values[i])
			} else if value.Valid {
				c.connection_seller_location = new(pulid.ID)
				*c.connection_seller_location = *value.S.(*pulid.ID)
			}
		case connection.ForeignKeys[5]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field connection_currency", values[i])
			} else if value.Valid {
				c.connection_currency = new(pulid.ID)
				*c.connection_currency = *value.S.(*pulid.ID)
			}
		case connection.ForeignKeys[6]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field connection_packing_slip_template", values[i])
			} else if value.Valid {
				c.connection_packing_slip_template = new(pulid.ID)
				*c.connection_packing_slip_template = *value.S.(*pulid.ID)
			}
		case connection.ForeignKeys[7]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field return_portal_connection", values[i])
			} else if value.Valid {
				c.return_portal_connection = new(pulid.ID)
				*c.return_portal_connection = *value.S.(*pulid.ID)
			}
		default:
			c.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Connection.
// This includes values selected through modifiers, order, etc.
func (c *Connection) Value(name string) (ent.Value, error) {
	return c.selectValues.Get(name)
}

// QueryTenant queries the "tenant" edge of the Connection entity.
func (c *Connection) QueryTenant() *TenantQuery {
	return NewConnectionClient(c.config).QueryTenant(c)
}

// QueryConnectionBrand queries the "connection_brand" edge of the Connection entity.
func (c *Connection) QueryConnectionBrand() *ConnectionBrandQuery {
	return NewConnectionClient(c.config).QueryConnectionBrand(c)
}

// QueryConnectionShopify queries the "connection_shopify" edge of the Connection entity.
func (c *Connection) QueryConnectionShopify() *ConnectionShopifyQuery {
	return NewConnectionClient(c.config).QueryConnectionShopify(c)
}

// QueryOrders queries the "orders" edge of the Connection entity.
func (c *Connection) QueryOrders() *OrderQuery {
	return NewConnectionClient(c.config).QueryOrders(c)
}

// QuerySenderLocation queries the "sender_location" edge of the Connection entity.
func (c *Connection) QuerySenderLocation() *LocationQuery {
	return NewConnectionClient(c.config).QuerySenderLocation(c)
}

// QueryPickupLocation queries the "pickup_location" edge of the Connection entity.
func (c *Connection) QueryPickupLocation() *LocationQuery {
	return NewConnectionClient(c.config).QueryPickupLocation(c)
}

// QueryReturnLocation queries the "return_location" edge of the Connection entity.
func (c *Connection) QueryReturnLocation() *LocationQuery {
	return NewConnectionClient(c.config).QueryReturnLocation(c)
}

// QuerySellerLocation queries the "seller_location" edge of the Connection entity.
func (c *Connection) QuerySellerLocation() *LocationQuery {
	return NewConnectionClient(c.config).QuerySellerLocation(c)
}

// QueryDeliveryOption queries the "delivery_option" edge of the Connection entity.
func (c *Connection) QueryDeliveryOption() *DeliveryOptionQuery {
	return NewConnectionClient(c.config).QueryDeliveryOption(c)
}

// QueryDefaultDeliveryOption queries the "default_delivery_option" edge of the Connection entity.
func (c *Connection) QueryDefaultDeliveryOption() *DeliveryOptionQuery {
	return NewConnectionClient(c.config).QueryDefaultDeliveryOption(c)
}

// QueryReturnPortal queries the "return_portal" edge of the Connection entity.
func (c *Connection) QueryReturnPortal() *ReturnPortalQuery {
	return NewConnectionClient(c.config).QueryReturnPortal(c)
}

// QueryHypothesisTest queries the "hypothesis_test" edge of the Connection entity.
func (c *Connection) QueryHypothesisTest() *HypothesisTestQuery {
	return NewConnectionClient(c.config).QueryHypothesisTest(c)
}

// QueryNotifications queries the "notifications" edge of the Connection entity.
func (c *Connection) QueryNotifications() *NotificationQuery {
	return NewConnectionClient(c.config).QueryNotifications(c)
}

// QueryCurrency queries the "currency" edge of the Connection entity.
func (c *Connection) QueryCurrency() *CurrencyQuery {
	return NewConnectionClient(c.config).QueryCurrency(c)
}

// QueryPackingSlipTemplate queries the "packing_slip_template" edge of the Connection entity.
func (c *Connection) QueryPackingSlipTemplate() *DocumentQuery {
	return NewConnectionClient(c.config).QueryPackingSlipTemplate(c)
}

// QueryConnectionLookup queries the "connection_lookup" edge of the Connection entity.
func (c *Connection) QueryConnectionLookup() *ConnectionLookupQuery {
	return NewConnectionClient(c.config).QueryConnectionLookup(c)
}

// Update returns a builder for updating this Connection.
// Note that you need to call Connection.Unwrap() before calling this method if this Connection
// was returned from a transaction, and the transaction was committed or rolled back.
func (c *Connection) Update() *ConnectionUpdateOne {
	return NewConnectionClient(c.config).UpdateOne(c)
}

// Unwrap unwraps the Connection entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (c *Connection) Unwrap() *Connection {
	_tx, ok := c.config.driver.(*txDriver)
	if !ok {
		panic("ent: Connection is not a transactional entity")
	}
	c.config.driver = _tx.drv
	return c
}

// String implements the fmt.Stringer.
func (c *Connection) String() string {
	var builder strings.Builder
	builder.WriteString("Connection(")
	builder.WriteString(fmt.Sprintf("id=%v, ", c.ID))
	builder.WriteString("tenant_id=")
	builder.WriteString(fmt.Sprintf("%v", c.TenantID))
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(c.Name)
	builder.WriteString(", ")
	builder.WriteString("sync_orders=")
	builder.WriteString(fmt.Sprintf("%v", c.SyncOrders))
	builder.WriteString(", ")
	builder.WriteString("sync_products=")
	builder.WriteString(fmt.Sprintf("%v", c.SyncProducts))
	builder.WriteString(", ")
	builder.WriteString("fulfill_automatically=")
	builder.WriteString(fmt.Sprintf("%v", c.FulfillAutomatically))
	builder.WriteString(", ")
	builder.WriteString("dispatch_automatically=")
	builder.WriteString(fmt.Sprintf("%v", c.DispatchAutomatically))
	builder.WriteString(", ")
	builder.WriteString("convert_currency=")
	builder.WriteString(fmt.Sprintf("%v", c.ConvertCurrency))
	builder.WriteString(", ")
	builder.WriteString("auto_print_parcel_slip=")
	builder.WriteString(fmt.Sprintf("%v", c.AutoPrintParcelSlip))
	builder.WriteByte(')')
	return builder.String()
}

// NamedOrders returns the Orders named value or an error if the edge was not
// loaded in eager-loading with this name.
func (c *Connection) NamedOrders(name string) ([]*Order, error) {
	if c.Edges.namedOrders == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := c.Edges.namedOrders[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (c *Connection) appendNamedOrders(name string, edges ...*Order) {
	if c.Edges.namedOrders == nil {
		c.Edges.namedOrders = make(map[string][]*Order)
	}
	if len(edges) == 0 {
		c.Edges.namedOrders[name] = []*Order{}
	} else {
		c.Edges.namedOrders[name] = append(c.Edges.namedOrders[name], edges...)
	}
}

// NamedDeliveryOption returns the DeliveryOption named value or an error if the edge was not
// loaded in eager-loading with this name.
func (c *Connection) NamedDeliveryOption(name string) ([]*DeliveryOption, error) {
	if c.Edges.namedDeliveryOption == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := c.Edges.namedDeliveryOption[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (c *Connection) appendNamedDeliveryOption(name string, edges ...*DeliveryOption) {
	if c.Edges.namedDeliveryOption == nil {
		c.Edges.namedDeliveryOption = make(map[string][]*DeliveryOption)
	}
	if len(edges) == 0 {
		c.Edges.namedDeliveryOption[name] = []*DeliveryOption{}
	} else {
		c.Edges.namedDeliveryOption[name] = append(c.Edges.namedDeliveryOption[name], edges...)
	}
}

// NamedHypothesisTest returns the HypothesisTest named value or an error if the edge was not
// loaded in eager-loading with this name.
func (c *Connection) NamedHypothesisTest(name string) ([]*HypothesisTest, error) {
	if c.Edges.namedHypothesisTest == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := c.Edges.namedHypothesisTest[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (c *Connection) appendNamedHypothesisTest(name string, edges ...*HypothesisTest) {
	if c.Edges.namedHypothesisTest == nil {
		c.Edges.namedHypothesisTest = make(map[string][]*HypothesisTest)
	}
	if len(edges) == 0 {
		c.Edges.namedHypothesisTest[name] = []*HypothesisTest{}
	} else {
		c.Edges.namedHypothesisTest[name] = append(c.Edges.namedHypothesisTest[name], edges...)
	}
}

// NamedNotifications returns the Notifications named value or an error if the edge was not
// loaded in eager-loading with this name.
func (c *Connection) NamedNotifications(name string) ([]*Notification, error) {
	if c.Edges.namedNotifications == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := c.Edges.namedNotifications[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (c *Connection) appendNamedNotifications(name string, edges ...*Notification) {
	if c.Edges.namedNotifications == nil {
		c.Edges.namedNotifications = make(map[string][]*Notification)
	}
	if len(edges) == 0 {
		c.Edges.namedNotifications[name] = []*Notification{}
	} else {
		c.Edges.namedNotifications[name] = append(c.Edges.namedNotifications[name], edges...)
	}
}

// NamedConnectionLookup returns the ConnectionLookup named value or an error if the edge was not
// loaded in eager-loading with this name.
func (c *Connection) NamedConnectionLookup(name string) ([]*ConnectionLookup, error) {
	if c.Edges.namedConnectionLookup == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := c.Edges.namedConnectionLookup[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (c *Connection) appendNamedConnectionLookup(name string, edges ...*ConnectionLookup) {
	if c.Edges.namedConnectionLookup == nil {
		c.Edges.namedConnectionLookup = make(map[string][]*ConnectionLookup)
	}
	if len(edges) == 0 {
		c.Edges.namedConnectionLookup[name] = []*ConnectionLookup{}
	} else {
		c.Edges.namedConnectionLookup[name] = append(c.Edges.namedConnectionLookup[name], edges...)
	}
}

// Connections is a parsable slice of Connection.
type Connections []*Connection
