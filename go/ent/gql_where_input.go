// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"delivrio.io/go/ent/accessright"
	"delivrio.io/go/ent/address"
	"delivrio.io/go/ent/addressglobal"
	"delivrio.io/go/ent/apitoken"
	"delivrio.io/go/ent/businesshoursperiod"
	"delivrio.io/go/ent/carrier"
	"delivrio.io/go/ent/carrieradditionalservicebring"
	"delivrio.io/go/ent/carrieradditionalservicedao"
	"delivrio.io/go/ent/carrieradditionalservicedf"
	"delivrio.io/go/ent/carrieradditionalservicedsv"
	"delivrio.io/go/ent/carrieradditionalserviceeasypost"
	"delivrio.io/go/ent/carrieradditionalservicegls"
	"delivrio.io/go/ent/carrieradditionalservicepostnord"
	"delivrio.io/go/ent/carrieradditionalserviceusps"
	"delivrio.io/go/ent/carrierbrand"
	"delivrio.io/go/ent/carrierbring"
	"delivrio.io/go/ent/carrierdao"
	"delivrio.io/go/ent/carrierdf"
	"delivrio.io/go/ent/carrierdsv"
	"delivrio.io/go/ent/carriereasypost"
	"delivrio.io/go/ent/carriergls"
	"delivrio.io/go/ent/carrierpostnord"
	"delivrio.io/go/ent/carrierservice"
	"delivrio.io/go/ent/carrierservicebring"
	"delivrio.io/go/ent/carrierservicedao"
	"delivrio.io/go/ent/carrierservicedf"
	"delivrio.io/go/ent/carrierservicedsv"
	"delivrio.io/go/ent/carrierserviceeasypost"
	"delivrio.io/go/ent/carrierservicegls"
	"delivrio.io/go/ent/carrierservicepostnord"
	"delivrio.io/go/ent/carrierserviceusps"
	"delivrio.io/go/ent/carrierusps"
	"delivrio.io/go/ent/changehistory"
	"delivrio.io/go/ent/colli"
	"delivrio.io/go/ent/connection"
	"delivrio.io/go/ent/connectionbrand"
	"delivrio.io/go/ent/connectionlookup"
	"delivrio.io/go/ent/connectionshopify"
	"delivrio.io/go/ent/connectoptioncarrier"
	"delivrio.io/go/ent/connectoptionplatform"
	"delivrio.io/go/ent/consolidation"
	"delivrio.io/go/ent/contact"
	"delivrio.io/go/ent/country"
	"delivrio.io/go/ent/countryharmonizedcode"
	"delivrio.io/go/ent/currency"
	"delivrio.io/go/ent/deliveryoption"
	"delivrio.io/go/ent/deliveryoptionbring"
	"delivrio.io/go/ent/deliveryoptiondao"
	"delivrio.io/go/ent/deliveryoptiondf"
	"delivrio.io/go/ent/deliveryoptiondsv"
	"delivrio.io/go/ent/deliveryoptioneasypost"
	"delivrio.io/go/ent/deliveryoptiongls"
	"delivrio.io/go/ent/deliveryoptionpostnord"
	"delivrio.io/go/ent/deliveryoptionusps"
	"delivrio.io/go/ent/deliveryrule"
	"delivrio.io/go/ent/deliveryruleconstraint"
	"delivrio.io/go/ent/deliveryruleconstraintgroup"
	"delivrio.io/go/ent/document"
	"delivrio.io/go/ent/documentfile"
	"delivrio.io/go/ent/emailtemplate"
	"delivrio.io/go/ent/hypothesistest"
	"delivrio.io/go/ent/hypothesistestdeliveryoption"
	"delivrio.io/go/ent/hypothesistestdeliveryoptionlookup"
	"delivrio.io/go/ent/hypothesistestdeliveryoptionrequest"
	"delivrio.io/go/ent/inventoryitem"
	"delivrio.io/go/ent/language"
	"delivrio.io/go/ent/location"
	"delivrio.io/go/ent/locationtag"
	"delivrio.io/go/ent/notification"
	"delivrio.io/go/ent/order"
	"delivrio.io/go/ent/orderhistory"
	"delivrio.io/go/ent/orderline"
	"delivrio.io/go/ent/ordersender"
	"delivrio.io/go/ent/otkrequests"
	"delivrio.io/go/ent/packaging"
	"delivrio.io/go/ent/packagingdf"
	"delivrio.io/go/ent/packagingusps"
	"delivrio.io/go/ent/packaginguspsprocessingcategory"
	"delivrio.io/go/ent/packaginguspsrateindicator"
	"delivrio.io/go/ent/pallet"
	"delivrio.io/go/ent/parcelshop"
	"delivrio.io/go/ent/parcelshopbring"
	"delivrio.io/go/ent/parcelshopdao"
	"delivrio.io/go/ent/parcelshopgls"
	"delivrio.io/go/ent/parcelshoppostnord"
	"delivrio.io/go/ent/plan"
	"delivrio.io/go/ent/planhistory"
	"delivrio.io/go/ent/predicate"
	"delivrio.io/go/ent/printer"
	"delivrio.io/go/ent/printjob"
	"delivrio.io/go/ent/product"
	"delivrio.io/go/ent/productimage"
	"delivrio.io/go/ent/producttag"
	"delivrio.io/go/ent/productvariant"
	"delivrio.io/go/ent/returncolli"
	"delivrio.io/go/ent/returncollihistory"
	"delivrio.io/go/ent/returnorderline"
	"delivrio.io/go/ent/returnportal"
	"delivrio.io/go/ent/returnportalclaim"
	"delivrio.io/go/ent/seatgroup"
	"delivrio.io/go/ent/seatgroupaccessright"
	"delivrio.io/go/ent/shipment"
	"delivrio.io/go/ent/shipmentbring"
	"delivrio.io/go/ent/shipmentdao"
	"delivrio.io/go/ent/shipmentdf"
	"delivrio.io/go/ent/shipmentdsv"
	"delivrio.io/go/ent/shipmenteasypost"
	"delivrio.io/go/ent/shipmentgls"
	"delivrio.io/go/ent/shipmenthistory"
	"delivrio.io/go/ent/shipmentpallet"
	"delivrio.io/go/ent/shipmentparcel"
	"delivrio.io/go/ent/shipmentpostnord"
	"delivrio.io/go/ent/shipmentusps"
	"delivrio.io/go/ent/signupoptions"
	"delivrio.io/go/ent/systemevents"
	"delivrio.io/go/ent/tenant"
	"delivrio.io/go/ent/user"
	"delivrio.io/go/ent/userseat"
	"delivrio.io/go/ent/workspacerecentscan"
	"delivrio.io/go/ent/workstation"
	"delivrio.io/go/schema/fieldjson"
	"delivrio.io/shared-utils/pulid"
)

// APITokenWhereInput represents a where input for filtering APIToken queries.
type APITokenWhereInput struct {
	Predicates []predicate.APIToken  `json:"-"`
	Not        *APITokenWhereInput   `json:"not,omitempty"`
	Or         []*APITokenWhereInput `json:"or,omitempty"`
	And        []*APITokenWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "hashed_token" field predicates.
	HashedToken             *string  `json:"hashedToken,omitempty"`
	HashedTokenNEQ          *string  `json:"hashedTokenNEQ,omitempty"`
	HashedTokenIn           []string `json:"hashedTokenIn,omitempty"`
	HashedTokenNotIn        []string `json:"hashedTokenNotIn,omitempty"`
	HashedTokenGT           *string  `json:"hashedTokenGT,omitempty"`
	HashedTokenGTE          *string  `json:"hashedTokenGTE,omitempty"`
	HashedTokenLT           *string  `json:"hashedTokenLT,omitempty"`
	HashedTokenLTE          *string  `json:"hashedTokenLTE,omitempty"`
	HashedTokenContains     *string  `json:"hashedTokenContains,omitempty"`
	HashedTokenHasPrefix    *string  `json:"hashedTokenHasPrefix,omitempty"`
	HashedTokenHasSuffix    *string  `json:"hashedTokenHasSuffix,omitempty"`
	HashedTokenEqualFold    *string  `json:"hashedTokenEqualFold,omitempty"`
	HashedTokenContainsFold *string  `json:"hashedTokenContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "last_used" field predicates.
	LastUsed       *time.Time  `json:"lastUsed,omitempty"`
	LastUsedNEQ    *time.Time  `json:"lastUsedNEQ,omitempty"`
	LastUsedIn     []time.Time `json:"lastUsedIn,omitempty"`
	LastUsedNotIn  []time.Time `json:"lastUsedNotIn,omitempty"`
	LastUsedGT     *time.Time  `json:"lastUsedGT,omitempty"`
	LastUsedGTE    *time.Time  `json:"lastUsedGTE,omitempty"`
	LastUsedLT     *time.Time  `json:"lastUsedLT,omitempty"`
	LastUsedLTE    *time.Time  `json:"lastUsedLTE,omitempty"`
	LastUsedIsNil  bool        `json:"lastUsedIsNil,omitempty"`
	LastUsedNotNil bool        `json:"lastUsedNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *APITokenWhereInput) AddPredicates(predicates ...predicate.APIToken) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the APITokenWhereInput filter on the APITokenQuery builder.
func (i *APITokenWhereInput) Filter(q *APITokenQuery) (*APITokenQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAPITokenWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAPITokenWhereInput is returned in case the APITokenWhereInput is empty.
var ErrEmptyAPITokenWhereInput = errors.New("ent: empty predicate APITokenWhereInput")

// P returns a predicate for filtering apitokens.
// An error is returned if the input is empty or invalid.
func (i *APITokenWhereInput) P() (predicate.APIToken, error) {
	var predicates []predicate.APIToken
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, apitoken.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.APIToken, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, apitoken.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.APIToken, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, apitoken.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, apitoken.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, apitoken.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, apitoken.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, apitoken.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, apitoken.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, apitoken.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, apitoken.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, apitoken.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, apitoken.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, apitoken.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, apitoken.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, apitoken.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, apitoken.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, apitoken.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, apitoken.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, apitoken.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, apitoken.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, apitoken.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, apitoken.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, apitoken.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, apitoken.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, apitoken.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, apitoken.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, apitoken.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, apitoken.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, apitoken.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, apitoken.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, apitoken.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, apitoken.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, apitoken.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, apitoken.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, apitoken.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, apitoken.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, apitoken.NameContainsFold(*i.NameContainsFold))
	}
	if i.HashedToken != nil {
		predicates = append(predicates, apitoken.HashedTokenEQ(*i.HashedToken))
	}
	if i.HashedTokenNEQ != nil {
		predicates = append(predicates, apitoken.HashedTokenNEQ(*i.HashedTokenNEQ))
	}
	if len(i.HashedTokenIn) > 0 {
		predicates = append(predicates, apitoken.HashedTokenIn(i.HashedTokenIn...))
	}
	if len(i.HashedTokenNotIn) > 0 {
		predicates = append(predicates, apitoken.HashedTokenNotIn(i.HashedTokenNotIn...))
	}
	if i.HashedTokenGT != nil {
		predicates = append(predicates, apitoken.HashedTokenGT(*i.HashedTokenGT))
	}
	if i.HashedTokenGTE != nil {
		predicates = append(predicates, apitoken.HashedTokenGTE(*i.HashedTokenGTE))
	}
	if i.HashedTokenLT != nil {
		predicates = append(predicates, apitoken.HashedTokenLT(*i.HashedTokenLT))
	}
	if i.HashedTokenLTE != nil {
		predicates = append(predicates, apitoken.HashedTokenLTE(*i.HashedTokenLTE))
	}
	if i.HashedTokenContains != nil {
		predicates = append(predicates, apitoken.HashedTokenContains(*i.HashedTokenContains))
	}
	if i.HashedTokenHasPrefix != nil {
		predicates = append(predicates, apitoken.HashedTokenHasPrefix(*i.HashedTokenHasPrefix))
	}
	if i.HashedTokenHasSuffix != nil {
		predicates = append(predicates, apitoken.HashedTokenHasSuffix(*i.HashedTokenHasSuffix))
	}
	if i.HashedTokenEqualFold != nil {
		predicates = append(predicates, apitoken.HashedTokenEqualFold(*i.HashedTokenEqualFold))
	}
	if i.HashedTokenContainsFold != nil {
		predicates = append(predicates, apitoken.HashedTokenContainsFold(*i.HashedTokenContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, apitoken.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, apitoken.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, apitoken.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, apitoken.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, apitoken.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, apitoken.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, apitoken.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, apitoken.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, apitoken.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, apitoken.CreatedAtNotNil())
	}
	if i.LastUsed != nil {
		predicates = append(predicates, apitoken.LastUsedEQ(*i.LastUsed))
	}
	if i.LastUsedNEQ != nil {
		predicates = append(predicates, apitoken.LastUsedNEQ(*i.LastUsedNEQ))
	}
	if len(i.LastUsedIn) > 0 {
		predicates = append(predicates, apitoken.LastUsedIn(i.LastUsedIn...))
	}
	if len(i.LastUsedNotIn) > 0 {
		predicates = append(predicates, apitoken.LastUsedNotIn(i.LastUsedNotIn...))
	}
	if i.LastUsedGT != nil {
		predicates = append(predicates, apitoken.LastUsedGT(*i.LastUsedGT))
	}
	if i.LastUsedGTE != nil {
		predicates = append(predicates, apitoken.LastUsedGTE(*i.LastUsedGTE))
	}
	if i.LastUsedLT != nil {
		predicates = append(predicates, apitoken.LastUsedLT(*i.LastUsedLT))
	}
	if i.LastUsedLTE != nil {
		predicates = append(predicates, apitoken.LastUsedLTE(*i.LastUsedLTE))
	}
	if i.LastUsedIsNil {
		predicates = append(predicates, apitoken.LastUsedIsNil())
	}
	if i.LastUsedNotNil {
		predicates = append(predicates, apitoken.LastUsedNotNil())
	}

	if i.HasTenant != nil {
		p := apitoken.HasTenant()
		if !*i.HasTenant {
			p = apitoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apitoken.HasTenantWith(with...))
	}
	if i.HasUser != nil {
		p := apitoken.HasUser()
		if !*i.HasUser {
			p = apitoken.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, apitoken.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAPITokenWhereInput
	case 1:
		return predicates[0], nil
	default:
		return apitoken.And(predicates...), nil
	}
}

// AccessRightWhereInput represents a where input for filtering AccessRight queries.
type AccessRightWhereInput struct {
	Predicates []predicate.AccessRight  `json:"-"`
	Not        *AccessRightWhereInput   `json:"not,omitempty"`
	Or         []*AccessRightWhereInput `json:"or,omitempty"`
	And        []*AccessRightWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "internal_id" field predicates.
	InternalID             *string  `json:"internalID,omitempty"`
	InternalIDNEQ          *string  `json:"internalIDNEQ,omitempty"`
	InternalIDIn           []string `json:"internalIDIn,omitempty"`
	InternalIDNotIn        []string `json:"internalIDNotIn,omitempty"`
	InternalIDGT           *string  `json:"internalIDGT,omitempty"`
	InternalIDGTE          *string  `json:"internalIDGTE,omitempty"`
	InternalIDLT           *string  `json:"internalIDLT,omitempty"`
	InternalIDLTE          *string  `json:"internalIDLTE,omitempty"`
	InternalIDContains     *string  `json:"internalIDContains,omitempty"`
	InternalIDHasPrefix    *string  `json:"internalIDHasPrefix,omitempty"`
	InternalIDHasSuffix    *string  `json:"internalIDHasSuffix,omitempty"`
	InternalIDEqualFold    *string  `json:"internalIDEqualFold,omitempty"`
	InternalIDContainsFold *string  `json:"internalIDContainsFold,omitempty"`

	// "assigned_access_right" edge predicates.
	HasAssignedAccessRight     *bool                  `json:"hasAssignedAccessRight,omitempty"`
	HasAssignedAccessRightWith []*SeatGroupWhereInput `json:"hasAssignedAccessRightWith,omitempty"`

	// "seat_group_access_right" edge predicates.
	HasSeatGroupAccessRight     *bool                             `json:"hasSeatGroupAccessRight,omitempty"`
	HasSeatGroupAccessRightWith []*SeatGroupAccessRightWhereInput `json:"hasSeatGroupAccessRightWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AccessRightWhereInput) AddPredicates(predicates ...predicate.AccessRight) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AccessRightWhereInput filter on the AccessRightQuery builder.
func (i *AccessRightWhereInput) Filter(q *AccessRightQuery) (*AccessRightQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAccessRightWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAccessRightWhereInput is returned in case the AccessRightWhereInput is empty.
var ErrEmptyAccessRightWhereInput = errors.New("ent: empty predicate AccessRightWhereInput")

// P returns a predicate for filtering accessrights.
// An error is returned if the input is empty or invalid.
func (i *AccessRightWhereInput) P() (predicate.AccessRight, error) {
	var predicates []predicate.AccessRight
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, accessright.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AccessRight, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, accessright.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AccessRight, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, accessright.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, accessright.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, accessright.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, accessright.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, accessright.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, accessright.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, accessright.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, accessright.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, accessright.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, accessright.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, accessright.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, accessright.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, accessright.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, accessright.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, accessright.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, accessright.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, accessright.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, accessright.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, accessright.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, accessright.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, accessright.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, accessright.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.InternalID != nil {
		predicates = append(predicates, accessright.InternalIDEQ(*i.InternalID))
	}
	if i.InternalIDNEQ != nil {
		predicates = append(predicates, accessright.InternalIDNEQ(*i.InternalIDNEQ))
	}
	if len(i.InternalIDIn) > 0 {
		predicates = append(predicates, accessright.InternalIDIn(i.InternalIDIn...))
	}
	if len(i.InternalIDNotIn) > 0 {
		predicates = append(predicates, accessright.InternalIDNotIn(i.InternalIDNotIn...))
	}
	if i.InternalIDGT != nil {
		predicates = append(predicates, accessright.InternalIDGT(*i.InternalIDGT))
	}
	if i.InternalIDGTE != nil {
		predicates = append(predicates, accessright.InternalIDGTE(*i.InternalIDGTE))
	}
	if i.InternalIDLT != nil {
		predicates = append(predicates, accessright.InternalIDLT(*i.InternalIDLT))
	}
	if i.InternalIDLTE != nil {
		predicates = append(predicates, accessright.InternalIDLTE(*i.InternalIDLTE))
	}
	if i.InternalIDContains != nil {
		predicates = append(predicates, accessright.InternalIDContains(*i.InternalIDContains))
	}
	if i.InternalIDHasPrefix != nil {
		predicates = append(predicates, accessright.InternalIDHasPrefix(*i.InternalIDHasPrefix))
	}
	if i.InternalIDHasSuffix != nil {
		predicates = append(predicates, accessright.InternalIDHasSuffix(*i.InternalIDHasSuffix))
	}
	if i.InternalIDEqualFold != nil {
		predicates = append(predicates, accessright.InternalIDEqualFold(*i.InternalIDEqualFold))
	}
	if i.InternalIDContainsFold != nil {
		predicates = append(predicates, accessright.InternalIDContainsFold(*i.InternalIDContainsFold))
	}

	if i.HasAssignedAccessRight != nil {
		p := accessright.HasAssignedAccessRight()
		if !*i.HasAssignedAccessRight {
			p = accessright.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedAccessRightWith) > 0 {
		with := make([]predicate.SeatGroup, 0, len(i.HasAssignedAccessRightWith))
		for _, w := range i.HasAssignedAccessRightWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedAccessRightWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, accessright.HasAssignedAccessRightWith(with...))
	}
	if i.HasSeatGroupAccessRight != nil {
		p := accessright.HasSeatGroupAccessRight()
		if !*i.HasSeatGroupAccessRight {
			p = accessright.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSeatGroupAccessRightWith) > 0 {
		with := make([]predicate.SeatGroupAccessRight, 0, len(i.HasSeatGroupAccessRightWith))
		for _, w := range i.HasSeatGroupAccessRightWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSeatGroupAccessRightWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, accessright.HasSeatGroupAccessRightWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAccessRightWhereInput
	case 1:
		return predicates[0], nil
	default:
		return accessright.And(predicates...), nil
	}
}

// AddressWhereInput represents a where input for filtering Address queries.
type AddressWhereInput struct {
	Predicates []predicate.Address  `json:"-"`
	Not        *AddressWhereInput   `json:"not,omitempty"`
	Or         []*AddressWhereInput `json:"or,omitempty"`
	And        []*AddressWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "phone_number_2" field predicates.
	PhoneNumber2             *string  `json:"phoneNumber2,omitempty"`
	PhoneNumber2NEQ          *string  `json:"phoneNumber2NEQ,omitempty"`
	PhoneNumber2In           []string `json:"phoneNumber2In,omitempty"`
	PhoneNumber2NotIn        []string `json:"phoneNumber2NotIn,omitempty"`
	PhoneNumber2GT           *string  `json:"phoneNumber2GT,omitempty"`
	PhoneNumber2GTE          *string  `json:"phoneNumber2GTE,omitempty"`
	PhoneNumber2LT           *string  `json:"phoneNumber2LT,omitempty"`
	PhoneNumber2LTE          *string  `json:"phoneNumber2LTE,omitempty"`
	PhoneNumber2Contains     *string  `json:"phoneNumber2Contains,omitempty"`
	PhoneNumber2HasPrefix    *string  `json:"phoneNumber2HasPrefix,omitempty"`
	PhoneNumber2HasSuffix    *string  `json:"phoneNumber2HasSuffix,omitempty"`
	PhoneNumber2IsNil        bool     `json:"phoneNumber2IsNil,omitempty"`
	PhoneNumber2NotNil       bool     `json:"phoneNumber2NotNil,omitempty"`
	PhoneNumber2EqualFold    *string  `json:"phoneNumber2EqualFold,omitempty"`
	PhoneNumber2ContainsFold *string  `json:"phoneNumber2ContainsFold,omitempty"`

	// "vat_number" field predicates.
	VatNumber             *string  `json:"vatNumber,omitempty"`
	VatNumberNEQ          *string  `json:"vatNumberNEQ,omitempty"`
	VatNumberIn           []string `json:"vatNumberIn,omitempty"`
	VatNumberNotIn        []string `json:"vatNumberNotIn,omitempty"`
	VatNumberGT           *string  `json:"vatNumberGT,omitempty"`
	VatNumberGTE          *string  `json:"vatNumberGTE,omitempty"`
	VatNumberLT           *string  `json:"vatNumberLT,omitempty"`
	VatNumberLTE          *string  `json:"vatNumberLTE,omitempty"`
	VatNumberContains     *string  `json:"vatNumberContains,omitempty"`
	VatNumberHasPrefix    *string  `json:"vatNumberHasPrefix,omitempty"`
	VatNumberHasSuffix    *string  `json:"vatNumberHasSuffix,omitempty"`
	VatNumberIsNil        bool     `json:"vatNumberIsNil,omitempty"`
	VatNumberNotNil       bool     `json:"vatNumberNotNil,omitempty"`
	VatNumberEqualFold    *string  `json:"vatNumberEqualFold,omitempty"`
	VatNumberContainsFold *string  `json:"vatNumberContainsFold,omitempty"`

	// "company" field predicates.
	Company             *string  `json:"company,omitempty"`
	CompanyNEQ          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGT           *string  `json:"companyGT,omitempty"`
	CompanyGTE          *string  `json:"companyGTE,omitempty"`
	CompanyLT           *string  `json:"companyLT,omitempty"`
	CompanyLTE          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        bool     `json:"companyIsNil,omitempty"`
	CompanyNotNil       bool     `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`

	// "address_one" field predicates.
	AddressOne             *string  `json:"addressOne,omitempty"`
	AddressOneNEQ          *string  `json:"addressOneNEQ,omitempty"`
	AddressOneIn           []string `json:"addressOneIn,omitempty"`
	AddressOneNotIn        []string `json:"addressOneNotIn,omitempty"`
	AddressOneGT           *string  `json:"addressOneGT,omitempty"`
	AddressOneGTE          *string  `json:"addressOneGTE,omitempty"`
	AddressOneLT           *string  `json:"addressOneLT,omitempty"`
	AddressOneLTE          *string  `json:"addressOneLTE,omitempty"`
	AddressOneContains     *string  `json:"addressOneContains,omitempty"`
	AddressOneHasPrefix    *string  `json:"addressOneHasPrefix,omitempty"`
	AddressOneHasSuffix    *string  `json:"addressOneHasSuffix,omitempty"`
	AddressOneEqualFold    *string  `json:"addressOneEqualFold,omitempty"`
	AddressOneContainsFold *string  `json:"addressOneContainsFold,omitempty"`

	// "address_two" field predicates.
	AddressTwo             *string  `json:"addressTwo,omitempty"`
	AddressTwoNEQ          *string  `json:"addressTwoNEQ,omitempty"`
	AddressTwoIn           []string `json:"addressTwoIn,omitempty"`
	AddressTwoNotIn        []string `json:"addressTwoNotIn,omitempty"`
	AddressTwoGT           *string  `json:"addressTwoGT,omitempty"`
	AddressTwoGTE          *string  `json:"addressTwoGTE,omitempty"`
	AddressTwoLT           *string  `json:"addressTwoLT,omitempty"`
	AddressTwoLTE          *string  `json:"addressTwoLTE,omitempty"`
	AddressTwoContains     *string  `json:"addressTwoContains,omitempty"`
	AddressTwoHasPrefix    *string  `json:"addressTwoHasPrefix,omitempty"`
	AddressTwoHasSuffix    *string  `json:"addressTwoHasSuffix,omitempty"`
	AddressTwoEqualFold    *string  `json:"addressTwoEqualFold,omitempty"`
	AddressTwoContainsFold *string  `json:"addressTwoContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "state" field predicates.
	State             *string  `json:"state,omitempty"`
	StateNEQ          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGT           *string  `json:"stateGT,omitempty"`
	StateGTE          *string  `json:"stateGTE,omitempty"`
	StateLT           *string  `json:"stateLT,omitempty"`
	StateLTE          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateIsNil        bool     `json:"stateIsNil,omitempty"`
	StateNotNil       bool     `json:"stateNotNil,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`

	// "zip" field predicates.
	Zip             *string  `json:"zip,omitempty"`
	ZipNEQ          *string  `json:"zipNEQ,omitempty"`
	ZipIn           []string `json:"zipIn,omitempty"`
	ZipNotIn        []string `json:"zipNotIn,omitempty"`
	ZipGT           *string  `json:"zipGT,omitempty"`
	ZipGTE          *string  `json:"zipGTE,omitempty"`
	ZipLT           *string  `json:"zipLT,omitempty"`
	ZipLTE          *string  `json:"zipLTE,omitempty"`
	ZipContains     *string  `json:"zipContains,omitempty"`
	ZipHasPrefix    *string  `json:"zipHasPrefix,omitempty"`
	ZipHasSuffix    *string  `json:"zipHasSuffix,omitempty"`
	ZipEqualFold    *string  `json:"zipEqualFold,omitempty"`
	ZipContainsFold *string  `json:"zipContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "recipient_colli" edge predicates.
	HasRecipientColli     *bool              `json:"hasRecipientColli,omitempty"`
	HasRecipientColliWith []*ColliWhereInput `json:"hasRecipientColliWith,omitempty"`

	// "recipient_consolidation" edge predicates.
	HasRecipientConsolidation     *bool                      `json:"hasRecipientConsolidation,omitempty"`
	HasRecipientConsolidationWith []*ConsolidationWhereInput `json:"hasRecipientConsolidationWith,omitempty"`

	// "company_address" edge predicates.
	HasCompanyAddress     *bool               `json:"hasCompanyAddress,omitempty"`
	HasCompanyAddressWith []*TenantWhereInput `json:"hasCompanyAddressWith,omitempty"`

	// "location" edge predicates.
	HasLocation     *bool                 `json:"hasLocation,omitempty"`
	HasLocationWith []*LocationWhereInput `json:"hasLocationWith,omitempty"`

	// "sender_colli" edge predicates.
	HasSenderColli     *bool              `json:"hasSenderColli,omitempty"`
	HasSenderColliWith []*ColliWhereInput `json:"hasSenderColliWith,omitempty"`

	// "sender_consolidation" edge predicates.
	HasSenderConsolidation     *bool                      `json:"hasSenderConsolidation,omitempty"`
	HasSenderConsolidationWith []*ConsolidationWhereInput `json:"hasSenderConsolidationWith,omitempty"`

	// "return_sender_colli" edge predicates.
	HasReturnSenderColli     *bool                    `json:"hasReturnSenderColli,omitempty"`
	HasReturnSenderColliWith []*ReturnColliWhereInput `json:"hasReturnSenderColliWith,omitempty"`

	// "return_recipient_colli" edge predicates.
	HasReturnRecipientColli     *bool                    `json:"hasReturnRecipientColli,omitempty"`
	HasReturnRecipientColliWith []*ReturnColliWhereInput `json:"hasReturnRecipientColliWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AddressWhereInput) AddPredicates(predicates ...predicate.Address) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AddressWhereInput filter on the AddressQuery builder.
func (i *AddressWhereInput) Filter(q *AddressQuery) (*AddressQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAddressWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAddressWhereInput is returned in case the AddressWhereInput is empty.
var ErrEmptyAddressWhereInput = errors.New("ent: empty predicate AddressWhereInput")

// P returns a predicate for filtering addresses.
// An error is returned if the input is empty or invalid.
func (i *AddressWhereInput) P() (predicate.Address, error) {
	var predicates []predicate.Address
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, address.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Address, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, address.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Address, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, address.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, address.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, address.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, address.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, address.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, address.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, address.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, address.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, address.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, address.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, address.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, address.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, address.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, address.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, address.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, address.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, address.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, address.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, address.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, address.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, address.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, address.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, address.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, address.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, address.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, address.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, address.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, address.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, address.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, address.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, address.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, address.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, address.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, address.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, address.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, address.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, address.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, address.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, address.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, address.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, address.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, address.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, address.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, address.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, address.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, address.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, address.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, address.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, address.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, address.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, address.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, address.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, address.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, address.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, address.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, address.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, address.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, address.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, address.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, address.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, address.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, address.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, address.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, address.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, address.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, address.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, address.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, address.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, address.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, address.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, address.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, address.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, address.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, address.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}
	if i.PhoneNumber2 != nil {
		predicates = append(predicates, address.PhoneNumber2EQ(*i.PhoneNumber2))
	}
	if i.PhoneNumber2NEQ != nil {
		predicates = append(predicates, address.PhoneNumber2NEQ(*i.PhoneNumber2NEQ))
	}
	if len(i.PhoneNumber2In) > 0 {
		predicates = append(predicates, address.PhoneNumber2In(i.PhoneNumber2In...))
	}
	if len(i.PhoneNumber2NotIn) > 0 {
		predicates = append(predicates, address.PhoneNumber2NotIn(i.PhoneNumber2NotIn...))
	}
	if i.PhoneNumber2GT != nil {
		predicates = append(predicates, address.PhoneNumber2GT(*i.PhoneNumber2GT))
	}
	if i.PhoneNumber2GTE != nil {
		predicates = append(predicates, address.PhoneNumber2GTE(*i.PhoneNumber2GTE))
	}
	if i.PhoneNumber2LT != nil {
		predicates = append(predicates, address.PhoneNumber2LT(*i.PhoneNumber2LT))
	}
	if i.PhoneNumber2LTE != nil {
		predicates = append(predicates, address.PhoneNumber2LTE(*i.PhoneNumber2LTE))
	}
	if i.PhoneNumber2Contains != nil {
		predicates = append(predicates, address.PhoneNumber2Contains(*i.PhoneNumber2Contains))
	}
	if i.PhoneNumber2HasPrefix != nil {
		predicates = append(predicates, address.PhoneNumber2HasPrefix(*i.PhoneNumber2HasPrefix))
	}
	if i.PhoneNumber2HasSuffix != nil {
		predicates = append(predicates, address.PhoneNumber2HasSuffix(*i.PhoneNumber2HasSuffix))
	}
	if i.PhoneNumber2IsNil {
		predicates = append(predicates, address.PhoneNumber2IsNil())
	}
	if i.PhoneNumber2NotNil {
		predicates = append(predicates, address.PhoneNumber2NotNil())
	}
	if i.PhoneNumber2EqualFold != nil {
		predicates = append(predicates, address.PhoneNumber2EqualFold(*i.PhoneNumber2EqualFold))
	}
	if i.PhoneNumber2ContainsFold != nil {
		predicates = append(predicates, address.PhoneNumber2ContainsFold(*i.PhoneNumber2ContainsFold))
	}
	if i.VatNumber != nil {
		predicates = append(predicates, address.VatNumberEQ(*i.VatNumber))
	}
	if i.VatNumberNEQ != nil {
		predicates = append(predicates, address.VatNumberNEQ(*i.VatNumberNEQ))
	}
	if len(i.VatNumberIn) > 0 {
		predicates = append(predicates, address.VatNumberIn(i.VatNumberIn...))
	}
	if len(i.VatNumberNotIn) > 0 {
		predicates = append(predicates, address.VatNumberNotIn(i.VatNumberNotIn...))
	}
	if i.VatNumberGT != nil {
		predicates = append(predicates, address.VatNumberGT(*i.VatNumberGT))
	}
	if i.VatNumberGTE != nil {
		predicates = append(predicates, address.VatNumberGTE(*i.VatNumberGTE))
	}
	if i.VatNumberLT != nil {
		predicates = append(predicates, address.VatNumberLT(*i.VatNumberLT))
	}
	if i.VatNumberLTE != nil {
		predicates = append(predicates, address.VatNumberLTE(*i.VatNumberLTE))
	}
	if i.VatNumberContains != nil {
		predicates = append(predicates, address.VatNumberContains(*i.VatNumberContains))
	}
	if i.VatNumberHasPrefix != nil {
		predicates = append(predicates, address.VatNumberHasPrefix(*i.VatNumberHasPrefix))
	}
	if i.VatNumberHasSuffix != nil {
		predicates = append(predicates, address.VatNumberHasSuffix(*i.VatNumberHasSuffix))
	}
	if i.VatNumberIsNil {
		predicates = append(predicates, address.VatNumberIsNil())
	}
	if i.VatNumberNotNil {
		predicates = append(predicates, address.VatNumberNotNil())
	}
	if i.VatNumberEqualFold != nil {
		predicates = append(predicates, address.VatNumberEqualFold(*i.VatNumberEqualFold))
	}
	if i.VatNumberContainsFold != nil {
		predicates = append(predicates, address.VatNumberContainsFold(*i.VatNumberContainsFold))
	}
	if i.Company != nil {
		predicates = append(predicates, address.CompanyEQ(*i.Company))
	}
	if i.CompanyNEQ != nil {
		predicates = append(predicates, address.CompanyNEQ(*i.CompanyNEQ))
	}
	if len(i.CompanyIn) > 0 {
		predicates = append(predicates, address.CompanyIn(i.CompanyIn...))
	}
	if len(i.CompanyNotIn) > 0 {
		predicates = append(predicates, address.CompanyNotIn(i.CompanyNotIn...))
	}
	if i.CompanyGT != nil {
		predicates = append(predicates, address.CompanyGT(*i.CompanyGT))
	}
	if i.CompanyGTE != nil {
		predicates = append(predicates, address.CompanyGTE(*i.CompanyGTE))
	}
	if i.CompanyLT != nil {
		predicates = append(predicates, address.CompanyLT(*i.CompanyLT))
	}
	if i.CompanyLTE != nil {
		predicates = append(predicates, address.CompanyLTE(*i.CompanyLTE))
	}
	if i.CompanyContains != nil {
		predicates = append(predicates, address.CompanyContains(*i.CompanyContains))
	}
	if i.CompanyHasPrefix != nil {
		predicates = append(predicates, address.CompanyHasPrefix(*i.CompanyHasPrefix))
	}
	if i.CompanyHasSuffix != nil {
		predicates = append(predicates, address.CompanyHasSuffix(*i.CompanyHasSuffix))
	}
	if i.CompanyIsNil {
		predicates = append(predicates, address.CompanyIsNil())
	}
	if i.CompanyNotNil {
		predicates = append(predicates, address.CompanyNotNil())
	}
	if i.CompanyEqualFold != nil {
		predicates = append(predicates, address.CompanyEqualFold(*i.CompanyEqualFold))
	}
	if i.CompanyContainsFold != nil {
		predicates = append(predicates, address.CompanyContainsFold(*i.CompanyContainsFold))
	}
	if i.AddressOne != nil {
		predicates = append(predicates, address.AddressOneEQ(*i.AddressOne))
	}
	if i.AddressOneNEQ != nil {
		predicates = append(predicates, address.AddressOneNEQ(*i.AddressOneNEQ))
	}
	if len(i.AddressOneIn) > 0 {
		predicates = append(predicates, address.AddressOneIn(i.AddressOneIn...))
	}
	if len(i.AddressOneNotIn) > 0 {
		predicates = append(predicates, address.AddressOneNotIn(i.AddressOneNotIn...))
	}
	if i.AddressOneGT != nil {
		predicates = append(predicates, address.AddressOneGT(*i.AddressOneGT))
	}
	if i.AddressOneGTE != nil {
		predicates = append(predicates, address.AddressOneGTE(*i.AddressOneGTE))
	}
	if i.AddressOneLT != nil {
		predicates = append(predicates, address.AddressOneLT(*i.AddressOneLT))
	}
	if i.AddressOneLTE != nil {
		predicates = append(predicates, address.AddressOneLTE(*i.AddressOneLTE))
	}
	if i.AddressOneContains != nil {
		predicates = append(predicates, address.AddressOneContains(*i.AddressOneContains))
	}
	if i.AddressOneHasPrefix != nil {
		predicates = append(predicates, address.AddressOneHasPrefix(*i.AddressOneHasPrefix))
	}
	if i.AddressOneHasSuffix != nil {
		predicates = append(predicates, address.AddressOneHasSuffix(*i.AddressOneHasSuffix))
	}
	if i.AddressOneEqualFold != nil {
		predicates = append(predicates, address.AddressOneEqualFold(*i.AddressOneEqualFold))
	}
	if i.AddressOneContainsFold != nil {
		predicates = append(predicates, address.AddressOneContainsFold(*i.AddressOneContainsFold))
	}
	if i.AddressTwo != nil {
		predicates = append(predicates, address.AddressTwoEQ(*i.AddressTwo))
	}
	if i.AddressTwoNEQ != nil {
		predicates = append(predicates, address.AddressTwoNEQ(*i.AddressTwoNEQ))
	}
	if len(i.AddressTwoIn) > 0 {
		predicates = append(predicates, address.AddressTwoIn(i.AddressTwoIn...))
	}
	if len(i.AddressTwoNotIn) > 0 {
		predicates = append(predicates, address.AddressTwoNotIn(i.AddressTwoNotIn...))
	}
	if i.AddressTwoGT != nil {
		predicates = append(predicates, address.AddressTwoGT(*i.AddressTwoGT))
	}
	if i.AddressTwoGTE != nil {
		predicates = append(predicates, address.AddressTwoGTE(*i.AddressTwoGTE))
	}
	if i.AddressTwoLT != nil {
		predicates = append(predicates, address.AddressTwoLT(*i.AddressTwoLT))
	}
	if i.AddressTwoLTE != nil {
		predicates = append(predicates, address.AddressTwoLTE(*i.AddressTwoLTE))
	}
	if i.AddressTwoContains != nil {
		predicates = append(predicates, address.AddressTwoContains(*i.AddressTwoContains))
	}
	if i.AddressTwoHasPrefix != nil {
		predicates = append(predicates, address.AddressTwoHasPrefix(*i.AddressTwoHasPrefix))
	}
	if i.AddressTwoHasSuffix != nil {
		predicates = append(predicates, address.AddressTwoHasSuffix(*i.AddressTwoHasSuffix))
	}
	if i.AddressTwoEqualFold != nil {
		predicates = append(predicates, address.AddressTwoEqualFold(*i.AddressTwoEqualFold))
	}
	if i.AddressTwoContainsFold != nil {
		predicates = append(predicates, address.AddressTwoContainsFold(*i.AddressTwoContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, address.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, address.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, address.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, address.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, address.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, address.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, address.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, address.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, address.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, address.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, address.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, address.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, address.CityContainsFold(*i.CityContainsFold))
	}
	if i.State != nil {
		predicates = append(predicates, address.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, address.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, address.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, address.StateNotIn(i.StateNotIn...))
	}
	if i.StateGT != nil {
		predicates = append(predicates, address.StateGT(*i.StateGT))
	}
	if i.StateGTE != nil {
		predicates = append(predicates, address.StateGTE(*i.StateGTE))
	}
	if i.StateLT != nil {
		predicates = append(predicates, address.StateLT(*i.StateLT))
	}
	if i.StateLTE != nil {
		predicates = append(predicates, address.StateLTE(*i.StateLTE))
	}
	if i.StateContains != nil {
		predicates = append(predicates, address.StateContains(*i.StateContains))
	}
	if i.StateHasPrefix != nil {
		predicates = append(predicates, address.StateHasPrefix(*i.StateHasPrefix))
	}
	if i.StateHasSuffix != nil {
		predicates = append(predicates, address.StateHasSuffix(*i.StateHasSuffix))
	}
	if i.StateIsNil {
		predicates = append(predicates, address.StateIsNil())
	}
	if i.StateNotNil {
		predicates = append(predicates, address.StateNotNil())
	}
	if i.StateEqualFold != nil {
		predicates = append(predicates, address.StateEqualFold(*i.StateEqualFold))
	}
	if i.StateContainsFold != nil {
		predicates = append(predicates, address.StateContainsFold(*i.StateContainsFold))
	}
	if i.Zip != nil {
		predicates = append(predicates, address.ZipEQ(*i.Zip))
	}
	if i.ZipNEQ != nil {
		predicates = append(predicates, address.ZipNEQ(*i.ZipNEQ))
	}
	if len(i.ZipIn) > 0 {
		predicates = append(predicates, address.ZipIn(i.ZipIn...))
	}
	if len(i.ZipNotIn) > 0 {
		predicates = append(predicates, address.ZipNotIn(i.ZipNotIn...))
	}
	if i.ZipGT != nil {
		predicates = append(predicates, address.ZipGT(*i.ZipGT))
	}
	if i.ZipGTE != nil {
		predicates = append(predicates, address.ZipGTE(*i.ZipGTE))
	}
	if i.ZipLT != nil {
		predicates = append(predicates, address.ZipLT(*i.ZipLT))
	}
	if i.ZipLTE != nil {
		predicates = append(predicates, address.ZipLTE(*i.ZipLTE))
	}
	if i.ZipContains != nil {
		predicates = append(predicates, address.ZipContains(*i.ZipContains))
	}
	if i.ZipHasPrefix != nil {
		predicates = append(predicates, address.ZipHasPrefix(*i.ZipHasPrefix))
	}
	if i.ZipHasSuffix != nil {
		predicates = append(predicates, address.ZipHasSuffix(*i.ZipHasSuffix))
	}
	if i.ZipEqualFold != nil {
		predicates = append(predicates, address.ZipEqualFold(*i.ZipEqualFold))
	}
	if i.ZipContainsFold != nil {
		predicates = append(predicates, address.ZipContainsFold(*i.ZipContainsFold))
	}

	if i.HasTenant != nil {
		p := address.HasTenant()
		if !*i.HasTenant {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasTenantWith(with...))
	}
	if i.HasRecipientColli != nil {
		p := address.HasRecipientColli()
		if !*i.HasRecipientColli {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRecipientColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasRecipientColliWith))
		for _, w := range i.HasRecipientColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRecipientColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasRecipientColliWith(with...))
	}
	if i.HasRecipientConsolidation != nil {
		p := address.HasRecipientConsolidation()
		if !*i.HasRecipientConsolidation {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRecipientConsolidationWith) > 0 {
		with := make([]predicate.Consolidation, 0, len(i.HasRecipientConsolidationWith))
		for _, w := range i.HasRecipientConsolidationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRecipientConsolidationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasRecipientConsolidationWith(with...))
	}
	if i.HasCompanyAddress != nil {
		p := address.HasCompanyAddress()
		if !*i.HasCompanyAddress {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyAddressWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasCompanyAddressWith))
		for _, w := range i.HasCompanyAddressWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyAddressWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasCompanyAddressWith(with...))
	}
	if i.HasLocation != nil {
		p := address.HasLocation()
		if !*i.HasLocation {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationWith))
		for _, w := range i.HasLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasLocationWith(with...))
	}
	if i.HasSenderColli != nil {
		p := address.HasSenderColli()
		if !*i.HasSenderColli {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSenderColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasSenderColliWith))
		for _, w := range i.HasSenderColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSenderColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasSenderColliWith(with...))
	}
	if i.HasSenderConsolidation != nil {
		p := address.HasSenderConsolidation()
		if !*i.HasSenderConsolidation {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSenderConsolidationWith) > 0 {
		with := make([]predicate.Consolidation, 0, len(i.HasSenderConsolidationWith))
		for _, w := range i.HasSenderConsolidationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSenderConsolidationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasSenderConsolidationWith(with...))
	}
	if i.HasReturnSenderColli != nil {
		p := address.HasReturnSenderColli()
		if !*i.HasReturnSenderColli {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnSenderColliWith) > 0 {
		with := make([]predicate.ReturnColli, 0, len(i.HasReturnSenderColliWith))
		for _, w := range i.HasReturnSenderColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnSenderColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasReturnSenderColliWith(with...))
	}
	if i.HasReturnRecipientColli != nil {
		p := address.HasReturnRecipientColli()
		if !*i.HasReturnRecipientColli {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnRecipientColliWith) > 0 {
		with := make([]predicate.ReturnColli, 0, len(i.HasReturnRecipientColliWith))
		for _, w := range i.HasReturnRecipientColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnRecipientColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasReturnRecipientColliWith(with...))
	}
	if i.HasCountry != nil {
		p := address.HasCountry()
		if !*i.HasCountry {
			p = address.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, address.HasCountryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAddressWhereInput
	case 1:
		return predicates[0], nil
	default:
		return address.And(predicates...), nil
	}
}

// AddressGlobalWhereInput represents a where input for filtering AddressGlobal queries.
type AddressGlobalWhereInput struct {
	Predicates []predicate.AddressGlobal  `json:"-"`
	Not        *AddressGlobalWhereInput   `json:"not,omitempty"`
	Or         []*AddressGlobalWhereInput `json:"or,omitempty"`
	And        []*AddressGlobalWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "company" field predicates.
	Company             *string  `json:"company,omitempty"`
	CompanyNEQ          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGT           *string  `json:"companyGT,omitempty"`
	CompanyGTE          *string  `json:"companyGTE,omitempty"`
	CompanyLT           *string  `json:"companyLT,omitempty"`
	CompanyLTE          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        bool     `json:"companyIsNil,omitempty"`
	CompanyNotNil       bool     `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`

	// "address_one" field predicates.
	AddressOne             *string  `json:"addressOne,omitempty"`
	AddressOneNEQ          *string  `json:"addressOneNEQ,omitempty"`
	AddressOneIn           []string `json:"addressOneIn,omitempty"`
	AddressOneNotIn        []string `json:"addressOneNotIn,omitempty"`
	AddressOneGT           *string  `json:"addressOneGT,omitempty"`
	AddressOneGTE          *string  `json:"addressOneGTE,omitempty"`
	AddressOneLT           *string  `json:"addressOneLT,omitempty"`
	AddressOneLTE          *string  `json:"addressOneLTE,omitempty"`
	AddressOneContains     *string  `json:"addressOneContains,omitempty"`
	AddressOneHasPrefix    *string  `json:"addressOneHasPrefix,omitempty"`
	AddressOneHasSuffix    *string  `json:"addressOneHasSuffix,omitempty"`
	AddressOneEqualFold    *string  `json:"addressOneEqualFold,omitempty"`
	AddressOneContainsFold *string  `json:"addressOneContainsFold,omitempty"`

	// "address_two" field predicates.
	AddressTwo             *string  `json:"addressTwo,omitempty"`
	AddressTwoNEQ          *string  `json:"addressTwoNEQ,omitempty"`
	AddressTwoIn           []string `json:"addressTwoIn,omitempty"`
	AddressTwoNotIn        []string `json:"addressTwoNotIn,omitempty"`
	AddressTwoGT           *string  `json:"addressTwoGT,omitempty"`
	AddressTwoGTE          *string  `json:"addressTwoGTE,omitempty"`
	AddressTwoLT           *string  `json:"addressTwoLT,omitempty"`
	AddressTwoLTE          *string  `json:"addressTwoLTE,omitempty"`
	AddressTwoContains     *string  `json:"addressTwoContains,omitempty"`
	AddressTwoHasPrefix    *string  `json:"addressTwoHasPrefix,omitempty"`
	AddressTwoHasSuffix    *string  `json:"addressTwoHasSuffix,omitempty"`
	AddressTwoIsNil        bool     `json:"addressTwoIsNil,omitempty"`
	AddressTwoNotNil       bool     `json:"addressTwoNotNil,omitempty"`
	AddressTwoEqualFold    *string  `json:"addressTwoEqualFold,omitempty"`
	AddressTwoContainsFold *string  `json:"addressTwoContainsFold,omitempty"`

	// "city" field predicates.
	City             *string  `json:"city,omitempty"`
	CityNEQ          *string  `json:"cityNEQ,omitempty"`
	CityIn           []string `json:"cityIn,omitempty"`
	CityNotIn        []string `json:"cityNotIn,omitempty"`
	CityGT           *string  `json:"cityGT,omitempty"`
	CityGTE          *string  `json:"cityGTE,omitempty"`
	CityLT           *string  `json:"cityLT,omitempty"`
	CityLTE          *string  `json:"cityLTE,omitempty"`
	CityContains     *string  `json:"cityContains,omitempty"`
	CityHasPrefix    *string  `json:"cityHasPrefix,omitempty"`
	CityHasSuffix    *string  `json:"cityHasSuffix,omitempty"`
	CityEqualFold    *string  `json:"cityEqualFold,omitempty"`
	CityContainsFold *string  `json:"cityContainsFold,omitempty"`

	// "state" field predicates.
	State             *string  `json:"state,omitempty"`
	StateNEQ          *string  `json:"stateNEQ,omitempty"`
	StateIn           []string `json:"stateIn,omitempty"`
	StateNotIn        []string `json:"stateNotIn,omitempty"`
	StateGT           *string  `json:"stateGT,omitempty"`
	StateGTE          *string  `json:"stateGTE,omitempty"`
	StateLT           *string  `json:"stateLT,omitempty"`
	StateLTE          *string  `json:"stateLTE,omitempty"`
	StateContains     *string  `json:"stateContains,omitempty"`
	StateHasPrefix    *string  `json:"stateHasPrefix,omitempty"`
	StateHasSuffix    *string  `json:"stateHasSuffix,omitempty"`
	StateIsNil        bool     `json:"stateIsNil,omitempty"`
	StateNotNil       bool     `json:"stateNotNil,omitempty"`
	StateEqualFold    *string  `json:"stateEqualFold,omitempty"`
	StateContainsFold *string  `json:"stateContainsFold,omitempty"`

	// "zip" field predicates.
	Zip             *string  `json:"zip,omitempty"`
	ZipNEQ          *string  `json:"zipNEQ,omitempty"`
	ZipIn           []string `json:"zipIn,omitempty"`
	ZipNotIn        []string `json:"zipNotIn,omitempty"`
	ZipGT           *string  `json:"zipGT,omitempty"`
	ZipGTE          *string  `json:"zipGTE,omitempty"`
	ZipLT           *string  `json:"zipLT,omitempty"`
	ZipLTE          *string  `json:"zipLTE,omitempty"`
	ZipContains     *string  `json:"zipContains,omitempty"`
	ZipHasPrefix    *string  `json:"zipHasPrefix,omitempty"`
	ZipHasSuffix    *string  `json:"zipHasSuffix,omitempty"`
	ZipEqualFold    *string  `json:"zipEqualFold,omitempty"`
	ZipContainsFold *string  `json:"zipContainsFold,omitempty"`

	// "latitude" field predicates.
	Latitude      *float64  `json:"latitude,omitempty"`
	LatitudeNEQ   *float64  `json:"latitudeNEQ,omitempty"`
	LatitudeIn    []float64 `json:"latitudeIn,omitempty"`
	LatitudeNotIn []float64 `json:"latitudeNotIn,omitempty"`
	LatitudeGT    *float64  `json:"latitudeGT,omitempty"`
	LatitudeGTE   *float64  `json:"latitudeGTE,omitempty"`
	LatitudeLT    *float64  `json:"latitudeLT,omitempty"`
	LatitudeLTE   *float64  `json:"latitudeLTE,omitempty"`

	// "longitude" field predicates.
	Longitude      *float64  `json:"longitude,omitempty"`
	LongitudeNEQ   *float64  `json:"longitudeNEQ,omitempty"`
	LongitudeIn    []float64 `json:"longitudeIn,omitempty"`
	LongitudeNotIn []float64 `json:"longitudeNotIn,omitempty"`
	LongitudeGT    *float64  `json:"longitudeGT,omitempty"`
	LongitudeGTE   *float64  `json:"longitudeGTE,omitempty"`
	LongitudeLT    *float64  `json:"longitudeLT,omitempty"`
	LongitudeLTE   *float64  `json:"longitudeLTE,omitempty"`

	// "parcel_shop_post_nord_delivery" edge predicates.
	HasParcelShopPostNordDelivery     *bool                           `json:"hasParcelShopPostNordDelivery,omitempty"`
	HasParcelShopPostNordDeliveryWith []*ParcelShopPostNordWhereInput `json:"hasParcelShopPostNordDeliveryWith,omitempty"`

	// "parcel_shop_bring_delivery" edge predicates.
	HasParcelShopBringDelivery     *bool                        `json:"hasParcelShopBringDelivery,omitempty"`
	HasParcelShopBringDeliveryWith []*ParcelShopBringWhereInput `json:"hasParcelShopBringDeliveryWith,omitempty"`

	// "parcel_shop" edge predicates.
	HasParcelShop     *bool                   `json:"hasParcelShop,omitempty"`
	HasParcelShopWith []*ParcelShopWhereInput `json:"hasParcelShopWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *AddressGlobalWhereInput) AddPredicates(predicates ...predicate.AddressGlobal) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the AddressGlobalWhereInput filter on the AddressGlobalQuery builder.
func (i *AddressGlobalWhereInput) Filter(q *AddressGlobalQuery) (*AddressGlobalQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyAddressGlobalWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyAddressGlobalWhereInput is returned in case the AddressGlobalWhereInput is empty.
var ErrEmptyAddressGlobalWhereInput = errors.New("ent: empty predicate AddressGlobalWhereInput")

// P returns a predicate for filtering addressglobals.
// An error is returned if the input is empty or invalid.
func (i *AddressGlobalWhereInput) P() (predicate.AddressGlobal, error) {
	var predicates []predicate.AddressGlobal
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, addressglobal.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.AddressGlobal, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, addressglobal.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.AddressGlobal, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, addressglobal.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, addressglobal.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, addressglobal.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, addressglobal.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, addressglobal.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, addressglobal.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, addressglobal.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, addressglobal.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, addressglobal.IDLTE(*i.IDLTE))
	}
	if i.Company != nil {
		predicates = append(predicates, addressglobal.CompanyEQ(*i.Company))
	}
	if i.CompanyNEQ != nil {
		predicates = append(predicates, addressglobal.CompanyNEQ(*i.CompanyNEQ))
	}
	if len(i.CompanyIn) > 0 {
		predicates = append(predicates, addressglobal.CompanyIn(i.CompanyIn...))
	}
	if len(i.CompanyNotIn) > 0 {
		predicates = append(predicates, addressglobal.CompanyNotIn(i.CompanyNotIn...))
	}
	if i.CompanyGT != nil {
		predicates = append(predicates, addressglobal.CompanyGT(*i.CompanyGT))
	}
	if i.CompanyGTE != nil {
		predicates = append(predicates, addressglobal.CompanyGTE(*i.CompanyGTE))
	}
	if i.CompanyLT != nil {
		predicates = append(predicates, addressglobal.CompanyLT(*i.CompanyLT))
	}
	if i.CompanyLTE != nil {
		predicates = append(predicates, addressglobal.CompanyLTE(*i.CompanyLTE))
	}
	if i.CompanyContains != nil {
		predicates = append(predicates, addressglobal.CompanyContains(*i.CompanyContains))
	}
	if i.CompanyHasPrefix != nil {
		predicates = append(predicates, addressglobal.CompanyHasPrefix(*i.CompanyHasPrefix))
	}
	if i.CompanyHasSuffix != nil {
		predicates = append(predicates, addressglobal.CompanyHasSuffix(*i.CompanyHasSuffix))
	}
	if i.CompanyIsNil {
		predicates = append(predicates, addressglobal.CompanyIsNil())
	}
	if i.CompanyNotNil {
		predicates = append(predicates, addressglobal.CompanyNotNil())
	}
	if i.CompanyEqualFold != nil {
		predicates = append(predicates, addressglobal.CompanyEqualFold(*i.CompanyEqualFold))
	}
	if i.CompanyContainsFold != nil {
		predicates = append(predicates, addressglobal.CompanyContainsFold(*i.CompanyContainsFold))
	}
	if i.AddressOne != nil {
		predicates = append(predicates, addressglobal.AddressOneEQ(*i.AddressOne))
	}
	if i.AddressOneNEQ != nil {
		predicates = append(predicates, addressglobal.AddressOneNEQ(*i.AddressOneNEQ))
	}
	if len(i.AddressOneIn) > 0 {
		predicates = append(predicates, addressglobal.AddressOneIn(i.AddressOneIn...))
	}
	if len(i.AddressOneNotIn) > 0 {
		predicates = append(predicates, addressglobal.AddressOneNotIn(i.AddressOneNotIn...))
	}
	if i.AddressOneGT != nil {
		predicates = append(predicates, addressglobal.AddressOneGT(*i.AddressOneGT))
	}
	if i.AddressOneGTE != nil {
		predicates = append(predicates, addressglobal.AddressOneGTE(*i.AddressOneGTE))
	}
	if i.AddressOneLT != nil {
		predicates = append(predicates, addressglobal.AddressOneLT(*i.AddressOneLT))
	}
	if i.AddressOneLTE != nil {
		predicates = append(predicates, addressglobal.AddressOneLTE(*i.AddressOneLTE))
	}
	if i.AddressOneContains != nil {
		predicates = append(predicates, addressglobal.AddressOneContains(*i.AddressOneContains))
	}
	if i.AddressOneHasPrefix != nil {
		predicates = append(predicates, addressglobal.AddressOneHasPrefix(*i.AddressOneHasPrefix))
	}
	if i.AddressOneHasSuffix != nil {
		predicates = append(predicates, addressglobal.AddressOneHasSuffix(*i.AddressOneHasSuffix))
	}
	if i.AddressOneEqualFold != nil {
		predicates = append(predicates, addressglobal.AddressOneEqualFold(*i.AddressOneEqualFold))
	}
	if i.AddressOneContainsFold != nil {
		predicates = append(predicates, addressglobal.AddressOneContainsFold(*i.AddressOneContainsFold))
	}
	if i.AddressTwo != nil {
		predicates = append(predicates, addressglobal.AddressTwoEQ(*i.AddressTwo))
	}
	if i.AddressTwoNEQ != nil {
		predicates = append(predicates, addressglobal.AddressTwoNEQ(*i.AddressTwoNEQ))
	}
	if len(i.AddressTwoIn) > 0 {
		predicates = append(predicates, addressglobal.AddressTwoIn(i.AddressTwoIn...))
	}
	if len(i.AddressTwoNotIn) > 0 {
		predicates = append(predicates, addressglobal.AddressTwoNotIn(i.AddressTwoNotIn...))
	}
	if i.AddressTwoGT != nil {
		predicates = append(predicates, addressglobal.AddressTwoGT(*i.AddressTwoGT))
	}
	if i.AddressTwoGTE != nil {
		predicates = append(predicates, addressglobal.AddressTwoGTE(*i.AddressTwoGTE))
	}
	if i.AddressTwoLT != nil {
		predicates = append(predicates, addressglobal.AddressTwoLT(*i.AddressTwoLT))
	}
	if i.AddressTwoLTE != nil {
		predicates = append(predicates, addressglobal.AddressTwoLTE(*i.AddressTwoLTE))
	}
	if i.AddressTwoContains != nil {
		predicates = append(predicates, addressglobal.AddressTwoContains(*i.AddressTwoContains))
	}
	if i.AddressTwoHasPrefix != nil {
		predicates = append(predicates, addressglobal.AddressTwoHasPrefix(*i.AddressTwoHasPrefix))
	}
	if i.AddressTwoHasSuffix != nil {
		predicates = append(predicates, addressglobal.AddressTwoHasSuffix(*i.AddressTwoHasSuffix))
	}
	if i.AddressTwoIsNil {
		predicates = append(predicates, addressglobal.AddressTwoIsNil())
	}
	if i.AddressTwoNotNil {
		predicates = append(predicates, addressglobal.AddressTwoNotNil())
	}
	if i.AddressTwoEqualFold != nil {
		predicates = append(predicates, addressglobal.AddressTwoEqualFold(*i.AddressTwoEqualFold))
	}
	if i.AddressTwoContainsFold != nil {
		predicates = append(predicates, addressglobal.AddressTwoContainsFold(*i.AddressTwoContainsFold))
	}
	if i.City != nil {
		predicates = append(predicates, addressglobal.CityEQ(*i.City))
	}
	if i.CityNEQ != nil {
		predicates = append(predicates, addressglobal.CityNEQ(*i.CityNEQ))
	}
	if len(i.CityIn) > 0 {
		predicates = append(predicates, addressglobal.CityIn(i.CityIn...))
	}
	if len(i.CityNotIn) > 0 {
		predicates = append(predicates, addressglobal.CityNotIn(i.CityNotIn...))
	}
	if i.CityGT != nil {
		predicates = append(predicates, addressglobal.CityGT(*i.CityGT))
	}
	if i.CityGTE != nil {
		predicates = append(predicates, addressglobal.CityGTE(*i.CityGTE))
	}
	if i.CityLT != nil {
		predicates = append(predicates, addressglobal.CityLT(*i.CityLT))
	}
	if i.CityLTE != nil {
		predicates = append(predicates, addressglobal.CityLTE(*i.CityLTE))
	}
	if i.CityContains != nil {
		predicates = append(predicates, addressglobal.CityContains(*i.CityContains))
	}
	if i.CityHasPrefix != nil {
		predicates = append(predicates, addressglobal.CityHasPrefix(*i.CityHasPrefix))
	}
	if i.CityHasSuffix != nil {
		predicates = append(predicates, addressglobal.CityHasSuffix(*i.CityHasSuffix))
	}
	if i.CityEqualFold != nil {
		predicates = append(predicates, addressglobal.CityEqualFold(*i.CityEqualFold))
	}
	if i.CityContainsFold != nil {
		predicates = append(predicates, addressglobal.CityContainsFold(*i.CityContainsFold))
	}
	if i.State != nil {
		predicates = append(predicates, addressglobal.StateEQ(*i.State))
	}
	if i.StateNEQ != nil {
		predicates = append(predicates, addressglobal.StateNEQ(*i.StateNEQ))
	}
	if len(i.StateIn) > 0 {
		predicates = append(predicates, addressglobal.StateIn(i.StateIn...))
	}
	if len(i.StateNotIn) > 0 {
		predicates = append(predicates, addressglobal.StateNotIn(i.StateNotIn...))
	}
	if i.StateGT != nil {
		predicates = append(predicates, addressglobal.StateGT(*i.StateGT))
	}
	if i.StateGTE != nil {
		predicates = append(predicates, addressglobal.StateGTE(*i.StateGTE))
	}
	if i.StateLT != nil {
		predicates = append(predicates, addressglobal.StateLT(*i.StateLT))
	}
	if i.StateLTE != nil {
		predicates = append(predicates, addressglobal.StateLTE(*i.StateLTE))
	}
	if i.StateContains != nil {
		predicates = append(predicates, addressglobal.StateContains(*i.StateContains))
	}
	if i.StateHasPrefix != nil {
		predicates = append(predicates, addressglobal.StateHasPrefix(*i.StateHasPrefix))
	}
	if i.StateHasSuffix != nil {
		predicates = append(predicates, addressglobal.StateHasSuffix(*i.StateHasSuffix))
	}
	if i.StateIsNil {
		predicates = append(predicates, addressglobal.StateIsNil())
	}
	if i.StateNotNil {
		predicates = append(predicates, addressglobal.StateNotNil())
	}
	if i.StateEqualFold != nil {
		predicates = append(predicates, addressglobal.StateEqualFold(*i.StateEqualFold))
	}
	if i.StateContainsFold != nil {
		predicates = append(predicates, addressglobal.StateContainsFold(*i.StateContainsFold))
	}
	if i.Zip != nil {
		predicates = append(predicates, addressglobal.ZipEQ(*i.Zip))
	}
	if i.ZipNEQ != nil {
		predicates = append(predicates, addressglobal.ZipNEQ(*i.ZipNEQ))
	}
	if len(i.ZipIn) > 0 {
		predicates = append(predicates, addressglobal.ZipIn(i.ZipIn...))
	}
	if len(i.ZipNotIn) > 0 {
		predicates = append(predicates, addressglobal.ZipNotIn(i.ZipNotIn...))
	}
	if i.ZipGT != nil {
		predicates = append(predicates, addressglobal.ZipGT(*i.ZipGT))
	}
	if i.ZipGTE != nil {
		predicates = append(predicates, addressglobal.ZipGTE(*i.ZipGTE))
	}
	if i.ZipLT != nil {
		predicates = append(predicates, addressglobal.ZipLT(*i.ZipLT))
	}
	if i.ZipLTE != nil {
		predicates = append(predicates, addressglobal.ZipLTE(*i.ZipLTE))
	}
	if i.ZipContains != nil {
		predicates = append(predicates, addressglobal.ZipContains(*i.ZipContains))
	}
	if i.ZipHasPrefix != nil {
		predicates = append(predicates, addressglobal.ZipHasPrefix(*i.ZipHasPrefix))
	}
	if i.ZipHasSuffix != nil {
		predicates = append(predicates, addressglobal.ZipHasSuffix(*i.ZipHasSuffix))
	}
	if i.ZipEqualFold != nil {
		predicates = append(predicates, addressglobal.ZipEqualFold(*i.ZipEqualFold))
	}
	if i.ZipContainsFold != nil {
		predicates = append(predicates, addressglobal.ZipContainsFold(*i.ZipContainsFold))
	}
	if i.Latitude != nil {
		predicates = append(predicates, addressglobal.LatitudeEQ(*i.Latitude))
	}
	if i.LatitudeNEQ != nil {
		predicates = append(predicates, addressglobal.LatitudeNEQ(*i.LatitudeNEQ))
	}
	if len(i.LatitudeIn) > 0 {
		predicates = append(predicates, addressglobal.LatitudeIn(i.LatitudeIn...))
	}
	if len(i.LatitudeNotIn) > 0 {
		predicates = append(predicates, addressglobal.LatitudeNotIn(i.LatitudeNotIn...))
	}
	if i.LatitudeGT != nil {
		predicates = append(predicates, addressglobal.LatitudeGT(*i.LatitudeGT))
	}
	if i.LatitudeGTE != nil {
		predicates = append(predicates, addressglobal.LatitudeGTE(*i.LatitudeGTE))
	}
	if i.LatitudeLT != nil {
		predicates = append(predicates, addressglobal.LatitudeLT(*i.LatitudeLT))
	}
	if i.LatitudeLTE != nil {
		predicates = append(predicates, addressglobal.LatitudeLTE(*i.LatitudeLTE))
	}
	if i.Longitude != nil {
		predicates = append(predicates, addressglobal.LongitudeEQ(*i.Longitude))
	}
	if i.LongitudeNEQ != nil {
		predicates = append(predicates, addressglobal.LongitudeNEQ(*i.LongitudeNEQ))
	}
	if len(i.LongitudeIn) > 0 {
		predicates = append(predicates, addressglobal.LongitudeIn(i.LongitudeIn...))
	}
	if len(i.LongitudeNotIn) > 0 {
		predicates = append(predicates, addressglobal.LongitudeNotIn(i.LongitudeNotIn...))
	}
	if i.LongitudeGT != nil {
		predicates = append(predicates, addressglobal.LongitudeGT(*i.LongitudeGT))
	}
	if i.LongitudeGTE != nil {
		predicates = append(predicates, addressglobal.LongitudeGTE(*i.LongitudeGTE))
	}
	if i.LongitudeLT != nil {
		predicates = append(predicates, addressglobal.LongitudeLT(*i.LongitudeLT))
	}
	if i.LongitudeLTE != nil {
		predicates = append(predicates, addressglobal.LongitudeLTE(*i.LongitudeLTE))
	}

	if i.HasParcelShopPostNordDelivery != nil {
		p := addressglobal.HasParcelShopPostNordDelivery()
		if !*i.HasParcelShopPostNordDelivery {
			p = addressglobal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopPostNordDeliveryWith) > 0 {
		with := make([]predicate.ParcelShopPostNord, 0, len(i.HasParcelShopPostNordDeliveryWith))
		for _, w := range i.HasParcelShopPostNordDeliveryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopPostNordDeliveryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, addressglobal.HasParcelShopPostNordDeliveryWith(with...))
	}
	if i.HasParcelShopBringDelivery != nil {
		p := addressglobal.HasParcelShopBringDelivery()
		if !*i.HasParcelShopBringDelivery {
			p = addressglobal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopBringDeliveryWith) > 0 {
		with := make([]predicate.ParcelShopBring, 0, len(i.HasParcelShopBringDeliveryWith))
		for _, w := range i.HasParcelShopBringDeliveryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopBringDeliveryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, addressglobal.HasParcelShopBringDeliveryWith(with...))
	}
	if i.HasParcelShop != nil {
		p := addressglobal.HasParcelShop()
		if !*i.HasParcelShop {
			p = addressglobal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopWith) > 0 {
		with := make([]predicate.ParcelShop, 0, len(i.HasParcelShopWith))
		for _, w := range i.HasParcelShopWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, addressglobal.HasParcelShopWith(with...))
	}
	if i.HasCountry != nil {
		p := addressglobal.HasCountry()
		if !*i.HasCountry {
			p = addressglobal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, addressglobal.HasCountryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyAddressGlobalWhereInput
	case 1:
		return predicates[0], nil
	default:
		return addressglobal.And(predicates...), nil
	}
}

// BusinessHoursPeriodWhereInput represents a where input for filtering BusinessHoursPeriod queries.
type BusinessHoursPeriodWhereInput struct {
	Predicates []predicate.BusinessHoursPeriod  `json:"-"`
	Not        *BusinessHoursPeriodWhereInput   `json:"not,omitempty"`
	Or         []*BusinessHoursPeriodWhereInput `json:"or,omitempty"`
	And        []*BusinessHoursPeriodWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "day_of_week" field predicates.
	DayOfWeek      *businesshoursperiod.DayOfWeek  `json:"dayOfWeek,omitempty"`
	DayOfWeekNEQ   *businesshoursperiod.DayOfWeek  `json:"dayOfWeekNEQ,omitempty"`
	DayOfWeekIn    []businesshoursperiod.DayOfWeek `json:"dayOfWeekIn,omitempty"`
	DayOfWeekNotIn []businesshoursperiod.DayOfWeek `json:"dayOfWeekNotIn,omitempty"`

	// "opening" field predicates.
	Opening      *time.Time  `json:"opening,omitempty"`
	OpeningNEQ   *time.Time  `json:"openingNEQ,omitempty"`
	OpeningIn    []time.Time `json:"openingIn,omitempty"`
	OpeningNotIn []time.Time `json:"openingNotIn,omitempty"`
	OpeningGT    *time.Time  `json:"openingGT,omitempty"`
	OpeningGTE   *time.Time  `json:"openingGTE,omitempty"`
	OpeningLT    *time.Time  `json:"openingLT,omitempty"`
	OpeningLTE   *time.Time  `json:"openingLTE,omitempty"`

	// "closing" field predicates.
	Closing      *time.Time  `json:"closing,omitempty"`
	ClosingNEQ   *time.Time  `json:"closingNEQ,omitempty"`
	ClosingIn    []time.Time `json:"closingIn,omitempty"`
	ClosingNotIn []time.Time `json:"closingNotIn,omitempty"`
	ClosingGT    *time.Time  `json:"closingGT,omitempty"`
	ClosingGTE   *time.Time  `json:"closingGTE,omitempty"`
	ClosingLT    *time.Time  `json:"closingLT,omitempty"`
	ClosingLTE   *time.Time  `json:"closingLTE,omitempty"`

	// "parcel_shop" edge predicates.
	HasParcelShop     *bool                   `json:"hasParcelShop,omitempty"`
	HasParcelShopWith []*ParcelShopWhereInput `json:"hasParcelShopWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *BusinessHoursPeriodWhereInput) AddPredicates(predicates ...predicate.BusinessHoursPeriod) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the BusinessHoursPeriodWhereInput filter on the BusinessHoursPeriodQuery builder.
func (i *BusinessHoursPeriodWhereInput) Filter(q *BusinessHoursPeriodQuery) (*BusinessHoursPeriodQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyBusinessHoursPeriodWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyBusinessHoursPeriodWhereInput is returned in case the BusinessHoursPeriodWhereInput is empty.
var ErrEmptyBusinessHoursPeriodWhereInput = errors.New("ent: empty predicate BusinessHoursPeriodWhereInput")

// P returns a predicate for filtering businesshoursperiods.
// An error is returned if the input is empty or invalid.
func (i *BusinessHoursPeriodWhereInput) P() (predicate.BusinessHoursPeriod, error) {
	var predicates []predicate.BusinessHoursPeriod
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, businesshoursperiod.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.BusinessHoursPeriod, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, businesshoursperiod.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.BusinessHoursPeriod, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, businesshoursperiod.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, businesshoursperiod.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, businesshoursperiod.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, businesshoursperiod.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, businesshoursperiod.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, businesshoursperiod.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, businesshoursperiod.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, businesshoursperiod.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, businesshoursperiod.IDLTE(*i.IDLTE))
	}
	if i.DayOfWeek != nil {
		predicates = append(predicates, businesshoursperiod.DayOfWeekEQ(*i.DayOfWeek))
	}
	if i.DayOfWeekNEQ != nil {
		predicates = append(predicates, businesshoursperiod.DayOfWeekNEQ(*i.DayOfWeekNEQ))
	}
	if len(i.DayOfWeekIn) > 0 {
		predicates = append(predicates, businesshoursperiod.DayOfWeekIn(i.DayOfWeekIn...))
	}
	if len(i.DayOfWeekNotIn) > 0 {
		predicates = append(predicates, businesshoursperiod.DayOfWeekNotIn(i.DayOfWeekNotIn...))
	}
	if i.Opening != nil {
		predicates = append(predicates, businesshoursperiod.OpeningEQ(*i.Opening))
	}
	if i.OpeningNEQ != nil {
		predicates = append(predicates, businesshoursperiod.OpeningNEQ(*i.OpeningNEQ))
	}
	if len(i.OpeningIn) > 0 {
		predicates = append(predicates, businesshoursperiod.OpeningIn(i.OpeningIn...))
	}
	if len(i.OpeningNotIn) > 0 {
		predicates = append(predicates, businesshoursperiod.OpeningNotIn(i.OpeningNotIn...))
	}
	if i.OpeningGT != nil {
		predicates = append(predicates, businesshoursperiod.OpeningGT(*i.OpeningGT))
	}
	if i.OpeningGTE != nil {
		predicates = append(predicates, businesshoursperiod.OpeningGTE(*i.OpeningGTE))
	}
	if i.OpeningLT != nil {
		predicates = append(predicates, businesshoursperiod.OpeningLT(*i.OpeningLT))
	}
	if i.OpeningLTE != nil {
		predicates = append(predicates, businesshoursperiod.OpeningLTE(*i.OpeningLTE))
	}
	if i.Closing != nil {
		predicates = append(predicates, businesshoursperiod.ClosingEQ(*i.Closing))
	}
	if i.ClosingNEQ != nil {
		predicates = append(predicates, businesshoursperiod.ClosingNEQ(*i.ClosingNEQ))
	}
	if len(i.ClosingIn) > 0 {
		predicates = append(predicates, businesshoursperiod.ClosingIn(i.ClosingIn...))
	}
	if len(i.ClosingNotIn) > 0 {
		predicates = append(predicates, businesshoursperiod.ClosingNotIn(i.ClosingNotIn...))
	}
	if i.ClosingGT != nil {
		predicates = append(predicates, businesshoursperiod.ClosingGT(*i.ClosingGT))
	}
	if i.ClosingGTE != nil {
		predicates = append(predicates, businesshoursperiod.ClosingGTE(*i.ClosingGTE))
	}
	if i.ClosingLT != nil {
		predicates = append(predicates, businesshoursperiod.ClosingLT(*i.ClosingLT))
	}
	if i.ClosingLTE != nil {
		predicates = append(predicates, businesshoursperiod.ClosingLTE(*i.ClosingLTE))
	}

	if i.HasParcelShop != nil {
		p := businesshoursperiod.HasParcelShop()
		if !*i.HasParcelShop {
			p = businesshoursperiod.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopWith) > 0 {
		with := make([]predicate.ParcelShop, 0, len(i.HasParcelShopWith))
		for _, w := range i.HasParcelShopWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, businesshoursperiod.HasParcelShopWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyBusinessHoursPeriodWhereInput
	case 1:
		return predicates[0], nil
	default:
		return businesshoursperiod.And(predicates...), nil
	}
}

// CarrierWhereInput represents a where input for filtering Carrier queries.
type CarrierWhereInput struct {
	Predicates []predicate.Carrier  `json:"-"`
	Not        *CarrierWhereInput   `json:"not,omitempty"`
	Or         []*CarrierWhereInput `json:"or,omitempty"`
	And        []*CarrierWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "sync_cancelation" field predicates.
	SyncCancelation    *bool `json:"syncCancelation,omitempty"`
	SyncCancelationNEQ *bool `json:"syncCancelationNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier_brand" edge predicates.
	HasCarrierBrand     *bool                     `json:"hasCarrierBrand,omitempty"`
	HasCarrierBrandWith []*CarrierBrandWhereInput `json:"hasCarrierBrandWith,omitempty"`

	// "carrier_dao" edge predicates.
	HasCarrierDAO     *bool                   `json:"hasCarrierDAO,omitempty"`
	HasCarrierDAOWith []*CarrierDAOWhereInput `json:"hasCarrierDAOWith,omitempty"`

	// "carrier_df" edge predicates.
	HasCarrierDF     *bool                  `json:"hasCarrierDF,omitempty"`
	HasCarrierDFWith []*CarrierDFWhereInput `json:"hasCarrierDFWith,omitempty"`

	// "carrier_dsv" edge predicates.
	HasCarrierDSV     *bool                   `json:"hasCarrierDSV,omitempty"`
	HasCarrierDSVWith []*CarrierDSVWhereInput `json:"hasCarrierDSVWith,omitempty"`

	// "carrier_easy_post" edge predicates.
	HasCarrierEasyPost     *bool                        `json:"hasCarrierEasyPost,omitempty"`
	HasCarrierEasyPostWith []*CarrierEasyPostWhereInput `json:"hasCarrierEasyPostWith,omitempty"`

	// "carrier_gls" edge predicates.
	HasCarrierGLS     *bool                   `json:"hasCarrierGLS,omitempty"`
	HasCarrierGLSWith []*CarrierGLSWhereInput `json:"hasCarrierGLSWith,omitempty"`

	// "carrier_post_nord" edge predicates.
	HasCarrierPostNord     *bool                        `json:"hasCarrierPostNord,omitempty"`
	HasCarrierPostNordWith []*CarrierPostNordWhereInput `json:"hasCarrierPostNordWith,omitempty"`

	// "carrier_usps" edge predicates.
	HasCarrierUSPS     *bool                    `json:"hasCarrierUSPS,omitempty"`
	HasCarrierUSPSWith []*CarrierUSPSWhereInput `json:"hasCarrierUSPSWith,omitempty"`

	// "carrier_bring" edge predicates.
	HasCarrierBring     *bool                     `json:"hasCarrierBring,omitempty"`
	HasCarrierBringWith []*CarrierBringWhereInput `json:"hasCarrierBringWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierWhereInput) AddPredicates(predicates ...predicate.Carrier) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierWhereInput filter on the CarrierQuery builder.
func (i *CarrierWhereInput) Filter(q *CarrierQuery) (*CarrierQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierWhereInput is returned in case the CarrierWhereInput is empty.
var ErrEmptyCarrierWhereInput = errors.New("ent: empty predicate CarrierWhereInput")

// P returns a predicate for filtering carriers.
// An error is returned if the input is empty or invalid.
func (i *CarrierWhereInput) P() (predicate.Carrier, error) {
	var predicates []predicate.Carrier
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrier.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Carrier, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrier.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Carrier, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrier.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrier.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrier.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrier.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrier.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrier.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrier.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrier.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrier.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, carrier.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, carrier.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, carrier.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, carrier.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, carrier.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, carrier.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, carrier.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, carrier.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, carrier.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, carrier.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, carrier.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, carrier.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, carrier.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, carrier.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, carrier.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, carrier.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, carrier.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, carrier.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, carrier.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, carrier.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, carrier.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, carrier.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, carrier.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, carrier.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, carrier.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, carrier.NameContainsFold(*i.NameContainsFold))
	}
	if i.SyncCancelation != nil {
		predicates = append(predicates, carrier.SyncCancelationEQ(*i.SyncCancelation))
	}
	if i.SyncCancelationNEQ != nil {
		predicates = append(predicates, carrier.SyncCancelationNEQ(*i.SyncCancelationNEQ))
	}

	if i.HasTenant != nil {
		p := carrier.HasTenant()
		if !*i.HasTenant {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasTenantWith(with...))
	}
	if i.HasCarrierBrand != nil {
		p := carrier.HasCarrierBrand()
		if !*i.HasCarrierBrand {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierBrandWith) > 0 {
		with := make([]predicate.CarrierBrand, 0, len(i.HasCarrierBrandWith))
		for _, w := range i.HasCarrierBrandWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierBrandWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasCarrierBrandWith(with...))
	}
	if i.HasCarrierDAO != nil {
		p := carrier.HasCarrierDAO()
		if !*i.HasCarrierDAO {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierDAOWith) > 0 {
		with := make([]predicate.CarrierDAO, 0, len(i.HasCarrierDAOWith))
		for _, w := range i.HasCarrierDAOWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierDAOWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasCarrierDAOWith(with...))
	}
	if i.HasCarrierDF != nil {
		p := carrier.HasCarrierDF()
		if !*i.HasCarrierDF {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierDFWith) > 0 {
		with := make([]predicate.CarrierDF, 0, len(i.HasCarrierDFWith))
		for _, w := range i.HasCarrierDFWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierDFWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasCarrierDFWith(with...))
	}
	if i.HasCarrierDSV != nil {
		p := carrier.HasCarrierDSV()
		if !*i.HasCarrierDSV {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierDSVWith) > 0 {
		with := make([]predicate.CarrierDSV, 0, len(i.HasCarrierDSVWith))
		for _, w := range i.HasCarrierDSVWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierDSVWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasCarrierDSVWith(with...))
	}
	if i.HasCarrierEasyPost != nil {
		p := carrier.HasCarrierEasyPost()
		if !*i.HasCarrierEasyPost {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierEasyPostWith) > 0 {
		with := make([]predicate.CarrierEasyPost, 0, len(i.HasCarrierEasyPostWith))
		for _, w := range i.HasCarrierEasyPostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierEasyPostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasCarrierEasyPostWith(with...))
	}
	if i.HasCarrierGLS != nil {
		p := carrier.HasCarrierGLS()
		if !*i.HasCarrierGLS {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierGLSWith) > 0 {
		with := make([]predicate.CarrierGLS, 0, len(i.HasCarrierGLSWith))
		for _, w := range i.HasCarrierGLSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierGLSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasCarrierGLSWith(with...))
	}
	if i.HasCarrierPostNord != nil {
		p := carrier.HasCarrierPostNord()
		if !*i.HasCarrierPostNord {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierPostNordWith) > 0 {
		with := make([]predicate.CarrierPostNord, 0, len(i.HasCarrierPostNordWith))
		for _, w := range i.HasCarrierPostNordWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierPostNordWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasCarrierPostNordWith(with...))
	}
	if i.HasCarrierUSPS != nil {
		p := carrier.HasCarrierUSPS()
		if !*i.HasCarrierUSPS {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierUSPSWith) > 0 {
		with := make([]predicate.CarrierUSPS, 0, len(i.HasCarrierUSPSWith))
		for _, w := range i.HasCarrierUSPSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierUSPSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasCarrierUSPSWith(with...))
	}
	if i.HasCarrierBring != nil {
		p := carrier.HasCarrierBring()
		if !*i.HasCarrierBring {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierBringWith) > 0 {
		with := make([]predicate.CarrierBring, 0, len(i.HasCarrierBringWith))
		for _, w := range i.HasCarrierBringWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierBringWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasCarrierBringWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := carrier.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasDeliveryOptionWith(with...))
	}
	if i.HasShipment != nil {
		p := carrier.HasShipment()
		if !*i.HasShipment {
			p = carrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrier.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrier.And(predicates...), nil
	}
}

// CarrierAdditionalServiceBringWhereInput represents a where input for filtering CarrierAdditionalServiceBring queries.
type CarrierAdditionalServiceBringWhereInput struct {
	Predicates []predicate.CarrierAdditionalServiceBring  `json:"-"`
	Not        *CarrierAdditionalServiceBringWhereInput   `json:"not,omitempty"`
	Or         []*CarrierAdditionalServiceBringWhereInput `json:"or,omitempty"`
	And        []*CarrierAdditionalServiceBringWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "api_code_booking" field predicates.
	APICodeBooking             *string  `json:"apiCodeBooking,omitempty"`
	APICodeBookingNEQ          *string  `json:"apiCodeBookingNEQ,omitempty"`
	APICodeBookingIn           []string `json:"apiCodeBookingIn,omitempty"`
	APICodeBookingNotIn        []string `json:"apiCodeBookingNotIn,omitempty"`
	APICodeBookingGT           *string  `json:"apiCodeBookingGT,omitempty"`
	APICodeBookingGTE          *string  `json:"apiCodeBookingGTE,omitempty"`
	APICodeBookingLT           *string  `json:"apiCodeBookingLT,omitempty"`
	APICodeBookingLTE          *string  `json:"apiCodeBookingLTE,omitempty"`
	APICodeBookingContains     *string  `json:"apiCodeBookingContains,omitempty"`
	APICodeBookingHasPrefix    *string  `json:"apiCodeBookingHasPrefix,omitempty"`
	APICodeBookingHasSuffix    *string  `json:"apiCodeBookingHasSuffix,omitempty"`
	APICodeBookingEqualFold    *string  `json:"apiCodeBookingEqualFold,omitempty"`
	APICodeBookingContainsFold *string  `json:"apiCodeBookingContainsFold,omitempty"`

	// "carrier_service_bring" edge predicates.
	HasCarrierServiceBring     *bool                            `json:"hasCarrierServiceBring,omitempty"`
	HasCarrierServiceBringWith []*CarrierServiceBringWhereInput `json:"hasCarrierServiceBringWith,omitempty"`

	// "delivery_option_bring" edge predicates.
	HasDeliveryOptionBring     *bool                            `json:"hasDeliveryOptionBring,omitempty"`
	HasDeliveryOptionBringWith []*DeliveryOptionBringWhereInput `json:"hasDeliveryOptionBringWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierAdditionalServiceBringWhereInput) AddPredicates(predicates ...predicate.CarrierAdditionalServiceBring) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierAdditionalServiceBringWhereInput filter on the CarrierAdditionalServiceBringQuery builder.
func (i *CarrierAdditionalServiceBringWhereInput) Filter(q *CarrierAdditionalServiceBringQuery) (*CarrierAdditionalServiceBringQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierAdditionalServiceBringWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierAdditionalServiceBringWhereInput is returned in case the CarrierAdditionalServiceBringWhereInput is empty.
var ErrEmptyCarrierAdditionalServiceBringWhereInput = errors.New("ent: empty predicate CarrierAdditionalServiceBringWhereInput")

// P returns a predicate for filtering carrieradditionalservicebrings.
// An error is returned if the input is empty or invalid.
func (i *CarrierAdditionalServiceBringWhereInput) P() (predicate.CarrierAdditionalServiceBring, error) {
	var predicates []predicate.CarrierAdditionalServiceBring
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrieradditionalservicebring.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierAdditionalServiceBring, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrieradditionalservicebring.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierAdditionalServiceBring, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrieradditionalservicebring.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrieradditionalservicebring.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrieradditionalservicebring.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrieradditionalservicebring.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicebring.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrieradditionalservicebring.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrieradditionalservicebring.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrieradditionalservicebring.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrieradditionalservicebring.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrieradditionalservicebring.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicebring.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicebring.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.APICodeBooking != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingEQ(*i.APICodeBooking))
	}
	if i.APICodeBookingNEQ != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingNEQ(*i.APICodeBookingNEQ))
	}
	if len(i.APICodeBookingIn) > 0 {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingIn(i.APICodeBookingIn...))
	}
	if len(i.APICodeBookingNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingNotIn(i.APICodeBookingNotIn...))
	}
	if i.APICodeBookingGT != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingGT(*i.APICodeBookingGT))
	}
	if i.APICodeBookingGTE != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingGTE(*i.APICodeBookingGTE))
	}
	if i.APICodeBookingLT != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingLT(*i.APICodeBookingLT))
	}
	if i.APICodeBookingLTE != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingLTE(*i.APICodeBookingLTE))
	}
	if i.APICodeBookingContains != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingContains(*i.APICodeBookingContains))
	}
	if i.APICodeBookingHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingHasPrefix(*i.APICodeBookingHasPrefix))
	}
	if i.APICodeBookingHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingHasSuffix(*i.APICodeBookingHasSuffix))
	}
	if i.APICodeBookingEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingEqualFold(*i.APICodeBookingEqualFold))
	}
	if i.APICodeBookingContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicebring.APICodeBookingContainsFold(*i.APICodeBookingContainsFold))
	}

	if i.HasCarrierServiceBring != nil {
		p := carrieradditionalservicebring.HasCarrierServiceBring()
		if !*i.HasCarrierServiceBring {
			p = carrieradditionalservicebring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceBringWith) > 0 {
		with := make([]predicate.CarrierServiceBring, 0, len(i.HasCarrierServiceBringWith))
		for _, w := range i.HasCarrierServiceBringWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceBringWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicebring.HasCarrierServiceBringWith(with...))
	}
	if i.HasDeliveryOptionBring != nil {
		p := carrieradditionalservicebring.HasDeliveryOptionBring()
		if !*i.HasDeliveryOptionBring {
			p = carrieradditionalservicebring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionBringWith) > 0 {
		with := make([]predicate.DeliveryOptionBring, 0, len(i.HasDeliveryOptionBringWith))
		for _, w := range i.HasDeliveryOptionBringWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionBringWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicebring.HasDeliveryOptionBringWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierAdditionalServiceBringWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrieradditionalservicebring.And(predicates...), nil
	}
}

// CarrierAdditionalServiceDAOWhereInput represents a where input for filtering CarrierAdditionalServiceDAO queries.
type CarrierAdditionalServiceDAOWhereInput struct {
	Predicates []predicate.CarrierAdditionalServiceDAO  `json:"-"`
	Not        *CarrierAdditionalServiceDAOWhereInput   `json:"not,omitempty"`
	Or         []*CarrierAdditionalServiceDAOWhereInput `json:"or,omitempty"`
	And        []*CarrierAdditionalServiceDAOWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "api_code" field predicates.
	APICode             *string  `json:"apiCode,omitempty"`
	APICodeNEQ          *string  `json:"apiCodeNEQ,omitempty"`
	APICodeIn           []string `json:"apiCodeIn,omitempty"`
	APICodeNotIn        []string `json:"apiCodeNotIn,omitempty"`
	APICodeGT           *string  `json:"apiCodeGT,omitempty"`
	APICodeGTE          *string  `json:"apiCodeGTE,omitempty"`
	APICodeLT           *string  `json:"apiCodeLT,omitempty"`
	APICodeLTE          *string  `json:"apiCodeLTE,omitempty"`
	APICodeContains     *string  `json:"apiCodeContains,omitempty"`
	APICodeHasPrefix    *string  `json:"apiCodeHasPrefix,omitempty"`
	APICodeHasSuffix    *string  `json:"apiCodeHasSuffix,omitempty"`
	APICodeEqualFold    *string  `json:"apiCodeEqualFold,omitempty"`
	APICodeContainsFold *string  `json:"apiCodeContainsFold,omitempty"`

	// "carrier_service_dao" edge predicates.
	HasCarrierServiceDAO     *bool                          `json:"hasCarrierServiceDAO,omitempty"`
	HasCarrierServiceDAOWith []*CarrierServiceDAOWhereInput `json:"hasCarrierServiceDAOWith,omitempty"`

	// "delivery_option_dao" edge predicates.
	HasDeliveryOptionDAO     *bool                          `json:"hasDeliveryOptionDAO,omitempty"`
	HasDeliveryOptionDAOWith []*DeliveryOptionDAOWhereInput `json:"hasDeliveryOptionDAOWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierAdditionalServiceDAOWhereInput) AddPredicates(predicates ...predicate.CarrierAdditionalServiceDAO) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierAdditionalServiceDAOWhereInput filter on the CarrierAdditionalServiceDAOQuery builder.
func (i *CarrierAdditionalServiceDAOWhereInput) Filter(q *CarrierAdditionalServiceDAOQuery) (*CarrierAdditionalServiceDAOQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierAdditionalServiceDAOWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierAdditionalServiceDAOWhereInput is returned in case the CarrierAdditionalServiceDAOWhereInput is empty.
var ErrEmptyCarrierAdditionalServiceDAOWhereInput = errors.New("ent: empty predicate CarrierAdditionalServiceDAOWhereInput")

// P returns a predicate for filtering carrieradditionalservicedaos.
// An error is returned if the input is empty or invalid.
func (i *CarrierAdditionalServiceDAOWhereInput) P() (predicate.CarrierAdditionalServiceDAO, error) {
	var predicates []predicate.CarrierAdditionalServiceDAO
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrieradditionalservicedao.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierAdditionalServiceDAO, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrieradditionalservicedao.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierAdditionalServiceDAO, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrieradditionalservicedao.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrieradditionalservicedao.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrieradditionalservicedao.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedao.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedao.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrieradditionalservicedao.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrieradditionalservicedao.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrieradditionalservicedao.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrieradditionalservicedao.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedao.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedao.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicedao.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.APICode != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeEQ(*i.APICode))
	}
	if i.APICodeNEQ != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeNEQ(*i.APICodeNEQ))
	}
	if len(i.APICodeIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedao.APICodeIn(i.APICodeIn...))
	}
	if len(i.APICodeNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedao.APICodeNotIn(i.APICodeNotIn...))
	}
	if i.APICodeGT != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeGT(*i.APICodeGT))
	}
	if i.APICodeGTE != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeGTE(*i.APICodeGTE))
	}
	if i.APICodeLT != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeLT(*i.APICodeLT))
	}
	if i.APICodeLTE != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeLTE(*i.APICodeLTE))
	}
	if i.APICodeContains != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeContains(*i.APICodeContains))
	}
	if i.APICodeHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeHasPrefix(*i.APICodeHasPrefix))
	}
	if i.APICodeHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeHasSuffix(*i.APICodeHasSuffix))
	}
	if i.APICodeEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeEqualFold(*i.APICodeEqualFold))
	}
	if i.APICodeContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicedao.APICodeContainsFold(*i.APICodeContainsFold))
	}

	if i.HasCarrierServiceDAO != nil {
		p := carrieradditionalservicedao.HasCarrierServiceDAO()
		if !*i.HasCarrierServiceDAO {
			p = carrieradditionalservicedao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceDAOWith) > 0 {
		with := make([]predicate.CarrierServiceDAO, 0, len(i.HasCarrierServiceDAOWith))
		for _, w := range i.HasCarrierServiceDAOWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceDAOWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicedao.HasCarrierServiceDAOWith(with...))
	}
	if i.HasDeliveryOptionDAO != nil {
		p := carrieradditionalservicedao.HasDeliveryOptionDAO()
		if !*i.HasDeliveryOptionDAO {
			p = carrieradditionalservicedao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionDAOWith) > 0 {
		with := make([]predicate.DeliveryOptionDAO, 0, len(i.HasDeliveryOptionDAOWith))
		for _, w := range i.HasDeliveryOptionDAOWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionDAOWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicedao.HasDeliveryOptionDAOWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierAdditionalServiceDAOWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrieradditionalservicedao.And(predicates...), nil
	}
}

// CarrierAdditionalServiceDFWhereInput represents a where input for filtering CarrierAdditionalServiceDF queries.
type CarrierAdditionalServiceDFWhereInput struct {
	Predicates []predicate.CarrierAdditionalServiceDF  `json:"-"`
	Not        *CarrierAdditionalServiceDFWhereInput   `json:"not,omitempty"`
	Or         []*CarrierAdditionalServiceDFWhereInput `json:"or,omitempty"`
	And        []*CarrierAdditionalServiceDFWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "api_code" field predicates.
	APICode             *string  `json:"apiCode,omitempty"`
	APICodeNEQ          *string  `json:"apiCodeNEQ,omitempty"`
	APICodeIn           []string `json:"apiCodeIn,omitempty"`
	APICodeNotIn        []string `json:"apiCodeNotIn,omitempty"`
	APICodeGT           *string  `json:"apiCodeGT,omitempty"`
	APICodeGTE          *string  `json:"apiCodeGTE,omitempty"`
	APICodeLT           *string  `json:"apiCodeLT,omitempty"`
	APICodeLTE          *string  `json:"apiCodeLTE,omitempty"`
	APICodeContains     *string  `json:"apiCodeContains,omitempty"`
	APICodeHasPrefix    *string  `json:"apiCodeHasPrefix,omitempty"`
	APICodeHasSuffix    *string  `json:"apiCodeHasSuffix,omitempty"`
	APICodeEqualFold    *string  `json:"apiCodeEqualFold,omitempty"`
	APICodeContainsFold *string  `json:"apiCodeContainsFold,omitempty"`

	// "carrier_service_df" edge predicates.
	HasCarrierServiceDF     *bool                         `json:"hasCarrierServiceDF,omitempty"`
	HasCarrierServiceDFWith []*CarrierServiceDFWhereInput `json:"hasCarrierServiceDFWith,omitempty"`

	// "delivery_option_df" edge predicates.
	HasDeliveryOptionDF     *bool                         `json:"hasDeliveryOptionDF,omitempty"`
	HasDeliveryOptionDFWith []*DeliveryOptionDFWhereInput `json:"hasDeliveryOptionDFWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierAdditionalServiceDFWhereInput) AddPredicates(predicates ...predicate.CarrierAdditionalServiceDF) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierAdditionalServiceDFWhereInput filter on the CarrierAdditionalServiceDFQuery builder.
func (i *CarrierAdditionalServiceDFWhereInput) Filter(q *CarrierAdditionalServiceDFQuery) (*CarrierAdditionalServiceDFQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierAdditionalServiceDFWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierAdditionalServiceDFWhereInput is returned in case the CarrierAdditionalServiceDFWhereInput is empty.
var ErrEmptyCarrierAdditionalServiceDFWhereInput = errors.New("ent: empty predicate CarrierAdditionalServiceDFWhereInput")

// P returns a predicate for filtering carrieradditionalservicedfs.
// An error is returned if the input is empty or invalid.
func (i *CarrierAdditionalServiceDFWhereInput) P() (predicate.CarrierAdditionalServiceDF, error) {
	var predicates []predicate.CarrierAdditionalServiceDF
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrieradditionalservicedf.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierAdditionalServiceDF, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrieradditionalservicedf.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierAdditionalServiceDF, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrieradditionalservicedf.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrieradditionalservicedf.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrieradditionalservicedf.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedf.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedf.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrieradditionalservicedf.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrieradditionalservicedf.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrieradditionalservicedf.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrieradditionalservicedf.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedf.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedf.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicedf.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.APICode != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeEQ(*i.APICode))
	}
	if i.APICodeNEQ != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeNEQ(*i.APICodeNEQ))
	}
	if len(i.APICodeIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedf.APICodeIn(i.APICodeIn...))
	}
	if len(i.APICodeNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedf.APICodeNotIn(i.APICodeNotIn...))
	}
	if i.APICodeGT != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeGT(*i.APICodeGT))
	}
	if i.APICodeGTE != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeGTE(*i.APICodeGTE))
	}
	if i.APICodeLT != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeLT(*i.APICodeLT))
	}
	if i.APICodeLTE != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeLTE(*i.APICodeLTE))
	}
	if i.APICodeContains != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeContains(*i.APICodeContains))
	}
	if i.APICodeHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeHasPrefix(*i.APICodeHasPrefix))
	}
	if i.APICodeHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeHasSuffix(*i.APICodeHasSuffix))
	}
	if i.APICodeEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeEqualFold(*i.APICodeEqualFold))
	}
	if i.APICodeContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicedf.APICodeContainsFold(*i.APICodeContainsFold))
	}

	if i.HasCarrierServiceDF != nil {
		p := carrieradditionalservicedf.HasCarrierServiceDF()
		if !*i.HasCarrierServiceDF {
			p = carrieradditionalservicedf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceDFWith) > 0 {
		with := make([]predicate.CarrierServiceDF, 0, len(i.HasCarrierServiceDFWith))
		for _, w := range i.HasCarrierServiceDFWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceDFWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicedf.HasCarrierServiceDFWith(with...))
	}
	if i.HasDeliveryOptionDF != nil {
		p := carrieradditionalservicedf.HasDeliveryOptionDF()
		if !*i.HasDeliveryOptionDF {
			p = carrieradditionalservicedf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionDFWith) > 0 {
		with := make([]predicate.DeliveryOptionDF, 0, len(i.HasDeliveryOptionDFWith))
		for _, w := range i.HasDeliveryOptionDFWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionDFWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicedf.HasDeliveryOptionDFWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierAdditionalServiceDFWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrieradditionalservicedf.And(predicates...), nil
	}
}

// CarrierAdditionalServiceDSVWhereInput represents a where input for filtering CarrierAdditionalServiceDSV queries.
type CarrierAdditionalServiceDSVWhereInput struct {
	Predicates []predicate.CarrierAdditionalServiceDSV  `json:"-"`
	Not        *CarrierAdditionalServiceDSVWhereInput   `json:"not,omitempty"`
	Or         []*CarrierAdditionalServiceDSVWhereInput `json:"or,omitempty"`
	And        []*CarrierAdditionalServiceDSVWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "api_code" field predicates.
	APICode             *string  `json:"apiCode,omitempty"`
	APICodeNEQ          *string  `json:"apiCodeNEQ,omitempty"`
	APICodeIn           []string `json:"apiCodeIn,omitempty"`
	APICodeNotIn        []string `json:"apiCodeNotIn,omitempty"`
	APICodeGT           *string  `json:"apiCodeGT,omitempty"`
	APICodeGTE          *string  `json:"apiCodeGTE,omitempty"`
	APICodeLT           *string  `json:"apiCodeLT,omitempty"`
	APICodeLTE          *string  `json:"apiCodeLTE,omitempty"`
	APICodeContains     *string  `json:"apiCodeContains,omitempty"`
	APICodeHasPrefix    *string  `json:"apiCodeHasPrefix,omitempty"`
	APICodeHasSuffix    *string  `json:"apiCodeHasSuffix,omitempty"`
	APICodeEqualFold    *string  `json:"apiCodeEqualFold,omitempty"`
	APICodeContainsFold *string  `json:"apiCodeContainsFold,omitempty"`

	// "carrier_service_dsv" edge predicates.
	HasCarrierServiceDSV     *bool                          `json:"hasCarrierServiceDSV,omitempty"`
	HasCarrierServiceDSVWith []*CarrierServiceDSVWhereInput `json:"hasCarrierServiceDSVWith,omitempty"`

	// "delivery_option_dsv" edge predicates.
	HasDeliveryOptionDSV     *bool                          `json:"hasDeliveryOptionDSV,omitempty"`
	HasDeliveryOptionDSVWith []*DeliveryOptionDSVWhereInput `json:"hasDeliveryOptionDSVWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierAdditionalServiceDSVWhereInput) AddPredicates(predicates ...predicate.CarrierAdditionalServiceDSV) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierAdditionalServiceDSVWhereInput filter on the CarrierAdditionalServiceDSVQuery builder.
func (i *CarrierAdditionalServiceDSVWhereInput) Filter(q *CarrierAdditionalServiceDSVQuery) (*CarrierAdditionalServiceDSVQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierAdditionalServiceDSVWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierAdditionalServiceDSVWhereInput is returned in case the CarrierAdditionalServiceDSVWhereInput is empty.
var ErrEmptyCarrierAdditionalServiceDSVWhereInput = errors.New("ent: empty predicate CarrierAdditionalServiceDSVWhereInput")

// P returns a predicate for filtering carrieradditionalservicedsvs.
// An error is returned if the input is empty or invalid.
func (i *CarrierAdditionalServiceDSVWhereInput) P() (predicate.CarrierAdditionalServiceDSV, error) {
	var predicates []predicate.CarrierAdditionalServiceDSV
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrieradditionalservicedsv.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierAdditionalServiceDSV, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrieradditionalservicedsv.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierAdditionalServiceDSV, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrieradditionalservicedsv.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrieradditionalservicedsv.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrieradditionalservicedsv.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedsv.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedsv.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrieradditionalservicedsv.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrieradditionalservicedsv.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrieradditionalservicedsv.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrieradditionalservicedsv.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedsv.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedsv.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicedsv.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.APICode != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeEQ(*i.APICode))
	}
	if i.APICodeNEQ != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeNEQ(*i.APICodeNEQ))
	}
	if len(i.APICodeIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeIn(i.APICodeIn...))
	}
	if len(i.APICodeNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeNotIn(i.APICodeNotIn...))
	}
	if i.APICodeGT != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeGT(*i.APICodeGT))
	}
	if i.APICodeGTE != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeGTE(*i.APICodeGTE))
	}
	if i.APICodeLT != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeLT(*i.APICodeLT))
	}
	if i.APICodeLTE != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeLTE(*i.APICodeLTE))
	}
	if i.APICodeContains != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeContains(*i.APICodeContains))
	}
	if i.APICodeHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeHasPrefix(*i.APICodeHasPrefix))
	}
	if i.APICodeHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeHasSuffix(*i.APICodeHasSuffix))
	}
	if i.APICodeEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeEqualFold(*i.APICodeEqualFold))
	}
	if i.APICodeContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicedsv.APICodeContainsFold(*i.APICodeContainsFold))
	}

	if i.HasCarrierServiceDSV != nil {
		p := carrieradditionalservicedsv.HasCarrierServiceDSV()
		if !*i.HasCarrierServiceDSV {
			p = carrieradditionalservicedsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceDSVWith) > 0 {
		with := make([]predicate.CarrierServiceDSV, 0, len(i.HasCarrierServiceDSVWith))
		for _, w := range i.HasCarrierServiceDSVWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceDSVWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicedsv.HasCarrierServiceDSVWith(with...))
	}
	if i.HasDeliveryOptionDSV != nil {
		p := carrieradditionalservicedsv.HasDeliveryOptionDSV()
		if !*i.HasDeliveryOptionDSV {
			p = carrieradditionalservicedsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionDSVWith) > 0 {
		with := make([]predicate.DeliveryOptionDSV, 0, len(i.HasDeliveryOptionDSVWith))
		for _, w := range i.HasDeliveryOptionDSVWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionDSVWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicedsv.HasDeliveryOptionDSVWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierAdditionalServiceDSVWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrieradditionalservicedsv.And(predicates...), nil
	}
}

// CarrierAdditionalServiceEasyPostWhereInput represents a where input for filtering CarrierAdditionalServiceEasyPost queries.
type CarrierAdditionalServiceEasyPostWhereInput struct {
	Predicates []predicate.CarrierAdditionalServiceEasyPost  `json:"-"`
	Not        *CarrierAdditionalServiceEasyPostWhereInput   `json:"not,omitempty"`
	Or         []*CarrierAdditionalServiceEasyPostWhereInput `json:"or,omitempty"`
	And        []*CarrierAdditionalServiceEasyPostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "api_key" field predicates.
	APIKey             *string  `json:"apiKey,omitempty"`
	APIKeyNEQ          *string  `json:"apiKeyNEQ,omitempty"`
	APIKeyIn           []string `json:"apiKeyIn,omitempty"`
	APIKeyNotIn        []string `json:"apiKeyNotIn,omitempty"`
	APIKeyGT           *string  `json:"apiKeyGT,omitempty"`
	APIKeyGTE          *string  `json:"apiKeyGTE,omitempty"`
	APIKeyLT           *string  `json:"apiKeyLT,omitempty"`
	APIKeyLTE          *string  `json:"apiKeyLTE,omitempty"`
	APIKeyContains     *string  `json:"apiKeyContains,omitempty"`
	APIKeyHasPrefix    *string  `json:"apiKeyHasPrefix,omitempty"`
	APIKeyHasSuffix    *string  `json:"apiKeyHasSuffix,omitempty"`
	APIKeyEqualFold    *string  `json:"apiKeyEqualFold,omitempty"`
	APIKeyContainsFold *string  `json:"apiKeyContainsFold,omitempty"`

	// "api_value" field predicates.
	APIValue             *string  `json:"apiValue,omitempty"`
	APIValueNEQ          *string  `json:"apiValueNEQ,omitempty"`
	APIValueIn           []string `json:"apiValueIn,omitempty"`
	APIValueNotIn        []string `json:"apiValueNotIn,omitempty"`
	APIValueGT           *string  `json:"apiValueGT,omitempty"`
	APIValueGTE          *string  `json:"apiValueGTE,omitempty"`
	APIValueLT           *string  `json:"apiValueLT,omitempty"`
	APIValueLTE          *string  `json:"apiValueLTE,omitempty"`
	APIValueContains     *string  `json:"apiValueContains,omitempty"`
	APIValueHasPrefix    *string  `json:"apiValueHasPrefix,omitempty"`
	APIValueHasSuffix    *string  `json:"apiValueHasSuffix,omitempty"`
	APIValueEqualFold    *string  `json:"apiValueEqualFold,omitempty"`
	APIValueContainsFold *string  `json:"apiValueContainsFold,omitempty"`

	// "carrier_service_easy_post" edge predicates.
	HasCarrierServiceEasyPost     *bool                               `json:"hasCarrierServiceEasyPost,omitempty"`
	HasCarrierServiceEasyPostWith []*CarrierServiceEasyPostWhereInput `json:"hasCarrierServiceEasyPostWith,omitempty"`

	// "delivery_option_easy_post" edge predicates.
	HasDeliveryOptionEasyPost     *bool                               `json:"hasDeliveryOptionEasyPost,omitempty"`
	HasDeliveryOptionEasyPostWith []*DeliveryOptionEasyPostWhereInput `json:"hasDeliveryOptionEasyPostWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierAdditionalServiceEasyPostWhereInput) AddPredicates(predicates ...predicate.CarrierAdditionalServiceEasyPost) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierAdditionalServiceEasyPostWhereInput filter on the CarrierAdditionalServiceEasyPostQuery builder.
func (i *CarrierAdditionalServiceEasyPostWhereInput) Filter(q *CarrierAdditionalServiceEasyPostQuery) (*CarrierAdditionalServiceEasyPostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierAdditionalServiceEasyPostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierAdditionalServiceEasyPostWhereInput is returned in case the CarrierAdditionalServiceEasyPostWhereInput is empty.
var ErrEmptyCarrierAdditionalServiceEasyPostWhereInput = errors.New("ent: empty predicate CarrierAdditionalServiceEasyPostWhereInput")

// P returns a predicate for filtering carrieradditionalserviceeasyposts.
// An error is returned if the input is empty or invalid.
func (i *CarrierAdditionalServiceEasyPostWhereInput) P() (predicate.CarrierAdditionalServiceEasyPost, error) {
	var predicates []predicate.CarrierAdditionalServiceEasyPost
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrieradditionalserviceeasypost.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierAdditionalServiceEasyPost, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrieradditionalserviceeasypost.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierAdditionalServiceEasyPost, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrieradditionalserviceeasypost.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceeasypost.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceeasypost.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.APIKey != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyEQ(*i.APIKey))
	}
	if i.APIKeyNEQ != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyNEQ(*i.APIKeyNEQ))
	}
	if len(i.APIKeyIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyIn(i.APIKeyIn...))
	}
	if len(i.APIKeyNotIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyNotIn(i.APIKeyNotIn...))
	}
	if i.APIKeyGT != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyGT(*i.APIKeyGT))
	}
	if i.APIKeyGTE != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyGTE(*i.APIKeyGTE))
	}
	if i.APIKeyLT != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyLT(*i.APIKeyLT))
	}
	if i.APIKeyLTE != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyLTE(*i.APIKeyLTE))
	}
	if i.APIKeyContains != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyContains(*i.APIKeyContains))
	}
	if i.APIKeyHasPrefix != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyHasPrefix(*i.APIKeyHasPrefix))
	}
	if i.APIKeyHasSuffix != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyHasSuffix(*i.APIKeyHasSuffix))
	}
	if i.APIKeyEqualFold != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyEqualFold(*i.APIKeyEqualFold))
	}
	if i.APIKeyContainsFold != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIKeyContainsFold(*i.APIKeyContainsFold))
	}
	if i.APIValue != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueEQ(*i.APIValue))
	}
	if i.APIValueNEQ != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueNEQ(*i.APIValueNEQ))
	}
	if len(i.APIValueIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueIn(i.APIValueIn...))
	}
	if len(i.APIValueNotIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueNotIn(i.APIValueNotIn...))
	}
	if i.APIValueGT != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueGT(*i.APIValueGT))
	}
	if i.APIValueGTE != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueGTE(*i.APIValueGTE))
	}
	if i.APIValueLT != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueLT(*i.APIValueLT))
	}
	if i.APIValueLTE != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueLTE(*i.APIValueLTE))
	}
	if i.APIValueContains != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueContains(*i.APIValueContains))
	}
	if i.APIValueHasPrefix != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueHasPrefix(*i.APIValueHasPrefix))
	}
	if i.APIValueHasSuffix != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueHasSuffix(*i.APIValueHasSuffix))
	}
	if i.APIValueEqualFold != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueEqualFold(*i.APIValueEqualFold))
	}
	if i.APIValueContainsFold != nil {
		predicates = append(predicates, carrieradditionalserviceeasypost.APIValueContainsFold(*i.APIValueContainsFold))
	}

	if i.HasCarrierServiceEasyPost != nil {
		p := carrieradditionalserviceeasypost.HasCarrierServiceEasyPost()
		if !*i.HasCarrierServiceEasyPost {
			p = carrieradditionalserviceeasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceEasyPostWith) > 0 {
		with := make([]predicate.CarrierServiceEasyPost, 0, len(i.HasCarrierServiceEasyPostWith))
		for _, w := range i.HasCarrierServiceEasyPostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceEasyPostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalserviceeasypost.HasCarrierServiceEasyPostWith(with...))
	}
	if i.HasDeliveryOptionEasyPost != nil {
		p := carrieradditionalserviceeasypost.HasDeliveryOptionEasyPost()
		if !*i.HasDeliveryOptionEasyPost {
			p = carrieradditionalserviceeasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionEasyPostWith) > 0 {
		with := make([]predicate.DeliveryOptionEasyPost, 0, len(i.HasDeliveryOptionEasyPostWith))
		for _, w := range i.HasDeliveryOptionEasyPostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionEasyPostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalserviceeasypost.HasDeliveryOptionEasyPostWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierAdditionalServiceEasyPostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrieradditionalserviceeasypost.And(predicates...), nil
	}
}

// CarrierAdditionalServiceGLSWhereInput represents a where input for filtering CarrierAdditionalServiceGLS queries.
type CarrierAdditionalServiceGLSWhereInput struct {
	Predicates []predicate.CarrierAdditionalServiceGLS  `json:"-"`
	Not        *CarrierAdditionalServiceGLSWhereInput   `json:"not,omitempty"`
	Or         []*CarrierAdditionalServiceGLSWhereInput `json:"or,omitempty"`
	And        []*CarrierAdditionalServiceGLSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "mandatory" field predicates.
	Mandatory    *bool `json:"mandatory,omitempty"`
	MandatoryNEQ *bool `json:"mandatoryNEQ,omitempty"`

	// "all_countries_consignor" field predicates.
	AllCountriesConsignor    *bool `json:"allCountriesConsignor,omitempty"`
	AllCountriesConsignorNEQ *bool `json:"allCountriesConsignorNEQ,omitempty"`

	// "all_countries_consignee" field predicates.
	AllCountriesConsignee    *bool `json:"allCountriesConsignee,omitempty"`
	AllCountriesConsigneeNEQ *bool `json:"allCountriesConsigneeNEQ,omitempty"`

	// "internal_id" field predicates.
	InternalID             *string  `json:"internalID,omitempty"`
	InternalIDNEQ          *string  `json:"internalIDNEQ,omitempty"`
	InternalIDIn           []string `json:"internalIDIn,omitempty"`
	InternalIDNotIn        []string `json:"internalIDNotIn,omitempty"`
	InternalIDGT           *string  `json:"internalIDGT,omitempty"`
	InternalIDGTE          *string  `json:"internalIDGTE,omitempty"`
	InternalIDLT           *string  `json:"internalIDLT,omitempty"`
	InternalIDLTE          *string  `json:"internalIDLTE,omitempty"`
	InternalIDContains     *string  `json:"internalIDContains,omitempty"`
	InternalIDHasPrefix    *string  `json:"internalIDHasPrefix,omitempty"`
	InternalIDHasSuffix    *string  `json:"internalIDHasSuffix,omitempty"`
	InternalIDEqualFold    *string  `json:"internalIDEqualFold,omitempty"`
	InternalIDContainsFold *string  `json:"internalIDContainsFold,omitempty"`

	// "carrier_service_gls" edge predicates.
	HasCarrierServiceGLS     *bool                          `json:"hasCarrierServiceGLS,omitempty"`
	HasCarrierServiceGLSWith []*CarrierServiceGLSWhereInput `json:"hasCarrierServiceGLSWith,omitempty"`

	// "delivery_option_gls" edge predicates.
	HasDeliveryOptionGLS     *bool                          `json:"hasDeliveryOptionGLS,omitempty"`
	HasDeliveryOptionGLSWith []*DeliveryOptionGLSWhereInput `json:"hasDeliveryOptionGLSWith,omitempty"`

	// "countries_consignee" edge predicates.
	HasCountriesConsignee     *bool                `json:"hasCountriesConsignee,omitempty"`
	HasCountriesConsigneeWith []*CountryWhereInput `json:"hasCountriesConsigneeWith,omitempty"`

	// "countries_consignor" edge predicates.
	HasCountriesConsignor     *bool                `json:"hasCountriesConsignor,omitempty"`
	HasCountriesConsignorWith []*CountryWhereInput `json:"hasCountriesConsignorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierAdditionalServiceGLSWhereInput) AddPredicates(predicates ...predicate.CarrierAdditionalServiceGLS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierAdditionalServiceGLSWhereInput filter on the CarrierAdditionalServiceGLSQuery builder.
func (i *CarrierAdditionalServiceGLSWhereInput) Filter(q *CarrierAdditionalServiceGLSQuery) (*CarrierAdditionalServiceGLSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierAdditionalServiceGLSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierAdditionalServiceGLSWhereInput is returned in case the CarrierAdditionalServiceGLSWhereInput is empty.
var ErrEmptyCarrierAdditionalServiceGLSWhereInput = errors.New("ent: empty predicate CarrierAdditionalServiceGLSWhereInput")

// P returns a predicate for filtering carrieradditionalserviceglss.
// An error is returned if the input is empty or invalid.
func (i *CarrierAdditionalServiceGLSWhereInput) P() (predicate.CarrierAdditionalServiceGLS, error) {
	var predicates []predicate.CarrierAdditionalServiceGLS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrieradditionalservicegls.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierAdditionalServiceGLS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrieradditionalservicegls.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierAdditionalServiceGLS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrieradditionalservicegls.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrieradditionalservicegls.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrieradditionalservicegls.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrieradditionalservicegls.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicegls.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrieradditionalservicegls.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrieradditionalservicegls.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrieradditionalservicegls.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrieradditionalservicegls.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrieradditionalservicegls.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicegls.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicegls.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.Mandatory != nil {
		predicates = append(predicates, carrieradditionalservicegls.MandatoryEQ(*i.Mandatory))
	}
	if i.MandatoryNEQ != nil {
		predicates = append(predicates, carrieradditionalservicegls.MandatoryNEQ(*i.MandatoryNEQ))
	}
	if i.AllCountriesConsignor != nil {
		predicates = append(predicates, carrieradditionalservicegls.AllCountriesConsignorEQ(*i.AllCountriesConsignor))
	}
	if i.AllCountriesConsignorNEQ != nil {
		predicates = append(predicates, carrieradditionalservicegls.AllCountriesConsignorNEQ(*i.AllCountriesConsignorNEQ))
	}
	if i.AllCountriesConsignee != nil {
		predicates = append(predicates, carrieradditionalservicegls.AllCountriesConsigneeEQ(*i.AllCountriesConsignee))
	}
	if i.AllCountriesConsigneeNEQ != nil {
		predicates = append(predicates, carrieradditionalservicegls.AllCountriesConsigneeNEQ(*i.AllCountriesConsigneeNEQ))
	}
	if i.InternalID != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDEQ(*i.InternalID))
	}
	if i.InternalIDNEQ != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDNEQ(*i.InternalIDNEQ))
	}
	if len(i.InternalIDIn) > 0 {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDIn(i.InternalIDIn...))
	}
	if len(i.InternalIDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDNotIn(i.InternalIDNotIn...))
	}
	if i.InternalIDGT != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDGT(*i.InternalIDGT))
	}
	if i.InternalIDGTE != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDGTE(*i.InternalIDGTE))
	}
	if i.InternalIDLT != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDLT(*i.InternalIDLT))
	}
	if i.InternalIDLTE != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDLTE(*i.InternalIDLTE))
	}
	if i.InternalIDContains != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDContains(*i.InternalIDContains))
	}
	if i.InternalIDHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDHasPrefix(*i.InternalIDHasPrefix))
	}
	if i.InternalIDHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDHasSuffix(*i.InternalIDHasSuffix))
	}
	if i.InternalIDEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDEqualFold(*i.InternalIDEqualFold))
	}
	if i.InternalIDContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicegls.InternalIDContainsFold(*i.InternalIDContainsFold))
	}

	if i.HasCarrierServiceGLS != nil {
		p := carrieradditionalservicegls.HasCarrierServiceGLS()
		if !*i.HasCarrierServiceGLS {
			p = carrieradditionalservicegls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceGLSWith) > 0 {
		with := make([]predicate.CarrierServiceGLS, 0, len(i.HasCarrierServiceGLSWith))
		for _, w := range i.HasCarrierServiceGLSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceGLSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicegls.HasCarrierServiceGLSWith(with...))
	}
	if i.HasDeliveryOptionGLS != nil {
		p := carrieradditionalservicegls.HasDeliveryOptionGLS()
		if !*i.HasDeliveryOptionGLS {
			p = carrieradditionalservicegls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionGLSWith) > 0 {
		with := make([]predicate.DeliveryOptionGLS, 0, len(i.HasDeliveryOptionGLSWith))
		for _, w := range i.HasDeliveryOptionGLSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionGLSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicegls.HasDeliveryOptionGLSWith(with...))
	}
	if i.HasCountriesConsignee != nil {
		p := carrieradditionalservicegls.HasCountriesConsignee()
		if !*i.HasCountriesConsignee {
			p = carrieradditionalservicegls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountriesConsigneeWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountriesConsigneeWith))
		for _, w := range i.HasCountriesConsigneeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountriesConsigneeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicegls.HasCountriesConsigneeWith(with...))
	}
	if i.HasCountriesConsignor != nil {
		p := carrieradditionalservicegls.HasCountriesConsignor()
		if !*i.HasCountriesConsignor {
			p = carrieradditionalservicegls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountriesConsignorWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountriesConsignorWith))
		for _, w := range i.HasCountriesConsignorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountriesConsignorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicegls.HasCountriesConsignorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierAdditionalServiceGLSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrieradditionalservicegls.And(predicates...), nil
	}
}

// CarrierAdditionalServicePostNordWhereInput represents a where input for filtering CarrierAdditionalServicePostNord queries.
type CarrierAdditionalServicePostNordWhereInput struct {
	Predicates []predicate.CarrierAdditionalServicePostNord  `json:"-"`
	Not        *CarrierAdditionalServicePostNordWhereInput   `json:"not,omitempty"`
	Or         []*CarrierAdditionalServicePostNordWhereInput `json:"or,omitempty"`
	And        []*CarrierAdditionalServicePostNordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "mandatory" field predicates.
	Mandatory    *bool `json:"mandatory,omitempty"`
	MandatoryNEQ *bool `json:"mandatoryNEQ,omitempty"`

	// "all_countries_consignor" field predicates.
	AllCountriesConsignor    *bool `json:"allCountriesConsignor,omitempty"`
	AllCountriesConsignorNEQ *bool `json:"allCountriesConsignorNEQ,omitempty"`

	// "all_countries_consignee" field predicates.
	AllCountriesConsignee    *bool `json:"allCountriesConsignee,omitempty"`
	AllCountriesConsigneeNEQ *bool `json:"allCountriesConsigneeNEQ,omitempty"`

	// "internal_id" field predicates.
	InternalID             *string  `json:"internalID,omitempty"`
	InternalIDNEQ          *string  `json:"internalIDNEQ,omitempty"`
	InternalIDIn           []string `json:"internalIDIn,omitempty"`
	InternalIDNotIn        []string `json:"internalIDNotIn,omitempty"`
	InternalIDGT           *string  `json:"internalIDGT,omitempty"`
	InternalIDGTE          *string  `json:"internalIDGTE,omitempty"`
	InternalIDLT           *string  `json:"internalIDLT,omitempty"`
	InternalIDLTE          *string  `json:"internalIDLTE,omitempty"`
	InternalIDContains     *string  `json:"internalIDContains,omitempty"`
	InternalIDHasPrefix    *string  `json:"internalIDHasPrefix,omitempty"`
	InternalIDHasSuffix    *string  `json:"internalIDHasSuffix,omitempty"`
	InternalIDEqualFold    *string  `json:"internalIDEqualFold,omitempty"`
	InternalIDContainsFold *string  `json:"internalIDContainsFold,omitempty"`

	// "api_code" field predicates.
	APICode             *string  `json:"apiCode,omitempty"`
	APICodeNEQ          *string  `json:"apiCodeNEQ,omitempty"`
	APICodeIn           []string `json:"apiCodeIn,omitempty"`
	APICodeNotIn        []string `json:"apiCodeNotIn,omitempty"`
	APICodeGT           *string  `json:"apiCodeGT,omitempty"`
	APICodeGTE          *string  `json:"apiCodeGTE,omitempty"`
	APICodeLT           *string  `json:"apiCodeLT,omitempty"`
	APICodeLTE          *string  `json:"apiCodeLTE,omitempty"`
	APICodeContains     *string  `json:"apiCodeContains,omitempty"`
	APICodeHasPrefix    *string  `json:"apiCodeHasPrefix,omitempty"`
	APICodeHasSuffix    *string  `json:"apiCodeHasSuffix,omitempty"`
	APICodeEqualFold    *string  `json:"apiCodeEqualFold,omitempty"`
	APICodeContainsFold *string  `json:"apiCodeContainsFold,omitempty"`

	// "carrier_service_post_nord" edge predicates.
	HasCarrierServicePostNord     *bool                               `json:"hasCarrierServicePostNord,omitempty"`
	HasCarrierServicePostNordWith []*CarrierServicePostNordWhereInput `json:"hasCarrierServicePostNordWith,omitempty"`

	// "delivery_option_post_nord" edge predicates.
	HasDeliveryOptionPostNord     *bool                               `json:"hasDeliveryOptionPostNord,omitempty"`
	HasDeliveryOptionPostNordWith []*DeliveryOptionPostNordWhereInput `json:"hasDeliveryOptionPostNordWith,omitempty"`

	// "countries_consignee" edge predicates.
	HasCountriesConsignee     *bool                `json:"hasCountriesConsignee,omitempty"`
	HasCountriesConsigneeWith []*CountryWhereInput `json:"hasCountriesConsigneeWith,omitempty"`

	// "countries_consignor" edge predicates.
	HasCountriesConsignor     *bool                `json:"hasCountriesConsignor,omitempty"`
	HasCountriesConsignorWith []*CountryWhereInput `json:"hasCountriesConsignorWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierAdditionalServicePostNordWhereInput) AddPredicates(predicates ...predicate.CarrierAdditionalServicePostNord) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierAdditionalServicePostNordWhereInput filter on the CarrierAdditionalServicePostNordQuery builder.
func (i *CarrierAdditionalServicePostNordWhereInput) Filter(q *CarrierAdditionalServicePostNordQuery) (*CarrierAdditionalServicePostNordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierAdditionalServicePostNordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierAdditionalServicePostNordWhereInput is returned in case the CarrierAdditionalServicePostNordWhereInput is empty.
var ErrEmptyCarrierAdditionalServicePostNordWhereInput = errors.New("ent: empty predicate CarrierAdditionalServicePostNordWhereInput")

// P returns a predicate for filtering carrieradditionalservicepostnords.
// An error is returned if the input is empty or invalid.
func (i *CarrierAdditionalServicePostNordWhereInput) P() (predicate.CarrierAdditionalServicePostNord, error) {
	var predicates []predicate.CarrierAdditionalServicePostNord
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrieradditionalservicepostnord.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierAdditionalServicePostNord, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrieradditionalservicepostnord.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierAdditionalServicePostNord, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrieradditionalservicepostnord.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrieradditionalservicepostnord.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicepostnord.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.Mandatory != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.MandatoryEQ(*i.Mandatory))
	}
	if i.MandatoryNEQ != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.MandatoryNEQ(*i.MandatoryNEQ))
	}
	if i.AllCountriesConsignor != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.AllCountriesConsignorEQ(*i.AllCountriesConsignor))
	}
	if i.AllCountriesConsignorNEQ != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.AllCountriesConsignorNEQ(*i.AllCountriesConsignorNEQ))
	}
	if i.AllCountriesConsignee != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.AllCountriesConsigneeEQ(*i.AllCountriesConsignee))
	}
	if i.AllCountriesConsigneeNEQ != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.AllCountriesConsigneeNEQ(*i.AllCountriesConsigneeNEQ))
	}
	if i.InternalID != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDEQ(*i.InternalID))
	}
	if i.InternalIDNEQ != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDNEQ(*i.InternalIDNEQ))
	}
	if len(i.InternalIDIn) > 0 {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDIn(i.InternalIDIn...))
	}
	if len(i.InternalIDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDNotIn(i.InternalIDNotIn...))
	}
	if i.InternalIDGT != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDGT(*i.InternalIDGT))
	}
	if i.InternalIDGTE != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDGTE(*i.InternalIDGTE))
	}
	if i.InternalIDLT != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDLT(*i.InternalIDLT))
	}
	if i.InternalIDLTE != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDLTE(*i.InternalIDLTE))
	}
	if i.InternalIDContains != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDContains(*i.InternalIDContains))
	}
	if i.InternalIDHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDHasPrefix(*i.InternalIDHasPrefix))
	}
	if i.InternalIDHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDHasSuffix(*i.InternalIDHasSuffix))
	}
	if i.InternalIDEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDEqualFold(*i.InternalIDEqualFold))
	}
	if i.InternalIDContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.InternalIDContainsFold(*i.InternalIDContainsFold))
	}
	if i.APICode != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeEQ(*i.APICode))
	}
	if i.APICodeNEQ != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeNEQ(*i.APICodeNEQ))
	}
	if len(i.APICodeIn) > 0 {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeIn(i.APICodeIn...))
	}
	if len(i.APICodeNotIn) > 0 {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeNotIn(i.APICodeNotIn...))
	}
	if i.APICodeGT != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeGT(*i.APICodeGT))
	}
	if i.APICodeGTE != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeGTE(*i.APICodeGTE))
	}
	if i.APICodeLT != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeLT(*i.APICodeLT))
	}
	if i.APICodeLTE != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeLTE(*i.APICodeLTE))
	}
	if i.APICodeContains != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeContains(*i.APICodeContains))
	}
	if i.APICodeHasPrefix != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeHasPrefix(*i.APICodeHasPrefix))
	}
	if i.APICodeHasSuffix != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeHasSuffix(*i.APICodeHasSuffix))
	}
	if i.APICodeEqualFold != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeEqualFold(*i.APICodeEqualFold))
	}
	if i.APICodeContainsFold != nil {
		predicates = append(predicates, carrieradditionalservicepostnord.APICodeContainsFold(*i.APICodeContainsFold))
	}

	if i.HasCarrierServicePostNord != nil {
		p := carrieradditionalservicepostnord.HasCarrierServicePostNord()
		if !*i.HasCarrierServicePostNord {
			p = carrieradditionalservicepostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServicePostNordWith) > 0 {
		with := make([]predicate.CarrierServicePostNord, 0, len(i.HasCarrierServicePostNordWith))
		for _, w := range i.HasCarrierServicePostNordWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServicePostNordWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicepostnord.HasCarrierServicePostNordWith(with...))
	}
	if i.HasDeliveryOptionPostNord != nil {
		p := carrieradditionalservicepostnord.HasDeliveryOptionPostNord()
		if !*i.HasDeliveryOptionPostNord {
			p = carrieradditionalservicepostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionPostNordWith) > 0 {
		with := make([]predicate.DeliveryOptionPostNord, 0, len(i.HasDeliveryOptionPostNordWith))
		for _, w := range i.HasDeliveryOptionPostNordWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionPostNordWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicepostnord.HasDeliveryOptionPostNordWith(with...))
	}
	if i.HasCountriesConsignee != nil {
		p := carrieradditionalservicepostnord.HasCountriesConsignee()
		if !*i.HasCountriesConsignee {
			p = carrieradditionalservicepostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountriesConsigneeWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountriesConsigneeWith))
		for _, w := range i.HasCountriesConsigneeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountriesConsigneeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicepostnord.HasCountriesConsigneeWith(with...))
	}
	if i.HasCountriesConsignor != nil {
		p := carrieradditionalservicepostnord.HasCountriesConsignor()
		if !*i.HasCountriesConsignor {
			p = carrieradditionalservicepostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountriesConsignorWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountriesConsignorWith))
		for _, w := range i.HasCountriesConsignorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountriesConsignorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalservicepostnord.HasCountriesConsignorWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierAdditionalServicePostNordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrieradditionalservicepostnord.And(predicates...), nil
	}
}

// CarrierAdditionalServiceUSPSWhereInput represents a where input for filtering CarrierAdditionalServiceUSPS queries.
type CarrierAdditionalServiceUSPSWhereInput struct {
	Predicates []predicate.CarrierAdditionalServiceUSPS  `json:"-"`
	Not        *CarrierAdditionalServiceUSPSWhereInput   `json:"not,omitempty"`
	Or         []*CarrierAdditionalServiceUSPSWhereInput `json:"or,omitempty"`
	And        []*CarrierAdditionalServiceUSPSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "commonly_used" field predicates.
	CommonlyUsed    *bool `json:"commonlyUsed,omitempty"`
	CommonlyUsedNEQ *bool `json:"commonlyUsedNEQ,omitempty"`

	// "internal_id" field predicates.
	InternalID      *carrieradditionalserviceusps.InternalID  `json:"internalID,omitempty"`
	InternalIDNEQ   *carrieradditionalserviceusps.InternalID  `json:"internalIDNEQ,omitempty"`
	InternalIDIn    []carrieradditionalserviceusps.InternalID `json:"internalIDIn,omitempty"`
	InternalIDNotIn []carrieradditionalserviceusps.InternalID `json:"internalIDNotIn,omitempty"`

	// "api_code" field predicates.
	APICode             *string  `json:"apiCode,omitempty"`
	APICodeNEQ          *string  `json:"apiCodeNEQ,omitempty"`
	APICodeIn           []string `json:"apiCodeIn,omitempty"`
	APICodeNotIn        []string `json:"apiCodeNotIn,omitempty"`
	APICodeGT           *string  `json:"apiCodeGT,omitempty"`
	APICodeGTE          *string  `json:"apiCodeGTE,omitempty"`
	APICodeLT           *string  `json:"apiCodeLT,omitempty"`
	APICodeLTE          *string  `json:"apiCodeLTE,omitempty"`
	APICodeContains     *string  `json:"apiCodeContains,omitempty"`
	APICodeHasPrefix    *string  `json:"apiCodeHasPrefix,omitempty"`
	APICodeHasSuffix    *string  `json:"apiCodeHasSuffix,omitempty"`
	APICodeEqualFold    *string  `json:"apiCodeEqualFold,omitempty"`
	APICodeContainsFold *string  `json:"apiCodeContainsFold,omitempty"`

	// "carrier_service_usps" edge predicates.
	HasCarrierServiceUSPS     *bool                           `json:"hasCarrierServiceUSPS,omitempty"`
	HasCarrierServiceUSPSWith []*CarrierServiceUSPSWhereInput `json:"hasCarrierServiceUSPSWith,omitempty"`

	// "delivery_option_usps" edge predicates.
	HasDeliveryOptionUSPS     *bool                           `json:"hasDeliveryOptionUSPS,omitempty"`
	HasDeliveryOptionUSPSWith []*DeliveryOptionUSPSWhereInput `json:"hasDeliveryOptionUSPSWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierAdditionalServiceUSPSWhereInput) AddPredicates(predicates ...predicate.CarrierAdditionalServiceUSPS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierAdditionalServiceUSPSWhereInput filter on the CarrierAdditionalServiceUSPSQuery builder.
func (i *CarrierAdditionalServiceUSPSWhereInput) Filter(q *CarrierAdditionalServiceUSPSQuery) (*CarrierAdditionalServiceUSPSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierAdditionalServiceUSPSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierAdditionalServiceUSPSWhereInput is returned in case the CarrierAdditionalServiceUSPSWhereInput is empty.
var ErrEmptyCarrierAdditionalServiceUSPSWhereInput = errors.New("ent: empty predicate CarrierAdditionalServiceUSPSWhereInput")

// P returns a predicate for filtering carrieradditionalserviceuspss.
// An error is returned if the input is empty or invalid.
func (i *CarrierAdditionalServiceUSPSWhereInput) P() (predicate.CarrierAdditionalServiceUSPS, error) {
	var predicates []predicate.CarrierAdditionalServiceUSPS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrieradditionalserviceusps.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierAdditionalServiceUSPS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrieradditionalserviceusps.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierAdditionalServiceUSPS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrieradditionalserviceusps.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrieradditionalserviceusps.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrieradditionalserviceusps.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceusps.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceusps.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrieradditionalserviceusps.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrieradditionalserviceusps.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrieradditionalserviceusps.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrieradditionalserviceusps.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceusps.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceusps.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrieradditionalserviceusps.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.CommonlyUsed != nil {
		predicates = append(predicates, carrieradditionalserviceusps.CommonlyUsedEQ(*i.CommonlyUsed))
	}
	if i.CommonlyUsedNEQ != nil {
		predicates = append(predicates, carrieradditionalserviceusps.CommonlyUsedNEQ(*i.CommonlyUsedNEQ))
	}
	if i.InternalID != nil {
		predicates = append(predicates, carrieradditionalserviceusps.InternalIDEQ(*i.InternalID))
	}
	if i.InternalIDNEQ != nil {
		predicates = append(predicates, carrieradditionalserviceusps.InternalIDNEQ(*i.InternalIDNEQ))
	}
	if len(i.InternalIDIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceusps.InternalIDIn(i.InternalIDIn...))
	}
	if len(i.InternalIDNotIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceusps.InternalIDNotIn(i.InternalIDNotIn...))
	}
	if i.APICode != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeEQ(*i.APICode))
	}
	if i.APICodeNEQ != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeNEQ(*i.APICodeNEQ))
	}
	if len(i.APICodeIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeIn(i.APICodeIn...))
	}
	if len(i.APICodeNotIn) > 0 {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeNotIn(i.APICodeNotIn...))
	}
	if i.APICodeGT != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeGT(*i.APICodeGT))
	}
	if i.APICodeGTE != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeGTE(*i.APICodeGTE))
	}
	if i.APICodeLT != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeLT(*i.APICodeLT))
	}
	if i.APICodeLTE != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeLTE(*i.APICodeLTE))
	}
	if i.APICodeContains != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeContains(*i.APICodeContains))
	}
	if i.APICodeHasPrefix != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeHasPrefix(*i.APICodeHasPrefix))
	}
	if i.APICodeHasSuffix != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeHasSuffix(*i.APICodeHasSuffix))
	}
	if i.APICodeEqualFold != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeEqualFold(*i.APICodeEqualFold))
	}
	if i.APICodeContainsFold != nil {
		predicates = append(predicates, carrieradditionalserviceusps.APICodeContainsFold(*i.APICodeContainsFold))
	}

	if i.HasCarrierServiceUSPS != nil {
		p := carrieradditionalserviceusps.HasCarrierServiceUSPS()
		if !*i.HasCarrierServiceUSPS {
			p = carrieradditionalserviceusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceUSPSWith) > 0 {
		with := make([]predicate.CarrierServiceUSPS, 0, len(i.HasCarrierServiceUSPSWith))
		for _, w := range i.HasCarrierServiceUSPSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceUSPSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalserviceusps.HasCarrierServiceUSPSWith(with...))
	}
	if i.HasDeliveryOptionUSPS != nil {
		p := carrieradditionalserviceusps.HasDeliveryOptionUSPS()
		if !*i.HasDeliveryOptionUSPS {
			p = carrieradditionalserviceusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionUSPSWith) > 0 {
		with := make([]predicate.DeliveryOptionUSPS, 0, len(i.HasDeliveryOptionUSPSWith))
		for _, w := range i.HasDeliveryOptionUSPSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionUSPSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrieradditionalserviceusps.HasDeliveryOptionUSPSWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierAdditionalServiceUSPSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrieradditionalserviceusps.And(predicates...), nil
	}
}

// CarrierBrandWhereInput represents a where input for filtering CarrierBrand queries.
type CarrierBrandWhereInput struct {
	Predicates []predicate.CarrierBrand  `json:"-"`
	Not        *CarrierBrandWhereInput   `json:"not,omitempty"`
	Or         []*CarrierBrandWhereInput `json:"or,omitempty"`
	And        []*CarrierBrandWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "label_short" field predicates.
	LabelShort             *string  `json:"labelShort,omitempty"`
	LabelShortNEQ          *string  `json:"labelShortNEQ,omitempty"`
	LabelShortIn           []string `json:"labelShortIn,omitempty"`
	LabelShortNotIn        []string `json:"labelShortNotIn,omitempty"`
	LabelShortGT           *string  `json:"labelShortGT,omitempty"`
	LabelShortGTE          *string  `json:"labelShortGTE,omitempty"`
	LabelShortLT           *string  `json:"labelShortLT,omitempty"`
	LabelShortLTE          *string  `json:"labelShortLTE,omitempty"`
	LabelShortContains     *string  `json:"labelShortContains,omitempty"`
	LabelShortHasPrefix    *string  `json:"labelShortHasPrefix,omitempty"`
	LabelShortHasSuffix    *string  `json:"labelShortHasSuffix,omitempty"`
	LabelShortEqualFold    *string  `json:"labelShortEqualFold,omitempty"`
	LabelShortContainsFold *string  `json:"labelShortContainsFold,omitempty"`

	// "internal_id" field predicates.
	InternalID      *carrierbrand.InternalID  `json:"internalID,omitempty"`
	InternalIDNEQ   *carrierbrand.InternalID  `json:"internalIDNEQ,omitempty"`
	InternalIDIn    []carrierbrand.InternalID `json:"internalIDIn,omitempty"`
	InternalIDNotIn []carrierbrand.InternalID `json:"internalIDNotIn,omitempty"`

	// "logo_url" field predicates.
	LogoURL             *string  `json:"logoURL,omitempty"`
	LogoURLNEQ          *string  `json:"logoURLNEQ,omitempty"`
	LogoURLIn           []string `json:"logoURLIn,omitempty"`
	LogoURLNotIn        []string `json:"logoURLNotIn,omitempty"`
	LogoURLGT           *string  `json:"logoURLGT,omitempty"`
	LogoURLGTE          *string  `json:"logoURLGTE,omitempty"`
	LogoURLLT           *string  `json:"logoURLLT,omitempty"`
	LogoURLLTE          *string  `json:"logoURLLTE,omitempty"`
	LogoURLContains     *string  `json:"logoURLContains,omitempty"`
	LogoURLHasPrefix    *string  `json:"logoURLHasPrefix,omitempty"`
	LogoURLHasSuffix    *string  `json:"logoURLHasSuffix,omitempty"`
	LogoURLIsNil        bool     `json:"logoURLIsNil,omitempty"`
	LogoURLNotNil       bool     `json:"logoURLNotNil,omitempty"`
	LogoURLEqualFold    *string  `json:"logoURLEqualFold,omitempty"`
	LogoURLContainsFold *string  `json:"logoURLContainsFold,omitempty"`

	// "text_color" field predicates.
	TextColor             *string  `json:"textColor,omitempty"`
	TextColorNEQ          *string  `json:"textColorNEQ,omitempty"`
	TextColorIn           []string `json:"textColorIn,omitempty"`
	TextColorNotIn        []string `json:"textColorNotIn,omitempty"`
	TextColorGT           *string  `json:"textColorGT,omitempty"`
	TextColorGTE          *string  `json:"textColorGTE,omitempty"`
	TextColorLT           *string  `json:"textColorLT,omitempty"`
	TextColorLTE          *string  `json:"textColorLTE,omitempty"`
	TextColorContains     *string  `json:"textColorContains,omitempty"`
	TextColorHasPrefix    *string  `json:"textColorHasPrefix,omitempty"`
	TextColorHasSuffix    *string  `json:"textColorHasSuffix,omitempty"`
	TextColorIsNil        bool     `json:"textColorIsNil,omitempty"`
	TextColorNotNil       bool     `json:"textColorNotNil,omitempty"`
	TextColorEqualFold    *string  `json:"textColorEqualFold,omitempty"`
	TextColorContainsFold *string  `json:"textColorContainsFold,omitempty"`

	// "background_color" field predicates.
	BackgroundColor             *string  `json:"backgroundColor,omitempty"`
	BackgroundColorNEQ          *string  `json:"backgroundColorNEQ,omitempty"`
	BackgroundColorIn           []string `json:"backgroundColorIn,omitempty"`
	BackgroundColorNotIn        []string `json:"backgroundColorNotIn,omitempty"`
	BackgroundColorGT           *string  `json:"backgroundColorGT,omitempty"`
	BackgroundColorGTE          *string  `json:"backgroundColorGTE,omitempty"`
	BackgroundColorLT           *string  `json:"backgroundColorLT,omitempty"`
	BackgroundColorLTE          *string  `json:"backgroundColorLTE,omitempty"`
	BackgroundColorContains     *string  `json:"backgroundColorContains,omitempty"`
	BackgroundColorHasPrefix    *string  `json:"backgroundColorHasPrefix,omitempty"`
	BackgroundColorHasSuffix    *string  `json:"backgroundColorHasSuffix,omitempty"`
	BackgroundColorIsNil        bool     `json:"backgroundColorIsNil,omitempty"`
	BackgroundColorNotNil       bool     `json:"backgroundColorNotNil,omitempty"`
	BackgroundColorEqualFold    *string  `json:"backgroundColorEqualFold,omitempty"`
	BackgroundColorContainsFold *string  `json:"backgroundColorContainsFold,omitempty"`

	// "carrier_service" edge predicates.
	HasCarrierService     *bool                       `json:"hasCarrierService,omitempty"`
	HasCarrierServiceWith []*CarrierServiceWhereInput `json:"hasCarrierServiceWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`

	// "parcel_shop" edge predicates.
	HasParcelShop     *bool                   `json:"hasParcelShop,omitempty"`
	HasParcelShopWith []*ParcelShopWhereInput `json:"hasParcelShopWith,omitempty"`

	// "packaging" edge predicates.
	HasPackaging     *bool                  `json:"hasPackaging,omitempty"`
	HasPackagingWith []*PackagingWhereInput `json:"hasPackagingWith,omitempty"`

	// "document" edge predicates.
	HasDocument     *bool                 `json:"hasDocument,omitempty"`
	HasDocumentWith []*DocumentWhereInput `json:"hasDocumentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierBrandWhereInput) AddPredicates(predicates ...predicate.CarrierBrand) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierBrandWhereInput filter on the CarrierBrandQuery builder.
func (i *CarrierBrandWhereInput) Filter(q *CarrierBrandQuery) (*CarrierBrandQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierBrandWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierBrandWhereInput is returned in case the CarrierBrandWhereInput is empty.
var ErrEmptyCarrierBrandWhereInput = errors.New("ent: empty predicate CarrierBrandWhereInput")

// P returns a predicate for filtering carrierbrands.
// An error is returned if the input is empty or invalid.
func (i *CarrierBrandWhereInput) P() (predicate.CarrierBrand, error) {
	var predicates []predicate.CarrierBrand
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierbrand.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierBrand, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierbrand.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierBrand, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierbrand.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierbrand.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierbrand.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierbrand.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierbrand.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierbrand.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierbrand.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierbrand.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierbrand.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrierbrand.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrierbrand.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrierbrand.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrierbrand.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrierbrand.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrierbrand.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrierbrand.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrierbrand.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrierbrand.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrierbrand.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrierbrand.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrierbrand.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrierbrand.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.LabelShort != nil {
		predicates = append(predicates, carrierbrand.LabelShortEQ(*i.LabelShort))
	}
	if i.LabelShortNEQ != nil {
		predicates = append(predicates, carrierbrand.LabelShortNEQ(*i.LabelShortNEQ))
	}
	if len(i.LabelShortIn) > 0 {
		predicates = append(predicates, carrierbrand.LabelShortIn(i.LabelShortIn...))
	}
	if len(i.LabelShortNotIn) > 0 {
		predicates = append(predicates, carrierbrand.LabelShortNotIn(i.LabelShortNotIn...))
	}
	if i.LabelShortGT != nil {
		predicates = append(predicates, carrierbrand.LabelShortGT(*i.LabelShortGT))
	}
	if i.LabelShortGTE != nil {
		predicates = append(predicates, carrierbrand.LabelShortGTE(*i.LabelShortGTE))
	}
	if i.LabelShortLT != nil {
		predicates = append(predicates, carrierbrand.LabelShortLT(*i.LabelShortLT))
	}
	if i.LabelShortLTE != nil {
		predicates = append(predicates, carrierbrand.LabelShortLTE(*i.LabelShortLTE))
	}
	if i.LabelShortContains != nil {
		predicates = append(predicates, carrierbrand.LabelShortContains(*i.LabelShortContains))
	}
	if i.LabelShortHasPrefix != nil {
		predicates = append(predicates, carrierbrand.LabelShortHasPrefix(*i.LabelShortHasPrefix))
	}
	if i.LabelShortHasSuffix != nil {
		predicates = append(predicates, carrierbrand.LabelShortHasSuffix(*i.LabelShortHasSuffix))
	}
	if i.LabelShortEqualFold != nil {
		predicates = append(predicates, carrierbrand.LabelShortEqualFold(*i.LabelShortEqualFold))
	}
	if i.LabelShortContainsFold != nil {
		predicates = append(predicates, carrierbrand.LabelShortContainsFold(*i.LabelShortContainsFold))
	}
	if i.InternalID != nil {
		predicates = append(predicates, carrierbrand.InternalIDEQ(*i.InternalID))
	}
	if i.InternalIDNEQ != nil {
		predicates = append(predicates, carrierbrand.InternalIDNEQ(*i.InternalIDNEQ))
	}
	if len(i.InternalIDIn) > 0 {
		predicates = append(predicates, carrierbrand.InternalIDIn(i.InternalIDIn...))
	}
	if len(i.InternalIDNotIn) > 0 {
		predicates = append(predicates, carrierbrand.InternalIDNotIn(i.InternalIDNotIn...))
	}
	if i.LogoURL != nil {
		predicates = append(predicates, carrierbrand.LogoURLEQ(*i.LogoURL))
	}
	if i.LogoURLNEQ != nil {
		predicates = append(predicates, carrierbrand.LogoURLNEQ(*i.LogoURLNEQ))
	}
	if len(i.LogoURLIn) > 0 {
		predicates = append(predicates, carrierbrand.LogoURLIn(i.LogoURLIn...))
	}
	if len(i.LogoURLNotIn) > 0 {
		predicates = append(predicates, carrierbrand.LogoURLNotIn(i.LogoURLNotIn...))
	}
	if i.LogoURLGT != nil {
		predicates = append(predicates, carrierbrand.LogoURLGT(*i.LogoURLGT))
	}
	if i.LogoURLGTE != nil {
		predicates = append(predicates, carrierbrand.LogoURLGTE(*i.LogoURLGTE))
	}
	if i.LogoURLLT != nil {
		predicates = append(predicates, carrierbrand.LogoURLLT(*i.LogoURLLT))
	}
	if i.LogoURLLTE != nil {
		predicates = append(predicates, carrierbrand.LogoURLLTE(*i.LogoURLLTE))
	}
	if i.LogoURLContains != nil {
		predicates = append(predicates, carrierbrand.LogoURLContains(*i.LogoURLContains))
	}
	if i.LogoURLHasPrefix != nil {
		predicates = append(predicates, carrierbrand.LogoURLHasPrefix(*i.LogoURLHasPrefix))
	}
	if i.LogoURLHasSuffix != nil {
		predicates = append(predicates, carrierbrand.LogoURLHasSuffix(*i.LogoURLHasSuffix))
	}
	if i.LogoURLIsNil {
		predicates = append(predicates, carrierbrand.LogoURLIsNil())
	}
	if i.LogoURLNotNil {
		predicates = append(predicates, carrierbrand.LogoURLNotNil())
	}
	if i.LogoURLEqualFold != nil {
		predicates = append(predicates, carrierbrand.LogoURLEqualFold(*i.LogoURLEqualFold))
	}
	if i.LogoURLContainsFold != nil {
		predicates = append(predicates, carrierbrand.LogoURLContainsFold(*i.LogoURLContainsFold))
	}
	if i.TextColor != nil {
		predicates = append(predicates, carrierbrand.TextColorEQ(*i.TextColor))
	}
	if i.TextColorNEQ != nil {
		predicates = append(predicates, carrierbrand.TextColorNEQ(*i.TextColorNEQ))
	}
	if len(i.TextColorIn) > 0 {
		predicates = append(predicates, carrierbrand.TextColorIn(i.TextColorIn...))
	}
	if len(i.TextColorNotIn) > 0 {
		predicates = append(predicates, carrierbrand.TextColorNotIn(i.TextColorNotIn...))
	}
	if i.TextColorGT != nil {
		predicates = append(predicates, carrierbrand.TextColorGT(*i.TextColorGT))
	}
	if i.TextColorGTE != nil {
		predicates = append(predicates, carrierbrand.TextColorGTE(*i.TextColorGTE))
	}
	if i.TextColorLT != nil {
		predicates = append(predicates, carrierbrand.TextColorLT(*i.TextColorLT))
	}
	if i.TextColorLTE != nil {
		predicates = append(predicates, carrierbrand.TextColorLTE(*i.TextColorLTE))
	}
	if i.TextColorContains != nil {
		predicates = append(predicates, carrierbrand.TextColorContains(*i.TextColorContains))
	}
	if i.TextColorHasPrefix != nil {
		predicates = append(predicates, carrierbrand.TextColorHasPrefix(*i.TextColorHasPrefix))
	}
	if i.TextColorHasSuffix != nil {
		predicates = append(predicates, carrierbrand.TextColorHasSuffix(*i.TextColorHasSuffix))
	}
	if i.TextColorIsNil {
		predicates = append(predicates, carrierbrand.TextColorIsNil())
	}
	if i.TextColorNotNil {
		predicates = append(predicates, carrierbrand.TextColorNotNil())
	}
	if i.TextColorEqualFold != nil {
		predicates = append(predicates, carrierbrand.TextColorEqualFold(*i.TextColorEqualFold))
	}
	if i.TextColorContainsFold != nil {
		predicates = append(predicates, carrierbrand.TextColorContainsFold(*i.TextColorContainsFold))
	}
	if i.BackgroundColor != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorEQ(*i.BackgroundColor))
	}
	if i.BackgroundColorNEQ != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorNEQ(*i.BackgroundColorNEQ))
	}
	if len(i.BackgroundColorIn) > 0 {
		predicates = append(predicates, carrierbrand.BackgroundColorIn(i.BackgroundColorIn...))
	}
	if len(i.BackgroundColorNotIn) > 0 {
		predicates = append(predicates, carrierbrand.BackgroundColorNotIn(i.BackgroundColorNotIn...))
	}
	if i.BackgroundColorGT != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorGT(*i.BackgroundColorGT))
	}
	if i.BackgroundColorGTE != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorGTE(*i.BackgroundColorGTE))
	}
	if i.BackgroundColorLT != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorLT(*i.BackgroundColorLT))
	}
	if i.BackgroundColorLTE != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorLTE(*i.BackgroundColorLTE))
	}
	if i.BackgroundColorContains != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorContains(*i.BackgroundColorContains))
	}
	if i.BackgroundColorHasPrefix != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorHasPrefix(*i.BackgroundColorHasPrefix))
	}
	if i.BackgroundColorHasSuffix != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorHasSuffix(*i.BackgroundColorHasSuffix))
	}
	if i.BackgroundColorIsNil {
		predicates = append(predicates, carrierbrand.BackgroundColorIsNil())
	}
	if i.BackgroundColorNotNil {
		predicates = append(predicates, carrierbrand.BackgroundColorNotNil())
	}
	if i.BackgroundColorEqualFold != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorEqualFold(*i.BackgroundColorEqualFold))
	}
	if i.BackgroundColorContainsFold != nil {
		predicates = append(predicates, carrierbrand.BackgroundColorContainsFold(*i.BackgroundColorContainsFold))
	}

	if i.HasCarrierService != nil {
		p := carrierbrand.HasCarrierService()
		if !*i.HasCarrierService {
			p = carrierbrand.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceWith) > 0 {
		with := make([]predicate.CarrierService, 0, len(i.HasCarrierServiceWith))
		for _, w := range i.HasCarrierServiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierbrand.HasCarrierServiceWith(with...))
	}
	if i.HasCarrier != nil {
		p := carrierbrand.HasCarrier()
		if !*i.HasCarrier {
			p = carrierbrand.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierbrand.HasCarrierWith(with...))
	}
	if i.HasParcelShop != nil {
		p := carrierbrand.HasParcelShop()
		if !*i.HasParcelShop {
			p = carrierbrand.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopWith) > 0 {
		with := make([]predicate.ParcelShop, 0, len(i.HasParcelShopWith))
		for _, w := range i.HasParcelShopWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierbrand.HasParcelShopWith(with...))
	}
	if i.HasPackaging != nil {
		p := carrierbrand.HasPackaging()
		if !*i.HasPackaging {
			p = carrierbrand.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingWith) > 0 {
		with := make([]predicate.Packaging, 0, len(i.HasPackagingWith))
		for _, w := range i.HasPackagingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierbrand.HasPackagingWith(with...))
	}
	if i.HasDocument != nil {
		p := carrierbrand.HasDocument()
		if !*i.HasDocument {
			p = carrierbrand.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasDocumentWith))
		for _, w := range i.HasDocumentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierbrand.HasDocumentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierBrandWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierbrand.And(predicates...), nil
	}
}

// CarrierBringWhereInput represents a where input for filtering CarrierBring queries.
type CarrierBringWhereInput struct {
	Predicates []predicate.CarrierBring  `json:"-"`
	Not        *CarrierBringWhereInput   `json:"not,omitempty"`
	Or         []*CarrierBringWhereInput `json:"or,omitempty"`
	And        []*CarrierBringWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "api_key" field predicates.
	APIKey             *string  `json:"apiKey,omitempty"`
	APIKeyNEQ          *string  `json:"apiKeyNEQ,omitempty"`
	APIKeyIn           []string `json:"apiKeyIn,omitempty"`
	APIKeyNotIn        []string `json:"apiKeyNotIn,omitempty"`
	APIKeyGT           *string  `json:"apiKeyGT,omitempty"`
	APIKeyGTE          *string  `json:"apiKeyGTE,omitempty"`
	APIKeyLT           *string  `json:"apiKeyLT,omitempty"`
	APIKeyLTE          *string  `json:"apiKeyLTE,omitempty"`
	APIKeyContains     *string  `json:"apiKeyContains,omitempty"`
	APIKeyHasPrefix    *string  `json:"apiKeyHasPrefix,omitempty"`
	APIKeyHasSuffix    *string  `json:"apiKeyHasSuffix,omitempty"`
	APIKeyIsNil        bool     `json:"apiKeyIsNil,omitempty"`
	APIKeyNotNil       bool     `json:"apiKeyNotNil,omitempty"`
	APIKeyEqualFold    *string  `json:"apiKeyEqualFold,omitempty"`
	APIKeyContainsFold *string  `json:"apiKeyContainsFold,omitempty"`

	// "customer_number" field predicates.
	CustomerNumber             *string  `json:"customerNumber,omitempty"`
	CustomerNumberNEQ          *string  `json:"customerNumberNEQ,omitempty"`
	CustomerNumberIn           []string `json:"customerNumberIn,omitempty"`
	CustomerNumberNotIn        []string `json:"customerNumberNotIn,omitempty"`
	CustomerNumberGT           *string  `json:"customerNumberGT,omitempty"`
	CustomerNumberGTE          *string  `json:"customerNumberGTE,omitempty"`
	CustomerNumberLT           *string  `json:"customerNumberLT,omitempty"`
	CustomerNumberLTE          *string  `json:"customerNumberLTE,omitempty"`
	CustomerNumberContains     *string  `json:"customerNumberContains,omitempty"`
	CustomerNumberHasPrefix    *string  `json:"customerNumberHasPrefix,omitempty"`
	CustomerNumberHasSuffix    *string  `json:"customerNumberHasSuffix,omitempty"`
	CustomerNumberIsNil        bool     `json:"customerNumberIsNil,omitempty"`
	CustomerNumberNotNil       bool     `json:"customerNumberNotNil,omitempty"`
	CustomerNumberEqualFold    *string  `json:"customerNumberEqualFold,omitempty"`
	CustomerNumberContainsFold *string  `json:"customerNumberContainsFold,omitempty"`

	// "test" field predicates.
	Test    *bool `json:"test,omitempty"`
	TestNEQ *bool `json:"testNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierBringWhereInput) AddPredicates(predicates ...predicate.CarrierBring) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierBringWhereInput filter on the CarrierBringQuery builder.
func (i *CarrierBringWhereInput) Filter(q *CarrierBringQuery) (*CarrierBringQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierBringWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierBringWhereInput is returned in case the CarrierBringWhereInput is empty.
var ErrEmptyCarrierBringWhereInput = errors.New("ent: empty predicate CarrierBringWhereInput")

// P returns a predicate for filtering carrierbrings.
// An error is returned if the input is empty or invalid.
func (i *CarrierBringWhereInput) P() (predicate.CarrierBring, error) {
	var predicates []predicate.CarrierBring
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierbring.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierBring, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierbring.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierBring, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierbring.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierbring.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierbring.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierbring.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierbring.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierbring.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierbring.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierbring.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierbring.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, carrierbring.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, carrierbring.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, carrierbring.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, carrierbring.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, carrierbring.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, carrierbring.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, carrierbring.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, carrierbring.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, carrierbring.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, carrierbring.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, carrierbring.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, carrierbring.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, carrierbring.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.APIKey != nil {
		predicates = append(predicates, carrierbring.APIKeyEQ(*i.APIKey))
	}
	if i.APIKeyNEQ != nil {
		predicates = append(predicates, carrierbring.APIKeyNEQ(*i.APIKeyNEQ))
	}
	if len(i.APIKeyIn) > 0 {
		predicates = append(predicates, carrierbring.APIKeyIn(i.APIKeyIn...))
	}
	if len(i.APIKeyNotIn) > 0 {
		predicates = append(predicates, carrierbring.APIKeyNotIn(i.APIKeyNotIn...))
	}
	if i.APIKeyGT != nil {
		predicates = append(predicates, carrierbring.APIKeyGT(*i.APIKeyGT))
	}
	if i.APIKeyGTE != nil {
		predicates = append(predicates, carrierbring.APIKeyGTE(*i.APIKeyGTE))
	}
	if i.APIKeyLT != nil {
		predicates = append(predicates, carrierbring.APIKeyLT(*i.APIKeyLT))
	}
	if i.APIKeyLTE != nil {
		predicates = append(predicates, carrierbring.APIKeyLTE(*i.APIKeyLTE))
	}
	if i.APIKeyContains != nil {
		predicates = append(predicates, carrierbring.APIKeyContains(*i.APIKeyContains))
	}
	if i.APIKeyHasPrefix != nil {
		predicates = append(predicates, carrierbring.APIKeyHasPrefix(*i.APIKeyHasPrefix))
	}
	if i.APIKeyHasSuffix != nil {
		predicates = append(predicates, carrierbring.APIKeyHasSuffix(*i.APIKeyHasSuffix))
	}
	if i.APIKeyIsNil {
		predicates = append(predicates, carrierbring.APIKeyIsNil())
	}
	if i.APIKeyNotNil {
		predicates = append(predicates, carrierbring.APIKeyNotNil())
	}
	if i.APIKeyEqualFold != nil {
		predicates = append(predicates, carrierbring.APIKeyEqualFold(*i.APIKeyEqualFold))
	}
	if i.APIKeyContainsFold != nil {
		predicates = append(predicates, carrierbring.APIKeyContainsFold(*i.APIKeyContainsFold))
	}
	if i.CustomerNumber != nil {
		predicates = append(predicates, carrierbring.CustomerNumberEQ(*i.CustomerNumber))
	}
	if i.CustomerNumberNEQ != nil {
		predicates = append(predicates, carrierbring.CustomerNumberNEQ(*i.CustomerNumberNEQ))
	}
	if len(i.CustomerNumberIn) > 0 {
		predicates = append(predicates, carrierbring.CustomerNumberIn(i.CustomerNumberIn...))
	}
	if len(i.CustomerNumberNotIn) > 0 {
		predicates = append(predicates, carrierbring.CustomerNumberNotIn(i.CustomerNumberNotIn...))
	}
	if i.CustomerNumberGT != nil {
		predicates = append(predicates, carrierbring.CustomerNumberGT(*i.CustomerNumberGT))
	}
	if i.CustomerNumberGTE != nil {
		predicates = append(predicates, carrierbring.CustomerNumberGTE(*i.CustomerNumberGTE))
	}
	if i.CustomerNumberLT != nil {
		predicates = append(predicates, carrierbring.CustomerNumberLT(*i.CustomerNumberLT))
	}
	if i.CustomerNumberLTE != nil {
		predicates = append(predicates, carrierbring.CustomerNumberLTE(*i.CustomerNumberLTE))
	}
	if i.CustomerNumberContains != nil {
		predicates = append(predicates, carrierbring.CustomerNumberContains(*i.CustomerNumberContains))
	}
	if i.CustomerNumberHasPrefix != nil {
		predicates = append(predicates, carrierbring.CustomerNumberHasPrefix(*i.CustomerNumberHasPrefix))
	}
	if i.CustomerNumberHasSuffix != nil {
		predicates = append(predicates, carrierbring.CustomerNumberHasSuffix(*i.CustomerNumberHasSuffix))
	}
	if i.CustomerNumberIsNil {
		predicates = append(predicates, carrierbring.CustomerNumberIsNil())
	}
	if i.CustomerNumberNotNil {
		predicates = append(predicates, carrierbring.CustomerNumberNotNil())
	}
	if i.CustomerNumberEqualFold != nil {
		predicates = append(predicates, carrierbring.CustomerNumberEqualFold(*i.CustomerNumberEqualFold))
	}
	if i.CustomerNumberContainsFold != nil {
		predicates = append(predicates, carrierbring.CustomerNumberContainsFold(*i.CustomerNumberContainsFold))
	}
	if i.Test != nil {
		predicates = append(predicates, carrierbring.TestEQ(*i.Test))
	}
	if i.TestNEQ != nil {
		predicates = append(predicates, carrierbring.TestNEQ(*i.TestNEQ))
	}

	if i.HasTenant != nil {
		p := carrierbring.HasTenant()
		if !*i.HasTenant {
			p = carrierbring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierbring.HasTenantWith(with...))
	}
	if i.HasCarrier != nil {
		p := carrierbring.HasCarrier()
		if !*i.HasCarrier {
			p = carrierbring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierbring.HasCarrierWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierBringWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierbring.And(predicates...), nil
	}
}

// CarrierDAOWhereInput represents a where input for filtering CarrierDAO queries.
type CarrierDAOWhereInput struct {
	Predicates []predicate.CarrierDAO  `json:"-"`
	Not        *CarrierDAOWhereInput   `json:"not,omitempty"`
	Or         []*CarrierDAOWhereInput `json:"or,omitempty"`
	And        []*CarrierDAOWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "customer_id" field predicates.
	CustomerID             *string  `json:"customerID,omitempty"`
	CustomerIDNEQ          *string  `json:"customerIDNEQ,omitempty"`
	CustomerIDIn           []string `json:"customerIDIn,omitempty"`
	CustomerIDNotIn        []string `json:"customerIDNotIn,omitempty"`
	CustomerIDGT           *string  `json:"customerIDGT,omitempty"`
	CustomerIDGTE          *string  `json:"customerIDGTE,omitempty"`
	CustomerIDLT           *string  `json:"customerIDLT,omitempty"`
	CustomerIDLTE          *string  `json:"customerIDLTE,omitempty"`
	CustomerIDContains     *string  `json:"customerIDContains,omitempty"`
	CustomerIDHasPrefix    *string  `json:"customerIDHasPrefix,omitempty"`
	CustomerIDHasSuffix    *string  `json:"customerIDHasSuffix,omitempty"`
	CustomerIDIsNil        bool     `json:"customerIDIsNil,omitempty"`
	CustomerIDNotNil       bool     `json:"customerIDNotNil,omitempty"`
	CustomerIDEqualFold    *string  `json:"customerIDEqualFold,omitempty"`
	CustomerIDContainsFold *string  `json:"customerIDContainsFold,omitempty"`

	// "api_key" field predicates.
	APIKey             *string  `json:"apiKey,omitempty"`
	APIKeyNEQ          *string  `json:"apiKeyNEQ,omitempty"`
	APIKeyIn           []string `json:"apiKeyIn,omitempty"`
	APIKeyNotIn        []string `json:"apiKeyNotIn,omitempty"`
	APIKeyGT           *string  `json:"apiKeyGT,omitempty"`
	APIKeyGTE          *string  `json:"apiKeyGTE,omitempty"`
	APIKeyLT           *string  `json:"apiKeyLT,omitempty"`
	APIKeyLTE          *string  `json:"apiKeyLTE,omitempty"`
	APIKeyContains     *string  `json:"apiKeyContains,omitempty"`
	APIKeyHasPrefix    *string  `json:"apiKeyHasPrefix,omitempty"`
	APIKeyHasSuffix    *string  `json:"apiKeyHasSuffix,omitempty"`
	APIKeyIsNil        bool     `json:"apiKeyIsNil,omitempty"`
	APIKeyNotNil       bool     `json:"apiKeyNotNil,omitempty"`
	APIKeyEqualFold    *string  `json:"apiKeyEqualFold,omitempty"`
	APIKeyContainsFold *string  `json:"apiKeyContainsFold,omitempty"`

	// "Test" field predicates.
	Test    *bool `json:"test,omitempty"`
	TestNEQ *bool `json:"testNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierDAOWhereInput) AddPredicates(predicates ...predicate.CarrierDAO) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierDAOWhereInput filter on the CarrierDAOQuery builder.
func (i *CarrierDAOWhereInput) Filter(q *CarrierDAOQuery) (*CarrierDAOQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierDAOWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierDAOWhereInput is returned in case the CarrierDAOWhereInput is empty.
var ErrEmptyCarrierDAOWhereInput = errors.New("ent: empty predicate CarrierDAOWhereInput")

// P returns a predicate for filtering carrierdaos.
// An error is returned if the input is empty or invalid.
func (i *CarrierDAOWhereInput) P() (predicate.CarrierDAO, error) {
	var predicates []predicate.CarrierDAO
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierdao.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierDAO, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierdao.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierDAO, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierdao.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierdao.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierdao.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierdao.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierdao.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierdao.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierdao.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierdao.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierdao.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, carrierdao.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, carrierdao.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, carrierdao.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, carrierdao.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, carrierdao.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, carrierdao.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, carrierdao.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, carrierdao.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, carrierdao.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, carrierdao.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, carrierdao.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, carrierdao.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, carrierdao.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.CustomerID != nil {
		predicates = append(predicates, carrierdao.CustomerIDEQ(*i.CustomerID))
	}
	if i.CustomerIDNEQ != nil {
		predicates = append(predicates, carrierdao.CustomerIDNEQ(*i.CustomerIDNEQ))
	}
	if len(i.CustomerIDIn) > 0 {
		predicates = append(predicates, carrierdao.CustomerIDIn(i.CustomerIDIn...))
	}
	if len(i.CustomerIDNotIn) > 0 {
		predicates = append(predicates, carrierdao.CustomerIDNotIn(i.CustomerIDNotIn...))
	}
	if i.CustomerIDGT != nil {
		predicates = append(predicates, carrierdao.CustomerIDGT(*i.CustomerIDGT))
	}
	if i.CustomerIDGTE != nil {
		predicates = append(predicates, carrierdao.CustomerIDGTE(*i.CustomerIDGTE))
	}
	if i.CustomerIDLT != nil {
		predicates = append(predicates, carrierdao.CustomerIDLT(*i.CustomerIDLT))
	}
	if i.CustomerIDLTE != nil {
		predicates = append(predicates, carrierdao.CustomerIDLTE(*i.CustomerIDLTE))
	}
	if i.CustomerIDContains != nil {
		predicates = append(predicates, carrierdao.CustomerIDContains(*i.CustomerIDContains))
	}
	if i.CustomerIDHasPrefix != nil {
		predicates = append(predicates, carrierdao.CustomerIDHasPrefix(*i.CustomerIDHasPrefix))
	}
	if i.CustomerIDHasSuffix != nil {
		predicates = append(predicates, carrierdao.CustomerIDHasSuffix(*i.CustomerIDHasSuffix))
	}
	if i.CustomerIDIsNil {
		predicates = append(predicates, carrierdao.CustomerIDIsNil())
	}
	if i.CustomerIDNotNil {
		predicates = append(predicates, carrierdao.CustomerIDNotNil())
	}
	if i.CustomerIDEqualFold != nil {
		predicates = append(predicates, carrierdao.CustomerIDEqualFold(*i.CustomerIDEqualFold))
	}
	if i.CustomerIDContainsFold != nil {
		predicates = append(predicates, carrierdao.CustomerIDContainsFold(*i.CustomerIDContainsFold))
	}
	if i.APIKey != nil {
		predicates = append(predicates, carrierdao.APIKeyEQ(*i.APIKey))
	}
	if i.APIKeyNEQ != nil {
		predicates = append(predicates, carrierdao.APIKeyNEQ(*i.APIKeyNEQ))
	}
	if len(i.APIKeyIn) > 0 {
		predicates = append(predicates, carrierdao.APIKeyIn(i.APIKeyIn...))
	}
	if len(i.APIKeyNotIn) > 0 {
		predicates = append(predicates, carrierdao.APIKeyNotIn(i.APIKeyNotIn...))
	}
	if i.APIKeyGT != nil {
		predicates = append(predicates, carrierdao.APIKeyGT(*i.APIKeyGT))
	}
	if i.APIKeyGTE != nil {
		predicates = append(predicates, carrierdao.APIKeyGTE(*i.APIKeyGTE))
	}
	if i.APIKeyLT != nil {
		predicates = append(predicates, carrierdao.APIKeyLT(*i.APIKeyLT))
	}
	if i.APIKeyLTE != nil {
		predicates = append(predicates, carrierdao.APIKeyLTE(*i.APIKeyLTE))
	}
	if i.APIKeyContains != nil {
		predicates = append(predicates, carrierdao.APIKeyContains(*i.APIKeyContains))
	}
	if i.APIKeyHasPrefix != nil {
		predicates = append(predicates, carrierdao.APIKeyHasPrefix(*i.APIKeyHasPrefix))
	}
	if i.APIKeyHasSuffix != nil {
		predicates = append(predicates, carrierdao.APIKeyHasSuffix(*i.APIKeyHasSuffix))
	}
	if i.APIKeyIsNil {
		predicates = append(predicates, carrierdao.APIKeyIsNil())
	}
	if i.APIKeyNotNil {
		predicates = append(predicates, carrierdao.APIKeyNotNil())
	}
	if i.APIKeyEqualFold != nil {
		predicates = append(predicates, carrierdao.APIKeyEqualFold(*i.APIKeyEqualFold))
	}
	if i.APIKeyContainsFold != nil {
		predicates = append(predicates, carrierdao.APIKeyContainsFold(*i.APIKeyContainsFold))
	}
	if i.Test != nil {
		predicates = append(predicates, carrierdao.TestEQ(*i.Test))
	}
	if i.TestNEQ != nil {
		predicates = append(predicates, carrierdao.TestNEQ(*i.TestNEQ))
	}

	if i.HasTenant != nil {
		p := carrierdao.HasTenant()
		if !*i.HasTenant {
			p = carrierdao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierdao.HasTenantWith(with...))
	}
	if i.HasCarrier != nil {
		p := carrierdao.HasCarrier()
		if !*i.HasCarrier {
			p = carrierdao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierdao.HasCarrierWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierDAOWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierdao.And(predicates...), nil
	}
}

// CarrierDFWhereInput represents a where input for filtering CarrierDF queries.
type CarrierDFWhereInput struct {
	Predicates []predicate.CarrierDF  `json:"-"`
	Not        *CarrierDFWhereInput   `json:"not,omitempty"`
	Or         []*CarrierDFWhereInput `json:"or,omitempty"`
	And        []*CarrierDFWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "customer_id" field predicates.
	CustomerID             *string  `json:"customerID,omitempty"`
	CustomerIDNEQ          *string  `json:"customerIDNEQ,omitempty"`
	CustomerIDIn           []string `json:"customerIDIn,omitempty"`
	CustomerIDNotIn        []string `json:"customerIDNotIn,omitempty"`
	CustomerIDGT           *string  `json:"customerIDGT,omitempty"`
	CustomerIDGTE          *string  `json:"customerIDGTE,omitempty"`
	CustomerIDLT           *string  `json:"customerIDLT,omitempty"`
	CustomerIDLTE          *string  `json:"customerIDLTE,omitempty"`
	CustomerIDContains     *string  `json:"customerIDContains,omitempty"`
	CustomerIDHasPrefix    *string  `json:"customerIDHasPrefix,omitempty"`
	CustomerIDHasSuffix    *string  `json:"customerIDHasSuffix,omitempty"`
	CustomerIDEqualFold    *string  `json:"customerIDEqualFold,omitempty"`
	CustomerIDContainsFold *string  `json:"customerIDContainsFold,omitempty"`

	// "agreement_number" field predicates.
	AgreementNumber             *string  `json:"agreementNumber,omitempty"`
	AgreementNumberNEQ          *string  `json:"agreementNumberNEQ,omitempty"`
	AgreementNumberIn           []string `json:"agreementNumberIn,omitempty"`
	AgreementNumberNotIn        []string `json:"agreementNumberNotIn,omitempty"`
	AgreementNumberGT           *string  `json:"agreementNumberGT,omitempty"`
	AgreementNumberGTE          *string  `json:"agreementNumberGTE,omitempty"`
	AgreementNumberLT           *string  `json:"agreementNumberLT,omitempty"`
	AgreementNumberLTE          *string  `json:"agreementNumberLTE,omitempty"`
	AgreementNumberContains     *string  `json:"agreementNumberContains,omitempty"`
	AgreementNumberHasPrefix    *string  `json:"agreementNumberHasPrefix,omitempty"`
	AgreementNumberHasSuffix    *string  `json:"agreementNumberHasSuffix,omitempty"`
	AgreementNumberEqualFold    *string  `json:"agreementNumberEqualFold,omitempty"`
	AgreementNumberContainsFold *string  `json:"agreementNumberContainsFold,omitempty"`

	// "who_pays" field predicates.
	WhoPays      *carrierdf.WhoPays  `json:"whoPays,omitempty"`
	WhoPaysNEQ   *carrierdf.WhoPays  `json:"whoPaysNEQ,omitempty"`
	WhoPaysIn    []carrierdf.WhoPays `json:"whoPaysIn,omitempty"`
	WhoPaysNotIn []carrierdf.WhoPays `json:"whoPaysNotIn,omitempty"`

	// "test" field predicates.
	Test    *bool `json:"test,omitempty"`
	TestNEQ *bool `json:"testNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierDFWhereInput) AddPredicates(predicates ...predicate.CarrierDF) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierDFWhereInput filter on the CarrierDFQuery builder.
func (i *CarrierDFWhereInput) Filter(q *CarrierDFQuery) (*CarrierDFQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierDFWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierDFWhereInput is returned in case the CarrierDFWhereInput is empty.
var ErrEmptyCarrierDFWhereInput = errors.New("ent: empty predicate CarrierDFWhereInput")

// P returns a predicate for filtering carrierdfs.
// An error is returned if the input is empty or invalid.
func (i *CarrierDFWhereInput) P() (predicate.CarrierDF, error) {
	var predicates []predicate.CarrierDF
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierdf.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierDF, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierdf.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierDF, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierdf.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierdf.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierdf.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierdf.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierdf.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierdf.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierdf.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierdf.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierdf.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, carrierdf.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, carrierdf.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, carrierdf.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, carrierdf.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, carrierdf.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, carrierdf.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, carrierdf.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, carrierdf.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, carrierdf.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, carrierdf.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, carrierdf.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, carrierdf.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, carrierdf.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.CustomerID != nil {
		predicates = append(predicates, carrierdf.CustomerIDEQ(*i.CustomerID))
	}
	if i.CustomerIDNEQ != nil {
		predicates = append(predicates, carrierdf.CustomerIDNEQ(*i.CustomerIDNEQ))
	}
	if len(i.CustomerIDIn) > 0 {
		predicates = append(predicates, carrierdf.CustomerIDIn(i.CustomerIDIn...))
	}
	if len(i.CustomerIDNotIn) > 0 {
		predicates = append(predicates, carrierdf.CustomerIDNotIn(i.CustomerIDNotIn...))
	}
	if i.CustomerIDGT != nil {
		predicates = append(predicates, carrierdf.CustomerIDGT(*i.CustomerIDGT))
	}
	if i.CustomerIDGTE != nil {
		predicates = append(predicates, carrierdf.CustomerIDGTE(*i.CustomerIDGTE))
	}
	if i.CustomerIDLT != nil {
		predicates = append(predicates, carrierdf.CustomerIDLT(*i.CustomerIDLT))
	}
	if i.CustomerIDLTE != nil {
		predicates = append(predicates, carrierdf.CustomerIDLTE(*i.CustomerIDLTE))
	}
	if i.CustomerIDContains != nil {
		predicates = append(predicates, carrierdf.CustomerIDContains(*i.CustomerIDContains))
	}
	if i.CustomerIDHasPrefix != nil {
		predicates = append(predicates, carrierdf.CustomerIDHasPrefix(*i.CustomerIDHasPrefix))
	}
	if i.CustomerIDHasSuffix != nil {
		predicates = append(predicates, carrierdf.CustomerIDHasSuffix(*i.CustomerIDHasSuffix))
	}
	if i.CustomerIDEqualFold != nil {
		predicates = append(predicates, carrierdf.CustomerIDEqualFold(*i.CustomerIDEqualFold))
	}
	if i.CustomerIDContainsFold != nil {
		predicates = append(predicates, carrierdf.CustomerIDContainsFold(*i.CustomerIDContainsFold))
	}
	if i.AgreementNumber != nil {
		predicates = append(predicates, carrierdf.AgreementNumberEQ(*i.AgreementNumber))
	}
	if i.AgreementNumberNEQ != nil {
		predicates = append(predicates, carrierdf.AgreementNumberNEQ(*i.AgreementNumberNEQ))
	}
	if len(i.AgreementNumberIn) > 0 {
		predicates = append(predicates, carrierdf.AgreementNumberIn(i.AgreementNumberIn...))
	}
	if len(i.AgreementNumberNotIn) > 0 {
		predicates = append(predicates, carrierdf.AgreementNumberNotIn(i.AgreementNumberNotIn...))
	}
	if i.AgreementNumberGT != nil {
		predicates = append(predicates, carrierdf.AgreementNumberGT(*i.AgreementNumberGT))
	}
	if i.AgreementNumberGTE != nil {
		predicates = append(predicates, carrierdf.AgreementNumberGTE(*i.AgreementNumberGTE))
	}
	if i.AgreementNumberLT != nil {
		predicates = append(predicates, carrierdf.AgreementNumberLT(*i.AgreementNumberLT))
	}
	if i.AgreementNumberLTE != nil {
		predicates = append(predicates, carrierdf.AgreementNumberLTE(*i.AgreementNumberLTE))
	}
	if i.AgreementNumberContains != nil {
		predicates = append(predicates, carrierdf.AgreementNumberContains(*i.AgreementNumberContains))
	}
	if i.AgreementNumberHasPrefix != nil {
		predicates = append(predicates, carrierdf.AgreementNumberHasPrefix(*i.AgreementNumberHasPrefix))
	}
	if i.AgreementNumberHasSuffix != nil {
		predicates = append(predicates, carrierdf.AgreementNumberHasSuffix(*i.AgreementNumberHasSuffix))
	}
	if i.AgreementNumberEqualFold != nil {
		predicates = append(predicates, carrierdf.AgreementNumberEqualFold(*i.AgreementNumberEqualFold))
	}
	if i.AgreementNumberContainsFold != nil {
		predicates = append(predicates, carrierdf.AgreementNumberContainsFold(*i.AgreementNumberContainsFold))
	}
	if i.WhoPays != nil {
		predicates = append(predicates, carrierdf.WhoPaysEQ(*i.WhoPays))
	}
	if i.WhoPaysNEQ != nil {
		predicates = append(predicates, carrierdf.WhoPaysNEQ(*i.WhoPaysNEQ))
	}
	if len(i.WhoPaysIn) > 0 {
		predicates = append(predicates, carrierdf.WhoPaysIn(i.WhoPaysIn...))
	}
	if len(i.WhoPaysNotIn) > 0 {
		predicates = append(predicates, carrierdf.WhoPaysNotIn(i.WhoPaysNotIn...))
	}
	if i.Test != nil {
		predicates = append(predicates, carrierdf.TestEQ(*i.Test))
	}
	if i.TestNEQ != nil {
		predicates = append(predicates, carrierdf.TestNEQ(*i.TestNEQ))
	}

	if i.HasTenant != nil {
		p := carrierdf.HasTenant()
		if !*i.HasTenant {
			p = carrierdf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierdf.HasTenantWith(with...))
	}
	if i.HasCarrier != nil {
		p := carrierdf.HasCarrier()
		if !*i.HasCarrier {
			p = carrierdf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierdf.HasCarrierWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierDFWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierdf.And(predicates...), nil
	}
}

// CarrierDSVWhereInput represents a where input for filtering CarrierDSV queries.
type CarrierDSVWhereInput struct {
	Predicates []predicate.CarrierDSV  `json:"-"`
	Not        *CarrierDSVWhereInput   `json:"not,omitempty"`
	Or         []*CarrierDSVWhereInput `json:"or,omitempty"`
	And        []*CarrierDSVWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierDSVWhereInput) AddPredicates(predicates ...predicate.CarrierDSV) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierDSVWhereInput filter on the CarrierDSVQuery builder.
func (i *CarrierDSVWhereInput) Filter(q *CarrierDSVQuery) (*CarrierDSVQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierDSVWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierDSVWhereInput is returned in case the CarrierDSVWhereInput is empty.
var ErrEmptyCarrierDSVWhereInput = errors.New("ent: empty predicate CarrierDSVWhereInput")

// P returns a predicate for filtering carrierdsvs.
// An error is returned if the input is empty or invalid.
func (i *CarrierDSVWhereInput) P() (predicate.CarrierDSV, error) {
	var predicates []predicate.CarrierDSV
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierdsv.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierDSV, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierdsv.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierDSV, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierdsv.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierdsv.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierdsv.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierdsv.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierdsv.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierdsv.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierdsv.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierdsv.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierdsv.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, carrierdsv.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, carrierdsv.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, carrierdsv.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, carrierdsv.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, carrierdsv.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, carrierdsv.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, carrierdsv.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, carrierdsv.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, carrierdsv.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, carrierdsv.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, carrierdsv.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, carrierdsv.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, carrierdsv.TenantIDContainsFold(*i.TenantIDContainsFold))
	}

	if i.HasTenant != nil {
		p := carrierdsv.HasTenant()
		if !*i.HasTenant {
			p = carrierdsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierdsv.HasTenantWith(with...))
	}
	if i.HasCarrier != nil {
		p := carrierdsv.HasCarrier()
		if !*i.HasCarrier {
			p = carrierdsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierdsv.HasCarrierWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierDSVWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierdsv.And(predicates...), nil
	}
}

// CarrierEasyPostWhereInput represents a where input for filtering CarrierEasyPost queries.
type CarrierEasyPostWhereInput struct {
	Predicates []predicate.CarrierEasyPost  `json:"-"`
	Not        *CarrierEasyPostWhereInput   `json:"not,omitempty"`
	Or         []*CarrierEasyPostWhereInput `json:"or,omitempty"`
	And        []*CarrierEasyPostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "api_key" field predicates.
	APIKey             *string  `json:"apiKey,omitempty"`
	APIKeyNEQ          *string  `json:"apiKeyNEQ,omitempty"`
	APIKeyIn           []string `json:"apiKeyIn,omitempty"`
	APIKeyNotIn        []string `json:"apiKeyNotIn,omitempty"`
	APIKeyGT           *string  `json:"apiKeyGT,omitempty"`
	APIKeyGTE          *string  `json:"apiKeyGTE,omitempty"`
	APIKeyLT           *string  `json:"apiKeyLT,omitempty"`
	APIKeyLTE          *string  `json:"apiKeyLTE,omitempty"`
	APIKeyContains     *string  `json:"apiKeyContains,omitempty"`
	APIKeyHasPrefix    *string  `json:"apiKeyHasPrefix,omitempty"`
	APIKeyHasSuffix    *string  `json:"apiKeyHasSuffix,omitempty"`
	APIKeyEqualFold    *string  `json:"apiKeyEqualFold,omitempty"`
	APIKeyContainsFold *string  `json:"apiKeyContainsFold,omitempty"`

	// "test" field predicates.
	Test    *bool `json:"test,omitempty"`
	TestNEQ *bool `json:"testNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierEasyPostWhereInput) AddPredicates(predicates ...predicate.CarrierEasyPost) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierEasyPostWhereInput filter on the CarrierEasyPostQuery builder.
func (i *CarrierEasyPostWhereInput) Filter(q *CarrierEasyPostQuery) (*CarrierEasyPostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierEasyPostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierEasyPostWhereInput is returned in case the CarrierEasyPostWhereInput is empty.
var ErrEmptyCarrierEasyPostWhereInput = errors.New("ent: empty predicate CarrierEasyPostWhereInput")

// P returns a predicate for filtering carriereasyposts.
// An error is returned if the input is empty or invalid.
func (i *CarrierEasyPostWhereInput) P() (predicate.CarrierEasyPost, error) {
	var predicates []predicate.CarrierEasyPost
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carriereasypost.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierEasyPost, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carriereasypost.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierEasyPost, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carriereasypost.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carriereasypost.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carriereasypost.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carriereasypost.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carriereasypost.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carriereasypost.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carriereasypost.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carriereasypost.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carriereasypost.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, carriereasypost.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, carriereasypost.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, carriereasypost.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, carriereasypost.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, carriereasypost.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, carriereasypost.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, carriereasypost.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, carriereasypost.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, carriereasypost.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, carriereasypost.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, carriereasypost.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, carriereasypost.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, carriereasypost.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.APIKey != nil {
		predicates = append(predicates, carriereasypost.APIKeyEQ(*i.APIKey))
	}
	if i.APIKeyNEQ != nil {
		predicates = append(predicates, carriereasypost.APIKeyNEQ(*i.APIKeyNEQ))
	}
	if len(i.APIKeyIn) > 0 {
		predicates = append(predicates, carriereasypost.APIKeyIn(i.APIKeyIn...))
	}
	if len(i.APIKeyNotIn) > 0 {
		predicates = append(predicates, carriereasypost.APIKeyNotIn(i.APIKeyNotIn...))
	}
	if i.APIKeyGT != nil {
		predicates = append(predicates, carriereasypost.APIKeyGT(*i.APIKeyGT))
	}
	if i.APIKeyGTE != nil {
		predicates = append(predicates, carriereasypost.APIKeyGTE(*i.APIKeyGTE))
	}
	if i.APIKeyLT != nil {
		predicates = append(predicates, carriereasypost.APIKeyLT(*i.APIKeyLT))
	}
	if i.APIKeyLTE != nil {
		predicates = append(predicates, carriereasypost.APIKeyLTE(*i.APIKeyLTE))
	}
	if i.APIKeyContains != nil {
		predicates = append(predicates, carriereasypost.APIKeyContains(*i.APIKeyContains))
	}
	if i.APIKeyHasPrefix != nil {
		predicates = append(predicates, carriereasypost.APIKeyHasPrefix(*i.APIKeyHasPrefix))
	}
	if i.APIKeyHasSuffix != nil {
		predicates = append(predicates, carriereasypost.APIKeyHasSuffix(*i.APIKeyHasSuffix))
	}
	if i.APIKeyEqualFold != nil {
		predicates = append(predicates, carriereasypost.APIKeyEqualFold(*i.APIKeyEqualFold))
	}
	if i.APIKeyContainsFold != nil {
		predicates = append(predicates, carriereasypost.APIKeyContainsFold(*i.APIKeyContainsFold))
	}
	if i.Test != nil {
		predicates = append(predicates, carriereasypost.TestEQ(*i.Test))
	}
	if i.TestNEQ != nil {
		predicates = append(predicates, carriereasypost.TestNEQ(*i.TestNEQ))
	}

	if i.HasTenant != nil {
		p := carriereasypost.HasTenant()
		if !*i.HasTenant {
			p = carriereasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carriereasypost.HasTenantWith(with...))
	}
	if i.HasCarrier != nil {
		p := carriereasypost.HasCarrier()
		if !*i.HasCarrier {
			p = carriereasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carriereasypost.HasCarrierWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierEasyPostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carriereasypost.And(predicates...), nil
	}
}

// CarrierGLSWhereInput represents a where input for filtering CarrierGLS queries.
type CarrierGLSWhereInput struct {
	Predicates []predicate.CarrierGLS  `json:"-"`
	Not        *CarrierGLSWhereInput   `json:"not,omitempty"`
	Or         []*CarrierGLSWhereInput `json:"or,omitempty"`
	And        []*CarrierGLSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "contact_id" field predicates.
	ContactID             *string  `json:"contactID,omitempty"`
	ContactIDNEQ          *string  `json:"contactIDNEQ,omitempty"`
	ContactIDIn           []string `json:"contactIDIn,omitempty"`
	ContactIDNotIn        []string `json:"contactIDNotIn,omitempty"`
	ContactIDGT           *string  `json:"contactIDGT,omitempty"`
	ContactIDGTE          *string  `json:"contactIDGTE,omitempty"`
	ContactIDLT           *string  `json:"contactIDLT,omitempty"`
	ContactIDLTE          *string  `json:"contactIDLTE,omitempty"`
	ContactIDContains     *string  `json:"contactIDContains,omitempty"`
	ContactIDHasPrefix    *string  `json:"contactIDHasPrefix,omitempty"`
	ContactIDHasSuffix    *string  `json:"contactIDHasSuffix,omitempty"`
	ContactIDIsNil        bool     `json:"contactIDIsNil,omitempty"`
	ContactIDNotNil       bool     `json:"contactIDNotNil,omitempty"`
	ContactIDEqualFold    *string  `json:"contactIDEqualFold,omitempty"`
	ContactIDContainsFold *string  `json:"contactIDContainsFold,omitempty"`

	// "gls_username" field predicates.
	GLSUsername             *string  `json:"glsUsername,omitempty"`
	GLSUsernameNEQ          *string  `json:"glsUsernameNEQ,omitempty"`
	GLSUsernameIn           []string `json:"glsUsernameIn,omitempty"`
	GLSUsernameNotIn        []string `json:"glsUsernameNotIn,omitempty"`
	GLSUsernameGT           *string  `json:"glsUsernameGT,omitempty"`
	GLSUsernameGTE          *string  `json:"glsUsernameGTE,omitempty"`
	GLSUsernameLT           *string  `json:"glsUsernameLT,omitempty"`
	GLSUsernameLTE          *string  `json:"glsUsernameLTE,omitempty"`
	GLSUsernameContains     *string  `json:"glsUsernameContains,omitempty"`
	GLSUsernameHasPrefix    *string  `json:"glsUsernameHasPrefix,omitempty"`
	GLSUsernameHasSuffix    *string  `json:"glsUsernameHasSuffix,omitempty"`
	GLSUsernameIsNil        bool     `json:"glsUsernameIsNil,omitempty"`
	GLSUsernameNotNil       bool     `json:"glsUsernameNotNil,omitempty"`
	GLSUsernameEqualFold    *string  `json:"glsUsernameEqualFold,omitempty"`
	GLSUsernameContainsFold *string  `json:"glsUsernameContainsFold,omitempty"`

	// "gls_password" field predicates.
	GLSPassword             *string  `json:"glsPassword,omitempty"`
	GLSPasswordNEQ          *string  `json:"glsPasswordNEQ,omitempty"`
	GLSPasswordIn           []string `json:"glsPasswordIn,omitempty"`
	GLSPasswordNotIn        []string `json:"glsPasswordNotIn,omitempty"`
	GLSPasswordGT           *string  `json:"glsPasswordGT,omitempty"`
	GLSPasswordGTE          *string  `json:"glsPasswordGTE,omitempty"`
	GLSPasswordLT           *string  `json:"glsPasswordLT,omitempty"`
	GLSPasswordLTE          *string  `json:"glsPasswordLTE,omitempty"`
	GLSPasswordContains     *string  `json:"glsPasswordContains,omitempty"`
	GLSPasswordHasPrefix    *string  `json:"glsPasswordHasPrefix,omitempty"`
	GLSPasswordHasSuffix    *string  `json:"glsPasswordHasSuffix,omitempty"`
	GLSPasswordIsNil        bool     `json:"glsPasswordIsNil,omitempty"`
	GLSPasswordNotNil       bool     `json:"glsPasswordNotNil,omitempty"`
	GLSPasswordEqualFold    *string  `json:"glsPasswordEqualFold,omitempty"`
	GLSPasswordContainsFold *string  `json:"glsPasswordContainsFold,omitempty"`

	// "customer_id" field predicates.
	CustomerID             *string  `json:"customerID,omitempty"`
	CustomerIDNEQ          *string  `json:"customerIDNEQ,omitempty"`
	CustomerIDIn           []string `json:"customerIDIn,omitempty"`
	CustomerIDNotIn        []string `json:"customerIDNotIn,omitempty"`
	CustomerIDGT           *string  `json:"customerIDGT,omitempty"`
	CustomerIDGTE          *string  `json:"customerIDGTE,omitempty"`
	CustomerIDLT           *string  `json:"customerIDLT,omitempty"`
	CustomerIDLTE          *string  `json:"customerIDLTE,omitempty"`
	CustomerIDContains     *string  `json:"customerIDContains,omitempty"`
	CustomerIDHasPrefix    *string  `json:"customerIDHasPrefix,omitempty"`
	CustomerIDHasSuffix    *string  `json:"customerIDHasSuffix,omitempty"`
	CustomerIDIsNil        bool     `json:"customerIDIsNil,omitempty"`
	CustomerIDNotNil       bool     `json:"customerIDNotNil,omitempty"`
	CustomerIDEqualFold    *string  `json:"customerIDEqualFold,omitempty"`
	CustomerIDContainsFold *string  `json:"customerIDContainsFold,omitempty"`

	// "gls_country_code" field predicates.
	GLSCountryCode             *string  `json:"glsCountryCode,omitempty"`
	GLSCountryCodeNEQ          *string  `json:"glsCountryCodeNEQ,omitempty"`
	GLSCountryCodeIn           []string `json:"glsCountryCodeIn,omitempty"`
	GLSCountryCodeNotIn        []string `json:"glsCountryCodeNotIn,omitempty"`
	GLSCountryCodeGT           *string  `json:"glsCountryCodeGT,omitempty"`
	GLSCountryCodeGTE          *string  `json:"glsCountryCodeGTE,omitempty"`
	GLSCountryCodeLT           *string  `json:"glsCountryCodeLT,omitempty"`
	GLSCountryCodeLTE          *string  `json:"glsCountryCodeLTE,omitempty"`
	GLSCountryCodeContains     *string  `json:"glsCountryCodeContains,omitempty"`
	GLSCountryCodeHasPrefix    *string  `json:"glsCountryCodeHasPrefix,omitempty"`
	GLSCountryCodeHasSuffix    *string  `json:"glsCountryCodeHasSuffix,omitempty"`
	GLSCountryCodeIsNil        bool     `json:"glsCountryCodeIsNil,omitempty"`
	GLSCountryCodeNotNil       bool     `json:"glsCountryCodeNotNil,omitempty"`
	GLSCountryCodeEqualFold    *string  `json:"glsCountryCodeEqualFold,omitempty"`
	GLSCountryCodeContainsFold *string  `json:"glsCountryCodeContainsFold,omitempty"`

	// "sync_shipment_cancellation" field predicates.
	SyncShipmentCancellation       *bool `json:"syncShipmentCancellation,omitempty"`
	SyncShipmentCancellationNEQ    *bool `json:"syncShipmentCancellationNEQ,omitempty"`
	SyncShipmentCancellationIsNil  bool  `json:"syncShipmentCancellationIsNil,omitempty"`
	SyncShipmentCancellationNotNil bool  `json:"syncShipmentCancellationNotNil,omitempty"`

	// "print_error_on_label" field predicates.
	PrintErrorOnLabel       *bool `json:"printErrorOnLabel,omitempty"`
	PrintErrorOnLabelNEQ    *bool `json:"printErrorOnLabelNEQ,omitempty"`
	PrintErrorOnLabelIsNil  bool  `json:"printErrorOnLabelIsNil,omitempty"`
	PrintErrorOnLabelNotNil bool  `json:"printErrorOnLabelNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierGLSWhereInput) AddPredicates(predicates ...predicate.CarrierGLS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierGLSWhereInput filter on the CarrierGLSQuery builder.
func (i *CarrierGLSWhereInput) Filter(q *CarrierGLSQuery) (*CarrierGLSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierGLSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierGLSWhereInput is returned in case the CarrierGLSWhereInput is empty.
var ErrEmptyCarrierGLSWhereInput = errors.New("ent: empty predicate CarrierGLSWhereInput")

// P returns a predicate for filtering carrierglss.
// An error is returned if the input is empty or invalid.
func (i *CarrierGLSWhereInput) P() (predicate.CarrierGLS, error) {
	var predicates []predicate.CarrierGLS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carriergls.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierGLS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carriergls.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierGLS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carriergls.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carriergls.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carriergls.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carriergls.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carriergls.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carriergls.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carriergls.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carriergls.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carriergls.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, carriergls.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, carriergls.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, carriergls.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, carriergls.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, carriergls.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, carriergls.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, carriergls.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, carriergls.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, carriergls.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, carriergls.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, carriergls.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, carriergls.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, carriergls.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ContactID != nil {
		predicates = append(predicates, carriergls.ContactIDEQ(*i.ContactID))
	}
	if i.ContactIDNEQ != nil {
		predicates = append(predicates, carriergls.ContactIDNEQ(*i.ContactIDNEQ))
	}
	if len(i.ContactIDIn) > 0 {
		predicates = append(predicates, carriergls.ContactIDIn(i.ContactIDIn...))
	}
	if len(i.ContactIDNotIn) > 0 {
		predicates = append(predicates, carriergls.ContactIDNotIn(i.ContactIDNotIn...))
	}
	if i.ContactIDGT != nil {
		predicates = append(predicates, carriergls.ContactIDGT(*i.ContactIDGT))
	}
	if i.ContactIDGTE != nil {
		predicates = append(predicates, carriergls.ContactIDGTE(*i.ContactIDGTE))
	}
	if i.ContactIDLT != nil {
		predicates = append(predicates, carriergls.ContactIDLT(*i.ContactIDLT))
	}
	if i.ContactIDLTE != nil {
		predicates = append(predicates, carriergls.ContactIDLTE(*i.ContactIDLTE))
	}
	if i.ContactIDContains != nil {
		predicates = append(predicates, carriergls.ContactIDContains(*i.ContactIDContains))
	}
	if i.ContactIDHasPrefix != nil {
		predicates = append(predicates, carriergls.ContactIDHasPrefix(*i.ContactIDHasPrefix))
	}
	if i.ContactIDHasSuffix != nil {
		predicates = append(predicates, carriergls.ContactIDHasSuffix(*i.ContactIDHasSuffix))
	}
	if i.ContactIDIsNil {
		predicates = append(predicates, carriergls.ContactIDIsNil())
	}
	if i.ContactIDNotNil {
		predicates = append(predicates, carriergls.ContactIDNotNil())
	}
	if i.ContactIDEqualFold != nil {
		predicates = append(predicates, carriergls.ContactIDEqualFold(*i.ContactIDEqualFold))
	}
	if i.ContactIDContainsFold != nil {
		predicates = append(predicates, carriergls.ContactIDContainsFold(*i.ContactIDContainsFold))
	}
	if i.GLSUsername != nil {
		predicates = append(predicates, carriergls.GLSUsernameEQ(*i.GLSUsername))
	}
	if i.GLSUsernameNEQ != nil {
		predicates = append(predicates, carriergls.GLSUsernameNEQ(*i.GLSUsernameNEQ))
	}
	if len(i.GLSUsernameIn) > 0 {
		predicates = append(predicates, carriergls.GLSUsernameIn(i.GLSUsernameIn...))
	}
	if len(i.GLSUsernameNotIn) > 0 {
		predicates = append(predicates, carriergls.GLSUsernameNotIn(i.GLSUsernameNotIn...))
	}
	if i.GLSUsernameGT != nil {
		predicates = append(predicates, carriergls.GLSUsernameGT(*i.GLSUsernameGT))
	}
	if i.GLSUsernameGTE != nil {
		predicates = append(predicates, carriergls.GLSUsernameGTE(*i.GLSUsernameGTE))
	}
	if i.GLSUsernameLT != nil {
		predicates = append(predicates, carriergls.GLSUsernameLT(*i.GLSUsernameLT))
	}
	if i.GLSUsernameLTE != nil {
		predicates = append(predicates, carriergls.GLSUsernameLTE(*i.GLSUsernameLTE))
	}
	if i.GLSUsernameContains != nil {
		predicates = append(predicates, carriergls.GLSUsernameContains(*i.GLSUsernameContains))
	}
	if i.GLSUsernameHasPrefix != nil {
		predicates = append(predicates, carriergls.GLSUsernameHasPrefix(*i.GLSUsernameHasPrefix))
	}
	if i.GLSUsernameHasSuffix != nil {
		predicates = append(predicates, carriergls.GLSUsernameHasSuffix(*i.GLSUsernameHasSuffix))
	}
	if i.GLSUsernameIsNil {
		predicates = append(predicates, carriergls.GLSUsernameIsNil())
	}
	if i.GLSUsernameNotNil {
		predicates = append(predicates, carriergls.GLSUsernameNotNil())
	}
	if i.GLSUsernameEqualFold != nil {
		predicates = append(predicates, carriergls.GLSUsernameEqualFold(*i.GLSUsernameEqualFold))
	}
	if i.GLSUsernameContainsFold != nil {
		predicates = append(predicates, carriergls.GLSUsernameContainsFold(*i.GLSUsernameContainsFold))
	}
	if i.GLSPassword != nil {
		predicates = append(predicates, carriergls.GLSPasswordEQ(*i.GLSPassword))
	}
	if i.GLSPasswordNEQ != nil {
		predicates = append(predicates, carriergls.GLSPasswordNEQ(*i.GLSPasswordNEQ))
	}
	if len(i.GLSPasswordIn) > 0 {
		predicates = append(predicates, carriergls.GLSPasswordIn(i.GLSPasswordIn...))
	}
	if len(i.GLSPasswordNotIn) > 0 {
		predicates = append(predicates, carriergls.GLSPasswordNotIn(i.GLSPasswordNotIn...))
	}
	if i.GLSPasswordGT != nil {
		predicates = append(predicates, carriergls.GLSPasswordGT(*i.GLSPasswordGT))
	}
	if i.GLSPasswordGTE != nil {
		predicates = append(predicates, carriergls.GLSPasswordGTE(*i.GLSPasswordGTE))
	}
	if i.GLSPasswordLT != nil {
		predicates = append(predicates, carriergls.GLSPasswordLT(*i.GLSPasswordLT))
	}
	if i.GLSPasswordLTE != nil {
		predicates = append(predicates, carriergls.GLSPasswordLTE(*i.GLSPasswordLTE))
	}
	if i.GLSPasswordContains != nil {
		predicates = append(predicates, carriergls.GLSPasswordContains(*i.GLSPasswordContains))
	}
	if i.GLSPasswordHasPrefix != nil {
		predicates = append(predicates, carriergls.GLSPasswordHasPrefix(*i.GLSPasswordHasPrefix))
	}
	if i.GLSPasswordHasSuffix != nil {
		predicates = append(predicates, carriergls.GLSPasswordHasSuffix(*i.GLSPasswordHasSuffix))
	}
	if i.GLSPasswordIsNil {
		predicates = append(predicates, carriergls.GLSPasswordIsNil())
	}
	if i.GLSPasswordNotNil {
		predicates = append(predicates, carriergls.GLSPasswordNotNil())
	}
	if i.GLSPasswordEqualFold != nil {
		predicates = append(predicates, carriergls.GLSPasswordEqualFold(*i.GLSPasswordEqualFold))
	}
	if i.GLSPasswordContainsFold != nil {
		predicates = append(predicates, carriergls.GLSPasswordContainsFold(*i.GLSPasswordContainsFold))
	}
	if i.CustomerID != nil {
		predicates = append(predicates, carriergls.CustomerIDEQ(*i.CustomerID))
	}
	if i.CustomerIDNEQ != nil {
		predicates = append(predicates, carriergls.CustomerIDNEQ(*i.CustomerIDNEQ))
	}
	if len(i.CustomerIDIn) > 0 {
		predicates = append(predicates, carriergls.CustomerIDIn(i.CustomerIDIn...))
	}
	if len(i.CustomerIDNotIn) > 0 {
		predicates = append(predicates, carriergls.CustomerIDNotIn(i.CustomerIDNotIn...))
	}
	if i.CustomerIDGT != nil {
		predicates = append(predicates, carriergls.CustomerIDGT(*i.CustomerIDGT))
	}
	if i.CustomerIDGTE != nil {
		predicates = append(predicates, carriergls.CustomerIDGTE(*i.CustomerIDGTE))
	}
	if i.CustomerIDLT != nil {
		predicates = append(predicates, carriergls.CustomerIDLT(*i.CustomerIDLT))
	}
	if i.CustomerIDLTE != nil {
		predicates = append(predicates, carriergls.CustomerIDLTE(*i.CustomerIDLTE))
	}
	if i.CustomerIDContains != nil {
		predicates = append(predicates, carriergls.CustomerIDContains(*i.CustomerIDContains))
	}
	if i.CustomerIDHasPrefix != nil {
		predicates = append(predicates, carriergls.CustomerIDHasPrefix(*i.CustomerIDHasPrefix))
	}
	if i.CustomerIDHasSuffix != nil {
		predicates = append(predicates, carriergls.CustomerIDHasSuffix(*i.CustomerIDHasSuffix))
	}
	if i.CustomerIDIsNil {
		predicates = append(predicates, carriergls.CustomerIDIsNil())
	}
	if i.CustomerIDNotNil {
		predicates = append(predicates, carriergls.CustomerIDNotNil())
	}
	if i.CustomerIDEqualFold != nil {
		predicates = append(predicates, carriergls.CustomerIDEqualFold(*i.CustomerIDEqualFold))
	}
	if i.CustomerIDContainsFold != nil {
		predicates = append(predicates, carriergls.CustomerIDContainsFold(*i.CustomerIDContainsFold))
	}
	if i.GLSCountryCode != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeEQ(*i.GLSCountryCode))
	}
	if i.GLSCountryCodeNEQ != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeNEQ(*i.GLSCountryCodeNEQ))
	}
	if len(i.GLSCountryCodeIn) > 0 {
		predicates = append(predicates, carriergls.GLSCountryCodeIn(i.GLSCountryCodeIn...))
	}
	if len(i.GLSCountryCodeNotIn) > 0 {
		predicates = append(predicates, carriergls.GLSCountryCodeNotIn(i.GLSCountryCodeNotIn...))
	}
	if i.GLSCountryCodeGT != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeGT(*i.GLSCountryCodeGT))
	}
	if i.GLSCountryCodeGTE != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeGTE(*i.GLSCountryCodeGTE))
	}
	if i.GLSCountryCodeLT != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeLT(*i.GLSCountryCodeLT))
	}
	if i.GLSCountryCodeLTE != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeLTE(*i.GLSCountryCodeLTE))
	}
	if i.GLSCountryCodeContains != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeContains(*i.GLSCountryCodeContains))
	}
	if i.GLSCountryCodeHasPrefix != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeHasPrefix(*i.GLSCountryCodeHasPrefix))
	}
	if i.GLSCountryCodeHasSuffix != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeHasSuffix(*i.GLSCountryCodeHasSuffix))
	}
	if i.GLSCountryCodeIsNil {
		predicates = append(predicates, carriergls.GLSCountryCodeIsNil())
	}
	if i.GLSCountryCodeNotNil {
		predicates = append(predicates, carriergls.GLSCountryCodeNotNil())
	}
	if i.GLSCountryCodeEqualFold != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeEqualFold(*i.GLSCountryCodeEqualFold))
	}
	if i.GLSCountryCodeContainsFold != nil {
		predicates = append(predicates, carriergls.GLSCountryCodeContainsFold(*i.GLSCountryCodeContainsFold))
	}
	if i.SyncShipmentCancellation != nil {
		predicates = append(predicates, carriergls.SyncShipmentCancellationEQ(*i.SyncShipmentCancellation))
	}
	if i.SyncShipmentCancellationNEQ != nil {
		predicates = append(predicates, carriergls.SyncShipmentCancellationNEQ(*i.SyncShipmentCancellationNEQ))
	}
	if i.SyncShipmentCancellationIsNil {
		predicates = append(predicates, carriergls.SyncShipmentCancellationIsNil())
	}
	if i.SyncShipmentCancellationNotNil {
		predicates = append(predicates, carriergls.SyncShipmentCancellationNotNil())
	}
	if i.PrintErrorOnLabel != nil {
		predicates = append(predicates, carriergls.PrintErrorOnLabelEQ(*i.PrintErrorOnLabel))
	}
	if i.PrintErrorOnLabelNEQ != nil {
		predicates = append(predicates, carriergls.PrintErrorOnLabelNEQ(*i.PrintErrorOnLabelNEQ))
	}
	if i.PrintErrorOnLabelIsNil {
		predicates = append(predicates, carriergls.PrintErrorOnLabelIsNil())
	}
	if i.PrintErrorOnLabelNotNil {
		predicates = append(predicates, carriergls.PrintErrorOnLabelNotNil())
	}

	if i.HasTenant != nil {
		p := carriergls.HasTenant()
		if !*i.HasTenant {
			p = carriergls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carriergls.HasTenantWith(with...))
	}
	if i.HasCarrier != nil {
		p := carriergls.HasCarrier()
		if !*i.HasCarrier {
			p = carriergls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carriergls.HasCarrierWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierGLSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carriergls.And(predicates...), nil
	}
}

// CarrierPostNordWhereInput represents a where input for filtering CarrierPostNord queries.
type CarrierPostNordWhereInput struct {
	Predicates []predicate.CarrierPostNord  `json:"-"`
	Not        *CarrierPostNordWhereInput   `json:"not,omitempty"`
	Or         []*CarrierPostNordWhereInput `json:"or,omitempty"`
	And        []*CarrierPostNordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "customer_number" field predicates.
	CustomerNumber             *string  `json:"customerNumber,omitempty"`
	CustomerNumberNEQ          *string  `json:"customerNumberNEQ,omitempty"`
	CustomerNumberIn           []string `json:"customerNumberIn,omitempty"`
	CustomerNumberNotIn        []string `json:"customerNumberNotIn,omitempty"`
	CustomerNumberGT           *string  `json:"customerNumberGT,omitempty"`
	CustomerNumberGTE          *string  `json:"customerNumberGTE,omitempty"`
	CustomerNumberLT           *string  `json:"customerNumberLT,omitempty"`
	CustomerNumberLTE          *string  `json:"customerNumberLTE,omitempty"`
	CustomerNumberContains     *string  `json:"customerNumberContains,omitempty"`
	CustomerNumberHasPrefix    *string  `json:"customerNumberHasPrefix,omitempty"`
	CustomerNumberHasSuffix    *string  `json:"customerNumberHasSuffix,omitempty"`
	CustomerNumberEqualFold    *string  `json:"customerNumberEqualFold,omitempty"`
	CustomerNumberContainsFold *string  `json:"customerNumberContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierPostNordWhereInput) AddPredicates(predicates ...predicate.CarrierPostNord) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierPostNordWhereInput filter on the CarrierPostNordQuery builder.
func (i *CarrierPostNordWhereInput) Filter(q *CarrierPostNordQuery) (*CarrierPostNordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierPostNordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierPostNordWhereInput is returned in case the CarrierPostNordWhereInput is empty.
var ErrEmptyCarrierPostNordWhereInput = errors.New("ent: empty predicate CarrierPostNordWhereInput")

// P returns a predicate for filtering carrierpostnords.
// An error is returned if the input is empty or invalid.
func (i *CarrierPostNordWhereInput) P() (predicate.CarrierPostNord, error) {
	var predicates []predicate.CarrierPostNord
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierpostnord.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierPostNord, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierpostnord.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierPostNord, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierpostnord.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierpostnord.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierpostnord.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierpostnord.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierpostnord.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierpostnord.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierpostnord.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierpostnord.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierpostnord.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, carrierpostnord.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, carrierpostnord.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, carrierpostnord.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, carrierpostnord.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, carrierpostnord.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, carrierpostnord.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, carrierpostnord.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, carrierpostnord.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, carrierpostnord.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, carrierpostnord.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, carrierpostnord.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, carrierpostnord.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, carrierpostnord.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.CustomerNumber != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberEQ(*i.CustomerNumber))
	}
	if i.CustomerNumberNEQ != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberNEQ(*i.CustomerNumberNEQ))
	}
	if len(i.CustomerNumberIn) > 0 {
		predicates = append(predicates, carrierpostnord.CustomerNumberIn(i.CustomerNumberIn...))
	}
	if len(i.CustomerNumberNotIn) > 0 {
		predicates = append(predicates, carrierpostnord.CustomerNumberNotIn(i.CustomerNumberNotIn...))
	}
	if i.CustomerNumberGT != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberGT(*i.CustomerNumberGT))
	}
	if i.CustomerNumberGTE != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberGTE(*i.CustomerNumberGTE))
	}
	if i.CustomerNumberLT != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberLT(*i.CustomerNumberLT))
	}
	if i.CustomerNumberLTE != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberLTE(*i.CustomerNumberLTE))
	}
	if i.CustomerNumberContains != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberContains(*i.CustomerNumberContains))
	}
	if i.CustomerNumberHasPrefix != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberHasPrefix(*i.CustomerNumberHasPrefix))
	}
	if i.CustomerNumberHasSuffix != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberHasSuffix(*i.CustomerNumberHasSuffix))
	}
	if i.CustomerNumberEqualFold != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberEqualFold(*i.CustomerNumberEqualFold))
	}
	if i.CustomerNumberContainsFold != nil {
		predicates = append(predicates, carrierpostnord.CustomerNumberContainsFold(*i.CustomerNumberContainsFold))
	}

	if i.HasTenant != nil {
		p := carrierpostnord.HasTenant()
		if !*i.HasTenant {
			p = carrierpostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierpostnord.HasTenantWith(with...))
	}
	if i.HasCarrier != nil {
		p := carrierpostnord.HasCarrier()
		if !*i.HasCarrier {
			p = carrierpostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierpostnord.HasCarrierWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierPostNordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierpostnord.And(predicates...), nil
	}
}

// CarrierServiceWhereInput represents a where input for filtering CarrierService queries.
type CarrierServiceWhereInput struct {
	Predicates []predicate.CarrierService  `json:"-"`
	Not        *CarrierServiceWhereInput   `json:"not,omitempty"`
	Or         []*CarrierServiceWhereInput `json:"or,omitempty"`
	And        []*CarrierServiceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "internal_id" field predicates.
	InternalID             *string  `json:"internalID,omitempty"`
	InternalIDNEQ          *string  `json:"internalIDNEQ,omitempty"`
	InternalIDIn           []string `json:"internalIDIn,omitempty"`
	InternalIDNotIn        []string `json:"internalIDNotIn,omitempty"`
	InternalIDGT           *string  `json:"internalIDGT,omitempty"`
	InternalIDGTE          *string  `json:"internalIDGTE,omitempty"`
	InternalIDLT           *string  `json:"internalIDLT,omitempty"`
	InternalIDLTE          *string  `json:"internalIDLTE,omitempty"`
	InternalIDContains     *string  `json:"internalIDContains,omitempty"`
	InternalIDHasPrefix    *string  `json:"internalIDHasPrefix,omitempty"`
	InternalIDHasSuffix    *string  `json:"internalIDHasSuffix,omitempty"`
	InternalIDEqualFold    *string  `json:"internalIDEqualFold,omitempty"`
	InternalIDContainsFold *string  `json:"internalIDContainsFold,omitempty"`

	// "return" field predicates.
	Return    *bool `json:"return,omitempty"`
	ReturnNEQ *bool `json:"returnNEQ,omitempty"`

	// "consolidation" field predicates.
	Consolidation    *bool `json:"consolidation,omitempty"`
	ConsolidationNEQ *bool `json:"consolidationNEQ,omitempty"`

	// "delivery_point_optional" field predicates.
	DeliveryPointOptional    *bool `json:"deliveryPointOptional,omitempty"`
	DeliveryPointOptionalNEQ *bool `json:"deliveryPointOptionalNEQ,omitempty"`

	// "delivery_point_required" field predicates.
	DeliveryPointRequired    *bool `json:"deliveryPointRequired,omitempty"`
	DeliveryPointRequiredNEQ *bool `json:"deliveryPointRequiredNEQ,omitempty"`

	// "carrier_service_post_nord" edge predicates.
	HasCarrierServicePostNord     *bool                               `json:"hasCarrierServicePostNord,omitempty"`
	HasCarrierServicePostNordWith []*CarrierServicePostNordWhereInput `json:"hasCarrierServicePostNordWith,omitempty"`

	// "carrier_service_dao" edge predicates.
	HasCarrierServiceDAO     *bool                          `json:"hasCarrierServiceDAO,omitempty"`
	HasCarrierServiceDAOWith []*CarrierServiceDAOWhereInput `json:"hasCarrierServiceDAOWith,omitempty"`

	// "carrier_service_df" edge predicates.
	HasCarrierServiceDF     *bool                         `json:"hasCarrierServiceDF,omitempty"`
	HasCarrierServiceDFWith []*CarrierServiceDFWhereInput `json:"hasCarrierServiceDFWith,omitempty"`

	// "carrier_service_dsv" edge predicates.
	HasCarrierServiceDSV     *bool                          `json:"hasCarrierServiceDSV,omitempty"`
	HasCarrierServiceDSVWith []*CarrierServiceDSVWhereInput `json:"hasCarrierServiceDSVWith,omitempty"`

	// "carrier_serv_easy_post" edge predicates.
	HasCarrierServEasyPost     *bool                               `json:"hasCarrierServEasyPost,omitempty"`
	HasCarrierServEasyPostWith []*CarrierServiceEasyPostWhereInput `json:"hasCarrierServEasyPostWith,omitempty"`

	// "carrier_service_gls" edge predicates.
	HasCarrierServiceGLS     *bool                          `json:"hasCarrierServiceGLS,omitempty"`
	HasCarrierServiceGLSWith []*CarrierServiceGLSWhereInput `json:"hasCarrierServiceGLSWith,omitempty"`

	// "carrier_service_usps" edge predicates.
	HasCarrierServiceUSPS     *bool                           `json:"hasCarrierServiceUSPS,omitempty"`
	HasCarrierServiceUSPSWith []*CarrierServiceUSPSWhereInput `json:"hasCarrierServiceUSPSWith,omitempty"`

	// "carrier_service_bring" edge predicates.
	HasCarrierServiceBring     *bool                            `json:"hasCarrierServiceBring,omitempty"`
	HasCarrierServiceBringWith []*CarrierServiceBringWhereInput `json:"hasCarrierServiceBringWith,omitempty"`

	// "carrier_brand" edge predicates.
	HasCarrierBrand     *bool                     `json:"hasCarrierBrand,omitempty"`
	HasCarrierBrandWith []*CarrierBrandWhereInput `json:"hasCarrierBrandWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierServiceWhereInput) AddPredicates(predicates ...predicate.CarrierService) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierServiceWhereInput filter on the CarrierServiceQuery builder.
func (i *CarrierServiceWhereInput) Filter(q *CarrierServiceQuery) (*CarrierServiceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierServiceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierServiceWhereInput is returned in case the CarrierServiceWhereInput is empty.
var ErrEmptyCarrierServiceWhereInput = errors.New("ent: empty predicate CarrierServiceWhereInput")

// P returns a predicate for filtering carrierservices.
// An error is returned if the input is empty or invalid.
func (i *CarrierServiceWhereInput) P() (predicate.CarrierService, error) {
	var predicates []predicate.CarrierService
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierservice.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierService, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierservice.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierService, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierservice.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierservice.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierservice.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierservice.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierservice.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierservice.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierservice.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierservice.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierservice.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrierservice.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrierservice.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrierservice.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrierservice.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrierservice.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrierservice.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrierservice.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrierservice.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrierservice.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrierservice.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrierservice.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrierservice.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrierservice.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.InternalID != nil {
		predicates = append(predicates, carrierservice.InternalIDEQ(*i.InternalID))
	}
	if i.InternalIDNEQ != nil {
		predicates = append(predicates, carrierservice.InternalIDNEQ(*i.InternalIDNEQ))
	}
	if len(i.InternalIDIn) > 0 {
		predicates = append(predicates, carrierservice.InternalIDIn(i.InternalIDIn...))
	}
	if len(i.InternalIDNotIn) > 0 {
		predicates = append(predicates, carrierservice.InternalIDNotIn(i.InternalIDNotIn...))
	}
	if i.InternalIDGT != nil {
		predicates = append(predicates, carrierservice.InternalIDGT(*i.InternalIDGT))
	}
	if i.InternalIDGTE != nil {
		predicates = append(predicates, carrierservice.InternalIDGTE(*i.InternalIDGTE))
	}
	if i.InternalIDLT != nil {
		predicates = append(predicates, carrierservice.InternalIDLT(*i.InternalIDLT))
	}
	if i.InternalIDLTE != nil {
		predicates = append(predicates, carrierservice.InternalIDLTE(*i.InternalIDLTE))
	}
	if i.InternalIDContains != nil {
		predicates = append(predicates, carrierservice.InternalIDContains(*i.InternalIDContains))
	}
	if i.InternalIDHasPrefix != nil {
		predicates = append(predicates, carrierservice.InternalIDHasPrefix(*i.InternalIDHasPrefix))
	}
	if i.InternalIDHasSuffix != nil {
		predicates = append(predicates, carrierservice.InternalIDHasSuffix(*i.InternalIDHasSuffix))
	}
	if i.InternalIDEqualFold != nil {
		predicates = append(predicates, carrierservice.InternalIDEqualFold(*i.InternalIDEqualFold))
	}
	if i.InternalIDContainsFold != nil {
		predicates = append(predicates, carrierservice.InternalIDContainsFold(*i.InternalIDContainsFold))
	}
	if i.Return != nil {
		predicates = append(predicates, carrierservice.ReturnEQ(*i.Return))
	}
	if i.ReturnNEQ != nil {
		predicates = append(predicates, carrierservice.ReturnNEQ(*i.ReturnNEQ))
	}
	if i.Consolidation != nil {
		predicates = append(predicates, carrierservice.ConsolidationEQ(*i.Consolidation))
	}
	if i.ConsolidationNEQ != nil {
		predicates = append(predicates, carrierservice.ConsolidationNEQ(*i.ConsolidationNEQ))
	}
	if i.DeliveryPointOptional != nil {
		predicates = append(predicates, carrierservice.DeliveryPointOptionalEQ(*i.DeliveryPointOptional))
	}
	if i.DeliveryPointOptionalNEQ != nil {
		predicates = append(predicates, carrierservice.DeliveryPointOptionalNEQ(*i.DeliveryPointOptionalNEQ))
	}
	if i.DeliveryPointRequired != nil {
		predicates = append(predicates, carrierservice.DeliveryPointRequiredEQ(*i.DeliveryPointRequired))
	}
	if i.DeliveryPointRequiredNEQ != nil {
		predicates = append(predicates, carrierservice.DeliveryPointRequiredNEQ(*i.DeliveryPointRequiredNEQ))
	}

	if i.HasCarrierServicePostNord != nil {
		p := carrierservice.HasCarrierServicePostNord()
		if !*i.HasCarrierServicePostNord {
			p = carrierservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServicePostNordWith) > 0 {
		with := make([]predicate.CarrierServicePostNord, 0, len(i.HasCarrierServicePostNordWith))
		for _, w := range i.HasCarrierServicePostNordWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServicePostNordWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservice.HasCarrierServicePostNordWith(with...))
	}
	if i.HasCarrierServiceDAO != nil {
		p := carrierservice.HasCarrierServiceDAO()
		if !*i.HasCarrierServiceDAO {
			p = carrierservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceDAOWith) > 0 {
		with := make([]predicate.CarrierServiceDAO, 0, len(i.HasCarrierServiceDAOWith))
		for _, w := range i.HasCarrierServiceDAOWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceDAOWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservice.HasCarrierServiceDAOWith(with...))
	}
	if i.HasCarrierServiceDF != nil {
		p := carrierservice.HasCarrierServiceDF()
		if !*i.HasCarrierServiceDF {
			p = carrierservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceDFWith) > 0 {
		with := make([]predicate.CarrierServiceDF, 0, len(i.HasCarrierServiceDFWith))
		for _, w := range i.HasCarrierServiceDFWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceDFWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservice.HasCarrierServiceDFWith(with...))
	}
	if i.HasCarrierServiceDSV != nil {
		p := carrierservice.HasCarrierServiceDSV()
		if !*i.HasCarrierServiceDSV {
			p = carrierservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceDSVWith) > 0 {
		with := make([]predicate.CarrierServiceDSV, 0, len(i.HasCarrierServiceDSVWith))
		for _, w := range i.HasCarrierServiceDSVWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceDSVWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservice.HasCarrierServiceDSVWith(with...))
	}
	if i.HasCarrierServEasyPost != nil {
		p := carrierservice.HasCarrierServEasyPost()
		if !*i.HasCarrierServEasyPost {
			p = carrierservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServEasyPostWith) > 0 {
		with := make([]predicate.CarrierServiceEasyPost, 0, len(i.HasCarrierServEasyPostWith))
		for _, w := range i.HasCarrierServEasyPostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServEasyPostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservice.HasCarrierServEasyPostWith(with...))
	}
	if i.HasCarrierServiceGLS != nil {
		p := carrierservice.HasCarrierServiceGLS()
		if !*i.HasCarrierServiceGLS {
			p = carrierservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceGLSWith) > 0 {
		with := make([]predicate.CarrierServiceGLS, 0, len(i.HasCarrierServiceGLSWith))
		for _, w := range i.HasCarrierServiceGLSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceGLSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservice.HasCarrierServiceGLSWith(with...))
	}
	if i.HasCarrierServiceUSPS != nil {
		p := carrierservice.HasCarrierServiceUSPS()
		if !*i.HasCarrierServiceUSPS {
			p = carrierservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceUSPSWith) > 0 {
		with := make([]predicate.CarrierServiceUSPS, 0, len(i.HasCarrierServiceUSPSWith))
		for _, w := range i.HasCarrierServiceUSPSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceUSPSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservice.HasCarrierServiceUSPSWith(with...))
	}
	if i.HasCarrierServiceBring != nil {
		p := carrierservice.HasCarrierServiceBring()
		if !*i.HasCarrierServiceBring {
			p = carrierservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceBringWith) > 0 {
		with := make([]predicate.CarrierServiceBring, 0, len(i.HasCarrierServiceBringWith))
		for _, w := range i.HasCarrierServiceBringWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceBringWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservice.HasCarrierServiceBringWith(with...))
	}
	if i.HasCarrierBrand != nil {
		p := carrierservice.HasCarrierBrand()
		if !*i.HasCarrierBrand {
			p = carrierservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierBrandWith) > 0 {
		with := make([]predicate.CarrierBrand, 0, len(i.HasCarrierBrandWith))
		for _, w := range i.HasCarrierBrandWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierBrandWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservice.HasCarrierBrandWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := carrierservice.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = carrierservice.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservice.HasDeliveryOptionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierServiceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierservice.And(predicates...), nil
	}
}

// CarrierServiceBringWhereInput represents a where input for filtering CarrierServiceBring queries.
type CarrierServiceBringWhereInput struct {
	Predicates []predicate.CarrierServiceBring  `json:"-"`
	Not        *CarrierServiceBringWhereInput   `json:"not,omitempty"`
	Or         []*CarrierServiceBringWhereInput `json:"or,omitempty"`
	And        []*CarrierServiceBringWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "api_service_code" field predicates.
	APIServiceCode             *string  `json:"apiServiceCode,omitempty"`
	APIServiceCodeNEQ          *string  `json:"apiServiceCodeNEQ,omitempty"`
	APIServiceCodeIn           []string `json:"apiServiceCodeIn,omitempty"`
	APIServiceCodeNotIn        []string `json:"apiServiceCodeNotIn,omitempty"`
	APIServiceCodeGT           *string  `json:"apiServiceCodeGT,omitempty"`
	APIServiceCodeGTE          *string  `json:"apiServiceCodeGTE,omitempty"`
	APIServiceCodeLT           *string  `json:"apiServiceCodeLT,omitempty"`
	APIServiceCodeLTE          *string  `json:"apiServiceCodeLTE,omitempty"`
	APIServiceCodeContains     *string  `json:"apiServiceCodeContains,omitempty"`
	APIServiceCodeHasPrefix    *string  `json:"apiServiceCodeHasPrefix,omitempty"`
	APIServiceCodeHasSuffix    *string  `json:"apiServiceCodeHasSuffix,omitempty"`
	APIServiceCodeEqualFold    *string  `json:"apiServiceCodeEqualFold,omitempty"`
	APIServiceCodeContainsFold *string  `json:"apiServiceCodeContainsFold,omitempty"`

	// "api_request" field predicates.
	APIRequest             *string  `json:"apiRequest,omitempty"`
	APIRequestNEQ          *string  `json:"apiRequestNEQ,omitempty"`
	APIRequestIn           []string `json:"apiRequestIn,omitempty"`
	APIRequestNotIn        []string `json:"apiRequestNotIn,omitempty"`
	APIRequestGT           *string  `json:"apiRequestGT,omitempty"`
	APIRequestGTE          *string  `json:"apiRequestGTE,omitempty"`
	APIRequestLT           *string  `json:"apiRequestLT,omitempty"`
	APIRequestLTE          *string  `json:"apiRequestLTE,omitempty"`
	APIRequestContains     *string  `json:"apiRequestContains,omitempty"`
	APIRequestHasPrefix    *string  `json:"apiRequestHasPrefix,omitempty"`
	APIRequestHasSuffix    *string  `json:"apiRequestHasSuffix,omitempty"`
	APIRequestEqualFold    *string  `json:"apiRequestEqualFold,omitempty"`
	APIRequestContainsFold *string  `json:"apiRequestContainsFold,omitempty"`

	// "carrier_service" edge predicates.
	HasCarrierService     *bool                       `json:"hasCarrierService,omitempty"`
	HasCarrierServiceWith []*CarrierServiceWhereInput `json:"hasCarrierServiceWith,omitempty"`

	// "carrier_additional_service_bring" edge predicates.
	HasCarrierAdditionalServiceBring     *bool                                      `json:"hasCarrierAdditionalServiceBring,omitempty"`
	HasCarrierAdditionalServiceBringWith []*CarrierAdditionalServiceBringWhereInput `json:"hasCarrierAdditionalServiceBringWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierServiceBringWhereInput) AddPredicates(predicates ...predicate.CarrierServiceBring) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierServiceBringWhereInput filter on the CarrierServiceBringQuery builder.
func (i *CarrierServiceBringWhereInput) Filter(q *CarrierServiceBringQuery) (*CarrierServiceBringQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierServiceBringWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierServiceBringWhereInput is returned in case the CarrierServiceBringWhereInput is empty.
var ErrEmptyCarrierServiceBringWhereInput = errors.New("ent: empty predicate CarrierServiceBringWhereInput")

// P returns a predicate for filtering carrierservicebrings.
// An error is returned if the input is empty or invalid.
func (i *CarrierServiceBringWhereInput) P() (predicate.CarrierServiceBring, error) {
	var predicates []predicate.CarrierServiceBring
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierservicebring.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierServiceBring, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierservicebring.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierServiceBring, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierservicebring.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierservicebring.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierservicebring.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierservicebring.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierservicebring.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierservicebring.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierservicebring.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierservicebring.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierservicebring.IDLTE(*i.IDLTE))
	}
	if i.APIServiceCode != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeEQ(*i.APIServiceCode))
	}
	if i.APIServiceCodeNEQ != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeNEQ(*i.APIServiceCodeNEQ))
	}
	if len(i.APIServiceCodeIn) > 0 {
		predicates = append(predicates, carrierservicebring.APIServiceCodeIn(i.APIServiceCodeIn...))
	}
	if len(i.APIServiceCodeNotIn) > 0 {
		predicates = append(predicates, carrierservicebring.APIServiceCodeNotIn(i.APIServiceCodeNotIn...))
	}
	if i.APIServiceCodeGT != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeGT(*i.APIServiceCodeGT))
	}
	if i.APIServiceCodeGTE != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeGTE(*i.APIServiceCodeGTE))
	}
	if i.APIServiceCodeLT != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeLT(*i.APIServiceCodeLT))
	}
	if i.APIServiceCodeLTE != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeLTE(*i.APIServiceCodeLTE))
	}
	if i.APIServiceCodeContains != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeContains(*i.APIServiceCodeContains))
	}
	if i.APIServiceCodeHasPrefix != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeHasPrefix(*i.APIServiceCodeHasPrefix))
	}
	if i.APIServiceCodeHasSuffix != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeHasSuffix(*i.APIServiceCodeHasSuffix))
	}
	if i.APIServiceCodeEqualFold != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeEqualFold(*i.APIServiceCodeEqualFold))
	}
	if i.APIServiceCodeContainsFold != nil {
		predicates = append(predicates, carrierservicebring.APIServiceCodeContainsFold(*i.APIServiceCodeContainsFold))
	}
	if i.APIRequest != nil {
		predicates = append(predicates, carrierservicebring.APIRequestEQ(*i.APIRequest))
	}
	if i.APIRequestNEQ != nil {
		predicates = append(predicates, carrierservicebring.APIRequestNEQ(*i.APIRequestNEQ))
	}
	if len(i.APIRequestIn) > 0 {
		predicates = append(predicates, carrierservicebring.APIRequestIn(i.APIRequestIn...))
	}
	if len(i.APIRequestNotIn) > 0 {
		predicates = append(predicates, carrierservicebring.APIRequestNotIn(i.APIRequestNotIn...))
	}
	if i.APIRequestGT != nil {
		predicates = append(predicates, carrierservicebring.APIRequestGT(*i.APIRequestGT))
	}
	if i.APIRequestGTE != nil {
		predicates = append(predicates, carrierservicebring.APIRequestGTE(*i.APIRequestGTE))
	}
	if i.APIRequestLT != nil {
		predicates = append(predicates, carrierservicebring.APIRequestLT(*i.APIRequestLT))
	}
	if i.APIRequestLTE != nil {
		predicates = append(predicates, carrierservicebring.APIRequestLTE(*i.APIRequestLTE))
	}
	if i.APIRequestContains != nil {
		predicates = append(predicates, carrierservicebring.APIRequestContains(*i.APIRequestContains))
	}
	if i.APIRequestHasPrefix != nil {
		predicates = append(predicates, carrierservicebring.APIRequestHasPrefix(*i.APIRequestHasPrefix))
	}
	if i.APIRequestHasSuffix != nil {
		predicates = append(predicates, carrierservicebring.APIRequestHasSuffix(*i.APIRequestHasSuffix))
	}
	if i.APIRequestEqualFold != nil {
		predicates = append(predicates, carrierservicebring.APIRequestEqualFold(*i.APIRequestEqualFold))
	}
	if i.APIRequestContainsFold != nil {
		predicates = append(predicates, carrierservicebring.APIRequestContainsFold(*i.APIRequestContainsFold))
	}

	if i.HasCarrierService != nil {
		p := carrierservicebring.HasCarrierService()
		if !*i.HasCarrierService {
			p = carrierservicebring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceWith) > 0 {
		with := make([]predicate.CarrierService, 0, len(i.HasCarrierServiceWith))
		for _, w := range i.HasCarrierServiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicebring.HasCarrierServiceWith(with...))
	}
	if i.HasCarrierAdditionalServiceBring != nil {
		p := carrierservicebring.HasCarrierAdditionalServiceBring()
		if !*i.HasCarrierAdditionalServiceBring {
			p = carrierservicebring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceBringWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceBring, 0, len(i.HasCarrierAdditionalServiceBringWith))
		for _, w := range i.HasCarrierAdditionalServiceBringWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceBringWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicebring.HasCarrierAdditionalServiceBringWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierServiceBringWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierservicebring.And(predicates...), nil
	}
}

// CarrierServiceDAOWhereInput represents a where input for filtering CarrierServiceDAO queries.
type CarrierServiceDAOWhereInput struct {
	Predicates []predicate.CarrierServiceDAO  `json:"-"`
	Not        *CarrierServiceDAOWhereInput   `json:"not,omitempty"`
	Or         []*CarrierServiceDAOWhereInput `json:"or,omitempty"`
	And        []*CarrierServiceDAOWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "carrier_service" edge predicates.
	HasCarrierService     *bool                       `json:"hasCarrierService,omitempty"`
	HasCarrierServiceWith []*CarrierServiceWhereInput `json:"hasCarrierServiceWith,omitempty"`

	// "carrier_additional_service_dao" edge predicates.
	HasCarrierAdditionalServiceDAO     *bool                                    `json:"hasCarrierAdditionalServiceDAO,omitempty"`
	HasCarrierAdditionalServiceDAOWith []*CarrierAdditionalServiceDAOWhereInput `json:"hasCarrierAdditionalServiceDAOWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierServiceDAOWhereInput) AddPredicates(predicates ...predicate.CarrierServiceDAO) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierServiceDAOWhereInput filter on the CarrierServiceDAOQuery builder.
func (i *CarrierServiceDAOWhereInput) Filter(q *CarrierServiceDAOQuery) (*CarrierServiceDAOQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierServiceDAOWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierServiceDAOWhereInput is returned in case the CarrierServiceDAOWhereInput is empty.
var ErrEmptyCarrierServiceDAOWhereInput = errors.New("ent: empty predicate CarrierServiceDAOWhereInput")

// P returns a predicate for filtering carrierservicedaos.
// An error is returned if the input is empty or invalid.
func (i *CarrierServiceDAOWhereInput) P() (predicate.CarrierServiceDAO, error) {
	var predicates []predicate.CarrierServiceDAO
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierservicedao.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierServiceDAO, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierservicedao.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierServiceDAO, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierservicedao.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierservicedao.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierservicedao.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierservicedao.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierservicedao.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierservicedao.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierservicedao.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierservicedao.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierservicedao.IDLTE(*i.IDLTE))
	}

	if i.HasCarrierService != nil {
		p := carrierservicedao.HasCarrierService()
		if !*i.HasCarrierService {
			p = carrierservicedao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceWith) > 0 {
		with := make([]predicate.CarrierService, 0, len(i.HasCarrierServiceWith))
		for _, w := range i.HasCarrierServiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicedao.HasCarrierServiceWith(with...))
	}
	if i.HasCarrierAdditionalServiceDAO != nil {
		p := carrierservicedao.HasCarrierAdditionalServiceDAO()
		if !*i.HasCarrierAdditionalServiceDAO {
			p = carrierservicedao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceDAOWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceDAO, 0, len(i.HasCarrierAdditionalServiceDAOWith))
		for _, w := range i.HasCarrierAdditionalServiceDAOWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceDAOWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicedao.HasCarrierAdditionalServiceDAOWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierServiceDAOWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierservicedao.And(predicates...), nil
	}
}

// CarrierServiceDFWhereInput represents a where input for filtering CarrierServiceDF queries.
type CarrierServiceDFWhereInput struct {
	Predicates []predicate.CarrierServiceDF  `json:"-"`
	Not        *CarrierServiceDFWhereInput   `json:"not,omitempty"`
	Or         []*CarrierServiceDFWhereInput `json:"or,omitempty"`
	And        []*CarrierServiceDFWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "carrier_service" edge predicates.
	HasCarrierService     *bool                       `json:"hasCarrierService,omitempty"`
	HasCarrierServiceWith []*CarrierServiceWhereInput `json:"hasCarrierServiceWith,omitempty"`

	// "carrier_additional_service_df" edge predicates.
	HasCarrierAdditionalServiceDF     *bool                                   `json:"hasCarrierAdditionalServiceDF,omitempty"`
	HasCarrierAdditionalServiceDFWith []*CarrierAdditionalServiceDFWhereInput `json:"hasCarrierAdditionalServiceDFWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierServiceDFWhereInput) AddPredicates(predicates ...predicate.CarrierServiceDF) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierServiceDFWhereInput filter on the CarrierServiceDFQuery builder.
func (i *CarrierServiceDFWhereInput) Filter(q *CarrierServiceDFQuery) (*CarrierServiceDFQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierServiceDFWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierServiceDFWhereInput is returned in case the CarrierServiceDFWhereInput is empty.
var ErrEmptyCarrierServiceDFWhereInput = errors.New("ent: empty predicate CarrierServiceDFWhereInput")

// P returns a predicate for filtering carrierservicedfs.
// An error is returned if the input is empty or invalid.
func (i *CarrierServiceDFWhereInput) P() (predicate.CarrierServiceDF, error) {
	var predicates []predicate.CarrierServiceDF
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierservicedf.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierServiceDF, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierservicedf.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierServiceDF, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierservicedf.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierservicedf.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierservicedf.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierservicedf.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierservicedf.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierservicedf.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierservicedf.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierservicedf.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierservicedf.IDLTE(*i.IDLTE))
	}

	if i.HasCarrierService != nil {
		p := carrierservicedf.HasCarrierService()
		if !*i.HasCarrierService {
			p = carrierservicedf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceWith) > 0 {
		with := make([]predicate.CarrierService, 0, len(i.HasCarrierServiceWith))
		for _, w := range i.HasCarrierServiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicedf.HasCarrierServiceWith(with...))
	}
	if i.HasCarrierAdditionalServiceDF != nil {
		p := carrierservicedf.HasCarrierAdditionalServiceDF()
		if !*i.HasCarrierAdditionalServiceDF {
			p = carrierservicedf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceDFWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceDF, 0, len(i.HasCarrierAdditionalServiceDFWith))
		for _, w := range i.HasCarrierAdditionalServiceDFWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceDFWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicedf.HasCarrierAdditionalServiceDFWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierServiceDFWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierservicedf.And(predicates...), nil
	}
}

// CarrierServiceDSVWhereInput represents a where input for filtering CarrierServiceDSV queries.
type CarrierServiceDSVWhereInput struct {
	Predicates []predicate.CarrierServiceDSV  `json:"-"`
	Not        *CarrierServiceDSVWhereInput   `json:"not,omitempty"`
	Or         []*CarrierServiceDSVWhereInput `json:"or,omitempty"`
	And        []*CarrierServiceDSVWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "carrier_service" edge predicates.
	HasCarrierService     *bool                       `json:"hasCarrierService,omitempty"`
	HasCarrierServiceWith []*CarrierServiceWhereInput `json:"hasCarrierServiceWith,omitempty"`

	// "carrier_additional_service_dsv" edge predicates.
	HasCarrierAdditionalServiceDSV     *bool                                    `json:"hasCarrierAdditionalServiceDSV,omitempty"`
	HasCarrierAdditionalServiceDSVWith []*CarrierAdditionalServiceDSVWhereInput `json:"hasCarrierAdditionalServiceDSVWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierServiceDSVWhereInput) AddPredicates(predicates ...predicate.CarrierServiceDSV) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierServiceDSVWhereInput filter on the CarrierServiceDSVQuery builder.
func (i *CarrierServiceDSVWhereInput) Filter(q *CarrierServiceDSVQuery) (*CarrierServiceDSVQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierServiceDSVWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierServiceDSVWhereInput is returned in case the CarrierServiceDSVWhereInput is empty.
var ErrEmptyCarrierServiceDSVWhereInput = errors.New("ent: empty predicate CarrierServiceDSVWhereInput")

// P returns a predicate for filtering carrierservicedsvs.
// An error is returned if the input is empty or invalid.
func (i *CarrierServiceDSVWhereInput) P() (predicate.CarrierServiceDSV, error) {
	var predicates []predicate.CarrierServiceDSV
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierservicedsv.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierServiceDSV, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierservicedsv.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierServiceDSV, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierservicedsv.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierservicedsv.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierservicedsv.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierservicedsv.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierservicedsv.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierservicedsv.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierservicedsv.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierservicedsv.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierservicedsv.IDLTE(*i.IDLTE))
	}

	if i.HasCarrierService != nil {
		p := carrierservicedsv.HasCarrierService()
		if !*i.HasCarrierService {
			p = carrierservicedsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceWith) > 0 {
		with := make([]predicate.CarrierService, 0, len(i.HasCarrierServiceWith))
		for _, w := range i.HasCarrierServiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicedsv.HasCarrierServiceWith(with...))
	}
	if i.HasCarrierAdditionalServiceDSV != nil {
		p := carrierservicedsv.HasCarrierAdditionalServiceDSV()
		if !*i.HasCarrierAdditionalServiceDSV {
			p = carrierservicedsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceDSVWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceDSV, 0, len(i.HasCarrierAdditionalServiceDSVWith))
		for _, w := range i.HasCarrierAdditionalServiceDSVWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceDSVWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicedsv.HasCarrierAdditionalServiceDSVWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierServiceDSVWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierservicedsv.And(predicates...), nil
	}
}

// CarrierServiceEasyPostWhereInput represents a where input for filtering CarrierServiceEasyPost queries.
type CarrierServiceEasyPostWhereInput struct {
	Predicates []predicate.CarrierServiceEasyPost  `json:"-"`
	Not        *CarrierServiceEasyPostWhereInput   `json:"not,omitempty"`
	Or         []*CarrierServiceEasyPostWhereInput `json:"or,omitempty"`
	And        []*CarrierServiceEasyPostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "carrier_service" edge predicates.
	HasCarrierService     *bool                       `json:"hasCarrierService,omitempty"`
	HasCarrierServiceWith []*CarrierServiceWhereInput `json:"hasCarrierServiceWith,omitempty"`

	// "carrier_add_serv_easy_post" edge predicates.
	HasCarrierAddServEasyPost     *bool                                         `json:"hasCarrierAddServEasyPost,omitempty"`
	HasCarrierAddServEasyPostWith []*CarrierAdditionalServiceEasyPostWhereInput `json:"hasCarrierAddServEasyPostWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierServiceEasyPostWhereInput) AddPredicates(predicates ...predicate.CarrierServiceEasyPost) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierServiceEasyPostWhereInput filter on the CarrierServiceEasyPostQuery builder.
func (i *CarrierServiceEasyPostWhereInput) Filter(q *CarrierServiceEasyPostQuery) (*CarrierServiceEasyPostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierServiceEasyPostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierServiceEasyPostWhereInput is returned in case the CarrierServiceEasyPostWhereInput is empty.
var ErrEmptyCarrierServiceEasyPostWhereInput = errors.New("ent: empty predicate CarrierServiceEasyPostWhereInput")

// P returns a predicate for filtering carrierserviceeasyposts.
// An error is returned if the input is empty or invalid.
func (i *CarrierServiceEasyPostWhereInput) P() (predicate.CarrierServiceEasyPost, error) {
	var predicates []predicate.CarrierServiceEasyPost
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierserviceeasypost.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierServiceEasyPost, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierserviceeasypost.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierServiceEasyPost, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierserviceeasypost.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierserviceeasypost.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierserviceeasypost.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierserviceeasypost.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierserviceeasypost.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierserviceeasypost.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierserviceeasypost.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierserviceeasypost.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierserviceeasypost.IDLTE(*i.IDLTE))
	}

	if i.HasCarrierService != nil {
		p := carrierserviceeasypost.HasCarrierService()
		if !*i.HasCarrierService {
			p = carrierserviceeasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceWith) > 0 {
		with := make([]predicate.CarrierService, 0, len(i.HasCarrierServiceWith))
		for _, w := range i.HasCarrierServiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierserviceeasypost.HasCarrierServiceWith(with...))
	}
	if i.HasCarrierAddServEasyPost != nil {
		p := carrierserviceeasypost.HasCarrierAddServEasyPost()
		if !*i.HasCarrierAddServEasyPost {
			p = carrierserviceeasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAddServEasyPostWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceEasyPost, 0, len(i.HasCarrierAddServEasyPostWith))
		for _, w := range i.HasCarrierAddServEasyPostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAddServEasyPostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierserviceeasypost.HasCarrierAddServEasyPostWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierServiceEasyPostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierserviceeasypost.And(predicates...), nil
	}
}

// CarrierServiceGLSWhereInput represents a where input for filtering CarrierServiceGLS queries.
type CarrierServiceGLSWhereInput struct {
	Predicates []predicate.CarrierServiceGLS  `json:"-"`
	Not        *CarrierServiceGLSWhereInput   `json:"not,omitempty"`
	Or         []*CarrierServiceGLSWhereInput `json:"or,omitempty"`
	And        []*CarrierServiceGLSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "api_key" field predicates.
	APIKey             *string  `json:"apiKey,omitempty"`
	APIKeyNEQ          *string  `json:"apiKeyNEQ,omitempty"`
	APIKeyIn           []string `json:"apiKeyIn,omitempty"`
	APIKeyNotIn        []string `json:"apiKeyNotIn,omitempty"`
	APIKeyGT           *string  `json:"apiKeyGT,omitempty"`
	APIKeyGTE          *string  `json:"apiKeyGTE,omitempty"`
	APIKeyLT           *string  `json:"apiKeyLT,omitempty"`
	APIKeyLTE          *string  `json:"apiKeyLTE,omitempty"`
	APIKeyContains     *string  `json:"apiKeyContains,omitempty"`
	APIKeyHasPrefix    *string  `json:"apiKeyHasPrefix,omitempty"`
	APIKeyHasSuffix    *string  `json:"apiKeyHasSuffix,omitempty"`
	APIKeyIsNil        bool     `json:"apiKeyIsNil,omitempty"`
	APIKeyNotNil       bool     `json:"apiKeyNotNil,omitempty"`
	APIKeyEqualFold    *string  `json:"apiKeyEqualFold,omitempty"`
	APIKeyContainsFold *string  `json:"apiKeyContainsFold,omitempty"`

	// "api_value" field predicates.
	APIValue      *carrierservicegls.APIValue  `json:"apiValue,omitempty"`
	APIValueNEQ   *carrierservicegls.APIValue  `json:"apiValueNEQ,omitempty"`
	APIValueIn    []carrierservicegls.APIValue `json:"apiValueIn,omitempty"`
	APIValueNotIn []carrierservicegls.APIValue `json:"apiValueNotIn,omitempty"`

	// "carrier_service" edge predicates.
	HasCarrierService     *bool                       `json:"hasCarrierService,omitempty"`
	HasCarrierServiceWith []*CarrierServiceWhereInput `json:"hasCarrierServiceWith,omitempty"`

	// "carrier_additional_service_gls" edge predicates.
	HasCarrierAdditionalServiceGLS     *bool                                    `json:"hasCarrierAdditionalServiceGLS,omitempty"`
	HasCarrierAdditionalServiceGLSWith []*CarrierAdditionalServiceGLSWhereInput `json:"hasCarrierAdditionalServiceGLSWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierServiceGLSWhereInput) AddPredicates(predicates ...predicate.CarrierServiceGLS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierServiceGLSWhereInput filter on the CarrierServiceGLSQuery builder.
func (i *CarrierServiceGLSWhereInput) Filter(q *CarrierServiceGLSQuery) (*CarrierServiceGLSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierServiceGLSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierServiceGLSWhereInput is returned in case the CarrierServiceGLSWhereInput is empty.
var ErrEmptyCarrierServiceGLSWhereInput = errors.New("ent: empty predicate CarrierServiceGLSWhereInput")

// P returns a predicate for filtering carrierserviceglss.
// An error is returned if the input is empty or invalid.
func (i *CarrierServiceGLSWhereInput) P() (predicate.CarrierServiceGLS, error) {
	var predicates []predicate.CarrierServiceGLS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierservicegls.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierServiceGLS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierservicegls.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierServiceGLS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierservicegls.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierservicegls.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierservicegls.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierservicegls.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierservicegls.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierservicegls.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierservicegls.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierservicegls.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierservicegls.IDLTE(*i.IDLTE))
	}
	if i.APIKey != nil {
		predicates = append(predicates, carrierservicegls.APIKeyEQ(*i.APIKey))
	}
	if i.APIKeyNEQ != nil {
		predicates = append(predicates, carrierservicegls.APIKeyNEQ(*i.APIKeyNEQ))
	}
	if len(i.APIKeyIn) > 0 {
		predicates = append(predicates, carrierservicegls.APIKeyIn(i.APIKeyIn...))
	}
	if len(i.APIKeyNotIn) > 0 {
		predicates = append(predicates, carrierservicegls.APIKeyNotIn(i.APIKeyNotIn...))
	}
	if i.APIKeyGT != nil {
		predicates = append(predicates, carrierservicegls.APIKeyGT(*i.APIKeyGT))
	}
	if i.APIKeyGTE != nil {
		predicates = append(predicates, carrierservicegls.APIKeyGTE(*i.APIKeyGTE))
	}
	if i.APIKeyLT != nil {
		predicates = append(predicates, carrierservicegls.APIKeyLT(*i.APIKeyLT))
	}
	if i.APIKeyLTE != nil {
		predicates = append(predicates, carrierservicegls.APIKeyLTE(*i.APIKeyLTE))
	}
	if i.APIKeyContains != nil {
		predicates = append(predicates, carrierservicegls.APIKeyContains(*i.APIKeyContains))
	}
	if i.APIKeyHasPrefix != nil {
		predicates = append(predicates, carrierservicegls.APIKeyHasPrefix(*i.APIKeyHasPrefix))
	}
	if i.APIKeyHasSuffix != nil {
		predicates = append(predicates, carrierservicegls.APIKeyHasSuffix(*i.APIKeyHasSuffix))
	}
	if i.APIKeyIsNil {
		predicates = append(predicates, carrierservicegls.APIKeyIsNil())
	}
	if i.APIKeyNotNil {
		predicates = append(predicates, carrierservicegls.APIKeyNotNil())
	}
	if i.APIKeyEqualFold != nil {
		predicates = append(predicates, carrierservicegls.APIKeyEqualFold(*i.APIKeyEqualFold))
	}
	if i.APIKeyContainsFold != nil {
		predicates = append(predicates, carrierservicegls.APIKeyContainsFold(*i.APIKeyContainsFold))
	}
	if i.APIValue != nil {
		predicates = append(predicates, carrierservicegls.APIValueEQ(*i.APIValue))
	}
	if i.APIValueNEQ != nil {
		predicates = append(predicates, carrierservicegls.APIValueNEQ(*i.APIValueNEQ))
	}
	if len(i.APIValueIn) > 0 {
		predicates = append(predicates, carrierservicegls.APIValueIn(i.APIValueIn...))
	}
	if len(i.APIValueNotIn) > 0 {
		predicates = append(predicates, carrierservicegls.APIValueNotIn(i.APIValueNotIn...))
	}

	if i.HasCarrierService != nil {
		p := carrierservicegls.HasCarrierService()
		if !*i.HasCarrierService {
			p = carrierservicegls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceWith) > 0 {
		with := make([]predicate.CarrierService, 0, len(i.HasCarrierServiceWith))
		for _, w := range i.HasCarrierServiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicegls.HasCarrierServiceWith(with...))
	}
	if i.HasCarrierAdditionalServiceGLS != nil {
		p := carrierservicegls.HasCarrierAdditionalServiceGLS()
		if !*i.HasCarrierAdditionalServiceGLS {
			p = carrierservicegls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceGLSWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceGLS, 0, len(i.HasCarrierAdditionalServiceGLSWith))
		for _, w := range i.HasCarrierAdditionalServiceGLSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceGLSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicegls.HasCarrierAdditionalServiceGLSWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierServiceGLSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierservicegls.And(predicates...), nil
	}
}

// CarrierServicePostNordWhereInput represents a where input for filtering CarrierServicePostNord queries.
type CarrierServicePostNordWhereInput struct {
	Predicates []predicate.CarrierServicePostNord  `json:"-"`
	Not        *CarrierServicePostNordWhereInput   `json:"not,omitempty"`
	Or         []*CarrierServicePostNordWhereInput `json:"or,omitempty"`
	And        []*CarrierServicePostNordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "internal_id" field predicates.
	InternalID             *string  `json:"internalID,omitempty"`
	InternalIDNEQ          *string  `json:"internalIDNEQ,omitempty"`
	InternalIDIn           []string `json:"internalIDIn,omitempty"`
	InternalIDNotIn        []string `json:"internalIDNotIn,omitempty"`
	InternalIDGT           *string  `json:"internalIDGT,omitempty"`
	InternalIDGTE          *string  `json:"internalIDGTE,omitempty"`
	InternalIDLT           *string  `json:"internalIDLT,omitempty"`
	InternalIDLTE          *string  `json:"internalIDLTE,omitempty"`
	InternalIDContains     *string  `json:"internalIDContains,omitempty"`
	InternalIDHasPrefix    *string  `json:"internalIDHasPrefix,omitempty"`
	InternalIDHasSuffix    *string  `json:"internalIDHasSuffix,omitempty"`
	InternalIDEqualFold    *string  `json:"internalIDEqualFold,omitempty"`
	InternalIDContainsFold *string  `json:"internalIDContainsFold,omitempty"`

	// "api_code" field predicates.
	APICode             *string  `json:"apiCode,omitempty"`
	APICodeNEQ          *string  `json:"apiCodeNEQ,omitempty"`
	APICodeIn           []string `json:"apiCodeIn,omitempty"`
	APICodeNotIn        []string `json:"apiCodeNotIn,omitempty"`
	APICodeGT           *string  `json:"apiCodeGT,omitempty"`
	APICodeGTE          *string  `json:"apiCodeGTE,omitempty"`
	APICodeLT           *string  `json:"apiCodeLT,omitempty"`
	APICodeLTE          *string  `json:"apiCodeLTE,omitempty"`
	APICodeContains     *string  `json:"apiCodeContains,omitempty"`
	APICodeHasPrefix    *string  `json:"apiCodeHasPrefix,omitempty"`
	APICodeHasSuffix    *string  `json:"apiCodeHasSuffix,omitempty"`
	APICodeEqualFold    *string  `json:"apiCodeEqualFold,omitempty"`
	APICodeContainsFold *string  `json:"apiCodeContainsFold,omitempty"`

	// "carrier_service" edge predicates.
	HasCarrierService     *bool                       `json:"hasCarrierService,omitempty"`
	HasCarrierServiceWith []*CarrierServiceWhereInput `json:"hasCarrierServiceWith,omitempty"`

	// "carrier_add_serv_post_nord" edge predicates.
	HasCarrierAddServPostNord     *bool                                         `json:"hasCarrierAddServPostNord,omitempty"`
	HasCarrierAddServPostNordWith []*CarrierAdditionalServicePostNordWhereInput `json:"hasCarrierAddServPostNordWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierServicePostNordWhereInput) AddPredicates(predicates ...predicate.CarrierServicePostNord) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierServicePostNordWhereInput filter on the CarrierServicePostNordQuery builder.
func (i *CarrierServicePostNordWhereInput) Filter(q *CarrierServicePostNordQuery) (*CarrierServicePostNordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierServicePostNordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierServicePostNordWhereInput is returned in case the CarrierServicePostNordWhereInput is empty.
var ErrEmptyCarrierServicePostNordWhereInput = errors.New("ent: empty predicate CarrierServicePostNordWhereInput")

// P returns a predicate for filtering carrierservicepostnords.
// An error is returned if the input is empty or invalid.
func (i *CarrierServicePostNordWhereInput) P() (predicate.CarrierServicePostNord, error) {
	var predicates []predicate.CarrierServicePostNord
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierservicepostnord.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierServicePostNord, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierservicepostnord.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierServicePostNord, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierservicepostnord.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierservicepostnord.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierservicepostnord.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierservicepostnord.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierservicepostnord.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierservicepostnord.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierservicepostnord.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierservicepostnord.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierservicepostnord.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, carrierservicepostnord.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, carrierservicepostnord.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, carrierservicepostnord.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, carrierservicepostnord.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, carrierservicepostnord.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, carrierservicepostnord.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, carrierservicepostnord.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, carrierservicepostnord.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, carrierservicepostnord.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, carrierservicepostnord.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, carrierservicepostnord.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, carrierservicepostnord.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, carrierservicepostnord.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.InternalID != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDEQ(*i.InternalID))
	}
	if i.InternalIDNEQ != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDNEQ(*i.InternalIDNEQ))
	}
	if len(i.InternalIDIn) > 0 {
		predicates = append(predicates, carrierservicepostnord.InternalIDIn(i.InternalIDIn...))
	}
	if len(i.InternalIDNotIn) > 0 {
		predicates = append(predicates, carrierservicepostnord.InternalIDNotIn(i.InternalIDNotIn...))
	}
	if i.InternalIDGT != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDGT(*i.InternalIDGT))
	}
	if i.InternalIDGTE != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDGTE(*i.InternalIDGTE))
	}
	if i.InternalIDLT != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDLT(*i.InternalIDLT))
	}
	if i.InternalIDLTE != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDLTE(*i.InternalIDLTE))
	}
	if i.InternalIDContains != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDContains(*i.InternalIDContains))
	}
	if i.InternalIDHasPrefix != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDHasPrefix(*i.InternalIDHasPrefix))
	}
	if i.InternalIDHasSuffix != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDHasSuffix(*i.InternalIDHasSuffix))
	}
	if i.InternalIDEqualFold != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDEqualFold(*i.InternalIDEqualFold))
	}
	if i.InternalIDContainsFold != nil {
		predicates = append(predicates, carrierservicepostnord.InternalIDContainsFold(*i.InternalIDContainsFold))
	}
	if i.APICode != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeEQ(*i.APICode))
	}
	if i.APICodeNEQ != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeNEQ(*i.APICodeNEQ))
	}
	if len(i.APICodeIn) > 0 {
		predicates = append(predicates, carrierservicepostnord.APICodeIn(i.APICodeIn...))
	}
	if len(i.APICodeNotIn) > 0 {
		predicates = append(predicates, carrierservicepostnord.APICodeNotIn(i.APICodeNotIn...))
	}
	if i.APICodeGT != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeGT(*i.APICodeGT))
	}
	if i.APICodeGTE != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeGTE(*i.APICodeGTE))
	}
	if i.APICodeLT != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeLT(*i.APICodeLT))
	}
	if i.APICodeLTE != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeLTE(*i.APICodeLTE))
	}
	if i.APICodeContains != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeContains(*i.APICodeContains))
	}
	if i.APICodeHasPrefix != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeHasPrefix(*i.APICodeHasPrefix))
	}
	if i.APICodeHasSuffix != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeHasSuffix(*i.APICodeHasSuffix))
	}
	if i.APICodeEqualFold != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeEqualFold(*i.APICodeEqualFold))
	}
	if i.APICodeContainsFold != nil {
		predicates = append(predicates, carrierservicepostnord.APICodeContainsFold(*i.APICodeContainsFold))
	}

	if i.HasCarrierService != nil {
		p := carrierservicepostnord.HasCarrierService()
		if !*i.HasCarrierService {
			p = carrierservicepostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceWith) > 0 {
		with := make([]predicate.CarrierService, 0, len(i.HasCarrierServiceWith))
		for _, w := range i.HasCarrierServiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicepostnord.HasCarrierServiceWith(with...))
	}
	if i.HasCarrierAddServPostNord != nil {
		p := carrierservicepostnord.HasCarrierAddServPostNord()
		if !*i.HasCarrierAddServPostNord {
			p = carrierservicepostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAddServPostNordWith) > 0 {
		with := make([]predicate.CarrierAdditionalServicePostNord, 0, len(i.HasCarrierAddServPostNordWith))
		for _, w := range i.HasCarrierAddServPostNordWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAddServPostNordWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierservicepostnord.HasCarrierAddServPostNordWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierServicePostNordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierservicepostnord.And(predicates...), nil
	}
}

// CarrierServiceUSPSWhereInput represents a where input for filtering CarrierServiceUSPS queries.
type CarrierServiceUSPSWhereInput struct {
	Predicates []predicate.CarrierServiceUSPS  `json:"-"`
	Not        *CarrierServiceUSPSWhereInput   `json:"not,omitempty"`
	Or         []*CarrierServiceUSPSWhereInput `json:"or,omitempty"`
	And        []*CarrierServiceUSPSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "carrier_service" edge predicates.
	HasCarrierService     *bool                       `json:"hasCarrierService,omitempty"`
	HasCarrierServiceWith []*CarrierServiceWhereInput `json:"hasCarrierServiceWith,omitempty"`

	// "carrier_additional_service_usps" edge predicates.
	HasCarrierAdditionalServiceUSPS     *bool                                     `json:"hasCarrierAdditionalServiceUSPS,omitempty"`
	HasCarrierAdditionalServiceUSPSWith []*CarrierAdditionalServiceUSPSWhereInput `json:"hasCarrierAdditionalServiceUSPSWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierServiceUSPSWhereInput) AddPredicates(predicates ...predicate.CarrierServiceUSPS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierServiceUSPSWhereInput filter on the CarrierServiceUSPSQuery builder.
func (i *CarrierServiceUSPSWhereInput) Filter(q *CarrierServiceUSPSQuery) (*CarrierServiceUSPSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierServiceUSPSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierServiceUSPSWhereInput is returned in case the CarrierServiceUSPSWhereInput is empty.
var ErrEmptyCarrierServiceUSPSWhereInput = errors.New("ent: empty predicate CarrierServiceUSPSWhereInput")

// P returns a predicate for filtering carrierserviceuspss.
// An error is returned if the input is empty or invalid.
func (i *CarrierServiceUSPSWhereInput) P() (predicate.CarrierServiceUSPS, error) {
	var predicates []predicate.CarrierServiceUSPS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierserviceusps.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierServiceUSPS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierserviceusps.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierServiceUSPS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierserviceusps.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierserviceusps.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierserviceusps.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierserviceusps.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierserviceusps.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierserviceusps.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierserviceusps.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierserviceusps.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierserviceusps.IDLTE(*i.IDLTE))
	}

	if i.HasCarrierService != nil {
		p := carrierserviceusps.HasCarrierService()
		if !*i.HasCarrierService {
			p = carrierserviceusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceWith) > 0 {
		with := make([]predicate.CarrierService, 0, len(i.HasCarrierServiceWith))
		for _, w := range i.HasCarrierServiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierserviceusps.HasCarrierServiceWith(with...))
	}
	if i.HasCarrierAdditionalServiceUSPS != nil {
		p := carrierserviceusps.HasCarrierAdditionalServiceUSPS()
		if !*i.HasCarrierAdditionalServiceUSPS {
			p = carrierserviceusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceUSPSWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceUSPS, 0, len(i.HasCarrierAdditionalServiceUSPSWith))
		for _, w := range i.HasCarrierAdditionalServiceUSPSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceUSPSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierserviceusps.HasCarrierAdditionalServiceUSPSWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierServiceUSPSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierserviceusps.And(predicates...), nil
	}
}

// CarrierUSPSWhereInput represents a where input for filtering CarrierUSPS queries.
type CarrierUSPSWhereInput struct {
	Predicates []predicate.CarrierUSPS  `json:"-"`
	Not        *CarrierUSPSWhereInput   `json:"not,omitempty"`
	Or         []*CarrierUSPSWhereInput `json:"or,omitempty"`
	And        []*CarrierUSPSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "is_test_api" field predicates.
	IsTestAPI    *bool `json:"isTestAPI,omitempty"`
	IsTestAPINEQ *bool `json:"isTestAPINEQ,omitempty"`

	// "consumer_key" field predicates.
	ConsumerKey             *string  `json:"consumerKey,omitempty"`
	ConsumerKeyNEQ          *string  `json:"consumerKeyNEQ,omitempty"`
	ConsumerKeyIn           []string `json:"consumerKeyIn,omitempty"`
	ConsumerKeyNotIn        []string `json:"consumerKeyNotIn,omitempty"`
	ConsumerKeyGT           *string  `json:"consumerKeyGT,omitempty"`
	ConsumerKeyGTE          *string  `json:"consumerKeyGTE,omitempty"`
	ConsumerKeyLT           *string  `json:"consumerKeyLT,omitempty"`
	ConsumerKeyLTE          *string  `json:"consumerKeyLTE,omitempty"`
	ConsumerKeyContains     *string  `json:"consumerKeyContains,omitempty"`
	ConsumerKeyHasPrefix    *string  `json:"consumerKeyHasPrefix,omitempty"`
	ConsumerKeyHasSuffix    *string  `json:"consumerKeyHasSuffix,omitempty"`
	ConsumerKeyIsNil        bool     `json:"consumerKeyIsNil,omitempty"`
	ConsumerKeyNotNil       bool     `json:"consumerKeyNotNil,omitempty"`
	ConsumerKeyEqualFold    *string  `json:"consumerKeyEqualFold,omitempty"`
	ConsumerKeyContainsFold *string  `json:"consumerKeyContainsFold,omitempty"`

	// "consumer_secret" field predicates.
	ConsumerSecret             *string  `json:"consumerSecret,omitempty"`
	ConsumerSecretNEQ          *string  `json:"consumerSecretNEQ,omitempty"`
	ConsumerSecretIn           []string `json:"consumerSecretIn,omitempty"`
	ConsumerSecretNotIn        []string `json:"consumerSecretNotIn,omitempty"`
	ConsumerSecretGT           *string  `json:"consumerSecretGT,omitempty"`
	ConsumerSecretGTE          *string  `json:"consumerSecretGTE,omitempty"`
	ConsumerSecretLT           *string  `json:"consumerSecretLT,omitempty"`
	ConsumerSecretLTE          *string  `json:"consumerSecretLTE,omitempty"`
	ConsumerSecretContains     *string  `json:"consumerSecretContains,omitempty"`
	ConsumerSecretHasPrefix    *string  `json:"consumerSecretHasPrefix,omitempty"`
	ConsumerSecretHasSuffix    *string  `json:"consumerSecretHasSuffix,omitempty"`
	ConsumerSecretIsNil        bool     `json:"consumerSecretIsNil,omitempty"`
	ConsumerSecretNotNil       bool     `json:"consumerSecretNotNil,omitempty"`
	ConsumerSecretEqualFold    *string  `json:"consumerSecretEqualFold,omitempty"`
	ConsumerSecretContainsFold *string  `json:"consumerSecretContainsFold,omitempty"`

	// "mid" field predicates.
	Mid             *string  `json:"mid,omitempty"`
	MidNEQ          *string  `json:"midNEQ,omitempty"`
	MidIn           []string `json:"midIn,omitempty"`
	MidNotIn        []string `json:"midNotIn,omitempty"`
	MidGT           *string  `json:"midGT,omitempty"`
	MidGTE          *string  `json:"midGTE,omitempty"`
	MidLT           *string  `json:"midLT,omitempty"`
	MidLTE          *string  `json:"midLTE,omitempty"`
	MidContains     *string  `json:"midContains,omitempty"`
	MidHasPrefix    *string  `json:"midHasPrefix,omitempty"`
	MidHasSuffix    *string  `json:"midHasSuffix,omitempty"`
	MidIsNil        bool     `json:"midIsNil,omitempty"`
	MidNotNil       bool     `json:"midNotNil,omitempty"`
	MidEqualFold    *string  `json:"midEqualFold,omitempty"`
	MidContainsFold *string  `json:"midContainsFold,omitempty"`

	// "manifest_mid" field predicates.
	ManifestMid             *string  `json:"manifestMid,omitempty"`
	ManifestMidNEQ          *string  `json:"manifestMidNEQ,omitempty"`
	ManifestMidIn           []string `json:"manifestMidIn,omitempty"`
	ManifestMidNotIn        []string `json:"manifestMidNotIn,omitempty"`
	ManifestMidGT           *string  `json:"manifestMidGT,omitempty"`
	ManifestMidGTE          *string  `json:"manifestMidGTE,omitempty"`
	ManifestMidLT           *string  `json:"manifestMidLT,omitempty"`
	ManifestMidLTE          *string  `json:"manifestMidLTE,omitempty"`
	ManifestMidContains     *string  `json:"manifestMidContains,omitempty"`
	ManifestMidHasPrefix    *string  `json:"manifestMidHasPrefix,omitempty"`
	ManifestMidHasSuffix    *string  `json:"manifestMidHasSuffix,omitempty"`
	ManifestMidIsNil        bool     `json:"manifestMidIsNil,omitempty"`
	ManifestMidNotNil       bool     `json:"manifestMidNotNil,omitempty"`
	ManifestMidEqualFold    *string  `json:"manifestMidEqualFold,omitempty"`
	ManifestMidContainsFold *string  `json:"manifestMidContainsFold,omitempty"`

	// "crid" field predicates.
	Crid             *string  `json:"crid,omitempty"`
	CridNEQ          *string  `json:"cridNEQ,omitempty"`
	CridIn           []string `json:"cridIn,omitempty"`
	CridNotIn        []string `json:"cridNotIn,omitempty"`
	CridGT           *string  `json:"cridGT,omitempty"`
	CridGTE          *string  `json:"cridGTE,omitempty"`
	CridLT           *string  `json:"cridLT,omitempty"`
	CridLTE          *string  `json:"cridLTE,omitempty"`
	CridContains     *string  `json:"cridContains,omitempty"`
	CridHasPrefix    *string  `json:"cridHasPrefix,omitempty"`
	CridHasSuffix    *string  `json:"cridHasSuffix,omitempty"`
	CridIsNil        bool     `json:"cridIsNil,omitempty"`
	CridNotNil       bool     `json:"cridNotNil,omitempty"`
	CridEqualFold    *string  `json:"cridEqualFold,omitempty"`
	CridContainsFold *string  `json:"cridContainsFold,omitempty"`

	// "eps_account_number" field predicates.
	EpsAccountNumber             *string  `json:"epsAccountNumber,omitempty"`
	EpsAccountNumberNEQ          *string  `json:"epsAccountNumberNEQ,omitempty"`
	EpsAccountNumberIn           []string `json:"epsAccountNumberIn,omitempty"`
	EpsAccountNumberNotIn        []string `json:"epsAccountNumberNotIn,omitempty"`
	EpsAccountNumberGT           *string  `json:"epsAccountNumberGT,omitempty"`
	EpsAccountNumberGTE          *string  `json:"epsAccountNumberGTE,omitempty"`
	EpsAccountNumberLT           *string  `json:"epsAccountNumberLT,omitempty"`
	EpsAccountNumberLTE          *string  `json:"epsAccountNumberLTE,omitempty"`
	EpsAccountNumberContains     *string  `json:"epsAccountNumberContains,omitempty"`
	EpsAccountNumberHasPrefix    *string  `json:"epsAccountNumberHasPrefix,omitempty"`
	EpsAccountNumberHasSuffix    *string  `json:"epsAccountNumberHasSuffix,omitempty"`
	EpsAccountNumberIsNil        bool     `json:"epsAccountNumberIsNil,omitempty"`
	EpsAccountNumberNotNil       bool     `json:"epsAccountNumberNotNil,omitempty"`
	EpsAccountNumberEqualFold    *string  `json:"epsAccountNumberEqualFold,omitempty"`
	EpsAccountNumberContainsFold *string  `json:"epsAccountNumberContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CarrierUSPSWhereInput) AddPredicates(predicates ...predicate.CarrierUSPS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CarrierUSPSWhereInput filter on the CarrierUSPSQuery builder.
func (i *CarrierUSPSWhereInput) Filter(q *CarrierUSPSQuery) (*CarrierUSPSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCarrierUSPSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCarrierUSPSWhereInput is returned in case the CarrierUSPSWhereInput is empty.
var ErrEmptyCarrierUSPSWhereInput = errors.New("ent: empty predicate CarrierUSPSWhereInput")

// P returns a predicate for filtering carrieruspss.
// An error is returned if the input is empty or invalid.
func (i *CarrierUSPSWhereInput) P() (predicate.CarrierUSPS, error) {
	var predicates []predicate.CarrierUSPS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, carrierusps.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CarrierUSPS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, carrierusps.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CarrierUSPS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, carrierusps.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, carrierusps.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, carrierusps.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, carrierusps.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, carrierusps.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, carrierusps.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, carrierusps.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, carrierusps.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, carrierusps.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, carrierusps.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, carrierusps.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, carrierusps.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, carrierusps.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, carrierusps.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, carrierusps.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, carrierusps.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, carrierusps.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, carrierusps.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, carrierusps.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, carrierusps.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, carrierusps.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, carrierusps.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.IsTestAPI != nil {
		predicates = append(predicates, carrierusps.IsTestAPIEQ(*i.IsTestAPI))
	}
	if i.IsTestAPINEQ != nil {
		predicates = append(predicates, carrierusps.IsTestAPINEQ(*i.IsTestAPINEQ))
	}
	if i.ConsumerKey != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyEQ(*i.ConsumerKey))
	}
	if i.ConsumerKeyNEQ != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyNEQ(*i.ConsumerKeyNEQ))
	}
	if len(i.ConsumerKeyIn) > 0 {
		predicates = append(predicates, carrierusps.ConsumerKeyIn(i.ConsumerKeyIn...))
	}
	if len(i.ConsumerKeyNotIn) > 0 {
		predicates = append(predicates, carrierusps.ConsumerKeyNotIn(i.ConsumerKeyNotIn...))
	}
	if i.ConsumerKeyGT != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyGT(*i.ConsumerKeyGT))
	}
	if i.ConsumerKeyGTE != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyGTE(*i.ConsumerKeyGTE))
	}
	if i.ConsumerKeyLT != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyLT(*i.ConsumerKeyLT))
	}
	if i.ConsumerKeyLTE != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyLTE(*i.ConsumerKeyLTE))
	}
	if i.ConsumerKeyContains != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyContains(*i.ConsumerKeyContains))
	}
	if i.ConsumerKeyHasPrefix != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyHasPrefix(*i.ConsumerKeyHasPrefix))
	}
	if i.ConsumerKeyHasSuffix != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyHasSuffix(*i.ConsumerKeyHasSuffix))
	}
	if i.ConsumerKeyIsNil {
		predicates = append(predicates, carrierusps.ConsumerKeyIsNil())
	}
	if i.ConsumerKeyNotNil {
		predicates = append(predicates, carrierusps.ConsumerKeyNotNil())
	}
	if i.ConsumerKeyEqualFold != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyEqualFold(*i.ConsumerKeyEqualFold))
	}
	if i.ConsumerKeyContainsFold != nil {
		predicates = append(predicates, carrierusps.ConsumerKeyContainsFold(*i.ConsumerKeyContainsFold))
	}
	if i.ConsumerSecret != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretEQ(*i.ConsumerSecret))
	}
	if i.ConsumerSecretNEQ != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretNEQ(*i.ConsumerSecretNEQ))
	}
	if len(i.ConsumerSecretIn) > 0 {
		predicates = append(predicates, carrierusps.ConsumerSecretIn(i.ConsumerSecretIn...))
	}
	if len(i.ConsumerSecretNotIn) > 0 {
		predicates = append(predicates, carrierusps.ConsumerSecretNotIn(i.ConsumerSecretNotIn...))
	}
	if i.ConsumerSecretGT != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretGT(*i.ConsumerSecretGT))
	}
	if i.ConsumerSecretGTE != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretGTE(*i.ConsumerSecretGTE))
	}
	if i.ConsumerSecretLT != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretLT(*i.ConsumerSecretLT))
	}
	if i.ConsumerSecretLTE != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretLTE(*i.ConsumerSecretLTE))
	}
	if i.ConsumerSecretContains != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretContains(*i.ConsumerSecretContains))
	}
	if i.ConsumerSecretHasPrefix != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretHasPrefix(*i.ConsumerSecretHasPrefix))
	}
	if i.ConsumerSecretHasSuffix != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretHasSuffix(*i.ConsumerSecretHasSuffix))
	}
	if i.ConsumerSecretIsNil {
		predicates = append(predicates, carrierusps.ConsumerSecretIsNil())
	}
	if i.ConsumerSecretNotNil {
		predicates = append(predicates, carrierusps.ConsumerSecretNotNil())
	}
	if i.ConsumerSecretEqualFold != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretEqualFold(*i.ConsumerSecretEqualFold))
	}
	if i.ConsumerSecretContainsFold != nil {
		predicates = append(predicates, carrierusps.ConsumerSecretContainsFold(*i.ConsumerSecretContainsFold))
	}
	if i.Mid != nil {
		predicates = append(predicates, carrierusps.MidEQ(*i.Mid))
	}
	if i.MidNEQ != nil {
		predicates = append(predicates, carrierusps.MidNEQ(*i.MidNEQ))
	}
	if len(i.MidIn) > 0 {
		predicates = append(predicates, carrierusps.MidIn(i.MidIn...))
	}
	if len(i.MidNotIn) > 0 {
		predicates = append(predicates, carrierusps.MidNotIn(i.MidNotIn...))
	}
	if i.MidGT != nil {
		predicates = append(predicates, carrierusps.MidGT(*i.MidGT))
	}
	if i.MidGTE != nil {
		predicates = append(predicates, carrierusps.MidGTE(*i.MidGTE))
	}
	if i.MidLT != nil {
		predicates = append(predicates, carrierusps.MidLT(*i.MidLT))
	}
	if i.MidLTE != nil {
		predicates = append(predicates, carrierusps.MidLTE(*i.MidLTE))
	}
	if i.MidContains != nil {
		predicates = append(predicates, carrierusps.MidContains(*i.MidContains))
	}
	if i.MidHasPrefix != nil {
		predicates = append(predicates, carrierusps.MidHasPrefix(*i.MidHasPrefix))
	}
	if i.MidHasSuffix != nil {
		predicates = append(predicates, carrierusps.MidHasSuffix(*i.MidHasSuffix))
	}
	if i.MidIsNil {
		predicates = append(predicates, carrierusps.MidIsNil())
	}
	if i.MidNotNil {
		predicates = append(predicates, carrierusps.MidNotNil())
	}
	if i.MidEqualFold != nil {
		predicates = append(predicates, carrierusps.MidEqualFold(*i.MidEqualFold))
	}
	if i.MidContainsFold != nil {
		predicates = append(predicates, carrierusps.MidContainsFold(*i.MidContainsFold))
	}
	if i.ManifestMid != nil {
		predicates = append(predicates, carrierusps.ManifestMidEQ(*i.ManifestMid))
	}
	if i.ManifestMidNEQ != nil {
		predicates = append(predicates, carrierusps.ManifestMidNEQ(*i.ManifestMidNEQ))
	}
	if len(i.ManifestMidIn) > 0 {
		predicates = append(predicates, carrierusps.ManifestMidIn(i.ManifestMidIn...))
	}
	if len(i.ManifestMidNotIn) > 0 {
		predicates = append(predicates, carrierusps.ManifestMidNotIn(i.ManifestMidNotIn...))
	}
	if i.ManifestMidGT != nil {
		predicates = append(predicates, carrierusps.ManifestMidGT(*i.ManifestMidGT))
	}
	if i.ManifestMidGTE != nil {
		predicates = append(predicates, carrierusps.ManifestMidGTE(*i.ManifestMidGTE))
	}
	if i.ManifestMidLT != nil {
		predicates = append(predicates, carrierusps.ManifestMidLT(*i.ManifestMidLT))
	}
	if i.ManifestMidLTE != nil {
		predicates = append(predicates, carrierusps.ManifestMidLTE(*i.ManifestMidLTE))
	}
	if i.ManifestMidContains != nil {
		predicates = append(predicates, carrierusps.ManifestMidContains(*i.ManifestMidContains))
	}
	if i.ManifestMidHasPrefix != nil {
		predicates = append(predicates, carrierusps.ManifestMidHasPrefix(*i.ManifestMidHasPrefix))
	}
	if i.ManifestMidHasSuffix != nil {
		predicates = append(predicates, carrierusps.ManifestMidHasSuffix(*i.ManifestMidHasSuffix))
	}
	if i.ManifestMidIsNil {
		predicates = append(predicates, carrierusps.ManifestMidIsNil())
	}
	if i.ManifestMidNotNil {
		predicates = append(predicates, carrierusps.ManifestMidNotNil())
	}
	if i.ManifestMidEqualFold != nil {
		predicates = append(predicates, carrierusps.ManifestMidEqualFold(*i.ManifestMidEqualFold))
	}
	if i.ManifestMidContainsFold != nil {
		predicates = append(predicates, carrierusps.ManifestMidContainsFold(*i.ManifestMidContainsFold))
	}
	if i.Crid != nil {
		predicates = append(predicates, carrierusps.CridEQ(*i.Crid))
	}
	if i.CridNEQ != nil {
		predicates = append(predicates, carrierusps.CridNEQ(*i.CridNEQ))
	}
	if len(i.CridIn) > 0 {
		predicates = append(predicates, carrierusps.CridIn(i.CridIn...))
	}
	if len(i.CridNotIn) > 0 {
		predicates = append(predicates, carrierusps.CridNotIn(i.CridNotIn...))
	}
	if i.CridGT != nil {
		predicates = append(predicates, carrierusps.CridGT(*i.CridGT))
	}
	if i.CridGTE != nil {
		predicates = append(predicates, carrierusps.CridGTE(*i.CridGTE))
	}
	if i.CridLT != nil {
		predicates = append(predicates, carrierusps.CridLT(*i.CridLT))
	}
	if i.CridLTE != nil {
		predicates = append(predicates, carrierusps.CridLTE(*i.CridLTE))
	}
	if i.CridContains != nil {
		predicates = append(predicates, carrierusps.CridContains(*i.CridContains))
	}
	if i.CridHasPrefix != nil {
		predicates = append(predicates, carrierusps.CridHasPrefix(*i.CridHasPrefix))
	}
	if i.CridHasSuffix != nil {
		predicates = append(predicates, carrierusps.CridHasSuffix(*i.CridHasSuffix))
	}
	if i.CridIsNil {
		predicates = append(predicates, carrierusps.CridIsNil())
	}
	if i.CridNotNil {
		predicates = append(predicates, carrierusps.CridNotNil())
	}
	if i.CridEqualFold != nil {
		predicates = append(predicates, carrierusps.CridEqualFold(*i.CridEqualFold))
	}
	if i.CridContainsFold != nil {
		predicates = append(predicates, carrierusps.CridContainsFold(*i.CridContainsFold))
	}
	if i.EpsAccountNumber != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberEQ(*i.EpsAccountNumber))
	}
	if i.EpsAccountNumberNEQ != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberNEQ(*i.EpsAccountNumberNEQ))
	}
	if len(i.EpsAccountNumberIn) > 0 {
		predicates = append(predicates, carrierusps.EpsAccountNumberIn(i.EpsAccountNumberIn...))
	}
	if len(i.EpsAccountNumberNotIn) > 0 {
		predicates = append(predicates, carrierusps.EpsAccountNumberNotIn(i.EpsAccountNumberNotIn...))
	}
	if i.EpsAccountNumberGT != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberGT(*i.EpsAccountNumberGT))
	}
	if i.EpsAccountNumberGTE != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberGTE(*i.EpsAccountNumberGTE))
	}
	if i.EpsAccountNumberLT != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberLT(*i.EpsAccountNumberLT))
	}
	if i.EpsAccountNumberLTE != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberLTE(*i.EpsAccountNumberLTE))
	}
	if i.EpsAccountNumberContains != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberContains(*i.EpsAccountNumberContains))
	}
	if i.EpsAccountNumberHasPrefix != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberHasPrefix(*i.EpsAccountNumberHasPrefix))
	}
	if i.EpsAccountNumberHasSuffix != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberHasSuffix(*i.EpsAccountNumberHasSuffix))
	}
	if i.EpsAccountNumberIsNil {
		predicates = append(predicates, carrierusps.EpsAccountNumberIsNil())
	}
	if i.EpsAccountNumberNotNil {
		predicates = append(predicates, carrierusps.EpsAccountNumberNotNil())
	}
	if i.EpsAccountNumberEqualFold != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberEqualFold(*i.EpsAccountNumberEqualFold))
	}
	if i.EpsAccountNumberContainsFold != nil {
		predicates = append(predicates, carrierusps.EpsAccountNumberContainsFold(*i.EpsAccountNumberContainsFold))
	}

	if i.HasTenant != nil {
		p := carrierusps.HasTenant()
		if !*i.HasTenant {
			p = carrierusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierusps.HasTenantWith(with...))
	}
	if i.HasCarrier != nil {
		p := carrierusps.HasCarrier()
		if !*i.HasCarrier {
			p = carrierusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, carrierusps.HasCarrierWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCarrierUSPSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return carrierusps.And(predicates...), nil
	}
}

// ChangeHistoryWhereInput represents a where input for filtering ChangeHistory queries.
type ChangeHistoryWhereInput struct {
	Predicates []predicate.ChangeHistory  `json:"-"`
	Not        *ChangeHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ChangeHistoryWhereInput `json:"or,omitempty"`
	And        []*ChangeHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "origin" field predicates.
	Origin      *changehistory.Origin  `json:"origin,omitempty"`
	OriginNEQ   *changehistory.Origin  `json:"originNEQ,omitempty"`
	OriginIn    []changehistory.Origin `json:"originIn,omitempty"`
	OriginNotIn []changehistory.Origin `json:"originNotIn,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "plan_history" edge predicates.
	HasPlanHistory     *bool                    `json:"hasPlanHistory,omitempty"`
	HasPlanHistoryWith []*PlanHistoryWhereInput `json:"hasPlanHistoryWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "order_history" edge predicates.
	HasOrderHistory     *bool                     `json:"hasOrderHistory,omitempty"`
	HasOrderHistoryWith []*OrderHistoryWhereInput `json:"hasOrderHistoryWith,omitempty"`

	// "shipment_history" edge predicates.
	HasShipmentHistory     *bool                        `json:"hasShipmentHistory,omitempty"`
	HasShipmentHistoryWith []*ShipmentHistoryWhereInput `json:"hasShipmentHistoryWith,omitempty"`

	// "return_colli_history" edge predicates.
	HasReturnColliHistory     *bool                           `json:"hasReturnColliHistory,omitempty"`
	HasReturnColliHistoryWith []*ReturnColliHistoryWhereInput `json:"hasReturnColliHistoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ChangeHistoryWhereInput) AddPredicates(predicates ...predicate.ChangeHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ChangeHistoryWhereInput filter on the ChangeHistoryQuery builder.
func (i *ChangeHistoryWhereInput) Filter(q *ChangeHistoryQuery) (*ChangeHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyChangeHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyChangeHistoryWhereInput is returned in case the ChangeHistoryWhereInput is empty.
var ErrEmptyChangeHistoryWhereInput = errors.New("ent: empty predicate ChangeHistoryWhereInput")

// P returns a predicate for filtering changehistories.
// An error is returned if the input is empty or invalid.
func (i *ChangeHistoryWhereInput) P() (predicate.ChangeHistory, error) {
	var predicates []predicate.ChangeHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, changehistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ChangeHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, changehistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ChangeHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, changehistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, changehistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, changehistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, changehistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, changehistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, changehistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, changehistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, changehistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, changehistory.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, changehistory.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, changehistory.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, changehistory.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, changehistory.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, changehistory.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, changehistory.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, changehistory.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, changehistory.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, changehistory.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, changehistory.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, changehistory.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, changehistory.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, changehistory.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, changehistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, changehistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, changehistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, changehistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, changehistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, changehistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, changehistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, changehistory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Origin != nil {
		predicates = append(predicates, changehistory.OriginEQ(*i.Origin))
	}
	if i.OriginNEQ != nil {
		predicates = append(predicates, changehistory.OriginNEQ(*i.OriginNEQ))
	}
	if len(i.OriginIn) > 0 {
		predicates = append(predicates, changehistory.OriginIn(i.OriginIn...))
	}
	if len(i.OriginNotIn) > 0 {
		predicates = append(predicates, changehistory.OriginNotIn(i.OriginNotIn...))
	}

	if i.HasTenant != nil {
		p := changehistory.HasTenant()
		if !*i.HasTenant {
			p = changehistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, changehistory.HasTenantWith(with...))
	}
	if i.HasPlanHistory != nil {
		p := changehistory.HasPlanHistory()
		if !*i.HasPlanHistory {
			p = changehistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlanHistoryWith) > 0 {
		with := make([]predicate.PlanHistory, 0, len(i.HasPlanHistoryWith))
		for _, w := range i.HasPlanHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPlanHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, changehistory.HasPlanHistoryWith(with...))
	}
	if i.HasUser != nil {
		p := changehistory.HasUser()
		if !*i.HasUser {
			p = changehistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, changehistory.HasUserWith(with...))
	}
	if i.HasOrderHistory != nil {
		p := changehistory.HasOrderHistory()
		if !*i.HasOrderHistory {
			p = changehistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrderHistoryWith) > 0 {
		with := make([]predicate.OrderHistory, 0, len(i.HasOrderHistoryWith))
		for _, w := range i.HasOrderHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrderHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, changehistory.HasOrderHistoryWith(with...))
	}
	if i.HasShipmentHistory != nil {
		p := changehistory.HasShipmentHistory()
		if !*i.HasShipmentHistory {
			p = changehistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentHistoryWith) > 0 {
		with := make([]predicate.ShipmentHistory, 0, len(i.HasShipmentHistoryWith))
		for _, w := range i.HasShipmentHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, changehistory.HasShipmentHistoryWith(with...))
	}
	if i.HasReturnColliHistory != nil {
		p := changehistory.HasReturnColliHistory()
		if !*i.HasReturnColliHistory {
			p = changehistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnColliHistoryWith) > 0 {
		with := make([]predicate.ReturnColliHistory, 0, len(i.HasReturnColliHistoryWith))
		for _, w := range i.HasReturnColliHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnColliHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, changehistory.HasReturnColliHistoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyChangeHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return changehistory.And(predicates...), nil
	}
}

// ColliWhereInput represents a where input for filtering Colli queries.
type ColliWhereInput struct {
	Predicates []predicate.Colli  `json:"-"`
	Not        *ColliWhereInput   `json:"not,omitempty"`
	Or         []*ColliWhereInput `json:"or,omitempty"`
	And        []*ColliWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "internal_barcode" field predicates.
	InternalBarcode       *int64  `json:"internalBarcode,omitempty"`
	InternalBarcodeNEQ    *int64  `json:"internalBarcodeNEQ,omitempty"`
	InternalBarcodeIn     []int64 `json:"internalBarcodeIn,omitempty"`
	InternalBarcodeNotIn  []int64 `json:"internalBarcodeNotIn,omitempty"`
	InternalBarcodeGT     *int64  `json:"internalBarcodeGT,omitempty"`
	InternalBarcodeGTE    *int64  `json:"internalBarcodeGTE,omitempty"`
	InternalBarcodeLT     *int64  `json:"internalBarcodeLT,omitempty"`
	InternalBarcodeLTE    *int64  `json:"internalBarcodeLTE,omitempty"`
	InternalBarcodeIsNil  bool    `json:"internalBarcodeIsNil,omitempty"`
	InternalBarcodeNotNil bool    `json:"internalBarcodeNotNil,omitempty"`

	// "status" field predicates.
	Status      *colli.Status  `json:"status,omitempty"`
	StatusNEQ   *colli.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []colli.Status `json:"statusIn,omitempty"`
	StatusNotIn []colli.Status `json:"statusNotIn,omitempty"`

	// "slip_print_status" field predicates.
	SlipPrintStatus      *colli.SlipPrintStatus  `json:"slipPrintStatus,omitempty"`
	SlipPrintStatusNEQ   *colli.SlipPrintStatus  `json:"slipPrintStatusNEQ,omitempty"`
	SlipPrintStatusIn    []colli.SlipPrintStatus `json:"slipPrintStatusIn,omitempty"`
	SlipPrintStatusNotIn []colli.SlipPrintStatus `json:"slipPrintStatusNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "email_packing_slip_printed_at" field predicates.
	EmailPackingSlipPrintedAt       *time.Time  `json:"emailPackingSlipPrintedAt,omitempty"`
	EmailPackingSlipPrintedAtNEQ    *time.Time  `json:"emailPackingSlipPrintedAtNEQ,omitempty"`
	EmailPackingSlipPrintedAtIn     []time.Time `json:"emailPackingSlipPrintedAtIn,omitempty"`
	EmailPackingSlipPrintedAtNotIn  []time.Time `json:"emailPackingSlipPrintedAtNotIn,omitempty"`
	EmailPackingSlipPrintedAtGT     *time.Time  `json:"emailPackingSlipPrintedAtGT,omitempty"`
	EmailPackingSlipPrintedAtGTE    *time.Time  `json:"emailPackingSlipPrintedAtGTE,omitempty"`
	EmailPackingSlipPrintedAtLT     *time.Time  `json:"emailPackingSlipPrintedAtLT,omitempty"`
	EmailPackingSlipPrintedAtLTE    *time.Time  `json:"emailPackingSlipPrintedAtLTE,omitempty"`
	EmailPackingSlipPrintedAtIsNil  bool        `json:"emailPackingSlipPrintedAtIsNil,omitempty"`
	EmailPackingSlipPrintedAtNotNil bool        `json:"emailPackingSlipPrintedAtNotNil,omitempty"`

	// "email_label_printed_at" field predicates.
	EmailLabelPrintedAt       *time.Time  `json:"emailLabelPrintedAt,omitempty"`
	EmailLabelPrintedAtNEQ    *time.Time  `json:"emailLabelPrintedAtNEQ,omitempty"`
	EmailLabelPrintedAtIn     []time.Time `json:"emailLabelPrintedAtIn,omitempty"`
	EmailLabelPrintedAtNotIn  []time.Time `json:"emailLabelPrintedAtNotIn,omitempty"`
	EmailLabelPrintedAtGT     *time.Time  `json:"emailLabelPrintedAtGT,omitempty"`
	EmailLabelPrintedAtGTE    *time.Time  `json:"emailLabelPrintedAtGTE,omitempty"`
	EmailLabelPrintedAtLT     *time.Time  `json:"emailLabelPrintedAtLT,omitempty"`
	EmailLabelPrintedAtLTE    *time.Time  `json:"emailLabelPrintedAtLTE,omitempty"`
	EmailLabelPrintedAtIsNil  bool        `json:"emailLabelPrintedAtIsNil,omitempty"`
	EmailLabelPrintedAtNotNil bool        `json:"emailLabelPrintedAtNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "recipient" edge predicates.
	HasRecipient     *bool                `json:"hasRecipient,omitempty"`
	HasRecipientWith []*AddressWhereInput `json:"hasRecipientWith,omitempty"`

	// "sender" edge predicates.
	HasSender     *bool                `json:"hasSender,omitempty"`
	HasSenderWith []*AddressWhereInput `json:"hasSenderWith,omitempty"`

	// "parcel_shop" edge predicates.
	HasParcelShop     *bool                   `json:"hasParcelShop,omitempty"`
	HasParcelShopWith []*ParcelShopWhereInput `json:"hasParcelShopWith,omitempty"`

	// "click_collect_location" edge predicates.
	HasClickCollectLocation     *bool                 `json:"hasClickCollectLocation,omitempty"`
	HasClickCollectLocationWith []*LocationWhereInput `json:"hasClickCollectLocationWith,omitempty"`

	// "order_lines" edge predicates.
	HasOrderLines     *bool                  `json:"hasOrderLines,omitempty"`
	HasOrderLinesWith []*OrderLineWhereInput `json:"hasOrderLinesWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "document_file" edge predicates.
	HasDocumentFile     *bool                     `json:"hasDocumentFile,omitempty"`
	HasDocumentFileWith []*DocumentFileWhereInput `json:"hasDocumentFileWith,omitempty"`

	// "shipment_parcel" edge predicates.
	HasShipmentParcel     *bool                       `json:"hasShipmentParcel,omitempty"`
	HasShipmentParcelWith []*ShipmentParcelWhereInput `json:"hasShipmentParcelWith,omitempty"`

	// "cancelled_shipment_parcel" edge predicates.
	HasCancelledShipmentParcel     *bool                       `json:"hasCancelledShipmentParcel,omitempty"`
	HasCancelledShipmentParcelWith []*ShipmentParcelWhereInput `json:"hasCancelledShipmentParcelWith,omitempty"`

	// "order" edge predicates.
	HasOrder     *bool              `json:"hasOrder,omitempty"`
	HasOrderWith []*OrderWhereInput `json:"hasOrderWith,omitempty"`

	// "packaging" edge predicates.
	HasPackaging     *bool                  `json:"hasPackaging,omitempty"`
	HasPackagingWith []*PackagingWhereInput `json:"hasPackagingWith,omitempty"`

	// "print_job" edge predicates.
	HasPrintJob     *bool                 `json:"hasPrintJob,omitempty"`
	HasPrintJobWith []*PrintJobWhereInput `json:"hasPrintJobWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ColliWhereInput) AddPredicates(predicates ...predicate.Colli) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ColliWhereInput filter on the ColliQuery builder.
func (i *ColliWhereInput) Filter(q *ColliQuery) (*ColliQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyColliWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyColliWhereInput is returned in case the ColliWhereInput is empty.
var ErrEmptyColliWhereInput = errors.New("ent: empty predicate ColliWhereInput")

// P returns a predicate for filtering collis.
// An error is returned if the input is empty or invalid.
func (i *ColliWhereInput) P() (predicate.Colli, error) {
	var predicates []predicate.Colli
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, colli.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Colli, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, colli.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Colli, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, colli.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, colli.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, colli.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, colli.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, colli.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, colli.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, colli.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, colli.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, colli.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, colli.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, colli.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, colli.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, colli.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, colli.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, colli.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, colli.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, colli.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, colli.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, colli.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, colli.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, colli.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, colli.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.InternalBarcode != nil {
		predicates = append(predicates, colli.InternalBarcodeEQ(*i.InternalBarcode))
	}
	if i.InternalBarcodeNEQ != nil {
		predicates = append(predicates, colli.InternalBarcodeNEQ(*i.InternalBarcodeNEQ))
	}
	if len(i.InternalBarcodeIn) > 0 {
		predicates = append(predicates, colli.InternalBarcodeIn(i.InternalBarcodeIn...))
	}
	if len(i.InternalBarcodeNotIn) > 0 {
		predicates = append(predicates, colli.InternalBarcodeNotIn(i.InternalBarcodeNotIn...))
	}
	if i.InternalBarcodeGT != nil {
		predicates = append(predicates, colli.InternalBarcodeGT(*i.InternalBarcodeGT))
	}
	if i.InternalBarcodeGTE != nil {
		predicates = append(predicates, colli.InternalBarcodeGTE(*i.InternalBarcodeGTE))
	}
	if i.InternalBarcodeLT != nil {
		predicates = append(predicates, colli.InternalBarcodeLT(*i.InternalBarcodeLT))
	}
	if i.InternalBarcodeLTE != nil {
		predicates = append(predicates, colli.InternalBarcodeLTE(*i.InternalBarcodeLTE))
	}
	if i.InternalBarcodeIsNil {
		predicates = append(predicates, colli.InternalBarcodeIsNil())
	}
	if i.InternalBarcodeNotNil {
		predicates = append(predicates, colli.InternalBarcodeNotNil())
	}
	if i.Status != nil {
		predicates = append(predicates, colli.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, colli.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, colli.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, colli.StatusNotIn(i.StatusNotIn...))
	}
	if i.SlipPrintStatus != nil {
		predicates = append(predicates, colli.SlipPrintStatusEQ(*i.SlipPrintStatus))
	}
	if i.SlipPrintStatusNEQ != nil {
		predicates = append(predicates, colli.SlipPrintStatusNEQ(*i.SlipPrintStatusNEQ))
	}
	if len(i.SlipPrintStatusIn) > 0 {
		predicates = append(predicates, colli.SlipPrintStatusIn(i.SlipPrintStatusIn...))
	}
	if len(i.SlipPrintStatusNotIn) > 0 {
		predicates = append(predicates, colli.SlipPrintStatusNotIn(i.SlipPrintStatusNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, colli.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, colli.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, colli.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, colli.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, colli.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, colli.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, colli.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, colli.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.EmailPackingSlipPrintedAt != nil {
		predicates = append(predicates, colli.EmailPackingSlipPrintedAtEQ(*i.EmailPackingSlipPrintedAt))
	}
	if i.EmailPackingSlipPrintedAtNEQ != nil {
		predicates = append(predicates, colli.EmailPackingSlipPrintedAtNEQ(*i.EmailPackingSlipPrintedAtNEQ))
	}
	if len(i.EmailPackingSlipPrintedAtIn) > 0 {
		predicates = append(predicates, colli.EmailPackingSlipPrintedAtIn(i.EmailPackingSlipPrintedAtIn...))
	}
	if len(i.EmailPackingSlipPrintedAtNotIn) > 0 {
		predicates = append(predicates, colli.EmailPackingSlipPrintedAtNotIn(i.EmailPackingSlipPrintedAtNotIn...))
	}
	if i.EmailPackingSlipPrintedAtGT != nil {
		predicates = append(predicates, colli.EmailPackingSlipPrintedAtGT(*i.EmailPackingSlipPrintedAtGT))
	}
	if i.EmailPackingSlipPrintedAtGTE != nil {
		predicates = append(predicates, colli.EmailPackingSlipPrintedAtGTE(*i.EmailPackingSlipPrintedAtGTE))
	}
	if i.EmailPackingSlipPrintedAtLT != nil {
		predicates = append(predicates, colli.EmailPackingSlipPrintedAtLT(*i.EmailPackingSlipPrintedAtLT))
	}
	if i.EmailPackingSlipPrintedAtLTE != nil {
		predicates = append(predicates, colli.EmailPackingSlipPrintedAtLTE(*i.EmailPackingSlipPrintedAtLTE))
	}
	if i.EmailPackingSlipPrintedAtIsNil {
		predicates = append(predicates, colli.EmailPackingSlipPrintedAtIsNil())
	}
	if i.EmailPackingSlipPrintedAtNotNil {
		predicates = append(predicates, colli.EmailPackingSlipPrintedAtNotNil())
	}
	if i.EmailLabelPrintedAt != nil {
		predicates = append(predicates, colli.EmailLabelPrintedAtEQ(*i.EmailLabelPrintedAt))
	}
	if i.EmailLabelPrintedAtNEQ != nil {
		predicates = append(predicates, colli.EmailLabelPrintedAtNEQ(*i.EmailLabelPrintedAtNEQ))
	}
	if len(i.EmailLabelPrintedAtIn) > 0 {
		predicates = append(predicates, colli.EmailLabelPrintedAtIn(i.EmailLabelPrintedAtIn...))
	}
	if len(i.EmailLabelPrintedAtNotIn) > 0 {
		predicates = append(predicates, colli.EmailLabelPrintedAtNotIn(i.EmailLabelPrintedAtNotIn...))
	}
	if i.EmailLabelPrintedAtGT != nil {
		predicates = append(predicates, colli.EmailLabelPrintedAtGT(*i.EmailLabelPrintedAtGT))
	}
	if i.EmailLabelPrintedAtGTE != nil {
		predicates = append(predicates, colli.EmailLabelPrintedAtGTE(*i.EmailLabelPrintedAtGTE))
	}
	if i.EmailLabelPrintedAtLT != nil {
		predicates = append(predicates, colli.EmailLabelPrintedAtLT(*i.EmailLabelPrintedAtLT))
	}
	if i.EmailLabelPrintedAtLTE != nil {
		predicates = append(predicates, colli.EmailLabelPrintedAtLTE(*i.EmailLabelPrintedAtLTE))
	}
	if i.EmailLabelPrintedAtIsNil {
		predicates = append(predicates, colli.EmailLabelPrintedAtIsNil())
	}
	if i.EmailLabelPrintedAtNotNil {
		predicates = append(predicates, colli.EmailLabelPrintedAtNotNil())
	}

	if i.HasTenant != nil {
		p := colli.HasTenant()
		if !*i.HasTenant {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasTenantWith(with...))
	}
	if i.HasRecipient != nil {
		p := colli.HasRecipient()
		if !*i.HasRecipient {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRecipientWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasRecipientWith))
		for _, w := range i.HasRecipientWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRecipientWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasRecipientWith(with...))
	}
	if i.HasSender != nil {
		p := colli.HasSender()
		if !*i.HasSender {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSenderWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasSenderWith))
		for _, w := range i.HasSenderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSenderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasSenderWith(with...))
	}
	if i.HasParcelShop != nil {
		p := colli.HasParcelShop()
		if !*i.HasParcelShop {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopWith) > 0 {
		with := make([]predicate.ParcelShop, 0, len(i.HasParcelShopWith))
		for _, w := range i.HasParcelShopWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasParcelShopWith(with...))
	}
	if i.HasClickCollectLocation != nil {
		p := colli.HasClickCollectLocation()
		if !*i.HasClickCollectLocation {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClickCollectLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasClickCollectLocationWith))
		for _, w := range i.HasClickCollectLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasClickCollectLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasClickCollectLocationWith(with...))
	}
	if i.HasOrderLines != nil {
		p := colli.HasOrderLines()
		if !*i.HasOrderLines {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrderLinesWith) > 0 {
		with := make([]predicate.OrderLine, 0, len(i.HasOrderLinesWith))
		for _, w := range i.HasOrderLinesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrderLinesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasOrderLinesWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := colli.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasDeliveryOptionWith(with...))
	}
	if i.HasDocumentFile != nil {
		p := colli.HasDocumentFile()
		if !*i.HasDocumentFile {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentFileWith) > 0 {
		with := make([]predicate.DocumentFile, 0, len(i.HasDocumentFileWith))
		for _, w := range i.HasDocumentFileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentFileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasDocumentFileWith(with...))
	}
	if i.HasShipmentParcel != nil {
		p := colli.HasShipmentParcel()
		if !*i.HasShipmentParcel {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentParcelWith) > 0 {
		with := make([]predicate.ShipmentParcel, 0, len(i.HasShipmentParcelWith))
		for _, w := range i.HasShipmentParcelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentParcelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasShipmentParcelWith(with...))
	}
	if i.HasCancelledShipmentParcel != nil {
		p := colli.HasCancelledShipmentParcel()
		if !*i.HasCancelledShipmentParcel {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCancelledShipmentParcelWith) > 0 {
		with := make([]predicate.ShipmentParcel, 0, len(i.HasCancelledShipmentParcelWith))
		for _, w := range i.HasCancelledShipmentParcelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCancelledShipmentParcelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasCancelledShipmentParcelWith(with...))
	}
	if i.HasOrder != nil {
		p := colli.HasOrder()
		if !*i.HasOrder {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrderWith) > 0 {
		with := make([]predicate.Order, 0, len(i.HasOrderWith))
		for _, w := range i.HasOrderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasOrderWith(with...))
	}
	if i.HasPackaging != nil {
		p := colli.HasPackaging()
		if !*i.HasPackaging {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingWith) > 0 {
		with := make([]predicate.Packaging, 0, len(i.HasPackagingWith))
		for _, w := range i.HasPackagingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasPackagingWith(with...))
	}
	if i.HasPrintJob != nil {
		p := colli.HasPrintJob()
		if !*i.HasPrintJob {
			p = colli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPrintJobWith) > 0 {
		with := make([]predicate.PrintJob, 0, len(i.HasPrintJobWith))
		for _, w := range i.HasPrintJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPrintJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, colli.HasPrintJobWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyColliWhereInput
	case 1:
		return predicates[0], nil
	default:
		return colli.And(predicates...), nil
	}
}

// ConnectOptionCarrierWhereInput represents a where input for filtering ConnectOptionCarrier queries.
type ConnectOptionCarrierWhereInput struct {
	Predicates []predicate.ConnectOptionCarrier  `json:"-"`
	Not        *ConnectOptionCarrierWhereInput   `json:"not,omitempty"`
	Or         []*ConnectOptionCarrierWhereInput `json:"or,omitempty"`
	And        []*ConnectOptionCarrierWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ConnectOptionCarrierWhereInput) AddPredicates(predicates ...predicate.ConnectOptionCarrier) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ConnectOptionCarrierWhereInput filter on the ConnectOptionCarrierQuery builder.
func (i *ConnectOptionCarrierWhereInput) Filter(q *ConnectOptionCarrierQuery) (*ConnectOptionCarrierQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyConnectOptionCarrierWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyConnectOptionCarrierWhereInput is returned in case the ConnectOptionCarrierWhereInput is empty.
var ErrEmptyConnectOptionCarrierWhereInput = errors.New("ent: empty predicate ConnectOptionCarrierWhereInput")

// P returns a predicate for filtering connectoptioncarriers.
// An error is returned if the input is empty or invalid.
func (i *ConnectOptionCarrierWhereInput) P() (predicate.ConnectOptionCarrier, error) {
	var predicates []predicate.ConnectOptionCarrier
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, connectoptioncarrier.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ConnectOptionCarrier, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, connectoptioncarrier.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ConnectOptionCarrier, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, connectoptioncarrier.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, connectoptioncarrier.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, connectoptioncarrier.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, connectoptioncarrier.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, connectoptioncarrier.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, connectoptioncarrier.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, connectoptioncarrier.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, connectoptioncarrier.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, connectoptioncarrier.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, connectoptioncarrier.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, connectoptioncarrier.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, connectoptioncarrier.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, connectoptioncarrier.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, connectoptioncarrier.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, connectoptioncarrier.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, connectoptioncarrier.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, connectoptioncarrier.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, connectoptioncarrier.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, connectoptioncarrier.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, connectoptioncarrier.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, connectoptioncarrier.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, connectoptioncarrier.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasTenant != nil {
		p := connectoptioncarrier.HasTenant()
		if !*i.HasTenant {
			p = connectoptioncarrier.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connectoptioncarrier.HasTenantWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyConnectOptionCarrierWhereInput
	case 1:
		return predicates[0], nil
	default:
		return connectoptioncarrier.And(predicates...), nil
	}
}

// ConnectOptionPlatformWhereInput represents a where input for filtering ConnectOptionPlatform queries.
type ConnectOptionPlatformWhereInput struct {
	Predicates []predicate.ConnectOptionPlatform  `json:"-"`
	Not        *ConnectOptionPlatformWhereInput   `json:"not,omitempty"`
	Or         []*ConnectOptionPlatformWhereInput `json:"or,omitempty"`
	And        []*ConnectOptionPlatformWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ConnectOptionPlatformWhereInput) AddPredicates(predicates ...predicate.ConnectOptionPlatform) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ConnectOptionPlatformWhereInput filter on the ConnectOptionPlatformQuery builder.
func (i *ConnectOptionPlatformWhereInput) Filter(q *ConnectOptionPlatformQuery) (*ConnectOptionPlatformQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyConnectOptionPlatformWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyConnectOptionPlatformWhereInput is returned in case the ConnectOptionPlatformWhereInput is empty.
var ErrEmptyConnectOptionPlatformWhereInput = errors.New("ent: empty predicate ConnectOptionPlatformWhereInput")

// P returns a predicate for filtering connectoptionplatforms.
// An error is returned if the input is empty or invalid.
func (i *ConnectOptionPlatformWhereInput) P() (predicate.ConnectOptionPlatform, error) {
	var predicates []predicate.ConnectOptionPlatform
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, connectoptionplatform.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ConnectOptionPlatform, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, connectoptionplatform.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ConnectOptionPlatform, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, connectoptionplatform.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, connectoptionplatform.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, connectoptionplatform.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, connectoptionplatform.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, connectoptionplatform.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, connectoptionplatform.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, connectoptionplatform.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, connectoptionplatform.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, connectoptionplatform.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, connectoptionplatform.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, connectoptionplatform.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, connectoptionplatform.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, connectoptionplatform.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, connectoptionplatform.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, connectoptionplatform.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, connectoptionplatform.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, connectoptionplatform.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, connectoptionplatform.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, connectoptionplatform.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, connectoptionplatform.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, connectoptionplatform.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, connectoptionplatform.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasTenant != nil {
		p := connectoptionplatform.HasTenant()
		if !*i.HasTenant {
			p = connectoptionplatform.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connectoptionplatform.HasTenantWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyConnectOptionPlatformWhereInput
	case 1:
		return predicates[0], nil
	default:
		return connectoptionplatform.And(predicates...), nil
	}
}

// ConnectionWhereInput represents a where input for filtering Connection queries.
type ConnectionWhereInput struct {
	Predicates []predicate.Connection  `json:"-"`
	Not        *ConnectionWhereInput   `json:"not,omitempty"`
	Or         []*ConnectionWhereInput `json:"or,omitempty"`
	And        []*ConnectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "sync_orders" field predicates.
	SyncOrders    *bool `json:"syncOrders,omitempty"`
	SyncOrdersNEQ *bool `json:"syncOrdersNEQ,omitempty"`

	// "sync_products" field predicates.
	SyncProducts    *bool `json:"syncProducts,omitempty"`
	SyncProductsNEQ *bool `json:"syncProductsNEQ,omitempty"`

	// "fulfill_automatically" field predicates.
	FulfillAutomatically    *bool `json:"fulfillAutomatically,omitempty"`
	FulfillAutomaticallyNEQ *bool `json:"fulfillAutomaticallyNEQ,omitempty"`

	// "dispatch_automatically" field predicates.
	DispatchAutomatically    *bool `json:"dispatchAutomatically,omitempty"`
	DispatchAutomaticallyNEQ *bool `json:"dispatchAutomaticallyNEQ,omitempty"`

	// "convert_currency" field predicates.
	ConvertCurrency    *bool `json:"convertCurrency,omitempty"`
	ConvertCurrencyNEQ *bool `json:"convertCurrencyNEQ,omitempty"`

	// "auto_print_parcel_slip" field predicates.
	AutoPrintParcelSlip    *bool `json:"autoPrintParcelSlip,omitempty"`
	AutoPrintParcelSlipNEQ *bool `json:"autoPrintParcelSlipNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "connection_brand" edge predicates.
	HasConnectionBrand     *bool                        `json:"hasConnectionBrand,omitempty"`
	HasConnectionBrandWith []*ConnectionBrandWhereInput `json:"hasConnectionBrandWith,omitempty"`

	// "connection_shopify" edge predicates.
	HasConnectionShopify     *bool                          `json:"hasConnectionShopify,omitempty"`
	HasConnectionShopifyWith []*ConnectionShopifyWhereInput `json:"hasConnectionShopifyWith,omitempty"`

	// "orders" edge predicates.
	HasOrders     *bool              `json:"hasOrders,omitempty"`
	HasOrdersWith []*OrderWhereInput `json:"hasOrdersWith,omitempty"`

	// "sender_location" edge predicates.
	HasSenderLocation     *bool                 `json:"hasSenderLocation,omitempty"`
	HasSenderLocationWith []*LocationWhereInput `json:"hasSenderLocationWith,omitempty"`

	// "pickup_location" edge predicates.
	HasPickupLocation     *bool                 `json:"hasPickupLocation,omitempty"`
	HasPickupLocationWith []*LocationWhereInput `json:"hasPickupLocationWith,omitempty"`

	// "return_location" edge predicates.
	HasReturnLocation     *bool                 `json:"hasReturnLocation,omitempty"`
	HasReturnLocationWith []*LocationWhereInput `json:"hasReturnLocationWith,omitempty"`

	// "seller_location" edge predicates.
	HasSellerLocation     *bool                 `json:"hasSellerLocation,omitempty"`
	HasSellerLocationWith []*LocationWhereInput `json:"hasSellerLocationWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "default_delivery_option" edge predicates.
	HasDefaultDeliveryOption     *bool                       `json:"hasDefaultDeliveryOption,omitempty"`
	HasDefaultDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDefaultDeliveryOptionWith,omitempty"`

	// "return_portal" edge predicates.
	HasReturnPortal     *bool                     `json:"hasReturnPortal,omitempty"`
	HasReturnPortalWith []*ReturnPortalWhereInput `json:"hasReturnPortalWith,omitempty"`

	// "hypothesis_test" edge predicates.
	HasHypothesisTest     *bool                       `json:"hasHypothesisTest,omitempty"`
	HasHypothesisTestWith []*HypothesisTestWhereInput `json:"hasHypothesisTestWith,omitempty"`

	// "notifications" edge predicates.
	HasNotifications     *bool                     `json:"hasNotifications,omitempty"`
	HasNotificationsWith []*NotificationWhereInput `json:"hasNotificationsWith,omitempty"`

	// "currency" edge predicates.
	HasCurrency     *bool                 `json:"hasCurrency,omitempty"`
	HasCurrencyWith []*CurrencyWhereInput `json:"hasCurrencyWith,omitempty"`

	// "packing_slip_template" edge predicates.
	HasPackingSlipTemplate     *bool                 `json:"hasPackingSlipTemplate,omitempty"`
	HasPackingSlipTemplateWith []*DocumentWhereInput `json:"hasPackingSlipTemplateWith,omitempty"`

	// "connection_lookup" edge predicates.
	HasConnectionLookup     *bool                         `json:"hasConnectionLookup,omitempty"`
	HasConnectionLookupWith []*ConnectionLookupWhereInput `json:"hasConnectionLookupWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ConnectionWhereInput) AddPredicates(predicates ...predicate.Connection) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ConnectionWhereInput filter on the ConnectionQuery builder.
func (i *ConnectionWhereInput) Filter(q *ConnectionQuery) (*ConnectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyConnectionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyConnectionWhereInput is returned in case the ConnectionWhereInput is empty.
var ErrEmptyConnectionWhereInput = errors.New("ent: empty predicate ConnectionWhereInput")

// P returns a predicate for filtering connections.
// An error is returned if the input is empty or invalid.
func (i *ConnectionWhereInput) P() (predicate.Connection, error) {
	var predicates []predicate.Connection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, connection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Connection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, connection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Connection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, connection.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, connection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, connection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, connection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, connection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, connection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, connection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, connection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, connection.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, connection.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, connection.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, connection.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, connection.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, connection.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, connection.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, connection.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, connection.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, connection.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, connection.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, connection.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, connection.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, connection.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, connection.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, connection.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, connection.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, connection.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, connection.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, connection.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, connection.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, connection.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, connection.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, connection.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, connection.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, connection.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, connection.NameContainsFold(*i.NameContainsFold))
	}
	if i.SyncOrders != nil {
		predicates = append(predicates, connection.SyncOrdersEQ(*i.SyncOrders))
	}
	if i.SyncOrdersNEQ != nil {
		predicates = append(predicates, connection.SyncOrdersNEQ(*i.SyncOrdersNEQ))
	}
	if i.SyncProducts != nil {
		predicates = append(predicates, connection.SyncProductsEQ(*i.SyncProducts))
	}
	if i.SyncProductsNEQ != nil {
		predicates = append(predicates, connection.SyncProductsNEQ(*i.SyncProductsNEQ))
	}
	if i.FulfillAutomatically != nil {
		predicates = append(predicates, connection.FulfillAutomaticallyEQ(*i.FulfillAutomatically))
	}
	if i.FulfillAutomaticallyNEQ != nil {
		predicates = append(predicates, connection.FulfillAutomaticallyNEQ(*i.FulfillAutomaticallyNEQ))
	}
	if i.DispatchAutomatically != nil {
		predicates = append(predicates, connection.DispatchAutomaticallyEQ(*i.DispatchAutomatically))
	}
	if i.DispatchAutomaticallyNEQ != nil {
		predicates = append(predicates, connection.DispatchAutomaticallyNEQ(*i.DispatchAutomaticallyNEQ))
	}
	if i.ConvertCurrency != nil {
		predicates = append(predicates, connection.ConvertCurrencyEQ(*i.ConvertCurrency))
	}
	if i.ConvertCurrencyNEQ != nil {
		predicates = append(predicates, connection.ConvertCurrencyNEQ(*i.ConvertCurrencyNEQ))
	}
	if i.AutoPrintParcelSlip != nil {
		predicates = append(predicates, connection.AutoPrintParcelSlipEQ(*i.AutoPrintParcelSlip))
	}
	if i.AutoPrintParcelSlipNEQ != nil {
		predicates = append(predicates, connection.AutoPrintParcelSlipNEQ(*i.AutoPrintParcelSlipNEQ))
	}

	if i.HasTenant != nil {
		p := connection.HasTenant()
		if !*i.HasTenant {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasTenantWith(with...))
	}
	if i.HasConnectionBrand != nil {
		p := connection.HasConnectionBrand()
		if !*i.HasConnectionBrand {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionBrandWith) > 0 {
		with := make([]predicate.ConnectionBrand, 0, len(i.HasConnectionBrandWith))
		for _, w := range i.HasConnectionBrandWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionBrandWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasConnectionBrandWith(with...))
	}
	if i.HasConnectionShopify != nil {
		p := connection.HasConnectionShopify()
		if !*i.HasConnectionShopify {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionShopifyWith) > 0 {
		with := make([]predicate.ConnectionShopify, 0, len(i.HasConnectionShopifyWith))
		for _, w := range i.HasConnectionShopifyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionShopifyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasConnectionShopifyWith(with...))
	}
	if i.HasOrders != nil {
		p := connection.HasOrders()
		if !*i.HasOrders {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrdersWith) > 0 {
		with := make([]predicate.Order, 0, len(i.HasOrdersWith))
		for _, w := range i.HasOrdersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrdersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasOrdersWith(with...))
	}
	if i.HasSenderLocation != nil {
		p := connection.HasSenderLocation()
		if !*i.HasSenderLocation {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSenderLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasSenderLocationWith))
		for _, w := range i.HasSenderLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSenderLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasSenderLocationWith(with...))
	}
	if i.HasPickupLocation != nil {
		p := connection.HasPickupLocation()
		if !*i.HasPickupLocation {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPickupLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasPickupLocationWith))
		for _, w := range i.HasPickupLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPickupLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasPickupLocationWith(with...))
	}
	if i.HasReturnLocation != nil {
		p := connection.HasReturnLocation()
		if !*i.HasReturnLocation {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasReturnLocationWith))
		for _, w := range i.HasReturnLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasReturnLocationWith(with...))
	}
	if i.HasSellerLocation != nil {
		p := connection.HasSellerLocation()
		if !*i.HasSellerLocation {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSellerLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasSellerLocationWith))
		for _, w := range i.HasSellerLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSellerLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasSellerLocationWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := connection.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasDeliveryOptionWith(with...))
	}
	if i.HasDefaultDeliveryOption != nil {
		p := connection.HasDefaultDeliveryOption()
		if !*i.HasDefaultDeliveryOption {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDefaultDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDefaultDeliveryOptionWith))
		for _, w := range i.HasDefaultDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDefaultDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasDefaultDeliveryOptionWith(with...))
	}
	if i.HasReturnPortal != nil {
		p := connection.HasReturnPortal()
		if !*i.HasReturnPortal {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalWith) > 0 {
		with := make([]predicate.ReturnPortal, 0, len(i.HasReturnPortalWith))
		for _, w := range i.HasReturnPortalWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasReturnPortalWith(with...))
	}
	if i.HasHypothesisTest != nil {
		p := connection.HasHypothesisTest()
		if !*i.HasHypothesisTest {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestWith) > 0 {
		with := make([]predicate.HypothesisTest, 0, len(i.HasHypothesisTestWith))
		for _, w := range i.HasHypothesisTestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasHypothesisTestWith(with...))
	}
	if i.HasNotifications != nil {
		p := connection.HasNotifications()
		if !*i.HasNotifications {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotificationsWith) > 0 {
		with := make([]predicate.Notification, 0, len(i.HasNotificationsWith))
		for _, w := range i.HasNotificationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotificationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasNotificationsWith(with...))
	}
	if i.HasCurrency != nil {
		p := connection.HasCurrency()
		if !*i.HasCurrency {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCurrencyWith) > 0 {
		with := make([]predicate.Currency, 0, len(i.HasCurrencyWith))
		for _, w := range i.HasCurrencyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCurrencyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasCurrencyWith(with...))
	}
	if i.HasPackingSlipTemplate != nil {
		p := connection.HasPackingSlipTemplate()
		if !*i.HasPackingSlipTemplate {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackingSlipTemplateWith) > 0 {
		with := make([]predicate.Document, 0, len(i.HasPackingSlipTemplateWith))
		for _, w := range i.HasPackingSlipTemplateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackingSlipTemplateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasPackingSlipTemplateWith(with...))
	}
	if i.HasConnectionLookup != nil {
		p := connection.HasConnectionLookup()
		if !*i.HasConnectionLookup {
			p = connection.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionLookupWith) > 0 {
		with := make([]predicate.ConnectionLookup, 0, len(i.HasConnectionLookupWith))
		for _, w := range i.HasConnectionLookupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionLookupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connection.HasConnectionLookupWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyConnectionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return connection.And(predicates...), nil
	}
}

// ConnectionBrandWhereInput represents a where input for filtering ConnectionBrand queries.
type ConnectionBrandWhereInput struct {
	Predicates []predicate.ConnectionBrand  `json:"-"`
	Not        *ConnectionBrandWhereInput   `json:"not,omitempty"`
	Or         []*ConnectionBrandWhereInput `json:"or,omitempty"`
	And        []*ConnectionBrandWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "internal_id" field predicates.
	InternalID      *connectionbrand.InternalID  `json:"internalID,omitempty"`
	InternalIDNEQ   *connectionbrand.InternalID  `json:"internalIDNEQ,omitempty"`
	InternalIDIn    []connectionbrand.InternalID `json:"internalIDIn,omitempty"`
	InternalIDNotIn []connectionbrand.InternalID `json:"internalIDNotIn,omitempty"`

	// "logo_url" field predicates.
	LogoURL             *string  `json:"logoURL,omitempty"`
	LogoURLNEQ          *string  `json:"logoURLNEQ,omitempty"`
	LogoURLIn           []string `json:"logoURLIn,omitempty"`
	LogoURLNotIn        []string `json:"logoURLNotIn,omitempty"`
	LogoURLGT           *string  `json:"logoURLGT,omitempty"`
	LogoURLGTE          *string  `json:"logoURLGTE,omitempty"`
	LogoURLLT           *string  `json:"logoURLLT,omitempty"`
	LogoURLLTE          *string  `json:"logoURLLTE,omitempty"`
	LogoURLContains     *string  `json:"logoURLContains,omitempty"`
	LogoURLHasPrefix    *string  `json:"logoURLHasPrefix,omitempty"`
	LogoURLHasSuffix    *string  `json:"logoURLHasSuffix,omitempty"`
	LogoURLIsNil        bool     `json:"logoURLIsNil,omitempty"`
	LogoURLNotNil       bool     `json:"logoURLNotNil,omitempty"`
	LogoURLEqualFold    *string  `json:"logoURLEqualFold,omitempty"`
	LogoURLContainsFold *string  `json:"logoURLContainsFold,omitempty"`

	// "connection" edge predicates.
	HasConnection     *bool                   `json:"hasConnection,omitempty"`
	HasConnectionWith []*ConnectionWhereInput `json:"hasConnectionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ConnectionBrandWhereInput) AddPredicates(predicates ...predicate.ConnectionBrand) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ConnectionBrandWhereInput filter on the ConnectionBrandQuery builder.
func (i *ConnectionBrandWhereInput) Filter(q *ConnectionBrandQuery) (*ConnectionBrandQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyConnectionBrandWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyConnectionBrandWhereInput is returned in case the ConnectionBrandWhereInput is empty.
var ErrEmptyConnectionBrandWhereInput = errors.New("ent: empty predicate ConnectionBrandWhereInput")

// P returns a predicate for filtering connectionbrands.
// An error is returned if the input is empty or invalid.
func (i *ConnectionBrandWhereInput) P() (predicate.ConnectionBrand, error) {
	var predicates []predicate.ConnectionBrand
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, connectionbrand.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ConnectionBrand, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, connectionbrand.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ConnectionBrand, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, connectionbrand.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, connectionbrand.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, connectionbrand.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, connectionbrand.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, connectionbrand.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, connectionbrand.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, connectionbrand.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, connectionbrand.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, connectionbrand.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, connectionbrand.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, connectionbrand.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, connectionbrand.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, connectionbrand.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, connectionbrand.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, connectionbrand.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, connectionbrand.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, connectionbrand.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, connectionbrand.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, connectionbrand.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, connectionbrand.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, connectionbrand.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, connectionbrand.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.InternalID != nil {
		predicates = append(predicates, connectionbrand.InternalIDEQ(*i.InternalID))
	}
	if i.InternalIDNEQ != nil {
		predicates = append(predicates, connectionbrand.InternalIDNEQ(*i.InternalIDNEQ))
	}
	if len(i.InternalIDIn) > 0 {
		predicates = append(predicates, connectionbrand.InternalIDIn(i.InternalIDIn...))
	}
	if len(i.InternalIDNotIn) > 0 {
		predicates = append(predicates, connectionbrand.InternalIDNotIn(i.InternalIDNotIn...))
	}
	if i.LogoURL != nil {
		predicates = append(predicates, connectionbrand.LogoURLEQ(*i.LogoURL))
	}
	if i.LogoURLNEQ != nil {
		predicates = append(predicates, connectionbrand.LogoURLNEQ(*i.LogoURLNEQ))
	}
	if len(i.LogoURLIn) > 0 {
		predicates = append(predicates, connectionbrand.LogoURLIn(i.LogoURLIn...))
	}
	if len(i.LogoURLNotIn) > 0 {
		predicates = append(predicates, connectionbrand.LogoURLNotIn(i.LogoURLNotIn...))
	}
	if i.LogoURLGT != nil {
		predicates = append(predicates, connectionbrand.LogoURLGT(*i.LogoURLGT))
	}
	if i.LogoURLGTE != nil {
		predicates = append(predicates, connectionbrand.LogoURLGTE(*i.LogoURLGTE))
	}
	if i.LogoURLLT != nil {
		predicates = append(predicates, connectionbrand.LogoURLLT(*i.LogoURLLT))
	}
	if i.LogoURLLTE != nil {
		predicates = append(predicates, connectionbrand.LogoURLLTE(*i.LogoURLLTE))
	}
	if i.LogoURLContains != nil {
		predicates = append(predicates, connectionbrand.LogoURLContains(*i.LogoURLContains))
	}
	if i.LogoURLHasPrefix != nil {
		predicates = append(predicates, connectionbrand.LogoURLHasPrefix(*i.LogoURLHasPrefix))
	}
	if i.LogoURLHasSuffix != nil {
		predicates = append(predicates, connectionbrand.LogoURLHasSuffix(*i.LogoURLHasSuffix))
	}
	if i.LogoURLIsNil {
		predicates = append(predicates, connectionbrand.LogoURLIsNil())
	}
	if i.LogoURLNotNil {
		predicates = append(predicates, connectionbrand.LogoURLNotNil())
	}
	if i.LogoURLEqualFold != nil {
		predicates = append(predicates, connectionbrand.LogoURLEqualFold(*i.LogoURLEqualFold))
	}
	if i.LogoURLContainsFold != nil {
		predicates = append(predicates, connectionbrand.LogoURLContainsFold(*i.LogoURLContainsFold))
	}

	if i.HasConnection != nil {
		p := connectionbrand.HasConnection()
		if !*i.HasConnection {
			p = connectionbrand.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionWith))
		for _, w := range i.HasConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connectionbrand.HasConnectionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyConnectionBrandWhereInput
	case 1:
		return predicates[0], nil
	default:
		return connectionbrand.And(predicates...), nil
	}
}

// ConnectionLookupWhereInput represents a where input for filtering ConnectionLookup queries.
type ConnectionLookupWhereInput struct {
	Predicates []predicate.ConnectionLookup  `json:"-"`
	Not        *ConnectionLookupWhereInput   `json:"not,omitempty"`
	Or         []*ConnectionLookupWhereInput `json:"or,omitempty"`
	And        []*ConnectionLookupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "payload" field predicates.
	Payload             *string  `json:"payload,omitempty"`
	PayloadNEQ          *string  `json:"payloadNEQ,omitempty"`
	PayloadIn           []string `json:"payloadIn,omitempty"`
	PayloadNotIn        []string `json:"payloadNotIn,omitempty"`
	PayloadGT           *string  `json:"payloadGT,omitempty"`
	PayloadGTE          *string  `json:"payloadGTE,omitempty"`
	PayloadLT           *string  `json:"payloadLT,omitempty"`
	PayloadLTE          *string  `json:"payloadLTE,omitempty"`
	PayloadContains     *string  `json:"payloadContains,omitempty"`
	PayloadHasPrefix    *string  `json:"payloadHasPrefix,omitempty"`
	PayloadHasSuffix    *string  `json:"payloadHasSuffix,omitempty"`
	PayloadEqualFold    *string  `json:"payloadEqualFold,omitempty"`
	PayloadContainsFold *string  `json:"payloadContainsFold,omitempty"`

	// "options_output_count" field predicates.
	OptionsOutputCount      *int  `json:"optionsOutputCount,omitempty"`
	OptionsOutputCountNEQ   *int  `json:"optionsOutputCountNEQ,omitempty"`
	OptionsOutputCountIn    []int `json:"optionsOutputCountIn,omitempty"`
	OptionsOutputCountNotIn []int `json:"optionsOutputCountNotIn,omitempty"`
	OptionsOutputCountGT    *int  `json:"optionsOutputCountGT,omitempty"`
	OptionsOutputCountGTE   *int  `json:"optionsOutputCountGTE,omitempty"`
	OptionsOutputCountLT    *int  `json:"optionsOutputCountLT,omitempty"`
	OptionsOutputCountLTE   *int  `json:"optionsOutputCountLTE,omitempty"`

	// "error" field predicates.
	Error             *string  `json:"error,omitempty"`
	ErrorNEQ          *string  `json:"errorNEQ,omitempty"`
	ErrorIn           []string `json:"errorIn,omitempty"`
	ErrorNotIn        []string `json:"errorNotIn,omitempty"`
	ErrorGT           *string  `json:"errorGT,omitempty"`
	ErrorGTE          *string  `json:"errorGTE,omitempty"`
	ErrorLT           *string  `json:"errorLT,omitempty"`
	ErrorLTE          *string  `json:"errorLTE,omitempty"`
	ErrorContains     *string  `json:"errorContains,omitempty"`
	ErrorHasPrefix    *string  `json:"errorHasPrefix,omitempty"`
	ErrorHasSuffix    *string  `json:"errorHasSuffix,omitempty"`
	ErrorIsNil        bool     `json:"errorIsNil,omitempty"`
	ErrorNotNil       bool     `json:"errorNotNil,omitempty"`
	ErrorEqualFold    *string  `json:"errorEqualFold,omitempty"`
	ErrorContainsFold *string  `json:"errorContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "connections" edge predicates.
	HasConnections     *bool                   `json:"hasConnections,omitempty"`
	HasConnectionsWith []*ConnectionWhereInput `json:"hasConnectionsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ConnectionLookupWhereInput) AddPredicates(predicates ...predicate.ConnectionLookup) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ConnectionLookupWhereInput filter on the ConnectionLookupQuery builder.
func (i *ConnectionLookupWhereInput) Filter(q *ConnectionLookupQuery) (*ConnectionLookupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyConnectionLookupWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyConnectionLookupWhereInput is returned in case the ConnectionLookupWhereInput is empty.
var ErrEmptyConnectionLookupWhereInput = errors.New("ent: empty predicate ConnectionLookupWhereInput")

// P returns a predicate for filtering connectionlookups.
// An error is returned if the input is empty or invalid.
func (i *ConnectionLookupWhereInput) P() (predicate.ConnectionLookup, error) {
	var predicates []predicate.ConnectionLookup
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, connectionlookup.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ConnectionLookup, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, connectionlookup.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ConnectionLookup, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, connectionlookup.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, connectionlookup.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, connectionlookup.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, connectionlookup.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, connectionlookup.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, connectionlookup.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, connectionlookup.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, connectionlookup.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, connectionlookup.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, connectionlookup.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, connectionlookup.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, connectionlookup.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, connectionlookup.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, connectionlookup.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, connectionlookup.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, connectionlookup.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, connectionlookup.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, connectionlookup.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, connectionlookup.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, connectionlookup.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, connectionlookup.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, connectionlookup.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Payload != nil {
		predicates = append(predicates, connectionlookup.PayloadEQ(*i.Payload))
	}
	if i.PayloadNEQ != nil {
		predicates = append(predicates, connectionlookup.PayloadNEQ(*i.PayloadNEQ))
	}
	if len(i.PayloadIn) > 0 {
		predicates = append(predicates, connectionlookup.PayloadIn(i.PayloadIn...))
	}
	if len(i.PayloadNotIn) > 0 {
		predicates = append(predicates, connectionlookup.PayloadNotIn(i.PayloadNotIn...))
	}
	if i.PayloadGT != nil {
		predicates = append(predicates, connectionlookup.PayloadGT(*i.PayloadGT))
	}
	if i.PayloadGTE != nil {
		predicates = append(predicates, connectionlookup.PayloadGTE(*i.PayloadGTE))
	}
	if i.PayloadLT != nil {
		predicates = append(predicates, connectionlookup.PayloadLT(*i.PayloadLT))
	}
	if i.PayloadLTE != nil {
		predicates = append(predicates, connectionlookup.PayloadLTE(*i.PayloadLTE))
	}
	if i.PayloadContains != nil {
		predicates = append(predicates, connectionlookup.PayloadContains(*i.PayloadContains))
	}
	if i.PayloadHasPrefix != nil {
		predicates = append(predicates, connectionlookup.PayloadHasPrefix(*i.PayloadHasPrefix))
	}
	if i.PayloadHasSuffix != nil {
		predicates = append(predicates, connectionlookup.PayloadHasSuffix(*i.PayloadHasSuffix))
	}
	if i.PayloadEqualFold != nil {
		predicates = append(predicates, connectionlookup.PayloadEqualFold(*i.PayloadEqualFold))
	}
	if i.PayloadContainsFold != nil {
		predicates = append(predicates, connectionlookup.PayloadContainsFold(*i.PayloadContainsFold))
	}
	if i.OptionsOutputCount != nil {
		predicates = append(predicates, connectionlookup.OptionsOutputCountEQ(*i.OptionsOutputCount))
	}
	if i.OptionsOutputCountNEQ != nil {
		predicates = append(predicates, connectionlookup.OptionsOutputCountNEQ(*i.OptionsOutputCountNEQ))
	}
	if len(i.OptionsOutputCountIn) > 0 {
		predicates = append(predicates, connectionlookup.OptionsOutputCountIn(i.OptionsOutputCountIn...))
	}
	if len(i.OptionsOutputCountNotIn) > 0 {
		predicates = append(predicates, connectionlookup.OptionsOutputCountNotIn(i.OptionsOutputCountNotIn...))
	}
	if i.OptionsOutputCountGT != nil {
		predicates = append(predicates, connectionlookup.OptionsOutputCountGT(*i.OptionsOutputCountGT))
	}
	if i.OptionsOutputCountGTE != nil {
		predicates = append(predicates, connectionlookup.OptionsOutputCountGTE(*i.OptionsOutputCountGTE))
	}
	if i.OptionsOutputCountLT != nil {
		predicates = append(predicates, connectionlookup.OptionsOutputCountLT(*i.OptionsOutputCountLT))
	}
	if i.OptionsOutputCountLTE != nil {
		predicates = append(predicates, connectionlookup.OptionsOutputCountLTE(*i.OptionsOutputCountLTE))
	}
	if i.Error != nil {
		predicates = append(predicates, connectionlookup.ErrorEQ(*i.Error))
	}
	if i.ErrorNEQ != nil {
		predicates = append(predicates, connectionlookup.ErrorNEQ(*i.ErrorNEQ))
	}
	if len(i.ErrorIn) > 0 {
		predicates = append(predicates, connectionlookup.ErrorIn(i.ErrorIn...))
	}
	if len(i.ErrorNotIn) > 0 {
		predicates = append(predicates, connectionlookup.ErrorNotIn(i.ErrorNotIn...))
	}
	if i.ErrorGT != nil {
		predicates = append(predicates, connectionlookup.ErrorGT(*i.ErrorGT))
	}
	if i.ErrorGTE != nil {
		predicates = append(predicates, connectionlookup.ErrorGTE(*i.ErrorGTE))
	}
	if i.ErrorLT != nil {
		predicates = append(predicates, connectionlookup.ErrorLT(*i.ErrorLT))
	}
	if i.ErrorLTE != nil {
		predicates = append(predicates, connectionlookup.ErrorLTE(*i.ErrorLTE))
	}
	if i.ErrorContains != nil {
		predicates = append(predicates, connectionlookup.ErrorContains(*i.ErrorContains))
	}
	if i.ErrorHasPrefix != nil {
		predicates = append(predicates, connectionlookup.ErrorHasPrefix(*i.ErrorHasPrefix))
	}
	if i.ErrorHasSuffix != nil {
		predicates = append(predicates, connectionlookup.ErrorHasSuffix(*i.ErrorHasSuffix))
	}
	if i.ErrorIsNil {
		predicates = append(predicates, connectionlookup.ErrorIsNil())
	}
	if i.ErrorNotNil {
		predicates = append(predicates, connectionlookup.ErrorNotNil())
	}
	if i.ErrorEqualFold != nil {
		predicates = append(predicates, connectionlookup.ErrorEqualFold(*i.ErrorEqualFold))
	}
	if i.ErrorContainsFold != nil {
		predicates = append(predicates, connectionlookup.ErrorContainsFold(*i.ErrorContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, connectionlookup.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, connectionlookup.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, connectionlookup.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, connectionlookup.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, connectionlookup.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, connectionlookup.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, connectionlookup.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, connectionlookup.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasTenant != nil {
		p := connectionlookup.HasTenant()
		if !*i.HasTenant {
			p = connectionlookup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connectionlookup.HasTenantWith(with...))
	}
	if i.HasConnections != nil {
		p := connectionlookup.HasConnections()
		if !*i.HasConnections {
			p = connectionlookup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionsWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionsWith))
		for _, w := range i.HasConnectionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connectionlookup.HasConnectionsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyConnectionLookupWhereInput
	case 1:
		return predicates[0], nil
	default:
		return connectionlookup.And(predicates...), nil
	}
}

// ConnectionShopifyWhereInput represents a where input for filtering ConnectionShopify queries.
type ConnectionShopifyWhereInput struct {
	Predicates []predicate.ConnectionShopify  `json:"-"`
	Not        *ConnectionShopifyWhereInput   `json:"not,omitempty"`
	Or         []*ConnectionShopifyWhereInput `json:"or,omitempty"`
	And        []*ConnectionShopifyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "rate_integration" field predicates.
	RateIntegration    *bool `json:"rateIntegration,omitempty"`
	RateIntegrationNEQ *bool `json:"rateIntegrationNEQ,omitempty"`

	// "store_url" field predicates.
	StoreURL             *string  `json:"storeURL,omitempty"`
	StoreURLNEQ          *string  `json:"storeURLNEQ,omitempty"`
	StoreURLIn           []string `json:"storeURLIn,omitempty"`
	StoreURLNotIn        []string `json:"storeURLNotIn,omitempty"`
	StoreURLGT           *string  `json:"storeURLGT,omitempty"`
	StoreURLGTE          *string  `json:"storeURLGTE,omitempty"`
	StoreURLLT           *string  `json:"storeURLLT,omitempty"`
	StoreURLLTE          *string  `json:"storeURLLTE,omitempty"`
	StoreURLContains     *string  `json:"storeURLContains,omitempty"`
	StoreURLHasPrefix    *string  `json:"storeURLHasPrefix,omitempty"`
	StoreURLHasSuffix    *string  `json:"storeURLHasSuffix,omitempty"`
	StoreURLIsNil        bool     `json:"storeURLIsNil,omitempty"`
	StoreURLNotNil       bool     `json:"storeURLNotNil,omitempty"`
	StoreURLEqualFold    *string  `json:"storeURLEqualFold,omitempty"`
	StoreURLContainsFold *string  `json:"storeURLContainsFold,omitempty"`

	// "api_key" field predicates.
	APIKey             *string  `json:"apiKey,omitempty"`
	APIKeyNEQ          *string  `json:"apiKeyNEQ,omitempty"`
	APIKeyIn           []string `json:"apiKeyIn,omitempty"`
	APIKeyNotIn        []string `json:"apiKeyNotIn,omitempty"`
	APIKeyGT           *string  `json:"apiKeyGT,omitempty"`
	APIKeyGTE          *string  `json:"apiKeyGTE,omitempty"`
	APIKeyLT           *string  `json:"apiKeyLT,omitempty"`
	APIKeyLTE          *string  `json:"apiKeyLTE,omitempty"`
	APIKeyContains     *string  `json:"apiKeyContains,omitempty"`
	APIKeyHasPrefix    *string  `json:"apiKeyHasPrefix,omitempty"`
	APIKeyHasSuffix    *string  `json:"apiKeyHasSuffix,omitempty"`
	APIKeyIsNil        bool     `json:"apiKeyIsNil,omitempty"`
	APIKeyNotNil       bool     `json:"apiKeyNotNil,omitempty"`
	APIKeyEqualFold    *string  `json:"apiKeyEqualFold,omitempty"`
	APIKeyContainsFold *string  `json:"apiKeyContainsFold,omitempty"`

	// "lookup_key" field predicates.
	LookupKey             *string  `json:"lookupKey,omitempty"`
	LookupKeyNEQ          *string  `json:"lookupKeyNEQ,omitempty"`
	LookupKeyIn           []string `json:"lookupKeyIn,omitempty"`
	LookupKeyNotIn        []string `json:"lookupKeyNotIn,omitempty"`
	LookupKeyGT           *string  `json:"lookupKeyGT,omitempty"`
	LookupKeyGTE          *string  `json:"lookupKeyGTE,omitempty"`
	LookupKeyLT           *string  `json:"lookupKeyLT,omitempty"`
	LookupKeyLTE          *string  `json:"lookupKeyLTE,omitempty"`
	LookupKeyContains     *string  `json:"lookupKeyContains,omitempty"`
	LookupKeyHasPrefix    *string  `json:"lookupKeyHasPrefix,omitempty"`
	LookupKeyHasSuffix    *string  `json:"lookupKeyHasSuffix,omitempty"`
	LookupKeyIsNil        bool     `json:"lookupKeyIsNil,omitempty"`
	LookupKeyNotNil       bool     `json:"lookupKeyNotNil,omitempty"`
	LookupKeyEqualFold    *string  `json:"lookupKeyEqualFold,omitempty"`
	LookupKeyContainsFold *string  `json:"lookupKeyContainsFold,omitempty"`

	// "sync_from" field predicates.
	SyncFrom       *time.Time  `json:"syncFrom,omitempty"`
	SyncFromNEQ    *time.Time  `json:"syncFromNEQ,omitempty"`
	SyncFromIn     []time.Time `json:"syncFromIn,omitempty"`
	SyncFromNotIn  []time.Time `json:"syncFromNotIn,omitempty"`
	SyncFromGT     *time.Time  `json:"syncFromGT,omitempty"`
	SyncFromGTE    *time.Time  `json:"syncFromGTE,omitempty"`
	SyncFromLT     *time.Time  `json:"syncFromLT,omitempty"`
	SyncFromLTE    *time.Time  `json:"syncFromLTE,omitempty"`
	SyncFromIsNil  bool        `json:"syncFromIsNil,omitempty"`
	SyncFromNotNil bool        `json:"syncFromNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "connection" edge predicates.
	HasConnection     *bool                   `json:"hasConnection,omitempty"`
	HasConnectionWith []*ConnectionWhereInput `json:"hasConnectionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ConnectionShopifyWhereInput) AddPredicates(predicates ...predicate.ConnectionShopify) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ConnectionShopifyWhereInput filter on the ConnectionShopifyQuery builder.
func (i *ConnectionShopifyWhereInput) Filter(q *ConnectionShopifyQuery) (*ConnectionShopifyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyConnectionShopifyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyConnectionShopifyWhereInput is returned in case the ConnectionShopifyWhereInput is empty.
var ErrEmptyConnectionShopifyWhereInput = errors.New("ent: empty predicate ConnectionShopifyWhereInput")

// P returns a predicate for filtering connectionshopifies.
// An error is returned if the input is empty or invalid.
func (i *ConnectionShopifyWhereInput) P() (predicate.ConnectionShopify, error) {
	var predicates []predicate.ConnectionShopify
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, connectionshopify.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ConnectionShopify, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, connectionshopify.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ConnectionShopify, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, connectionshopify.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, connectionshopify.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, connectionshopify.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, connectionshopify.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, connectionshopify.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, connectionshopify.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, connectionshopify.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, connectionshopify.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, connectionshopify.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, connectionshopify.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, connectionshopify.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, connectionshopify.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, connectionshopify.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, connectionshopify.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, connectionshopify.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, connectionshopify.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, connectionshopify.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, connectionshopify.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, connectionshopify.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, connectionshopify.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, connectionshopify.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, connectionshopify.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.RateIntegration != nil {
		predicates = append(predicates, connectionshopify.RateIntegrationEQ(*i.RateIntegration))
	}
	if i.RateIntegrationNEQ != nil {
		predicates = append(predicates, connectionshopify.RateIntegrationNEQ(*i.RateIntegrationNEQ))
	}
	if i.StoreURL != nil {
		predicates = append(predicates, connectionshopify.StoreURLEQ(*i.StoreURL))
	}
	if i.StoreURLNEQ != nil {
		predicates = append(predicates, connectionshopify.StoreURLNEQ(*i.StoreURLNEQ))
	}
	if len(i.StoreURLIn) > 0 {
		predicates = append(predicates, connectionshopify.StoreURLIn(i.StoreURLIn...))
	}
	if len(i.StoreURLNotIn) > 0 {
		predicates = append(predicates, connectionshopify.StoreURLNotIn(i.StoreURLNotIn...))
	}
	if i.StoreURLGT != nil {
		predicates = append(predicates, connectionshopify.StoreURLGT(*i.StoreURLGT))
	}
	if i.StoreURLGTE != nil {
		predicates = append(predicates, connectionshopify.StoreURLGTE(*i.StoreURLGTE))
	}
	if i.StoreURLLT != nil {
		predicates = append(predicates, connectionshopify.StoreURLLT(*i.StoreURLLT))
	}
	if i.StoreURLLTE != nil {
		predicates = append(predicates, connectionshopify.StoreURLLTE(*i.StoreURLLTE))
	}
	if i.StoreURLContains != nil {
		predicates = append(predicates, connectionshopify.StoreURLContains(*i.StoreURLContains))
	}
	if i.StoreURLHasPrefix != nil {
		predicates = append(predicates, connectionshopify.StoreURLHasPrefix(*i.StoreURLHasPrefix))
	}
	if i.StoreURLHasSuffix != nil {
		predicates = append(predicates, connectionshopify.StoreURLHasSuffix(*i.StoreURLHasSuffix))
	}
	if i.StoreURLIsNil {
		predicates = append(predicates, connectionshopify.StoreURLIsNil())
	}
	if i.StoreURLNotNil {
		predicates = append(predicates, connectionshopify.StoreURLNotNil())
	}
	if i.StoreURLEqualFold != nil {
		predicates = append(predicates, connectionshopify.StoreURLEqualFold(*i.StoreURLEqualFold))
	}
	if i.StoreURLContainsFold != nil {
		predicates = append(predicates, connectionshopify.StoreURLContainsFold(*i.StoreURLContainsFold))
	}
	if i.APIKey != nil {
		predicates = append(predicates, connectionshopify.APIKeyEQ(*i.APIKey))
	}
	if i.APIKeyNEQ != nil {
		predicates = append(predicates, connectionshopify.APIKeyNEQ(*i.APIKeyNEQ))
	}
	if len(i.APIKeyIn) > 0 {
		predicates = append(predicates, connectionshopify.APIKeyIn(i.APIKeyIn...))
	}
	if len(i.APIKeyNotIn) > 0 {
		predicates = append(predicates, connectionshopify.APIKeyNotIn(i.APIKeyNotIn...))
	}
	if i.APIKeyGT != nil {
		predicates = append(predicates, connectionshopify.APIKeyGT(*i.APIKeyGT))
	}
	if i.APIKeyGTE != nil {
		predicates = append(predicates, connectionshopify.APIKeyGTE(*i.APIKeyGTE))
	}
	if i.APIKeyLT != nil {
		predicates = append(predicates, connectionshopify.APIKeyLT(*i.APIKeyLT))
	}
	if i.APIKeyLTE != nil {
		predicates = append(predicates, connectionshopify.APIKeyLTE(*i.APIKeyLTE))
	}
	if i.APIKeyContains != nil {
		predicates = append(predicates, connectionshopify.APIKeyContains(*i.APIKeyContains))
	}
	if i.APIKeyHasPrefix != nil {
		predicates = append(predicates, connectionshopify.APIKeyHasPrefix(*i.APIKeyHasPrefix))
	}
	if i.APIKeyHasSuffix != nil {
		predicates = append(predicates, connectionshopify.APIKeyHasSuffix(*i.APIKeyHasSuffix))
	}
	if i.APIKeyIsNil {
		predicates = append(predicates, connectionshopify.APIKeyIsNil())
	}
	if i.APIKeyNotNil {
		predicates = append(predicates, connectionshopify.APIKeyNotNil())
	}
	if i.APIKeyEqualFold != nil {
		predicates = append(predicates, connectionshopify.APIKeyEqualFold(*i.APIKeyEqualFold))
	}
	if i.APIKeyContainsFold != nil {
		predicates = append(predicates, connectionshopify.APIKeyContainsFold(*i.APIKeyContainsFold))
	}
	if i.LookupKey != nil {
		predicates = append(predicates, connectionshopify.LookupKeyEQ(*i.LookupKey))
	}
	if i.LookupKeyNEQ != nil {
		predicates = append(predicates, connectionshopify.LookupKeyNEQ(*i.LookupKeyNEQ))
	}
	if len(i.LookupKeyIn) > 0 {
		predicates = append(predicates, connectionshopify.LookupKeyIn(i.LookupKeyIn...))
	}
	if len(i.LookupKeyNotIn) > 0 {
		predicates = append(predicates, connectionshopify.LookupKeyNotIn(i.LookupKeyNotIn...))
	}
	if i.LookupKeyGT != nil {
		predicates = append(predicates, connectionshopify.LookupKeyGT(*i.LookupKeyGT))
	}
	if i.LookupKeyGTE != nil {
		predicates = append(predicates, connectionshopify.LookupKeyGTE(*i.LookupKeyGTE))
	}
	if i.LookupKeyLT != nil {
		predicates = append(predicates, connectionshopify.LookupKeyLT(*i.LookupKeyLT))
	}
	if i.LookupKeyLTE != nil {
		predicates = append(predicates, connectionshopify.LookupKeyLTE(*i.LookupKeyLTE))
	}
	if i.LookupKeyContains != nil {
		predicates = append(predicates, connectionshopify.LookupKeyContains(*i.LookupKeyContains))
	}
	if i.LookupKeyHasPrefix != nil {
		predicates = append(predicates, connectionshopify.LookupKeyHasPrefix(*i.LookupKeyHasPrefix))
	}
	if i.LookupKeyHasSuffix != nil {
		predicates = append(predicates, connectionshopify.LookupKeyHasSuffix(*i.LookupKeyHasSuffix))
	}
	if i.LookupKeyIsNil {
		predicates = append(predicates, connectionshopify.LookupKeyIsNil())
	}
	if i.LookupKeyNotNil {
		predicates = append(predicates, connectionshopify.LookupKeyNotNil())
	}
	if i.LookupKeyEqualFold != nil {
		predicates = append(predicates, connectionshopify.LookupKeyEqualFold(*i.LookupKeyEqualFold))
	}
	if i.LookupKeyContainsFold != nil {
		predicates = append(predicates, connectionshopify.LookupKeyContainsFold(*i.LookupKeyContainsFold))
	}
	if i.SyncFrom != nil {
		predicates = append(predicates, connectionshopify.SyncFromEQ(*i.SyncFrom))
	}
	if i.SyncFromNEQ != nil {
		predicates = append(predicates, connectionshopify.SyncFromNEQ(*i.SyncFromNEQ))
	}
	if len(i.SyncFromIn) > 0 {
		predicates = append(predicates, connectionshopify.SyncFromIn(i.SyncFromIn...))
	}
	if len(i.SyncFromNotIn) > 0 {
		predicates = append(predicates, connectionshopify.SyncFromNotIn(i.SyncFromNotIn...))
	}
	if i.SyncFromGT != nil {
		predicates = append(predicates, connectionshopify.SyncFromGT(*i.SyncFromGT))
	}
	if i.SyncFromGTE != nil {
		predicates = append(predicates, connectionshopify.SyncFromGTE(*i.SyncFromGTE))
	}
	if i.SyncFromLT != nil {
		predicates = append(predicates, connectionshopify.SyncFromLT(*i.SyncFromLT))
	}
	if i.SyncFromLTE != nil {
		predicates = append(predicates, connectionshopify.SyncFromLTE(*i.SyncFromLTE))
	}
	if i.SyncFromIsNil {
		predicates = append(predicates, connectionshopify.SyncFromIsNil())
	}
	if i.SyncFromNotNil {
		predicates = append(predicates, connectionshopify.SyncFromNotNil())
	}

	if i.HasTenant != nil {
		p := connectionshopify.HasTenant()
		if !*i.HasTenant {
			p = connectionshopify.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connectionshopify.HasTenantWith(with...))
	}
	if i.HasConnection != nil {
		p := connectionshopify.HasConnection()
		if !*i.HasConnection {
			p = connectionshopify.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionWith))
		for _, w := range i.HasConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, connectionshopify.HasConnectionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyConnectionShopifyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return connectionshopify.And(predicates...), nil
	}
}

// ConsolidationWhereInput represents a where input for filtering Consolidation queries.
type ConsolidationWhereInput struct {
	Predicates []predicate.Consolidation  `json:"-"`
	Not        *ConsolidationWhereInput   `json:"not,omitempty"`
	Or         []*ConsolidationWhereInput `json:"or,omitempty"`
	And        []*ConsolidationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "public_id" field predicates.
	PublicID             *string  `json:"publicID,omitempty"`
	PublicIDNEQ          *string  `json:"publicIDNEQ,omitempty"`
	PublicIDIn           []string `json:"publicIDIn,omitempty"`
	PublicIDNotIn        []string `json:"publicIDNotIn,omitempty"`
	PublicIDGT           *string  `json:"publicIDGT,omitempty"`
	PublicIDGTE          *string  `json:"publicIDGTE,omitempty"`
	PublicIDLT           *string  `json:"publicIDLT,omitempty"`
	PublicIDLTE          *string  `json:"publicIDLTE,omitempty"`
	PublicIDContains     *string  `json:"publicIDContains,omitempty"`
	PublicIDHasPrefix    *string  `json:"publicIDHasPrefix,omitempty"`
	PublicIDHasSuffix    *string  `json:"publicIDHasSuffix,omitempty"`
	PublicIDEqualFold    *string  `json:"publicIDEqualFold,omitempty"`
	PublicIDContainsFold *string  `json:"publicIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "status" field predicates.
	Status      *consolidation.Status  `json:"status,omitempty"`
	StatusNEQ   *consolidation.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []consolidation.Status `json:"statusIn,omitempty"`
	StatusNotIn []consolidation.Status `json:"statusNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "pallets" edge predicates.
	HasPallets     *bool               `json:"hasPallets,omitempty"`
	HasPalletsWith []*PalletWhereInput `json:"hasPalletsWith,omitempty"`

	// "orders" edge predicates.
	HasOrders     *bool              `json:"hasOrders,omitempty"`
	HasOrdersWith []*OrderWhereInput `json:"hasOrdersWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "recipient" edge predicates.
	HasRecipient     *bool                `json:"hasRecipient,omitempty"`
	HasRecipientWith []*AddressWhereInput `json:"hasRecipientWith,omitempty"`

	// "sender" edge predicates.
	HasSender     *bool                `json:"hasSender,omitempty"`
	HasSenderWith []*AddressWhereInput `json:"hasSenderWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`

	// "cancelled_shipments" edge predicates.
	HasCancelledShipments     *bool                 `json:"hasCancelledShipments,omitempty"`
	HasCancelledShipmentsWith []*ShipmentWhereInput `json:"hasCancelledShipmentsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ConsolidationWhereInput) AddPredicates(predicates ...predicate.Consolidation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ConsolidationWhereInput filter on the ConsolidationQuery builder.
func (i *ConsolidationWhereInput) Filter(q *ConsolidationQuery) (*ConsolidationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyConsolidationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyConsolidationWhereInput is returned in case the ConsolidationWhereInput is empty.
var ErrEmptyConsolidationWhereInput = errors.New("ent: empty predicate ConsolidationWhereInput")

// P returns a predicate for filtering consolidations.
// An error is returned if the input is empty or invalid.
func (i *ConsolidationWhereInput) P() (predicate.Consolidation, error) {
	var predicates []predicate.Consolidation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, consolidation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Consolidation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, consolidation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Consolidation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, consolidation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, consolidation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, consolidation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, consolidation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, consolidation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, consolidation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, consolidation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, consolidation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, consolidation.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, consolidation.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, consolidation.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, consolidation.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, consolidation.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, consolidation.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, consolidation.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, consolidation.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, consolidation.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, consolidation.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, consolidation.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, consolidation.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, consolidation.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, consolidation.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.PublicID != nil {
		predicates = append(predicates, consolidation.PublicIDEQ(*i.PublicID))
	}
	if i.PublicIDNEQ != nil {
		predicates = append(predicates, consolidation.PublicIDNEQ(*i.PublicIDNEQ))
	}
	if len(i.PublicIDIn) > 0 {
		predicates = append(predicates, consolidation.PublicIDIn(i.PublicIDIn...))
	}
	if len(i.PublicIDNotIn) > 0 {
		predicates = append(predicates, consolidation.PublicIDNotIn(i.PublicIDNotIn...))
	}
	if i.PublicIDGT != nil {
		predicates = append(predicates, consolidation.PublicIDGT(*i.PublicIDGT))
	}
	if i.PublicIDGTE != nil {
		predicates = append(predicates, consolidation.PublicIDGTE(*i.PublicIDGTE))
	}
	if i.PublicIDLT != nil {
		predicates = append(predicates, consolidation.PublicIDLT(*i.PublicIDLT))
	}
	if i.PublicIDLTE != nil {
		predicates = append(predicates, consolidation.PublicIDLTE(*i.PublicIDLTE))
	}
	if i.PublicIDContains != nil {
		predicates = append(predicates, consolidation.PublicIDContains(*i.PublicIDContains))
	}
	if i.PublicIDHasPrefix != nil {
		predicates = append(predicates, consolidation.PublicIDHasPrefix(*i.PublicIDHasPrefix))
	}
	if i.PublicIDHasSuffix != nil {
		predicates = append(predicates, consolidation.PublicIDHasSuffix(*i.PublicIDHasSuffix))
	}
	if i.PublicIDEqualFold != nil {
		predicates = append(predicates, consolidation.PublicIDEqualFold(*i.PublicIDEqualFold))
	}
	if i.PublicIDContainsFold != nil {
		predicates = append(predicates, consolidation.PublicIDContainsFold(*i.PublicIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, consolidation.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, consolidation.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, consolidation.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, consolidation.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, consolidation.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, consolidation.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, consolidation.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, consolidation.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, consolidation.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, consolidation.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, consolidation.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, consolidation.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, consolidation.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, consolidation.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, consolidation.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, consolidation.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, consolidation.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, consolidation.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, consolidation.StatusNotIn(i.StatusNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, consolidation.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, consolidation.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, consolidation.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, consolidation.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, consolidation.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, consolidation.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, consolidation.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, consolidation.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, consolidation.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, consolidation.CreatedAtNotNil())
	}

	if i.HasTenant != nil {
		p := consolidation.HasTenant()
		if !*i.HasTenant {
			p = consolidation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, consolidation.HasTenantWith(with...))
	}
	if i.HasPallets != nil {
		p := consolidation.HasPallets()
		if !*i.HasPallets {
			p = consolidation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPalletsWith) > 0 {
		with := make([]predicate.Pallet, 0, len(i.HasPalletsWith))
		for _, w := range i.HasPalletsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPalletsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, consolidation.HasPalletsWith(with...))
	}
	if i.HasOrders != nil {
		p := consolidation.HasOrders()
		if !*i.HasOrders {
			p = consolidation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrdersWith) > 0 {
		with := make([]predicate.Order, 0, len(i.HasOrdersWith))
		for _, w := range i.HasOrdersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrdersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, consolidation.HasOrdersWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := consolidation.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = consolidation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, consolidation.HasDeliveryOptionWith(with...))
	}
	if i.HasRecipient != nil {
		p := consolidation.HasRecipient()
		if !*i.HasRecipient {
			p = consolidation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRecipientWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasRecipientWith))
		for _, w := range i.HasRecipientWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRecipientWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, consolidation.HasRecipientWith(with...))
	}
	if i.HasSender != nil {
		p := consolidation.HasSender()
		if !*i.HasSender {
			p = consolidation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSenderWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasSenderWith))
		for _, w := range i.HasSenderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSenderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, consolidation.HasSenderWith(with...))
	}
	if i.HasShipment != nil {
		p := consolidation.HasShipment()
		if !*i.HasShipment {
			p = consolidation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, consolidation.HasShipmentWith(with...))
	}
	if i.HasCancelledShipments != nil {
		p := consolidation.HasCancelledShipments()
		if !*i.HasCancelledShipments {
			p = consolidation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCancelledShipmentsWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasCancelledShipmentsWith))
		for _, w := range i.HasCancelledShipmentsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCancelledShipmentsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, consolidation.HasCancelledShipmentsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyConsolidationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return consolidation.And(predicates...), nil
	}
}

// ContactWhereInput represents a where input for filtering Contact queries.
type ContactWhereInput struct {
	Predicates []predicate.Contact  `json:"-"`
	Not        *ContactWhereInput   `json:"not,omitempty"`
	Or         []*ContactWhereInput `json:"or,omitempty"`
	And        []*ContactWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "surname" field predicates.
	Surname             *string  `json:"surname,omitempty"`
	SurnameNEQ          *string  `json:"surnameNEQ,omitempty"`
	SurnameIn           []string `json:"surnameIn,omitempty"`
	SurnameNotIn        []string `json:"surnameNotIn,omitempty"`
	SurnameGT           *string  `json:"surnameGT,omitempty"`
	SurnameGTE          *string  `json:"surnameGTE,omitempty"`
	SurnameLT           *string  `json:"surnameLT,omitempty"`
	SurnameLTE          *string  `json:"surnameLTE,omitempty"`
	SurnameContains     *string  `json:"surnameContains,omitempty"`
	SurnameHasPrefix    *string  `json:"surnameHasPrefix,omitempty"`
	SurnameHasSuffix    *string  `json:"surnameHasSuffix,omitempty"`
	SurnameEqualFold    *string  `json:"surnameEqualFold,omitempty"`
	SurnameContainsFold *string  `json:"surnameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "billing_contact" edge predicates.
	HasBillingContact     *bool               `json:"hasBillingContact,omitempty"`
	HasBillingContactWith []*TenantWhereInput `json:"hasBillingContactWith,omitempty"`

	// "admin_contact" edge predicates.
	HasAdminContact     *bool               `json:"hasAdminContact,omitempty"`
	HasAdminContactWith []*TenantWhereInput `json:"hasAdminContactWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ContactWhereInput) AddPredicates(predicates ...predicate.Contact) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ContactWhereInput filter on the ContactQuery builder.
func (i *ContactWhereInput) Filter(q *ContactQuery) (*ContactQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyContactWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyContactWhereInput is returned in case the ContactWhereInput is empty.
var ErrEmptyContactWhereInput = errors.New("ent: empty predicate ContactWhereInput")

// P returns a predicate for filtering contacts.
// An error is returned if the input is empty or invalid.
func (i *ContactWhereInput) P() (predicate.Contact, error) {
	var predicates []predicate.Contact
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, contact.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Contact, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, contact.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Contact, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, contact.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, contact.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, contact.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, contact.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, contact.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, contact.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, contact.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, contact.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, contact.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, contact.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, contact.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, contact.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, contact.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, contact.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, contact.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, contact.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, contact.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, contact.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, contact.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, contact.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, contact.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, contact.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, contact.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, contact.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, contact.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, contact.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, contact.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, contact.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, contact.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, contact.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, contact.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, contact.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, contact.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, contact.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, contact.NameContainsFold(*i.NameContainsFold))
	}
	if i.Surname != nil {
		predicates = append(predicates, contact.SurnameEQ(*i.Surname))
	}
	if i.SurnameNEQ != nil {
		predicates = append(predicates, contact.SurnameNEQ(*i.SurnameNEQ))
	}
	if len(i.SurnameIn) > 0 {
		predicates = append(predicates, contact.SurnameIn(i.SurnameIn...))
	}
	if len(i.SurnameNotIn) > 0 {
		predicates = append(predicates, contact.SurnameNotIn(i.SurnameNotIn...))
	}
	if i.SurnameGT != nil {
		predicates = append(predicates, contact.SurnameGT(*i.SurnameGT))
	}
	if i.SurnameGTE != nil {
		predicates = append(predicates, contact.SurnameGTE(*i.SurnameGTE))
	}
	if i.SurnameLT != nil {
		predicates = append(predicates, contact.SurnameLT(*i.SurnameLT))
	}
	if i.SurnameLTE != nil {
		predicates = append(predicates, contact.SurnameLTE(*i.SurnameLTE))
	}
	if i.SurnameContains != nil {
		predicates = append(predicates, contact.SurnameContains(*i.SurnameContains))
	}
	if i.SurnameHasPrefix != nil {
		predicates = append(predicates, contact.SurnameHasPrefix(*i.SurnameHasPrefix))
	}
	if i.SurnameHasSuffix != nil {
		predicates = append(predicates, contact.SurnameHasSuffix(*i.SurnameHasSuffix))
	}
	if i.SurnameEqualFold != nil {
		predicates = append(predicates, contact.SurnameEqualFold(*i.SurnameEqualFold))
	}
	if i.SurnameContainsFold != nil {
		predicates = append(predicates, contact.SurnameContainsFold(*i.SurnameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, contact.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, contact.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, contact.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, contact.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, contact.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, contact.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, contact.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, contact.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, contact.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, contact.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, contact.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, contact.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, contact.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, contact.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, contact.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, contact.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, contact.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, contact.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, contact.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, contact.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, contact.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, contact.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, contact.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, contact.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, contact.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, contact.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}

	if i.HasTenant != nil {
		p := contact.HasTenant()
		if !*i.HasTenant {
			p = contact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contact.HasTenantWith(with...))
	}
	if i.HasBillingContact != nil {
		p := contact.HasBillingContact()
		if !*i.HasBillingContact {
			p = contact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBillingContactWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasBillingContactWith))
		for _, w := range i.HasBillingContactWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBillingContactWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contact.HasBillingContactWith(with...))
	}
	if i.HasAdminContact != nil {
		p := contact.HasAdminContact()
		if !*i.HasAdminContact {
			p = contact.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAdminContactWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasAdminContactWith))
		for _, w := range i.HasAdminContactWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAdminContactWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, contact.HasAdminContactWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyContactWhereInput
	case 1:
		return predicates[0], nil
	default:
		return contact.And(predicates...), nil
	}
}

// CountryWhereInput represents a where input for filtering Country queries.
type CountryWhereInput struct {
	Predicates []predicate.Country  `json:"-"`
	Not        *CountryWhereInput   `json:"not,omitempty"`
	Or         []*CountryWhereInput `json:"or,omitempty"`
	And        []*CountryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "alpha_2" field predicates.
	Alpha2             *string  `json:"alpha2,omitempty"`
	Alpha2NEQ          *string  `json:"alpha2NEQ,omitempty"`
	Alpha2In           []string `json:"alpha2In,omitempty"`
	Alpha2NotIn        []string `json:"alpha2NotIn,omitempty"`
	Alpha2GT           *string  `json:"alpha2GT,omitempty"`
	Alpha2GTE          *string  `json:"alpha2GTE,omitempty"`
	Alpha2LT           *string  `json:"alpha2LT,omitempty"`
	Alpha2LTE          *string  `json:"alpha2LTE,omitempty"`
	Alpha2Contains     *string  `json:"alpha2Contains,omitempty"`
	Alpha2HasPrefix    *string  `json:"alpha2HasPrefix,omitempty"`
	Alpha2HasSuffix    *string  `json:"alpha2HasSuffix,omitempty"`
	Alpha2EqualFold    *string  `json:"alpha2EqualFold,omitempty"`
	Alpha2ContainsFold *string  `json:"alpha2ContainsFold,omitempty"`

	// "alpha_3" field predicates.
	Alpha3             *string  `json:"alpha3,omitempty"`
	Alpha3NEQ          *string  `json:"alpha3NEQ,omitempty"`
	Alpha3In           []string `json:"alpha3In,omitempty"`
	Alpha3NotIn        []string `json:"alpha3NotIn,omitempty"`
	Alpha3GT           *string  `json:"alpha3GT,omitempty"`
	Alpha3GTE          *string  `json:"alpha3GTE,omitempty"`
	Alpha3LT           *string  `json:"alpha3LT,omitempty"`
	Alpha3LTE          *string  `json:"alpha3LTE,omitempty"`
	Alpha3Contains     *string  `json:"alpha3Contains,omitempty"`
	Alpha3HasPrefix    *string  `json:"alpha3HasPrefix,omitempty"`
	Alpha3HasSuffix    *string  `json:"alpha3HasSuffix,omitempty"`
	Alpha3EqualFold    *string  `json:"alpha3EqualFold,omitempty"`
	Alpha3ContainsFold *string  `json:"alpha3ContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "region" field predicates.
	Region      *country.Region  `json:"region,omitempty"`
	RegionNEQ   *country.Region  `json:"regionNEQ,omitempty"`
	RegionIn    []country.Region `json:"regionIn,omitempty"`
	RegionNotIn []country.Region `json:"regionNotIn,omitempty"`

	// "delivery_rule" edge predicates.
	HasDeliveryRule     *bool                     `json:"hasDeliveryRule,omitempty"`
	HasDeliveryRuleWith []*DeliveryRuleWhereInput `json:"hasDeliveryRuleWith,omitempty"`

	// "address" edge predicates.
	HasAddress     *bool                `json:"hasAddress,omitempty"`
	HasAddressWith []*AddressWhereInput `json:"hasAddressWith,omitempty"`

	// "address_global" edge predicates.
	HasAddressGlobal     *bool                      `json:"hasAddressGlobal,omitempty"`
	HasAddressGlobalWith []*AddressGlobalWhereInput `json:"hasAddressGlobalWith,omitempty"`

	// "carrier_additional_service_post_nord_consignee" edge predicates.
	HasCarrierAdditionalServicePostNordConsignee     *bool                                         `json:"hasCarrierAdditionalServicePostNordConsignee,omitempty"`
	HasCarrierAdditionalServicePostNordConsigneeWith []*CarrierAdditionalServicePostNordWhereInput `json:"hasCarrierAdditionalServicePostNordConsigneeWith,omitempty"`

	// "carrier_additional_service_post_nord_consignor" edge predicates.
	HasCarrierAdditionalServicePostNordConsignor     *bool                                         `json:"hasCarrierAdditionalServicePostNordConsignor,omitempty"`
	HasCarrierAdditionalServicePostNordConsignorWith []*CarrierAdditionalServicePostNordWhereInput `json:"hasCarrierAdditionalServicePostNordConsignorWith,omitempty"`

	// "carrier_additional_service_gls_consignee" edge predicates.
	HasCarrierAdditionalServiceGLSConsignee     *bool                                    `json:"hasCarrierAdditionalServiceGLSConsignee,omitempty"`
	HasCarrierAdditionalServiceGLSConsigneeWith []*CarrierAdditionalServiceGLSWhereInput `json:"hasCarrierAdditionalServiceGLSConsigneeWith,omitempty"`

	// "carrier_additional_service_gls_consignor" edge predicates.
	HasCarrierAdditionalServiceGLSConsignor     *bool                                    `json:"hasCarrierAdditionalServiceGLSConsignor,omitempty"`
	HasCarrierAdditionalServiceGLSConsignorWith []*CarrierAdditionalServiceGLSWhereInput `json:"hasCarrierAdditionalServiceGLSConsignorWith,omitempty"`

	// "country_harmonized_code" edge predicates.
	HasCountryHarmonizedCode     *bool                              `json:"hasCountryHarmonizedCode,omitempty"`
	HasCountryHarmonizedCodeWith []*CountryHarmonizedCodeWhereInput `json:"hasCountryHarmonizedCodeWith,omitempty"`

	// "inventory_item" edge predicates.
	HasInventoryItem     *bool                      `json:"hasInventoryItem,omitempty"`
	HasInventoryItemWith []*InventoryItemWhereInput `json:"hasInventoryItemWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CountryWhereInput) AddPredicates(predicates ...predicate.Country) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CountryWhereInput filter on the CountryQuery builder.
func (i *CountryWhereInput) Filter(q *CountryQuery) (*CountryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCountryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCountryWhereInput is returned in case the CountryWhereInput is empty.
var ErrEmptyCountryWhereInput = errors.New("ent: empty predicate CountryWhereInput")

// P returns a predicate for filtering countries.
// An error is returned if the input is empty or invalid.
func (i *CountryWhereInput) P() (predicate.Country, error) {
	var predicates []predicate.Country
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, country.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Country, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, country.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Country, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, country.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, country.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, country.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, country.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, country.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, country.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, country.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, country.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, country.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, country.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, country.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, country.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, country.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, country.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, country.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, country.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, country.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, country.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, country.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, country.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, country.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, country.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.Alpha2 != nil {
		predicates = append(predicates, country.Alpha2EQ(*i.Alpha2))
	}
	if i.Alpha2NEQ != nil {
		predicates = append(predicates, country.Alpha2NEQ(*i.Alpha2NEQ))
	}
	if len(i.Alpha2In) > 0 {
		predicates = append(predicates, country.Alpha2In(i.Alpha2In...))
	}
	if len(i.Alpha2NotIn) > 0 {
		predicates = append(predicates, country.Alpha2NotIn(i.Alpha2NotIn...))
	}
	if i.Alpha2GT != nil {
		predicates = append(predicates, country.Alpha2GT(*i.Alpha2GT))
	}
	if i.Alpha2GTE != nil {
		predicates = append(predicates, country.Alpha2GTE(*i.Alpha2GTE))
	}
	if i.Alpha2LT != nil {
		predicates = append(predicates, country.Alpha2LT(*i.Alpha2LT))
	}
	if i.Alpha2LTE != nil {
		predicates = append(predicates, country.Alpha2LTE(*i.Alpha2LTE))
	}
	if i.Alpha2Contains != nil {
		predicates = append(predicates, country.Alpha2Contains(*i.Alpha2Contains))
	}
	if i.Alpha2HasPrefix != nil {
		predicates = append(predicates, country.Alpha2HasPrefix(*i.Alpha2HasPrefix))
	}
	if i.Alpha2HasSuffix != nil {
		predicates = append(predicates, country.Alpha2HasSuffix(*i.Alpha2HasSuffix))
	}
	if i.Alpha2EqualFold != nil {
		predicates = append(predicates, country.Alpha2EqualFold(*i.Alpha2EqualFold))
	}
	if i.Alpha2ContainsFold != nil {
		predicates = append(predicates, country.Alpha2ContainsFold(*i.Alpha2ContainsFold))
	}
	if i.Alpha3 != nil {
		predicates = append(predicates, country.Alpha3EQ(*i.Alpha3))
	}
	if i.Alpha3NEQ != nil {
		predicates = append(predicates, country.Alpha3NEQ(*i.Alpha3NEQ))
	}
	if len(i.Alpha3In) > 0 {
		predicates = append(predicates, country.Alpha3In(i.Alpha3In...))
	}
	if len(i.Alpha3NotIn) > 0 {
		predicates = append(predicates, country.Alpha3NotIn(i.Alpha3NotIn...))
	}
	if i.Alpha3GT != nil {
		predicates = append(predicates, country.Alpha3GT(*i.Alpha3GT))
	}
	if i.Alpha3GTE != nil {
		predicates = append(predicates, country.Alpha3GTE(*i.Alpha3GTE))
	}
	if i.Alpha3LT != nil {
		predicates = append(predicates, country.Alpha3LT(*i.Alpha3LT))
	}
	if i.Alpha3LTE != nil {
		predicates = append(predicates, country.Alpha3LTE(*i.Alpha3LTE))
	}
	if i.Alpha3Contains != nil {
		predicates = append(predicates, country.Alpha3Contains(*i.Alpha3Contains))
	}
	if i.Alpha3HasPrefix != nil {
		predicates = append(predicates, country.Alpha3HasPrefix(*i.Alpha3HasPrefix))
	}
	if i.Alpha3HasSuffix != nil {
		predicates = append(predicates, country.Alpha3HasSuffix(*i.Alpha3HasSuffix))
	}
	if i.Alpha3EqualFold != nil {
		predicates = append(predicates, country.Alpha3EqualFold(*i.Alpha3EqualFold))
	}
	if i.Alpha3ContainsFold != nil {
		predicates = append(predicates, country.Alpha3ContainsFold(*i.Alpha3ContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, country.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, country.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, country.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, country.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, country.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, country.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, country.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, country.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, country.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, country.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, country.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, country.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, country.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Region != nil {
		predicates = append(predicates, country.RegionEQ(*i.Region))
	}
	if i.RegionNEQ != nil {
		predicates = append(predicates, country.RegionNEQ(*i.RegionNEQ))
	}
	if len(i.RegionIn) > 0 {
		predicates = append(predicates, country.RegionIn(i.RegionIn...))
	}
	if len(i.RegionNotIn) > 0 {
		predicates = append(predicates, country.RegionNotIn(i.RegionNotIn...))
	}

	if i.HasDeliveryRule != nil {
		p := country.HasDeliveryRule()
		if !*i.HasDeliveryRule {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryRuleWith) > 0 {
		with := make([]predicate.DeliveryRule, 0, len(i.HasDeliveryRuleWith))
		for _, w := range i.HasDeliveryRuleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryRuleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasDeliveryRuleWith(with...))
	}
	if i.HasAddress != nil {
		p := country.HasAddress()
		if !*i.HasAddress {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAddressWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasAddressWith))
		for _, w := range i.HasAddressWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAddressWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasAddressWith(with...))
	}
	if i.HasAddressGlobal != nil {
		p := country.HasAddressGlobal()
		if !*i.HasAddressGlobal {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAddressGlobalWith) > 0 {
		with := make([]predicate.AddressGlobal, 0, len(i.HasAddressGlobalWith))
		for _, w := range i.HasAddressGlobalWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAddressGlobalWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasAddressGlobalWith(with...))
	}
	if i.HasCarrierAdditionalServicePostNordConsignee != nil {
		p := country.HasCarrierAdditionalServicePostNordConsignee()
		if !*i.HasCarrierAdditionalServicePostNordConsignee {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServicePostNordConsigneeWith) > 0 {
		with := make([]predicate.CarrierAdditionalServicePostNord, 0, len(i.HasCarrierAdditionalServicePostNordConsigneeWith))
		for _, w := range i.HasCarrierAdditionalServicePostNordConsigneeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServicePostNordConsigneeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasCarrierAdditionalServicePostNordConsigneeWith(with...))
	}
	if i.HasCarrierAdditionalServicePostNordConsignor != nil {
		p := country.HasCarrierAdditionalServicePostNordConsignor()
		if !*i.HasCarrierAdditionalServicePostNordConsignor {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServicePostNordConsignorWith) > 0 {
		with := make([]predicate.CarrierAdditionalServicePostNord, 0, len(i.HasCarrierAdditionalServicePostNordConsignorWith))
		for _, w := range i.HasCarrierAdditionalServicePostNordConsignorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServicePostNordConsignorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasCarrierAdditionalServicePostNordConsignorWith(with...))
	}
	if i.HasCarrierAdditionalServiceGLSConsignee != nil {
		p := country.HasCarrierAdditionalServiceGLSConsignee()
		if !*i.HasCarrierAdditionalServiceGLSConsignee {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceGLSConsigneeWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceGLS, 0, len(i.HasCarrierAdditionalServiceGLSConsigneeWith))
		for _, w := range i.HasCarrierAdditionalServiceGLSConsigneeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceGLSConsigneeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasCarrierAdditionalServiceGLSConsigneeWith(with...))
	}
	if i.HasCarrierAdditionalServiceGLSConsignor != nil {
		p := country.HasCarrierAdditionalServiceGLSConsignor()
		if !*i.HasCarrierAdditionalServiceGLSConsignor {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceGLSConsignorWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceGLS, 0, len(i.HasCarrierAdditionalServiceGLSConsignorWith))
		for _, w := range i.HasCarrierAdditionalServiceGLSConsignorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceGLSConsignorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasCarrierAdditionalServiceGLSConsignorWith(with...))
	}
	if i.HasCountryHarmonizedCode != nil {
		p := country.HasCountryHarmonizedCode()
		if !*i.HasCountryHarmonizedCode {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryHarmonizedCodeWith) > 0 {
		with := make([]predicate.CountryHarmonizedCode, 0, len(i.HasCountryHarmonizedCodeWith))
		for _, w := range i.HasCountryHarmonizedCodeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryHarmonizedCodeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasCountryHarmonizedCodeWith(with...))
	}
	if i.HasInventoryItem != nil {
		p := country.HasInventoryItem()
		if !*i.HasInventoryItem {
			p = country.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInventoryItemWith) > 0 {
		with := make([]predicate.InventoryItem, 0, len(i.HasInventoryItemWith))
		for _, w := range i.HasInventoryItemWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInventoryItemWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, country.HasInventoryItemWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCountryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return country.And(predicates...), nil
	}
}

// CountryHarmonizedCodeWhereInput represents a where input for filtering CountryHarmonizedCode queries.
type CountryHarmonizedCodeWhereInput struct {
	Predicates []predicate.CountryHarmonizedCode  `json:"-"`
	Not        *CountryHarmonizedCodeWhereInput   `json:"not,omitempty"`
	Or         []*CountryHarmonizedCodeWhereInput `json:"or,omitempty"`
	And        []*CountryHarmonizedCodeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "inventory_item" edge predicates.
	HasInventoryItem     *bool                      `json:"hasInventoryItem,omitempty"`
	HasInventoryItemWith []*InventoryItemWhereInput `json:"hasInventoryItemWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CountryHarmonizedCodeWhereInput) AddPredicates(predicates ...predicate.CountryHarmonizedCode) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CountryHarmonizedCodeWhereInput filter on the CountryHarmonizedCodeQuery builder.
func (i *CountryHarmonizedCodeWhereInput) Filter(q *CountryHarmonizedCodeQuery) (*CountryHarmonizedCodeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCountryHarmonizedCodeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCountryHarmonizedCodeWhereInput is returned in case the CountryHarmonizedCodeWhereInput is empty.
var ErrEmptyCountryHarmonizedCodeWhereInput = errors.New("ent: empty predicate CountryHarmonizedCodeWhereInput")

// P returns a predicate for filtering countryharmonizedcodes.
// An error is returned if the input is empty or invalid.
func (i *CountryHarmonizedCodeWhereInput) P() (predicate.CountryHarmonizedCode, error) {
	var predicates []predicate.CountryHarmonizedCode
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, countryharmonizedcode.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.CountryHarmonizedCode, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, countryharmonizedcode.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.CountryHarmonizedCode, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, countryharmonizedcode.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, countryharmonizedcode.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, countryharmonizedcode.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, countryharmonizedcode.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, countryharmonizedcode.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, countryharmonizedcode.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, countryharmonizedcode.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, countryharmonizedcode.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, countryharmonizedcode.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, countryharmonizedcode.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, countryharmonizedcode.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, countryharmonizedcode.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, countryharmonizedcode.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, countryharmonizedcode.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, countryharmonizedcode.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, countryharmonizedcode.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, countryharmonizedcode.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, countryharmonizedcode.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, countryharmonizedcode.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, countryharmonizedcode.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, countryharmonizedcode.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, countryharmonizedcode.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, countryharmonizedcode.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, countryharmonizedcode.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, countryharmonizedcode.CodeContainsFold(*i.CodeContainsFold))
	}

	if i.HasTenant != nil {
		p := countryharmonizedcode.HasTenant()
		if !*i.HasTenant {
			p = countryharmonizedcode.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, countryharmonizedcode.HasTenantWith(with...))
	}
	if i.HasInventoryItem != nil {
		p := countryharmonizedcode.HasInventoryItem()
		if !*i.HasInventoryItem {
			p = countryharmonizedcode.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInventoryItemWith) > 0 {
		with := make([]predicate.InventoryItem, 0, len(i.HasInventoryItemWith))
		for _, w := range i.HasInventoryItemWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInventoryItemWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, countryharmonizedcode.HasInventoryItemWith(with...))
	}
	if i.HasCountry != nil {
		p := countryharmonizedcode.HasCountry()
		if !*i.HasCountry {
			p = countryharmonizedcode.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, countryharmonizedcode.HasCountryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCountryHarmonizedCodeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return countryharmonizedcode.And(predicates...), nil
	}
}

// CurrencyWhereInput represents a where input for filtering Currency queries.
type CurrencyWhereInput struct {
	Predicates []predicate.Currency  `json:"-"`
	Not        *CurrencyWhereInput   `json:"not,omitempty"`
	Or         []*CurrencyWhereInput `json:"or,omitempty"`
	And        []*CurrencyWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "display" field predicates.
	Display             *string  `json:"display,omitempty"`
	DisplayNEQ          *string  `json:"displayNEQ,omitempty"`
	DisplayIn           []string `json:"displayIn,omitempty"`
	DisplayNotIn        []string `json:"displayNotIn,omitempty"`
	DisplayGT           *string  `json:"displayGT,omitempty"`
	DisplayGTE          *string  `json:"displayGTE,omitempty"`
	DisplayLT           *string  `json:"displayLT,omitempty"`
	DisplayLTE          *string  `json:"displayLTE,omitempty"`
	DisplayContains     *string  `json:"displayContains,omitempty"`
	DisplayHasPrefix    *string  `json:"displayHasPrefix,omitempty"`
	DisplayHasSuffix    *string  `json:"displayHasSuffix,omitempty"`
	DisplayEqualFold    *string  `json:"displayEqualFold,omitempty"`
	DisplayContainsFold *string  `json:"displayContainsFold,omitempty"`

	// "currency_code" field predicates.
	CurrencyCode      *currency.CurrencyCode  `json:"currencyCode,omitempty"`
	CurrencyCodeNEQ   *currency.CurrencyCode  `json:"currencyCodeNEQ,omitempty"`
	CurrencyCodeIn    []currency.CurrencyCode `json:"currencyCodeIn,omitempty"`
	CurrencyCodeNotIn []currency.CurrencyCode `json:"currencyCodeNotIn,omitempty"`

	// "order_line" edge predicates.
	HasOrderLine     *bool                  `json:"hasOrderLine,omitempty"`
	HasOrderLineWith []*OrderLineWhereInput `json:"hasOrderLineWith,omitempty"`

	// "delivery_rule" edge predicates.
	HasDeliveryRule     *bool                     `json:"hasDeliveryRule,omitempty"`
	HasDeliveryRuleWith []*DeliveryRuleWhereInput `json:"hasDeliveryRuleWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *CurrencyWhereInput) AddPredicates(predicates ...predicate.Currency) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the CurrencyWhereInput filter on the CurrencyQuery builder.
func (i *CurrencyWhereInput) Filter(q *CurrencyQuery) (*CurrencyQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyCurrencyWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyCurrencyWhereInput is returned in case the CurrencyWhereInput is empty.
var ErrEmptyCurrencyWhereInput = errors.New("ent: empty predicate CurrencyWhereInput")

// P returns a predicate for filtering currencies.
// An error is returned if the input is empty or invalid.
func (i *CurrencyWhereInput) P() (predicate.Currency, error) {
	var predicates []predicate.Currency
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, currency.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Currency, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, currency.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Currency, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, currency.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, currency.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, currency.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, currency.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, currency.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, currency.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, currency.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, currency.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, currency.IDLTE(*i.IDLTE))
	}
	if i.Display != nil {
		predicates = append(predicates, currency.DisplayEQ(*i.Display))
	}
	if i.DisplayNEQ != nil {
		predicates = append(predicates, currency.DisplayNEQ(*i.DisplayNEQ))
	}
	if len(i.DisplayIn) > 0 {
		predicates = append(predicates, currency.DisplayIn(i.DisplayIn...))
	}
	if len(i.DisplayNotIn) > 0 {
		predicates = append(predicates, currency.DisplayNotIn(i.DisplayNotIn...))
	}
	if i.DisplayGT != nil {
		predicates = append(predicates, currency.DisplayGT(*i.DisplayGT))
	}
	if i.DisplayGTE != nil {
		predicates = append(predicates, currency.DisplayGTE(*i.DisplayGTE))
	}
	if i.DisplayLT != nil {
		predicates = append(predicates, currency.DisplayLT(*i.DisplayLT))
	}
	if i.DisplayLTE != nil {
		predicates = append(predicates, currency.DisplayLTE(*i.DisplayLTE))
	}
	if i.DisplayContains != nil {
		predicates = append(predicates, currency.DisplayContains(*i.DisplayContains))
	}
	if i.DisplayHasPrefix != nil {
		predicates = append(predicates, currency.DisplayHasPrefix(*i.DisplayHasPrefix))
	}
	if i.DisplayHasSuffix != nil {
		predicates = append(predicates, currency.DisplayHasSuffix(*i.DisplayHasSuffix))
	}
	if i.DisplayEqualFold != nil {
		predicates = append(predicates, currency.DisplayEqualFold(*i.DisplayEqualFold))
	}
	if i.DisplayContainsFold != nil {
		predicates = append(predicates, currency.DisplayContainsFold(*i.DisplayContainsFold))
	}
	if i.CurrencyCode != nil {
		predicates = append(predicates, currency.CurrencyCodeEQ(*i.CurrencyCode))
	}
	if i.CurrencyCodeNEQ != nil {
		predicates = append(predicates, currency.CurrencyCodeNEQ(*i.CurrencyCodeNEQ))
	}
	if len(i.CurrencyCodeIn) > 0 {
		predicates = append(predicates, currency.CurrencyCodeIn(i.CurrencyCodeIn...))
	}
	if len(i.CurrencyCodeNotIn) > 0 {
		predicates = append(predicates, currency.CurrencyCodeNotIn(i.CurrencyCodeNotIn...))
	}

	if i.HasOrderLine != nil {
		p := currency.HasOrderLine()
		if !*i.HasOrderLine {
			p = currency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrderLineWith) > 0 {
		with := make([]predicate.OrderLine, 0, len(i.HasOrderLineWith))
		for _, w := range i.HasOrderLineWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrderLineWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, currency.HasOrderLineWith(with...))
	}
	if i.HasDeliveryRule != nil {
		p := currency.HasDeliveryRule()
		if !*i.HasDeliveryRule {
			p = currency.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryRuleWith) > 0 {
		with := make([]predicate.DeliveryRule, 0, len(i.HasDeliveryRuleWith))
		for _, w := range i.HasDeliveryRuleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryRuleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, currency.HasDeliveryRuleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyCurrencyWhereInput
	case 1:
		return predicates[0], nil
	default:
		return currency.And(predicates...), nil
	}
}

// DeliveryOptionWhereInput represents a where input for filtering DeliveryOption queries.
type DeliveryOptionWhereInput struct {
	Predicates []predicate.DeliveryOption  `json:"-"`
	Not        *DeliveryOptionWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryOptionWhereInput `json:"or,omitempty"`
	And        []*DeliveryOptionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "archived_at" field predicates.
	ArchivedAt       *time.Time  `json:"archivedAt,omitempty"`
	ArchivedAtNEQ    *time.Time  `json:"archivedAtNEQ,omitempty"`
	ArchivedAtIn     []time.Time `json:"archivedAtIn,omitempty"`
	ArchivedAtNotIn  []time.Time `json:"archivedAtNotIn,omitempty"`
	ArchivedAtGT     *time.Time  `json:"archivedAtGT,omitempty"`
	ArchivedAtGTE    *time.Time  `json:"archivedAtGTE,omitempty"`
	ArchivedAtLT     *time.Time  `json:"archivedAtLT,omitempty"`
	ArchivedAtLTE    *time.Time  `json:"archivedAtLTE,omitempty"`
	ArchivedAtIsNil  bool        `json:"archivedAtIsNil,omitempty"`
	ArchivedAtNotNil bool        `json:"archivedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "sort_order" field predicates.
	SortOrder      *int  `json:"sortOrder,omitempty"`
	SortOrderNEQ   *int  `json:"sortOrderNEQ,omitempty"`
	SortOrderIn    []int `json:"sortOrderIn,omitempty"`
	SortOrderNotIn []int `json:"sortOrderNotIn,omitempty"`
	SortOrderGT    *int  `json:"sortOrderGT,omitempty"`
	SortOrderGTE   *int  `json:"sortOrderGTE,omitempty"`
	SortOrderLT    *int  `json:"sortOrderLT,omitempty"`
	SortOrderLTE   *int  `json:"sortOrderLTE,omitempty"`

	// "click_option_display_count" field predicates.
	ClickOptionDisplayCount       *int  `json:"clickOptionDisplayCount,omitempty"`
	ClickOptionDisplayCountNEQ    *int  `json:"clickOptionDisplayCountNEQ,omitempty"`
	ClickOptionDisplayCountIn     []int `json:"clickOptionDisplayCountIn,omitempty"`
	ClickOptionDisplayCountNotIn  []int `json:"clickOptionDisplayCountNotIn,omitempty"`
	ClickOptionDisplayCountGT     *int  `json:"clickOptionDisplayCountGT,omitempty"`
	ClickOptionDisplayCountGTE    *int  `json:"clickOptionDisplayCountGTE,omitempty"`
	ClickOptionDisplayCountLT     *int  `json:"clickOptionDisplayCountLT,omitempty"`
	ClickOptionDisplayCountLTE    *int  `json:"clickOptionDisplayCountLTE,omitempty"`
	ClickOptionDisplayCountIsNil  bool  `json:"clickOptionDisplayCountIsNil,omitempty"`
	ClickOptionDisplayCountNotNil bool  `json:"clickOptionDisplayCountNotNil,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "click_collect" field predicates.
	ClickCollect       *bool `json:"clickCollect,omitempty"`
	ClickCollectNEQ    *bool `json:"clickCollectNEQ,omitempty"`
	ClickCollectIsNil  bool  `json:"clickCollectIsNil,omitempty"`
	ClickCollectNotNil bool  `json:"clickCollectNotNil,omitempty"`

	// "override_sender_address" field predicates.
	OverrideSenderAddress       *bool `json:"overrideSenderAddress,omitempty"`
	OverrideSenderAddressNEQ    *bool `json:"overrideSenderAddressNEQ,omitempty"`
	OverrideSenderAddressIsNil  bool  `json:"overrideSenderAddressIsNil,omitempty"`
	OverrideSenderAddressNotNil bool  `json:"overrideSenderAddressNotNil,omitempty"`

	// "override_return_address" field predicates.
	OverrideReturnAddress       *bool `json:"overrideReturnAddress,omitempty"`
	OverrideReturnAddressNEQ    *bool `json:"overrideReturnAddressNEQ,omitempty"`
	OverrideReturnAddressIsNil  bool  `json:"overrideReturnAddressIsNil,omitempty"`
	OverrideReturnAddressNotNil bool  `json:"overrideReturnAddressNotNil,omitempty"`

	// "hide_delivery_option" field predicates.
	HideDeliveryOption       *bool `json:"hideDeliveryOption,omitempty"`
	HideDeliveryOptionNEQ    *bool `json:"hideDeliveryOptionNEQ,omitempty"`
	HideDeliveryOptionIsNil  bool  `json:"hideDeliveryOptionIsNil,omitempty"`
	HideDeliveryOptionNotNil bool  `json:"hideDeliveryOptionNotNil,omitempty"`

	// "delivery_estimate_from" field predicates.
	DeliveryEstimateFrom       *int  `json:"deliveryEstimateFrom,omitempty"`
	DeliveryEstimateFromNEQ    *int  `json:"deliveryEstimateFromNEQ,omitempty"`
	DeliveryEstimateFromIn     []int `json:"deliveryEstimateFromIn,omitempty"`
	DeliveryEstimateFromNotIn  []int `json:"deliveryEstimateFromNotIn,omitempty"`
	DeliveryEstimateFromGT     *int  `json:"deliveryEstimateFromGT,omitempty"`
	DeliveryEstimateFromGTE    *int  `json:"deliveryEstimateFromGTE,omitempty"`
	DeliveryEstimateFromLT     *int  `json:"deliveryEstimateFromLT,omitempty"`
	DeliveryEstimateFromLTE    *int  `json:"deliveryEstimateFromLTE,omitempty"`
	DeliveryEstimateFromIsNil  bool  `json:"deliveryEstimateFromIsNil,omitempty"`
	DeliveryEstimateFromNotNil bool  `json:"deliveryEstimateFromNotNil,omitempty"`

	// "delivery_estimate_to" field predicates.
	DeliveryEstimateTo       *int  `json:"deliveryEstimateTo,omitempty"`
	DeliveryEstimateToNEQ    *int  `json:"deliveryEstimateToNEQ,omitempty"`
	DeliveryEstimateToIn     []int `json:"deliveryEstimateToIn,omitempty"`
	DeliveryEstimateToNotIn  []int `json:"deliveryEstimateToNotIn,omitempty"`
	DeliveryEstimateToGT     *int  `json:"deliveryEstimateToGT,omitempty"`
	DeliveryEstimateToGTE    *int  `json:"deliveryEstimateToGTE,omitempty"`
	DeliveryEstimateToLT     *int  `json:"deliveryEstimateToLT,omitempty"`
	DeliveryEstimateToLTE    *int  `json:"deliveryEstimateToLTE,omitempty"`
	DeliveryEstimateToIsNil  bool  `json:"deliveryEstimateToIsNil,omitempty"`
	DeliveryEstimateToNotNil bool  `json:"deliveryEstimateToNotNil,omitempty"`

	// "webshipper_integration" field predicates.
	WebshipperIntegration    *bool `json:"webshipperIntegration,omitempty"`
	WebshipperIntegrationNEQ *bool `json:"webshipperIntegrationNEQ,omitempty"`

	// "webshipper_id" field predicates.
	WebshipperID       *int  `json:"webshipperID,omitempty"`
	WebshipperIDNEQ    *int  `json:"webshipperIDNEQ,omitempty"`
	WebshipperIDIn     []int `json:"webshipperIDIn,omitempty"`
	WebshipperIDNotIn  []int `json:"webshipperIDNotIn,omitempty"`
	WebshipperIDGT     *int  `json:"webshipperIDGT,omitempty"`
	WebshipperIDGTE    *int  `json:"webshipperIDGTE,omitempty"`
	WebshipperIDLT     *int  `json:"webshipperIDLT,omitempty"`
	WebshipperIDLTE    *int  `json:"webshipperIDLTE,omitempty"`
	WebshipperIDIsNil  bool  `json:"webshipperIDIsNil,omitempty"`
	WebshipperIDNotNil bool  `json:"webshipperIDNotNil,omitempty"`

	// "shipmondo_integration" field predicates.
	ShipmondoIntegration    *bool `json:"shipmondoIntegration,omitempty"`
	ShipmondoIntegrationNEQ *bool `json:"shipmondoIntegrationNEQ,omitempty"`

	// "shipmondo_delivery_option" field predicates.
	ShipmondoDeliveryOption             *string  `json:"shipmondoDeliveryOption,omitempty"`
	ShipmondoDeliveryOptionNEQ          *string  `json:"shipmondoDeliveryOptionNEQ,omitempty"`
	ShipmondoDeliveryOptionIn           []string `json:"shipmondoDeliveryOptionIn,omitempty"`
	ShipmondoDeliveryOptionNotIn        []string `json:"shipmondoDeliveryOptionNotIn,omitempty"`
	ShipmondoDeliveryOptionGT           *string  `json:"shipmondoDeliveryOptionGT,omitempty"`
	ShipmondoDeliveryOptionGTE          *string  `json:"shipmondoDeliveryOptionGTE,omitempty"`
	ShipmondoDeliveryOptionLT           *string  `json:"shipmondoDeliveryOptionLT,omitempty"`
	ShipmondoDeliveryOptionLTE          *string  `json:"shipmondoDeliveryOptionLTE,omitempty"`
	ShipmondoDeliveryOptionContains     *string  `json:"shipmondoDeliveryOptionContains,omitempty"`
	ShipmondoDeliveryOptionHasPrefix    *string  `json:"shipmondoDeliveryOptionHasPrefix,omitempty"`
	ShipmondoDeliveryOptionHasSuffix    *string  `json:"shipmondoDeliveryOptionHasSuffix,omitempty"`
	ShipmondoDeliveryOptionIsNil        bool     `json:"shipmondoDeliveryOptionIsNil,omitempty"`
	ShipmondoDeliveryOptionNotNil       bool     `json:"shipmondoDeliveryOptionNotNil,omitempty"`
	ShipmondoDeliveryOptionEqualFold    *string  `json:"shipmondoDeliveryOptionEqualFold,omitempty"`
	ShipmondoDeliveryOptionContainsFold *string  `json:"shipmondoDeliveryOptionContainsFold,omitempty"`

	// "customs_enabled" field predicates.
	CustomsEnabled    *bool `json:"customsEnabled,omitempty"`
	CustomsEnabledNEQ *bool `json:"customsEnabledNEQ,omitempty"`

	// "customs_signer" field predicates.
	CustomsSigner             *string  `json:"customsSigner,omitempty"`
	CustomsSignerNEQ          *string  `json:"customsSignerNEQ,omitempty"`
	CustomsSignerIn           []string `json:"customsSignerIn,omitempty"`
	CustomsSignerNotIn        []string `json:"customsSignerNotIn,omitempty"`
	CustomsSignerGT           *string  `json:"customsSignerGT,omitempty"`
	CustomsSignerGTE          *string  `json:"customsSignerGTE,omitempty"`
	CustomsSignerLT           *string  `json:"customsSignerLT,omitempty"`
	CustomsSignerLTE          *string  `json:"customsSignerLTE,omitempty"`
	CustomsSignerContains     *string  `json:"customsSignerContains,omitempty"`
	CustomsSignerHasPrefix    *string  `json:"customsSignerHasPrefix,omitempty"`
	CustomsSignerHasSuffix    *string  `json:"customsSignerHasSuffix,omitempty"`
	CustomsSignerIsNil        bool     `json:"customsSignerIsNil,omitempty"`
	CustomsSignerNotNil       bool     `json:"customsSignerNotNil,omitempty"`
	CustomsSignerEqualFold    *string  `json:"customsSignerEqualFold,omitempty"`
	CustomsSignerContainsFold *string  `json:"customsSignerContainsFold,omitempty"`

	// "hide_if_company_empty" field predicates.
	HideIfCompanyEmpty    *bool `json:"hideIfCompanyEmpty,omitempty"`
	HideIfCompanyEmptyNEQ *bool `json:"hideIfCompanyEmptyNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`

	// "delivery_rule" edge predicates.
	HasDeliveryRule     *bool                     `json:"hasDeliveryRule,omitempty"`
	HasDeliveryRuleWith []*DeliveryRuleWhereInput `json:"hasDeliveryRuleWith,omitempty"`

	// "delivery_option_dao" edge predicates.
	HasDeliveryOptionDAO     *bool                          `json:"hasDeliveryOptionDAO,omitempty"`
	HasDeliveryOptionDAOWith []*DeliveryOptionDAOWhereInput `json:"hasDeliveryOptionDAOWith,omitempty"`

	// "delivery_option_df" edge predicates.
	HasDeliveryOptionDF     *bool                         `json:"hasDeliveryOptionDF,omitempty"`
	HasDeliveryOptionDFWith []*DeliveryOptionDFWhereInput `json:"hasDeliveryOptionDFWith,omitempty"`

	// "delivery_option_dsv" edge predicates.
	HasDeliveryOptionDSV     *bool                          `json:"hasDeliveryOptionDSV,omitempty"`
	HasDeliveryOptionDSVWith []*DeliveryOptionDSVWhereInput `json:"hasDeliveryOptionDSVWith,omitempty"`

	// "delivery_option_easy_post" edge predicates.
	HasDeliveryOptionEasyPost     *bool                               `json:"hasDeliveryOptionEasyPost,omitempty"`
	HasDeliveryOptionEasyPostWith []*DeliveryOptionEasyPostWhereInput `json:"hasDeliveryOptionEasyPostWith,omitempty"`

	// "delivery_option_gls" edge predicates.
	HasDeliveryOptionGLS     *bool                          `json:"hasDeliveryOptionGLS,omitempty"`
	HasDeliveryOptionGLSWith []*DeliveryOptionGLSWhereInput `json:"hasDeliveryOptionGLSWith,omitempty"`

	// "delivery_option_post_nord" edge predicates.
	HasDeliveryOptionPostNord     *bool                               `json:"hasDeliveryOptionPostNord,omitempty"`
	HasDeliveryOptionPostNordWith []*DeliveryOptionPostNordWhereInput `json:"hasDeliveryOptionPostNordWith,omitempty"`

	// "delivery_option_usps" edge predicates.
	HasDeliveryOptionUSPS     *bool                           `json:"hasDeliveryOptionUSPS,omitempty"`
	HasDeliveryOptionUSPSWith []*DeliveryOptionUSPSWhereInput `json:"hasDeliveryOptionUSPSWith,omitempty"`

	// "delivery_option_bring" edge predicates.
	HasDeliveryOptionBring     *bool                            `json:"hasDeliveryOptionBring,omitempty"`
	HasDeliveryOptionBringWith []*DeliveryOptionBringWhereInput `json:"hasDeliveryOptionBringWith,omitempty"`

	// "return_portals" edge predicates.
	HasReturnPortals     *bool                     `json:"hasReturnPortals,omitempty"`
	HasReturnPortalsWith []*ReturnPortalWhereInput `json:"hasReturnPortalsWith,omitempty"`

	// "colli" edge predicates.
	HasColli     *bool              `json:"hasColli,omitempty"`
	HasColliWith []*ColliWhereInput `json:"hasColliWith,omitempty"`

	// "return_colli" edge predicates.
	HasReturnColli     *bool                    `json:"hasReturnColli,omitempty"`
	HasReturnColliWith []*ReturnColliWhereInput `json:"hasReturnColliWith,omitempty"`

	// "carrier_service" edge predicates.
	HasCarrierService     *bool                       `json:"hasCarrierService,omitempty"`
	HasCarrierServiceWith []*CarrierServiceWhereInput `json:"hasCarrierServiceWith,omitempty"`

	// "connection" edge predicates.
	HasConnection     *bool                   `json:"hasConnection,omitempty"`
	HasConnectionWith []*ConnectionWhereInput `json:"hasConnectionWith,omitempty"`

	// "connection_default" edge predicates.
	HasConnectionDefault     *bool                   `json:"hasConnectionDefault,omitempty"`
	HasConnectionDefaultWith []*ConnectionWhereInput `json:"hasConnectionDefaultWith,omitempty"`

	// "hypothesis_test_delivery_option_group_one" edge predicates.
	HasHypothesisTestDeliveryOptionGroupOne     *bool                                     `json:"hasHypothesisTestDeliveryOptionGroupOne,omitempty"`
	HasHypothesisTestDeliveryOptionGroupOneWith []*HypothesisTestDeliveryOptionWhereInput `json:"hasHypothesisTestDeliveryOptionGroupOneWith,omitempty"`

	// "hypothesis_test_delivery_option_group_two" edge predicates.
	HasHypothesisTestDeliveryOptionGroupTwo     *bool                                     `json:"hasHypothesisTestDeliveryOptionGroupTwo,omitempty"`
	HasHypothesisTestDeliveryOptionGroupTwoWith []*HypothesisTestDeliveryOptionWhereInput `json:"hasHypothesisTestDeliveryOptionGroupTwoWith,omitempty"`

	// "hypothesis_test_delivery_option_lookup" edge predicates.
	HasHypothesisTestDeliveryOptionLookup     *bool                                           `json:"hasHypothesisTestDeliveryOptionLookup,omitempty"`
	HasHypothesisTestDeliveryOptionLookupWith []*HypothesisTestDeliveryOptionLookupWhereInput `json:"hasHypothesisTestDeliveryOptionLookupWith,omitempty"`

	// "click_collect_location" edge predicates.
	HasClickCollectLocation     *bool                 `json:"hasClickCollectLocation,omitempty"`
	HasClickCollectLocationWith []*LocationWhereInput `json:"hasClickCollectLocationWith,omitempty"`

	// "email_click_collect_at_store" edge predicates.
	HasEmailClickCollectAtStore     *bool                      `json:"hasEmailClickCollectAtStore,omitempty"`
	HasEmailClickCollectAtStoreWith []*EmailTemplateWhereInput `json:"hasEmailClickCollectAtStoreWith,omitempty"`

	// "consolidation" edge predicates.
	HasConsolidation     *bool                      `json:"hasConsolidation,omitempty"`
	HasConsolidationWith []*ConsolidationWhereInput `json:"hasConsolidationWith,omitempty"`

	// "default_packaging" edge predicates.
	HasDefaultPackaging     *bool                  `json:"hasDefaultPackaging,omitempty"`
	HasDefaultPackagingWith []*PackagingWhereInput `json:"hasDefaultPackagingWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryOptionWhereInput) AddPredicates(predicates ...predicate.DeliveryOption) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryOptionWhereInput filter on the DeliveryOptionQuery builder.
func (i *DeliveryOptionWhereInput) Filter(q *DeliveryOptionQuery) (*DeliveryOptionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryOptionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryOptionWhereInput is returned in case the DeliveryOptionWhereInput is empty.
var ErrEmptyDeliveryOptionWhereInput = errors.New("ent: empty predicate DeliveryOptionWhereInput")

// P returns a predicate for filtering deliveryoptions.
// An error is returned if the input is empty or invalid.
func (i *DeliveryOptionWhereInput) P() (predicate.DeliveryOption, error) {
	var predicates []predicate.DeliveryOption
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryoption.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryOption, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryoption.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryOption, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryoption.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryoption.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryoption.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryoption.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryoption.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryoption.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryoption.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryoption.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryoption.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryoption.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryoption.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryoption.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryoption.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryoption.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryoption.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryoption.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryoption.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryoption.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryoption.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryoption.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryoption.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryoption.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ArchivedAt != nil {
		predicates = append(predicates, deliveryoption.ArchivedAtEQ(*i.ArchivedAt))
	}
	if i.ArchivedAtNEQ != nil {
		predicates = append(predicates, deliveryoption.ArchivedAtNEQ(*i.ArchivedAtNEQ))
	}
	if len(i.ArchivedAtIn) > 0 {
		predicates = append(predicates, deliveryoption.ArchivedAtIn(i.ArchivedAtIn...))
	}
	if len(i.ArchivedAtNotIn) > 0 {
		predicates = append(predicates, deliveryoption.ArchivedAtNotIn(i.ArchivedAtNotIn...))
	}
	if i.ArchivedAtGT != nil {
		predicates = append(predicates, deliveryoption.ArchivedAtGT(*i.ArchivedAtGT))
	}
	if i.ArchivedAtGTE != nil {
		predicates = append(predicates, deliveryoption.ArchivedAtGTE(*i.ArchivedAtGTE))
	}
	if i.ArchivedAtLT != nil {
		predicates = append(predicates, deliveryoption.ArchivedAtLT(*i.ArchivedAtLT))
	}
	if i.ArchivedAtLTE != nil {
		predicates = append(predicates, deliveryoption.ArchivedAtLTE(*i.ArchivedAtLTE))
	}
	if i.ArchivedAtIsNil {
		predicates = append(predicates, deliveryoption.ArchivedAtIsNil())
	}
	if i.ArchivedAtNotNil {
		predicates = append(predicates, deliveryoption.ArchivedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, deliveryoption.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, deliveryoption.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, deliveryoption.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, deliveryoption.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, deliveryoption.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, deliveryoption.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, deliveryoption.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, deliveryoption.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, deliveryoption.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, deliveryoption.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, deliveryoption.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, deliveryoption.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, deliveryoption.NameContainsFold(*i.NameContainsFold))
	}
	if i.SortOrder != nil {
		predicates = append(predicates, deliveryoption.SortOrderEQ(*i.SortOrder))
	}
	if i.SortOrderNEQ != nil {
		predicates = append(predicates, deliveryoption.SortOrderNEQ(*i.SortOrderNEQ))
	}
	if len(i.SortOrderIn) > 0 {
		predicates = append(predicates, deliveryoption.SortOrderIn(i.SortOrderIn...))
	}
	if len(i.SortOrderNotIn) > 0 {
		predicates = append(predicates, deliveryoption.SortOrderNotIn(i.SortOrderNotIn...))
	}
	if i.SortOrderGT != nil {
		predicates = append(predicates, deliveryoption.SortOrderGT(*i.SortOrderGT))
	}
	if i.SortOrderGTE != nil {
		predicates = append(predicates, deliveryoption.SortOrderGTE(*i.SortOrderGTE))
	}
	if i.SortOrderLT != nil {
		predicates = append(predicates, deliveryoption.SortOrderLT(*i.SortOrderLT))
	}
	if i.SortOrderLTE != nil {
		predicates = append(predicates, deliveryoption.SortOrderLTE(*i.SortOrderLTE))
	}
	if i.ClickOptionDisplayCount != nil {
		predicates = append(predicates, deliveryoption.ClickOptionDisplayCountEQ(*i.ClickOptionDisplayCount))
	}
	if i.ClickOptionDisplayCountNEQ != nil {
		predicates = append(predicates, deliveryoption.ClickOptionDisplayCountNEQ(*i.ClickOptionDisplayCountNEQ))
	}
	if len(i.ClickOptionDisplayCountIn) > 0 {
		predicates = append(predicates, deliveryoption.ClickOptionDisplayCountIn(i.ClickOptionDisplayCountIn...))
	}
	if len(i.ClickOptionDisplayCountNotIn) > 0 {
		predicates = append(predicates, deliveryoption.ClickOptionDisplayCountNotIn(i.ClickOptionDisplayCountNotIn...))
	}
	if i.ClickOptionDisplayCountGT != nil {
		predicates = append(predicates, deliveryoption.ClickOptionDisplayCountGT(*i.ClickOptionDisplayCountGT))
	}
	if i.ClickOptionDisplayCountGTE != nil {
		predicates = append(predicates, deliveryoption.ClickOptionDisplayCountGTE(*i.ClickOptionDisplayCountGTE))
	}
	if i.ClickOptionDisplayCountLT != nil {
		predicates = append(predicates, deliveryoption.ClickOptionDisplayCountLT(*i.ClickOptionDisplayCountLT))
	}
	if i.ClickOptionDisplayCountLTE != nil {
		predicates = append(predicates, deliveryoption.ClickOptionDisplayCountLTE(*i.ClickOptionDisplayCountLTE))
	}
	if i.ClickOptionDisplayCountIsNil {
		predicates = append(predicates, deliveryoption.ClickOptionDisplayCountIsNil())
	}
	if i.ClickOptionDisplayCountNotNil {
		predicates = append(predicates, deliveryoption.ClickOptionDisplayCountNotNil())
	}
	if i.Description != nil {
		predicates = append(predicates, deliveryoption.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, deliveryoption.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, deliveryoption.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, deliveryoption.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, deliveryoption.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, deliveryoption.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, deliveryoption.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, deliveryoption.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, deliveryoption.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, deliveryoption.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, deliveryoption.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, deliveryoption.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, deliveryoption.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, deliveryoption.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, deliveryoption.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.ClickCollect != nil {
		predicates = append(predicates, deliveryoption.ClickCollectEQ(*i.ClickCollect))
	}
	if i.ClickCollectNEQ != nil {
		predicates = append(predicates, deliveryoption.ClickCollectNEQ(*i.ClickCollectNEQ))
	}
	if i.ClickCollectIsNil {
		predicates = append(predicates, deliveryoption.ClickCollectIsNil())
	}
	if i.ClickCollectNotNil {
		predicates = append(predicates, deliveryoption.ClickCollectNotNil())
	}
	if i.OverrideSenderAddress != nil {
		predicates = append(predicates, deliveryoption.OverrideSenderAddressEQ(*i.OverrideSenderAddress))
	}
	if i.OverrideSenderAddressNEQ != nil {
		predicates = append(predicates, deliveryoption.OverrideSenderAddressNEQ(*i.OverrideSenderAddressNEQ))
	}
	if i.OverrideSenderAddressIsNil {
		predicates = append(predicates, deliveryoption.OverrideSenderAddressIsNil())
	}
	if i.OverrideSenderAddressNotNil {
		predicates = append(predicates, deliveryoption.OverrideSenderAddressNotNil())
	}
	if i.OverrideReturnAddress != nil {
		predicates = append(predicates, deliveryoption.OverrideReturnAddressEQ(*i.OverrideReturnAddress))
	}
	if i.OverrideReturnAddressNEQ != nil {
		predicates = append(predicates, deliveryoption.OverrideReturnAddressNEQ(*i.OverrideReturnAddressNEQ))
	}
	if i.OverrideReturnAddressIsNil {
		predicates = append(predicates, deliveryoption.OverrideReturnAddressIsNil())
	}
	if i.OverrideReturnAddressNotNil {
		predicates = append(predicates, deliveryoption.OverrideReturnAddressNotNil())
	}
	if i.HideDeliveryOption != nil {
		predicates = append(predicates, deliveryoption.HideDeliveryOptionEQ(*i.HideDeliveryOption))
	}
	if i.HideDeliveryOptionNEQ != nil {
		predicates = append(predicates, deliveryoption.HideDeliveryOptionNEQ(*i.HideDeliveryOptionNEQ))
	}
	if i.HideDeliveryOptionIsNil {
		predicates = append(predicates, deliveryoption.HideDeliveryOptionIsNil())
	}
	if i.HideDeliveryOptionNotNil {
		predicates = append(predicates, deliveryoption.HideDeliveryOptionNotNil())
	}
	if i.DeliveryEstimateFrom != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateFromEQ(*i.DeliveryEstimateFrom))
	}
	if i.DeliveryEstimateFromNEQ != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateFromNEQ(*i.DeliveryEstimateFromNEQ))
	}
	if len(i.DeliveryEstimateFromIn) > 0 {
		predicates = append(predicates, deliveryoption.DeliveryEstimateFromIn(i.DeliveryEstimateFromIn...))
	}
	if len(i.DeliveryEstimateFromNotIn) > 0 {
		predicates = append(predicates, deliveryoption.DeliveryEstimateFromNotIn(i.DeliveryEstimateFromNotIn...))
	}
	if i.DeliveryEstimateFromGT != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateFromGT(*i.DeliveryEstimateFromGT))
	}
	if i.DeliveryEstimateFromGTE != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateFromGTE(*i.DeliveryEstimateFromGTE))
	}
	if i.DeliveryEstimateFromLT != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateFromLT(*i.DeliveryEstimateFromLT))
	}
	if i.DeliveryEstimateFromLTE != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateFromLTE(*i.DeliveryEstimateFromLTE))
	}
	if i.DeliveryEstimateFromIsNil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateFromIsNil())
	}
	if i.DeliveryEstimateFromNotNil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateFromNotNil())
	}
	if i.DeliveryEstimateTo != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateToEQ(*i.DeliveryEstimateTo))
	}
	if i.DeliveryEstimateToNEQ != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateToNEQ(*i.DeliveryEstimateToNEQ))
	}
	if len(i.DeliveryEstimateToIn) > 0 {
		predicates = append(predicates, deliveryoption.DeliveryEstimateToIn(i.DeliveryEstimateToIn...))
	}
	if len(i.DeliveryEstimateToNotIn) > 0 {
		predicates = append(predicates, deliveryoption.DeliveryEstimateToNotIn(i.DeliveryEstimateToNotIn...))
	}
	if i.DeliveryEstimateToGT != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateToGT(*i.DeliveryEstimateToGT))
	}
	if i.DeliveryEstimateToGTE != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateToGTE(*i.DeliveryEstimateToGTE))
	}
	if i.DeliveryEstimateToLT != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateToLT(*i.DeliveryEstimateToLT))
	}
	if i.DeliveryEstimateToLTE != nil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateToLTE(*i.DeliveryEstimateToLTE))
	}
	if i.DeliveryEstimateToIsNil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateToIsNil())
	}
	if i.DeliveryEstimateToNotNil {
		predicates = append(predicates, deliveryoption.DeliveryEstimateToNotNil())
	}
	if i.WebshipperIntegration != nil {
		predicates = append(predicates, deliveryoption.WebshipperIntegrationEQ(*i.WebshipperIntegration))
	}
	if i.WebshipperIntegrationNEQ != nil {
		predicates = append(predicates, deliveryoption.WebshipperIntegrationNEQ(*i.WebshipperIntegrationNEQ))
	}
	if i.WebshipperID != nil {
		predicates = append(predicates, deliveryoption.WebshipperIDEQ(*i.WebshipperID))
	}
	if i.WebshipperIDNEQ != nil {
		predicates = append(predicates, deliveryoption.WebshipperIDNEQ(*i.WebshipperIDNEQ))
	}
	if len(i.WebshipperIDIn) > 0 {
		predicates = append(predicates, deliveryoption.WebshipperIDIn(i.WebshipperIDIn...))
	}
	if len(i.WebshipperIDNotIn) > 0 {
		predicates = append(predicates, deliveryoption.WebshipperIDNotIn(i.WebshipperIDNotIn...))
	}
	if i.WebshipperIDGT != nil {
		predicates = append(predicates, deliveryoption.WebshipperIDGT(*i.WebshipperIDGT))
	}
	if i.WebshipperIDGTE != nil {
		predicates = append(predicates, deliveryoption.WebshipperIDGTE(*i.WebshipperIDGTE))
	}
	if i.WebshipperIDLT != nil {
		predicates = append(predicates, deliveryoption.WebshipperIDLT(*i.WebshipperIDLT))
	}
	if i.WebshipperIDLTE != nil {
		predicates = append(predicates, deliveryoption.WebshipperIDLTE(*i.WebshipperIDLTE))
	}
	if i.WebshipperIDIsNil {
		predicates = append(predicates, deliveryoption.WebshipperIDIsNil())
	}
	if i.WebshipperIDNotNil {
		predicates = append(predicates, deliveryoption.WebshipperIDNotNil())
	}
	if i.ShipmondoIntegration != nil {
		predicates = append(predicates, deliveryoption.ShipmondoIntegrationEQ(*i.ShipmondoIntegration))
	}
	if i.ShipmondoIntegrationNEQ != nil {
		predicates = append(predicates, deliveryoption.ShipmondoIntegrationNEQ(*i.ShipmondoIntegrationNEQ))
	}
	if i.ShipmondoDeliveryOption != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionEQ(*i.ShipmondoDeliveryOption))
	}
	if i.ShipmondoDeliveryOptionNEQ != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionNEQ(*i.ShipmondoDeliveryOptionNEQ))
	}
	if len(i.ShipmondoDeliveryOptionIn) > 0 {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionIn(i.ShipmondoDeliveryOptionIn...))
	}
	if len(i.ShipmondoDeliveryOptionNotIn) > 0 {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionNotIn(i.ShipmondoDeliveryOptionNotIn...))
	}
	if i.ShipmondoDeliveryOptionGT != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionGT(*i.ShipmondoDeliveryOptionGT))
	}
	if i.ShipmondoDeliveryOptionGTE != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionGTE(*i.ShipmondoDeliveryOptionGTE))
	}
	if i.ShipmondoDeliveryOptionLT != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionLT(*i.ShipmondoDeliveryOptionLT))
	}
	if i.ShipmondoDeliveryOptionLTE != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionLTE(*i.ShipmondoDeliveryOptionLTE))
	}
	if i.ShipmondoDeliveryOptionContains != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionContains(*i.ShipmondoDeliveryOptionContains))
	}
	if i.ShipmondoDeliveryOptionHasPrefix != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionHasPrefix(*i.ShipmondoDeliveryOptionHasPrefix))
	}
	if i.ShipmondoDeliveryOptionHasSuffix != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionHasSuffix(*i.ShipmondoDeliveryOptionHasSuffix))
	}
	if i.ShipmondoDeliveryOptionIsNil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionIsNil())
	}
	if i.ShipmondoDeliveryOptionNotNil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionNotNil())
	}
	if i.ShipmondoDeliveryOptionEqualFold != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionEqualFold(*i.ShipmondoDeliveryOptionEqualFold))
	}
	if i.ShipmondoDeliveryOptionContainsFold != nil {
		predicates = append(predicates, deliveryoption.ShipmondoDeliveryOptionContainsFold(*i.ShipmondoDeliveryOptionContainsFold))
	}
	if i.CustomsEnabled != nil {
		predicates = append(predicates, deliveryoption.CustomsEnabledEQ(*i.CustomsEnabled))
	}
	if i.CustomsEnabledNEQ != nil {
		predicates = append(predicates, deliveryoption.CustomsEnabledNEQ(*i.CustomsEnabledNEQ))
	}
	if i.CustomsSigner != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerEQ(*i.CustomsSigner))
	}
	if i.CustomsSignerNEQ != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerNEQ(*i.CustomsSignerNEQ))
	}
	if len(i.CustomsSignerIn) > 0 {
		predicates = append(predicates, deliveryoption.CustomsSignerIn(i.CustomsSignerIn...))
	}
	if len(i.CustomsSignerNotIn) > 0 {
		predicates = append(predicates, deliveryoption.CustomsSignerNotIn(i.CustomsSignerNotIn...))
	}
	if i.CustomsSignerGT != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerGT(*i.CustomsSignerGT))
	}
	if i.CustomsSignerGTE != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerGTE(*i.CustomsSignerGTE))
	}
	if i.CustomsSignerLT != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerLT(*i.CustomsSignerLT))
	}
	if i.CustomsSignerLTE != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerLTE(*i.CustomsSignerLTE))
	}
	if i.CustomsSignerContains != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerContains(*i.CustomsSignerContains))
	}
	if i.CustomsSignerHasPrefix != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerHasPrefix(*i.CustomsSignerHasPrefix))
	}
	if i.CustomsSignerHasSuffix != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerHasSuffix(*i.CustomsSignerHasSuffix))
	}
	if i.CustomsSignerIsNil {
		predicates = append(predicates, deliveryoption.CustomsSignerIsNil())
	}
	if i.CustomsSignerNotNil {
		predicates = append(predicates, deliveryoption.CustomsSignerNotNil())
	}
	if i.CustomsSignerEqualFold != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerEqualFold(*i.CustomsSignerEqualFold))
	}
	if i.CustomsSignerContainsFold != nil {
		predicates = append(predicates, deliveryoption.CustomsSignerContainsFold(*i.CustomsSignerContainsFold))
	}
	if i.HideIfCompanyEmpty != nil {
		predicates = append(predicates, deliveryoption.HideIfCompanyEmptyEQ(*i.HideIfCompanyEmpty))
	}
	if i.HideIfCompanyEmptyNEQ != nil {
		predicates = append(predicates, deliveryoption.HideIfCompanyEmptyNEQ(*i.HideIfCompanyEmptyNEQ))
	}

	if i.HasTenant != nil {
		p := deliveryoption.HasTenant()
		if !*i.HasTenant {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasTenantWith(with...))
	}
	if i.HasCarrier != nil {
		p := deliveryoption.HasCarrier()
		if !*i.HasCarrier {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasCarrierWith(with...))
	}
	if i.HasDeliveryRule != nil {
		p := deliveryoption.HasDeliveryRule()
		if !*i.HasDeliveryRule {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryRuleWith) > 0 {
		with := make([]predicate.DeliveryRule, 0, len(i.HasDeliveryRuleWith))
		for _, w := range i.HasDeliveryRuleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryRuleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasDeliveryRuleWith(with...))
	}
	if i.HasDeliveryOptionDAO != nil {
		p := deliveryoption.HasDeliveryOptionDAO()
		if !*i.HasDeliveryOptionDAO {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionDAOWith) > 0 {
		with := make([]predicate.DeliveryOptionDAO, 0, len(i.HasDeliveryOptionDAOWith))
		for _, w := range i.HasDeliveryOptionDAOWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionDAOWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasDeliveryOptionDAOWith(with...))
	}
	if i.HasDeliveryOptionDF != nil {
		p := deliveryoption.HasDeliveryOptionDF()
		if !*i.HasDeliveryOptionDF {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionDFWith) > 0 {
		with := make([]predicate.DeliveryOptionDF, 0, len(i.HasDeliveryOptionDFWith))
		for _, w := range i.HasDeliveryOptionDFWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionDFWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasDeliveryOptionDFWith(with...))
	}
	if i.HasDeliveryOptionDSV != nil {
		p := deliveryoption.HasDeliveryOptionDSV()
		if !*i.HasDeliveryOptionDSV {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionDSVWith) > 0 {
		with := make([]predicate.DeliveryOptionDSV, 0, len(i.HasDeliveryOptionDSVWith))
		for _, w := range i.HasDeliveryOptionDSVWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionDSVWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasDeliveryOptionDSVWith(with...))
	}
	if i.HasDeliveryOptionEasyPost != nil {
		p := deliveryoption.HasDeliveryOptionEasyPost()
		if !*i.HasDeliveryOptionEasyPost {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionEasyPostWith) > 0 {
		with := make([]predicate.DeliveryOptionEasyPost, 0, len(i.HasDeliveryOptionEasyPostWith))
		for _, w := range i.HasDeliveryOptionEasyPostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionEasyPostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasDeliveryOptionEasyPostWith(with...))
	}
	if i.HasDeliveryOptionGLS != nil {
		p := deliveryoption.HasDeliveryOptionGLS()
		if !*i.HasDeliveryOptionGLS {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionGLSWith) > 0 {
		with := make([]predicate.DeliveryOptionGLS, 0, len(i.HasDeliveryOptionGLSWith))
		for _, w := range i.HasDeliveryOptionGLSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionGLSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasDeliveryOptionGLSWith(with...))
	}
	if i.HasDeliveryOptionPostNord != nil {
		p := deliveryoption.HasDeliveryOptionPostNord()
		if !*i.HasDeliveryOptionPostNord {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionPostNordWith) > 0 {
		with := make([]predicate.DeliveryOptionPostNord, 0, len(i.HasDeliveryOptionPostNordWith))
		for _, w := range i.HasDeliveryOptionPostNordWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionPostNordWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasDeliveryOptionPostNordWith(with...))
	}
	if i.HasDeliveryOptionUSPS != nil {
		p := deliveryoption.HasDeliveryOptionUSPS()
		if !*i.HasDeliveryOptionUSPS {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionUSPSWith) > 0 {
		with := make([]predicate.DeliveryOptionUSPS, 0, len(i.HasDeliveryOptionUSPSWith))
		for _, w := range i.HasDeliveryOptionUSPSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionUSPSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasDeliveryOptionUSPSWith(with...))
	}
	if i.HasDeliveryOptionBring != nil {
		p := deliveryoption.HasDeliveryOptionBring()
		if !*i.HasDeliveryOptionBring {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionBringWith) > 0 {
		with := make([]predicate.DeliveryOptionBring, 0, len(i.HasDeliveryOptionBringWith))
		for _, w := range i.HasDeliveryOptionBringWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionBringWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasDeliveryOptionBringWith(with...))
	}
	if i.HasReturnPortals != nil {
		p := deliveryoption.HasReturnPortals()
		if !*i.HasReturnPortals {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalsWith) > 0 {
		with := make([]predicate.ReturnPortal, 0, len(i.HasReturnPortalsWith))
		for _, w := range i.HasReturnPortalsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasReturnPortalsWith(with...))
	}
	if i.HasColli != nil {
		p := deliveryoption.HasColli()
		if !*i.HasColli {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasColliWith))
		for _, w := range i.HasColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasColliWith(with...))
	}
	if i.HasReturnColli != nil {
		p := deliveryoption.HasReturnColli()
		if !*i.HasReturnColli {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnColliWith) > 0 {
		with := make([]predicate.ReturnColli, 0, len(i.HasReturnColliWith))
		for _, w := range i.HasReturnColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasReturnColliWith(with...))
	}
	if i.HasCarrierService != nil {
		p := deliveryoption.HasCarrierService()
		if !*i.HasCarrierService {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierServiceWith) > 0 {
		with := make([]predicate.CarrierService, 0, len(i.HasCarrierServiceWith))
		for _, w := range i.HasCarrierServiceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierServiceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasCarrierServiceWith(with...))
	}
	if i.HasConnection != nil {
		p := deliveryoption.HasConnection()
		if !*i.HasConnection {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionWith))
		for _, w := range i.HasConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasConnectionWith(with...))
	}
	if i.HasConnectionDefault != nil {
		p := deliveryoption.HasConnectionDefault()
		if !*i.HasConnectionDefault {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionDefaultWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionDefaultWith))
		for _, w := range i.HasConnectionDefaultWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionDefaultWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasConnectionDefaultWith(with...))
	}
	if i.HasHypothesisTestDeliveryOptionGroupOne != nil {
		p := deliveryoption.HasHypothesisTestDeliveryOptionGroupOne()
		if !*i.HasHypothesisTestDeliveryOptionGroupOne {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestDeliveryOptionGroupOneWith) > 0 {
		with := make([]predicate.HypothesisTestDeliveryOption, 0, len(i.HasHypothesisTestDeliveryOptionGroupOneWith))
		for _, w := range i.HasHypothesisTestDeliveryOptionGroupOneWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestDeliveryOptionGroupOneWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasHypothesisTestDeliveryOptionGroupOneWith(with...))
	}
	if i.HasHypothesisTestDeliveryOptionGroupTwo != nil {
		p := deliveryoption.HasHypothesisTestDeliveryOptionGroupTwo()
		if !*i.HasHypothesisTestDeliveryOptionGroupTwo {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestDeliveryOptionGroupTwoWith) > 0 {
		with := make([]predicate.HypothesisTestDeliveryOption, 0, len(i.HasHypothesisTestDeliveryOptionGroupTwoWith))
		for _, w := range i.HasHypothesisTestDeliveryOptionGroupTwoWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestDeliveryOptionGroupTwoWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasHypothesisTestDeliveryOptionGroupTwoWith(with...))
	}
	if i.HasHypothesisTestDeliveryOptionLookup != nil {
		p := deliveryoption.HasHypothesisTestDeliveryOptionLookup()
		if !*i.HasHypothesisTestDeliveryOptionLookup {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestDeliveryOptionLookupWith) > 0 {
		with := make([]predicate.HypothesisTestDeliveryOptionLookup, 0, len(i.HasHypothesisTestDeliveryOptionLookupWith))
		for _, w := range i.HasHypothesisTestDeliveryOptionLookupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestDeliveryOptionLookupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasHypothesisTestDeliveryOptionLookupWith(with...))
	}
	if i.HasClickCollectLocation != nil {
		p := deliveryoption.HasClickCollectLocation()
		if !*i.HasClickCollectLocation {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasClickCollectLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasClickCollectLocationWith))
		for _, w := range i.HasClickCollectLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasClickCollectLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasClickCollectLocationWith(with...))
	}
	if i.HasEmailClickCollectAtStore != nil {
		p := deliveryoption.HasEmailClickCollectAtStore()
		if !*i.HasEmailClickCollectAtStore {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmailClickCollectAtStoreWith) > 0 {
		with := make([]predicate.EmailTemplate, 0, len(i.HasEmailClickCollectAtStoreWith))
		for _, w := range i.HasEmailClickCollectAtStoreWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmailClickCollectAtStoreWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasEmailClickCollectAtStoreWith(with...))
	}
	if i.HasConsolidation != nil {
		p := deliveryoption.HasConsolidation()
		if !*i.HasConsolidation {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConsolidationWith) > 0 {
		with := make([]predicate.Consolidation, 0, len(i.HasConsolidationWith))
		for _, w := range i.HasConsolidationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConsolidationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasConsolidationWith(with...))
	}
	if i.HasDefaultPackaging != nil {
		p := deliveryoption.HasDefaultPackaging()
		if !*i.HasDefaultPackaging {
			p = deliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDefaultPackagingWith) > 0 {
		with := make([]predicate.Packaging, 0, len(i.HasDefaultPackagingWith))
		for _, w := range i.HasDefaultPackagingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDefaultPackagingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoption.HasDefaultPackagingWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryOptionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryoption.And(predicates...), nil
	}
}

// DeliveryOptionBringWhereInput represents a where input for filtering DeliveryOptionBring queries.
type DeliveryOptionBringWhereInput struct {
	Predicates []predicate.DeliveryOptionBring  `json:"-"`
	Not        *DeliveryOptionBringWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryOptionBringWhereInput `json:"or,omitempty"`
	And        []*DeliveryOptionBringWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "electronic_customs" field predicates.
	ElectronicCustoms    *bool `json:"electronicCustoms,omitempty"`
	ElectronicCustomsNEQ *bool `json:"electronicCustomsNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "carrier_additional_service_bring" edge predicates.
	HasCarrierAdditionalServiceBring     *bool                                      `json:"hasCarrierAdditionalServiceBring,omitempty"`
	HasCarrierAdditionalServiceBringWith []*CarrierAdditionalServiceBringWhereInput `json:"hasCarrierAdditionalServiceBringWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryOptionBringWhereInput) AddPredicates(predicates ...predicate.DeliveryOptionBring) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryOptionBringWhereInput filter on the DeliveryOptionBringQuery builder.
func (i *DeliveryOptionBringWhereInput) Filter(q *DeliveryOptionBringQuery) (*DeliveryOptionBringQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryOptionBringWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryOptionBringWhereInput is returned in case the DeliveryOptionBringWhereInput is empty.
var ErrEmptyDeliveryOptionBringWhereInput = errors.New("ent: empty predicate DeliveryOptionBringWhereInput")

// P returns a predicate for filtering deliveryoptionbrings.
// An error is returned if the input is empty or invalid.
func (i *DeliveryOptionBringWhereInput) P() (predicate.DeliveryOptionBring, error) {
	var predicates []predicate.DeliveryOptionBring
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryoptionbring.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryOptionBring, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryoptionbring.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryOptionBring, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryoptionbring.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryoptionbring.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryoptionbring.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryoptionbring.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryoptionbring.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryoptionbring.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryoptionbring.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryoptionbring.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryoptionbring.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryoptionbring.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryoptionbring.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryoptionbring.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ElectronicCustoms != nil {
		predicates = append(predicates, deliveryoptionbring.ElectronicCustomsEQ(*i.ElectronicCustoms))
	}
	if i.ElectronicCustomsNEQ != nil {
		predicates = append(predicates, deliveryoptionbring.ElectronicCustomsNEQ(*i.ElectronicCustomsNEQ))
	}

	if i.HasTenant != nil {
		p := deliveryoptionbring.HasTenant()
		if !*i.HasTenant {
			p = deliveryoptionbring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptionbring.HasTenantWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := deliveryoptionbring.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = deliveryoptionbring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptionbring.HasDeliveryOptionWith(with...))
	}
	if i.HasCarrierAdditionalServiceBring != nil {
		p := deliveryoptionbring.HasCarrierAdditionalServiceBring()
		if !*i.HasCarrierAdditionalServiceBring {
			p = deliveryoptionbring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceBringWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceBring, 0, len(i.HasCarrierAdditionalServiceBringWith))
		for _, w := range i.HasCarrierAdditionalServiceBringWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceBringWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptionbring.HasCarrierAdditionalServiceBringWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryOptionBringWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryoptionbring.And(predicates...), nil
	}
}

// DeliveryOptionDAOWhereInput represents a where input for filtering DeliveryOptionDAO queries.
type DeliveryOptionDAOWhereInput struct {
	Predicates []predicate.DeliveryOptionDAO  `json:"-"`
	Not        *DeliveryOptionDAOWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryOptionDAOWhereInput `json:"or,omitempty"`
	And        []*DeliveryOptionDAOWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "carrier_additional_service_dao" edge predicates.
	HasCarrierAdditionalServiceDAO     *bool                                    `json:"hasCarrierAdditionalServiceDAO,omitempty"`
	HasCarrierAdditionalServiceDAOWith []*CarrierAdditionalServiceDAOWhereInput `json:"hasCarrierAdditionalServiceDAOWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryOptionDAOWhereInput) AddPredicates(predicates ...predicate.DeliveryOptionDAO) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryOptionDAOWhereInput filter on the DeliveryOptionDAOQuery builder.
func (i *DeliveryOptionDAOWhereInput) Filter(q *DeliveryOptionDAOQuery) (*DeliveryOptionDAOQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryOptionDAOWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryOptionDAOWhereInput is returned in case the DeliveryOptionDAOWhereInput is empty.
var ErrEmptyDeliveryOptionDAOWhereInput = errors.New("ent: empty predicate DeliveryOptionDAOWhereInput")

// P returns a predicate for filtering deliveryoptiondaos.
// An error is returned if the input is empty or invalid.
func (i *DeliveryOptionDAOWhereInput) P() (predicate.DeliveryOptionDAO, error) {
	var predicates []predicate.DeliveryOptionDAO
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryoptiondao.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryOptionDAO, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryoptiondao.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryOptionDAO, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryoptiondao.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryoptiondao.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryoptiondao.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryoptiondao.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryoptiondao.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryoptiondao.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryoptiondao.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryoptiondao.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryoptiondao.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryoptiondao.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryoptiondao.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryoptiondao.TenantIDContainsFold(*i.TenantIDContainsFold))
	}

	if i.HasTenant != nil {
		p := deliveryoptiondao.HasTenant()
		if !*i.HasTenant {
			p = deliveryoptiondao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiondao.HasTenantWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := deliveryoptiondao.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = deliveryoptiondao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiondao.HasDeliveryOptionWith(with...))
	}
	if i.HasCarrierAdditionalServiceDAO != nil {
		p := deliveryoptiondao.HasCarrierAdditionalServiceDAO()
		if !*i.HasCarrierAdditionalServiceDAO {
			p = deliveryoptiondao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceDAOWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceDAO, 0, len(i.HasCarrierAdditionalServiceDAOWith))
		for _, w := range i.HasCarrierAdditionalServiceDAOWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceDAOWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiondao.HasCarrierAdditionalServiceDAOWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryOptionDAOWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryoptiondao.And(predicates...), nil
	}
}

// DeliveryOptionDFWhereInput represents a where input for filtering DeliveryOptionDF queries.
type DeliveryOptionDFWhereInput struct {
	Predicates []predicate.DeliveryOptionDF  `json:"-"`
	Not        *DeliveryOptionDFWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryOptionDFWhereInput `json:"or,omitempty"`
	And        []*DeliveryOptionDFWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "carrier_additional_service_df" edge predicates.
	HasCarrierAdditionalServiceDF     *bool                                   `json:"hasCarrierAdditionalServiceDF,omitempty"`
	HasCarrierAdditionalServiceDFWith []*CarrierAdditionalServiceDFWhereInput `json:"hasCarrierAdditionalServiceDFWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryOptionDFWhereInput) AddPredicates(predicates ...predicate.DeliveryOptionDF) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryOptionDFWhereInput filter on the DeliveryOptionDFQuery builder.
func (i *DeliveryOptionDFWhereInput) Filter(q *DeliveryOptionDFQuery) (*DeliveryOptionDFQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryOptionDFWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryOptionDFWhereInput is returned in case the DeliveryOptionDFWhereInput is empty.
var ErrEmptyDeliveryOptionDFWhereInput = errors.New("ent: empty predicate DeliveryOptionDFWhereInput")

// P returns a predicate for filtering deliveryoptiondfs.
// An error is returned if the input is empty or invalid.
func (i *DeliveryOptionDFWhereInput) P() (predicate.DeliveryOptionDF, error) {
	var predicates []predicate.DeliveryOptionDF
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryoptiondf.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryOptionDF, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryoptiondf.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryOptionDF, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryoptiondf.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryoptiondf.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryoptiondf.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryoptiondf.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryoptiondf.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryoptiondf.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryoptiondf.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryoptiondf.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryoptiondf.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryoptiondf.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryoptiondf.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryoptiondf.TenantIDContainsFold(*i.TenantIDContainsFold))
	}

	if i.HasTenant != nil {
		p := deliveryoptiondf.HasTenant()
		if !*i.HasTenant {
			p = deliveryoptiondf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiondf.HasTenantWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := deliveryoptiondf.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = deliveryoptiondf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiondf.HasDeliveryOptionWith(with...))
	}
	if i.HasCarrierAdditionalServiceDF != nil {
		p := deliveryoptiondf.HasCarrierAdditionalServiceDF()
		if !*i.HasCarrierAdditionalServiceDF {
			p = deliveryoptiondf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceDFWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceDF, 0, len(i.HasCarrierAdditionalServiceDFWith))
		for _, w := range i.HasCarrierAdditionalServiceDFWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceDFWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiondf.HasCarrierAdditionalServiceDFWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryOptionDFWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryoptiondf.And(predicates...), nil
	}
}

// DeliveryOptionDSVWhereInput represents a where input for filtering DeliveryOptionDSV queries.
type DeliveryOptionDSVWhereInput struct {
	Predicates []predicate.DeliveryOptionDSV  `json:"-"`
	Not        *DeliveryOptionDSVWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryOptionDSVWhereInput `json:"or,omitempty"`
	And        []*DeliveryOptionDSVWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "carrier_additional_service_dsv" edge predicates.
	HasCarrierAdditionalServiceDSV     *bool                                    `json:"hasCarrierAdditionalServiceDSV,omitempty"`
	HasCarrierAdditionalServiceDSVWith []*CarrierAdditionalServiceDSVWhereInput `json:"hasCarrierAdditionalServiceDSVWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryOptionDSVWhereInput) AddPredicates(predicates ...predicate.DeliveryOptionDSV) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryOptionDSVWhereInput filter on the DeliveryOptionDSVQuery builder.
func (i *DeliveryOptionDSVWhereInput) Filter(q *DeliveryOptionDSVQuery) (*DeliveryOptionDSVQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryOptionDSVWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryOptionDSVWhereInput is returned in case the DeliveryOptionDSVWhereInput is empty.
var ErrEmptyDeliveryOptionDSVWhereInput = errors.New("ent: empty predicate DeliveryOptionDSVWhereInput")

// P returns a predicate for filtering deliveryoptiondsvs.
// An error is returned if the input is empty or invalid.
func (i *DeliveryOptionDSVWhereInput) P() (predicate.DeliveryOptionDSV, error) {
	var predicates []predicate.DeliveryOptionDSV
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryoptiondsv.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryOptionDSV, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryoptiondsv.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryOptionDSV, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryoptiondsv.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryoptiondsv.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryoptiondsv.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryoptiondsv.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryoptiondsv.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryoptiondsv.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryoptiondsv.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryoptiondsv.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryoptiondsv.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryoptiondsv.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryoptiondsv.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryoptiondsv.TenantIDContainsFold(*i.TenantIDContainsFold))
	}

	if i.HasTenant != nil {
		p := deliveryoptiondsv.HasTenant()
		if !*i.HasTenant {
			p = deliveryoptiondsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiondsv.HasTenantWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := deliveryoptiondsv.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = deliveryoptiondsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiondsv.HasDeliveryOptionWith(with...))
	}
	if i.HasCarrierAdditionalServiceDSV != nil {
		p := deliveryoptiondsv.HasCarrierAdditionalServiceDSV()
		if !*i.HasCarrierAdditionalServiceDSV {
			p = deliveryoptiondsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceDSVWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceDSV, 0, len(i.HasCarrierAdditionalServiceDSVWith))
		for _, w := range i.HasCarrierAdditionalServiceDSVWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceDSVWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiondsv.HasCarrierAdditionalServiceDSVWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryOptionDSVWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryoptiondsv.And(predicates...), nil
	}
}

// DeliveryOptionEasyPostWhereInput represents a where input for filtering DeliveryOptionEasyPost queries.
type DeliveryOptionEasyPostWhereInput struct {
	Predicates []predicate.DeliveryOptionEasyPost  `json:"-"`
	Not        *DeliveryOptionEasyPostWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryOptionEasyPostWhereInput `json:"or,omitempty"`
	And        []*DeliveryOptionEasyPostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "carrier_add_serv_easy_post" edge predicates.
	HasCarrierAddServEasyPost     *bool                                         `json:"hasCarrierAddServEasyPost,omitempty"`
	HasCarrierAddServEasyPostWith []*CarrierAdditionalServiceEasyPostWhereInput `json:"hasCarrierAddServEasyPostWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryOptionEasyPostWhereInput) AddPredicates(predicates ...predicate.DeliveryOptionEasyPost) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryOptionEasyPostWhereInput filter on the DeliveryOptionEasyPostQuery builder.
func (i *DeliveryOptionEasyPostWhereInput) Filter(q *DeliveryOptionEasyPostQuery) (*DeliveryOptionEasyPostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryOptionEasyPostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryOptionEasyPostWhereInput is returned in case the DeliveryOptionEasyPostWhereInput is empty.
var ErrEmptyDeliveryOptionEasyPostWhereInput = errors.New("ent: empty predicate DeliveryOptionEasyPostWhereInput")

// P returns a predicate for filtering deliveryoptioneasyposts.
// An error is returned if the input is empty or invalid.
func (i *DeliveryOptionEasyPostWhereInput) P() (predicate.DeliveryOptionEasyPost, error) {
	var predicates []predicate.DeliveryOptionEasyPost
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryoptioneasypost.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryOptionEasyPost, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryoptioneasypost.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryOptionEasyPost, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryoptioneasypost.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryoptioneasypost.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryoptioneasypost.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryoptioneasypost.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryoptioneasypost.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryoptioneasypost.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryoptioneasypost.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryoptioneasypost.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryoptioneasypost.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryoptioneasypost.TenantIDContainsFold(*i.TenantIDContainsFold))
	}

	if i.HasTenant != nil {
		p := deliveryoptioneasypost.HasTenant()
		if !*i.HasTenant {
			p = deliveryoptioneasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptioneasypost.HasTenantWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := deliveryoptioneasypost.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = deliveryoptioneasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptioneasypost.HasDeliveryOptionWith(with...))
	}
	if i.HasCarrierAddServEasyPost != nil {
		p := deliveryoptioneasypost.HasCarrierAddServEasyPost()
		if !*i.HasCarrierAddServEasyPost {
			p = deliveryoptioneasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAddServEasyPostWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceEasyPost, 0, len(i.HasCarrierAddServEasyPostWith))
		for _, w := range i.HasCarrierAddServEasyPostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAddServEasyPostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptioneasypost.HasCarrierAddServEasyPostWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryOptionEasyPostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryoptioneasypost.And(predicates...), nil
	}
}

// DeliveryOptionGLSWhereInput represents a where input for filtering DeliveryOptionGLS queries.
type DeliveryOptionGLSWhereInput struct {
	Predicates []predicate.DeliveryOptionGLS  `json:"-"`
	Not        *DeliveryOptionGLSWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryOptionGLSWhereInput `json:"or,omitempty"`
	And        []*DeliveryOptionGLSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "carrier_additional_service_gls" edge predicates.
	HasCarrierAdditionalServiceGLS     *bool                                    `json:"hasCarrierAdditionalServiceGLS,omitempty"`
	HasCarrierAdditionalServiceGLSWith []*CarrierAdditionalServiceGLSWhereInput `json:"hasCarrierAdditionalServiceGLSWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryOptionGLSWhereInput) AddPredicates(predicates ...predicate.DeliveryOptionGLS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryOptionGLSWhereInput filter on the DeliveryOptionGLSQuery builder.
func (i *DeliveryOptionGLSWhereInput) Filter(q *DeliveryOptionGLSQuery) (*DeliveryOptionGLSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryOptionGLSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryOptionGLSWhereInput is returned in case the DeliveryOptionGLSWhereInput is empty.
var ErrEmptyDeliveryOptionGLSWhereInput = errors.New("ent: empty predicate DeliveryOptionGLSWhereInput")

// P returns a predicate for filtering deliveryoptionglss.
// An error is returned if the input is empty or invalid.
func (i *DeliveryOptionGLSWhereInput) P() (predicate.DeliveryOptionGLS, error) {
	var predicates []predicate.DeliveryOptionGLS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryoptiongls.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryOptionGLS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryoptiongls.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryOptionGLS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryoptiongls.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryoptiongls.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryoptiongls.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryoptiongls.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryoptiongls.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryoptiongls.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryoptiongls.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryoptiongls.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryoptiongls.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryoptiongls.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryoptiongls.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryoptiongls.TenantIDContainsFold(*i.TenantIDContainsFold))
	}

	if i.HasTenant != nil {
		p := deliveryoptiongls.HasTenant()
		if !*i.HasTenant {
			p = deliveryoptiongls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiongls.HasTenantWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := deliveryoptiongls.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = deliveryoptiongls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiongls.HasDeliveryOptionWith(with...))
	}
	if i.HasCarrierAdditionalServiceGLS != nil {
		p := deliveryoptiongls.HasCarrierAdditionalServiceGLS()
		if !*i.HasCarrierAdditionalServiceGLS {
			p = deliveryoptiongls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceGLSWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceGLS, 0, len(i.HasCarrierAdditionalServiceGLSWith))
		for _, w := range i.HasCarrierAdditionalServiceGLSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceGLSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptiongls.HasCarrierAdditionalServiceGLSWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryOptionGLSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryoptiongls.And(predicates...), nil
	}
}

// DeliveryOptionPostNordWhereInput represents a where input for filtering DeliveryOptionPostNord queries.
type DeliveryOptionPostNordWhereInput struct {
	Predicates []predicate.DeliveryOptionPostNord  `json:"-"`
	Not        *DeliveryOptionPostNordWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryOptionPostNordWhereInput `json:"or,omitempty"`
	And        []*DeliveryOptionPostNordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "format_zpl" field predicates.
	FormatZpl    *bool `json:"formatZpl,omitempty"`
	FormatZplNEQ *bool `json:"formatZplNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "carrier_add_serv_post_nord" edge predicates.
	HasCarrierAddServPostNord     *bool                                         `json:"hasCarrierAddServPostNord,omitempty"`
	HasCarrierAddServPostNordWith []*CarrierAdditionalServicePostNordWhereInput `json:"hasCarrierAddServPostNordWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryOptionPostNordWhereInput) AddPredicates(predicates ...predicate.DeliveryOptionPostNord) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryOptionPostNordWhereInput filter on the DeliveryOptionPostNordQuery builder.
func (i *DeliveryOptionPostNordWhereInput) Filter(q *DeliveryOptionPostNordQuery) (*DeliveryOptionPostNordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryOptionPostNordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryOptionPostNordWhereInput is returned in case the DeliveryOptionPostNordWhereInput is empty.
var ErrEmptyDeliveryOptionPostNordWhereInput = errors.New("ent: empty predicate DeliveryOptionPostNordWhereInput")

// P returns a predicate for filtering deliveryoptionpostnords.
// An error is returned if the input is empty or invalid.
func (i *DeliveryOptionPostNordWhereInput) P() (predicate.DeliveryOptionPostNord, error) {
	var predicates []predicate.DeliveryOptionPostNord
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryoptionpostnord.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryOptionPostNord, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryoptionpostnord.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryOptionPostNord, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryoptionpostnord.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryoptionpostnord.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryoptionpostnord.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryoptionpostnord.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryoptionpostnord.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryoptionpostnord.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryoptionpostnord.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryoptionpostnord.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryoptionpostnord.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryoptionpostnord.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.FormatZpl != nil {
		predicates = append(predicates, deliveryoptionpostnord.FormatZplEQ(*i.FormatZpl))
	}
	if i.FormatZplNEQ != nil {
		predicates = append(predicates, deliveryoptionpostnord.FormatZplNEQ(*i.FormatZplNEQ))
	}

	if i.HasTenant != nil {
		p := deliveryoptionpostnord.HasTenant()
		if !*i.HasTenant {
			p = deliveryoptionpostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptionpostnord.HasTenantWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := deliveryoptionpostnord.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = deliveryoptionpostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptionpostnord.HasDeliveryOptionWith(with...))
	}
	if i.HasCarrierAddServPostNord != nil {
		p := deliveryoptionpostnord.HasCarrierAddServPostNord()
		if !*i.HasCarrierAddServPostNord {
			p = deliveryoptionpostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAddServPostNordWith) > 0 {
		with := make([]predicate.CarrierAdditionalServicePostNord, 0, len(i.HasCarrierAddServPostNordWith))
		for _, w := range i.HasCarrierAddServPostNordWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAddServPostNordWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptionpostnord.HasCarrierAddServPostNordWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryOptionPostNordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryoptionpostnord.And(predicates...), nil
	}
}

// DeliveryOptionUSPSWhereInput represents a where input for filtering DeliveryOptionUSPS queries.
type DeliveryOptionUSPSWhereInput struct {
	Predicates []predicate.DeliveryOptionUSPS  `json:"-"`
	Not        *DeliveryOptionUSPSWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryOptionUSPSWhereInput `json:"or,omitempty"`
	And        []*DeliveryOptionUSPSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "format_zpl" field predicates.
	FormatZpl    *bool `json:"formatZpl,omitempty"`
	FormatZplNEQ *bool `json:"formatZplNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "carrier_additional_service_usps" edge predicates.
	HasCarrierAdditionalServiceUSPS     *bool                                     `json:"hasCarrierAdditionalServiceUSPS,omitempty"`
	HasCarrierAdditionalServiceUSPSWith []*CarrierAdditionalServiceUSPSWhereInput `json:"hasCarrierAdditionalServiceUSPSWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryOptionUSPSWhereInput) AddPredicates(predicates ...predicate.DeliveryOptionUSPS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryOptionUSPSWhereInput filter on the DeliveryOptionUSPSQuery builder.
func (i *DeliveryOptionUSPSWhereInput) Filter(q *DeliveryOptionUSPSQuery) (*DeliveryOptionUSPSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryOptionUSPSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryOptionUSPSWhereInput is returned in case the DeliveryOptionUSPSWhereInput is empty.
var ErrEmptyDeliveryOptionUSPSWhereInput = errors.New("ent: empty predicate DeliveryOptionUSPSWhereInput")

// P returns a predicate for filtering deliveryoptionuspss.
// An error is returned if the input is empty or invalid.
func (i *DeliveryOptionUSPSWhereInput) P() (predicate.DeliveryOptionUSPS, error) {
	var predicates []predicate.DeliveryOptionUSPS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryoptionusps.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryOptionUSPS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryoptionusps.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryOptionUSPS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryoptionusps.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryoptionusps.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryoptionusps.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryoptionusps.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryoptionusps.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryoptionusps.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryoptionusps.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryoptionusps.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryoptionusps.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryoptionusps.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryoptionusps.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryoptionusps.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.FormatZpl != nil {
		predicates = append(predicates, deliveryoptionusps.FormatZplEQ(*i.FormatZpl))
	}
	if i.FormatZplNEQ != nil {
		predicates = append(predicates, deliveryoptionusps.FormatZplNEQ(*i.FormatZplNEQ))
	}

	if i.HasTenant != nil {
		p := deliveryoptionusps.HasTenant()
		if !*i.HasTenant {
			p = deliveryoptionusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptionusps.HasTenantWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := deliveryoptionusps.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = deliveryoptionusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptionusps.HasDeliveryOptionWith(with...))
	}
	if i.HasCarrierAdditionalServiceUSPS != nil {
		p := deliveryoptionusps.HasCarrierAdditionalServiceUSPS()
		if !*i.HasCarrierAdditionalServiceUSPS {
			p = deliveryoptionusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierAdditionalServiceUSPSWith) > 0 {
		with := make([]predicate.CarrierAdditionalServiceUSPS, 0, len(i.HasCarrierAdditionalServiceUSPSWith))
		for _, w := range i.HasCarrierAdditionalServiceUSPSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierAdditionalServiceUSPSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryoptionusps.HasCarrierAdditionalServiceUSPSWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryOptionUSPSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryoptionusps.And(predicates...), nil
	}
}

// DeliveryRuleWhereInput represents a where input for filtering DeliveryRule queries.
type DeliveryRuleWhereInput struct {
	Predicates []predicate.DeliveryRule  `json:"-"`
	Not        *DeliveryRuleWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryRuleWhereInput `json:"or,omitempty"`
	And        []*DeliveryRuleWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "price" field predicates.
	Price      *float64  `json:"price,omitempty"`
	PriceNEQ   *float64  `json:"priceNEQ,omitempty"`
	PriceIn    []float64 `json:"priceIn,omitempty"`
	PriceNotIn []float64 `json:"priceNotIn,omitempty"`
	PriceGT    *float64  `json:"priceGT,omitempty"`
	PriceGTE   *float64  `json:"priceGTE,omitempty"`
	PriceLT    *float64  `json:"priceLT,omitempty"`
	PriceLTE   *float64  `json:"priceLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_rule_constraint_group" edge predicates.
	HasDeliveryRuleConstraintGroup     *bool                                    `json:"hasDeliveryRuleConstraintGroup,omitempty"`
	HasDeliveryRuleConstraintGroupWith []*DeliveryRuleConstraintGroupWhereInput `json:"hasDeliveryRuleConstraintGroupWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "country" edge predicates.
	HasCountry     *bool                `json:"hasCountry,omitempty"`
	HasCountryWith []*CountryWhereInput `json:"hasCountryWith,omitempty"`

	// "currency" edge predicates.
	HasCurrency     *bool                 `json:"hasCurrency,omitempty"`
	HasCurrencyWith []*CurrencyWhereInput `json:"hasCurrencyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryRuleWhereInput) AddPredicates(predicates ...predicate.DeliveryRule) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryRuleWhereInput filter on the DeliveryRuleQuery builder.
func (i *DeliveryRuleWhereInput) Filter(q *DeliveryRuleQuery) (*DeliveryRuleQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryRuleWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryRuleWhereInput is returned in case the DeliveryRuleWhereInput is empty.
var ErrEmptyDeliveryRuleWhereInput = errors.New("ent: empty predicate DeliveryRuleWhereInput")

// P returns a predicate for filtering deliveryrules.
// An error is returned if the input is empty or invalid.
func (i *DeliveryRuleWhereInput) P() (predicate.DeliveryRule, error) {
	var predicates []predicate.DeliveryRule
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryrule.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryRule, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryrule.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryRule, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryrule.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryrule.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryrule.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryrule.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryrule.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryrule.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryrule.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryrule.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryrule.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryrule.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryrule.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryrule.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryrule.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryrule.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryrule.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryrule.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryrule.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryrule.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryrule.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryrule.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryrule.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryrule.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, deliveryrule.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, deliveryrule.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, deliveryrule.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, deliveryrule.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, deliveryrule.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, deliveryrule.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, deliveryrule.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, deliveryrule.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, deliveryrule.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, deliveryrule.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, deliveryrule.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, deliveryrule.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, deliveryrule.NameContainsFold(*i.NameContainsFold))
	}
	if i.Price != nil {
		predicates = append(predicates, deliveryrule.PriceEQ(*i.Price))
	}
	if i.PriceNEQ != nil {
		predicates = append(predicates, deliveryrule.PriceNEQ(*i.PriceNEQ))
	}
	if len(i.PriceIn) > 0 {
		predicates = append(predicates, deliveryrule.PriceIn(i.PriceIn...))
	}
	if len(i.PriceNotIn) > 0 {
		predicates = append(predicates, deliveryrule.PriceNotIn(i.PriceNotIn...))
	}
	if i.PriceGT != nil {
		predicates = append(predicates, deliveryrule.PriceGT(*i.PriceGT))
	}
	if i.PriceGTE != nil {
		predicates = append(predicates, deliveryrule.PriceGTE(*i.PriceGTE))
	}
	if i.PriceLT != nil {
		predicates = append(predicates, deliveryrule.PriceLT(*i.PriceLT))
	}
	if i.PriceLTE != nil {
		predicates = append(predicates, deliveryrule.PriceLTE(*i.PriceLTE))
	}

	if i.HasTenant != nil {
		p := deliveryrule.HasTenant()
		if !*i.HasTenant {
			p = deliveryrule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryrule.HasTenantWith(with...))
	}
	if i.HasDeliveryRuleConstraintGroup != nil {
		p := deliveryrule.HasDeliveryRuleConstraintGroup()
		if !*i.HasDeliveryRuleConstraintGroup {
			p = deliveryrule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryRuleConstraintGroupWith) > 0 {
		with := make([]predicate.DeliveryRuleConstraintGroup, 0, len(i.HasDeliveryRuleConstraintGroupWith))
		for _, w := range i.HasDeliveryRuleConstraintGroupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryRuleConstraintGroupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryrule.HasDeliveryRuleConstraintGroupWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := deliveryrule.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = deliveryrule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryrule.HasDeliveryOptionWith(with...))
	}
	if i.HasCountry != nil {
		p := deliveryrule.HasCountry()
		if !*i.HasCountry {
			p = deliveryrule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryWith))
		for _, w := range i.HasCountryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryrule.HasCountryWith(with...))
	}
	if i.HasCurrency != nil {
		p := deliveryrule.HasCurrency()
		if !*i.HasCurrency {
			p = deliveryrule.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCurrencyWith) > 0 {
		with := make([]predicate.Currency, 0, len(i.HasCurrencyWith))
		for _, w := range i.HasCurrencyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCurrencyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryrule.HasCurrencyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryRuleWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryrule.And(predicates...), nil
	}
}

// DeliveryRuleConstraintWhereInput represents a where input for filtering DeliveryRuleConstraint queries.
type DeliveryRuleConstraintWhereInput struct {
	Predicates []predicate.DeliveryRuleConstraint  `json:"-"`
	Not        *DeliveryRuleConstraintWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryRuleConstraintWhereInput `json:"or,omitempty"`
	And        []*DeliveryRuleConstraintWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "property_type" field predicates.
	PropertyType      *deliveryruleconstraint.PropertyType  `json:"propertyType,omitempty"`
	PropertyTypeNEQ   *deliveryruleconstraint.PropertyType  `json:"propertyTypeNEQ,omitempty"`
	PropertyTypeIn    []deliveryruleconstraint.PropertyType `json:"propertyTypeIn,omitempty"`
	PropertyTypeNotIn []deliveryruleconstraint.PropertyType `json:"propertyTypeNotIn,omitempty"`

	// "comparison" field predicates.
	Comparison      *deliveryruleconstraint.Comparison  `json:"comparison,omitempty"`
	ComparisonNEQ   *deliveryruleconstraint.Comparison  `json:"comparisonNEQ,omitempty"`
	ComparisonIn    []deliveryruleconstraint.Comparison `json:"comparisonIn,omitempty"`
	ComparisonNotIn []deliveryruleconstraint.Comparison `json:"comparisonNotIn,omitempty"`

	// "selected_value" field predicates.
	SelectedValue      *fieldjson.DeliveryRuleConstraintSelectedValue   `json:"selectedValue,omitempty"`
	SelectedValueNEQ   *fieldjson.DeliveryRuleConstraintSelectedValue   `json:"selectedValueNEQ,omitempty"`
	SelectedValueIn    []*fieldjson.DeliveryRuleConstraintSelectedValue `json:"selectedValueIn,omitempty"`
	SelectedValueNotIn []*fieldjson.DeliveryRuleConstraintSelectedValue `json:"selectedValueNotIn,omitempty"`
	SelectedValueGT    *fieldjson.DeliveryRuleConstraintSelectedValue   `json:"selectedValueGT,omitempty"`
	SelectedValueGTE   *fieldjson.DeliveryRuleConstraintSelectedValue   `json:"selectedValueGTE,omitempty"`
	SelectedValueLT    *fieldjson.DeliveryRuleConstraintSelectedValue   `json:"selectedValueLT,omitempty"`
	SelectedValueLTE   *fieldjson.DeliveryRuleConstraintSelectedValue   `json:"selectedValueLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_rule_constraint_group" edge predicates.
	HasDeliveryRuleConstraintGroup     *bool                                    `json:"hasDeliveryRuleConstraintGroup,omitempty"`
	HasDeliveryRuleConstraintGroupWith []*DeliveryRuleConstraintGroupWhereInput `json:"hasDeliveryRuleConstraintGroupWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryRuleConstraintWhereInput) AddPredicates(predicates ...predicate.DeliveryRuleConstraint) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryRuleConstraintWhereInput filter on the DeliveryRuleConstraintQuery builder.
func (i *DeliveryRuleConstraintWhereInput) Filter(q *DeliveryRuleConstraintQuery) (*DeliveryRuleConstraintQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryRuleConstraintWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryRuleConstraintWhereInput is returned in case the DeliveryRuleConstraintWhereInput is empty.
var ErrEmptyDeliveryRuleConstraintWhereInput = errors.New("ent: empty predicate DeliveryRuleConstraintWhereInput")

// P returns a predicate for filtering deliveryruleconstraints.
// An error is returned if the input is empty or invalid.
func (i *DeliveryRuleConstraintWhereInput) P() (predicate.DeliveryRuleConstraint, error) {
	var predicates []predicate.DeliveryRuleConstraint
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryruleconstraint.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryRuleConstraint, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryruleconstraint.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryRuleConstraint, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryruleconstraint.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryruleconstraint.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryruleconstraint.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryruleconstraint.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryruleconstraint.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryruleconstraint.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryruleconstraint.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryruleconstraint.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryruleconstraint.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryruleconstraint.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryruleconstraint.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryruleconstraint.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.PropertyType != nil {
		predicates = append(predicates, deliveryruleconstraint.PropertyTypeEQ(*i.PropertyType))
	}
	if i.PropertyTypeNEQ != nil {
		predicates = append(predicates, deliveryruleconstraint.PropertyTypeNEQ(*i.PropertyTypeNEQ))
	}
	if len(i.PropertyTypeIn) > 0 {
		predicates = append(predicates, deliveryruleconstraint.PropertyTypeIn(i.PropertyTypeIn...))
	}
	if len(i.PropertyTypeNotIn) > 0 {
		predicates = append(predicates, deliveryruleconstraint.PropertyTypeNotIn(i.PropertyTypeNotIn...))
	}
	if i.Comparison != nil {
		predicates = append(predicates, deliveryruleconstraint.ComparisonEQ(*i.Comparison))
	}
	if i.ComparisonNEQ != nil {
		predicates = append(predicates, deliveryruleconstraint.ComparisonNEQ(*i.ComparisonNEQ))
	}
	if len(i.ComparisonIn) > 0 {
		predicates = append(predicates, deliveryruleconstraint.ComparisonIn(i.ComparisonIn...))
	}
	if len(i.ComparisonNotIn) > 0 {
		predicates = append(predicates, deliveryruleconstraint.ComparisonNotIn(i.ComparisonNotIn...))
	}
	if i.SelectedValue != nil {
		predicates = append(predicates, deliveryruleconstraint.SelectedValueEQ(i.SelectedValue))
	}
	if i.SelectedValueNEQ != nil {
		predicates = append(predicates, deliveryruleconstraint.SelectedValueNEQ(i.SelectedValueNEQ))
	}
	if len(i.SelectedValueIn) > 0 {
		predicates = append(predicates, deliveryruleconstraint.SelectedValueIn(i.SelectedValueIn...))
	}
	if len(i.SelectedValueNotIn) > 0 {
		predicates = append(predicates, deliveryruleconstraint.SelectedValueNotIn(i.SelectedValueNotIn...))
	}
	if i.SelectedValueGT != nil {
		predicates = append(predicates, deliveryruleconstraint.SelectedValueGT(i.SelectedValueGT))
	}
	if i.SelectedValueGTE != nil {
		predicates = append(predicates, deliveryruleconstraint.SelectedValueGTE(i.SelectedValueGTE))
	}
	if i.SelectedValueLT != nil {
		predicates = append(predicates, deliveryruleconstraint.SelectedValueLT(i.SelectedValueLT))
	}
	if i.SelectedValueLTE != nil {
		predicates = append(predicates, deliveryruleconstraint.SelectedValueLTE(i.SelectedValueLTE))
	}

	if i.HasTenant != nil {
		p := deliveryruleconstraint.HasTenant()
		if !*i.HasTenant {
			p = deliveryruleconstraint.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryruleconstraint.HasTenantWith(with...))
	}
	if i.HasDeliveryRuleConstraintGroup != nil {
		p := deliveryruleconstraint.HasDeliveryRuleConstraintGroup()
		if !*i.HasDeliveryRuleConstraintGroup {
			p = deliveryruleconstraint.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryRuleConstraintGroupWith) > 0 {
		with := make([]predicate.DeliveryRuleConstraintGroup, 0, len(i.HasDeliveryRuleConstraintGroupWith))
		for _, w := range i.HasDeliveryRuleConstraintGroupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryRuleConstraintGroupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryruleconstraint.HasDeliveryRuleConstraintGroupWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryRuleConstraintWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryruleconstraint.And(predicates...), nil
	}
}

// DeliveryRuleConstraintGroupWhereInput represents a where input for filtering DeliveryRuleConstraintGroup queries.
type DeliveryRuleConstraintGroupWhereInput struct {
	Predicates []predicate.DeliveryRuleConstraintGroup  `json:"-"`
	Not        *DeliveryRuleConstraintGroupWhereInput   `json:"not,omitempty"`
	Or         []*DeliveryRuleConstraintGroupWhereInput `json:"or,omitempty"`
	And        []*DeliveryRuleConstraintGroupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "constraint_logic" field predicates.
	ConstraintLogic      *deliveryruleconstraintgroup.ConstraintLogic  `json:"constraintLogic,omitempty"`
	ConstraintLogicNEQ   *deliveryruleconstraintgroup.ConstraintLogic  `json:"constraintLogicNEQ,omitempty"`
	ConstraintLogicIn    []deliveryruleconstraintgroup.ConstraintLogic `json:"constraintLogicIn,omitempty"`
	ConstraintLogicNotIn []deliveryruleconstraintgroup.ConstraintLogic `json:"constraintLogicNotIn,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_rule_constraints" edge predicates.
	HasDeliveryRuleConstraints     *bool                               `json:"hasDeliveryRuleConstraints,omitempty"`
	HasDeliveryRuleConstraintsWith []*DeliveryRuleConstraintWhereInput `json:"hasDeliveryRuleConstraintsWith,omitempty"`

	// "delivery_rule" edge predicates.
	HasDeliveryRule     *bool                     `json:"hasDeliveryRule,omitempty"`
	HasDeliveryRuleWith []*DeliveryRuleWhereInput `json:"hasDeliveryRuleWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DeliveryRuleConstraintGroupWhereInput) AddPredicates(predicates ...predicate.DeliveryRuleConstraintGroup) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DeliveryRuleConstraintGroupWhereInput filter on the DeliveryRuleConstraintGroupQuery builder.
func (i *DeliveryRuleConstraintGroupWhereInput) Filter(q *DeliveryRuleConstraintGroupQuery) (*DeliveryRuleConstraintGroupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDeliveryRuleConstraintGroupWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDeliveryRuleConstraintGroupWhereInput is returned in case the DeliveryRuleConstraintGroupWhereInput is empty.
var ErrEmptyDeliveryRuleConstraintGroupWhereInput = errors.New("ent: empty predicate DeliveryRuleConstraintGroupWhereInput")

// P returns a predicate for filtering deliveryruleconstraintgroups.
// An error is returned if the input is empty or invalid.
func (i *DeliveryRuleConstraintGroupWhereInput) P() (predicate.DeliveryRuleConstraintGroup, error) {
	var predicates []predicate.DeliveryRuleConstraintGroup
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, deliveryruleconstraintgroup.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DeliveryRuleConstraintGroup, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, deliveryruleconstraintgroup.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DeliveryRuleConstraintGroup, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, deliveryruleconstraintgroup.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, deliveryruleconstraintgroup.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, deliveryruleconstraintgroup.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ConstraintLogic != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.ConstraintLogicEQ(*i.ConstraintLogic))
	}
	if i.ConstraintLogicNEQ != nil {
		predicates = append(predicates, deliveryruleconstraintgroup.ConstraintLogicNEQ(*i.ConstraintLogicNEQ))
	}
	if len(i.ConstraintLogicIn) > 0 {
		predicates = append(predicates, deliveryruleconstraintgroup.ConstraintLogicIn(i.ConstraintLogicIn...))
	}
	if len(i.ConstraintLogicNotIn) > 0 {
		predicates = append(predicates, deliveryruleconstraintgroup.ConstraintLogicNotIn(i.ConstraintLogicNotIn...))
	}

	if i.HasTenant != nil {
		p := deliveryruleconstraintgroup.HasTenant()
		if !*i.HasTenant {
			p = deliveryruleconstraintgroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryruleconstraintgroup.HasTenantWith(with...))
	}
	if i.HasDeliveryRuleConstraints != nil {
		p := deliveryruleconstraintgroup.HasDeliveryRuleConstraints()
		if !*i.HasDeliveryRuleConstraints {
			p = deliveryruleconstraintgroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryRuleConstraintsWith) > 0 {
		with := make([]predicate.DeliveryRuleConstraint, 0, len(i.HasDeliveryRuleConstraintsWith))
		for _, w := range i.HasDeliveryRuleConstraintsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryRuleConstraintsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryruleconstraintgroup.HasDeliveryRuleConstraintsWith(with...))
	}
	if i.HasDeliveryRule != nil {
		p := deliveryruleconstraintgroup.HasDeliveryRule()
		if !*i.HasDeliveryRule {
			p = deliveryruleconstraintgroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryRuleWith) > 0 {
		with := make([]predicate.DeliveryRule, 0, len(i.HasDeliveryRuleWith))
		for _, w := range i.HasDeliveryRuleWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryRuleWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, deliveryruleconstraintgroup.HasDeliveryRuleWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDeliveryRuleConstraintGroupWhereInput
	case 1:
		return predicates[0], nil
	default:
		return deliveryruleconstraintgroup.And(predicates...), nil
	}
}

// DocumentWhereInput represents a where input for filtering Document queries.
type DocumentWhereInput struct {
	Predicates []predicate.Document  `json:"-"`
	Not        *DocumentWhereInput   `json:"not,omitempty"`
	Or         []*DocumentWhereInput `json:"or,omitempty"`
	And        []*DocumentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "html_template" field predicates.
	HTMLTemplate             *string  `json:"htmlTemplate,omitempty"`
	HTMLTemplateNEQ          *string  `json:"htmlTemplateNEQ,omitempty"`
	HTMLTemplateIn           []string `json:"htmlTemplateIn,omitempty"`
	HTMLTemplateNotIn        []string `json:"htmlTemplateNotIn,omitempty"`
	HTMLTemplateGT           *string  `json:"htmlTemplateGT,omitempty"`
	HTMLTemplateGTE          *string  `json:"htmlTemplateGTE,omitempty"`
	HTMLTemplateLT           *string  `json:"htmlTemplateLT,omitempty"`
	HTMLTemplateLTE          *string  `json:"htmlTemplateLTE,omitempty"`
	HTMLTemplateContains     *string  `json:"htmlTemplateContains,omitempty"`
	HTMLTemplateHasPrefix    *string  `json:"htmlTemplateHasPrefix,omitempty"`
	HTMLTemplateHasSuffix    *string  `json:"htmlTemplateHasSuffix,omitempty"`
	HTMLTemplateIsNil        bool     `json:"htmlTemplateIsNil,omitempty"`
	HTMLTemplateNotNil       bool     `json:"htmlTemplateNotNil,omitempty"`
	HTMLTemplateEqualFold    *string  `json:"htmlTemplateEqualFold,omitempty"`
	HTMLTemplateContainsFold *string  `json:"htmlTemplateContainsFold,omitempty"`

	// "html_header" field predicates.
	HTMLHeader             *string  `json:"htmlHeader,omitempty"`
	HTMLHeaderNEQ          *string  `json:"htmlHeaderNEQ,omitempty"`
	HTMLHeaderIn           []string `json:"htmlHeaderIn,omitempty"`
	HTMLHeaderNotIn        []string `json:"htmlHeaderNotIn,omitempty"`
	HTMLHeaderGT           *string  `json:"htmlHeaderGT,omitempty"`
	HTMLHeaderGTE          *string  `json:"htmlHeaderGTE,omitempty"`
	HTMLHeaderLT           *string  `json:"htmlHeaderLT,omitempty"`
	HTMLHeaderLTE          *string  `json:"htmlHeaderLTE,omitempty"`
	HTMLHeaderContains     *string  `json:"htmlHeaderContains,omitempty"`
	HTMLHeaderHasPrefix    *string  `json:"htmlHeaderHasPrefix,omitempty"`
	HTMLHeaderHasSuffix    *string  `json:"htmlHeaderHasSuffix,omitempty"`
	HTMLHeaderIsNil        bool     `json:"htmlHeaderIsNil,omitempty"`
	HTMLHeaderNotNil       bool     `json:"htmlHeaderNotNil,omitempty"`
	HTMLHeaderEqualFold    *string  `json:"htmlHeaderEqualFold,omitempty"`
	HTMLHeaderContainsFold *string  `json:"htmlHeaderContainsFold,omitempty"`

	// "html_footer" field predicates.
	HTMLFooter             *string  `json:"htmlFooter,omitempty"`
	HTMLFooterNEQ          *string  `json:"htmlFooterNEQ,omitempty"`
	HTMLFooterIn           []string `json:"htmlFooterIn,omitempty"`
	HTMLFooterNotIn        []string `json:"htmlFooterNotIn,omitempty"`
	HTMLFooterGT           *string  `json:"htmlFooterGT,omitempty"`
	HTMLFooterGTE          *string  `json:"htmlFooterGTE,omitempty"`
	HTMLFooterLT           *string  `json:"htmlFooterLT,omitempty"`
	HTMLFooterLTE          *string  `json:"htmlFooterLTE,omitempty"`
	HTMLFooterContains     *string  `json:"htmlFooterContains,omitempty"`
	HTMLFooterHasPrefix    *string  `json:"htmlFooterHasPrefix,omitempty"`
	HTMLFooterHasSuffix    *string  `json:"htmlFooterHasSuffix,omitempty"`
	HTMLFooterIsNil        bool     `json:"htmlFooterIsNil,omitempty"`
	HTMLFooterNotNil       bool     `json:"htmlFooterNotNil,omitempty"`
	HTMLFooterEqualFold    *string  `json:"htmlFooterEqualFold,omitempty"`
	HTMLFooterContainsFold *string  `json:"htmlFooterContainsFold,omitempty"`

	// "last_base64_pdf" field predicates.
	LastBase64Pdf             *string  `json:"lastBase64Pdf,omitempty"`
	LastBase64PdfNEQ          *string  `json:"lastBase64PdfNEQ,omitempty"`
	LastBase64PdfIn           []string `json:"lastBase64PdfIn,omitempty"`
	LastBase64PdfNotIn        []string `json:"lastBase64PdfNotIn,omitempty"`
	LastBase64PdfGT           *string  `json:"lastBase64PdfGT,omitempty"`
	LastBase64PdfGTE          *string  `json:"lastBase64PdfGTE,omitempty"`
	LastBase64PdfLT           *string  `json:"lastBase64PdfLT,omitempty"`
	LastBase64PdfLTE          *string  `json:"lastBase64PdfLTE,omitempty"`
	LastBase64PdfContains     *string  `json:"lastBase64PdfContains,omitempty"`
	LastBase64PdfHasPrefix    *string  `json:"lastBase64PdfHasPrefix,omitempty"`
	LastBase64PdfHasSuffix    *string  `json:"lastBase64PdfHasSuffix,omitempty"`
	LastBase64PdfIsNil        bool     `json:"lastBase64PdfIsNil,omitempty"`
	LastBase64PdfNotNil       bool     `json:"lastBase64PdfNotNil,omitempty"`
	LastBase64PdfEqualFold    *string  `json:"lastBase64PdfEqualFold,omitempty"`
	LastBase64PdfContainsFold *string  `json:"lastBase64PdfContainsFold,omitempty"`

	// "merge_type" field predicates.
	MergeType      *document.MergeType  `json:"mergeType,omitempty"`
	MergeTypeNEQ   *document.MergeType  `json:"mergeTypeNEQ,omitempty"`
	MergeTypeIn    []document.MergeType `json:"mergeTypeIn,omitempty"`
	MergeTypeNotIn []document.MergeType `json:"mergeTypeNotIn,omitempty"`

	// "paper_size" field predicates.
	PaperSize      *document.PaperSize  `json:"paperSize,omitempty"`
	PaperSizeNEQ   *document.PaperSize  `json:"paperSizeNEQ,omitempty"`
	PaperSizeIn    []document.PaperSize `json:"paperSizeIn,omitempty"`
	PaperSizeNotIn []document.PaperSize `json:"paperSizeNotIn,omitempty"`

	// "start_at" field predicates.
	StartAt      *time.Time  `json:"startAt,omitempty"`
	StartAtNEQ   *time.Time  `json:"startAtNEQ,omitempty"`
	StartAtIn    []time.Time `json:"startAtIn,omitempty"`
	StartAtNotIn []time.Time `json:"startAtNotIn,omitempty"`
	StartAtGT    *time.Time  `json:"startAtGT,omitempty"`
	StartAtGTE   *time.Time  `json:"startAtGTE,omitempty"`
	StartAtLT    *time.Time  `json:"startAtLT,omitempty"`
	StartAtLTE   *time.Time  `json:"startAtLTE,omitempty"`

	// "end_at" field predicates.
	EndAt      *time.Time  `json:"endAt,omitempty"`
	EndAtNEQ   *time.Time  `json:"endAtNEQ,omitempty"`
	EndAtIn    []time.Time `json:"endAtIn,omitempty"`
	EndAtNotIn []time.Time `json:"endAtNotIn,omitempty"`
	EndAtGT    *time.Time  `json:"endAtGT,omitempty"`
	EndAtGTE   *time.Time  `json:"endAtGTE,omitempty"`
	EndAtLT    *time.Time  `json:"endAtLT,omitempty"`
	EndAtLTE   *time.Time  `json:"endAtLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier_brand" edge predicates.
	HasCarrierBrand     *bool                     `json:"hasCarrierBrand,omitempty"`
	HasCarrierBrandWith []*CarrierBrandWhereInput `json:"hasCarrierBrandWith,omitempty"`

	// "connection_packing_slip" edge predicates.
	HasConnectionPackingSlip     *bool                   `json:"hasConnectionPackingSlip,omitempty"`
	HasConnectionPackingSlipWith []*ConnectionWhereInput `json:"hasConnectionPackingSlipWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DocumentWhereInput) AddPredicates(predicates ...predicate.Document) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DocumentWhereInput filter on the DocumentQuery builder.
func (i *DocumentWhereInput) Filter(q *DocumentQuery) (*DocumentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDocumentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDocumentWhereInput is returned in case the DocumentWhereInput is empty.
var ErrEmptyDocumentWhereInput = errors.New("ent: empty predicate DocumentWhereInput")

// P returns a predicate for filtering documents.
// An error is returned if the input is empty or invalid.
func (i *DocumentWhereInput) P() (predicate.Document, error) {
	var predicates []predicate.Document
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, document.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Document, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, document.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Document, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, document.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, document.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, document.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, document.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, document.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, document.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, document.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, document.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, document.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, document.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, document.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, document.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, document.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, document.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, document.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, document.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, document.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, document.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, document.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, document.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, document.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, document.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, document.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, document.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, document.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, document.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, document.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, document.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, document.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, document.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, document.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, document.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, document.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, document.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, document.NameContainsFold(*i.NameContainsFold))
	}
	if i.HTMLTemplate != nil {
		predicates = append(predicates, document.HTMLTemplateEQ(*i.HTMLTemplate))
	}
	if i.HTMLTemplateNEQ != nil {
		predicates = append(predicates, document.HTMLTemplateNEQ(*i.HTMLTemplateNEQ))
	}
	if len(i.HTMLTemplateIn) > 0 {
		predicates = append(predicates, document.HTMLTemplateIn(i.HTMLTemplateIn...))
	}
	if len(i.HTMLTemplateNotIn) > 0 {
		predicates = append(predicates, document.HTMLTemplateNotIn(i.HTMLTemplateNotIn...))
	}
	if i.HTMLTemplateGT != nil {
		predicates = append(predicates, document.HTMLTemplateGT(*i.HTMLTemplateGT))
	}
	if i.HTMLTemplateGTE != nil {
		predicates = append(predicates, document.HTMLTemplateGTE(*i.HTMLTemplateGTE))
	}
	if i.HTMLTemplateLT != nil {
		predicates = append(predicates, document.HTMLTemplateLT(*i.HTMLTemplateLT))
	}
	if i.HTMLTemplateLTE != nil {
		predicates = append(predicates, document.HTMLTemplateLTE(*i.HTMLTemplateLTE))
	}
	if i.HTMLTemplateContains != nil {
		predicates = append(predicates, document.HTMLTemplateContains(*i.HTMLTemplateContains))
	}
	if i.HTMLTemplateHasPrefix != nil {
		predicates = append(predicates, document.HTMLTemplateHasPrefix(*i.HTMLTemplateHasPrefix))
	}
	if i.HTMLTemplateHasSuffix != nil {
		predicates = append(predicates, document.HTMLTemplateHasSuffix(*i.HTMLTemplateHasSuffix))
	}
	if i.HTMLTemplateIsNil {
		predicates = append(predicates, document.HTMLTemplateIsNil())
	}
	if i.HTMLTemplateNotNil {
		predicates = append(predicates, document.HTMLTemplateNotNil())
	}
	if i.HTMLTemplateEqualFold != nil {
		predicates = append(predicates, document.HTMLTemplateEqualFold(*i.HTMLTemplateEqualFold))
	}
	if i.HTMLTemplateContainsFold != nil {
		predicates = append(predicates, document.HTMLTemplateContainsFold(*i.HTMLTemplateContainsFold))
	}
	if i.HTMLHeader != nil {
		predicates = append(predicates, document.HTMLHeaderEQ(*i.HTMLHeader))
	}
	if i.HTMLHeaderNEQ != nil {
		predicates = append(predicates, document.HTMLHeaderNEQ(*i.HTMLHeaderNEQ))
	}
	if len(i.HTMLHeaderIn) > 0 {
		predicates = append(predicates, document.HTMLHeaderIn(i.HTMLHeaderIn...))
	}
	if len(i.HTMLHeaderNotIn) > 0 {
		predicates = append(predicates, document.HTMLHeaderNotIn(i.HTMLHeaderNotIn...))
	}
	if i.HTMLHeaderGT != nil {
		predicates = append(predicates, document.HTMLHeaderGT(*i.HTMLHeaderGT))
	}
	if i.HTMLHeaderGTE != nil {
		predicates = append(predicates, document.HTMLHeaderGTE(*i.HTMLHeaderGTE))
	}
	if i.HTMLHeaderLT != nil {
		predicates = append(predicates, document.HTMLHeaderLT(*i.HTMLHeaderLT))
	}
	if i.HTMLHeaderLTE != nil {
		predicates = append(predicates, document.HTMLHeaderLTE(*i.HTMLHeaderLTE))
	}
	if i.HTMLHeaderContains != nil {
		predicates = append(predicates, document.HTMLHeaderContains(*i.HTMLHeaderContains))
	}
	if i.HTMLHeaderHasPrefix != nil {
		predicates = append(predicates, document.HTMLHeaderHasPrefix(*i.HTMLHeaderHasPrefix))
	}
	if i.HTMLHeaderHasSuffix != nil {
		predicates = append(predicates, document.HTMLHeaderHasSuffix(*i.HTMLHeaderHasSuffix))
	}
	if i.HTMLHeaderIsNil {
		predicates = append(predicates, document.HTMLHeaderIsNil())
	}
	if i.HTMLHeaderNotNil {
		predicates = append(predicates, document.HTMLHeaderNotNil())
	}
	if i.HTMLHeaderEqualFold != nil {
		predicates = append(predicates, document.HTMLHeaderEqualFold(*i.HTMLHeaderEqualFold))
	}
	if i.HTMLHeaderContainsFold != nil {
		predicates = append(predicates, document.HTMLHeaderContainsFold(*i.HTMLHeaderContainsFold))
	}
	if i.HTMLFooter != nil {
		predicates = append(predicates, document.HTMLFooterEQ(*i.HTMLFooter))
	}
	if i.HTMLFooterNEQ != nil {
		predicates = append(predicates, document.HTMLFooterNEQ(*i.HTMLFooterNEQ))
	}
	if len(i.HTMLFooterIn) > 0 {
		predicates = append(predicates, document.HTMLFooterIn(i.HTMLFooterIn...))
	}
	if len(i.HTMLFooterNotIn) > 0 {
		predicates = append(predicates, document.HTMLFooterNotIn(i.HTMLFooterNotIn...))
	}
	if i.HTMLFooterGT != nil {
		predicates = append(predicates, document.HTMLFooterGT(*i.HTMLFooterGT))
	}
	if i.HTMLFooterGTE != nil {
		predicates = append(predicates, document.HTMLFooterGTE(*i.HTMLFooterGTE))
	}
	if i.HTMLFooterLT != nil {
		predicates = append(predicates, document.HTMLFooterLT(*i.HTMLFooterLT))
	}
	if i.HTMLFooterLTE != nil {
		predicates = append(predicates, document.HTMLFooterLTE(*i.HTMLFooterLTE))
	}
	if i.HTMLFooterContains != nil {
		predicates = append(predicates, document.HTMLFooterContains(*i.HTMLFooterContains))
	}
	if i.HTMLFooterHasPrefix != nil {
		predicates = append(predicates, document.HTMLFooterHasPrefix(*i.HTMLFooterHasPrefix))
	}
	if i.HTMLFooterHasSuffix != nil {
		predicates = append(predicates, document.HTMLFooterHasSuffix(*i.HTMLFooterHasSuffix))
	}
	if i.HTMLFooterIsNil {
		predicates = append(predicates, document.HTMLFooterIsNil())
	}
	if i.HTMLFooterNotNil {
		predicates = append(predicates, document.HTMLFooterNotNil())
	}
	if i.HTMLFooterEqualFold != nil {
		predicates = append(predicates, document.HTMLFooterEqualFold(*i.HTMLFooterEqualFold))
	}
	if i.HTMLFooterContainsFold != nil {
		predicates = append(predicates, document.HTMLFooterContainsFold(*i.HTMLFooterContainsFold))
	}
	if i.LastBase64Pdf != nil {
		predicates = append(predicates, document.LastBase64PdfEQ(*i.LastBase64Pdf))
	}
	if i.LastBase64PdfNEQ != nil {
		predicates = append(predicates, document.LastBase64PdfNEQ(*i.LastBase64PdfNEQ))
	}
	if len(i.LastBase64PdfIn) > 0 {
		predicates = append(predicates, document.LastBase64PdfIn(i.LastBase64PdfIn...))
	}
	if len(i.LastBase64PdfNotIn) > 0 {
		predicates = append(predicates, document.LastBase64PdfNotIn(i.LastBase64PdfNotIn...))
	}
	if i.LastBase64PdfGT != nil {
		predicates = append(predicates, document.LastBase64PdfGT(*i.LastBase64PdfGT))
	}
	if i.LastBase64PdfGTE != nil {
		predicates = append(predicates, document.LastBase64PdfGTE(*i.LastBase64PdfGTE))
	}
	if i.LastBase64PdfLT != nil {
		predicates = append(predicates, document.LastBase64PdfLT(*i.LastBase64PdfLT))
	}
	if i.LastBase64PdfLTE != nil {
		predicates = append(predicates, document.LastBase64PdfLTE(*i.LastBase64PdfLTE))
	}
	if i.LastBase64PdfContains != nil {
		predicates = append(predicates, document.LastBase64PdfContains(*i.LastBase64PdfContains))
	}
	if i.LastBase64PdfHasPrefix != nil {
		predicates = append(predicates, document.LastBase64PdfHasPrefix(*i.LastBase64PdfHasPrefix))
	}
	if i.LastBase64PdfHasSuffix != nil {
		predicates = append(predicates, document.LastBase64PdfHasSuffix(*i.LastBase64PdfHasSuffix))
	}
	if i.LastBase64PdfIsNil {
		predicates = append(predicates, document.LastBase64PdfIsNil())
	}
	if i.LastBase64PdfNotNil {
		predicates = append(predicates, document.LastBase64PdfNotNil())
	}
	if i.LastBase64PdfEqualFold != nil {
		predicates = append(predicates, document.LastBase64PdfEqualFold(*i.LastBase64PdfEqualFold))
	}
	if i.LastBase64PdfContainsFold != nil {
		predicates = append(predicates, document.LastBase64PdfContainsFold(*i.LastBase64PdfContainsFold))
	}
	if i.MergeType != nil {
		predicates = append(predicates, document.MergeTypeEQ(*i.MergeType))
	}
	if i.MergeTypeNEQ != nil {
		predicates = append(predicates, document.MergeTypeNEQ(*i.MergeTypeNEQ))
	}
	if len(i.MergeTypeIn) > 0 {
		predicates = append(predicates, document.MergeTypeIn(i.MergeTypeIn...))
	}
	if len(i.MergeTypeNotIn) > 0 {
		predicates = append(predicates, document.MergeTypeNotIn(i.MergeTypeNotIn...))
	}
	if i.PaperSize != nil {
		predicates = append(predicates, document.PaperSizeEQ(*i.PaperSize))
	}
	if i.PaperSizeNEQ != nil {
		predicates = append(predicates, document.PaperSizeNEQ(*i.PaperSizeNEQ))
	}
	if len(i.PaperSizeIn) > 0 {
		predicates = append(predicates, document.PaperSizeIn(i.PaperSizeIn...))
	}
	if len(i.PaperSizeNotIn) > 0 {
		predicates = append(predicates, document.PaperSizeNotIn(i.PaperSizeNotIn...))
	}
	if i.StartAt != nil {
		predicates = append(predicates, document.StartAtEQ(*i.StartAt))
	}
	if i.StartAtNEQ != nil {
		predicates = append(predicates, document.StartAtNEQ(*i.StartAtNEQ))
	}
	if len(i.StartAtIn) > 0 {
		predicates = append(predicates, document.StartAtIn(i.StartAtIn...))
	}
	if len(i.StartAtNotIn) > 0 {
		predicates = append(predicates, document.StartAtNotIn(i.StartAtNotIn...))
	}
	if i.StartAtGT != nil {
		predicates = append(predicates, document.StartAtGT(*i.StartAtGT))
	}
	if i.StartAtGTE != nil {
		predicates = append(predicates, document.StartAtGTE(*i.StartAtGTE))
	}
	if i.StartAtLT != nil {
		predicates = append(predicates, document.StartAtLT(*i.StartAtLT))
	}
	if i.StartAtLTE != nil {
		predicates = append(predicates, document.StartAtLTE(*i.StartAtLTE))
	}
	if i.EndAt != nil {
		predicates = append(predicates, document.EndAtEQ(*i.EndAt))
	}
	if i.EndAtNEQ != nil {
		predicates = append(predicates, document.EndAtNEQ(*i.EndAtNEQ))
	}
	if len(i.EndAtIn) > 0 {
		predicates = append(predicates, document.EndAtIn(i.EndAtIn...))
	}
	if len(i.EndAtNotIn) > 0 {
		predicates = append(predicates, document.EndAtNotIn(i.EndAtNotIn...))
	}
	if i.EndAtGT != nil {
		predicates = append(predicates, document.EndAtGT(*i.EndAtGT))
	}
	if i.EndAtGTE != nil {
		predicates = append(predicates, document.EndAtGTE(*i.EndAtGTE))
	}
	if i.EndAtLT != nil {
		predicates = append(predicates, document.EndAtLT(*i.EndAtLT))
	}
	if i.EndAtLTE != nil {
		predicates = append(predicates, document.EndAtLTE(*i.EndAtLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, document.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, document.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, document.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, document.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, document.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, document.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, document.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, document.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasTenant != nil {
		p := document.HasTenant()
		if !*i.HasTenant {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasTenantWith(with...))
	}
	if i.HasCarrierBrand != nil {
		p := document.HasCarrierBrand()
		if !*i.HasCarrierBrand {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierBrandWith) > 0 {
		with := make([]predicate.CarrierBrand, 0, len(i.HasCarrierBrandWith))
		for _, w := range i.HasCarrierBrandWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierBrandWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasCarrierBrandWith(with...))
	}
	if i.HasConnectionPackingSlip != nil {
		p := document.HasConnectionPackingSlip()
		if !*i.HasConnectionPackingSlip {
			p = document.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionPackingSlipWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionPackingSlipWith))
		for _, w := range i.HasConnectionPackingSlipWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionPackingSlipWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, document.HasConnectionPackingSlipWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDocumentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return document.And(predicates...), nil
	}
}

// DocumentFileWhereInput represents a where input for filtering DocumentFile queries.
type DocumentFileWhereInput struct {
	Predicates []predicate.DocumentFile  `json:"-"`
	Not        *DocumentFileWhereInput   `json:"not,omitempty"`
	Or         []*DocumentFileWhereInput `json:"or,omitempty"`
	And        []*DocumentFileWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "storage_type" field predicates.
	StorageType      *documentfile.StorageType  `json:"storageType,omitempty"`
	StorageTypeNEQ   *documentfile.StorageType  `json:"storageTypeNEQ,omitempty"`
	StorageTypeIn    []documentfile.StorageType `json:"storageTypeIn,omitempty"`
	StorageTypeNotIn []documentfile.StorageType `json:"storageTypeNotIn,omitempty"`

	// "storage_path" field predicates.
	StoragePath             *string  `json:"storagePath,omitempty"`
	StoragePathNEQ          *string  `json:"storagePathNEQ,omitempty"`
	StoragePathIn           []string `json:"storagePathIn,omitempty"`
	StoragePathNotIn        []string `json:"storagePathNotIn,omitempty"`
	StoragePathGT           *string  `json:"storagePathGT,omitempty"`
	StoragePathGTE          *string  `json:"storagePathGTE,omitempty"`
	StoragePathLT           *string  `json:"storagePathLT,omitempty"`
	StoragePathLTE          *string  `json:"storagePathLTE,omitempty"`
	StoragePathContains     *string  `json:"storagePathContains,omitempty"`
	StoragePathHasPrefix    *string  `json:"storagePathHasPrefix,omitempty"`
	StoragePathHasSuffix    *string  `json:"storagePathHasSuffix,omitempty"`
	StoragePathIsNil        bool     `json:"storagePathIsNil,omitempty"`
	StoragePathNotNil       bool     `json:"storagePathNotNil,omitempty"`
	StoragePathEqualFold    *string  `json:"storagePathEqualFold,omitempty"`
	StoragePathContainsFold *string  `json:"storagePathContainsFold,omitempty"`

	// "storage_path_zpl" field predicates.
	StoragePathZpl             *string  `json:"storagePathZpl,omitempty"`
	StoragePathZplNEQ          *string  `json:"storagePathZplNEQ,omitempty"`
	StoragePathZplIn           []string `json:"storagePathZplIn,omitempty"`
	StoragePathZplNotIn        []string `json:"storagePathZplNotIn,omitempty"`
	StoragePathZplGT           *string  `json:"storagePathZplGT,omitempty"`
	StoragePathZplGTE          *string  `json:"storagePathZplGTE,omitempty"`
	StoragePathZplLT           *string  `json:"storagePathZplLT,omitempty"`
	StoragePathZplLTE          *string  `json:"storagePathZplLTE,omitempty"`
	StoragePathZplContains     *string  `json:"storagePathZplContains,omitempty"`
	StoragePathZplHasPrefix    *string  `json:"storagePathZplHasPrefix,omitempty"`
	StoragePathZplHasSuffix    *string  `json:"storagePathZplHasSuffix,omitempty"`
	StoragePathZplIsNil        bool     `json:"storagePathZplIsNil,omitempty"`
	StoragePathZplNotNil       bool     `json:"storagePathZplNotNil,omitempty"`
	StoragePathZplEqualFold    *string  `json:"storagePathZplEqualFold,omitempty"`
	StoragePathZplContainsFold *string  `json:"storagePathZplContainsFold,omitempty"`

	// "doc_type" field predicates.
	DocType      *documentfile.DocType  `json:"docType,omitempty"`
	DocTypeNEQ   *documentfile.DocType  `json:"docTypeNEQ,omitempty"`
	DocTypeIn    []documentfile.DocType `json:"docTypeIn,omitempty"`
	DocTypeNotIn []documentfile.DocType `json:"docTypeNotIn,omitempty"`

	// "data_pdf_base64" field predicates.
	DataPdfBase64             *string  `json:"dataPdfBase64,omitempty"`
	DataPdfBase64NEQ          *string  `json:"dataPdfBase64NEQ,omitempty"`
	DataPdfBase64In           []string `json:"dataPdfBase64In,omitempty"`
	DataPdfBase64NotIn        []string `json:"dataPdfBase64NotIn,omitempty"`
	DataPdfBase64GT           *string  `json:"dataPdfBase64GT,omitempty"`
	DataPdfBase64GTE          *string  `json:"dataPdfBase64GTE,omitempty"`
	DataPdfBase64LT           *string  `json:"dataPdfBase64LT,omitempty"`
	DataPdfBase64LTE          *string  `json:"dataPdfBase64LTE,omitempty"`
	DataPdfBase64Contains     *string  `json:"dataPdfBase64Contains,omitempty"`
	DataPdfBase64HasPrefix    *string  `json:"dataPdfBase64HasPrefix,omitempty"`
	DataPdfBase64HasSuffix    *string  `json:"dataPdfBase64HasSuffix,omitempty"`
	DataPdfBase64IsNil        bool     `json:"dataPdfBase64IsNil,omitempty"`
	DataPdfBase64NotNil       bool     `json:"dataPdfBase64NotNil,omitempty"`
	DataPdfBase64EqualFold    *string  `json:"dataPdfBase64EqualFold,omitempty"`
	DataPdfBase64ContainsFold *string  `json:"dataPdfBase64ContainsFold,omitempty"`

	// "data_zpl_base64" field predicates.
	DataZplBase64             *string  `json:"dataZplBase64,omitempty"`
	DataZplBase64NEQ          *string  `json:"dataZplBase64NEQ,omitempty"`
	DataZplBase64In           []string `json:"dataZplBase64In,omitempty"`
	DataZplBase64NotIn        []string `json:"dataZplBase64NotIn,omitempty"`
	DataZplBase64GT           *string  `json:"dataZplBase64GT,omitempty"`
	DataZplBase64GTE          *string  `json:"dataZplBase64GTE,omitempty"`
	DataZplBase64LT           *string  `json:"dataZplBase64LT,omitempty"`
	DataZplBase64LTE          *string  `json:"dataZplBase64LTE,omitempty"`
	DataZplBase64Contains     *string  `json:"dataZplBase64Contains,omitempty"`
	DataZplBase64HasPrefix    *string  `json:"dataZplBase64HasPrefix,omitempty"`
	DataZplBase64HasSuffix    *string  `json:"dataZplBase64HasSuffix,omitempty"`
	DataZplBase64IsNil        bool     `json:"dataZplBase64IsNil,omitempty"`
	DataZplBase64NotNil       bool     `json:"dataZplBase64NotNil,omitempty"`
	DataZplBase64EqualFold    *string  `json:"dataZplBase64EqualFold,omitempty"`
	DataZplBase64ContainsFold *string  `json:"dataZplBase64ContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "colli" edge predicates.
	HasColli     *bool              `json:"hasColli,omitempty"`
	HasColliWith []*ColliWhereInput `json:"hasColliWith,omitempty"`

	// "shipment_parcel" edge predicates.
	HasShipmentParcel     *bool                       `json:"hasShipmentParcel,omitempty"`
	HasShipmentParcelWith []*ShipmentParcelWhereInput `json:"hasShipmentParcelWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *DocumentFileWhereInput) AddPredicates(predicates ...predicate.DocumentFile) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the DocumentFileWhereInput filter on the DocumentFileQuery builder.
func (i *DocumentFileWhereInput) Filter(q *DocumentFileQuery) (*DocumentFileQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyDocumentFileWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyDocumentFileWhereInput is returned in case the DocumentFileWhereInput is empty.
var ErrEmptyDocumentFileWhereInput = errors.New("ent: empty predicate DocumentFileWhereInput")

// P returns a predicate for filtering documentfiles.
// An error is returned if the input is empty or invalid.
func (i *DocumentFileWhereInput) P() (predicate.DocumentFile, error) {
	var predicates []predicate.DocumentFile
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, documentfile.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.DocumentFile, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, documentfile.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.DocumentFile, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, documentfile.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, documentfile.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, documentfile.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, documentfile.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, documentfile.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, documentfile.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, documentfile.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, documentfile.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, documentfile.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, documentfile.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, documentfile.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, documentfile.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, documentfile.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, documentfile.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, documentfile.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, documentfile.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, documentfile.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, documentfile.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, documentfile.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, documentfile.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, documentfile.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, documentfile.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, documentfile.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, documentfile.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, documentfile.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, documentfile.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, documentfile.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, documentfile.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, documentfile.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, documentfile.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.StorageType != nil {
		predicates = append(predicates, documentfile.StorageTypeEQ(*i.StorageType))
	}
	if i.StorageTypeNEQ != nil {
		predicates = append(predicates, documentfile.StorageTypeNEQ(*i.StorageTypeNEQ))
	}
	if len(i.StorageTypeIn) > 0 {
		predicates = append(predicates, documentfile.StorageTypeIn(i.StorageTypeIn...))
	}
	if len(i.StorageTypeNotIn) > 0 {
		predicates = append(predicates, documentfile.StorageTypeNotIn(i.StorageTypeNotIn...))
	}
	if i.StoragePath != nil {
		predicates = append(predicates, documentfile.StoragePathEQ(*i.StoragePath))
	}
	if i.StoragePathNEQ != nil {
		predicates = append(predicates, documentfile.StoragePathNEQ(*i.StoragePathNEQ))
	}
	if len(i.StoragePathIn) > 0 {
		predicates = append(predicates, documentfile.StoragePathIn(i.StoragePathIn...))
	}
	if len(i.StoragePathNotIn) > 0 {
		predicates = append(predicates, documentfile.StoragePathNotIn(i.StoragePathNotIn...))
	}
	if i.StoragePathGT != nil {
		predicates = append(predicates, documentfile.StoragePathGT(*i.StoragePathGT))
	}
	if i.StoragePathGTE != nil {
		predicates = append(predicates, documentfile.StoragePathGTE(*i.StoragePathGTE))
	}
	if i.StoragePathLT != nil {
		predicates = append(predicates, documentfile.StoragePathLT(*i.StoragePathLT))
	}
	if i.StoragePathLTE != nil {
		predicates = append(predicates, documentfile.StoragePathLTE(*i.StoragePathLTE))
	}
	if i.StoragePathContains != nil {
		predicates = append(predicates, documentfile.StoragePathContains(*i.StoragePathContains))
	}
	if i.StoragePathHasPrefix != nil {
		predicates = append(predicates, documentfile.StoragePathHasPrefix(*i.StoragePathHasPrefix))
	}
	if i.StoragePathHasSuffix != nil {
		predicates = append(predicates, documentfile.StoragePathHasSuffix(*i.StoragePathHasSuffix))
	}
	if i.StoragePathIsNil {
		predicates = append(predicates, documentfile.StoragePathIsNil())
	}
	if i.StoragePathNotNil {
		predicates = append(predicates, documentfile.StoragePathNotNil())
	}
	if i.StoragePathEqualFold != nil {
		predicates = append(predicates, documentfile.StoragePathEqualFold(*i.StoragePathEqualFold))
	}
	if i.StoragePathContainsFold != nil {
		predicates = append(predicates, documentfile.StoragePathContainsFold(*i.StoragePathContainsFold))
	}
	if i.StoragePathZpl != nil {
		predicates = append(predicates, documentfile.StoragePathZplEQ(*i.StoragePathZpl))
	}
	if i.StoragePathZplNEQ != nil {
		predicates = append(predicates, documentfile.StoragePathZplNEQ(*i.StoragePathZplNEQ))
	}
	if len(i.StoragePathZplIn) > 0 {
		predicates = append(predicates, documentfile.StoragePathZplIn(i.StoragePathZplIn...))
	}
	if len(i.StoragePathZplNotIn) > 0 {
		predicates = append(predicates, documentfile.StoragePathZplNotIn(i.StoragePathZplNotIn...))
	}
	if i.StoragePathZplGT != nil {
		predicates = append(predicates, documentfile.StoragePathZplGT(*i.StoragePathZplGT))
	}
	if i.StoragePathZplGTE != nil {
		predicates = append(predicates, documentfile.StoragePathZplGTE(*i.StoragePathZplGTE))
	}
	if i.StoragePathZplLT != nil {
		predicates = append(predicates, documentfile.StoragePathZplLT(*i.StoragePathZplLT))
	}
	if i.StoragePathZplLTE != nil {
		predicates = append(predicates, documentfile.StoragePathZplLTE(*i.StoragePathZplLTE))
	}
	if i.StoragePathZplContains != nil {
		predicates = append(predicates, documentfile.StoragePathZplContains(*i.StoragePathZplContains))
	}
	if i.StoragePathZplHasPrefix != nil {
		predicates = append(predicates, documentfile.StoragePathZplHasPrefix(*i.StoragePathZplHasPrefix))
	}
	if i.StoragePathZplHasSuffix != nil {
		predicates = append(predicates, documentfile.StoragePathZplHasSuffix(*i.StoragePathZplHasSuffix))
	}
	if i.StoragePathZplIsNil {
		predicates = append(predicates, documentfile.StoragePathZplIsNil())
	}
	if i.StoragePathZplNotNil {
		predicates = append(predicates, documentfile.StoragePathZplNotNil())
	}
	if i.StoragePathZplEqualFold != nil {
		predicates = append(predicates, documentfile.StoragePathZplEqualFold(*i.StoragePathZplEqualFold))
	}
	if i.StoragePathZplContainsFold != nil {
		predicates = append(predicates, documentfile.StoragePathZplContainsFold(*i.StoragePathZplContainsFold))
	}
	if i.DocType != nil {
		predicates = append(predicates, documentfile.DocTypeEQ(*i.DocType))
	}
	if i.DocTypeNEQ != nil {
		predicates = append(predicates, documentfile.DocTypeNEQ(*i.DocTypeNEQ))
	}
	if len(i.DocTypeIn) > 0 {
		predicates = append(predicates, documentfile.DocTypeIn(i.DocTypeIn...))
	}
	if len(i.DocTypeNotIn) > 0 {
		predicates = append(predicates, documentfile.DocTypeNotIn(i.DocTypeNotIn...))
	}
	if i.DataPdfBase64 != nil {
		predicates = append(predicates, documentfile.DataPdfBase64EQ(*i.DataPdfBase64))
	}
	if i.DataPdfBase64NEQ != nil {
		predicates = append(predicates, documentfile.DataPdfBase64NEQ(*i.DataPdfBase64NEQ))
	}
	if len(i.DataPdfBase64In) > 0 {
		predicates = append(predicates, documentfile.DataPdfBase64In(i.DataPdfBase64In...))
	}
	if len(i.DataPdfBase64NotIn) > 0 {
		predicates = append(predicates, documentfile.DataPdfBase64NotIn(i.DataPdfBase64NotIn...))
	}
	if i.DataPdfBase64GT != nil {
		predicates = append(predicates, documentfile.DataPdfBase64GT(*i.DataPdfBase64GT))
	}
	if i.DataPdfBase64GTE != nil {
		predicates = append(predicates, documentfile.DataPdfBase64GTE(*i.DataPdfBase64GTE))
	}
	if i.DataPdfBase64LT != nil {
		predicates = append(predicates, documentfile.DataPdfBase64LT(*i.DataPdfBase64LT))
	}
	if i.DataPdfBase64LTE != nil {
		predicates = append(predicates, documentfile.DataPdfBase64LTE(*i.DataPdfBase64LTE))
	}
	if i.DataPdfBase64Contains != nil {
		predicates = append(predicates, documentfile.DataPdfBase64Contains(*i.DataPdfBase64Contains))
	}
	if i.DataPdfBase64HasPrefix != nil {
		predicates = append(predicates, documentfile.DataPdfBase64HasPrefix(*i.DataPdfBase64HasPrefix))
	}
	if i.DataPdfBase64HasSuffix != nil {
		predicates = append(predicates, documentfile.DataPdfBase64HasSuffix(*i.DataPdfBase64HasSuffix))
	}
	if i.DataPdfBase64IsNil {
		predicates = append(predicates, documentfile.DataPdfBase64IsNil())
	}
	if i.DataPdfBase64NotNil {
		predicates = append(predicates, documentfile.DataPdfBase64NotNil())
	}
	if i.DataPdfBase64EqualFold != nil {
		predicates = append(predicates, documentfile.DataPdfBase64EqualFold(*i.DataPdfBase64EqualFold))
	}
	if i.DataPdfBase64ContainsFold != nil {
		predicates = append(predicates, documentfile.DataPdfBase64ContainsFold(*i.DataPdfBase64ContainsFold))
	}
	if i.DataZplBase64 != nil {
		predicates = append(predicates, documentfile.DataZplBase64EQ(*i.DataZplBase64))
	}
	if i.DataZplBase64NEQ != nil {
		predicates = append(predicates, documentfile.DataZplBase64NEQ(*i.DataZplBase64NEQ))
	}
	if len(i.DataZplBase64In) > 0 {
		predicates = append(predicates, documentfile.DataZplBase64In(i.DataZplBase64In...))
	}
	if len(i.DataZplBase64NotIn) > 0 {
		predicates = append(predicates, documentfile.DataZplBase64NotIn(i.DataZplBase64NotIn...))
	}
	if i.DataZplBase64GT != nil {
		predicates = append(predicates, documentfile.DataZplBase64GT(*i.DataZplBase64GT))
	}
	if i.DataZplBase64GTE != nil {
		predicates = append(predicates, documentfile.DataZplBase64GTE(*i.DataZplBase64GTE))
	}
	if i.DataZplBase64LT != nil {
		predicates = append(predicates, documentfile.DataZplBase64LT(*i.DataZplBase64LT))
	}
	if i.DataZplBase64LTE != nil {
		predicates = append(predicates, documentfile.DataZplBase64LTE(*i.DataZplBase64LTE))
	}
	if i.DataZplBase64Contains != nil {
		predicates = append(predicates, documentfile.DataZplBase64Contains(*i.DataZplBase64Contains))
	}
	if i.DataZplBase64HasPrefix != nil {
		predicates = append(predicates, documentfile.DataZplBase64HasPrefix(*i.DataZplBase64HasPrefix))
	}
	if i.DataZplBase64HasSuffix != nil {
		predicates = append(predicates, documentfile.DataZplBase64HasSuffix(*i.DataZplBase64HasSuffix))
	}
	if i.DataZplBase64IsNil {
		predicates = append(predicates, documentfile.DataZplBase64IsNil())
	}
	if i.DataZplBase64NotNil {
		predicates = append(predicates, documentfile.DataZplBase64NotNil())
	}
	if i.DataZplBase64EqualFold != nil {
		predicates = append(predicates, documentfile.DataZplBase64EqualFold(*i.DataZplBase64EqualFold))
	}
	if i.DataZplBase64ContainsFold != nil {
		predicates = append(predicates, documentfile.DataZplBase64ContainsFold(*i.DataZplBase64ContainsFold))
	}

	if i.HasTenant != nil {
		p := documentfile.HasTenant()
		if !*i.HasTenant {
			p = documentfile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, documentfile.HasTenantWith(with...))
	}
	if i.HasColli != nil {
		p := documentfile.HasColli()
		if !*i.HasColli {
			p = documentfile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasColliWith))
		for _, w := range i.HasColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, documentfile.HasColliWith(with...))
	}
	if i.HasShipmentParcel != nil {
		p := documentfile.HasShipmentParcel()
		if !*i.HasShipmentParcel {
			p = documentfile.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentParcelWith) > 0 {
		with := make([]predicate.ShipmentParcel, 0, len(i.HasShipmentParcelWith))
		for _, w := range i.HasShipmentParcelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentParcelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, documentfile.HasShipmentParcelWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyDocumentFileWhereInput
	case 1:
		return predicates[0], nil
	default:
		return documentfile.And(predicates...), nil
	}
}

// EmailTemplateWhereInput represents a where input for filtering EmailTemplate queries.
type EmailTemplateWhereInput struct {
	Predicates []predicate.EmailTemplate  `json:"-"`
	Not        *EmailTemplateWhereInput   `json:"not,omitempty"`
	Or         []*EmailTemplateWhereInput `json:"or,omitempty"`
	And        []*EmailTemplateWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "subject" field predicates.
	Subject             *string  `json:"subject,omitempty"`
	SubjectNEQ          *string  `json:"subjectNEQ,omitempty"`
	SubjectIn           []string `json:"subjectIn,omitempty"`
	SubjectNotIn        []string `json:"subjectNotIn,omitempty"`
	SubjectGT           *string  `json:"subjectGT,omitempty"`
	SubjectGTE          *string  `json:"subjectGTE,omitempty"`
	SubjectLT           *string  `json:"subjectLT,omitempty"`
	SubjectLTE          *string  `json:"subjectLTE,omitempty"`
	SubjectContains     *string  `json:"subjectContains,omitempty"`
	SubjectHasPrefix    *string  `json:"subjectHasPrefix,omitempty"`
	SubjectHasSuffix    *string  `json:"subjectHasSuffix,omitempty"`
	SubjectEqualFold    *string  `json:"subjectEqualFold,omitempty"`
	SubjectContainsFold *string  `json:"subjectContainsFold,omitempty"`

	// "html_template" field predicates.
	HTMLTemplate             *string  `json:"htmlTemplate,omitempty"`
	HTMLTemplateNEQ          *string  `json:"htmlTemplateNEQ,omitempty"`
	HTMLTemplateIn           []string `json:"htmlTemplateIn,omitempty"`
	HTMLTemplateNotIn        []string `json:"htmlTemplateNotIn,omitempty"`
	HTMLTemplateGT           *string  `json:"htmlTemplateGT,omitempty"`
	HTMLTemplateGTE          *string  `json:"htmlTemplateGTE,omitempty"`
	HTMLTemplateLT           *string  `json:"htmlTemplateLT,omitempty"`
	HTMLTemplateLTE          *string  `json:"htmlTemplateLTE,omitempty"`
	HTMLTemplateContains     *string  `json:"htmlTemplateContains,omitempty"`
	HTMLTemplateHasPrefix    *string  `json:"htmlTemplateHasPrefix,omitempty"`
	HTMLTemplateHasSuffix    *string  `json:"htmlTemplateHasSuffix,omitempty"`
	HTMLTemplateEqualFold    *string  `json:"htmlTemplateEqualFold,omitempty"`
	HTMLTemplateContainsFold *string  `json:"htmlTemplateContainsFold,omitempty"`

	// "merge_type" field predicates.
	MergeType      *emailtemplate.MergeType  `json:"mergeType,omitempty"`
	MergeTypeNEQ   *emailtemplate.MergeType  `json:"mergeTypeNEQ,omitempty"`
	MergeTypeIn    []emailtemplate.MergeType `json:"mergeTypeIn,omitempty"`
	MergeTypeNotIn []emailtemplate.MergeType `json:"mergeTypeNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "return_portal_confirmation_label" edge predicates.
	HasReturnPortalConfirmationLabel     *bool                     `json:"hasReturnPortalConfirmationLabel,omitempty"`
	HasReturnPortalConfirmationLabelWith []*ReturnPortalWhereInput `json:"hasReturnPortalConfirmationLabelWith,omitempty"`

	// "return_portal_confirmation_qr_code" edge predicates.
	HasReturnPortalConfirmationQrCode     *bool                     `json:"hasReturnPortalConfirmationQrCode,omitempty"`
	HasReturnPortalConfirmationQrCodeWith []*ReturnPortalWhereInput `json:"hasReturnPortalConfirmationQrCodeWith,omitempty"`

	// "return_portal_received" edge predicates.
	HasReturnPortalReceived     *bool                     `json:"hasReturnPortalReceived,omitempty"`
	HasReturnPortalReceivedWith []*ReturnPortalWhereInput `json:"hasReturnPortalReceivedWith,omitempty"`

	// "return_portal_accepted" edge predicates.
	HasReturnPortalAccepted     *bool                     `json:"hasReturnPortalAccepted,omitempty"`
	HasReturnPortalAcceptedWith []*ReturnPortalWhereInput `json:"hasReturnPortalAcceptedWith,omitempty"`

	// "delivery_option_click_collect_at_store" edge predicates.
	HasDeliveryOptionClickCollectAtStore     *bool                       `json:"hasDeliveryOptionClickCollectAtStore,omitempty"`
	HasDeliveryOptionClickCollectAtStoreWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionClickCollectAtStoreWith,omitempty"`

	// "notifications" edge predicates.
	HasNotifications     *bool                     `json:"hasNotifications,omitempty"`
	HasNotificationsWith []*NotificationWhereInput `json:"hasNotificationsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *EmailTemplateWhereInput) AddPredicates(predicates ...predicate.EmailTemplate) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the EmailTemplateWhereInput filter on the EmailTemplateQuery builder.
func (i *EmailTemplateWhereInput) Filter(q *EmailTemplateQuery) (*EmailTemplateQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyEmailTemplateWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyEmailTemplateWhereInput is returned in case the EmailTemplateWhereInput is empty.
var ErrEmptyEmailTemplateWhereInput = errors.New("ent: empty predicate EmailTemplateWhereInput")

// P returns a predicate for filtering emailtemplates.
// An error is returned if the input is empty or invalid.
func (i *EmailTemplateWhereInput) P() (predicate.EmailTemplate, error) {
	var predicates []predicate.EmailTemplate
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, emailtemplate.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.EmailTemplate, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, emailtemplate.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.EmailTemplate, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, emailtemplate.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, emailtemplate.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, emailtemplate.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, emailtemplate.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, emailtemplate.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, emailtemplate.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, emailtemplate.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, emailtemplate.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, emailtemplate.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, emailtemplate.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, emailtemplate.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, emailtemplate.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, emailtemplate.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, emailtemplate.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, emailtemplate.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, emailtemplate.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, emailtemplate.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, emailtemplate.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, emailtemplate.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, emailtemplate.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, emailtemplate.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, emailtemplate.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, emailtemplate.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, emailtemplate.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, emailtemplate.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, emailtemplate.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, emailtemplate.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, emailtemplate.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, emailtemplate.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, emailtemplate.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, emailtemplate.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, emailtemplate.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, emailtemplate.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, emailtemplate.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, emailtemplate.NameContainsFold(*i.NameContainsFold))
	}
	if i.Subject != nil {
		predicates = append(predicates, emailtemplate.SubjectEQ(*i.Subject))
	}
	if i.SubjectNEQ != nil {
		predicates = append(predicates, emailtemplate.SubjectNEQ(*i.SubjectNEQ))
	}
	if len(i.SubjectIn) > 0 {
		predicates = append(predicates, emailtemplate.SubjectIn(i.SubjectIn...))
	}
	if len(i.SubjectNotIn) > 0 {
		predicates = append(predicates, emailtemplate.SubjectNotIn(i.SubjectNotIn...))
	}
	if i.SubjectGT != nil {
		predicates = append(predicates, emailtemplate.SubjectGT(*i.SubjectGT))
	}
	if i.SubjectGTE != nil {
		predicates = append(predicates, emailtemplate.SubjectGTE(*i.SubjectGTE))
	}
	if i.SubjectLT != nil {
		predicates = append(predicates, emailtemplate.SubjectLT(*i.SubjectLT))
	}
	if i.SubjectLTE != nil {
		predicates = append(predicates, emailtemplate.SubjectLTE(*i.SubjectLTE))
	}
	if i.SubjectContains != nil {
		predicates = append(predicates, emailtemplate.SubjectContains(*i.SubjectContains))
	}
	if i.SubjectHasPrefix != nil {
		predicates = append(predicates, emailtemplate.SubjectHasPrefix(*i.SubjectHasPrefix))
	}
	if i.SubjectHasSuffix != nil {
		predicates = append(predicates, emailtemplate.SubjectHasSuffix(*i.SubjectHasSuffix))
	}
	if i.SubjectEqualFold != nil {
		predicates = append(predicates, emailtemplate.SubjectEqualFold(*i.SubjectEqualFold))
	}
	if i.SubjectContainsFold != nil {
		predicates = append(predicates, emailtemplate.SubjectContainsFold(*i.SubjectContainsFold))
	}
	if i.HTMLTemplate != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateEQ(*i.HTMLTemplate))
	}
	if i.HTMLTemplateNEQ != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateNEQ(*i.HTMLTemplateNEQ))
	}
	if len(i.HTMLTemplateIn) > 0 {
		predicates = append(predicates, emailtemplate.HTMLTemplateIn(i.HTMLTemplateIn...))
	}
	if len(i.HTMLTemplateNotIn) > 0 {
		predicates = append(predicates, emailtemplate.HTMLTemplateNotIn(i.HTMLTemplateNotIn...))
	}
	if i.HTMLTemplateGT != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateGT(*i.HTMLTemplateGT))
	}
	if i.HTMLTemplateGTE != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateGTE(*i.HTMLTemplateGTE))
	}
	if i.HTMLTemplateLT != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateLT(*i.HTMLTemplateLT))
	}
	if i.HTMLTemplateLTE != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateLTE(*i.HTMLTemplateLTE))
	}
	if i.HTMLTemplateContains != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateContains(*i.HTMLTemplateContains))
	}
	if i.HTMLTemplateHasPrefix != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateHasPrefix(*i.HTMLTemplateHasPrefix))
	}
	if i.HTMLTemplateHasSuffix != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateHasSuffix(*i.HTMLTemplateHasSuffix))
	}
	if i.HTMLTemplateEqualFold != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateEqualFold(*i.HTMLTemplateEqualFold))
	}
	if i.HTMLTemplateContainsFold != nil {
		predicates = append(predicates, emailtemplate.HTMLTemplateContainsFold(*i.HTMLTemplateContainsFold))
	}
	if i.MergeType != nil {
		predicates = append(predicates, emailtemplate.MergeTypeEQ(*i.MergeType))
	}
	if i.MergeTypeNEQ != nil {
		predicates = append(predicates, emailtemplate.MergeTypeNEQ(*i.MergeTypeNEQ))
	}
	if len(i.MergeTypeIn) > 0 {
		predicates = append(predicates, emailtemplate.MergeTypeIn(i.MergeTypeIn...))
	}
	if len(i.MergeTypeNotIn) > 0 {
		predicates = append(predicates, emailtemplate.MergeTypeNotIn(i.MergeTypeNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, emailtemplate.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, emailtemplate.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, emailtemplate.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, emailtemplate.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, emailtemplate.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, emailtemplate.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, emailtemplate.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, emailtemplate.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, emailtemplate.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, emailtemplate.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, emailtemplate.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, emailtemplate.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, emailtemplate.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, emailtemplate.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, emailtemplate.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, emailtemplate.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, emailtemplate.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, emailtemplate.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasTenant != nil {
		p := emailtemplate.HasTenant()
		if !*i.HasTenant {
			p = emailtemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, emailtemplate.HasTenantWith(with...))
	}
	if i.HasReturnPortalConfirmationLabel != nil {
		p := emailtemplate.HasReturnPortalConfirmationLabel()
		if !*i.HasReturnPortalConfirmationLabel {
			p = emailtemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalConfirmationLabelWith) > 0 {
		with := make([]predicate.ReturnPortal, 0, len(i.HasReturnPortalConfirmationLabelWith))
		for _, w := range i.HasReturnPortalConfirmationLabelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalConfirmationLabelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, emailtemplate.HasReturnPortalConfirmationLabelWith(with...))
	}
	if i.HasReturnPortalConfirmationQrCode != nil {
		p := emailtemplate.HasReturnPortalConfirmationQrCode()
		if !*i.HasReturnPortalConfirmationQrCode {
			p = emailtemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalConfirmationQrCodeWith) > 0 {
		with := make([]predicate.ReturnPortal, 0, len(i.HasReturnPortalConfirmationQrCodeWith))
		for _, w := range i.HasReturnPortalConfirmationQrCodeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalConfirmationQrCodeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, emailtemplate.HasReturnPortalConfirmationQrCodeWith(with...))
	}
	if i.HasReturnPortalReceived != nil {
		p := emailtemplate.HasReturnPortalReceived()
		if !*i.HasReturnPortalReceived {
			p = emailtemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalReceivedWith) > 0 {
		with := make([]predicate.ReturnPortal, 0, len(i.HasReturnPortalReceivedWith))
		for _, w := range i.HasReturnPortalReceivedWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalReceivedWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, emailtemplate.HasReturnPortalReceivedWith(with...))
	}
	if i.HasReturnPortalAccepted != nil {
		p := emailtemplate.HasReturnPortalAccepted()
		if !*i.HasReturnPortalAccepted {
			p = emailtemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalAcceptedWith) > 0 {
		with := make([]predicate.ReturnPortal, 0, len(i.HasReturnPortalAcceptedWith))
		for _, w := range i.HasReturnPortalAcceptedWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalAcceptedWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, emailtemplate.HasReturnPortalAcceptedWith(with...))
	}
	if i.HasDeliveryOptionClickCollectAtStore != nil {
		p := emailtemplate.HasDeliveryOptionClickCollectAtStore()
		if !*i.HasDeliveryOptionClickCollectAtStore {
			p = emailtemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionClickCollectAtStoreWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionClickCollectAtStoreWith))
		for _, w := range i.HasDeliveryOptionClickCollectAtStoreWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionClickCollectAtStoreWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, emailtemplate.HasDeliveryOptionClickCollectAtStoreWith(with...))
	}
	if i.HasNotifications != nil {
		p := emailtemplate.HasNotifications()
		if !*i.HasNotifications {
			p = emailtemplate.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasNotificationsWith) > 0 {
		with := make([]predicate.Notification, 0, len(i.HasNotificationsWith))
		for _, w := range i.HasNotificationsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasNotificationsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, emailtemplate.HasNotificationsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyEmailTemplateWhereInput
	case 1:
		return predicates[0], nil
	default:
		return emailtemplate.And(predicates...), nil
	}
}

// HypothesisTestWhereInput represents a where input for filtering HypothesisTest queries.
type HypothesisTestWhereInput struct {
	Predicates []predicate.HypothesisTest  `json:"-"`
	Not        *HypothesisTestWhereInput   `json:"not,omitempty"`
	Or         []*HypothesisTestWhereInput `json:"or,omitempty"`
	And        []*HypothesisTestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "hypothesis_test_delivery_option" edge predicates.
	HasHypothesisTestDeliveryOption     *bool                                     `json:"hasHypothesisTestDeliveryOption,omitempty"`
	HasHypothesisTestDeliveryOptionWith []*HypothesisTestDeliveryOptionWhereInput `json:"hasHypothesisTestDeliveryOptionWith,omitempty"`

	// "connection" edge predicates.
	HasConnection     *bool                   `json:"hasConnection,omitempty"`
	HasConnectionWith []*ConnectionWhereInput `json:"hasConnectionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HypothesisTestWhereInput) AddPredicates(predicates ...predicate.HypothesisTest) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HypothesisTestWhereInput filter on the HypothesisTestQuery builder.
func (i *HypothesisTestWhereInput) Filter(q *HypothesisTestQuery) (*HypothesisTestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHypothesisTestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHypothesisTestWhereInput is returned in case the HypothesisTestWhereInput is empty.
var ErrEmptyHypothesisTestWhereInput = errors.New("ent: empty predicate HypothesisTestWhereInput")

// P returns a predicate for filtering hypothesistests.
// An error is returned if the input is empty or invalid.
func (i *HypothesisTestWhereInput) P() (predicate.HypothesisTest, error) {
	var predicates []predicate.HypothesisTest
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, hypothesistest.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HypothesisTest, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, hypothesistest.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HypothesisTest, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, hypothesistest.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, hypothesistest.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hypothesistest.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hypothesistest.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hypothesistest.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hypothesistest.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hypothesistest.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hypothesistest.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hypothesistest.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, hypothesistest.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, hypothesistest.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, hypothesistest.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, hypothesistest.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, hypothesistest.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, hypothesistest.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, hypothesistest.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, hypothesistest.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, hypothesistest.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, hypothesistest.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, hypothesistest.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, hypothesistest.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, hypothesistest.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, hypothesistest.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, hypothesistest.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, hypothesistest.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, hypothesistest.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, hypothesistest.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, hypothesistest.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, hypothesistest.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, hypothesistest.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, hypothesistest.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, hypothesistest.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, hypothesistest.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, hypothesistest.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, hypothesistest.NameContainsFold(*i.NameContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, hypothesistest.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, hypothesistest.ActiveNEQ(*i.ActiveNEQ))
	}

	if i.HasTenant != nil {
		p := hypothesistest.HasTenant()
		if !*i.HasTenant {
			p = hypothesistest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistest.HasTenantWith(with...))
	}
	if i.HasHypothesisTestDeliveryOption != nil {
		p := hypothesistest.HasHypothesisTestDeliveryOption()
		if !*i.HasHypothesisTestDeliveryOption {
			p = hypothesistest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestDeliveryOptionWith) > 0 {
		with := make([]predicate.HypothesisTestDeliveryOption, 0, len(i.HasHypothesisTestDeliveryOptionWith))
		for _, w := range i.HasHypothesisTestDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistest.HasHypothesisTestDeliveryOptionWith(with...))
	}
	if i.HasConnection != nil {
		p := hypothesistest.HasConnection()
		if !*i.HasConnection {
			p = hypothesistest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionWith))
		for _, w := range i.HasConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistest.HasConnectionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHypothesisTestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return hypothesistest.And(predicates...), nil
	}
}

// HypothesisTestDeliveryOptionWhereInput represents a where input for filtering HypothesisTestDeliveryOption queries.
type HypothesisTestDeliveryOptionWhereInput struct {
	Predicates []predicate.HypothesisTestDeliveryOption  `json:"-"`
	Not        *HypothesisTestDeliveryOptionWhereInput   `json:"not,omitempty"`
	Or         []*HypothesisTestDeliveryOptionWhereInput `json:"or,omitempty"`
	And        []*HypothesisTestDeliveryOptionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "randomize_within_group_sort" field predicates.
	RandomizeWithinGroupSort    *bool `json:"randomizeWithinGroupSort,omitempty"`
	RandomizeWithinGroupSortNEQ *bool `json:"randomizeWithinGroupSortNEQ,omitempty"`

	// "by_interval_rotation" field predicates.
	ByIntervalRotation    *bool `json:"byIntervalRotation,omitempty"`
	ByIntervalRotationNEQ *bool `json:"byIntervalRotationNEQ,omitempty"`

	// "rotation_interval_hours" field predicates.
	RotationIntervalHours      *int  `json:"rotationIntervalHours,omitempty"`
	RotationIntervalHoursNEQ   *int  `json:"rotationIntervalHoursNEQ,omitempty"`
	RotationIntervalHoursIn    []int `json:"rotationIntervalHoursIn,omitempty"`
	RotationIntervalHoursNotIn []int `json:"rotationIntervalHoursNotIn,omitempty"`
	RotationIntervalHoursGT    *int  `json:"rotationIntervalHoursGT,omitempty"`
	RotationIntervalHoursGTE   *int  `json:"rotationIntervalHoursGTE,omitempty"`
	RotationIntervalHoursLT    *int  `json:"rotationIntervalHoursLT,omitempty"`
	RotationIntervalHoursLTE   *int  `json:"rotationIntervalHoursLTE,omitempty"`

	// "by_order" field predicates.
	ByOrder    *bool `json:"byOrder,omitempty"`
	ByOrderNEQ *bool `json:"byOrderNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "hypothesis_test" edge predicates.
	HasHypothesisTest     *bool                       `json:"hasHypothesisTest,omitempty"`
	HasHypothesisTestWith []*HypothesisTestWhereInput `json:"hasHypothesisTestWith,omitempty"`

	// "hypothesis_test_delivery_option_request" edge predicates.
	HasHypothesisTestDeliveryOptionRequest     *bool                                            `json:"hasHypothesisTestDeliveryOptionRequest,omitempty"`
	HasHypothesisTestDeliveryOptionRequestWith []*HypothesisTestDeliveryOptionRequestWhereInput `json:"hasHypothesisTestDeliveryOptionRequestWith,omitempty"`

	// "delivery_option_group_one" edge predicates.
	HasDeliveryOptionGroupOne     *bool                       `json:"hasDeliveryOptionGroupOne,omitempty"`
	HasDeliveryOptionGroupOneWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionGroupOneWith,omitempty"`

	// "delivery_option_group_two" edge predicates.
	HasDeliveryOptionGroupTwo     *bool                       `json:"hasDeliveryOptionGroupTwo,omitempty"`
	HasDeliveryOptionGroupTwoWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionGroupTwoWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HypothesisTestDeliveryOptionWhereInput) AddPredicates(predicates ...predicate.HypothesisTestDeliveryOption) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HypothesisTestDeliveryOptionWhereInput filter on the HypothesisTestDeliveryOptionQuery builder.
func (i *HypothesisTestDeliveryOptionWhereInput) Filter(q *HypothesisTestDeliveryOptionQuery) (*HypothesisTestDeliveryOptionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHypothesisTestDeliveryOptionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHypothesisTestDeliveryOptionWhereInput is returned in case the HypothesisTestDeliveryOptionWhereInput is empty.
var ErrEmptyHypothesisTestDeliveryOptionWhereInput = errors.New("ent: empty predicate HypothesisTestDeliveryOptionWhereInput")

// P returns a predicate for filtering hypothesistestdeliveryoptions.
// An error is returned if the input is empty or invalid.
func (i *HypothesisTestDeliveryOptionWhereInput) P() (predicate.HypothesisTestDeliveryOption, error) {
	var predicates []predicate.HypothesisTestDeliveryOption
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, hypothesistestdeliveryoption.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HypothesisTestDeliveryOption, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoption.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HypothesisTestDeliveryOption, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoption.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoption.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoption.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.RandomizeWithinGroupSort != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.RandomizeWithinGroupSortEQ(*i.RandomizeWithinGroupSort))
	}
	if i.RandomizeWithinGroupSortNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.RandomizeWithinGroupSortNEQ(*i.RandomizeWithinGroupSortNEQ))
	}
	if i.ByIntervalRotation != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.ByIntervalRotationEQ(*i.ByIntervalRotation))
	}
	if i.ByIntervalRotationNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.ByIntervalRotationNEQ(*i.ByIntervalRotationNEQ))
	}
	if i.RotationIntervalHours != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.RotationIntervalHoursEQ(*i.RotationIntervalHours))
	}
	if i.RotationIntervalHoursNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.RotationIntervalHoursNEQ(*i.RotationIntervalHoursNEQ))
	}
	if len(i.RotationIntervalHoursIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoption.RotationIntervalHoursIn(i.RotationIntervalHoursIn...))
	}
	if len(i.RotationIntervalHoursNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoption.RotationIntervalHoursNotIn(i.RotationIntervalHoursNotIn...))
	}
	if i.RotationIntervalHoursGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.RotationIntervalHoursGT(*i.RotationIntervalHoursGT))
	}
	if i.RotationIntervalHoursGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.RotationIntervalHoursGTE(*i.RotationIntervalHoursGTE))
	}
	if i.RotationIntervalHoursLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.RotationIntervalHoursLT(*i.RotationIntervalHoursLT))
	}
	if i.RotationIntervalHoursLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.RotationIntervalHoursLTE(*i.RotationIntervalHoursLTE))
	}
	if i.ByOrder != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.ByOrderEQ(*i.ByOrder))
	}
	if i.ByOrderNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoption.ByOrderNEQ(*i.ByOrderNEQ))
	}

	if i.HasTenant != nil {
		p := hypothesistestdeliveryoption.HasTenant()
		if !*i.HasTenant {
			p = hypothesistestdeliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoption.HasTenantWith(with...))
	}
	if i.HasHypothesisTest != nil {
		p := hypothesistestdeliveryoption.HasHypothesisTest()
		if !*i.HasHypothesisTest {
			p = hypothesistestdeliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestWith) > 0 {
		with := make([]predicate.HypothesisTest, 0, len(i.HasHypothesisTestWith))
		for _, w := range i.HasHypothesisTestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoption.HasHypothesisTestWith(with...))
	}
	if i.HasHypothesisTestDeliveryOptionRequest != nil {
		p := hypothesistestdeliveryoption.HasHypothesisTestDeliveryOptionRequest()
		if !*i.HasHypothesisTestDeliveryOptionRequest {
			p = hypothesistestdeliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestDeliveryOptionRequestWith) > 0 {
		with := make([]predicate.HypothesisTestDeliveryOptionRequest, 0, len(i.HasHypothesisTestDeliveryOptionRequestWith))
		for _, w := range i.HasHypothesisTestDeliveryOptionRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestDeliveryOptionRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoption.HasHypothesisTestDeliveryOptionRequestWith(with...))
	}
	if i.HasDeliveryOptionGroupOne != nil {
		p := hypothesistestdeliveryoption.HasDeliveryOptionGroupOne()
		if !*i.HasDeliveryOptionGroupOne {
			p = hypothesistestdeliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionGroupOneWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionGroupOneWith))
		for _, w := range i.HasDeliveryOptionGroupOneWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionGroupOneWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoption.HasDeliveryOptionGroupOneWith(with...))
	}
	if i.HasDeliveryOptionGroupTwo != nil {
		p := hypothesistestdeliveryoption.HasDeliveryOptionGroupTwo()
		if !*i.HasDeliveryOptionGroupTwo {
			p = hypothesistestdeliveryoption.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionGroupTwoWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionGroupTwoWith))
		for _, w := range i.HasDeliveryOptionGroupTwoWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionGroupTwoWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoption.HasDeliveryOptionGroupTwoWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHypothesisTestDeliveryOptionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return hypothesistestdeliveryoption.And(predicates...), nil
	}
}

// HypothesisTestDeliveryOptionLookupWhereInput represents a where input for filtering HypothesisTestDeliveryOptionLookup queries.
type HypothesisTestDeliveryOptionLookupWhereInput struct {
	Predicates []predicate.HypothesisTestDeliveryOptionLookup  `json:"-"`
	Not        *HypothesisTestDeliveryOptionLookupWhereInput   `json:"not,omitempty"`
	Or         []*HypothesisTestDeliveryOptionLookupWhereInput `json:"or,omitempty"`
	And        []*HypothesisTestDeliveryOptionLookupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "hypothesis_test_delivery_option_request" edge predicates.
	HasHypothesisTestDeliveryOptionRequest     *bool                                            `json:"hasHypothesisTestDeliveryOptionRequest,omitempty"`
	HasHypothesisTestDeliveryOptionRequestWith []*HypothesisTestDeliveryOptionRequestWhereInput `json:"hasHypothesisTestDeliveryOptionRequestWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HypothesisTestDeliveryOptionLookupWhereInput) AddPredicates(predicates ...predicate.HypothesisTestDeliveryOptionLookup) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HypothesisTestDeliveryOptionLookupWhereInput filter on the HypothesisTestDeliveryOptionLookupQuery builder.
func (i *HypothesisTestDeliveryOptionLookupWhereInput) Filter(q *HypothesisTestDeliveryOptionLookupQuery) (*HypothesisTestDeliveryOptionLookupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHypothesisTestDeliveryOptionLookupWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHypothesisTestDeliveryOptionLookupWhereInput is returned in case the HypothesisTestDeliveryOptionLookupWhereInput is empty.
var ErrEmptyHypothesisTestDeliveryOptionLookupWhereInput = errors.New("ent: empty predicate HypothesisTestDeliveryOptionLookupWhereInput")

// P returns a predicate for filtering hypothesistestdeliveryoptionlookups.
// An error is returned if the input is empty or invalid.
func (i *HypothesisTestDeliveryOptionLookupWhereInput) P() (predicate.HypothesisTestDeliveryOptionLookup, error) {
	var predicates []predicate.HypothesisTestDeliveryOptionLookup
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HypothesisTestDeliveryOptionLookup, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HypothesisTestDeliveryOptionLookup, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.TenantIDContainsFold(*i.TenantIDContainsFold))
	}

	if i.HasTenant != nil {
		p := hypothesistestdeliveryoptionlookup.HasTenant()
		if !*i.HasTenant {
			p = hypothesistestdeliveryoptionlookup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.HasTenantWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := hypothesistestdeliveryoptionlookup.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = hypothesistestdeliveryoptionlookup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.HasDeliveryOptionWith(with...))
	}
	if i.HasHypothesisTestDeliveryOptionRequest != nil {
		p := hypothesistestdeliveryoptionlookup.HasHypothesisTestDeliveryOptionRequest()
		if !*i.HasHypothesisTestDeliveryOptionRequest {
			p = hypothesistestdeliveryoptionlookup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestDeliveryOptionRequestWith) > 0 {
		with := make([]predicate.HypothesisTestDeliveryOptionRequest, 0, len(i.HasHypothesisTestDeliveryOptionRequestWith))
		for _, w := range i.HasHypothesisTestDeliveryOptionRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestDeliveryOptionRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionlookup.HasHypothesisTestDeliveryOptionRequestWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHypothesisTestDeliveryOptionLookupWhereInput
	case 1:
		return predicates[0], nil
	default:
		return hypothesistestdeliveryoptionlookup.And(predicates...), nil
	}
}

// HypothesisTestDeliveryOptionRequestWhereInput represents a where input for filtering HypothesisTestDeliveryOptionRequest queries.
type HypothesisTestDeliveryOptionRequestWhereInput struct {
	Predicates []predicate.HypothesisTestDeliveryOptionRequest  `json:"-"`
	Not        *HypothesisTestDeliveryOptionRequestWhereInput   `json:"not,omitempty"`
	Or         []*HypothesisTestDeliveryOptionRequestWhereInput `json:"or,omitempty"`
	And        []*HypothesisTestDeliveryOptionRequestWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "order_hash" field predicates.
	OrderHash             *string  `json:"orderHash,omitempty"`
	OrderHashNEQ          *string  `json:"orderHashNEQ,omitempty"`
	OrderHashIn           []string `json:"orderHashIn,omitempty"`
	OrderHashNotIn        []string `json:"orderHashNotIn,omitempty"`
	OrderHashGT           *string  `json:"orderHashGT,omitempty"`
	OrderHashGTE          *string  `json:"orderHashGTE,omitempty"`
	OrderHashLT           *string  `json:"orderHashLT,omitempty"`
	OrderHashLTE          *string  `json:"orderHashLTE,omitempty"`
	OrderHashContains     *string  `json:"orderHashContains,omitempty"`
	OrderHashHasPrefix    *string  `json:"orderHashHasPrefix,omitempty"`
	OrderHashHasSuffix    *string  `json:"orderHashHasSuffix,omitempty"`
	OrderHashEqualFold    *string  `json:"orderHashEqualFold,omitempty"`
	OrderHashContainsFold *string  `json:"orderHashContainsFold,omitempty"`

	// "shipping_address_hash" field predicates.
	ShippingAddressHash             *string  `json:"shippingAddressHash,omitempty"`
	ShippingAddressHashNEQ          *string  `json:"shippingAddressHashNEQ,omitempty"`
	ShippingAddressHashIn           []string `json:"shippingAddressHashIn,omitempty"`
	ShippingAddressHashNotIn        []string `json:"shippingAddressHashNotIn,omitempty"`
	ShippingAddressHashGT           *string  `json:"shippingAddressHashGT,omitempty"`
	ShippingAddressHashGTE          *string  `json:"shippingAddressHashGTE,omitempty"`
	ShippingAddressHashLT           *string  `json:"shippingAddressHashLT,omitempty"`
	ShippingAddressHashLTE          *string  `json:"shippingAddressHashLTE,omitempty"`
	ShippingAddressHashContains     *string  `json:"shippingAddressHashContains,omitempty"`
	ShippingAddressHashHasPrefix    *string  `json:"shippingAddressHashHasPrefix,omitempty"`
	ShippingAddressHashHasSuffix    *string  `json:"shippingAddressHashHasSuffix,omitempty"`
	ShippingAddressHashEqualFold    *string  `json:"shippingAddressHashEqualFold,omitempty"`
	ShippingAddressHashContainsFold *string  `json:"shippingAddressHashContainsFold,omitempty"`

	// "is_control_group" field predicates.
	IsControlGroup    *bool `json:"isControlGroup,omitempty"`
	IsControlGroupNEQ *bool `json:"isControlGroupNEQ,omitempty"`

	// "request_count" field predicates.
	RequestCount      *uint  `json:"requestCount,omitempty"`
	RequestCountNEQ   *uint  `json:"requestCountNEQ,omitempty"`
	RequestCountIn    []uint `json:"requestCountIn,omitempty"`
	RequestCountNotIn []uint `json:"requestCountNotIn,omitempty"`
	RequestCountGT    *uint  `json:"requestCountGT,omitempty"`
	RequestCountGTE   *uint  `json:"requestCountGTE,omitempty"`
	RequestCountLT    *uint  `json:"requestCountLT,omitempty"`
	RequestCountLTE   *uint  `json:"requestCountLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_requested_at" field predicates.
	LastRequestedAt      *time.Time  `json:"lastRequestedAt,omitempty"`
	LastRequestedAtNEQ   *time.Time  `json:"lastRequestedAtNEQ,omitempty"`
	LastRequestedAtIn    []time.Time `json:"lastRequestedAtIn,omitempty"`
	LastRequestedAtNotIn []time.Time `json:"lastRequestedAtNotIn,omitempty"`
	LastRequestedAtGT    *time.Time  `json:"lastRequestedAtGT,omitempty"`
	LastRequestedAtGTE   *time.Time  `json:"lastRequestedAtGTE,omitempty"`
	LastRequestedAtLT    *time.Time  `json:"lastRequestedAtLT,omitempty"`
	LastRequestedAtLTE   *time.Time  `json:"lastRequestedAtLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "hypothesis_test_delivery_option" edge predicates.
	HasHypothesisTestDeliveryOption     *bool                                     `json:"hasHypothesisTestDeliveryOption,omitempty"`
	HasHypothesisTestDeliveryOptionWith []*HypothesisTestDeliveryOptionWhereInput `json:"hasHypothesisTestDeliveryOptionWith,omitempty"`

	// "order" edge predicates.
	HasOrder     *bool              `json:"hasOrder,omitempty"`
	HasOrderWith []*OrderWhereInput `json:"hasOrderWith,omitempty"`

	// "hypothesis_test_delivery_option_lookup" edge predicates.
	HasHypothesisTestDeliveryOptionLookup     *bool                                           `json:"hasHypothesisTestDeliveryOptionLookup,omitempty"`
	HasHypothesisTestDeliveryOptionLookupWith []*HypothesisTestDeliveryOptionLookupWhereInput `json:"hasHypothesisTestDeliveryOptionLookupWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *HypothesisTestDeliveryOptionRequestWhereInput) AddPredicates(predicates ...predicate.HypothesisTestDeliveryOptionRequest) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the HypothesisTestDeliveryOptionRequestWhereInput filter on the HypothesisTestDeliveryOptionRequestQuery builder.
func (i *HypothesisTestDeliveryOptionRequestWhereInput) Filter(q *HypothesisTestDeliveryOptionRequestQuery) (*HypothesisTestDeliveryOptionRequestQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyHypothesisTestDeliveryOptionRequestWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyHypothesisTestDeliveryOptionRequestWhereInput is returned in case the HypothesisTestDeliveryOptionRequestWhereInput is empty.
var ErrEmptyHypothesisTestDeliveryOptionRequestWhereInput = errors.New("ent: empty predicate HypothesisTestDeliveryOptionRequestWhereInput")

// P returns a predicate for filtering hypothesistestdeliveryoptionrequests.
// An error is returned if the input is empty or invalid.
func (i *HypothesisTestDeliveryOptionRequestWhereInput) P() (predicate.HypothesisTestDeliveryOptionRequest, error) {
	var predicates []predicate.HypothesisTestDeliveryOptionRequest
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.HypothesisTestDeliveryOptionRequest, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.HypothesisTestDeliveryOptionRequest, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.OrderHash != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashEQ(*i.OrderHash))
	}
	if i.OrderHashNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashNEQ(*i.OrderHashNEQ))
	}
	if len(i.OrderHashIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashIn(i.OrderHashIn...))
	}
	if len(i.OrderHashNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashNotIn(i.OrderHashNotIn...))
	}
	if i.OrderHashGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashGT(*i.OrderHashGT))
	}
	if i.OrderHashGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashGTE(*i.OrderHashGTE))
	}
	if i.OrderHashLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashLT(*i.OrderHashLT))
	}
	if i.OrderHashLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashLTE(*i.OrderHashLTE))
	}
	if i.OrderHashContains != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashContains(*i.OrderHashContains))
	}
	if i.OrderHashHasPrefix != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashHasPrefix(*i.OrderHashHasPrefix))
	}
	if i.OrderHashHasSuffix != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashHasSuffix(*i.OrderHashHasSuffix))
	}
	if i.OrderHashEqualFold != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashEqualFold(*i.OrderHashEqualFold))
	}
	if i.OrderHashContainsFold != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.OrderHashContainsFold(*i.OrderHashContainsFold))
	}
	if i.ShippingAddressHash != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashEQ(*i.ShippingAddressHash))
	}
	if i.ShippingAddressHashNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashNEQ(*i.ShippingAddressHashNEQ))
	}
	if len(i.ShippingAddressHashIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashIn(i.ShippingAddressHashIn...))
	}
	if len(i.ShippingAddressHashNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashNotIn(i.ShippingAddressHashNotIn...))
	}
	if i.ShippingAddressHashGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashGT(*i.ShippingAddressHashGT))
	}
	if i.ShippingAddressHashGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashGTE(*i.ShippingAddressHashGTE))
	}
	if i.ShippingAddressHashLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashLT(*i.ShippingAddressHashLT))
	}
	if i.ShippingAddressHashLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashLTE(*i.ShippingAddressHashLTE))
	}
	if i.ShippingAddressHashContains != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashContains(*i.ShippingAddressHashContains))
	}
	if i.ShippingAddressHashHasPrefix != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashHasPrefix(*i.ShippingAddressHashHasPrefix))
	}
	if i.ShippingAddressHashHasSuffix != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashHasSuffix(*i.ShippingAddressHashHasSuffix))
	}
	if i.ShippingAddressHashEqualFold != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashEqualFold(*i.ShippingAddressHashEqualFold))
	}
	if i.ShippingAddressHashContainsFold != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.ShippingAddressHashContainsFold(*i.ShippingAddressHashContainsFold))
	}
	if i.IsControlGroup != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.IsControlGroupEQ(*i.IsControlGroup))
	}
	if i.IsControlGroupNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.IsControlGroupNEQ(*i.IsControlGroupNEQ))
	}
	if i.RequestCount != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.RequestCountEQ(*i.RequestCount))
	}
	if i.RequestCountNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.RequestCountNEQ(*i.RequestCountNEQ))
	}
	if len(i.RequestCountIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.RequestCountIn(i.RequestCountIn...))
	}
	if len(i.RequestCountNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.RequestCountNotIn(i.RequestCountNotIn...))
	}
	if i.RequestCountGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.RequestCountGT(*i.RequestCountGT))
	}
	if i.RequestCountGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.RequestCountGTE(*i.RequestCountGTE))
	}
	if i.RequestCountLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.RequestCountLT(*i.RequestCountLT))
	}
	if i.RequestCountLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.RequestCountLTE(*i.RequestCountLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastRequestedAt != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.LastRequestedAtEQ(*i.LastRequestedAt))
	}
	if i.LastRequestedAtNEQ != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.LastRequestedAtNEQ(*i.LastRequestedAtNEQ))
	}
	if len(i.LastRequestedAtIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.LastRequestedAtIn(i.LastRequestedAtIn...))
	}
	if len(i.LastRequestedAtNotIn) > 0 {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.LastRequestedAtNotIn(i.LastRequestedAtNotIn...))
	}
	if i.LastRequestedAtGT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.LastRequestedAtGT(*i.LastRequestedAtGT))
	}
	if i.LastRequestedAtGTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.LastRequestedAtGTE(*i.LastRequestedAtGTE))
	}
	if i.LastRequestedAtLT != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.LastRequestedAtLT(*i.LastRequestedAtLT))
	}
	if i.LastRequestedAtLTE != nil {
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.LastRequestedAtLTE(*i.LastRequestedAtLTE))
	}

	if i.HasTenant != nil {
		p := hypothesistestdeliveryoptionrequest.HasTenant()
		if !*i.HasTenant {
			p = hypothesistestdeliveryoptionrequest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.HasTenantWith(with...))
	}
	if i.HasHypothesisTestDeliveryOption != nil {
		p := hypothesistestdeliveryoptionrequest.HasHypothesisTestDeliveryOption()
		if !*i.HasHypothesisTestDeliveryOption {
			p = hypothesistestdeliveryoptionrequest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestDeliveryOptionWith) > 0 {
		with := make([]predicate.HypothesisTestDeliveryOption, 0, len(i.HasHypothesisTestDeliveryOptionWith))
		for _, w := range i.HasHypothesisTestDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.HasHypothesisTestDeliveryOptionWith(with...))
	}
	if i.HasOrder != nil {
		p := hypothesistestdeliveryoptionrequest.HasOrder()
		if !*i.HasOrder {
			p = hypothesistestdeliveryoptionrequest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrderWith) > 0 {
		with := make([]predicate.Order, 0, len(i.HasOrderWith))
		for _, w := range i.HasOrderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.HasOrderWith(with...))
	}
	if i.HasHypothesisTestDeliveryOptionLookup != nil {
		p := hypothesistestdeliveryoptionrequest.HasHypothesisTestDeliveryOptionLookup()
		if !*i.HasHypothesisTestDeliveryOptionLookup {
			p = hypothesistestdeliveryoptionrequest.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestDeliveryOptionLookupWith) > 0 {
		with := make([]predicate.HypothesisTestDeliveryOptionLookup, 0, len(i.HasHypothesisTestDeliveryOptionLookupWith))
		for _, w := range i.HasHypothesisTestDeliveryOptionLookupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestDeliveryOptionLookupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, hypothesistestdeliveryoptionrequest.HasHypothesisTestDeliveryOptionLookupWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyHypothesisTestDeliveryOptionRequestWhereInput
	case 1:
		return predicates[0], nil
	default:
		return hypothesistestdeliveryoptionrequest.And(predicates...), nil
	}
}

// InventoryItemWhereInput represents a where input for filtering InventoryItem queries.
type InventoryItemWhereInput struct {
	Predicates []predicate.InventoryItem  `json:"-"`
	Not        *InventoryItemWhereInput   `json:"not,omitempty"`
	Or         []*InventoryItemWhereInput `json:"or,omitempty"`
	And        []*InventoryItemWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "external_ID" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeIsNil        bool     `json:"codeIsNil,omitempty"`
	CodeNotNil       bool     `json:"codeNotNil,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "sku" field predicates.
	Sku             *string  `json:"sku,omitempty"`
	SkuNEQ          *string  `json:"skuNEQ,omitempty"`
	SkuIn           []string `json:"skuIn,omitempty"`
	SkuNotIn        []string `json:"skuNotIn,omitempty"`
	SkuGT           *string  `json:"skuGT,omitempty"`
	SkuGTE          *string  `json:"skuGTE,omitempty"`
	SkuLT           *string  `json:"skuLT,omitempty"`
	SkuLTE          *string  `json:"skuLTE,omitempty"`
	SkuContains     *string  `json:"skuContains,omitempty"`
	SkuHasPrefix    *string  `json:"skuHasPrefix,omitempty"`
	SkuHasSuffix    *string  `json:"skuHasSuffix,omitempty"`
	SkuIsNil        bool     `json:"skuIsNil,omitempty"`
	SkuNotNil       bool     `json:"skuNotNil,omitempty"`
	SkuEqualFold    *string  `json:"skuEqualFold,omitempty"`
	SkuContainsFold *string  `json:"skuContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "country_harmonized_code" edge predicates.
	HasCountryHarmonizedCode     *bool                              `json:"hasCountryHarmonizedCode,omitempty"`
	HasCountryHarmonizedCodeWith []*CountryHarmonizedCodeWhereInput `json:"hasCountryHarmonizedCodeWith,omitempty"`

	// "country_of_origin" edge predicates.
	HasCountryOfOrigin     *bool                `json:"hasCountryOfOrigin,omitempty"`
	HasCountryOfOriginWith []*CountryWhereInput `json:"hasCountryOfOriginWith,omitempty"`

	// "product_variant" edge predicates.
	HasProductVariant     *bool                       `json:"hasProductVariant,omitempty"`
	HasProductVariantWith []*ProductVariantWhereInput `json:"hasProductVariantWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *InventoryItemWhereInput) AddPredicates(predicates ...predicate.InventoryItem) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the InventoryItemWhereInput filter on the InventoryItemQuery builder.
func (i *InventoryItemWhereInput) Filter(q *InventoryItemQuery) (*InventoryItemQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyInventoryItemWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyInventoryItemWhereInput is returned in case the InventoryItemWhereInput is empty.
var ErrEmptyInventoryItemWhereInput = errors.New("ent: empty predicate InventoryItemWhereInput")

// P returns a predicate for filtering inventoryitems.
// An error is returned if the input is empty or invalid.
func (i *InventoryItemWhereInput) P() (predicate.InventoryItem, error) {
	var predicates []predicate.InventoryItem
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, inventoryitem.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.InventoryItem, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, inventoryitem.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.InventoryItem, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, inventoryitem.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, inventoryitem.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, inventoryitem.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, inventoryitem.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, inventoryitem.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, inventoryitem.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, inventoryitem.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, inventoryitem.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, inventoryitem.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, inventoryitem.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, inventoryitem.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, inventoryitem.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, inventoryitem.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, inventoryitem.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, inventoryitem.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, inventoryitem.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, inventoryitem.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, inventoryitem.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, inventoryitem.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, inventoryitem.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, inventoryitem.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, inventoryitem.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ExternalID != nil {
		predicates = append(predicates, inventoryitem.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, inventoryitem.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, inventoryitem.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, inventoryitem.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, inventoryitem.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, inventoryitem.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, inventoryitem.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, inventoryitem.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, inventoryitem.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, inventoryitem.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, inventoryitem.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, inventoryitem.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, inventoryitem.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, inventoryitem.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, inventoryitem.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.Code != nil {
		predicates = append(predicates, inventoryitem.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, inventoryitem.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, inventoryitem.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, inventoryitem.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, inventoryitem.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, inventoryitem.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, inventoryitem.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, inventoryitem.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, inventoryitem.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, inventoryitem.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, inventoryitem.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeIsNil {
		predicates = append(predicates, inventoryitem.CodeIsNil())
	}
	if i.CodeNotNil {
		predicates = append(predicates, inventoryitem.CodeNotNil())
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, inventoryitem.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, inventoryitem.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Sku != nil {
		predicates = append(predicates, inventoryitem.SkuEQ(*i.Sku))
	}
	if i.SkuNEQ != nil {
		predicates = append(predicates, inventoryitem.SkuNEQ(*i.SkuNEQ))
	}
	if len(i.SkuIn) > 0 {
		predicates = append(predicates, inventoryitem.SkuIn(i.SkuIn...))
	}
	if len(i.SkuNotIn) > 0 {
		predicates = append(predicates, inventoryitem.SkuNotIn(i.SkuNotIn...))
	}
	if i.SkuGT != nil {
		predicates = append(predicates, inventoryitem.SkuGT(*i.SkuGT))
	}
	if i.SkuGTE != nil {
		predicates = append(predicates, inventoryitem.SkuGTE(*i.SkuGTE))
	}
	if i.SkuLT != nil {
		predicates = append(predicates, inventoryitem.SkuLT(*i.SkuLT))
	}
	if i.SkuLTE != nil {
		predicates = append(predicates, inventoryitem.SkuLTE(*i.SkuLTE))
	}
	if i.SkuContains != nil {
		predicates = append(predicates, inventoryitem.SkuContains(*i.SkuContains))
	}
	if i.SkuHasPrefix != nil {
		predicates = append(predicates, inventoryitem.SkuHasPrefix(*i.SkuHasPrefix))
	}
	if i.SkuHasSuffix != nil {
		predicates = append(predicates, inventoryitem.SkuHasSuffix(*i.SkuHasSuffix))
	}
	if i.SkuIsNil {
		predicates = append(predicates, inventoryitem.SkuIsNil())
	}
	if i.SkuNotNil {
		predicates = append(predicates, inventoryitem.SkuNotNil())
	}
	if i.SkuEqualFold != nil {
		predicates = append(predicates, inventoryitem.SkuEqualFold(*i.SkuEqualFold))
	}
	if i.SkuContainsFold != nil {
		predicates = append(predicates, inventoryitem.SkuContainsFold(*i.SkuContainsFold))
	}

	if i.HasTenant != nil {
		p := inventoryitem.HasTenant()
		if !*i.HasTenant {
			p = inventoryitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, inventoryitem.HasTenantWith(with...))
	}
	if i.HasCountryHarmonizedCode != nil {
		p := inventoryitem.HasCountryHarmonizedCode()
		if !*i.HasCountryHarmonizedCode {
			p = inventoryitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryHarmonizedCodeWith) > 0 {
		with := make([]predicate.CountryHarmonizedCode, 0, len(i.HasCountryHarmonizedCodeWith))
		for _, w := range i.HasCountryHarmonizedCodeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryHarmonizedCodeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, inventoryitem.HasCountryHarmonizedCodeWith(with...))
	}
	if i.HasCountryOfOrigin != nil {
		p := inventoryitem.HasCountryOfOrigin()
		if !*i.HasCountryOfOrigin {
			p = inventoryitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCountryOfOriginWith) > 0 {
		with := make([]predicate.Country, 0, len(i.HasCountryOfOriginWith))
		for _, w := range i.HasCountryOfOriginWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCountryOfOriginWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, inventoryitem.HasCountryOfOriginWith(with...))
	}
	if i.HasProductVariant != nil {
		p := inventoryitem.HasProductVariant()
		if !*i.HasProductVariant {
			p = inventoryitem.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductVariantWith) > 0 {
		with := make([]predicate.ProductVariant, 0, len(i.HasProductVariantWith))
		for _, w := range i.HasProductVariantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductVariantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, inventoryitem.HasProductVariantWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyInventoryItemWhereInput
	case 1:
		return predicates[0], nil
	default:
		return inventoryitem.And(predicates...), nil
	}
}

// LanguageWhereInput represents a where input for filtering Language queries.
type LanguageWhereInput struct {
	Predicates []predicate.Language  `json:"-"`
	Not        *LanguageWhereInput   `json:"not,omitempty"`
	Or         []*LanguageWhereInput `json:"or,omitempty"`
	And        []*LanguageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "internal_id" field predicates.
	InternalID      *language.InternalID  `json:"internalID,omitempty"`
	InternalIDNEQ   *language.InternalID  `json:"internalIDNEQ,omitempty"`
	InternalIDIn    []language.InternalID `json:"internalIDIn,omitempty"`
	InternalIDNotIn []language.InternalID `json:"internalIDNotIn,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "language" edge predicates.
	HasLanguage     *bool               `json:"hasLanguage,omitempty"`
	HasLanguageWith []*TenantWhereInput `json:"hasLanguageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LanguageWhereInput) AddPredicates(predicates ...predicate.Language) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LanguageWhereInput filter on the LanguageQuery builder.
func (i *LanguageWhereInput) Filter(q *LanguageQuery) (*LanguageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLanguageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLanguageWhereInput is returned in case the LanguageWhereInput is empty.
var ErrEmptyLanguageWhereInput = errors.New("ent: empty predicate LanguageWhereInput")

// P returns a predicate for filtering languages.
// An error is returned if the input is empty or invalid.
func (i *LanguageWhereInput) P() (predicate.Language, error) {
	var predicates []predicate.Language
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, language.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Language, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, language.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Language, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, language.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, language.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, language.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, language.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, language.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, language.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, language.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, language.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, language.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, language.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, language.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, language.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, language.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, language.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, language.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, language.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, language.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, language.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, language.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, language.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, language.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, language.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.InternalID != nil {
		predicates = append(predicates, language.InternalIDEQ(*i.InternalID))
	}
	if i.InternalIDNEQ != nil {
		predicates = append(predicates, language.InternalIDNEQ(*i.InternalIDNEQ))
	}
	if len(i.InternalIDIn) > 0 {
		predicates = append(predicates, language.InternalIDIn(i.InternalIDIn...))
	}
	if len(i.InternalIDNotIn) > 0 {
		predicates = append(predicates, language.InternalIDNotIn(i.InternalIDNotIn...))
	}

	if i.HasUsers != nil {
		p := language.HasUsers()
		if !*i.HasUsers {
			p = language.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, language.HasUsersWith(with...))
	}
	if i.HasLanguage != nil {
		p := language.HasLanguage()
		if !*i.HasLanguage {
			p = language.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLanguageWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasLanguageWith))
		for _, w := range i.HasLanguageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLanguageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, language.HasLanguageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLanguageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return language.And(predicates...), nil
	}
}

// LocationWhereInput represents a where input for filtering Location queries.
type LocationWhereInput struct {
	Predicates []predicate.Location  `json:"-"`
	Not        *LocationWhereInput   `json:"not,omitempty"`
	Or         []*LocationWhereInput `json:"or,omitempty"`
	And        []*LocationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "address" edge predicates.
	HasAddress     *bool                `json:"hasAddress,omitempty"`
	HasAddressWith []*AddressWhereInput `json:"hasAddressWith,omitempty"`

	// "location_tags" edge predicates.
	HasLocationTags     *bool                    `json:"hasLocationTags,omitempty"`
	HasLocationTagsWith []*LocationTagWhereInput `json:"hasLocationTagsWith,omitempty"`

	// "sender_connection" edge predicates.
	HasSenderConnection     *bool                   `json:"hasSenderConnection,omitempty"`
	HasSenderConnectionWith []*ConnectionWhereInput `json:"hasSenderConnectionWith,omitempty"`

	// "pickup_connection" edge predicates.
	HasPickupConnection     *bool                   `json:"hasPickupConnection,omitempty"`
	HasPickupConnectionWith []*ConnectionWhereInput `json:"hasPickupConnectionWith,omitempty"`

	// "return_connection" edge predicates.
	HasReturnConnection     *bool                   `json:"hasReturnConnection,omitempty"`
	HasReturnConnectionWith []*ConnectionWhereInput `json:"hasReturnConnectionWith,omitempty"`

	// "seller_connection" edge predicates.
	HasSellerConnection     *bool                   `json:"hasSellerConnection,omitempty"`
	HasSellerConnectionWith []*ConnectionWhereInput `json:"hasSellerConnectionWith,omitempty"`

	// "return_portal" edge predicates.
	HasReturnPortal     *bool                     `json:"hasReturnPortal,omitempty"`
	HasReturnPortalWith []*ReturnPortalWhereInput `json:"hasReturnPortalWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "colli" edge predicates.
	HasColli     *bool              `json:"hasColli,omitempty"`
	HasColliWith []*ColliWhereInput `json:"hasColliWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LocationWhereInput) AddPredicates(predicates ...predicate.Location) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LocationWhereInput filter on the LocationQuery builder.
func (i *LocationWhereInput) Filter(q *LocationQuery) (*LocationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLocationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLocationWhereInput is returned in case the LocationWhereInput is empty.
var ErrEmptyLocationWhereInput = errors.New("ent: empty predicate LocationWhereInput")

// P returns a predicate for filtering locations.
// An error is returned if the input is empty or invalid.
func (i *LocationWhereInput) P() (predicate.Location, error) {
	var predicates []predicate.Location
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, location.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Location, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, location.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Location, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, location.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, location.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, location.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, location.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, location.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, location.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, location.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, location.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, location.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, location.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, location.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, location.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, location.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, location.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, location.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, location.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, location.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, location.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, location.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, location.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, location.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, location.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, location.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, location.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, location.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, location.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, location.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, location.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, location.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, location.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, location.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, location.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, location.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, location.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, location.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasTenant != nil {
		p := location.HasTenant()
		if !*i.HasTenant {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasTenantWith(with...))
	}
	if i.HasAddress != nil {
		p := location.HasAddress()
		if !*i.HasAddress {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAddressWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasAddressWith))
		for _, w := range i.HasAddressWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAddressWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasAddressWith(with...))
	}
	if i.HasLocationTags != nil {
		p := location.HasLocationTags()
		if !*i.HasLocationTags {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationTagsWith) > 0 {
		with := make([]predicate.LocationTag, 0, len(i.HasLocationTagsWith))
		for _, w := range i.HasLocationTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasLocationTagsWith(with...))
	}
	if i.HasSenderConnection != nil {
		p := location.HasSenderConnection()
		if !*i.HasSenderConnection {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSenderConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasSenderConnectionWith))
		for _, w := range i.HasSenderConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSenderConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasSenderConnectionWith(with...))
	}
	if i.HasPickupConnection != nil {
		p := location.HasPickupConnection()
		if !*i.HasPickupConnection {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPickupConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasPickupConnectionWith))
		for _, w := range i.HasPickupConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPickupConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasPickupConnectionWith(with...))
	}
	if i.HasReturnConnection != nil {
		p := location.HasReturnConnection()
		if !*i.HasReturnConnection {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasReturnConnectionWith))
		for _, w := range i.HasReturnConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasReturnConnectionWith(with...))
	}
	if i.HasSellerConnection != nil {
		p := location.HasSellerConnection()
		if !*i.HasSellerConnection {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSellerConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasSellerConnectionWith))
		for _, w := range i.HasSellerConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSellerConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasSellerConnectionWith(with...))
	}
	if i.HasReturnPortal != nil {
		p := location.HasReturnPortal()
		if !*i.HasReturnPortal {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalWith) > 0 {
		with := make([]predicate.ReturnPortal, 0, len(i.HasReturnPortalWith))
		for _, w := range i.HasReturnPortalWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasReturnPortalWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := location.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasDeliveryOptionWith(with...))
	}
	if i.HasColli != nil {
		p := location.HasColli()
		if !*i.HasColli {
			p = location.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasColliWith))
		for _, w := range i.HasColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, location.HasColliWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLocationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return location.And(predicates...), nil
	}
}

// LocationTagWhereInput represents a where input for filtering LocationTag queries.
type LocationTagWhereInput struct {
	Predicates []predicate.LocationTag  `json:"-"`
	Not        *LocationTagWhereInput   `json:"not,omitempty"`
	Or         []*LocationTagWhereInput `json:"or,omitempty"`
	And        []*LocationTagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "internal_id" field predicates.
	InternalID             *string  `json:"internalID,omitempty"`
	InternalIDNEQ          *string  `json:"internalIDNEQ,omitempty"`
	InternalIDIn           []string `json:"internalIDIn,omitempty"`
	InternalIDNotIn        []string `json:"internalIDNotIn,omitempty"`
	InternalIDGT           *string  `json:"internalIDGT,omitempty"`
	InternalIDGTE          *string  `json:"internalIDGTE,omitempty"`
	InternalIDLT           *string  `json:"internalIDLT,omitempty"`
	InternalIDLTE          *string  `json:"internalIDLTE,omitempty"`
	InternalIDContains     *string  `json:"internalIDContains,omitempty"`
	InternalIDHasPrefix    *string  `json:"internalIDHasPrefix,omitempty"`
	InternalIDHasSuffix    *string  `json:"internalIDHasSuffix,omitempty"`
	InternalIDEqualFold    *string  `json:"internalIDEqualFold,omitempty"`
	InternalIDContainsFold *string  `json:"internalIDContainsFold,omitempty"`

	// "location" edge predicates.
	HasLocation     *bool                 `json:"hasLocation,omitempty"`
	HasLocationWith []*LocationWhereInput `json:"hasLocationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *LocationTagWhereInput) AddPredicates(predicates ...predicate.LocationTag) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the LocationTagWhereInput filter on the LocationTagQuery builder.
func (i *LocationTagWhereInput) Filter(q *LocationTagQuery) (*LocationTagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyLocationTagWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyLocationTagWhereInput is returned in case the LocationTagWhereInput is empty.
var ErrEmptyLocationTagWhereInput = errors.New("ent: empty predicate LocationTagWhereInput")

// P returns a predicate for filtering locationtags.
// An error is returned if the input is empty or invalid.
func (i *LocationTagWhereInput) P() (predicate.LocationTag, error) {
	var predicates []predicate.LocationTag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, locationtag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.LocationTag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, locationtag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.LocationTag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, locationtag.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, locationtag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, locationtag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, locationtag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, locationtag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, locationtag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, locationtag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, locationtag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, locationtag.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, locationtag.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, locationtag.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, locationtag.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, locationtag.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, locationtag.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, locationtag.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, locationtag.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, locationtag.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, locationtag.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, locationtag.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, locationtag.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, locationtag.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, locationtag.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.InternalID != nil {
		predicates = append(predicates, locationtag.InternalIDEQ(*i.InternalID))
	}
	if i.InternalIDNEQ != nil {
		predicates = append(predicates, locationtag.InternalIDNEQ(*i.InternalIDNEQ))
	}
	if len(i.InternalIDIn) > 0 {
		predicates = append(predicates, locationtag.InternalIDIn(i.InternalIDIn...))
	}
	if len(i.InternalIDNotIn) > 0 {
		predicates = append(predicates, locationtag.InternalIDNotIn(i.InternalIDNotIn...))
	}
	if i.InternalIDGT != nil {
		predicates = append(predicates, locationtag.InternalIDGT(*i.InternalIDGT))
	}
	if i.InternalIDGTE != nil {
		predicates = append(predicates, locationtag.InternalIDGTE(*i.InternalIDGTE))
	}
	if i.InternalIDLT != nil {
		predicates = append(predicates, locationtag.InternalIDLT(*i.InternalIDLT))
	}
	if i.InternalIDLTE != nil {
		predicates = append(predicates, locationtag.InternalIDLTE(*i.InternalIDLTE))
	}
	if i.InternalIDContains != nil {
		predicates = append(predicates, locationtag.InternalIDContains(*i.InternalIDContains))
	}
	if i.InternalIDHasPrefix != nil {
		predicates = append(predicates, locationtag.InternalIDHasPrefix(*i.InternalIDHasPrefix))
	}
	if i.InternalIDHasSuffix != nil {
		predicates = append(predicates, locationtag.InternalIDHasSuffix(*i.InternalIDHasSuffix))
	}
	if i.InternalIDEqualFold != nil {
		predicates = append(predicates, locationtag.InternalIDEqualFold(*i.InternalIDEqualFold))
	}
	if i.InternalIDContainsFold != nil {
		predicates = append(predicates, locationtag.InternalIDContainsFold(*i.InternalIDContainsFold))
	}

	if i.HasLocation != nil {
		p := locationtag.HasLocation()
		if !*i.HasLocation {
			p = locationtag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasLocationWith))
		for _, w := range i.HasLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, locationtag.HasLocationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyLocationTagWhereInput
	case 1:
		return predicates[0], nil
	default:
		return locationtag.And(predicates...), nil
	}
}

// NotificationWhereInput represents a where input for filtering Notification queries.
type NotificationWhereInput struct {
	Predicates []predicate.Notification  `json:"-"`
	Not        *NotificationWhereInput   `json:"not,omitempty"`
	Or         []*NotificationWhereInput `json:"or,omitempty"`
	And        []*NotificationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "active" field predicates.
	Active    *bool `json:"active,omitempty"`
	ActiveNEQ *bool `json:"activeNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "connection" edge predicates.
	HasConnection     *bool                   `json:"hasConnection,omitempty"`
	HasConnectionWith []*ConnectionWhereInput `json:"hasConnectionWith,omitempty"`

	// "email_template" edge predicates.
	HasEmailTemplate     *bool                      `json:"hasEmailTemplate,omitempty"`
	HasEmailTemplateWith []*EmailTemplateWhereInput `json:"hasEmailTemplateWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *NotificationWhereInput) AddPredicates(predicates ...predicate.Notification) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the NotificationWhereInput filter on the NotificationQuery builder.
func (i *NotificationWhereInput) Filter(q *NotificationQuery) (*NotificationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyNotificationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyNotificationWhereInput is returned in case the NotificationWhereInput is empty.
var ErrEmptyNotificationWhereInput = errors.New("ent: empty predicate NotificationWhereInput")

// P returns a predicate for filtering notifications.
// An error is returned if the input is empty or invalid.
func (i *NotificationWhereInput) P() (predicate.Notification, error) {
	var predicates []predicate.Notification
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, notification.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Notification, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, notification.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Notification, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, notification.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, notification.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, notification.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, notification.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, notification.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, notification.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, notification.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, notification.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, notification.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, notification.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, notification.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, notification.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, notification.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, notification.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, notification.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, notification.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, notification.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, notification.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, notification.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, notification.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, notification.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, notification.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, notification.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, notification.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, notification.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, notification.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, notification.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, notification.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, notification.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, notification.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, notification.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, notification.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, notification.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, notification.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, notification.NameContainsFold(*i.NameContainsFold))
	}
	if i.Active != nil {
		predicates = append(predicates, notification.ActiveEQ(*i.Active))
	}
	if i.ActiveNEQ != nil {
		predicates = append(predicates, notification.ActiveNEQ(*i.ActiveNEQ))
	}

	if i.HasTenant != nil {
		p := notification.HasTenant()
		if !*i.HasTenant {
			p = notification.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, notification.HasTenantWith(with...))
	}
	if i.HasConnection != nil {
		p := notification.HasConnection()
		if !*i.HasConnection {
			p = notification.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionWith))
		for _, w := range i.HasConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, notification.HasConnectionWith(with...))
	}
	if i.HasEmailTemplate != nil {
		p := notification.HasEmailTemplate()
		if !*i.HasEmailTemplate {
			p = notification.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmailTemplateWith) > 0 {
		with := make([]predicate.EmailTemplate, 0, len(i.HasEmailTemplateWith))
		for _, w := range i.HasEmailTemplateWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmailTemplateWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, notification.HasEmailTemplateWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyNotificationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return notification.And(predicates...), nil
	}
}

// OTKRequestsWhereInput represents a where input for filtering OTKRequests queries.
type OTKRequestsWhereInput struct {
	Predicates []predicate.OTKRequests  `json:"-"`
	Not        *OTKRequestsWhereInput   `json:"not,omitempty"`
	Or         []*OTKRequestsWhereInput `json:"or,omitempty"`
	And        []*OTKRequestsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "otk" field predicates.
	Otk             *string  `json:"otk,omitempty"`
	OtkNEQ          *string  `json:"otkNEQ,omitempty"`
	OtkIn           []string `json:"otkIn,omitempty"`
	OtkNotIn        []string `json:"otkNotIn,omitempty"`
	OtkGT           *string  `json:"otkGT,omitempty"`
	OtkGTE          *string  `json:"otkGTE,omitempty"`
	OtkLT           *string  `json:"otkLT,omitempty"`
	OtkLTE          *string  `json:"otkLTE,omitempty"`
	OtkContains     *string  `json:"otkContains,omitempty"`
	OtkHasPrefix    *string  `json:"otkHasPrefix,omitempty"`
	OtkHasSuffix    *string  `json:"otkHasSuffix,omitempty"`
	OtkEqualFold    *string  `json:"otkEqualFold,omitempty"`
	OtkContainsFold *string  `json:"otkContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OTKRequestsWhereInput) AddPredicates(predicates ...predicate.OTKRequests) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OTKRequestsWhereInput filter on the OTKRequestsQuery builder.
func (i *OTKRequestsWhereInput) Filter(q *OTKRequestsQuery) (*OTKRequestsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOTKRequestsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOTKRequestsWhereInput is returned in case the OTKRequestsWhereInput is empty.
var ErrEmptyOTKRequestsWhereInput = errors.New("ent: empty predicate OTKRequestsWhereInput")

// P returns a predicate for filtering otkrequestsslice.
// An error is returned if the input is empty or invalid.
func (i *OTKRequestsWhereInput) P() (predicate.OTKRequests, error) {
	var predicates []predicate.OTKRequests
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, otkrequests.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OTKRequests, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, otkrequests.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OTKRequests, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, otkrequests.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, otkrequests.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, otkrequests.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, otkrequests.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, otkrequests.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, otkrequests.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, otkrequests.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, otkrequests.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, otkrequests.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, otkrequests.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, otkrequests.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, otkrequests.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, otkrequests.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, otkrequests.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, otkrequests.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, otkrequests.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, otkrequests.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, otkrequests.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, otkrequests.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, otkrequests.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, otkrequests.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, otkrequests.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Otk != nil {
		predicates = append(predicates, otkrequests.OtkEQ(*i.Otk))
	}
	if i.OtkNEQ != nil {
		predicates = append(predicates, otkrequests.OtkNEQ(*i.OtkNEQ))
	}
	if len(i.OtkIn) > 0 {
		predicates = append(predicates, otkrequests.OtkIn(i.OtkIn...))
	}
	if len(i.OtkNotIn) > 0 {
		predicates = append(predicates, otkrequests.OtkNotIn(i.OtkNotIn...))
	}
	if i.OtkGT != nil {
		predicates = append(predicates, otkrequests.OtkGT(*i.OtkGT))
	}
	if i.OtkGTE != nil {
		predicates = append(predicates, otkrequests.OtkGTE(*i.OtkGTE))
	}
	if i.OtkLT != nil {
		predicates = append(predicates, otkrequests.OtkLT(*i.OtkLT))
	}
	if i.OtkLTE != nil {
		predicates = append(predicates, otkrequests.OtkLTE(*i.OtkLTE))
	}
	if i.OtkContains != nil {
		predicates = append(predicates, otkrequests.OtkContains(*i.OtkContains))
	}
	if i.OtkHasPrefix != nil {
		predicates = append(predicates, otkrequests.OtkHasPrefix(*i.OtkHasPrefix))
	}
	if i.OtkHasSuffix != nil {
		predicates = append(predicates, otkrequests.OtkHasSuffix(*i.OtkHasSuffix))
	}
	if i.OtkEqualFold != nil {
		predicates = append(predicates, otkrequests.OtkEqualFold(*i.OtkEqualFold))
	}
	if i.OtkContainsFold != nil {
		predicates = append(predicates, otkrequests.OtkContainsFold(*i.OtkContainsFold))
	}

	if i.HasTenant != nil {
		p := otkrequests.HasTenant()
		if !*i.HasTenant {
			p = otkrequests.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, otkrequests.HasTenantWith(with...))
	}
	if i.HasUsers != nil {
		p := otkrequests.HasUsers()
		if !*i.HasUsers {
			p = otkrequests.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, otkrequests.HasUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOTKRequestsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return otkrequests.And(predicates...), nil
	}
}

// OrderWhereInput represents a where input for filtering Order queries.
type OrderWhereInput struct {
	Predicates []predicate.Order  `json:"-"`
	Not        *OrderWhereInput   `json:"not,omitempty"`
	Or         []*OrderWhereInput `json:"or,omitempty"`
	And        []*OrderWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "order_public_id" field predicates.
	OrderPublicID             *string  `json:"orderPublicID,omitempty"`
	OrderPublicIDNEQ          *string  `json:"orderPublicIDNEQ,omitempty"`
	OrderPublicIDIn           []string `json:"orderPublicIDIn,omitempty"`
	OrderPublicIDNotIn        []string `json:"orderPublicIDNotIn,omitempty"`
	OrderPublicIDGT           *string  `json:"orderPublicIDGT,omitempty"`
	OrderPublicIDGTE          *string  `json:"orderPublicIDGTE,omitempty"`
	OrderPublicIDLT           *string  `json:"orderPublicIDLT,omitempty"`
	OrderPublicIDLTE          *string  `json:"orderPublicIDLTE,omitempty"`
	OrderPublicIDContains     *string  `json:"orderPublicIDContains,omitempty"`
	OrderPublicIDHasPrefix    *string  `json:"orderPublicIDHasPrefix,omitempty"`
	OrderPublicIDHasSuffix    *string  `json:"orderPublicIDHasSuffix,omitempty"`
	OrderPublicIDEqualFold    *string  `json:"orderPublicIDEqualFold,omitempty"`
	OrderPublicIDContainsFold *string  `json:"orderPublicIDContainsFold,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "comment_internal" field predicates.
	CommentInternal             *string  `json:"commentInternal,omitempty"`
	CommentInternalNEQ          *string  `json:"commentInternalNEQ,omitempty"`
	CommentInternalIn           []string `json:"commentInternalIn,omitempty"`
	CommentInternalNotIn        []string `json:"commentInternalNotIn,omitempty"`
	CommentInternalGT           *string  `json:"commentInternalGT,omitempty"`
	CommentInternalGTE          *string  `json:"commentInternalGTE,omitempty"`
	CommentInternalLT           *string  `json:"commentInternalLT,omitempty"`
	CommentInternalLTE          *string  `json:"commentInternalLTE,omitempty"`
	CommentInternalContains     *string  `json:"commentInternalContains,omitempty"`
	CommentInternalHasPrefix    *string  `json:"commentInternalHasPrefix,omitempty"`
	CommentInternalHasSuffix    *string  `json:"commentInternalHasSuffix,omitempty"`
	CommentInternalIsNil        bool     `json:"commentInternalIsNil,omitempty"`
	CommentInternalNotNil       bool     `json:"commentInternalNotNil,omitempty"`
	CommentInternalEqualFold    *string  `json:"commentInternalEqualFold,omitempty"`
	CommentInternalContainsFold *string  `json:"commentInternalContainsFold,omitempty"`

	// "comment_external" field predicates.
	CommentExternal             *string  `json:"commentExternal,omitempty"`
	CommentExternalNEQ          *string  `json:"commentExternalNEQ,omitempty"`
	CommentExternalIn           []string `json:"commentExternalIn,omitempty"`
	CommentExternalNotIn        []string `json:"commentExternalNotIn,omitempty"`
	CommentExternalGT           *string  `json:"commentExternalGT,omitempty"`
	CommentExternalGTE          *string  `json:"commentExternalGTE,omitempty"`
	CommentExternalLT           *string  `json:"commentExternalLT,omitempty"`
	CommentExternalLTE          *string  `json:"commentExternalLTE,omitempty"`
	CommentExternalContains     *string  `json:"commentExternalContains,omitempty"`
	CommentExternalHasPrefix    *string  `json:"commentExternalHasPrefix,omitempty"`
	CommentExternalHasSuffix    *string  `json:"commentExternalHasSuffix,omitempty"`
	CommentExternalIsNil        bool     `json:"commentExternalIsNil,omitempty"`
	CommentExternalNotNil       bool     `json:"commentExternalNotNil,omitempty"`
	CommentExternalEqualFold    *string  `json:"commentExternalEqualFold,omitempty"`
	CommentExternalContainsFold *string  `json:"commentExternalContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "email_sync_confirmation_at" field predicates.
	EmailSyncConfirmationAt       *time.Time  `json:"emailSyncConfirmationAt,omitempty"`
	EmailSyncConfirmationAtNEQ    *time.Time  `json:"emailSyncConfirmationAtNEQ,omitempty"`
	EmailSyncConfirmationAtIn     []time.Time `json:"emailSyncConfirmationAtIn,omitempty"`
	EmailSyncConfirmationAtNotIn  []time.Time `json:"emailSyncConfirmationAtNotIn,omitempty"`
	EmailSyncConfirmationAtGT     *time.Time  `json:"emailSyncConfirmationAtGT,omitempty"`
	EmailSyncConfirmationAtGTE    *time.Time  `json:"emailSyncConfirmationAtGTE,omitempty"`
	EmailSyncConfirmationAtLT     *time.Time  `json:"emailSyncConfirmationAtLT,omitempty"`
	EmailSyncConfirmationAtLTE    *time.Time  `json:"emailSyncConfirmationAtLTE,omitempty"`
	EmailSyncConfirmationAtIsNil  bool        `json:"emailSyncConfirmationAtIsNil,omitempty"`
	EmailSyncConfirmationAtNotNil bool        `json:"emailSyncConfirmationAtNotNil,omitempty"`

	// "status" field predicates.
	Status      *order.Status  `json:"status,omitempty"`
	StatusNEQ   *order.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []order.Status `json:"statusIn,omitempty"`
	StatusNotIn []order.Status `json:"statusNotIn,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "order_history" edge predicates.
	HasOrderHistory     *bool                     `json:"hasOrderHistory,omitempty"`
	HasOrderHistoryWith []*OrderHistoryWhereInput `json:"hasOrderHistoryWith,omitempty"`

	// "connection" edge predicates.
	HasConnection     *bool                   `json:"hasConnection,omitempty"`
	HasConnectionWith []*ConnectionWhereInput `json:"hasConnectionWith,omitempty"`

	// "colli" edge predicates.
	HasColli     *bool              `json:"hasColli,omitempty"`
	HasColliWith []*ColliWhereInput `json:"hasColliWith,omitempty"`

	// "return_colli" edge predicates.
	HasReturnColli     *bool                    `json:"hasReturnColli,omitempty"`
	HasReturnColliWith []*ReturnColliWhereInput `json:"hasReturnColliWith,omitempty"`

	// "hypothesis_test_delivery_option_request" edge predicates.
	HasHypothesisTestDeliveryOptionRequest     *bool                                            `json:"hasHypothesisTestDeliveryOptionRequest,omitempty"`
	HasHypothesisTestDeliveryOptionRequestWith []*HypothesisTestDeliveryOptionRequestWhereInput `json:"hasHypothesisTestDeliveryOptionRequestWith,omitempty"`

	// "pallet" edge predicates.
	HasPallet     *bool               `json:"hasPallet,omitempty"`
	HasPalletWith []*PalletWhereInput `json:"hasPalletWith,omitempty"`

	// "consolidation" edge predicates.
	HasConsolidation     *bool                      `json:"hasConsolidation,omitempty"`
	HasConsolidationWith []*ConsolidationWhereInput `json:"hasConsolidationWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrderWhereInput) AddPredicates(predicates ...predicate.Order) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrderWhereInput filter on the OrderQuery builder.
func (i *OrderWhereInput) Filter(q *OrderQuery) (*OrderQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrderWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrderWhereInput is returned in case the OrderWhereInput is empty.
var ErrEmptyOrderWhereInput = errors.New("ent: empty predicate OrderWhereInput")

// P returns a predicate for filtering orders.
// An error is returned if the input is empty or invalid.
func (i *OrderWhereInput) P() (predicate.Order, error) {
	var predicates []predicate.Order
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, order.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Order, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, order.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Order, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, order.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, order.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, order.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, order.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, order.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, order.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, order.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, order.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, order.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, order.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, order.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, order.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, order.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, order.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, order.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, order.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, order.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, order.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, order.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, order.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, order.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, order.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.OrderPublicID != nil {
		predicates = append(predicates, order.OrderPublicIDEQ(*i.OrderPublicID))
	}
	if i.OrderPublicIDNEQ != nil {
		predicates = append(predicates, order.OrderPublicIDNEQ(*i.OrderPublicIDNEQ))
	}
	if len(i.OrderPublicIDIn) > 0 {
		predicates = append(predicates, order.OrderPublicIDIn(i.OrderPublicIDIn...))
	}
	if len(i.OrderPublicIDNotIn) > 0 {
		predicates = append(predicates, order.OrderPublicIDNotIn(i.OrderPublicIDNotIn...))
	}
	if i.OrderPublicIDGT != nil {
		predicates = append(predicates, order.OrderPublicIDGT(*i.OrderPublicIDGT))
	}
	if i.OrderPublicIDGTE != nil {
		predicates = append(predicates, order.OrderPublicIDGTE(*i.OrderPublicIDGTE))
	}
	if i.OrderPublicIDLT != nil {
		predicates = append(predicates, order.OrderPublicIDLT(*i.OrderPublicIDLT))
	}
	if i.OrderPublicIDLTE != nil {
		predicates = append(predicates, order.OrderPublicIDLTE(*i.OrderPublicIDLTE))
	}
	if i.OrderPublicIDContains != nil {
		predicates = append(predicates, order.OrderPublicIDContains(*i.OrderPublicIDContains))
	}
	if i.OrderPublicIDHasPrefix != nil {
		predicates = append(predicates, order.OrderPublicIDHasPrefix(*i.OrderPublicIDHasPrefix))
	}
	if i.OrderPublicIDHasSuffix != nil {
		predicates = append(predicates, order.OrderPublicIDHasSuffix(*i.OrderPublicIDHasSuffix))
	}
	if i.OrderPublicIDEqualFold != nil {
		predicates = append(predicates, order.OrderPublicIDEqualFold(*i.OrderPublicIDEqualFold))
	}
	if i.OrderPublicIDContainsFold != nil {
		predicates = append(predicates, order.OrderPublicIDContainsFold(*i.OrderPublicIDContainsFold))
	}
	if i.ExternalID != nil {
		predicates = append(predicates, order.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, order.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, order.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, order.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, order.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, order.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, order.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, order.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, order.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, order.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, order.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, order.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, order.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, order.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, order.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.CommentInternal != nil {
		predicates = append(predicates, order.CommentInternalEQ(*i.CommentInternal))
	}
	if i.CommentInternalNEQ != nil {
		predicates = append(predicates, order.CommentInternalNEQ(*i.CommentInternalNEQ))
	}
	if len(i.CommentInternalIn) > 0 {
		predicates = append(predicates, order.CommentInternalIn(i.CommentInternalIn...))
	}
	if len(i.CommentInternalNotIn) > 0 {
		predicates = append(predicates, order.CommentInternalNotIn(i.CommentInternalNotIn...))
	}
	if i.CommentInternalGT != nil {
		predicates = append(predicates, order.CommentInternalGT(*i.CommentInternalGT))
	}
	if i.CommentInternalGTE != nil {
		predicates = append(predicates, order.CommentInternalGTE(*i.CommentInternalGTE))
	}
	if i.CommentInternalLT != nil {
		predicates = append(predicates, order.CommentInternalLT(*i.CommentInternalLT))
	}
	if i.CommentInternalLTE != nil {
		predicates = append(predicates, order.CommentInternalLTE(*i.CommentInternalLTE))
	}
	if i.CommentInternalContains != nil {
		predicates = append(predicates, order.CommentInternalContains(*i.CommentInternalContains))
	}
	if i.CommentInternalHasPrefix != nil {
		predicates = append(predicates, order.CommentInternalHasPrefix(*i.CommentInternalHasPrefix))
	}
	if i.CommentInternalHasSuffix != nil {
		predicates = append(predicates, order.CommentInternalHasSuffix(*i.CommentInternalHasSuffix))
	}
	if i.CommentInternalIsNil {
		predicates = append(predicates, order.CommentInternalIsNil())
	}
	if i.CommentInternalNotNil {
		predicates = append(predicates, order.CommentInternalNotNil())
	}
	if i.CommentInternalEqualFold != nil {
		predicates = append(predicates, order.CommentInternalEqualFold(*i.CommentInternalEqualFold))
	}
	if i.CommentInternalContainsFold != nil {
		predicates = append(predicates, order.CommentInternalContainsFold(*i.CommentInternalContainsFold))
	}
	if i.CommentExternal != nil {
		predicates = append(predicates, order.CommentExternalEQ(*i.CommentExternal))
	}
	if i.CommentExternalNEQ != nil {
		predicates = append(predicates, order.CommentExternalNEQ(*i.CommentExternalNEQ))
	}
	if len(i.CommentExternalIn) > 0 {
		predicates = append(predicates, order.CommentExternalIn(i.CommentExternalIn...))
	}
	if len(i.CommentExternalNotIn) > 0 {
		predicates = append(predicates, order.CommentExternalNotIn(i.CommentExternalNotIn...))
	}
	if i.CommentExternalGT != nil {
		predicates = append(predicates, order.CommentExternalGT(*i.CommentExternalGT))
	}
	if i.CommentExternalGTE != nil {
		predicates = append(predicates, order.CommentExternalGTE(*i.CommentExternalGTE))
	}
	if i.CommentExternalLT != nil {
		predicates = append(predicates, order.CommentExternalLT(*i.CommentExternalLT))
	}
	if i.CommentExternalLTE != nil {
		predicates = append(predicates, order.CommentExternalLTE(*i.CommentExternalLTE))
	}
	if i.CommentExternalContains != nil {
		predicates = append(predicates, order.CommentExternalContains(*i.CommentExternalContains))
	}
	if i.CommentExternalHasPrefix != nil {
		predicates = append(predicates, order.CommentExternalHasPrefix(*i.CommentExternalHasPrefix))
	}
	if i.CommentExternalHasSuffix != nil {
		predicates = append(predicates, order.CommentExternalHasSuffix(*i.CommentExternalHasSuffix))
	}
	if i.CommentExternalIsNil {
		predicates = append(predicates, order.CommentExternalIsNil())
	}
	if i.CommentExternalNotNil {
		predicates = append(predicates, order.CommentExternalNotNil())
	}
	if i.CommentExternalEqualFold != nil {
		predicates = append(predicates, order.CommentExternalEqualFold(*i.CommentExternalEqualFold))
	}
	if i.CommentExternalContainsFold != nil {
		predicates = append(predicates, order.CommentExternalContainsFold(*i.CommentExternalContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, order.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, order.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, order.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, order.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, order.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, order.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, order.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, order.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.EmailSyncConfirmationAt != nil {
		predicates = append(predicates, order.EmailSyncConfirmationAtEQ(*i.EmailSyncConfirmationAt))
	}
	if i.EmailSyncConfirmationAtNEQ != nil {
		predicates = append(predicates, order.EmailSyncConfirmationAtNEQ(*i.EmailSyncConfirmationAtNEQ))
	}
	if len(i.EmailSyncConfirmationAtIn) > 0 {
		predicates = append(predicates, order.EmailSyncConfirmationAtIn(i.EmailSyncConfirmationAtIn...))
	}
	if len(i.EmailSyncConfirmationAtNotIn) > 0 {
		predicates = append(predicates, order.EmailSyncConfirmationAtNotIn(i.EmailSyncConfirmationAtNotIn...))
	}
	if i.EmailSyncConfirmationAtGT != nil {
		predicates = append(predicates, order.EmailSyncConfirmationAtGT(*i.EmailSyncConfirmationAtGT))
	}
	if i.EmailSyncConfirmationAtGTE != nil {
		predicates = append(predicates, order.EmailSyncConfirmationAtGTE(*i.EmailSyncConfirmationAtGTE))
	}
	if i.EmailSyncConfirmationAtLT != nil {
		predicates = append(predicates, order.EmailSyncConfirmationAtLT(*i.EmailSyncConfirmationAtLT))
	}
	if i.EmailSyncConfirmationAtLTE != nil {
		predicates = append(predicates, order.EmailSyncConfirmationAtLTE(*i.EmailSyncConfirmationAtLTE))
	}
	if i.EmailSyncConfirmationAtIsNil {
		predicates = append(predicates, order.EmailSyncConfirmationAtIsNil())
	}
	if i.EmailSyncConfirmationAtNotNil {
		predicates = append(predicates, order.EmailSyncConfirmationAtNotNil())
	}
	if i.Status != nil {
		predicates = append(predicates, order.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, order.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, order.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, order.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasTenant != nil {
		p := order.HasTenant()
		if !*i.HasTenant {
			p = order.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, order.HasTenantWith(with...))
	}
	if i.HasOrderHistory != nil {
		p := order.HasOrderHistory()
		if !*i.HasOrderHistory {
			p = order.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrderHistoryWith) > 0 {
		with := make([]predicate.OrderHistory, 0, len(i.HasOrderHistoryWith))
		for _, w := range i.HasOrderHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrderHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, order.HasOrderHistoryWith(with...))
	}
	if i.HasConnection != nil {
		p := order.HasConnection()
		if !*i.HasConnection {
			p = order.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionWith))
		for _, w := range i.HasConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, order.HasConnectionWith(with...))
	}
	if i.HasColli != nil {
		p := order.HasColli()
		if !*i.HasColli {
			p = order.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasColliWith))
		for _, w := range i.HasColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, order.HasColliWith(with...))
	}
	if i.HasReturnColli != nil {
		p := order.HasReturnColli()
		if !*i.HasReturnColli {
			p = order.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnColliWith) > 0 {
		with := make([]predicate.ReturnColli, 0, len(i.HasReturnColliWith))
		for _, w := range i.HasReturnColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, order.HasReturnColliWith(with...))
	}
	if i.HasHypothesisTestDeliveryOptionRequest != nil {
		p := order.HasHypothesisTestDeliveryOptionRequest()
		if !*i.HasHypothesisTestDeliveryOptionRequest {
			p = order.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasHypothesisTestDeliveryOptionRequestWith) > 0 {
		with := make([]predicate.HypothesisTestDeliveryOptionRequest, 0, len(i.HasHypothesisTestDeliveryOptionRequestWith))
		for _, w := range i.HasHypothesisTestDeliveryOptionRequestWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasHypothesisTestDeliveryOptionRequestWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, order.HasHypothesisTestDeliveryOptionRequestWith(with...))
	}
	if i.HasPallet != nil {
		p := order.HasPallet()
		if !*i.HasPallet {
			p = order.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPalletWith) > 0 {
		with := make([]predicate.Pallet, 0, len(i.HasPalletWith))
		for _, w := range i.HasPalletWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPalletWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, order.HasPalletWith(with...))
	}
	if i.HasConsolidation != nil {
		p := order.HasConsolidation()
		if !*i.HasConsolidation {
			p = order.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConsolidationWith) > 0 {
		with := make([]predicate.Consolidation, 0, len(i.HasConsolidationWith))
		for _, w := range i.HasConsolidationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConsolidationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, order.HasConsolidationWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrderWhereInput
	case 1:
		return predicates[0], nil
	default:
		return order.And(predicates...), nil
	}
}

// OrderHistoryWhereInput represents a where input for filtering OrderHistory queries.
type OrderHistoryWhereInput struct {
	Predicates []predicate.OrderHistory  `json:"-"`
	Not        *OrderHistoryWhereInput   `json:"not,omitempty"`
	Or         []*OrderHistoryWhereInput `json:"or,omitempty"`
	And        []*OrderHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "type" field predicates.
	Type      *orderhistory.Type  `json:"type,omitempty"`
	TypeNEQ   *orderhistory.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []orderhistory.Type `json:"typeIn,omitempty"`
	TypeNotIn []orderhistory.Type `json:"typeNotIn,omitempty"`

	// "change_history" edge predicates.
	HasChangeHistory     *bool                      `json:"hasChangeHistory,omitempty"`
	HasChangeHistoryWith []*ChangeHistoryWhereInput `json:"hasChangeHistoryWith,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "order" edge predicates.
	HasOrder     *bool              `json:"hasOrder,omitempty"`
	HasOrderWith []*OrderWhereInput `json:"hasOrderWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrderHistoryWhereInput) AddPredicates(predicates ...predicate.OrderHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrderHistoryWhereInput filter on the OrderHistoryQuery builder.
func (i *OrderHistoryWhereInput) Filter(q *OrderHistoryQuery) (*OrderHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrderHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrderHistoryWhereInput is returned in case the OrderHistoryWhereInput is empty.
var ErrEmptyOrderHistoryWhereInput = errors.New("ent: empty predicate OrderHistoryWhereInput")

// P returns a predicate for filtering orderhistories.
// An error is returned if the input is empty or invalid.
func (i *OrderHistoryWhereInput) P() (predicate.OrderHistory, error) {
	var predicates []predicate.OrderHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orderhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrderHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orderhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrderHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orderhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orderhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orderhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orderhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orderhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orderhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orderhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orderhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orderhistory.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, orderhistory.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, orderhistory.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, orderhistory.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, orderhistory.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, orderhistory.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, orderhistory.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, orderhistory.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, orderhistory.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, orderhistory.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, orderhistory.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, orderhistory.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, orderhistory.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, orderhistory.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, orderhistory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, orderhistory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, orderhistory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, orderhistory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, orderhistory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, orderhistory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, orderhistory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, orderhistory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, orderhistory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, orderhistory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, orderhistory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, orderhistory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, orderhistory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, orderhistory.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, orderhistory.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, orderhistory.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, orderhistory.TypeNotIn(i.TypeNotIn...))
	}

	if i.HasChangeHistory != nil {
		p := orderhistory.HasChangeHistory()
		if !*i.HasChangeHistory {
			p = orderhistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChangeHistoryWith) > 0 {
		with := make([]predicate.ChangeHistory, 0, len(i.HasChangeHistoryWith))
		for _, w := range i.HasChangeHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChangeHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orderhistory.HasChangeHistoryWith(with...))
	}
	if i.HasTenant != nil {
		p := orderhistory.HasTenant()
		if !*i.HasTenant {
			p = orderhistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orderhistory.HasTenantWith(with...))
	}
	if i.HasOrder != nil {
		p := orderhistory.HasOrder()
		if !*i.HasOrder {
			p = orderhistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrderWith) > 0 {
		with := make([]predicate.Order, 0, len(i.HasOrderWith))
		for _, w := range i.HasOrderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orderhistory.HasOrderWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrderHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orderhistory.And(predicates...), nil
	}
}

// OrderLineWhereInput represents a where input for filtering OrderLine queries.
type OrderLineWhereInput struct {
	Predicates []predicate.OrderLine  `json:"-"`
	Not        *OrderLineWhereInput   `json:"not,omitempty"`
	Or         []*OrderLineWhereInput `json:"or,omitempty"`
	And        []*OrderLineWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "unit_price" field predicates.
	UnitPrice      *float64  `json:"unitPrice,omitempty"`
	UnitPriceNEQ   *float64  `json:"unitPriceNEQ,omitempty"`
	UnitPriceIn    []float64 `json:"unitPriceIn,omitempty"`
	UnitPriceNotIn []float64 `json:"unitPriceNotIn,omitempty"`
	UnitPriceGT    *float64  `json:"unitPriceGT,omitempty"`
	UnitPriceGTE   *float64  `json:"unitPriceGTE,omitempty"`
	UnitPriceLT    *float64  `json:"unitPriceLT,omitempty"`
	UnitPriceLTE   *float64  `json:"unitPriceLTE,omitempty"`

	// "discount_allocation_amount" field predicates.
	DiscountAllocationAmount      *float64  `json:"discountAllocationAmount,omitempty"`
	DiscountAllocationAmountNEQ   *float64  `json:"discountAllocationAmountNEQ,omitempty"`
	DiscountAllocationAmountIn    []float64 `json:"discountAllocationAmountIn,omitempty"`
	DiscountAllocationAmountNotIn []float64 `json:"discountAllocationAmountNotIn,omitempty"`
	DiscountAllocationAmountGT    *float64  `json:"discountAllocationAmountGT,omitempty"`
	DiscountAllocationAmountGTE   *float64  `json:"discountAllocationAmountGTE,omitempty"`
	DiscountAllocationAmountLT    *float64  `json:"discountAllocationAmountLT,omitempty"`
	DiscountAllocationAmountLTE   *float64  `json:"discountAllocationAmountLTE,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "units" field predicates.
	Units      *int  `json:"units,omitempty"`
	UnitsNEQ   *int  `json:"unitsNEQ,omitempty"`
	UnitsIn    []int `json:"unitsIn,omitempty"`
	UnitsNotIn []int `json:"unitsNotIn,omitempty"`
	UnitsGT    *int  `json:"unitsGT,omitempty"`
	UnitsGTE   *int  `json:"unitsGTE,omitempty"`
	UnitsLT    *int  `json:"unitsLT,omitempty"`
	UnitsLTE   *int  `json:"unitsLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "product_variant_id" field predicates.
	ProductVariantID             *pulid.ID  `json:"productVariantID,omitempty"`
	ProductVariantIDNEQ          *pulid.ID  `json:"productVariantIDNEQ,omitempty"`
	ProductVariantIDIn           []pulid.ID `json:"productVariantIDIn,omitempty"`
	ProductVariantIDNotIn        []pulid.ID `json:"productVariantIDNotIn,omitempty"`
	ProductVariantIDGT           *pulid.ID  `json:"productVariantIDGT,omitempty"`
	ProductVariantIDGTE          *pulid.ID  `json:"productVariantIDGTE,omitempty"`
	ProductVariantIDLT           *pulid.ID  `json:"productVariantIDLT,omitempty"`
	ProductVariantIDLTE          *pulid.ID  `json:"productVariantIDLTE,omitempty"`
	ProductVariantIDContains     *pulid.ID  `json:"productVariantIDContains,omitempty"`
	ProductVariantIDHasPrefix    *pulid.ID  `json:"productVariantIDHasPrefix,omitempty"`
	ProductVariantIDHasSuffix    *pulid.ID  `json:"productVariantIDHasSuffix,omitempty"`
	ProductVariantIDEqualFold    *pulid.ID  `json:"productVariantIDEqualFold,omitempty"`
	ProductVariantIDContainsFold *pulid.ID  `json:"productVariantIDContainsFold,omitempty"`

	// "colli_id" field predicates.
	ColliID             *pulid.ID  `json:"colliID,omitempty"`
	ColliIDNEQ          *pulid.ID  `json:"colliIDNEQ,omitempty"`
	ColliIDIn           []pulid.ID `json:"colliIDIn,omitempty"`
	ColliIDNotIn        []pulid.ID `json:"colliIDNotIn,omitempty"`
	ColliIDGT           *pulid.ID  `json:"colliIDGT,omitempty"`
	ColliIDGTE          *pulid.ID  `json:"colliIDGTE,omitempty"`
	ColliIDLT           *pulid.ID  `json:"colliIDLT,omitempty"`
	ColliIDLTE          *pulid.ID  `json:"colliIDLTE,omitempty"`
	ColliIDContains     *pulid.ID  `json:"colliIDContains,omitempty"`
	ColliIDHasPrefix    *pulid.ID  `json:"colliIDHasPrefix,omitempty"`
	ColliIDHasSuffix    *pulid.ID  `json:"colliIDHasSuffix,omitempty"`
	ColliIDEqualFold    *pulid.ID  `json:"colliIDEqualFold,omitempty"`
	ColliIDContainsFold *pulid.ID  `json:"colliIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "product_variant" edge predicates.
	HasProductVariant     *bool                       `json:"hasProductVariant,omitempty"`
	HasProductVariantWith []*ProductVariantWhereInput `json:"hasProductVariantWith,omitempty"`

	// "colli" edge predicates.
	HasColli     *bool              `json:"hasColli,omitempty"`
	HasColliWith []*ColliWhereInput `json:"hasColliWith,omitempty"`

	// "return_order_line" edge predicates.
	HasReturnOrderLine     *bool                        `json:"hasReturnOrderLine,omitempty"`
	HasReturnOrderLineWith []*ReturnOrderLineWhereInput `json:"hasReturnOrderLineWith,omitempty"`

	// "currency" edge predicates.
	HasCurrency     *bool                 `json:"hasCurrency,omitempty"`
	HasCurrencyWith []*CurrencyWhereInput `json:"hasCurrencyWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrderLineWhereInput) AddPredicates(predicates ...predicate.OrderLine) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrderLineWhereInput filter on the OrderLineQuery builder.
func (i *OrderLineWhereInput) Filter(q *OrderLineQuery) (*OrderLineQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrderLineWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrderLineWhereInput is returned in case the OrderLineWhereInput is empty.
var ErrEmptyOrderLineWhereInput = errors.New("ent: empty predicate OrderLineWhereInput")

// P returns a predicate for filtering orderlines.
// An error is returned if the input is empty or invalid.
func (i *OrderLineWhereInput) P() (predicate.OrderLine, error) {
	var predicates []predicate.OrderLine
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, orderline.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrderLine, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, orderline.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrderLine, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, orderline.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, orderline.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, orderline.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, orderline.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, orderline.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, orderline.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, orderline.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, orderline.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, orderline.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, orderline.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, orderline.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, orderline.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, orderline.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, orderline.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, orderline.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, orderline.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, orderline.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, orderline.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, orderline.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, orderline.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, orderline.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, orderline.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.UnitPrice != nil {
		predicates = append(predicates, orderline.UnitPriceEQ(*i.UnitPrice))
	}
	if i.UnitPriceNEQ != nil {
		predicates = append(predicates, orderline.UnitPriceNEQ(*i.UnitPriceNEQ))
	}
	if len(i.UnitPriceIn) > 0 {
		predicates = append(predicates, orderline.UnitPriceIn(i.UnitPriceIn...))
	}
	if len(i.UnitPriceNotIn) > 0 {
		predicates = append(predicates, orderline.UnitPriceNotIn(i.UnitPriceNotIn...))
	}
	if i.UnitPriceGT != nil {
		predicates = append(predicates, orderline.UnitPriceGT(*i.UnitPriceGT))
	}
	if i.UnitPriceGTE != nil {
		predicates = append(predicates, orderline.UnitPriceGTE(*i.UnitPriceGTE))
	}
	if i.UnitPriceLT != nil {
		predicates = append(predicates, orderline.UnitPriceLT(*i.UnitPriceLT))
	}
	if i.UnitPriceLTE != nil {
		predicates = append(predicates, orderline.UnitPriceLTE(*i.UnitPriceLTE))
	}
	if i.DiscountAllocationAmount != nil {
		predicates = append(predicates, orderline.DiscountAllocationAmountEQ(*i.DiscountAllocationAmount))
	}
	if i.DiscountAllocationAmountNEQ != nil {
		predicates = append(predicates, orderline.DiscountAllocationAmountNEQ(*i.DiscountAllocationAmountNEQ))
	}
	if len(i.DiscountAllocationAmountIn) > 0 {
		predicates = append(predicates, orderline.DiscountAllocationAmountIn(i.DiscountAllocationAmountIn...))
	}
	if len(i.DiscountAllocationAmountNotIn) > 0 {
		predicates = append(predicates, orderline.DiscountAllocationAmountNotIn(i.DiscountAllocationAmountNotIn...))
	}
	if i.DiscountAllocationAmountGT != nil {
		predicates = append(predicates, orderline.DiscountAllocationAmountGT(*i.DiscountAllocationAmountGT))
	}
	if i.DiscountAllocationAmountGTE != nil {
		predicates = append(predicates, orderline.DiscountAllocationAmountGTE(*i.DiscountAllocationAmountGTE))
	}
	if i.DiscountAllocationAmountLT != nil {
		predicates = append(predicates, orderline.DiscountAllocationAmountLT(*i.DiscountAllocationAmountLT))
	}
	if i.DiscountAllocationAmountLTE != nil {
		predicates = append(predicates, orderline.DiscountAllocationAmountLTE(*i.DiscountAllocationAmountLTE))
	}
	if i.ExternalID != nil {
		predicates = append(predicates, orderline.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, orderline.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, orderline.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, orderline.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, orderline.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, orderline.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, orderline.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, orderline.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, orderline.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, orderline.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, orderline.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, orderline.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, orderline.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, orderline.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, orderline.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.Units != nil {
		predicates = append(predicates, orderline.UnitsEQ(*i.Units))
	}
	if i.UnitsNEQ != nil {
		predicates = append(predicates, orderline.UnitsNEQ(*i.UnitsNEQ))
	}
	if len(i.UnitsIn) > 0 {
		predicates = append(predicates, orderline.UnitsIn(i.UnitsIn...))
	}
	if len(i.UnitsNotIn) > 0 {
		predicates = append(predicates, orderline.UnitsNotIn(i.UnitsNotIn...))
	}
	if i.UnitsGT != nil {
		predicates = append(predicates, orderline.UnitsGT(*i.UnitsGT))
	}
	if i.UnitsGTE != nil {
		predicates = append(predicates, orderline.UnitsGTE(*i.UnitsGTE))
	}
	if i.UnitsLT != nil {
		predicates = append(predicates, orderline.UnitsLT(*i.UnitsLT))
	}
	if i.UnitsLTE != nil {
		predicates = append(predicates, orderline.UnitsLTE(*i.UnitsLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, orderline.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, orderline.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, orderline.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, orderline.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, orderline.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, orderline.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, orderline.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, orderline.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, orderline.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, orderline.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, orderline.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, orderline.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, orderline.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, orderline.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, orderline.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, orderline.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, orderline.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, orderline.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.ProductVariantID != nil {
		predicates = append(predicates, orderline.ProductVariantIDEQ(*i.ProductVariantID))
	}
	if i.ProductVariantIDNEQ != nil {
		predicates = append(predicates, orderline.ProductVariantIDNEQ(*i.ProductVariantIDNEQ))
	}
	if len(i.ProductVariantIDIn) > 0 {
		predicates = append(predicates, orderline.ProductVariantIDIn(i.ProductVariantIDIn...))
	}
	if len(i.ProductVariantIDNotIn) > 0 {
		predicates = append(predicates, orderline.ProductVariantIDNotIn(i.ProductVariantIDNotIn...))
	}
	if i.ProductVariantIDGT != nil {
		predicates = append(predicates, orderline.ProductVariantIDGT(*i.ProductVariantIDGT))
	}
	if i.ProductVariantIDGTE != nil {
		predicates = append(predicates, orderline.ProductVariantIDGTE(*i.ProductVariantIDGTE))
	}
	if i.ProductVariantIDLT != nil {
		predicates = append(predicates, orderline.ProductVariantIDLT(*i.ProductVariantIDLT))
	}
	if i.ProductVariantIDLTE != nil {
		predicates = append(predicates, orderline.ProductVariantIDLTE(*i.ProductVariantIDLTE))
	}
	if i.ProductVariantIDContains != nil {
		predicates = append(predicates, orderline.ProductVariantIDContains(*i.ProductVariantIDContains))
	}
	if i.ProductVariantIDHasPrefix != nil {
		predicates = append(predicates, orderline.ProductVariantIDHasPrefix(*i.ProductVariantIDHasPrefix))
	}
	if i.ProductVariantIDHasSuffix != nil {
		predicates = append(predicates, orderline.ProductVariantIDHasSuffix(*i.ProductVariantIDHasSuffix))
	}
	if i.ProductVariantIDEqualFold != nil {
		predicates = append(predicates, orderline.ProductVariantIDEqualFold(*i.ProductVariantIDEqualFold))
	}
	if i.ProductVariantIDContainsFold != nil {
		predicates = append(predicates, orderline.ProductVariantIDContainsFold(*i.ProductVariantIDContainsFold))
	}
	if i.ColliID != nil {
		predicates = append(predicates, orderline.ColliIDEQ(*i.ColliID))
	}
	if i.ColliIDNEQ != nil {
		predicates = append(predicates, orderline.ColliIDNEQ(*i.ColliIDNEQ))
	}
	if len(i.ColliIDIn) > 0 {
		predicates = append(predicates, orderline.ColliIDIn(i.ColliIDIn...))
	}
	if len(i.ColliIDNotIn) > 0 {
		predicates = append(predicates, orderline.ColliIDNotIn(i.ColliIDNotIn...))
	}
	if i.ColliIDGT != nil {
		predicates = append(predicates, orderline.ColliIDGT(*i.ColliIDGT))
	}
	if i.ColliIDGTE != nil {
		predicates = append(predicates, orderline.ColliIDGTE(*i.ColliIDGTE))
	}
	if i.ColliIDLT != nil {
		predicates = append(predicates, orderline.ColliIDLT(*i.ColliIDLT))
	}
	if i.ColliIDLTE != nil {
		predicates = append(predicates, orderline.ColliIDLTE(*i.ColliIDLTE))
	}
	if i.ColliIDContains != nil {
		predicates = append(predicates, orderline.ColliIDContains(*i.ColliIDContains))
	}
	if i.ColliIDHasPrefix != nil {
		predicates = append(predicates, orderline.ColliIDHasPrefix(*i.ColliIDHasPrefix))
	}
	if i.ColliIDHasSuffix != nil {
		predicates = append(predicates, orderline.ColliIDHasSuffix(*i.ColliIDHasSuffix))
	}
	if i.ColliIDEqualFold != nil {
		predicates = append(predicates, orderline.ColliIDEqualFold(*i.ColliIDEqualFold))
	}
	if i.ColliIDContainsFold != nil {
		predicates = append(predicates, orderline.ColliIDContainsFold(*i.ColliIDContainsFold))
	}

	if i.HasTenant != nil {
		p := orderline.HasTenant()
		if !*i.HasTenant {
			p = orderline.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orderline.HasTenantWith(with...))
	}
	if i.HasProductVariant != nil {
		p := orderline.HasProductVariant()
		if !*i.HasProductVariant {
			p = orderline.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductVariantWith) > 0 {
		with := make([]predicate.ProductVariant, 0, len(i.HasProductVariantWith))
		for _, w := range i.HasProductVariantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductVariantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orderline.HasProductVariantWith(with...))
	}
	if i.HasColli != nil {
		p := orderline.HasColli()
		if !*i.HasColli {
			p = orderline.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasColliWith))
		for _, w := range i.HasColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orderline.HasColliWith(with...))
	}
	if i.HasReturnOrderLine != nil {
		p := orderline.HasReturnOrderLine()
		if !*i.HasReturnOrderLine {
			p = orderline.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnOrderLineWith) > 0 {
		with := make([]predicate.ReturnOrderLine, 0, len(i.HasReturnOrderLineWith))
		for _, w := range i.HasReturnOrderLineWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnOrderLineWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orderline.HasReturnOrderLineWith(with...))
	}
	if i.HasCurrency != nil {
		p := orderline.HasCurrency()
		if !*i.HasCurrency {
			p = orderline.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCurrencyWith) > 0 {
		with := make([]predicate.Currency, 0, len(i.HasCurrencyWith))
		for _, w := range i.HasCurrencyWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCurrencyWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, orderline.HasCurrencyWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrderLineWhereInput
	case 1:
		return predicates[0], nil
	default:
		return orderline.And(predicates...), nil
	}
}

// OrderSenderWhereInput represents a where input for filtering OrderSender queries.
type OrderSenderWhereInput struct {
	Predicates []predicate.OrderSender  `json:"-"`
	Not        *OrderSenderWhereInput   `json:"not,omitempty"`
	Or         []*OrderSenderWhereInput `json:"or,omitempty"`
	And        []*OrderSenderWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "vat_number" field predicates.
	VatNumber             *string  `json:"vatNumber,omitempty"`
	VatNumberNEQ          *string  `json:"vatNumberNEQ,omitempty"`
	VatNumberIn           []string `json:"vatNumberIn,omitempty"`
	VatNumberNotIn        []string `json:"vatNumberNotIn,omitempty"`
	VatNumberGT           *string  `json:"vatNumberGT,omitempty"`
	VatNumberGTE          *string  `json:"vatNumberGTE,omitempty"`
	VatNumberLT           *string  `json:"vatNumberLT,omitempty"`
	VatNumberLTE          *string  `json:"vatNumberLTE,omitempty"`
	VatNumberContains     *string  `json:"vatNumberContains,omitempty"`
	VatNumberHasPrefix    *string  `json:"vatNumberHasPrefix,omitempty"`
	VatNumberHasSuffix    *string  `json:"vatNumberHasSuffix,omitempty"`
	VatNumberEqualFold    *string  `json:"vatNumberEqualFold,omitempty"`
	VatNumberContainsFold *string  `json:"vatNumberContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OrderSenderWhereInput) AddPredicates(predicates ...predicate.OrderSender) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OrderSenderWhereInput filter on the OrderSenderQuery builder.
func (i *OrderSenderWhereInput) Filter(q *OrderSenderQuery) (*OrderSenderQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOrderSenderWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOrderSenderWhereInput is returned in case the OrderSenderWhereInput is empty.
var ErrEmptyOrderSenderWhereInput = errors.New("ent: empty predicate OrderSenderWhereInput")

// P returns a predicate for filtering ordersenders.
// An error is returned if the input is empty or invalid.
func (i *OrderSenderWhereInput) P() (predicate.OrderSender, error) {
	var predicates []predicate.OrderSender
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, ordersender.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OrderSender, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, ordersender.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OrderSender, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, ordersender.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, ordersender.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, ordersender.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, ordersender.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, ordersender.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, ordersender.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, ordersender.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, ordersender.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, ordersender.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, ordersender.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, ordersender.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, ordersender.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, ordersender.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, ordersender.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, ordersender.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, ordersender.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, ordersender.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, ordersender.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, ordersender.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, ordersender.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, ordersender.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, ordersender.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, ordersender.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, ordersender.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, ordersender.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, ordersender.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, ordersender.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, ordersender.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, ordersender.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, ordersender.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, ordersender.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, ordersender.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, ordersender.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, ordersender.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, ordersender.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, ordersender.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, ordersender.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, ordersender.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, ordersender.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, ordersender.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, ordersender.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, ordersender.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, ordersender.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, ordersender.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, ordersender.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, ordersender.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, ordersender.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, ordersender.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, ordersender.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, ordersender.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, ordersender.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, ordersender.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, ordersender.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, ordersender.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, ordersender.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, ordersender.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, ordersender.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, ordersender.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, ordersender.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, ordersender.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, ordersender.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, ordersender.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, ordersender.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, ordersender.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, ordersender.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, ordersender.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, ordersender.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, ordersender.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, ordersender.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, ordersender.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, ordersender.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, ordersender.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, ordersender.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, ordersender.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}
	if i.VatNumber != nil {
		predicates = append(predicates, ordersender.VatNumberEQ(*i.VatNumber))
	}
	if i.VatNumberNEQ != nil {
		predicates = append(predicates, ordersender.VatNumberNEQ(*i.VatNumberNEQ))
	}
	if len(i.VatNumberIn) > 0 {
		predicates = append(predicates, ordersender.VatNumberIn(i.VatNumberIn...))
	}
	if len(i.VatNumberNotIn) > 0 {
		predicates = append(predicates, ordersender.VatNumberNotIn(i.VatNumberNotIn...))
	}
	if i.VatNumberGT != nil {
		predicates = append(predicates, ordersender.VatNumberGT(*i.VatNumberGT))
	}
	if i.VatNumberGTE != nil {
		predicates = append(predicates, ordersender.VatNumberGTE(*i.VatNumberGTE))
	}
	if i.VatNumberLT != nil {
		predicates = append(predicates, ordersender.VatNumberLT(*i.VatNumberLT))
	}
	if i.VatNumberLTE != nil {
		predicates = append(predicates, ordersender.VatNumberLTE(*i.VatNumberLTE))
	}
	if i.VatNumberContains != nil {
		predicates = append(predicates, ordersender.VatNumberContains(*i.VatNumberContains))
	}
	if i.VatNumberHasPrefix != nil {
		predicates = append(predicates, ordersender.VatNumberHasPrefix(*i.VatNumberHasPrefix))
	}
	if i.VatNumberHasSuffix != nil {
		predicates = append(predicates, ordersender.VatNumberHasSuffix(*i.VatNumberHasSuffix))
	}
	if i.VatNumberEqualFold != nil {
		predicates = append(predicates, ordersender.VatNumberEqualFold(*i.VatNumberEqualFold))
	}
	if i.VatNumberContainsFold != nil {
		predicates = append(predicates, ordersender.VatNumberContainsFold(*i.VatNumberContainsFold))
	}

	if i.HasTenant != nil {
		p := ordersender.HasTenant()
		if !*i.HasTenant {
			p = ordersender.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, ordersender.HasTenantWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOrderSenderWhereInput
	case 1:
		return predicates[0], nil
	default:
		return ordersender.And(predicates...), nil
	}
}

// PackagingWhereInput represents a where input for filtering Packaging queries.
type PackagingWhereInput struct {
	Predicates []predicate.Packaging  `json:"-"`
	Not        *PackagingWhereInput   `json:"not,omitempty"`
	Or         []*PackagingWhereInput `json:"or,omitempty"`
	And        []*PackagingWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "archived_at" field predicates.
	ArchivedAt       *time.Time  `json:"archivedAt,omitempty"`
	ArchivedAtNEQ    *time.Time  `json:"archivedAtNEQ,omitempty"`
	ArchivedAtIn     []time.Time `json:"archivedAtIn,omitempty"`
	ArchivedAtNotIn  []time.Time `json:"archivedAtNotIn,omitempty"`
	ArchivedAtGT     *time.Time  `json:"archivedAtGT,omitempty"`
	ArchivedAtGTE    *time.Time  `json:"archivedAtGTE,omitempty"`
	ArchivedAtLT     *time.Time  `json:"archivedAtLT,omitempty"`
	ArchivedAtLTE    *time.Time  `json:"archivedAtLTE,omitempty"`
	ArchivedAtIsNil  bool        `json:"archivedAtIsNil,omitempty"`
	ArchivedAtNotNil bool        `json:"archivedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "height_cm" field predicates.
	HeightCm      *int  `json:"heightCm,omitempty"`
	HeightCmNEQ   *int  `json:"heightCmNEQ,omitempty"`
	HeightCmIn    []int `json:"heightCmIn,omitempty"`
	HeightCmNotIn []int `json:"heightCmNotIn,omitempty"`
	HeightCmGT    *int  `json:"heightCmGT,omitempty"`
	HeightCmGTE   *int  `json:"heightCmGTE,omitempty"`
	HeightCmLT    *int  `json:"heightCmLT,omitempty"`
	HeightCmLTE   *int  `json:"heightCmLTE,omitempty"`

	// "width_cm" field predicates.
	WidthCm      *int  `json:"widthCm,omitempty"`
	WidthCmNEQ   *int  `json:"widthCmNEQ,omitempty"`
	WidthCmIn    []int `json:"widthCmIn,omitempty"`
	WidthCmNotIn []int `json:"widthCmNotIn,omitempty"`
	WidthCmGT    *int  `json:"widthCmGT,omitempty"`
	WidthCmGTE   *int  `json:"widthCmGTE,omitempty"`
	WidthCmLT    *int  `json:"widthCmLT,omitempty"`
	WidthCmLTE   *int  `json:"widthCmLTE,omitempty"`

	// "length_cm" field predicates.
	LengthCm      *int  `json:"lengthCm,omitempty"`
	LengthCmNEQ   *int  `json:"lengthCmNEQ,omitempty"`
	LengthCmIn    []int `json:"lengthCmIn,omitempty"`
	LengthCmNotIn []int `json:"lengthCmNotIn,omitempty"`
	LengthCmGT    *int  `json:"lengthCmGT,omitempty"`
	LengthCmGTE   *int  `json:"lengthCmGTE,omitempty"`
	LengthCmLT    *int  `json:"lengthCmLT,omitempty"`
	LengthCmLTE   *int  `json:"lengthCmLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment_parcel" edge predicates.
	HasShipmentParcel     *bool                       `json:"hasShipmentParcel,omitempty"`
	HasShipmentParcelWith []*ShipmentParcelWhereInput `json:"hasShipmentParcelWith,omitempty"`

	// "pallet" edge predicates.
	HasPallet     *bool               `json:"hasPallet,omitempty"`
	HasPalletWith []*PalletWhereInput `json:"hasPalletWith,omitempty"`

	// "colli" edge predicates.
	HasColli     *bool              `json:"hasColli,omitempty"`
	HasColliWith []*ColliWhereInput `json:"hasColliWith,omitempty"`

	// "return_colli" edge predicates.
	HasReturnColli     *bool                    `json:"hasReturnColli,omitempty"`
	HasReturnColliWith []*ReturnColliWhereInput `json:"hasReturnColliWith,omitempty"`

	// "packaging_df" edge predicates.
	HasPackagingDF     *bool                    `json:"hasPackagingDF,omitempty"`
	HasPackagingDFWith []*PackagingDFWhereInput `json:"hasPackagingDFWith,omitempty"`

	// "packaging_usps" edge predicates.
	HasPackagingUSPS     *bool                      `json:"hasPackagingUSPS,omitempty"`
	HasPackagingUSPSWith []*PackagingUSPSWhereInput `json:"hasPackagingUSPSWith,omitempty"`

	// "carrier_brand" edge predicates.
	HasCarrierBrand     *bool                     `json:"hasCarrierBrand,omitempty"`
	HasCarrierBrandWith []*CarrierBrandWhereInput `json:"hasCarrierBrandWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PackagingWhereInput) AddPredicates(predicates ...predicate.Packaging) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PackagingWhereInput filter on the PackagingQuery builder.
func (i *PackagingWhereInput) Filter(q *PackagingQuery) (*PackagingQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPackagingWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPackagingWhereInput is returned in case the PackagingWhereInput is empty.
var ErrEmptyPackagingWhereInput = errors.New("ent: empty predicate PackagingWhereInput")

// P returns a predicate for filtering packagings.
// An error is returned if the input is empty or invalid.
func (i *PackagingWhereInput) P() (predicate.Packaging, error) {
	var predicates []predicate.Packaging
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, packaging.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Packaging, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, packaging.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Packaging, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, packaging.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, packaging.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, packaging.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, packaging.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, packaging.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, packaging.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, packaging.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, packaging.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, packaging.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, packaging.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, packaging.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, packaging.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, packaging.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, packaging.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, packaging.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, packaging.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, packaging.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, packaging.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, packaging.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, packaging.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, packaging.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, packaging.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ArchivedAt != nil {
		predicates = append(predicates, packaging.ArchivedAtEQ(*i.ArchivedAt))
	}
	if i.ArchivedAtNEQ != nil {
		predicates = append(predicates, packaging.ArchivedAtNEQ(*i.ArchivedAtNEQ))
	}
	if len(i.ArchivedAtIn) > 0 {
		predicates = append(predicates, packaging.ArchivedAtIn(i.ArchivedAtIn...))
	}
	if len(i.ArchivedAtNotIn) > 0 {
		predicates = append(predicates, packaging.ArchivedAtNotIn(i.ArchivedAtNotIn...))
	}
	if i.ArchivedAtGT != nil {
		predicates = append(predicates, packaging.ArchivedAtGT(*i.ArchivedAtGT))
	}
	if i.ArchivedAtGTE != nil {
		predicates = append(predicates, packaging.ArchivedAtGTE(*i.ArchivedAtGTE))
	}
	if i.ArchivedAtLT != nil {
		predicates = append(predicates, packaging.ArchivedAtLT(*i.ArchivedAtLT))
	}
	if i.ArchivedAtLTE != nil {
		predicates = append(predicates, packaging.ArchivedAtLTE(*i.ArchivedAtLTE))
	}
	if i.ArchivedAtIsNil {
		predicates = append(predicates, packaging.ArchivedAtIsNil())
	}
	if i.ArchivedAtNotNil {
		predicates = append(predicates, packaging.ArchivedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, packaging.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, packaging.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, packaging.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, packaging.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, packaging.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, packaging.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, packaging.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, packaging.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, packaging.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, packaging.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, packaging.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, packaging.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, packaging.NameContainsFold(*i.NameContainsFold))
	}
	if i.HeightCm != nil {
		predicates = append(predicates, packaging.HeightCmEQ(*i.HeightCm))
	}
	if i.HeightCmNEQ != nil {
		predicates = append(predicates, packaging.HeightCmNEQ(*i.HeightCmNEQ))
	}
	if len(i.HeightCmIn) > 0 {
		predicates = append(predicates, packaging.HeightCmIn(i.HeightCmIn...))
	}
	if len(i.HeightCmNotIn) > 0 {
		predicates = append(predicates, packaging.HeightCmNotIn(i.HeightCmNotIn...))
	}
	if i.HeightCmGT != nil {
		predicates = append(predicates, packaging.HeightCmGT(*i.HeightCmGT))
	}
	if i.HeightCmGTE != nil {
		predicates = append(predicates, packaging.HeightCmGTE(*i.HeightCmGTE))
	}
	if i.HeightCmLT != nil {
		predicates = append(predicates, packaging.HeightCmLT(*i.HeightCmLT))
	}
	if i.HeightCmLTE != nil {
		predicates = append(predicates, packaging.HeightCmLTE(*i.HeightCmLTE))
	}
	if i.WidthCm != nil {
		predicates = append(predicates, packaging.WidthCmEQ(*i.WidthCm))
	}
	if i.WidthCmNEQ != nil {
		predicates = append(predicates, packaging.WidthCmNEQ(*i.WidthCmNEQ))
	}
	if len(i.WidthCmIn) > 0 {
		predicates = append(predicates, packaging.WidthCmIn(i.WidthCmIn...))
	}
	if len(i.WidthCmNotIn) > 0 {
		predicates = append(predicates, packaging.WidthCmNotIn(i.WidthCmNotIn...))
	}
	if i.WidthCmGT != nil {
		predicates = append(predicates, packaging.WidthCmGT(*i.WidthCmGT))
	}
	if i.WidthCmGTE != nil {
		predicates = append(predicates, packaging.WidthCmGTE(*i.WidthCmGTE))
	}
	if i.WidthCmLT != nil {
		predicates = append(predicates, packaging.WidthCmLT(*i.WidthCmLT))
	}
	if i.WidthCmLTE != nil {
		predicates = append(predicates, packaging.WidthCmLTE(*i.WidthCmLTE))
	}
	if i.LengthCm != nil {
		predicates = append(predicates, packaging.LengthCmEQ(*i.LengthCm))
	}
	if i.LengthCmNEQ != nil {
		predicates = append(predicates, packaging.LengthCmNEQ(*i.LengthCmNEQ))
	}
	if len(i.LengthCmIn) > 0 {
		predicates = append(predicates, packaging.LengthCmIn(i.LengthCmIn...))
	}
	if len(i.LengthCmNotIn) > 0 {
		predicates = append(predicates, packaging.LengthCmNotIn(i.LengthCmNotIn...))
	}
	if i.LengthCmGT != nil {
		predicates = append(predicates, packaging.LengthCmGT(*i.LengthCmGT))
	}
	if i.LengthCmGTE != nil {
		predicates = append(predicates, packaging.LengthCmGTE(*i.LengthCmGTE))
	}
	if i.LengthCmLT != nil {
		predicates = append(predicates, packaging.LengthCmLT(*i.LengthCmLT))
	}
	if i.LengthCmLTE != nil {
		predicates = append(predicates, packaging.LengthCmLTE(*i.LengthCmLTE))
	}

	if i.HasTenant != nil {
		p := packaging.HasTenant()
		if !*i.HasTenant {
			p = packaging.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packaging.HasTenantWith(with...))
	}
	if i.HasShipmentParcel != nil {
		p := packaging.HasShipmentParcel()
		if !*i.HasShipmentParcel {
			p = packaging.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentParcelWith) > 0 {
		with := make([]predicate.ShipmentParcel, 0, len(i.HasShipmentParcelWith))
		for _, w := range i.HasShipmentParcelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentParcelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packaging.HasShipmentParcelWith(with...))
	}
	if i.HasPallet != nil {
		p := packaging.HasPallet()
		if !*i.HasPallet {
			p = packaging.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPalletWith) > 0 {
		with := make([]predicate.Pallet, 0, len(i.HasPalletWith))
		for _, w := range i.HasPalletWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPalletWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packaging.HasPalletWith(with...))
	}
	if i.HasColli != nil {
		p := packaging.HasColli()
		if !*i.HasColli {
			p = packaging.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasColliWith))
		for _, w := range i.HasColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packaging.HasColliWith(with...))
	}
	if i.HasReturnColli != nil {
		p := packaging.HasReturnColli()
		if !*i.HasReturnColli {
			p = packaging.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnColliWith) > 0 {
		with := make([]predicate.ReturnColli, 0, len(i.HasReturnColliWith))
		for _, w := range i.HasReturnColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packaging.HasReturnColliWith(with...))
	}
	if i.HasPackagingDF != nil {
		p := packaging.HasPackagingDF()
		if !*i.HasPackagingDF {
			p = packaging.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingDFWith) > 0 {
		with := make([]predicate.PackagingDF, 0, len(i.HasPackagingDFWith))
		for _, w := range i.HasPackagingDFWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingDFWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packaging.HasPackagingDFWith(with...))
	}
	if i.HasPackagingUSPS != nil {
		p := packaging.HasPackagingUSPS()
		if !*i.HasPackagingUSPS {
			p = packaging.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingUSPSWith) > 0 {
		with := make([]predicate.PackagingUSPS, 0, len(i.HasPackagingUSPSWith))
		for _, w := range i.HasPackagingUSPSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingUSPSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packaging.HasPackagingUSPSWith(with...))
	}
	if i.HasCarrierBrand != nil {
		p := packaging.HasCarrierBrand()
		if !*i.HasCarrierBrand {
			p = packaging.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierBrandWith) > 0 {
		with := make([]predicate.CarrierBrand, 0, len(i.HasCarrierBrandWith))
		for _, w := range i.HasCarrierBrandWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierBrandWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packaging.HasCarrierBrandWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := packaging.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = packaging.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packaging.HasDeliveryOptionWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPackagingWhereInput
	case 1:
		return predicates[0], nil
	default:
		return packaging.And(predicates...), nil
	}
}

// PackagingDFWhereInput represents a where input for filtering PackagingDF queries.
type PackagingDFWhereInput struct {
	Predicates []predicate.PackagingDF  `json:"-"`
	Not        *PackagingDFWhereInput   `json:"not,omitempty"`
	Or         []*PackagingDFWhereInput `json:"or,omitempty"`
	And        []*PackagingDFWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "api_type" field predicates.
	APIType      *packagingdf.APIType  `json:"apiType,omitempty"`
	APITypeNEQ   *packagingdf.APIType  `json:"apiTypeNEQ,omitempty"`
	APITypeIn    []packagingdf.APIType `json:"apiTypeIn,omitempty"`
	APITypeNotIn []packagingdf.APIType `json:"apiTypeNotIn,omitempty"`

	// "max_weight" field predicates.
	MaxWeight       *float64  `json:"maxWeight,omitempty"`
	MaxWeightNEQ    *float64  `json:"maxWeightNEQ,omitempty"`
	MaxWeightIn     []float64 `json:"maxWeightIn,omitempty"`
	MaxWeightNotIn  []float64 `json:"maxWeightNotIn,omitempty"`
	MaxWeightGT     *float64  `json:"maxWeightGT,omitempty"`
	MaxWeightGTE    *float64  `json:"maxWeightGTE,omitempty"`
	MaxWeightLT     *float64  `json:"maxWeightLT,omitempty"`
	MaxWeightLTE    *float64  `json:"maxWeightLTE,omitempty"`
	MaxWeightIsNil  bool      `json:"maxWeightIsNil,omitempty"`
	MaxWeightNotNil bool      `json:"maxWeightNotNil,omitempty"`

	// "min_weight" field predicates.
	MinWeight       *float64  `json:"minWeight,omitempty"`
	MinWeightNEQ    *float64  `json:"minWeightNEQ,omitempty"`
	MinWeightIn     []float64 `json:"minWeightIn,omitempty"`
	MinWeightNotIn  []float64 `json:"minWeightNotIn,omitempty"`
	MinWeightGT     *float64  `json:"minWeightGT,omitempty"`
	MinWeightGTE    *float64  `json:"minWeightGTE,omitempty"`
	MinWeightLT     *float64  `json:"minWeightLT,omitempty"`
	MinWeightLTE    *float64  `json:"minWeightLTE,omitempty"`
	MinWeightIsNil  bool      `json:"minWeightIsNil,omitempty"`
	MinWeightNotNil bool      `json:"minWeightNotNil,omitempty"`

	// "stackable" field predicates.
	Stackable    *bool `json:"stackable,omitempty"`
	StackableNEQ *bool `json:"stackableNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "packaging" edge predicates.
	HasPackaging     *bool                  `json:"hasPackaging,omitempty"`
	HasPackagingWith []*PackagingWhereInput `json:"hasPackagingWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PackagingDFWhereInput) AddPredicates(predicates ...predicate.PackagingDF) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PackagingDFWhereInput filter on the PackagingDFQuery builder.
func (i *PackagingDFWhereInput) Filter(q *PackagingDFQuery) (*PackagingDFQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPackagingDFWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPackagingDFWhereInput is returned in case the PackagingDFWhereInput is empty.
var ErrEmptyPackagingDFWhereInput = errors.New("ent: empty predicate PackagingDFWhereInput")

// P returns a predicate for filtering packagingdfs.
// An error is returned if the input is empty or invalid.
func (i *PackagingDFWhereInput) P() (predicate.PackagingDF, error) {
	var predicates []predicate.PackagingDF
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, packagingdf.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PackagingDF, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, packagingdf.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PackagingDF, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, packagingdf.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, packagingdf.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, packagingdf.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, packagingdf.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, packagingdf.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, packagingdf.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, packagingdf.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, packagingdf.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, packagingdf.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, packagingdf.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, packagingdf.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, packagingdf.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, packagingdf.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, packagingdf.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, packagingdf.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, packagingdf.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, packagingdf.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, packagingdf.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, packagingdf.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, packagingdf.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, packagingdf.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, packagingdf.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.APIType != nil {
		predicates = append(predicates, packagingdf.APITypeEQ(*i.APIType))
	}
	if i.APITypeNEQ != nil {
		predicates = append(predicates, packagingdf.APITypeNEQ(*i.APITypeNEQ))
	}
	if len(i.APITypeIn) > 0 {
		predicates = append(predicates, packagingdf.APITypeIn(i.APITypeIn...))
	}
	if len(i.APITypeNotIn) > 0 {
		predicates = append(predicates, packagingdf.APITypeNotIn(i.APITypeNotIn...))
	}
	if i.MaxWeight != nil {
		predicates = append(predicates, packagingdf.MaxWeightEQ(*i.MaxWeight))
	}
	if i.MaxWeightNEQ != nil {
		predicates = append(predicates, packagingdf.MaxWeightNEQ(*i.MaxWeightNEQ))
	}
	if len(i.MaxWeightIn) > 0 {
		predicates = append(predicates, packagingdf.MaxWeightIn(i.MaxWeightIn...))
	}
	if len(i.MaxWeightNotIn) > 0 {
		predicates = append(predicates, packagingdf.MaxWeightNotIn(i.MaxWeightNotIn...))
	}
	if i.MaxWeightGT != nil {
		predicates = append(predicates, packagingdf.MaxWeightGT(*i.MaxWeightGT))
	}
	if i.MaxWeightGTE != nil {
		predicates = append(predicates, packagingdf.MaxWeightGTE(*i.MaxWeightGTE))
	}
	if i.MaxWeightLT != nil {
		predicates = append(predicates, packagingdf.MaxWeightLT(*i.MaxWeightLT))
	}
	if i.MaxWeightLTE != nil {
		predicates = append(predicates, packagingdf.MaxWeightLTE(*i.MaxWeightLTE))
	}
	if i.MaxWeightIsNil {
		predicates = append(predicates, packagingdf.MaxWeightIsNil())
	}
	if i.MaxWeightNotNil {
		predicates = append(predicates, packagingdf.MaxWeightNotNil())
	}
	if i.MinWeight != nil {
		predicates = append(predicates, packagingdf.MinWeightEQ(*i.MinWeight))
	}
	if i.MinWeightNEQ != nil {
		predicates = append(predicates, packagingdf.MinWeightNEQ(*i.MinWeightNEQ))
	}
	if len(i.MinWeightIn) > 0 {
		predicates = append(predicates, packagingdf.MinWeightIn(i.MinWeightIn...))
	}
	if len(i.MinWeightNotIn) > 0 {
		predicates = append(predicates, packagingdf.MinWeightNotIn(i.MinWeightNotIn...))
	}
	if i.MinWeightGT != nil {
		predicates = append(predicates, packagingdf.MinWeightGT(*i.MinWeightGT))
	}
	if i.MinWeightGTE != nil {
		predicates = append(predicates, packagingdf.MinWeightGTE(*i.MinWeightGTE))
	}
	if i.MinWeightLT != nil {
		predicates = append(predicates, packagingdf.MinWeightLT(*i.MinWeightLT))
	}
	if i.MinWeightLTE != nil {
		predicates = append(predicates, packagingdf.MinWeightLTE(*i.MinWeightLTE))
	}
	if i.MinWeightIsNil {
		predicates = append(predicates, packagingdf.MinWeightIsNil())
	}
	if i.MinWeightNotNil {
		predicates = append(predicates, packagingdf.MinWeightNotNil())
	}
	if i.Stackable != nil {
		predicates = append(predicates, packagingdf.StackableEQ(*i.Stackable))
	}
	if i.StackableNEQ != nil {
		predicates = append(predicates, packagingdf.StackableNEQ(*i.StackableNEQ))
	}

	if i.HasTenant != nil {
		p := packagingdf.HasTenant()
		if !*i.HasTenant {
			p = packagingdf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packagingdf.HasTenantWith(with...))
	}
	if i.HasPackaging != nil {
		p := packagingdf.HasPackaging()
		if !*i.HasPackaging {
			p = packagingdf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingWith) > 0 {
		with := make([]predicate.Packaging, 0, len(i.HasPackagingWith))
		for _, w := range i.HasPackagingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packagingdf.HasPackagingWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPackagingDFWhereInput
	case 1:
		return predicates[0], nil
	default:
		return packagingdf.And(predicates...), nil
	}
}

// PackagingUSPSWhereInput represents a where input for filtering PackagingUSPS queries.
type PackagingUSPSWhereInput struct {
	Predicates []predicate.PackagingUSPS  `json:"-"`
	Not        *PackagingUSPSWhereInput   `json:"not,omitempty"`
	Or         []*PackagingUSPSWhereInput `json:"or,omitempty"`
	And        []*PackagingUSPSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "packaging" edge predicates.
	HasPackaging     *bool                  `json:"hasPackaging,omitempty"`
	HasPackagingWith []*PackagingWhereInput `json:"hasPackagingWith,omitempty"`

	// "packaging_usps_rate_indicator" edge predicates.
	HasPackagingUSPSRateIndicator     *bool                                   `json:"hasPackagingUSPSRateIndicator,omitempty"`
	HasPackagingUSPSRateIndicatorWith []*PackagingUSPSRateIndicatorWhereInput `json:"hasPackagingUSPSRateIndicatorWith,omitempty"`

	// "packaging_usps_processing_category" edge predicates.
	HasPackagingUSPSProcessingCategory     *bool                                        `json:"hasPackagingUSPSProcessingCategory,omitempty"`
	HasPackagingUSPSProcessingCategoryWith []*PackagingUSPSProcessingCategoryWhereInput `json:"hasPackagingUSPSProcessingCategoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PackagingUSPSWhereInput) AddPredicates(predicates ...predicate.PackagingUSPS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PackagingUSPSWhereInput filter on the PackagingUSPSQuery builder.
func (i *PackagingUSPSWhereInput) Filter(q *PackagingUSPSQuery) (*PackagingUSPSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPackagingUSPSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPackagingUSPSWhereInput is returned in case the PackagingUSPSWhereInput is empty.
var ErrEmptyPackagingUSPSWhereInput = errors.New("ent: empty predicate PackagingUSPSWhereInput")

// P returns a predicate for filtering packaginguspss.
// An error is returned if the input is empty or invalid.
func (i *PackagingUSPSWhereInput) P() (predicate.PackagingUSPS, error) {
	var predicates []predicate.PackagingUSPS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, packagingusps.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PackagingUSPS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, packagingusps.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PackagingUSPS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, packagingusps.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, packagingusps.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, packagingusps.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, packagingusps.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, packagingusps.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, packagingusps.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, packagingusps.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, packagingusps.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, packagingusps.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, packagingusps.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, packagingusps.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, packagingusps.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, packagingusps.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, packagingusps.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, packagingusps.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, packagingusps.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, packagingusps.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, packagingusps.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, packagingusps.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, packagingusps.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, packagingusps.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, packagingusps.TenantIDContainsFold(*i.TenantIDContainsFold))
	}

	if i.HasTenant != nil {
		p := packagingusps.HasTenant()
		if !*i.HasTenant {
			p = packagingusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packagingusps.HasTenantWith(with...))
	}
	if i.HasPackaging != nil {
		p := packagingusps.HasPackaging()
		if !*i.HasPackaging {
			p = packagingusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingWith) > 0 {
		with := make([]predicate.Packaging, 0, len(i.HasPackagingWith))
		for _, w := range i.HasPackagingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packagingusps.HasPackagingWith(with...))
	}
	if i.HasPackagingUSPSRateIndicator != nil {
		p := packagingusps.HasPackagingUSPSRateIndicator()
		if !*i.HasPackagingUSPSRateIndicator {
			p = packagingusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingUSPSRateIndicatorWith) > 0 {
		with := make([]predicate.PackagingUSPSRateIndicator, 0, len(i.HasPackagingUSPSRateIndicatorWith))
		for _, w := range i.HasPackagingUSPSRateIndicatorWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingUSPSRateIndicatorWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packagingusps.HasPackagingUSPSRateIndicatorWith(with...))
	}
	if i.HasPackagingUSPSProcessingCategory != nil {
		p := packagingusps.HasPackagingUSPSProcessingCategory()
		if !*i.HasPackagingUSPSProcessingCategory {
			p = packagingusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingUSPSProcessingCategoryWith) > 0 {
		with := make([]predicate.PackagingUSPSProcessingCategory, 0, len(i.HasPackagingUSPSProcessingCategoryWith))
		for _, w := range i.HasPackagingUSPSProcessingCategoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingUSPSProcessingCategoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packagingusps.HasPackagingUSPSProcessingCategoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPackagingUSPSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return packagingusps.And(predicates...), nil
	}
}

// PackagingUSPSProcessingCategoryWhereInput represents a where input for filtering PackagingUSPSProcessingCategory queries.
type PackagingUSPSProcessingCategoryWhereInput struct {
	Predicates []predicate.PackagingUSPSProcessingCategory  `json:"-"`
	Not        *PackagingUSPSProcessingCategoryWhereInput   `json:"not,omitempty"`
	Or         []*PackagingUSPSProcessingCategoryWhereInput `json:"or,omitempty"`
	And        []*PackagingUSPSProcessingCategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "processing_category" field predicates.
	ProcessingCategory      *packaginguspsprocessingcategory.ProcessingCategory  `json:"processingCategory,omitempty"`
	ProcessingCategoryNEQ   *packaginguspsprocessingcategory.ProcessingCategory  `json:"processingCategoryNEQ,omitempty"`
	ProcessingCategoryIn    []packaginguspsprocessingcategory.ProcessingCategory `json:"processingCategoryIn,omitempty"`
	ProcessingCategoryNotIn []packaginguspsprocessingcategory.ProcessingCategory `json:"processingCategoryNotIn,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PackagingUSPSProcessingCategoryWhereInput) AddPredicates(predicates ...predicate.PackagingUSPSProcessingCategory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PackagingUSPSProcessingCategoryWhereInput filter on the PackagingUSPSProcessingCategoryQuery builder.
func (i *PackagingUSPSProcessingCategoryWhereInput) Filter(q *PackagingUSPSProcessingCategoryQuery) (*PackagingUSPSProcessingCategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPackagingUSPSProcessingCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPackagingUSPSProcessingCategoryWhereInput is returned in case the PackagingUSPSProcessingCategoryWhereInput is empty.
var ErrEmptyPackagingUSPSProcessingCategoryWhereInput = errors.New("ent: empty predicate PackagingUSPSProcessingCategoryWhereInput")

// P returns a predicate for filtering packaginguspsprocessingcategories.
// An error is returned if the input is empty or invalid.
func (i *PackagingUSPSProcessingCategoryWhereInput) P() (predicate.PackagingUSPSProcessingCategory, error) {
	var predicates []predicate.PackagingUSPSProcessingCategory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, packaginguspsprocessingcategory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PackagingUSPSProcessingCategory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, packaginguspsprocessingcategory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PackagingUSPSProcessingCategory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, packaginguspsprocessingcategory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, packaginguspsprocessingcategory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, packaginguspsprocessingcategory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, packaginguspsprocessingcategory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, packaginguspsprocessingcategory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.NameContainsFold(*i.NameContainsFold))
	}
	if i.ProcessingCategory != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.ProcessingCategoryEQ(*i.ProcessingCategory))
	}
	if i.ProcessingCategoryNEQ != nil {
		predicates = append(predicates, packaginguspsprocessingcategory.ProcessingCategoryNEQ(*i.ProcessingCategoryNEQ))
	}
	if len(i.ProcessingCategoryIn) > 0 {
		predicates = append(predicates, packaginguspsprocessingcategory.ProcessingCategoryIn(i.ProcessingCategoryIn...))
	}
	if len(i.ProcessingCategoryNotIn) > 0 {
		predicates = append(predicates, packaginguspsprocessingcategory.ProcessingCategoryNotIn(i.ProcessingCategoryNotIn...))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPackagingUSPSProcessingCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return packaginguspsprocessingcategory.And(predicates...), nil
	}
}

// PackagingUSPSRateIndicatorWhereInput represents a where input for filtering PackagingUSPSRateIndicator queries.
type PackagingUSPSRateIndicatorWhereInput struct {
	Predicates []predicate.PackagingUSPSRateIndicator  `json:"-"`
	Not        *PackagingUSPSRateIndicatorWhereInput   `json:"not,omitempty"`
	Or         []*PackagingUSPSRateIndicatorWhereInput `json:"or,omitempty"`
	And        []*PackagingUSPSRateIndicatorWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "code" field predicates.
	Code             *string  `json:"code,omitempty"`
	CodeNEQ          *string  `json:"codeNEQ,omitempty"`
	CodeIn           []string `json:"codeIn,omitempty"`
	CodeNotIn        []string `json:"codeNotIn,omitempty"`
	CodeGT           *string  `json:"codeGT,omitempty"`
	CodeGTE          *string  `json:"codeGTE,omitempty"`
	CodeLT           *string  `json:"codeLT,omitempty"`
	CodeLTE          *string  `json:"codeLTE,omitempty"`
	CodeContains     *string  `json:"codeContains,omitempty"`
	CodeHasPrefix    *string  `json:"codeHasPrefix,omitempty"`
	CodeHasSuffix    *string  `json:"codeHasSuffix,omitempty"`
	CodeEqualFold    *string  `json:"codeEqualFold,omitempty"`
	CodeContainsFold *string  `json:"codeContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "packaging_usps" edge predicates.
	HasPackagingUSPS     *bool                      `json:"hasPackagingUSPS,omitempty"`
	HasPackagingUSPSWith []*PackagingUSPSWhereInput `json:"hasPackagingUSPSWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PackagingUSPSRateIndicatorWhereInput) AddPredicates(predicates ...predicate.PackagingUSPSRateIndicator) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PackagingUSPSRateIndicatorWhereInput filter on the PackagingUSPSRateIndicatorQuery builder.
func (i *PackagingUSPSRateIndicatorWhereInput) Filter(q *PackagingUSPSRateIndicatorQuery) (*PackagingUSPSRateIndicatorQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPackagingUSPSRateIndicatorWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPackagingUSPSRateIndicatorWhereInput is returned in case the PackagingUSPSRateIndicatorWhereInput is empty.
var ErrEmptyPackagingUSPSRateIndicatorWhereInput = errors.New("ent: empty predicate PackagingUSPSRateIndicatorWhereInput")

// P returns a predicate for filtering packaginguspsrateindicators.
// An error is returned if the input is empty or invalid.
func (i *PackagingUSPSRateIndicatorWhereInput) P() (predicate.PackagingUSPSRateIndicator, error) {
	var predicates []predicate.PackagingUSPSRateIndicator
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, packaginguspsrateindicator.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PackagingUSPSRateIndicator, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, packaginguspsrateindicator.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PackagingUSPSRateIndicator, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, packaginguspsrateindicator.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, packaginguspsrateindicator.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, packaginguspsrateindicator.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, packaginguspsrateindicator.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, packaginguspsrateindicator.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, packaginguspsrateindicator.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, packaginguspsrateindicator.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, packaginguspsrateindicator.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, packaginguspsrateindicator.IDLTE(*i.IDLTE))
	}
	if i.Code != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeEQ(*i.Code))
	}
	if i.CodeNEQ != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeNEQ(*i.CodeNEQ))
	}
	if len(i.CodeIn) > 0 {
		predicates = append(predicates, packaginguspsrateindicator.CodeIn(i.CodeIn...))
	}
	if len(i.CodeNotIn) > 0 {
		predicates = append(predicates, packaginguspsrateindicator.CodeNotIn(i.CodeNotIn...))
	}
	if i.CodeGT != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeGT(*i.CodeGT))
	}
	if i.CodeGTE != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeGTE(*i.CodeGTE))
	}
	if i.CodeLT != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeLT(*i.CodeLT))
	}
	if i.CodeLTE != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeLTE(*i.CodeLTE))
	}
	if i.CodeContains != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeContains(*i.CodeContains))
	}
	if i.CodeHasPrefix != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeHasPrefix(*i.CodeHasPrefix))
	}
	if i.CodeHasSuffix != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeHasSuffix(*i.CodeHasSuffix))
	}
	if i.CodeEqualFold != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeEqualFold(*i.CodeEqualFold))
	}
	if i.CodeContainsFold != nil {
		predicates = append(predicates, packaginguspsrateindicator.CodeContainsFold(*i.CodeContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, packaginguspsrateindicator.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, packaginguspsrateindicator.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, packaginguspsrateindicator.NameContainsFold(*i.NameContainsFold))
	}

	if i.HasPackagingUSPS != nil {
		p := packaginguspsrateindicator.HasPackagingUSPS()
		if !*i.HasPackagingUSPS {
			p = packaginguspsrateindicator.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingUSPSWith) > 0 {
		with := make([]predicate.PackagingUSPS, 0, len(i.HasPackagingUSPSWith))
		for _, w := range i.HasPackagingUSPSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingUSPSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, packaginguspsrateindicator.HasPackagingUSPSWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPackagingUSPSRateIndicatorWhereInput
	case 1:
		return predicates[0], nil
	default:
		return packaginguspsrateindicator.And(predicates...), nil
	}
}

// PalletWhereInput represents a where input for filtering Pallet queries.
type PalletWhereInput struct {
	Predicates []predicate.Pallet  `json:"-"`
	Not        *PalletWhereInput   `json:"not,omitempty"`
	Or         []*PalletWhereInput `json:"or,omitempty"`
	And        []*PalletWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "public_id" field predicates.
	PublicID             *string  `json:"publicID,omitempty"`
	PublicIDNEQ          *string  `json:"publicIDNEQ,omitempty"`
	PublicIDIn           []string `json:"publicIDIn,omitempty"`
	PublicIDNotIn        []string `json:"publicIDNotIn,omitempty"`
	PublicIDGT           *string  `json:"publicIDGT,omitempty"`
	PublicIDGTE          *string  `json:"publicIDGTE,omitempty"`
	PublicIDLT           *string  `json:"publicIDLT,omitempty"`
	PublicIDLTE          *string  `json:"publicIDLTE,omitempty"`
	PublicIDContains     *string  `json:"publicIDContains,omitempty"`
	PublicIDHasPrefix    *string  `json:"publicIDHasPrefix,omitempty"`
	PublicIDHasSuffix    *string  `json:"publicIDHasSuffix,omitempty"`
	PublicIDEqualFold    *string  `json:"publicIDEqualFold,omitempty"`
	PublicIDContainsFold *string  `json:"publicIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "orders" edge predicates.
	HasOrders     *bool              `json:"hasOrders,omitempty"`
	HasOrdersWith []*OrderWhereInput `json:"hasOrdersWith,omitempty"`

	// "packaging" edge predicates.
	HasPackaging     *bool                  `json:"hasPackaging,omitempty"`
	HasPackagingWith []*PackagingWhereInput `json:"hasPackagingWith,omitempty"`

	// "consolidation" edge predicates.
	HasConsolidation     *bool                      `json:"hasConsolidation,omitempty"`
	HasConsolidationWith []*ConsolidationWhereInput `json:"hasConsolidationWith,omitempty"`

	// "shipment_pallet" edge predicates.
	HasShipmentPallet     *bool                       `json:"hasShipmentPallet,omitempty"`
	HasShipmentPalletWith []*ShipmentPalletWhereInput `json:"hasShipmentPalletWith,omitempty"`

	// "cancelled_shipment_pallet" edge predicates.
	HasCancelledShipmentPallet     *bool                       `json:"hasCancelledShipmentPallet,omitempty"`
	HasCancelledShipmentPalletWith []*ShipmentPalletWhereInput `json:"hasCancelledShipmentPalletWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PalletWhereInput) AddPredicates(predicates ...predicate.Pallet) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PalletWhereInput filter on the PalletQuery builder.
func (i *PalletWhereInput) Filter(q *PalletQuery) (*PalletQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPalletWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPalletWhereInput is returned in case the PalletWhereInput is empty.
var ErrEmptyPalletWhereInput = errors.New("ent: empty predicate PalletWhereInput")

// P returns a predicate for filtering pallets.
// An error is returned if the input is empty or invalid.
func (i *PalletWhereInput) P() (predicate.Pallet, error) {
	var predicates []predicate.Pallet
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, pallet.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Pallet, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, pallet.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Pallet, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, pallet.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, pallet.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, pallet.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, pallet.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, pallet.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, pallet.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, pallet.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, pallet.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, pallet.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, pallet.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, pallet.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, pallet.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, pallet.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, pallet.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, pallet.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, pallet.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, pallet.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, pallet.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, pallet.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, pallet.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, pallet.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, pallet.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.PublicID != nil {
		predicates = append(predicates, pallet.PublicIDEQ(*i.PublicID))
	}
	if i.PublicIDNEQ != nil {
		predicates = append(predicates, pallet.PublicIDNEQ(*i.PublicIDNEQ))
	}
	if len(i.PublicIDIn) > 0 {
		predicates = append(predicates, pallet.PublicIDIn(i.PublicIDIn...))
	}
	if len(i.PublicIDNotIn) > 0 {
		predicates = append(predicates, pallet.PublicIDNotIn(i.PublicIDNotIn...))
	}
	if i.PublicIDGT != nil {
		predicates = append(predicates, pallet.PublicIDGT(*i.PublicIDGT))
	}
	if i.PublicIDGTE != nil {
		predicates = append(predicates, pallet.PublicIDGTE(*i.PublicIDGTE))
	}
	if i.PublicIDLT != nil {
		predicates = append(predicates, pallet.PublicIDLT(*i.PublicIDLT))
	}
	if i.PublicIDLTE != nil {
		predicates = append(predicates, pallet.PublicIDLTE(*i.PublicIDLTE))
	}
	if i.PublicIDContains != nil {
		predicates = append(predicates, pallet.PublicIDContains(*i.PublicIDContains))
	}
	if i.PublicIDHasPrefix != nil {
		predicates = append(predicates, pallet.PublicIDHasPrefix(*i.PublicIDHasPrefix))
	}
	if i.PublicIDHasSuffix != nil {
		predicates = append(predicates, pallet.PublicIDHasSuffix(*i.PublicIDHasSuffix))
	}
	if i.PublicIDEqualFold != nil {
		predicates = append(predicates, pallet.PublicIDEqualFold(*i.PublicIDEqualFold))
	}
	if i.PublicIDContainsFold != nil {
		predicates = append(predicates, pallet.PublicIDContainsFold(*i.PublicIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, pallet.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, pallet.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, pallet.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, pallet.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, pallet.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, pallet.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, pallet.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, pallet.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, pallet.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, pallet.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, pallet.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, pallet.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, pallet.DescriptionContainsFold(*i.DescriptionContainsFold))
	}

	if i.HasTenant != nil {
		p := pallet.HasTenant()
		if !*i.HasTenant {
			p = pallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, pallet.HasTenantWith(with...))
	}
	if i.HasOrders != nil {
		p := pallet.HasOrders()
		if !*i.HasOrders {
			p = pallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrdersWith) > 0 {
		with := make([]predicate.Order, 0, len(i.HasOrdersWith))
		for _, w := range i.HasOrdersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrdersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, pallet.HasOrdersWith(with...))
	}
	if i.HasPackaging != nil {
		p := pallet.HasPackaging()
		if !*i.HasPackaging {
			p = pallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingWith) > 0 {
		with := make([]predicate.Packaging, 0, len(i.HasPackagingWith))
		for _, w := range i.HasPackagingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, pallet.HasPackagingWith(with...))
	}
	if i.HasConsolidation != nil {
		p := pallet.HasConsolidation()
		if !*i.HasConsolidation {
			p = pallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConsolidationWith) > 0 {
		with := make([]predicate.Consolidation, 0, len(i.HasConsolidationWith))
		for _, w := range i.HasConsolidationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConsolidationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, pallet.HasConsolidationWith(with...))
	}
	if i.HasShipmentPallet != nil {
		p := pallet.HasShipmentPallet()
		if !*i.HasShipmentPallet {
			p = pallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentPalletWith) > 0 {
		with := make([]predicate.ShipmentPallet, 0, len(i.HasShipmentPalletWith))
		for _, w := range i.HasShipmentPalletWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentPalletWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, pallet.HasShipmentPalletWith(with...))
	}
	if i.HasCancelledShipmentPallet != nil {
		p := pallet.HasCancelledShipmentPallet()
		if !*i.HasCancelledShipmentPallet {
			p = pallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCancelledShipmentPalletWith) > 0 {
		with := make([]predicate.ShipmentPallet, 0, len(i.HasCancelledShipmentPalletWith))
		for _, w := range i.HasCancelledShipmentPalletWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCancelledShipmentPalletWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, pallet.HasCancelledShipmentPalletWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPalletWhereInput
	case 1:
		return predicates[0], nil
	default:
		return pallet.And(predicates...), nil
	}
}

// ParcelShopWhereInput represents a where input for filtering ParcelShop queries.
type ParcelShopWhereInput struct {
	Predicates []predicate.ParcelShop  `json:"-"`
	Not        *ParcelShopWhereInput   `json:"not,omitempty"`
	Or         []*ParcelShopWhereInput `json:"or,omitempty"`
	And        []*ParcelShopWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "last_updated" field predicates.
	LastUpdated      *time.Time  `json:"lastUpdated,omitempty"`
	LastUpdatedNEQ   *time.Time  `json:"lastUpdatedNEQ,omitempty"`
	LastUpdatedIn    []time.Time `json:"lastUpdatedIn,omitempty"`
	LastUpdatedNotIn []time.Time `json:"lastUpdatedNotIn,omitempty"`
	LastUpdatedGT    *time.Time  `json:"lastUpdatedGT,omitempty"`
	LastUpdatedGTE   *time.Time  `json:"lastUpdatedGTE,omitempty"`
	LastUpdatedLT    *time.Time  `json:"lastUpdatedLT,omitempty"`
	LastUpdatedLTE   *time.Time  `json:"lastUpdatedLTE,omitempty"`

	// "parcel_shop_dao" edge predicates.
	HasParcelShopDAO     *bool                      `json:"hasParcelShopDAO,omitempty"`
	HasParcelShopDAOWith []*ParcelShopDAOWhereInput `json:"hasParcelShopDAOWith,omitempty"`

	// "parcel_shop_post_nord" edge predicates.
	HasParcelShopPostNord     *bool                           `json:"hasParcelShopPostNord,omitempty"`
	HasParcelShopPostNordWith []*ParcelShopPostNordWhereInput `json:"hasParcelShopPostNordWith,omitempty"`

	// "parcel_shop_gls" edge predicates.
	HasParcelShopGLS     *bool                      `json:"hasParcelShopGLS,omitempty"`
	HasParcelShopGLSWith []*ParcelShopGLSWhereInput `json:"hasParcelShopGLSWith,omitempty"`

	// "parcel_shop_bring" edge predicates.
	HasParcelShopBring     *bool                        `json:"hasParcelShopBring,omitempty"`
	HasParcelShopBringWith []*ParcelShopBringWhereInput `json:"hasParcelShopBringWith,omitempty"`

	// "carrier_brand" edge predicates.
	HasCarrierBrand     *bool                     `json:"hasCarrierBrand,omitempty"`
	HasCarrierBrandWith []*CarrierBrandWhereInput `json:"hasCarrierBrandWith,omitempty"`

	// "address" edge predicates.
	HasAddress     *bool                      `json:"hasAddress,omitempty"`
	HasAddressWith []*AddressGlobalWhereInput `json:"hasAddressWith,omitempty"`

	// "colli" edge predicates.
	HasColli     *bool              `json:"hasColli,omitempty"`
	HasColliWith []*ColliWhereInput `json:"hasColliWith,omitempty"`

	// "business_hours_period" edge predicates.
	HasBusinessHoursPeriod     *bool                            `json:"hasBusinessHoursPeriod,omitempty"`
	HasBusinessHoursPeriodWith []*BusinessHoursPeriodWhereInput `json:"hasBusinessHoursPeriodWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ParcelShopWhereInput) AddPredicates(predicates ...predicate.ParcelShop) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ParcelShopWhereInput filter on the ParcelShopQuery builder.
func (i *ParcelShopWhereInput) Filter(q *ParcelShopQuery) (*ParcelShopQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyParcelShopWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyParcelShopWhereInput is returned in case the ParcelShopWhereInput is empty.
var ErrEmptyParcelShopWhereInput = errors.New("ent: empty predicate ParcelShopWhereInput")

// P returns a predicate for filtering parcelshops.
// An error is returned if the input is empty or invalid.
func (i *ParcelShopWhereInput) P() (predicate.ParcelShop, error) {
	var predicates []predicate.ParcelShop
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, parcelshop.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ParcelShop, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, parcelshop.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ParcelShop, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, parcelshop.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, parcelshop.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, parcelshop.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, parcelshop.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, parcelshop.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, parcelshop.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, parcelshop.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, parcelshop.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, parcelshop.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, parcelshop.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, parcelshop.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, parcelshop.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, parcelshop.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, parcelshop.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, parcelshop.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, parcelshop.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, parcelshop.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, parcelshop.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, parcelshop.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, parcelshop.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, parcelshop.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, parcelshop.NameContainsFold(*i.NameContainsFold))
	}
	if i.LastUpdated != nil {
		predicates = append(predicates, parcelshop.LastUpdatedEQ(*i.LastUpdated))
	}
	if i.LastUpdatedNEQ != nil {
		predicates = append(predicates, parcelshop.LastUpdatedNEQ(*i.LastUpdatedNEQ))
	}
	if len(i.LastUpdatedIn) > 0 {
		predicates = append(predicates, parcelshop.LastUpdatedIn(i.LastUpdatedIn...))
	}
	if len(i.LastUpdatedNotIn) > 0 {
		predicates = append(predicates, parcelshop.LastUpdatedNotIn(i.LastUpdatedNotIn...))
	}
	if i.LastUpdatedGT != nil {
		predicates = append(predicates, parcelshop.LastUpdatedGT(*i.LastUpdatedGT))
	}
	if i.LastUpdatedGTE != nil {
		predicates = append(predicates, parcelshop.LastUpdatedGTE(*i.LastUpdatedGTE))
	}
	if i.LastUpdatedLT != nil {
		predicates = append(predicates, parcelshop.LastUpdatedLT(*i.LastUpdatedLT))
	}
	if i.LastUpdatedLTE != nil {
		predicates = append(predicates, parcelshop.LastUpdatedLTE(*i.LastUpdatedLTE))
	}

	if i.HasParcelShopDAO != nil {
		p := parcelshop.HasParcelShopDAO()
		if !*i.HasParcelShopDAO {
			p = parcelshop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopDAOWith) > 0 {
		with := make([]predicate.ParcelShopDAO, 0, len(i.HasParcelShopDAOWith))
		for _, w := range i.HasParcelShopDAOWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopDAOWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshop.HasParcelShopDAOWith(with...))
	}
	if i.HasParcelShopPostNord != nil {
		p := parcelshop.HasParcelShopPostNord()
		if !*i.HasParcelShopPostNord {
			p = parcelshop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopPostNordWith) > 0 {
		with := make([]predicate.ParcelShopPostNord, 0, len(i.HasParcelShopPostNordWith))
		for _, w := range i.HasParcelShopPostNordWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopPostNordWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshop.HasParcelShopPostNordWith(with...))
	}
	if i.HasParcelShopGLS != nil {
		p := parcelshop.HasParcelShopGLS()
		if !*i.HasParcelShopGLS {
			p = parcelshop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopGLSWith) > 0 {
		with := make([]predicate.ParcelShopGLS, 0, len(i.HasParcelShopGLSWith))
		for _, w := range i.HasParcelShopGLSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopGLSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshop.HasParcelShopGLSWith(with...))
	}
	if i.HasParcelShopBring != nil {
		p := parcelshop.HasParcelShopBring()
		if !*i.HasParcelShopBring {
			p = parcelshop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopBringWith) > 0 {
		with := make([]predicate.ParcelShopBring, 0, len(i.HasParcelShopBringWith))
		for _, w := range i.HasParcelShopBringWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopBringWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshop.HasParcelShopBringWith(with...))
	}
	if i.HasCarrierBrand != nil {
		p := parcelshop.HasCarrierBrand()
		if !*i.HasCarrierBrand {
			p = parcelshop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierBrandWith) > 0 {
		with := make([]predicate.CarrierBrand, 0, len(i.HasCarrierBrandWith))
		for _, w := range i.HasCarrierBrandWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierBrandWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshop.HasCarrierBrandWith(with...))
	}
	if i.HasAddress != nil {
		p := parcelshop.HasAddress()
		if !*i.HasAddress {
			p = parcelshop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAddressWith) > 0 {
		with := make([]predicate.AddressGlobal, 0, len(i.HasAddressWith))
		for _, w := range i.HasAddressWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAddressWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshop.HasAddressWith(with...))
	}
	if i.HasColli != nil {
		p := parcelshop.HasColli()
		if !*i.HasColli {
			p = parcelshop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasColliWith))
		for _, w := range i.HasColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshop.HasColliWith(with...))
	}
	if i.HasBusinessHoursPeriod != nil {
		p := parcelshop.HasBusinessHoursPeriod()
		if !*i.HasBusinessHoursPeriod {
			p = parcelshop.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBusinessHoursPeriodWith) > 0 {
		with := make([]predicate.BusinessHoursPeriod, 0, len(i.HasBusinessHoursPeriodWith))
		for _, w := range i.HasBusinessHoursPeriodWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBusinessHoursPeriodWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshop.HasBusinessHoursPeriodWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyParcelShopWhereInput
	case 1:
		return predicates[0], nil
	default:
		return parcelshop.And(predicates...), nil
	}
}

// ParcelShopBringWhereInput represents a where input for filtering ParcelShopBring queries.
type ParcelShopBringWhereInput struct {
	Predicates []predicate.ParcelShopBring  `json:"-"`
	Not        *ParcelShopBringWhereInput   `json:"not,omitempty"`
	Or         []*ParcelShopBringWhereInput `json:"or,omitempty"`
	And        []*ParcelShopBringWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "point_type" field predicates.
	PointType      *parcelshopbring.PointType  `json:"pointType,omitempty"`
	PointTypeNEQ   *parcelshopbring.PointType  `json:"pointTypeNEQ,omitempty"`
	PointTypeIn    []parcelshopbring.PointType `json:"pointTypeIn,omitempty"`
	PointTypeNotIn []parcelshopbring.PointType `json:"pointTypeNotIn,omitempty"`

	// "bring_id" field predicates.
	BringID             *string  `json:"bringID,omitempty"`
	BringIDNEQ          *string  `json:"bringIDNEQ,omitempty"`
	BringIDIn           []string `json:"bringIDIn,omitempty"`
	BringIDNotIn        []string `json:"bringIDNotIn,omitempty"`
	BringIDGT           *string  `json:"bringIDGT,omitempty"`
	BringIDGTE          *string  `json:"bringIDGTE,omitempty"`
	BringIDLT           *string  `json:"bringIDLT,omitempty"`
	BringIDLTE          *string  `json:"bringIDLTE,omitempty"`
	BringIDContains     *string  `json:"bringIDContains,omitempty"`
	BringIDHasPrefix    *string  `json:"bringIDHasPrefix,omitempty"`
	BringIDHasSuffix    *string  `json:"bringIDHasSuffix,omitempty"`
	BringIDEqualFold    *string  `json:"bringIDEqualFold,omitempty"`
	BringIDContainsFold *string  `json:"bringIDContainsFold,omitempty"`

	// "parcel_shop" edge predicates.
	HasParcelShop     *bool                   `json:"hasParcelShop,omitempty"`
	HasParcelShopWith []*ParcelShopWhereInput `json:"hasParcelShopWith,omitempty"`

	// "address_delivery" edge predicates.
	HasAddressDelivery     *bool                      `json:"hasAddressDelivery,omitempty"`
	HasAddressDeliveryWith []*AddressGlobalWhereInput `json:"hasAddressDeliveryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ParcelShopBringWhereInput) AddPredicates(predicates ...predicate.ParcelShopBring) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ParcelShopBringWhereInput filter on the ParcelShopBringQuery builder.
func (i *ParcelShopBringWhereInput) Filter(q *ParcelShopBringQuery) (*ParcelShopBringQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyParcelShopBringWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyParcelShopBringWhereInput is returned in case the ParcelShopBringWhereInput is empty.
var ErrEmptyParcelShopBringWhereInput = errors.New("ent: empty predicate ParcelShopBringWhereInput")

// P returns a predicate for filtering parcelshopbrings.
// An error is returned if the input is empty or invalid.
func (i *ParcelShopBringWhereInput) P() (predicate.ParcelShopBring, error) {
	var predicates []predicate.ParcelShopBring
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, parcelshopbring.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ParcelShopBring, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, parcelshopbring.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ParcelShopBring, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, parcelshopbring.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, parcelshopbring.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, parcelshopbring.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, parcelshopbring.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, parcelshopbring.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, parcelshopbring.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, parcelshopbring.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, parcelshopbring.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, parcelshopbring.IDLTE(*i.IDLTE))
	}
	if i.PointType != nil {
		predicates = append(predicates, parcelshopbring.PointTypeEQ(*i.PointType))
	}
	if i.PointTypeNEQ != nil {
		predicates = append(predicates, parcelshopbring.PointTypeNEQ(*i.PointTypeNEQ))
	}
	if len(i.PointTypeIn) > 0 {
		predicates = append(predicates, parcelshopbring.PointTypeIn(i.PointTypeIn...))
	}
	if len(i.PointTypeNotIn) > 0 {
		predicates = append(predicates, parcelshopbring.PointTypeNotIn(i.PointTypeNotIn...))
	}
	if i.BringID != nil {
		predicates = append(predicates, parcelshopbring.BringIDEQ(*i.BringID))
	}
	if i.BringIDNEQ != nil {
		predicates = append(predicates, parcelshopbring.BringIDNEQ(*i.BringIDNEQ))
	}
	if len(i.BringIDIn) > 0 {
		predicates = append(predicates, parcelshopbring.BringIDIn(i.BringIDIn...))
	}
	if len(i.BringIDNotIn) > 0 {
		predicates = append(predicates, parcelshopbring.BringIDNotIn(i.BringIDNotIn...))
	}
	if i.BringIDGT != nil {
		predicates = append(predicates, parcelshopbring.BringIDGT(*i.BringIDGT))
	}
	if i.BringIDGTE != nil {
		predicates = append(predicates, parcelshopbring.BringIDGTE(*i.BringIDGTE))
	}
	if i.BringIDLT != nil {
		predicates = append(predicates, parcelshopbring.BringIDLT(*i.BringIDLT))
	}
	if i.BringIDLTE != nil {
		predicates = append(predicates, parcelshopbring.BringIDLTE(*i.BringIDLTE))
	}
	if i.BringIDContains != nil {
		predicates = append(predicates, parcelshopbring.BringIDContains(*i.BringIDContains))
	}
	if i.BringIDHasPrefix != nil {
		predicates = append(predicates, parcelshopbring.BringIDHasPrefix(*i.BringIDHasPrefix))
	}
	if i.BringIDHasSuffix != nil {
		predicates = append(predicates, parcelshopbring.BringIDHasSuffix(*i.BringIDHasSuffix))
	}
	if i.BringIDEqualFold != nil {
		predicates = append(predicates, parcelshopbring.BringIDEqualFold(*i.BringIDEqualFold))
	}
	if i.BringIDContainsFold != nil {
		predicates = append(predicates, parcelshopbring.BringIDContainsFold(*i.BringIDContainsFold))
	}

	if i.HasParcelShop != nil {
		p := parcelshopbring.HasParcelShop()
		if !*i.HasParcelShop {
			p = parcelshopbring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopWith) > 0 {
		with := make([]predicate.ParcelShop, 0, len(i.HasParcelShopWith))
		for _, w := range i.HasParcelShopWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshopbring.HasParcelShopWith(with...))
	}
	if i.HasAddressDelivery != nil {
		p := parcelshopbring.HasAddressDelivery()
		if !*i.HasAddressDelivery {
			p = parcelshopbring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAddressDeliveryWith) > 0 {
		with := make([]predicate.AddressGlobal, 0, len(i.HasAddressDeliveryWith))
		for _, w := range i.HasAddressDeliveryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAddressDeliveryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshopbring.HasAddressDeliveryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyParcelShopBringWhereInput
	case 1:
		return predicates[0], nil
	default:
		return parcelshopbring.And(predicates...), nil
	}
}

// ParcelShopDAOWhereInput represents a where input for filtering ParcelShopDAO queries.
type ParcelShopDAOWhereInput struct {
	Predicates []predicate.ParcelShopDAO  `json:"-"`
	Not        *ParcelShopDAOWhereInput   `json:"not,omitempty"`
	Or         []*ParcelShopDAOWhereInput `json:"or,omitempty"`
	And        []*ParcelShopDAOWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "shop_id" field predicates.
	ShopID             *string  `json:"shopID,omitempty"`
	ShopIDNEQ          *string  `json:"shopIDNEQ,omitempty"`
	ShopIDIn           []string `json:"shopIDIn,omitempty"`
	ShopIDNotIn        []string `json:"shopIDNotIn,omitempty"`
	ShopIDGT           *string  `json:"shopIDGT,omitempty"`
	ShopIDGTE          *string  `json:"shopIDGTE,omitempty"`
	ShopIDLT           *string  `json:"shopIDLT,omitempty"`
	ShopIDLTE          *string  `json:"shopIDLTE,omitempty"`
	ShopIDContains     *string  `json:"shopIDContains,omitempty"`
	ShopIDHasPrefix    *string  `json:"shopIDHasPrefix,omitempty"`
	ShopIDHasSuffix    *string  `json:"shopIDHasSuffix,omitempty"`
	ShopIDEqualFold    *string  `json:"shopIDEqualFold,omitempty"`
	ShopIDContainsFold *string  `json:"shopIDContainsFold,omitempty"`

	// "parcel_shop" edge predicates.
	HasParcelShop     *bool                   `json:"hasParcelShop,omitempty"`
	HasParcelShopWith []*ParcelShopWhereInput `json:"hasParcelShopWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ParcelShopDAOWhereInput) AddPredicates(predicates ...predicate.ParcelShopDAO) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ParcelShopDAOWhereInput filter on the ParcelShopDAOQuery builder.
func (i *ParcelShopDAOWhereInput) Filter(q *ParcelShopDAOQuery) (*ParcelShopDAOQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyParcelShopDAOWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyParcelShopDAOWhereInput is returned in case the ParcelShopDAOWhereInput is empty.
var ErrEmptyParcelShopDAOWhereInput = errors.New("ent: empty predicate ParcelShopDAOWhereInput")

// P returns a predicate for filtering parcelshopdaos.
// An error is returned if the input is empty or invalid.
func (i *ParcelShopDAOWhereInput) P() (predicate.ParcelShopDAO, error) {
	var predicates []predicate.ParcelShopDAO
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, parcelshopdao.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ParcelShopDAO, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, parcelshopdao.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ParcelShopDAO, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, parcelshopdao.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, parcelshopdao.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, parcelshopdao.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, parcelshopdao.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, parcelshopdao.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, parcelshopdao.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, parcelshopdao.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, parcelshopdao.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, parcelshopdao.IDLTE(*i.IDLTE))
	}
	if i.ShopID != nil {
		predicates = append(predicates, parcelshopdao.ShopIDEQ(*i.ShopID))
	}
	if i.ShopIDNEQ != nil {
		predicates = append(predicates, parcelshopdao.ShopIDNEQ(*i.ShopIDNEQ))
	}
	if len(i.ShopIDIn) > 0 {
		predicates = append(predicates, parcelshopdao.ShopIDIn(i.ShopIDIn...))
	}
	if len(i.ShopIDNotIn) > 0 {
		predicates = append(predicates, parcelshopdao.ShopIDNotIn(i.ShopIDNotIn...))
	}
	if i.ShopIDGT != nil {
		predicates = append(predicates, parcelshopdao.ShopIDGT(*i.ShopIDGT))
	}
	if i.ShopIDGTE != nil {
		predicates = append(predicates, parcelshopdao.ShopIDGTE(*i.ShopIDGTE))
	}
	if i.ShopIDLT != nil {
		predicates = append(predicates, parcelshopdao.ShopIDLT(*i.ShopIDLT))
	}
	if i.ShopIDLTE != nil {
		predicates = append(predicates, parcelshopdao.ShopIDLTE(*i.ShopIDLTE))
	}
	if i.ShopIDContains != nil {
		predicates = append(predicates, parcelshopdao.ShopIDContains(*i.ShopIDContains))
	}
	if i.ShopIDHasPrefix != nil {
		predicates = append(predicates, parcelshopdao.ShopIDHasPrefix(*i.ShopIDHasPrefix))
	}
	if i.ShopIDHasSuffix != nil {
		predicates = append(predicates, parcelshopdao.ShopIDHasSuffix(*i.ShopIDHasSuffix))
	}
	if i.ShopIDEqualFold != nil {
		predicates = append(predicates, parcelshopdao.ShopIDEqualFold(*i.ShopIDEqualFold))
	}
	if i.ShopIDContainsFold != nil {
		predicates = append(predicates, parcelshopdao.ShopIDContainsFold(*i.ShopIDContainsFold))
	}

	if i.HasParcelShop != nil {
		p := parcelshopdao.HasParcelShop()
		if !*i.HasParcelShop {
			p = parcelshopdao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopWith) > 0 {
		with := make([]predicate.ParcelShop, 0, len(i.HasParcelShopWith))
		for _, w := range i.HasParcelShopWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshopdao.HasParcelShopWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyParcelShopDAOWhereInput
	case 1:
		return predicates[0], nil
	default:
		return parcelshopdao.And(predicates...), nil
	}
}

// ParcelShopGLSWhereInput represents a where input for filtering ParcelShopGLS queries.
type ParcelShopGLSWhereInput struct {
	Predicates []predicate.ParcelShopGLS  `json:"-"`
	Not        *ParcelShopGLSWhereInput   `json:"not,omitempty"`
	Or         []*ParcelShopGLSWhereInput `json:"or,omitempty"`
	And        []*ParcelShopGLSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "gls_parcel_shop_id" field predicates.
	GLSParcelShopID             *string  `json:"glsParcelShopID,omitempty"`
	GLSParcelShopIDNEQ          *string  `json:"glsParcelShopIDNEQ,omitempty"`
	GLSParcelShopIDIn           []string `json:"glsParcelShopIDIn,omitempty"`
	GLSParcelShopIDNotIn        []string `json:"glsParcelShopIDNotIn,omitempty"`
	GLSParcelShopIDGT           *string  `json:"glsParcelShopIDGT,omitempty"`
	GLSParcelShopIDGTE          *string  `json:"glsParcelShopIDGTE,omitempty"`
	GLSParcelShopIDLT           *string  `json:"glsParcelShopIDLT,omitempty"`
	GLSParcelShopIDLTE          *string  `json:"glsParcelShopIDLTE,omitempty"`
	GLSParcelShopIDContains     *string  `json:"glsParcelShopIDContains,omitempty"`
	GLSParcelShopIDHasPrefix    *string  `json:"glsParcelShopIDHasPrefix,omitempty"`
	GLSParcelShopIDHasSuffix    *string  `json:"glsParcelShopIDHasSuffix,omitempty"`
	GLSParcelShopIDEqualFold    *string  `json:"glsParcelShopIDEqualFold,omitempty"`
	GLSParcelShopIDContainsFold *string  `json:"glsParcelShopIDContainsFold,omitempty"`

	// "partner_id" field predicates.
	PartnerID             *string  `json:"partnerID,omitempty"`
	PartnerIDNEQ          *string  `json:"partnerIDNEQ,omitempty"`
	PartnerIDIn           []string `json:"partnerIDIn,omitempty"`
	PartnerIDNotIn        []string `json:"partnerIDNotIn,omitempty"`
	PartnerIDGT           *string  `json:"partnerIDGT,omitempty"`
	PartnerIDGTE          *string  `json:"partnerIDGTE,omitempty"`
	PartnerIDLT           *string  `json:"partnerIDLT,omitempty"`
	PartnerIDLTE          *string  `json:"partnerIDLTE,omitempty"`
	PartnerIDContains     *string  `json:"partnerIDContains,omitempty"`
	PartnerIDHasPrefix    *string  `json:"partnerIDHasPrefix,omitempty"`
	PartnerIDHasSuffix    *string  `json:"partnerIDHasSuffix,omitempty"`
	PartnerIDIsNil        bool     `json:"partnerIDIsNil,omitempty"`
	PartnerIDNotNil       bool     `json:"partnerIDNotNil,omitempty"`
	PartnerIDEqualFold    *string  `json:"partnerIDEqualFold,omitempty"`
	PartnerIDContainsFold *string  `json:"partnerIDContainsFold,omitempty"`

	// "type" field predicates.
	Type             *string  `json:"type,omitempty"`
	TypeNEQ          *string  `json:"typeNEQ,omitempty"`
	TypeIn           []string `json:"typeIn,omitempty"`
	TypeNotIn        []string `json:"typeNotIn,omitempty"`
	TypeGT           *string  `json:"typeGT,omitempty"`
	TypeGTE          *string  `json:"typeGTE,omitempty"`
	TypeLT           *string  `json:"typeLT,omitempty"`
	TypeLTE          *string  `json:"typeLTE,omitempty"`
	TypeContains     *string  `json:"typeContains,omitempty"`
	TypeHasPrefix    *string  `json:"typeHasPrefix,omitempty"`
	TypeHasSuffix    *string  `json:"typeHasSuffix,omitempty"`
	TypeIsNil        bool     `json:"typeIsNil,omitempty"`
	TypeNotNil       bool     `json:"typeNotNil,omitempty"`
	TypeEqualFold    *string  `json:"typeEqualFold,omitempty"`
	TypeContainsFold *string  `json:"typeContainsFold,omitempty"`

	// "parcel_shop" edge predicates.
	HasParcelShop     *bool                   `json:"hasParcelShop,omitempty"`
	HasParcelShopWith []*ParcelShopWhereInput `json:"hasParcelShopWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ParcelShopGLSWhereInput) AddPredicates(predicates ...predicate.ParcelShopGLS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ParcelShopGLSWhereInput filter on the ParcelShopGLSQuery builder.
func (i *ParcelShopGLSWhereInput) Filter(q *ParcelShopGLSQuery) (*ParcelShopGLSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyParcelShopGLSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyParcelShopGLSWhereInput is returned in case the ParcelShopGLSWhereInput is empty.
var ErrEmptyParcelShopGLSWhereInput = errors.New("ent: empty predicate ParcelShopGLSWhereInput")

// P returns a predicate for filtering parcelshopglss.
// An error is returned if the input is empty or invalid.
func (i *ParcelShopGLSWhereInput) P() (predicate.ParcelShopGLS, error) {
	var predicates []predicate.ParcelShopGLS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, parcelshopgls.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ParcelShopGLS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, parcelshopgls.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ParcelShopGLS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, parcelshopgls.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, parcelshopgls.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, parcelshopgls.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, parcelshopgls.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, parcelshopgls.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, parcelshopgls.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, parcelshopgls.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, parcelshopgls.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, parcelshopgls.IDLTE(*i.IDLTE))
	}
	if i.GLSParcelShopID != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDEQ(*i.GLSParcelShopID))
	}
	if i.GLSParcelShopIDNEQ != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDNEQ(*i.GLSParcelShopIDNEQ))
	}
	if len(i.GLSParcelShopIDIn) > 0 {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDIn(i.GLSParcelShopIDIn...))
	}
	if len(i.GLSParcelShopIDNotIn) > 0 {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDNotIn(i.GLSParcelShopIDNotIn...))
	}
	if i.GLSParcelShopIDGT != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDGT(*i.GLSParcelShopIDGT))
	}
	if i.GLSParcelShopIDGTE != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDGTE(*i.GLSParcelShopIDGTE))
	}
	if i.GLSParcelShopIDLT != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDLT(*i.GLSParcelShopIDLT))
	}
	if i.GLSParcelShopIDLTE != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDLTE(*i.GLSParcelShopIDLTE))
	}
	if i.GLSParcelShopIDContains != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDContains(*i.GLSParcelShopIDContains))
	}
	if i.GLSParcelShopIDHasPrefix != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDHasPrefix(*i.GLSParcelShopIDHasPrefix))
	}
	if i.GLSParcelShopIDHasSuffix != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDHasSuffix(*i.GLSParcelShopIDHasSuffix))
	}
	if i.GLSParcelShopIDEqualFold != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDEqualFold(*i.GLSParcelShopIDEqualFold))
	}
	if i.GLSParcelShopIDContainsFold != nil {
		predicates = append(predicates, parcelshopgls.GLSParcelShopIDContainsFold(*i.GLSParcelShopIDContainsFold))
	}
	if i.PartnerID != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDEQ(*i.PartnerID))
	}
	if i.PartnerIDNEQ != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDNEQ(*i.PartnerIDNEQ))
	}
	if len(i.PartnerIDIn) > 0 {
		predicates = append(predicates, parcelshopgls.PartnerIDIn(i.PartnerIDIn...))
	}
	if len(i.PartnerIDNotIn) > 0 {
		predicates = append(predicates, parcelshopgls.PartnerIDNotIn(i.PartnerIDNotIn...))
	}
	if i.PartnerIDGT != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDGT(*i.PartnerIDGT))
	}
	if i.PartnerIDGTE != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDGTE(*i.PartnerIDGTE))
	}
	if i.PartnerIDLT != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDLT(*i.PartnerIDLT))
	}
	if i.PartnerIDLTE != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDLTE(*i.PartnerIDLTE))
	}
	if i.PartnerIDContains != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDContains(*i.PartnerIDContains))
	}
	if i.PartnerIDHasPrefix != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDHasPrefix(*i.PartnerIDHasPrefix))
	}
	if i.PartnerIDHasSuffix != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDHasSuffix(*i.PartnerIDHasSuffix))
	}
	if i.PartnerIDIsNil {
		predicates = append(predicates, parcelshopgls.PartnerIDIsNil())
	}
	if i.PartnerIDNotNil {
		predicates = append(predicates, parcelshopgls.PartnerIDNotNil())
	}
	if i.PartnerIDEqualFold != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDEqualFold(*i.PartnerIDEqualFold))
	}
	if i.PartnerIDContainsFold != nil {
		predicates = append(predicates, parcelshopgls.PartnerIDContainsFold(*i.PartnerIDContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, parcelshopgls.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, parcelshopgls.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, parcelshopgls.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, parcelshopgls.TypeNotIn(i.TypeNotIn...))
	}
	if i.TypeGT != nil {
		predicates = append(predicates, parcelshopgls.TypeGT(*i.TypeGT))
	}
	if i.TypeGTE != nil {
		predicates = append(predicates, parcelshopgls.TypeGTE(*i.TypeGTE))
	}
	if i.TypeLT != nil {
		predicates = append(predicates, parcelshopgls.TypeLT(*i.TypeLT))
	}
	if i.TypeLTE != nil {
		predicates = append(predicates, parcelshopgls.TypeLTE(*i.TypeLTE))
	}
	if i.TypeContains != nil {
		predicates = append(predicates, parcelshopgls.TypeContains(*i.TypeContains))
	}
	if i.TypeHasPrefix != nil {
		predicates = append(predicates, parcelshopgls.TypeHasPrefix(*i.TypeHasPrefix))
	}
	if i.TypeHasSuffix != nil {
		predicates = append(predicates, parcelshopgls.TypeHasSuffix(*i.TypeHasSuffix))
	}
	if i.TypeIsNil {
		predicates = append(predicates, parcelshopgls.TypeIsNil())
	}
	if i.TypeNotNil {
		predicates = append(predicates, parcelshopgls.TypeNotNil())
	}
	if i.TypeEqualFold != nil {
		predicates = append(predicates, parcelshopgls.TypeEqualFold(*i.TypeEqualFold))
	}
	if i.TypeContainsFold != nil {
		predicates = append(predicates, parcelshopgls.TypeContainsFold(*i.TypeContainsFold))
	}

	if i.HasParcelShop != nil {
		p := parcelshopgls.HasParcelShop()
		if !*i.HasParcelShop {
			p = parcelshopgls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopWith) > 0 {
		with := make([]predicate.ParcelShop, 0, len(i.HasParcelShopWith))
		for _, w := range i.HasParcelShopWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshopgls.HasParcelShopWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyParcelShopGLSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return parcelshopgls.And(predicates...), nil
	}
}

// ParcelShopPostNordWhereInput represents a where input for filtering ParcelShopPostNord queries.
type ParcelShopPostNordWhereInput struct {
	Predicates []predicate.ParcelShopPostNord  `json:"-"`
	Not        *ParcelShopPostNordWhereInput   `json:"not,omitempty"`
	Or         []*ParcelShopPostNordWhereInput `json:"or,omitempty"`
	And        []*ParcelShopPostNordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "service_point_id" field predicates.
	ServicePointID             *string  `json:"servicePointID,omitempty"`
	ServicePointIDNEQ          *string  `json:"servicePointIDNEQ,omitempty"`
	ServicePointIDIn           []string `json:"servicePointIDIn,omitempty"`
	ServicePointIDNotIn        []string `json:"servicePointIDNotIn,omitempty"`
	ServicePointIDGT           *string  `json:"servicePointIDGT,omitempty"`
	ServicePointIDGTE          *string  `json:"servicePointIDGTE,omitempty"`
	ServicePointIDLT           *string  `json:"servicePointIDLT,omitempty"`
	ServicePointIDLTE          *string  `json:"servicePointIDLTE,omitempty"`
	ServicePointIDContains     *string  `json:"servicePointIDContains,omitempty"`
	ServicePointIDHasPrefix    *string  `json:"servicePointIDHasPrefix,omitempty"`
	ServicePointIDHasSuffix    *string  `json:"servicePointIDHasSuffix,omitempty"`
	ServicePointIDEqualFold    *string  `json:"servicePointIDEqualFold,omitempty"`
	ServicePointIDContainsFold *string  `json:"servicePointIDContainsFold,omitempty"`

	// "pudoid" field predicates.
	Pudoid             *string  `json:"pudoid,omitempty"`
	PudoidNEQ          *string  `json:"pudoidNEQ,omitempty"`
	PudoidIn           []string `json:"pudoidIn,omitempty"`
	PudoidNotIn        []string `json:"pudoidNotIn,omitempty"`
	PudoidGT           *string  `json:"pudoidGT,omitempty"`
	PudoidGTE          *string  `json:"pudoidGTE,omitempty"`
	PudoidLT           *string  `json:"pudoidLT,omitempty"`
	PudoidLTE          *string  `json:"pudoidLTE,omitempty"`
	PudoidContains     *string  `json:"pudoidContains,omitempty"`
	PudoidHasPrefix    *string  `json:"pudoidHasPrefix,omitempty"`
	PudoidHasSuffix    *string  `json:"pudoidHasSuffix,omitempty"`
	PudoidEqualFold    *string  `json:"pudoidEqualFold,omitempty"`
	PudoidContainsFold *string  `json:"pudoidContainsFold,omitempty"`

	// "type_id" field predicates.
	TypeID             *string  `json:"typeID,omitempty"`
	TypeIDNEQ          *string  `json:"typeIDNEQ,omitempty"`
	TypeIDIn           []string `json:"typeIDIn,omitempty"`
	TypeIDNotIn        []string `json:"typeIDNotIn,omitempty"`
	TypeIDGT           *string  `json:"typeIDGT,omitempty"`
	TypeIDGTE          *string  `json:"typeIDGTE,omitempty"`
	TypeIDLT           *string  `json:"typeIDLT,omitempty"`
	TypeIDLTE          *string  `json:"typeIDLTE,omitempty"`
	TypeIDContains     *string  `json:"typeIDContains,omitempty"`
	TypeIDHasPrefix    *string  `json:"typeIDHasPrefix,omitempty"`
	TypeIDHasSuffix    *string  `json:"typeIDHasSuffix,omitempty"`
	TypeIDEqualFold    *string  `json:"typeIDEqualFold,omitempty"`
	TypeIDContainsFold *string  `json:"typeIDContainsFold,omitempty"`

	// "parcel_shop" edge predicates.
	HasParcelShop     *bool                   `json:"hasParcelShop,omitempty"`
	HasParcelShopWith []*ParcelShopWhereInput `json:"hasParcelShopWith,omitempty"`

	// "address_delivery" edge predicates.
	HasAddressDelivery     *bool                      `json:"hasAddressDelivery,omitempty"`
	HasAddressDeliveryWith []*AddressGlobalWhereInput `json:"hasAddressDeliveryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ParcelShopPostNordWhereInput) AddPredicates(predicates ...predicate.ParcelShopPostNord) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ParcelShopPostNordWhereInput filter on the ParcelShopPostNordQuery builder.
func (i *ParcelShopPostNordWhereInput) Filter(q *ParcelShopPostNordQuery) (*ParcelShopPostNordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyParcelShopPostNordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyParcelShopPostNordWhereInput is returned in case the ParcelShopPostNordWhereInput is empty.
var ErrEmptyParcelShopPostNordWhereInput = errors.New("ent: empty predicate ParcelShopPostNordWhereInput")

// P returns a predicate for filtering parcelshoppostnords.
// An error is returned if the input is empty or invalid.
func (i *ParcelShopPostNordWhereInput) P() (predicate.ParcelShopPostNord, error) {
	var predicates []predicate.ParcelShopPostNord
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, parcelshoppostnord.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ParcelShopPostNord, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, parcelshoppostnord.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ParcelShopPostNord, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, parcelshoppostnord.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, parcelshoppostnord.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, parcelshoppostnord.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, parcelshoppostnord.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, parcelshoppostnord.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, parcelshoppostnord.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, parcelshoppostnord.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, parcelshoppostnord.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, parcelshoppostnord.IDLTE(*i.IDLTE))
	}
	if i.ServicePointID != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDEQ(*i.ServicePointID))
	}
	if i.ServicePointIDNEQ != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDNEQ(*i.ServicePointIDNEQ))
	}
	if len(i.ServicePointIDIn) > 0 {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDIn(i.ServicePointIDIn...))
	}
	if len(i.ServicePointIDNotIn) > 0 {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDNotIn(i.ServicePointIDNotIn...))
	}
	if i.ServicePointIDGT != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDGT(*i.ServicePointIDGT))
	}
	if i.ServicePointIDGTE != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDGTE(*i.ServicePointIDGTE))
	}
	if i.ServicePointIDLT != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDLT(*i.ServicePointIDLT))
	}
	if i.ServicePointIDLTE != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDLTE(*i.ServicePointIDLTE))
	}
	if i.ServicePointIDContains != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDContains(*i.ServicePointIDContains))
	}
	if i.ServicePointIDHasPrefix != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDHasPrefix(*i.ServicePointIDHasPrefix))
	}
	if i.ServicePointIDHasSuffix != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDHasSuffix(*i.ServicePointIDHasSuffix))
	}
	if i.ServicePointIDEqualFold != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDEqualFold(*i.ServicePointIDEqualFold))
	}
	if i.ServicePointIDContainsFold != nil {
		predicates = append(predicates, parcelshoppostnord.ServicePointIDContainsFold(*i.ServicePointIDContainsFold))
	}
	if i.Pudoid != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidEQ(*i.Pudoid))
	}
	if i.PudoidNEQ != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidNEQ(*i.PudoidNEQ))
	}
	if len(i.PudoidIn) > 0 {
		predicates = append(predicates, parcelshoppostnord.PudoidIn(i.PudoidIn...))
	}
	if len(i.PudoidNotIn) > 0 {
		predicates = append(predicates, parcelshoppostnord.PudoidNotIn(i.PudoidNotIn...))
	}
	if i.PudoidGT != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidGT(*i.PudoidGT))
	}
	if i.PudoidGTE != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidGTE(*i.PudoidGTE))
	}
	if i.PudoidLT != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidLT(*i.PudoidLT))
	}
	if i.PudoidLTE != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidLTE(*i.PudoidLTE))
	}
	if i.PudoidContains != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidContains(*i.PudoidContains))
	}
	if i.PudoidHasPrefix != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidHasPrefix(*i.PudoidHasPrefix))
	}
	if i.PudoidHasSuffix != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidHasSuffix(*i.PudoidHasSuffix))
	}
	if i.PudoidEqualFold != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidEqualFold(*i.PudoidEqualFold))
	}
	if i.PudoidContainsFold != nil {
		predicates = append(predicates, parcelshoppostnord.PudoidContainsFold(*i.PudoidContainsFold))
	}
	if i.TypeID != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDEQ(*i.TypeID))
	}
	if i.TypeIDNEQ != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDNEQ(*i.TypeIDNEQ))
	}
	if len(i.TypeIDIn) > 0 {
		predicates = append(predicates, parcelshoppostnord.TypeIDIn(i.TypeIDIn...))
	}
	if len(i.TypeIDNotIn) > 0 {
		predicates = append(predicates, parcelshoppostnord.TypeIDNotIn(i.TypeIDNotIn...))
	}
	if i.TypeIDGT != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDGT(*i.TypeIDGT))
	}
	if i.TypeIDGTE != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDGTE(*i.TypeIDGTE))
	}
	if i.TypeIDLT != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDLT(*i.TypeIDLT))
	}
	if i.TypeIDLTE != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDLTE(*i.TypeIDLTE))
	}
	if i.TypeIDContains != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDContains(*i.TypeIDContains))
	}
	if i.TypeIDHasPrefix != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDHasPrefix(*i.TypeIDHasPrefix))
	}
	if i.TypeIDHasSuffix != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDHasSuffix(*i.TypeIDHasSuffix))
	}
	if i.TypeIDEqualFold != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDEqualFold(*i.TypeIDEqualFold))
	}
	if i.TypeIDContainsFold != nil {
		predicates = append(predicates, parcelshoppostnord.TypeIDContainsFold(*i.TypeIDContainsFold))
	}

	if i.HasParcelShop != nil {
		p := parcelshoppostnord.HasParcelShop()
		if !*i.HasParcelShop {
			p = parcelshoppostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParcelShopWith) > 0 {
		with := make([]predicate.ParcelShop, 0, len(i.HasParcelShopWith))
		for _, w := range i.HasParcelShopWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParcelShopWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshoppostnord.HasParcelShopWith(with...))
	}
	if i.HasAddressDelivery != nil {
		p := parcelshoppostnord.HasAddressDelivery()
		if !*i.HasAddressDelivery {
			p = parcelshoppostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAddressDeliveryWith) > 0 {
		with := make([]predicate.AddressGlobal, 0, len(i.HasAddressDeliveryWith))
		for _, w := range i.HasAddressDeliveryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAddressDeliveryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, parcelshoppostnord.HasAddressDeliveryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyParcelShopPostNordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return parcelshoppostnord.And(predicates...), nil
	}
}

// PlanWhereInput represents a where input for filtering Plan queries.
type PlanWhereInput struct {
	Predicates []predicate.Plan  `json:"-"`
	Not        *PlanWhereInput   `json:"not,omitempty"`
	Or         []*PlanWhereInput `json:"or,omitempty"`
	And        []*PlanWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "label" field predicates.
	Label             *string  `json:"label,omitempty"`
	LabelNEQ          *string  `json:"labelNEQ,omitempty"`
	LabelIn           []string `json:"labelIn,omitempty"`
	LabelNotIn        []string `json:"labelNotIn,omitempty"`
	LabelGT           *string  `json:"labelGT,omitempty"`
	LabelGTE          *string  `json:"labelGTE,omitempty"`
	LabelLT           *string  `json:"labelLT,omitempty"`
	LabelLTE          *string  `json:"labelLTE,omitempty"`
	LabelContains     *string  `json:"labelContains,omitempty"`
	LabelHasPrefix    *string  `json:"labelHasPrefix,omitempty"`
	LabelHasSuffix    *string  `json:"labelHasSuffix,omitempty"`
	LabelEqualFold    *string  `json:"labelEqualFold,omitempty"`
	LabelContainsFold *string  `json:"labelContainsFold,omitempty"`

	// "rank" field predicates.
	Rank      *int  `json:"rank,omitempty"`
	RankNEQ   *int  `json:"rankNEQ,omitempty"`
	RankIn    []int `json:"rankIn,omitempty"`
	RankNotIn []int `json:"rankNotIn,omitempty"`
	RankGT    *int  `json:"rankGT,omitempty"`
	RankGTE   *int  `json:"rankGTE,omitempty"`
	RankLT    *int  `json:"rankLT,omitempty"`
	RankLTE   *int  `json:"rankLTE,omitempty"`

	// "price_dkk" field predicates.
	PriceDkk      *int  `json:"priceDkk,omitempty"`
	PriceDkkNEQ   *int  `json:"priceDkkNEQ,omitempty"`
	PriceDkkIn    []int `json:"priceDkkIn,omitempty"`
	PriceDkkNotIn []int `json:"priceDkkNotIn,omitempty"`
	PriceDkkGT    *int  `json:"priceDkkGT,omitempty"`
	PriceDkkGTE   *int  `json:"priceDkkGTE,omitempty"`
	PriceDkkLT    *int  `json:"priceDkkLT,omitempty"`
	PriceDkkLTE   *int  `json:"priceDkkLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "plan_history_plan" edge predicates.
	HasPlanHistoryPlan     *bool                    `json:"hasPlanHistoryPlan,omitempty"`
	HasPlanHistoryPlanWith []*PlanHistoryWhereInput `json:"hasPlanHistoryPlanWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PlanWhereInput) AddPredicates(predicates ...predicate.Plan) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PlanWhereInput filter on the PlanQuery builder.
func (i *PlanWhereInput) Filter(q *PlanQuery) (*PlanQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPlanWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPlanWhereInput is returned in case the PlanWhereInput is empty.
var ErrEmptyPlanWhereInput = errors.New("ent: empty predicate PlanWhereInput")

// P returns a predicate for filtering plans.
// An error is returned if the input is empty or invalid.
func (i *PlanWhereInput) P() (predicate.Plan, error) {
	var predicates []predicate.Plan
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, plan.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Plan, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, plan.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Plan, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, plan.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, plan.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, plan.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, plan.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, plan.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, plan.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, plan.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, plan.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, plan.IDLTE(*i.IDLTE))
	}
	if i.Label != nil {
		predicates = append(predicates, plan.LabelEQ(*i.Label))
	}
	if i.LabelNEQ != nil {
		predicates = append(predicates, plan.LabelNEQ(*i.LabelNEQ))
	}
	if len(i.LabelIn) > 0 {
		predicates = append(predicates, plan.LabelIn(i.LabelIn...))
	}
	if len(i.LabelNotIn) > 0 {
		predicates = append(predicates, plan.LabelNotIn(i.LabelNotIn...))
	}
	if i.LabelGT != nil {
		predicates = append(predicates, plan.LabelGT(*i.LabelGT))
	}
	if i.LabelGTE != nil {
		predicates = append(predicates, plan.LabelGTE(*i.LabelGTE))
	}
	if i.LabelLT != nil {
		predicates = append(predicates, plan.LabelLT(*i.LabelLT))
	}
	if i.LabelLTE != nil {
		predicates = append(predicates, plan.LabelLTE(*i.LabelLTE))
	}
	if i.LabelContains != nil {
		predicates = append(predicates, plan.LabelContains(*i.LabelContains))
	}
	if i.LabelHasPrefix != nil {
		predicates = append(predicates, plan.LabelHasPrefix(*i.LabelHasPrefix))
	}
	if i.LabelHasSuffix != nil {
		predicates = append(predicates, plan.LabelHasSuffix(*i.LabelHasSuffix))
	}
	if i.LabelEqualFold != nil {
		predicates = append(predicates, plan.LabelEqualFold(*i.LabelEqualFold))
	}
	if i.LabelContainsFold != nil {
		predicates = append(predicates, plan.LabelContainsFold(*i.LabelContainsFold))
	}
	if i.Rank != nil {
		predicates = append(predicates, plan.RankEQ(*i.Rank))
	}
	if i.RankNEQ != nil {
		predicates = append(predicates, plan.RankNEQ(*i.RankNEQ))
	}
	if len(i.RankIn) > 0 {
		predicates = append(predicates, plan.RankIn(i.RankIn...))
	}
	if len(i.RankNotIn) > 0 {
		predicates = append(predicates, plan.RankNotIn(i.RankNotIn...))
	}
	if i.RankGT != nil {
		predicates = append(predicates, plan.RankGT(*i.RankGT))
	}
	if i.RankGTE != nil {
		predicates = append(predicates, plan.RankGTE(*i.RankGTE))
	}
	if i.RankLT != nil {
		predicates = append(predicates, plan.RankLT(*i.RankLT))
	}
	if i.RankLTE != nil {
		predicates = append(predicates, plan.RankLTE(*i.RankLTE))
	}
	if i.PriceDkk != nil {
		predicates = append(predicates, plan.PriceDkkEQ(*i.PriceDkk))
	}
	if i.PriceDkkNEQ != nil {
		predicates = append(predicates, plan.PriceDkkNEQ(*i.PriceDkkNEQ))
	}
	if len(i.PriceDkkIn) > 0 {
		predicates = append(predicates, plan.PriceDkkIn(i.PriceDkkIn...))
	}
	if len(i.PriceDkkNotIn) > 0 {
		predicates = append(predicates, plan.PriceDkkNotIn(i.PriceDkkNotIn...))
	}
	if i.PriceDkkGT != nil {
		predicates = append(predicates, plan.PriceDkkGT(*i.PriceDkkGT))
	}
	if i.PriceDkkGTE != nil {
		predicates = append(predicates, plan.PriceDkkGTE(*i.PriceDkkGTE))
	}
	if i.PriceDkkLT != nil {
		predicates = append(predicates, plan.PriceDkkLT(*i.PriceDkkLT))
	}
	if i.PriceDkkLTE != nil {
		predicates = append(predicates, plan.PriceDkkLTE(*i.PriceDkkLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, plan.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, plan.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, plan.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, plan.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, plan.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, plan.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, plan.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, plan.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasTenant != nil {
		p := plan.HasTenant()
		if !*i.HasTenant {
			p = plan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plan.HasTenantWith(with...))
	}
	if i.HasPlanHistoryPlan != nil {
		p := plan.HasPlanHistoryPlan()
		if !*i.HasPlanHistoryPlan {
			p = plan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlanHistoryPlanWith) > 0 {
		with := make([]predicate.PlanHistory, 0, len(i.HasPlanHistoryPlanWith))
		for _, w := range i.HasPlanHistoryPlanWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPlanHistoryPlanWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, plan.HasPlanHistoryPlanWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPlanWhereInput
	case 1:
		return predicates[0], nil
	default:
		return plan.And(predicates...), nil
	}
}

// PlanHistoryWhereInput represents a where input for filtering PlanHistory queries.
type PlanHistoryWhereInput struct {
	Predicates []predicate.PlanHistory  `json:"-"`
	Not        *PlanHistoryWhereInput   `json:"not,omitempty"`
	Or         []*PlanHistoryWhereInput `json:"or,omitempty"`
	And        []*PlanHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "change_history" edge predicates.
	HasChangeHistory     *bool                      `json:"hasChangeHistory,omitempty"`
	HasChangeHistoryWith []*ChangeHistoryWhereInput `json:"hasChangeHistoryWith,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "changed_by" edge predicates.
	HasChangedBy     *bool             `json:"hasChangedBy,omitempty"`
	HasChangedByWith []*UserWhereInput `json:"hasChangedByWith,omitempty"`

	// "changed_from" edge predicates.
	HasChangedFrom     *bool             `json:"hasChangedFrom,omitempty"`
	HasChangedFromWith []*PlanWhereInput `json:"hasChangedFromWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PlanHistoryWhereInput) AddPredicates(predicates ...predicate.PlanHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PlanHistoryWhereInput filter on the PlanHistoryQuery builder.
func (i *PlanHistoryWhereInput) Filter(q *PlanHistoryQuery) (*PlanHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPlanHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPlanHistoryWhereInput is returned in case the PlanHistoryWhereInput is empty.
var ErrEmptyPlanHistoryWhereInput = errors.New("ent: empty predicate PlanHistoryWhereInput")

// P returns a predicate for filtering planhistories.
// An error is returned if the input is empty or invalid.
func (i *PlanHistoryWhereInput) P() (predicate.PlanHistory, error) {
	var predicates []predicate.PlanHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, planhistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PlanHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, planhistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PlanHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, planhistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, planhistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, planhistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, planhistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, planhistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, planhistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, planhistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, planhistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, planhistory.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, planhistory.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, planhistory.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, planhistory.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, planhistory.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, planhistory.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, planhistory.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, planhistory.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, planhistory.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, planhistory.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, planhistory.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, planhistory.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, planhistory.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, planhistory.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, planhistory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, planhistory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, planhistory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, planhistory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, planhistory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, planhistory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, planhistory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, planhistory.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasChangeHistory != nil {
		p := planhistory.HasChangeHistory()
		if !*i.HasChangeHistory {
			p = planhistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChangeHistoryWith) > 0 {
		with := make([]predicate.ChangeHistory, 0, len(i.HasChangeHistoryWith))
		for _, w := range i.HasChangeHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChangeHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, planhistory.HasChangeHistoryWith(with...))
	}
	if i.HasTenant != nil {
		p := planhistory.HasTenant()
		if !*i.HasTenant {
			p = planhistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, planhistory.HasTenantWith(with...))
	}
	if i.HasChangedBy != nil {
		p := planhistory.HasChangedBy()
		if !*i.HasChangedBy {
			p = planhistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChangedByWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasChangedByWith))
		for _, w := range i.HasChangedByWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChangedByWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, planhistory.HasChangedByWith(with...))
	}
	if i.HasChangedFrom != nil {
		p := planhistory.HasChangedFrom()
		if !*i.HasChangedFrom {
			p = planhistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChangedFromWith) > 0 {
		with := make([]predicate.Plan, 0, len(i.HasChangedFromWith))
		for _, w := range i.HasChangedFromWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChangedFromWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, planhistory.HasChangedFromWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPlanHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return planhistory.And(predicates...), nil
	}
}

// PrintJobWhereInput represents a where input for filtering PrintJob queries.
type PrintJobWhereInput struct {
	Predicates []predicate.PrintJob  `json:"-"`
	Not        *PrintJobWhereInput   `json:"not,omitempty"`
	Or         []*PrintJobWhereInput `json:"or,omitempty"`
	And        []*PrintJobWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "status" field predicates.
	Status      *printjob.Status  `json:"status,omitempty"`
	StatusNEQ   *printjob.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []printjob.Status `json:"statusIn,omitempty"`
	StatusNotIn []printjob.Status `json:"statusNotIn,omitempty"`

	// "file_extension" field predicates.
	FileExtension      *printjob.FileExtension  `json:"fileExtension,omitempty"`
	FileExtensionNEQ   *printjob.FileExtension  `json:"fileExtensionNEQ,omitempty"`
	FileExtensionIn    []printjob.FileExtension `json:"fileExtensionIn,omitempty"`
	FileExtensionNotIn []printjob.FileExtension `json:"fileExtensionNotIn,omitempty"`

	// "document_type" field predicates.
	DocumentType      *printjob.DocumentType  `json:"documentType,omitempty"`
	DocumentTypeNEQ   *printjob.DocumentType  `json:"documentTypeNEQ,omitempty"`
	DocumentTypeIn    []printjob.DocumentType `json:"documentTypeIn,omitempty"`
	DocumentTypeNotIn []printjob.DocumentType `json:"documentTypeNotIn,omitempty"`

	// "base64_print_data" field predicates.
	Base64PrintData             *string  `json:"base64PrintData,omitempty"`
	Base64PrintDataNEQ          *string  `json:"base64PrintDataNEQ,omitempty"`
	Base64PrintDataIn           []string `json:"base64PrintDataIn,omitempty"`
	Base64PrintDataNotIn        []string `json:"base64PrintDataNotIn,omitempty"`
	Base64PrintDataGT           *string  `json:"base64PrintDataGT,omitempty"`
	Base64PrintDataGTE          *string  `json:"base64PrintDataGTE,omitempty"`
	Base64PrintDataLT           *string  `json:"base64PrintDataLT,omitempty"`
	Base64PrintDataLTE          *string  `json:"base64PrintDataLTE,omitempty"`
	Base64PrintDataContains     *string  `json:"base64PrintDataContains,omitempty"`
	Base64PrintDataHasPrefix    *string  `json:"base64PrintDataHasPrefix,omitempty"`
	Base64PrintDataHasSuffix    *string  `json:"base64PrintDataHasSuffix,omitempty"`
	Base64PrintDataEqualFold    *string  `json:"base64PrintDataEqualFold,omitempty"`
	Base64PrintDataContainsFold *string  `json:"base64PrintDataContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "printer" edge predicates.
	HasPrinter     *bool                `json:"hasPrinter,omitempty"`
	HasPrinterWith []*PrinterWhereInput `json:"hasPrinterWith,omitempty"`

	// "colli" edge predicates.
	HasColli     *bool              `json:"hasColli,omitempty"`
	HasColliWith []*ColliWhereInput `json:"hasColliWith,omitempty"`

	// "shipment_parcel" edge predicates.
	HasShipmentParcel     *bool                       `json:"hasShipmentParcel,omitempty"`
	HasShipmentParcelWith []*ShipmentParcelWhereInput `json:"hasShipmentParcelWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PrintJobWhereInput) AddPredicates(predicates ...predicate.PrintJob) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PrintJobWhereInput filter on the PrintJobQuery builder.
func (i *PrintJobWhereInput) Filter(q *PrintJobQuery) (*PrintJobQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPrintJobWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPrintJobWhereInput is returned in case the PrintJobWhereInput is empty.
var ErrEmptyPrintJobWhereInput = errors.New("ent: empty predicate PrintJobWhereInput")

// P returns a predicate for filtering printjobs.
// An error is returned if the input is empty or invalid.
func (i *PrintJobWhereInput) P() (predicate.PrintJob, error) {
	var predicates []predicate.PrintJob
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, printjob.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PrintJob, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, printjob.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PrintJob, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, printjob.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, printjob.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, printjob.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, printjob.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, printjob.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, printjob.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, printjob.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, printjob.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, printjob.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, printjob.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, printjob.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, printjob.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, printjob.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, printjob.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, printjob.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, printjob.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, printjob.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, printjob.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, printjob.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, printjob.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, printjob.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, printjob.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, printjob.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, printjob.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, printjob.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, printjob.StatusNotIn(i.StatusNotIn...))
	}
	if i.FileExtension != nil {
		predicates = append(predicates, printjob.FileExtensionEQ(*i.FileExtension))
	}
	if i.FileExtensionNEQ != nil {
		predicates = append(predicates, printjob.FileExtensionNEQ(*i.FileExtensionNEQ))
	}
	if len(i.FileExtensionIn) > 0 {
		predicates = append(predicates, printjob.FileExtensionIn(i.FileExtensionIn...))
	}
	if len(i.FileExtensionNotIn) > 0 {
		predicates = append(predicates, printjob.FileExtensionNotIn(i.FileExtensionNotIn...))
	}
	if i.DocumentType != nil {
		predicates = append(predicates, printjob.DocumentTypeEQ(*i.DocumentType))
	}
	if i.DocumentTypeNEQ != nil {
		predicates = append(predicates, printjob.DocumentTypeNEQ(*i.DocumentTypeNEQ))
	}
	if len(i.DocumentTypeIn) > 0 {
		predicates = append(predicates, printjob.DocumentTypeIn(i.DocumentTypeIn...))
	}
	if len(i.DocumentTypeNotIn) > 0 {
		predicates = append(predicates, printjob.DocumentTypeNotIn(i.DocumentTypeNotIn...))
	}
	if i.Base64PrintData != nil {
		predicates = append(predicates, printjob.Base64PrintDataEQ(*i.Base64PrintData))
	}
	if i.Base64PrintDataNEQ != nil {
		predicates = append(predicates, printjob.Base64PrintDataNEQ(*i.Base64PrintDataNEQ))
	}
	if len(i.Base64PrintDataIn) > 0 {
		predicates = append(predicates, printjob.Base64PrintDataIn(i.Base64PrintDataIn...))
	}
	if len(i.Base64PrintDataNotIn) > 0 {
		predicates = append(predicates, printjob.Base64PrintDataNotIn(i.Base64PrintDataNotIn...))
	}
	if i.Base64PrintDataGT != nil {
		predicates = append(predicates, printjob.Base64PrintDataGT(*i.Base64PrintDataGT))
	}
	if i.Base64PrintDataGTE != nil {
		predicates = append(predicates, printjob.Base64PrintDataGTE(*i.Base64PrintDataGTE))
	}
	if i.Base64PrintDataLT != nil {
		predicates = append(predicates, printjob.Base64PrintDataLT(*i.Base64PrintDataLT))
	}
	if i.Base64PrintDataLTE != nil {
		predicates = append(predicates, printjob.Base64PrintDataLTE(*i.Base64PrintDataLTE))
	}
	if i.Base64PrintDataContains != nil {
		predicates = append(predicates, printjob.Base64PrintDataContains(*i.Base64PrintDataContains))
	}
	if i.Base64PrintDataHasPrefix != nil {
		predicates = append(predicates, printjob.Base64PrintDataHasPrefix(*i.Base64PrintDataHasPrefix))
	}
	if i.Base64PrintDataHasSuffix != nil {
		predicates = append(predicates, printjob.Base64PrintDataHasSuffix(*i.Base64PrintDataHasSuffix))
	}
	if i.Base64PrintDataEqualFold != nil {
		predicates = append(predicates, printjob.Base64PrintDataEqualFold(*i.Base64PrintDataEqualFold))
	}
	if i.Base64PrintDataContainsFold != nil {
		predicates = append(predicates, printjob.Base64PrintDataContainsFold(*i.Base64PrintDataContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, printjob.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, printjob.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, printjob.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, printjob.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, printjob.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, printjob.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, printjob.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, printjob.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasTenant != nil {
		p := printjob.HasTenant()
		if !*i.HasTenant {
			p = printjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, printjob.HasTenantWith(with...))
	}
	if i.HasPrinter != nil {
		p := printjob.HasPrinter()
		if !*i.HasPrinter {
			p = printjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPrinterWith) > 0 {
		with := make([]predicate.Printer, 0, len(i.HasPrinterWith))
		for _, w := range i.HasPrinterWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPrinterWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, printjob.HasPrinterWith(with...))
	}
	if i.HasColli != nil {
		p := printjob.HasColli()
		if !*i.HasColli {
			p = printjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasColliWith))
		for _, w := range i.HasColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, printjob.HasColliWith(with...))
	}
	if i.HasShipmentParcel != nil {
		p := printjob.HasShipmentParcel()
		if !*i.HasShipmentParcel {
			p = printjob.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentParcelWith) > 0 {
		with := make([]predicate.ShipmentParcel, 0, len(i.HasShipmentParcelWith))
		for _, w := range i.HasShipmentParcelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentParcelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, printjob.HasShipmentParcelWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPrintJobWhereInput
	case 1:
		return predicates[0], nil
	default:
		return printjob.And(predicates...), nil
	}
}

// PrinterWhereInput represents a where input for filtering Printer queries.
type PrinterWhereInput struct {
	Predicates []predicate.Printer  `json:"-"`
	Not        *PrinterWhereInput   `json:"not,omitempty"`
	Or         []*PrinterWhereInput `json:"or,omitempty"`
	And        []*PrinterWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "device_id" field predicates.
	DeviceID             *pulid.ID  `json:"deviceID,omitempty"`
	DeviceIDNEQ          *pulid.ID  `json:"deviceIDNEQ,omitempty"`
	DeviceIDIn           []pulid.ID `json:"deviceIDIn,omitempty"`
	DeviceIDNotIn        []pulid.ID `json:"deviceIDNotIn,omitempty"`
	DeviceIDGT           *pulid.ID  `json:"deviceIDGT,omitempty"`
	DeviceIDGTE          *pulid.ID  `json:"deviceIDGTE,omitempty"`
	DeviceIDLT           *pulid.ID  `json:"deviceIDLT,omitempty"`
	DeviceIDLTE          *pulid.ID  `json:"deviceIDLTE,omitempty"`
	DeviceIDContains     *pulid.ID  `json:"deviceIDContains,omitempty"`
	DeviceIDHasPrefix    *pulid.ID  `json:"deviceIDHasPrefix,omitempty"`
	DeviceIDHasSuffix    *pulid.ID  `json:"deviceIDHasSuffix,omitempty"`
	DeviceIDEqualFold    *pulid.ID  `json:"deviceIDEqualFold,omitempty"`
	DeviceIDContainsFold *pulid.ID  `json:"deviceIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "label_zpl" field predicates.
	LabelZpl    *bool `json:"labelZpl,omitempty"`
	LabelZplNEQ *bool `json:"labelZplNEQ,omitempty"`

	// "label_pdf" field predicates.
	LabelPdf    *bool `json:"labelPdf,omitempty"`
	LabelPdfNEQ *bool `json:"labelPdfNEQ,omitempty"`

	// "label_png" field predicates.
	LabelPng    *bool `json:"labelPng,omitempty"`
	LabelPngNEQ *bool `json:"labelPngNEQ,omitempty"`

	// "document" field predicates.
	Document    *bool `json:"document,omitempty"`
	DocumentNEQ *bool `json:"documentNEQ,omitempty"`

	// "rotate_180" field predicates.
	Rotate180    *bool `json:"rotate180,omitempty"`
	Rotate180NEQ *bool `json:"rotate180NEQ,omitempty"`

	// "use_shell" field predicates.
	UseShell    *bool `json:"useShell,omitempty"`
	UseShellNEQ *bool `json:"useShellNEQ,omitempty"`

	// "print_size" field predicates.
	PrintSize      *printer.PrintSize  `json:"printSize,omitempty"`
	PrintSizeNEQ   *printer.PrintSize  `json:"printSizeNEQ,omitempty"`
	PrintSizeIn    []printer.PrintSize `json:"printSizeIn,omitempty"`
	PrintSizeNotIn []printer.PrintSize `json:"printSizeNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_ping" field predicates.
	LastPing      *time.Time  `json:"lastPing,omitempty"`
	LastPingNEQ   *time.Time  `json:"lastPingNEQ,omitempty"`
	LastPingIn    []time.Time `json:"lastPingIn,omitempty"`
	LastPingNotIn []time.Time `json:"lastPingNotIn,omitempty"`
	LastPingGT    *time.Time  `json:"lastPingGT,omitempty"`
	LastPingGTE   *time.Time  `json:"lastPingGTE,omitempty"`
	LastPingLT    *time.Time  `json:"lastPingLT,omitempty"`
	LastPingLTE   *time.Time  `json:"lastPingLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "workstation" edge predicates.
	HasWorkstation     *bool                    `json:"hasWorkstation,omitempty"`
	HasWorkstationWith []*WorkstationWhereInput `json:"hasWorkstationWith,omitempty"`

	// "print_jobs" edge predicates.
	HasPrintJobs     *bool                 `json:"hasPrintJobs,omitempty"`
	HasPrintJobsWith []*PrintJobWhereInput `json:"hasPrintJobsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PrinterWhereInput) AddPredicates(predicates ...predicate.Printer) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PrinterWhereInput filter on the PrinterQuery builder.
func (i *PrinterWhereInput) Filter(q *PrinterQuery) (*PrinterQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPrinterWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPrinterWhereInput is returned in case the PrinterWhereInput is empty.
var ErrEmptyPrinterWhereInput = errors.New("ent: empty predicate PrinterWhereInput")

// P returns a predicate for filtering printers.
// An error is returned if the input is empty or invalid.
func (i *PrinterWhereInput) P() (predicate.Printer, error) {
	var predicates []predicate.Printer
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, printer.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Printer, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, printer.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Printer, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, printer.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, printer.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, printer.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, printer.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, printer.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, printer.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, printer.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, printer.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, printer.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, printer.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, printer.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, printer.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, printer.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, printer.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, printer.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, printer.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, printer.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, printer.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, printer.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, printer.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, printer.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, printer.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.DeviceID != nil {
		predicates = append(predicates, printer.DeviceIDEQ(*i.DeviceID))
	}
	if i.DeviceIDNEQ != nil {
		predicates = append(predicates, printer.DeviceIDNEQ(*i.DeviceIDNEQ))
	}
	if len(i.DeviceIDIn) > 0 {
		predicates = append(predicates, printer.DeviceIDIn(i.DeviceIDIn...))
	}
	if len(i.DeviceIDNotIn) > 0 {
		predicates = append(predicates, printer.DeviceIDNotIn(i.DeviceIDNotIn...))
	}
	if i.DeviceIDGT != nil {
		predicates = append(predicates, printer.DeviceIDGT(*i.DeviceIDGT))
	}
	if i.DeviceIDGTE != nil {
		predicates = append(predicates, printer.DeviceIDGTE(*i.DeviceIDGTE))
	}
	if i.DeviceIDLT != nil {
		predicates = append(predicates, printer.DeviceIDLT(*i.DeviceIDLT))
	}
	if i.DeviceIDLTE != nil {
		predicates = append(predicates, printer.DeviceIDLTE(*i.DeviceIDLTE))
	}
	if i.DeviceIDContains != nil {
		predicates = append(predicates, printer.DeviceIDContains(*i.DeviceIDContains))
	}
	if i.DeviceIDHasPrefix != nil {
		predicates = append(predicates, printer.DeviceIDHasPrefix(*i.DeviceIDHasPrefix))
	}
	if i.DeviceIDHasSuffix != nil {
		predicates = append(predicates, printer.DeviceIDHasSuffix(*i.DeviceIDHasSuffix))
	}
	if i.DeviceIDEqualFold != nil {
		predicates = append(predicates, printer.DeviceIDEqualFold(*i.DeviceIDEqualFold))
	}
	if i.DeviceIDContainsFold != nil {
		predicates = append(predicates, printer.DeviceIDContainsFold(*i.DeviceIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, printer.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, printer.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, printer.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, printer.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, printer.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, printer.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, printer.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, printer.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, printer.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, printer.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, printer.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, printer.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, printer.NameContainsFold(*i.NameContainsFold))
	}
	if i.LabelZpl != nil {
		predicates = append(predicates, printer.LabelZplEQ(*i.LabelZpl))
	}
	if i.LabelZplNEQ != nil {
		predicates = append(predicates, printer.LabelZplNEQ(*i.LabelZplNEQ))
	}
	if i.LabelPdf != nil {
		predicates = append(predicates, printer.LabelPdfEQ(*i.LabelPdf))
	}
	if i.LabelPdfNEQ != nil {
		predicates = append(predicates, printer.LabelPdfNEQ(*i.LabelPdfNEQ))
	}
	if i.LabelPng != nil {
		predicates = append(predicates, printer.LabelPngEQ(*i.LabelPng))
	}
	if i.LabelPngNEQ != nil {
		predicates = append(predicates, printer.LabelPngNEQ(*i.LabelPngNEQ))
	}
	if i.Document != nil {
		predicates = append(predicates, printer.DocumentEQ(*i.Document))
	}
	if i.DocumentNEQ != nil {
		predicates = append(predicates, printer.DocumentNEQ(*i.DocumentNEQ))
	}
	if i.Rotate180 != nil {
		predicates = append(predicates, printer.Rotate180EQ(*i.Rotate180))
	}
	if i.Rotate180NEQ != nil {
		predicates = append(predicates, printer.Rotate180NEQ(*i.Rotate180NEQ))
	}
	if i.UseShell != nil {
		predicates = append(predicates, printer.UseShellEQ(*i.UseShell))
	}
	if i.UseShellNEQ != nil {
		predicates = append(predicates, printer.UseShellNEQ(*i.UseShellNEQ))
	}
	if i.PrintSize != nil {
		predicates = append(predicates, printer.PrintSizeEQ(*i.PrintSize))
	}
	if i.PrintSizeNEQ != nil {
		predicates = append(predicates, printer.PrintSizeNEQ(*i.PrintSizeNEQ))
	}
	if len(i.PrintSizeIn) > 0 {
		predicates = append(predicates, printer.PrintSizeIn(i.PrintSizeIn...))
	}
	if len(i.PrintSizeNotIn) > 0 {
		predicates = append(predicates, printer.PrintSizeNotIn(i.PrintSizeNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, printer.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, printer.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, printer.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, printer.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, printer.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, printer.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, printer.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, printer.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastPing != nil {
		predicates = append(predicates, printer.LastPingEQ(*i.LastPing))
	}
	if i.LastPingNEQ != nil {
		predicates = append(predicates, printer.LastPingNEQ(*i.LastPingNEQ))
	}
	if len(i.LastPingIn) > 0 {
		predicates = append(predicates, printer.LastPingIn(i.LastPingIn...))
	}
	if len(i.LastPingNotIn) > 0 {
		predicates = append(predicates, printer.LastPingNotIn(i.LastPingNotIn...))
	}
	if i.LastPingGT != nil {
		predicates = append(predicates, printer.LastPingGT(*i.LastPingGT))
	}
	if i.LastPingGTE != nil {
		predicates = append(predicates, printer.LastPingGTE(*i.LastPingGTE))
	}
	if i.LastPingLT != nil {
		predicates = append(predicates, printer.LastPingLT(*i.LastPingLT))
	}
	if i.LastPingLTE != nil {
		predicates = append(predicates, printer.LastPingLTE(*i.LastPingLTE))
	}

	if i.HasTenant != nil {
		p := printer.HasTenant()
		if !*i.HasTenant {
			p = printer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, printer.HasTenantWith(with...))
	}
	if i.HasWorkstation != nil {
		p := printer.HasWorkstation()
		if !*i.HasWorkstation {
			p = printer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkstationWith) > 0 {
		with := make([]predicate.Workstation, 0, len(i.HasWorkstationWith))
		for _, w := range i.HasWorkstationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkstationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, printer.HasWorkstationWith(with...))
	}
	if i.HasPrintJobs != nil {
		p := printer.HasPrintJobs()
		if !*i.HasPrintJobs {
			p = printer.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPrintJobsWith) > 0 {
		with := make([]predicate.PrintJob, 0, len(i.HasPrintJobsWith))
		for _, w := range i.HasPrintJobsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPrintJobsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, printer.HasPrintJobsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPrinterWhereInput
	case 1:
		return predicates[0], nil
	default:
		return printer.And(predicates...), nil
	}
}

// ProductWhereInput represents a where input for filtering Product queries.
type ProductWhereInput struct {
	Predicates []predicate.Product  `json:"-"`
	Not        *ProductWhereInput   `json:"not,omitempty"`
	Or         []*ProductWhereInput `json:"or,omitempty"`
	And        []*ProductWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "title" field predicates.
	Title             *string  `json:"title,omitempty"`
	TitleNEQ          *string  `json:"titleNEQ,omitempty"`
	TitleIn           []string `json:"titleIn,omitempty"`
	TitleNotIn        []string `json:"titleNotIn,omitempty"`
	TitleGT           *string  `json:"titleGT,omitempty"`
	TitleGTE          *string  `json:"titleGTE,omitempty"`
	TitleLT           *string  `json:"titleLT,omitempty"`
	TitleLTE          *string  `json:"titleLTE,omitempty"`
	TitleContains     *string  `json:"titleContains,omitempty"`
	TitleHasPrefix    *string  `json:"titleHasPrefix,omitempty"`
	TitleHasSuffix    *string  `json:"titleHasSuffix,omitempty"`
	TitleEqualFold    *string  `json:"titleEqualFold,omitempty"`
	TitleContainsFold *string  `json:"titleContainsFold,omitempty"`

	// "body_html" field predicates.
	BodyHTML             *string  `json:"bodyHTML,omitempty"`
	BodyHTMLNEQ          *string  `json:"bodyHTMLNEQ,omitempty"`
	BodyHTMLIn           []string `json:"bodyHTMLIn,omitempty"`
	BodyHTMLNotIn        []string `json:"bodyHTMLNotIn,omitempty"`
	BodyHTMLGT           *string  `json:"bodyHTMLGT,omitempty"`
	BodyHTMLGTE          *string  `json:"bodyHTMLGTE,omitempty"`
	BodyHTMLLT           *string  `json:"bodyHTMLLT,omitempty"`
	BodyHTMLLTE          *string  `json:"bodyHTMLLTE,omitempty"`
	BodyHTMLContains     *string  `json:"bodyHTMLContains,omitempty"`
	BodyHTMLHasPrefix    *string  `json:"bodyHTMLHasPrefix,omitempty"`
	BodyHTMLHasSuffix    *string  `json:"bodyHTMLHasSuffix,omitempty"`
	BodyHTMLIsNil        bool     `json:"bodyHTMLIsNil,omitempty"`
	BodyHTMLNotNil       bool     `json:"bodyHTMLNotNil,omitempty"`
	BodyHTMLEqualFold    *string  `json:"bodyHTMLEqualFold,omitempty"`
	BodyHTMLContainsFold *string  `json:"bodyHTMLContainsFold,omitempty"`

	// "status" field predicates.
	Status      *product.Status  `json:"status,omitempty"`
	StatusNEQ   *product.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []product.Status `json:"statusIn,omitempty"`
	StatusNotIn []product.Status `json:"statusNotIn,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "product_tags" edge predicates.
	HasProductTags     *bool                   `json:"hasProductTags,omitempty"`
	HasProductTagsWith []*ProductTagWhereInput `json:"hasProductTagsWith,omitempty"`

	// "product_variant" edge predicates.
	HasProductVariant     *bool                       `json:"hasProductVariant,omitempty"`
	HasProductVariantWith []*ProductVariantWhereInput `json:"hasProductVariantWith,omitempty"`

	// "product_image" edge predicates.
	HasProductImage     *bool                     `json:"hasProductImage,omitempty"`
	HasProductImageWith []*ProductImageWhereInput `json:"hasProductImageWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductWhereInput) AddPredicates(predicates ...predicate.Product) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductWhereInput filter on the ProductQuery builder.
func (i *ProductWhereInput) Filter(q *ProductQuery) (*ProductQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductWhereInput is returned in case the ProductWhereInput is empty.
var ErrEmptyProductWhereInput = errors.New("ent: empty predicate ProductWhereInput")

// P returns a predicate for filtering products.
// An error is returned if the input is empty or invalid.
func (i *ProductWhereInput) P() (predicate.Product, error) {
	var predicates []predicate.Product
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, product.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Product, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, product.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Product, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, product.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, product.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, product.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, product.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, product.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, product.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, product.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, product.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, product.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, product.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, product.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, product.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, product.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, product.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, product.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, product.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, product.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, product.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, product.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, product.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, product.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, product.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ExternalID != nil {
		predicates = append(predicates, product.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, product.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, product.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, product.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, product.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, product.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, product.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, product.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, product.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, product.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, product.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, product.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, product.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, product.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, product.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.Title != nil {
		predicates = append(predicates, product.TitleEQ(*i.Title))
	}
	if i.TitleNEQ != nil {
		predicates = append(predicates, product.TitleNEQ(*i.TitleNEQ))
	}
	if len(i.TitleIn) > 0 {
		predicates = append(predicates, product.TitleIn(i.TitleIn...))
	}
	if len(i.TitleNotIn) > 0 {
		predicates = append(predicates, product.TitleNotIn(i.TitleNotIn...))
	}
	if i.TitleGT != nil {
		predicates = append(predicates, product.TitleGT(*i.TitleGT))
	}
	if i.TitleGTE != nil {
		predicates = append(predicates, product.TitleGTE(*i.TitleGTE))
	}
	if i.TitleLT != nil {
		predicates = append(predicates, product.TitleLT(*i.TitleLT))
	}
	if i.TitleLTE != nil {
		predicates = append(predicates, product.TitleLTE(*i.TitleLTE))
	}
	if i.TitleContains != nil {
		predicates = append(predicates, product.TitleContains(*i.TitleContains))
	}
	if i.TitleHasPrefix != nil {
		predicates = append(predicates, product.TitleHasPrefix(*i.TitleHasPrefix))
	}
	if i.TitleHasSuffix != nil {
		predicates = append(predicates, product.TitleHasSuffix(*i.TitleHasSuffix))
	}
	if i.TitleEqualFold != nil {
		predicates = append(predicates, product.TitleEqualFold(*i.TitleEqualFold))
	}
	if i.TitleContainsFold != nil {
		predicates = append(predicates, product.TitleContainsFold(*i.TitleContainsFold))
	}
	if i.BodyHTML != nil {
		predicates = append(predicates, product.BodyHTMLEQ(*i.BodyHTML))
	}
	if i.BodyHTMLNEQ != nil {
		predicates = append(predicates, product.BodyHTMLNEQ(*i.BodyHTMLNEQ))
	}
	if len(i.BodyHTMLIn) > 0 {
		predicates = append(predicates, product.BodyHTMLIn(i.BodyHTMLIn...))
	}
	if len(i.BodyHTMLNotIn) > 0 {
		predicates = append(predicates, product.BodyHTMLNotIn(i.BodyHTMLNotIn...))
	}
	if i.BodyHTMLGT != nil {
		predicates = append(predicates, product.BodyHTMLGT(*i.BodyHTMLGT))
	}
	if i.BodyHTMLGTE != nil {
		predicates = append(predicates, product.BodyHTMLGTE(*i.BodyHTMLGTE))
	}
	if i.BodyHTMLLT != nil {
		predicates = append(predicates, product.BodyHTMLLT(*i.BodyHTMLLT))
	}
	if i.BodyHTMLLTE != nil {
		predicates = append(predicates, product.BodyHTMLLTE(*i.BodyHTMLLTE))
	}
	if i.BodyHTMLContains != nil {
		predicates = append(predicates, product.BodyHTMLContains(*i.BodyHTMLContains))
	}
	if i.BodyHTMLHasPrefix != nil {
		predicates = append(predicates, product.BodyHTMLHasPrefix(*i.BodyHTMLHasPrefix))
	}
	if i.BodyHTMLHasSuffix != nil {
		predicates = append(predicates, product.BodyHTMLHasSuffix(*i.BodyHTMLHasSuffix))
	}
	if i.BodyHTMLIsNil {
		predicates = append(predicates, product.BodyHTMLIsNil())
	}
	if i.BodyHTMLNotNil {
		predicates = append(predicates, product.BodyHTMLNotNil())
	}
	if i.BodyHTMLEqualFold != nil {
		predicates = append(predicates, product.BodyHTMLEqualFold(*i.BodyHTMLEqualFold))
	}
	if i.BodyHTMLContainsFold != nil {
		predicates = append(predicates, product.BodyHTMLContainsFold(*i.BodyHTMLContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, product.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, product.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, product.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, product.StatusNotIn(i.StatusNotIn...))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, product.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, product.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, product.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, product.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, product.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, product.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, product.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, product.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, product.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, product.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, product.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, product.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, product.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, product.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, product.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, product.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, product.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, product.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasTenant != nil {
		p := product.HasTenant()
		if !*i.HasTenant {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasTenantWith(with...))
	}
	if i.HasProductTags != nil {
		p := product.HasProductTags()
		if !*i.HasProductTags {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductTagsWith) > 0 {
		with := make([]predicate.ProductTag, 0, len(i.HasProductTagsWith))
		for _, w := range i.HasProductTagsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductTagsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasProductTagsWith(with...))
	}
	if i.HasProductVariant != nil {
		p := product.HasProductVariant()
		if !*i.HasProductVariant {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductVariantWith) > 0 {
		with := make([]predicate.ProductVariant, 0, len(i.HasProductVariantWith))
		for _, w := range i.HasProductVariantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductVariantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasProductVariantWith(with...))
	}
	if i.HasProductImage != nil {
		p := product.HasProductImage()
		if !*i.HasProductImage {
			p = product.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductImageWith) > 0 {
		with := make([]predicate.ProductImage, 0, len(i.HasProductImageWith))
		for _, w := range i.HasProductImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, product.HasProductImageWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductWhereInput
	case 1:
		return predicates[0], nil
	default:
		return product.And(predicates...), nil
	}
}

// ProductImageWhereInput represents a where input for filtering ProductImage queries.
type ProductImageWhereInput struct {
	Predicates []predicate.ProductImage  `json:"-"`
	Not        *ProductImageWhereInput   `json:"not,omitempty"`
	Or         []*ProductImageWhereInput `json:"or,omitempty"`
	And        []*ProductImageWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "external_id" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "url" field predicates.
	URL             *string  `json:"url,omitempty"`
	URLNEQ          *string  `json:"urlNEQ,omitempty"`
	URLIn           []string `json:"urlIn,omitempty"`
	URLNotIn        []string `json:"urlNotIn,omitempty"`
	URLGT           *string  `json:"urlGT,omitempty"`
	URLGTE          *string  `json:"urlGTE,omitempty"`
	URLLT           *string  `json:"urlLT,omitempty"`
	URLLTE          *string  `json:"urlLTE,omitempty"`
	URLContains     *string  `json:"urlContains,omitempty"`
	URLHasPrefix    *string  `json:"urlHasPrefix,omitempty"`
	URLHasSuffix    *string  `json:"urlHasSuffix,omitempty"`
	URLEqualFold    *string  `json:"urlEqualFold,omitempty"`
	URLContainsFold *string  `json:"urlContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "product" edge predicates.
	HasProduct     *bool                `json:"hasProduct,omitempty"`
	HasProductWith []*ProductWhereInput `json:"hasProductWith,omitempty"`

	// "product_variant" edge predicates.
	HasProductVariant     *bool                       `json:"hasProductVariant,omitempty"`
	HasProductVariantWith []*ProductVariantWhereInput `json:"hasProductVariantWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductImageWhereInput) AddPredicates(predicates ...predicate.ProductImage) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductImageWhereInput filter on the ProductImageQuery builder.
func (i *ProductImageWhereInput) Filter(q *ProductImageQuery) (*ProductImageQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductImageWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductImageWhereInput is returned in case the ProductImageWhereInput is empty.
var ErrEmptyProductImageWhereInput = errors.New("ent: empty predicate ProductImageWhereInput")

// P returns a predicate for filtering productimages.
// An error is returned if the input is empty or invalid.
func (i *ProductImageWhereInput) P() (predicate.ProductImage, error) {
	var predicates []predicate.ProductImage
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, productimage.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProductImage, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, productimage.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProductImage, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, productimage.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, productimage.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, productimage.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, productimage.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, productimage.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, productimage.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, productimage.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, productimage.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, productimage.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, productimage.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, productimage.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, productimage.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, productimage.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, productimage.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, productimage.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, productimage.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, productimage.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, productimage.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, productimage.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, productimage.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, productimage.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, productimage.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ExternalID != nil {
		predicates = append(predicates, productimage.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, productimage.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, productimage.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, productimage.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, productimage.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, productimage.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, productimage.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, productimage.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, productimage.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, productimage.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, productimage.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, productimage.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, productimage.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, productimage.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, productimage.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.URL != nil {
		predicates = append(predicates, productimage.URLEQ(*i.URL))
	}
	if i.URLNEQ != nil {
		predicates = append(predicates, productimage.URLNEQ(*i.URLNEQ))
	}
	if len(i.URLIn) > 0 {
		predicates = append(predicates, productimage.URLIn(i.URLIn...))
	}
	if len(i.URLNotIn) > 0 {
		predicates = append(predicates, productimage.URLNotIn(i.URLNotIn...))
	}
	if i.URLGT != nil {
		predicates = append(predicates, productimage.URLGT(*i.URLGT))
	}
	if i.URLGTE != nil {
		predicates = append(predicates, productimage.URLGTE(*i.URLGTE))
	}
	if i.URLLT != nil {
		predicates = append(predicates, productimage.URLLT(*i.URLLT))
	}
	if i.URLLTE != nil {
		predicates = append(predicates, productimage.URLLTE(*i.URLLTE))
	}
	if i.URLContains != nil {
		predicates = append(predicates, productimage.URLContains(*i.URLContains))
	}
	if i.URLHasPrefix != nil {
		predicates = append(predicates, productimage.URLHasPrefix(*i.URLHasPrefix))
	}
	if i.URLHasSuffix != nil {
		predicates = append(predicates, productimage.URLHasSuffix(*i.URLHasSuffix))
	}
	if i.URLEqualFold != nil {
		predicates = append(predicates, productimage.URLEqualFold(*i.URLEqualFold))
	}
	if i.URLContainsFold != nil {
		predicates = append(predicates, productimage.URLContainsFold(*i.URLContainsFold))
	}

	if i.HasTenant != nil {
		p := productimage.HasTenant()
		if !*i.HasTenant {
			p = productimage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productimage.HasTenantWith(with...))
	}
	if i.HasProduct != nil {
		p := productimage.HasProduct()
		if !*i.HasProduct {
			p = productimage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductWith))
		for _, w := range i.HasProductWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productimage.HasProductWith(with...))
	}
	if i.HasProductVariant != nil {
		p := productimage.HasProductVariant()
		if !*i.HasProductVariant {
			p = productimage.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductVariantWith) > 0 {
		with := make([]predicate.ProductVariant, 0, len(i.HasProductVariantWith))
		for _, w := range i.HasProductVariantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductVariantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productimage.HasProductVariantWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductImageWhereInput
	case 1:
		return predicates[0], nil
	default:
		return productimage.And(predicates...), nil
	}
}

// ProductTagWhereInput represents a where input for filtering ProductTag queries.
type ProductTagWhereInput struct {
	Predicates []predicate.ProductTag  `json:"-"`
	Not        *ProductTagWhereInput   `json:"not,omitempty"`
	Or         []*ProductTagWhereInput `json:"or,omitempty"`
	And        []*ProductTagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "products" edge predicates.
	HasProducts     *bool                `json:"hasProducts,omitempty"`
	HasProductsWith []*ProductWhereInput `json:"hasProductsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductTagWhereInput) AddPredicates(predicates ...predicate.ProductTag) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductTagWhereInput filter on the ProductTagQuery builder.
func (i *ProductTagWhereInput) Filter(q *ProductTagQuery) (*ProductTagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductTagWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductTagWhereInput is returned in case the ProductTagWhereInput is empty.
var ErrEmptyProductTagWhereInput = errors.New("ent: empty predicate ProductTagWhereInput")

// P returns a predicate for filtering producttags.
// An error is returned if the input is empty or invalid.
func (i *ProductTagWhereInput) P() (predicate.ProductTag, error) {
	var predicates []predicate.ProductTag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, producttag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProductTag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, producttag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProductTag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, producttag.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, producttag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, producttag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, producttag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, producttag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, producttag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, producttag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, producttag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, producttag.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, producttag.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, producttag.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, producttag.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, producttag.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, producttag.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, producttag.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, producttag.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, producttag.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, producttag.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, producttag.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, producttag.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, producttag.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, producttag.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, producttag.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, producttag.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, producttag.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, producttag.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, producttag.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, producttag.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, producttag.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, producttag.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, producttag.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, producttag.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, producttag.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, producttag.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, producttag.NameContainsFold(*i.NameContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, producttag.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, producttag.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, producttag.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, producttag.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, producttag.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, producttag.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, producttag.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, producttag.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, producttag.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, producttag.CreatedAtNotNil())
	}

	if i.HasTenant != nil {
		p := producttag.HasTenant()
		if !*i.HasTenant {
			p = producttag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, producttag.HasTenantWith(with...))
	}
	if i.HasProducts != nil {
		p := producttag.HasProducts()
		if !*i.HasProducts {
			p = producttag.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductsWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductsWith))
		for _, w := range i.HasProductsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, producttag.HasProductsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductTagWhereInput
	case 1:
		return predicates[0], nil
	default:
		return producttag.And(predicates...), nil
	}
}

// ProductVariantWhereInput represents a where input for filtering ProductVariant queries.
type ProductVariantWhereInput struct {
	Predicates []predicate.ProductVariant  `json:"-"`
	Not        *ProductVariantWhereInput   `json:"not,omitempty"`
	Or         []*ProductVariantWhereInput `json:"or,omitempty"`
	And        []*ProductVariantWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "archived" field predicates.
	Archived    *bool `json:"archived,omitempty"`
	ArchivedNEQ *bool `json:"archivedNEQ,omitempty"`

	// "external_ID" field predicates.
	ExternalID             *string  `json:"externalID,omitempty"`
	ExternalIDNEQ          *string  `json:"externalIDNEQ,omitempty"`
	ExternalIDIn           []string `json:"externalIDIn,omitempty"`
	ExternalIDNotIn        []string `json:"externalIDNotIn,omitempty"`
	ExternalIDGT           *string  `json:"externalIDGT,omitempty"`
	ExternalIDGTE          *string  `json:"externalIDGTE,omitempty"`
	ExternalIDLT           *string  `json:"externalIDLT,omitempty"`
	ExternalIDLTE          *string  `json:"externalIDLTE,omitempty"`
	ExternalIDContains     *string  `json:"externalIDContains,omitempty"`
	ExternalIDHasPrefix    *string  `json:"externalIDHasPrefix,omitempty"`
	ExternalIDHasSuffix    *string  `json:"externalIDHasSuffix,omitempty"`
	ExternalIDIsNil        bool     `json:"externalIDIsNil,omitempty"`
	ExternalIDNotNil       bool     `json:"externalIDNotNil,omitempty"`
	ExternalIDEqualFold    *string  `json:"externalIDEqualFold,omitempty"`
	ExternalIDContainsFold *string  `json:"externalIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionIsNil        bool     `json:"descriptionIsNil,omitempty"`
	DescriptionNotNil       bool     `json:"descriptionNotNil,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "ean_number" field predicates.
	EanNumber             *string  `json:"eanNumber,omitempty"`
	EanNumberNEQ          *string  `json:"eanNumberNEQ,omitempty"`
	EanNumberIn           []string `json:"eanNumberIn,omitempty"`
	EanNumberNotIn        []string `json:"eanNumberNotIn,omitempty"`
	EanNumberGT           *string  `json:"eanNumberGT,omitempty"`
	EanNumberGTE          *string  `json:"eanNumberGTE,omitempty"`
	EanNumberLT           *string  `json:"eanNumberLT,omitempty"`
	EanNumberLTE          *string  `json:"eanNumberLTE,omitempty"`
	EanNumberContains     *string  `json:"eanNumberContains,omitempty"`
	EanNumberHasPrefix    *string  `json:"eanNumberHasPrefix,omitempty"`
	EanNumberHasSuffix    *string  `json:"eanNumberHasSuffix,omitempty"`
	EanNumberIsNil        bool     `json:"eanNumberIsNil,omitempty"`
	EanNumberNotNil       bool     `json:"eanNumberNotNil,omitempty"`
	EanNumberEqualFold    *string  `json:"eanNumberEqualFold,omitempty"`
	EanNumberContainsFold *string  `json:"eanNumberContainsFold,omitempty"`

	// "weight_g" field predicates.
	WeightG       *int  `json:"weightG,omitempty"`
	WeightGNEQ    *int  `json:"weightGNEQ,omitempty"`
	WeightGIn     []int `json:"weightGIn,omitempty"`
	WeightGNotIn  []int `json:"weightGNotIn,omitempty"`
	WeightGGT     *int  `json:"weightGGT,omitempty"`
	WeightGGTE    *int  `json:"weightGGTE,omitempty"`
	WeightGLT     *int  `json:"weightGLT,omitempty"`
	WeightGLTE    *int  `json:"weightGLTE,omitempty"`
	WeightGIsNil  bool  `json:"weightGIsNil,omitempty"`
	WeightGNotNil bool  `json:"weightGNotNil,omitempty"`

	// "dimension_length" field predicates.
	DimensionLength       *int  `json:"dimensionLength,omitempty"`
	DimensionLengthNEQ    *int  `json:"dimensionLengthNEQ,omitempty"`
	DimensionLengthIn     []int `json:"dimensionLengthIn,omitempty"`
	DimensionLengthNotIn  []int `json:"dimensionLengthNotIn,omitempty"`
	DimensionLengthGT     *int  `json:"dimensionLengthGT,omitempty"`
	DimensionLengthGTE    *int  `json:"dimensionLengthGTE,omitempty"`
	DimensionLengthLT     *int  `json:"dimensionLengthLT,omitempty"`
	DimensionLengthLTE    *int  `json:"dimensionLengthLTE,omitempty"`
	DimensionLengthIsNil  bool  `json:"dimensionLengthIsNil,omitempty"`
	DimensionLengthNotNil bool  `json:"dimensionLengthNotNil,omitempty"`

	// "dimension_width" field predicates.
	DimensionWidth       *int  `json:"dimensionWidth,omitempty"`
	DimensionWidthNEQ    *int  `json:"dimensionWidthNEQ,omitempty"`
	DimensionWidthIn     []int `json:"dimensionWidthIn,omitempty"`
	DimensionWidthNotIn  []int `json:"dimensionWidthNotIn,omitempty"`
	DimensionWidthGT     *int  `json:"dimensionWidthGT,omitempty"`
	DimensionWidthGTE    *int  `json:"dimensionWidthGTE,omitempty"`
	DimensionWidthLT     *int  `json:"dimensionWidthLT,omitempty"`
	DimensionWidthLTE    *int  `json:"dimensionWidthLTE,omitempty"`
	DimensionWidthIsNil  bool  `json:"dimensionWidthIsNil,omitempty"`
	DimensionWidthNotNil bool  `json:"dimensionWidthNotNil,omitempty"`

	// "dimension_height" field predicates.
	DimensionHeight       *int  `json:"dimensionHeight,omitempty"`
	DimensionHeightNEQ    *int  `json:"dimensionHeightNEQ,omitempty"`
	DimensionHeightIn     []int `json:"dimensionHeightIn,omitempty"`
	DimensionHeightNotIn  []int `json:"dimensionHeightNotIn,omitempty"`
	DimensionHeightGT     *int  `json:"dimensionHeightGT,omitempty"`
	DimensionHeightGTE    *int  `json:"dimensionHeightGTE,omitempty"`
	DimensionHeightLT     *int  `json:"dimensionHeightLT,omitempty"`
	DimensionHeightLTE    *int  `json:"dimensionHeightLTE,omitempty"`
	DimensionHeightIsNil  bool  `json:"dimensionHeightIsNil,omitempty"`
	DimensionHeightNotNil bool  `json:"dimensionHeightNotNil,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "product" edge predicates.
	HasProduct     *bool                `json:"hasProduct,omitempty"`
	HasProductWith []*ProductWhereInput `json:"hasProductWith,omitempty"`

	// "order_lines" edge predicates.
	HasOrderLines     *bool                  `json:"hasOrderLines,omitempty"`
	HasOrderLinesWith []*OrderLineWhereInput `json:"hasOrderLinesWith,omitempty"`

	// "product_image" edge predicates.
	HasProductImage     *bool                     `json:"hasProductImage,omitempty"`
	HasProductImageWith []*ProductImageWhereInput `json:"hasProductImageWith,omitempty"`

	// "inventory_item" edge predicates.
	HasInventoryItem     *bool                      `json:"hasInventoryItem,omitempty"`
	HasInventoryItemWith []*InventoryItemWhereInput `json:"hasInventoryItemWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ProductVariantWhereInput) AddPredicates(predicates ...predicate.ProductVariant) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ProductVariantWhereInput filter on the ProductVariantQuery builder.
func (i *ProductVariantWhereInput) Filter(q *ProductVariantQuery) (*ProductVariantQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyProductVariantWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyProductVariantWhereInput is returned in case the ProductVariantWhereInput is empty.
var ErrEmptyProductVariantWhereInput = errors.New("ent: empty predicate ProductVariantWhereInput")

// P returns a predicate for filtering productvariants.
// An error is returned if the input is empty or invalid.
func (i *ProductVariantWhereInput) P() (predicate.ProductVariant, error) {
	var predicates []predicate.ProductVariant
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, productvariant.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ProductVariant, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, productvariant.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ProductVariant, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, productvariant.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, productvariant.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, productvariant.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, productvariant.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, productvariant.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, productvariant.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, productvariant.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, productvariant.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, productvariant.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, productvariant.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, productvariant.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, productvariant.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, productvariant.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, productvariant.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, productvariant.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, productvariant.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, productvariant.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, productvariant.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, productvariant.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, productvariant.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, productvariant.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, productvariant.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Archived != nil {
		predicates = append(predicates, productvariant.ArchivedEQ(*i.Archived))
	}
	if i.ArchivedNEQ != nil {
		predicates = append(predicates, productvariant.ArchivedNEQ(*i.ArchivedNEQ))
	}
	if i.ExternalID != nil {
		predicates = append(predicates, productvariant.ExternalIDEQ(*i.ExternalID))
	}
	if i.ExternalIDNEQ != nil {
		predicates = append(predicates, productvariant.ExternalIDNEQ(*i.ExternalIDNEQ))
	}
	if len(i.ExternalIDIn) > 0 {
		predicates = append(predicates, productvariant.ExternalIDIn(i.ExternalIDIn...))
	}
	if len(i.ExternalIDNotIn) > 0 {
		predicates = append(predicates, productvariant.ExternalIDNotIn(i.ExternalIDNotIn...))
	}
	if i.ExternalIDGT != nil {
		predicates = append(predicates, productvariant.ExternalIDGT(*i.ExternalIDGT))
	}
	if i.ExternalIDGTE != nil {
		predicates = append(predicates, productvariant.ExternalIDGTE(*i.ExternalIDGTE))
	}
	if i.ExternalIDLT != nil {
		predicates = append(predicates, productvariant.ExternalIDLT(*i.ExternalIDLT))
	}
	if i.ExternalIDLTE != nil {
		predicates = append(predicates, productvariant.ExternalIDLTE(*i.ExternalIDLTE))
	}
	if i.ExternalIDContains != nil {
		predicates = append(predicates, productvariant.ExternalIDContains(*i.ExternalIDContains))
	}
	if i.ExternalIDHasPrefix != nil {
		predicates = append(predicates, productvariant.ExternalIDHasPrefix(*i.ExternalIDHasPrefix))
	}
	if i.ExternalIDHasSuffix != nil {
		predicates = append(predicates, productvariant.ExternalIDHasSuffix(*i.ExternalIDHasSuffix))
	}
	if i.ExternalIDIsNil {
		predicates = append(predicates, productvariant.ExternalIDIsNil())
	}
	if i.ExternalIDNotNil {
		predicates = append(predicates, productvariant.ExternalIDNotNil())
	}
	if i.ExternalIDEqualFold != nil {
		predicates = append(predicates, productvariant.ExternalIDEqualFold(*i.ExternalIDEqualFold))
	}
	if i.ExternalIDContainsFold != nil {
		predicates = append(predicates, productvariant.ExternalIDContainsFold(*i.ExternalIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, productvariant.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, productvariant.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, productvariant.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, productvariant.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, productvariant.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, productvariant.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, productvariant.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, productvariant.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, productvariant.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, productvariant.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, productvariant.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionIsNil {
		predicates = append(predicates, productvariant.DescriptionIsNil())
	}
	if i.DescriptionNotNil {
		predicates = append(predicates, productvariant.DescriptionNotNil())
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, productvariant.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, productvariant.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.EanNumber != nil {
		predicates = append(predicates, productvariant.EanNumberEQ(*i.EanNumber))
	}
	if i.EanNumberNEQ != nil {
		predicates = append(predicates, productvariant.EanNumberNEQ(*i.EanNumberNEQ))
	}
	if len(i.EanNumberIn) > 0 {
		predicates = append(predicates, productvariant.EanNumberIn(i.EanNumberIn...))
	}
	if len(i.EanNumberNotIn) > 0 {
		predicates = append(predicates, productvariant.EanNumberNotIn(i.EanNumberNotIn...))
	}
	if i.EanNumberGT != nil {
		predicates = append(predicates, productvariant.EanNumberGT(*i.EanNumberGT))
	}
	if i.EanNumberGTE != nil {
		predicates = append(predicates, productvariant.EanNumberGTE(*i.EanNumberGTE))
	}
	if i.EanNumberLT != nil {
		predicates = append(predicates, productvariant.EanNumberLT(*i.EanNumberLT))
	}
	if i.EanNumberLTE != nil {
		predicates = append(predicates, productvariant.EanNumberLTE(*i.EanNumberLTE))
	}
	if i.EanNumberContains != nil {
		predicates = append(predicates, productvariant.EanNumberContains(*i.EanNumberContains))
	}
	if i.EanNumberHasPrefix != nil {
		predicates = append(predicates, productvariant.EanNumberHasPrefix(*i.EanNumberHasPrefix))
	}
	if i.EanNumberHasSuffix != nil {
		predicates = append(predicates, productvariant.EanNumberHasSuffix(*i.EanNumberHasSuffix))
	}
	if i.EanNumberIsNil {
		predicates = append(predicates, productvariant.EanNumberIsNil())
	}
	if i.EanNumberNotNil {
		predicates = append(predicates, productvariant.EanNumberNotNil())
	}
	if i.EanNumberEqualFold != nil {
		predicates = append(predicates, productvariant.EanNumberEqualFold(*i.EanNumberEqualFold))
	}
	if i.EanNumberContainsFold != nil {
		predicates = append(predicates, productvariant.EanNumberContainsFold(*i.EanNumberContainsFold))
	}
	if i.WeightG != nil {
		predicates = append(predicates, productvariant.WeightGEQ(*i.WeightG))
	}
	if i.WeightGNEQ != nil {
		predicates = append(predicates, productvariant.WeightGNEQ(*i.WeightGNEQ))
	}
	if len(i.WeightGIn) > 0 {
		predicates = append(predicates, productvariant.WeightGIn(i.WeightGIn...))
	}
	if len(i.WeightGNotIn) > 0 {
		predicates = append(predicates, productvariant.WeightGNotIn(i.WeightGNotIn...))
	}
	if i.WeightGGT != nil {
		predicates = append(predicates, productvariant.WeightGGT(*i.WeightGGT))
	}
	if i.WeightGGTE != nil {
		predicates = append(predicates, productvariant.WeightGGTE(*i.WeightGGTE))
	}
	if i.WeightGLT != nil {
		predicates = append(predicates, productvariant.WeightGLT(*i.WeightGLT))
	}
	if i.WeightGLTE != nil {
		predicates = append(predicates, productvariant.WeightGLTE(*i.WeightGLTE))
	}
	if i.WeightGIsNil {
		predicates = append(predicates, productvariant.WeightGIsNil())
	}
	if i.WeightGNotNil {
		predicates = append(predicates, productvariant.WeightGNotNil())
	}
	if i.DimensionLength != nil {
		predicates = append(predicates, productvariant.DimensionLengthEQ(*i.DimensionLength))
	}
	if i.DimensionLengthNEQ != nil {
		predicates = append(predicates, productvariant.DimensionLengthNEQ(*i.DimensionLengthNEQ))
	}
	if len(i.DimensionLengthIn) > 0 {
		predicates = append(predicates, productvariant.DimensionLengthIn(i.DimensionLengthIn...))
	}
	if len(i.DimensionLengthNotIn) > 0 {
		predicates = append(predicates, productvariant.DimensionLengthNotIn(i.DimensionLengthNotIn...))
	}
	if i.DimensionLengthGT != nil {
		predicates = append(predicates, productvariant.DimensionLengthGT(*i.DimensionLengthGT))
	}
	if i.DimensionLengthGTE != nil {
		predicates = append(predicates, productvariant.DimensionLengthGTE(*i.DimensionLengthGTE))
	}
	if i.DimensionLengthLT != nil {
		predicates = append(predicates, productvariant.DimensionLengthLT(*i.DimensionLengthLT))
	}
	if i.DimensionLengthLTE != nil {
		predicates = append(predicates, productvariant.DimensionLengthLTE(*i.DimensionLengthLTE))
	}
	if i.DimensionLengthIsNil {
		predicates = append(predicates, productvariant.DimensionLengthIsNil())
	}
	if i.DimensionLengthNotNil {
		predicates = append(predicates, productvariant.DimensionLengthNotNil())
	}
	if i.DimensionWidth != nil {
		predicates = append(predicates, productvariant.DimensionWidthEQ(*i.DimensionWidth))
	}
	if i.DimensionWidthNEQ != nil {
		predicates = append(predicates, productvariant.DimensionWidthNEQ(*i.DimensionWidthNEQ))
	}
	if len(i.DimensionWidthIn) > 0 {
		predicates = append(predicates, productvariant.DimensionWidthIn(i.DimensionWidthIn...))
	}
	if len(i.DimensionWidthNotIn) > 0 {
		predicates = append(predicates, productvariant.DimensionWidthNotIn(i.DimensionWidthNotIn...))
	}
	if i.DimensionWidthGT != nil {
		predicates = append(predicates, productvariant.DimensionWidthGT(*i.DimensionWidthGT))
	}
	if i.DimensionWidthGTE != nil {
		predicates = append(predicates, productvariant.DimensionWidthGTE(*i.DimensionWidthGTE))
	}
	if i.DimensionWidthLT != nil {
		predicates = append(predicates, productvariant.DimensionWidthLT(*i.DimensionWidthLT))
	}
	if i.DimensionWidthLTE != nil {
		predicates = append(predicates, productvariant.DimensionWidthLTE(*i.DimensionWidthLTE))
	}
	if i.DimensionWidthIsNil {
		predicates = append(predicates, productvariant.DimensionWidthIsNil())
	}
	if i.DimensionWidthNotNil {
		predicates = append(predicates, productvariant.DimensionWidthNotNil())
	}
	if i.DimensionHeight != nil {
		predicates = append(predicates, productvariant.DimensionHeightEQ(*i.DimensionHeight))
	}
	if i.DimensionHeightNEQ != nil {
		predicates = append(predicates, productvariant.DimensionHeightNEQ(*i.DimensionHeightNEQ))
	}
	if len(i.DimensionHeightIn) > 0 {
		predicates = append(predicates, productvariant.DimensionHeightIn(i.DimensionHeightIn...))
	}
	if len(i.DimensionHeightNotIn) > 0 {
		predicates = append(predicates, productvariant.DimensionHeightNotIn(i.DimensionHeightNotIn...))
	}
	if i.DimensionHeightGT != nil {
		predicates = append(predicates, productvariant.DimensionHeightGT(*i.DimensionHeightGT))
	}
	if i.DimensionHeightGTE != nil {
		predicates = append(predicates, productvariant.DimensionHeightGTE(*i.DimensionHeightGTE))
	}
	if i.DimensionHeightLT != nil {
		predicates = append(predicates, productvariant.DimensionHeightLT(*i.DimensionHeightLT))
	}
	if i.DimensionHeightLTE != nil {
		predicates = append(predicates, productvariant.DimensionHeightLTE(*i.DimensionHeightLTE))
	}
	if i.DimensionHeightIsNil {
		predicates = append(predicates, productvariant.DimensionHeightIsNil())
	}
	if i.DimensionHeightNotNil {
		predicates = append(predicates, productvariant.DimensionHeightNotNil())
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, productvariant.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, productvariant.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, productvariant.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, productvariant.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, productvariant.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, productvariant.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, productvariant.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, productvariant.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, productvariant.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, productvariant.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, productvariant.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, productvariant.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, productvariant.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, productvariant.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, productvariant.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, productvariant.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, productvariant.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, productvariant.UpdatedAtLTE(*i.UpdatedAtLTE))
	}

	if i.HasTenant != nil {
		p := productvariant.HasTenant()
		if !*i.HasTenant {
			p = productvariant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productvariant.HasTenantWith(with...))
	}
	if i.HasProduct != nil {
		p := productvariant.HasProduct()
		if !*i.HasProduct {
			p = productvariant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductWith) > 0 {
		with := make([]predicate.Product, 0, len(i.HasProductWith))
		for _, w := range i.HasProductWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productvariant.HasProductWith(with...))
	}
	if i.HasOrderLines != nil {
		p := productvariant.HasOrderLines()
		if !*i.HasOrderLines {
			p = productvariant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrderLinesWith) > 0 {
		with := make([]predicate.OrderLine, 0, len(i.HasOrderLinesWith))
		for _, w := range i.HasOrderLinesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrderLinesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productvariant.HasOrderLinesWith(with...))
	}
	if i.HasProductImage != nil {
		p := productvariant.HasProductImage()
		if !*i.HasProductImage {
			p = productvariant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasProductImageWith) > 0 {
		with := make([]predicate.ProductImage, 0, len(i.HasProductImageWith))
		for _, w := range i.HasProductImageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasProductImageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productvariant.HasProductImageWith(with...))
	}
	if i.HasInventoryItem != nil {
		p := productvariant.HasInventoryItem()
		if !*i.HasInventoryItem {
			p = productvariant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasInventoryItemWith) > 0 {
		with := make([]predicate.InventoryItem, 0, len(i.HasInventoryItemWith))
		for _, w := range i.HasInventoryItemWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasInventoryItemWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, productvariant.HasInventoryItemWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyProductVariantWhereInput
	case 1:
		return predicates[0], nil
	default:
		return productvariant.And(predicates...), nil
	}
}

// ReturnColliWhereInput represents a where input for filtering ReturnColli queries.
type ReturnColliWhereInput struct {
	Predicates []predicate.ReturnColli  `json:"-"`
	Not        *ReturnColliWhereInput   `json:"not,omitempty"`
	Or         []*ReturnColliWhereInput `json:"or,omitempty"`
	And        []*ReturnColliWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "expected_at" field predicates.
	ExpectedAt       *time.Time  `json:"expectedAt,omitempty"`
	ExpectedAtNEQ    *time.Time  `json:"expectedAtNEQ,omitempty"`
	ExpectedAtIn     []time.Time `json:"expectedAtIn,omitempty"`
	ExpectedAtNotIn  []time.Time `json:"expectedAtNotIn,omitempty"`
	ExpectedAtGT     *time.Time  `json:"expectedAtGT,omitempty"`
	ExpectedAtGTE    *time.Time  `json:"expectedAtGTE,omitempty"`
	ExpectedAtLT     *time.Time  `json:"expectedAtLT,omitempty"`
	ExpectedAtLTE    *time.Time  `json:"expectedAtLTE,omitempty"`
	ExpectedAtIsNil  bool        `json:"expectedAtIsNil,omitempty"`
	ExpectedAtNotNil bool        `json:"expectedAtNotNil,omitempty"`

	// "label_pdf" field predicates.
	LabelPdf             *string  `json:"labelPdf,omitempty"`
	LabelPdfNEQ          *string  `json:"labelPdfNEQ,omitempty"`
	LabelPdfIn           []string `json:"labelPdfIn,omitempty"`
	LabelPdfNotIn        []string `json:"labelPdfNotIn,omitempty"`
	LabelPdfGT           *string  `json:"labelPdfGT,omitempty"`
	LabelPdfGTE          *string  `json:"labelPdfGTE,omitempty"`
	LabelPdfLT           *string  `json:"labelPdfLT,omitempty"`
	LabelPdfLTE          *string  `json:"labelPdfLTE,omitempty"`
	LabelPdfContains     *string  `json:"labelPdfContains,omitempty"`
	LabelPdfHasPrefix    *string  `json:"labelPdfHasPrefix,omitempty"`
	LabelPdfHasSuffix    *string  `json:"labelPdfHasSuffix,omitempty"`
	LabelPdfIsNil        bool     `json:"labelPdfIsNil,omitempty"`
	LabelPdfNotNil       bool     `json:"labelPdfNotNil,omitempty"`
	LabelPdfEqualFold    *string  `json:"labelPdfEqualFold,omitempty"`
	LabelPdfContainsFold *string  `json:"labelPdfContainsFold,omitempty"`

	// "label_png" field predicates.
	LabelPng             *string  `json:"labelPng,omitempty"`
	LabelPngNEQ          *string  `json:"labelPngNEQ,omitempty"`
	LabelPngIn           []string `json:"labelPngIn,omitempty"`
	LabelPngNotIn        []string `json:"labelPngNotIn,omitempty"`
	LabelPngGT           *string  `json:"labelPngGT,omitempty"`
	LabelPngGTE          *string  `json:"labelPngGTE,omitempty"`
	LabelPngLT           *string  `json:"labelPngLT,omitempty"`
	LabelPngLTE          *string  `json:"labelPngLTE,omitempty"`
	LabelPngContains     *string  `json:"labelPngContains,omitempty"`
	LabelPngHasPrefix    *string  `json:"labelPngHasPrefix,omitempty"`
	LabelPngHasSuffix    *string  `json:"labelPngHasSuffix,omitempty"`
	LabelPngIsNil        bool     `json:"labelPngIsNil,omitempty"`
	LabelPngNotNil       bool     `json:"labelPngNotNil,omitempty"`
	LabelPngEqualFold    *string  `json:"labelPngEqualFold,omitempty"`
	LabelPngContainsFold *string  `json:"labelPngContainsFold,omitempty"`

	// "qr_code_png" field predicates.
	QrCodePng             *string  `json:"qrCodePng,omitempty"`
	QrCodePngNEQ          *string  `json:"qrCodePngNEQ,omitempty"`
	QrCodePngIn           []string `json:"qrCodePngIn,omitempty"`
	QrCodePngNotIn        []string `json:"qrCodePngNotIn,omitempty"`
	QrCodePngGT           *string  `json:"qrCodePngGT,omitempty"`
	QrCodePngGTE          *string  `json:"qrCodePngGTE,omitempty"`
	QrCodePngLT           *string  `json:"qrCodePngLT,omitempty"`
	QrCodePngLTE          *string  `json:"qrCodePngLTE,omitempty"`
	QrCodePngContains     *string  `json:"qrCodePngContains,omitempty"`
	QrCodePngHasPrefix    *string  `json:"qrCodePngHasPrefix,omitempty"`
	QrCodePngHasSuffix    *string  `json:"qrCodePngHasSuffix,omitempty"`
	QrCodePngIsNil        bool     `json:"qrCodePngIsNil,omitempty"`
	QrCodePngNotNil       bool     `json:"qrCodePngNotNil,omitempty"`
	QrCodePngEqualFold    *string  `json:"qrCodePngEqualFold,omitempty"`
	QrCodePngContainsFold *string  `json:"qrCodePngContainsFold,omitempty"`

	// "comment" field predicates.
	Comment             *string  `json:"comment,omitempty"`
	CommentNEQ          *string  `json:"commentNEQ,omitempty"`
	CommentIn           []string `json:"commentIn,omitempty"`
	CommentNotIn        []string `json:"commentNotIn,omitempty"`
	CommentGT           *string  `json:"commentGT,omitempty"`
	CommentGTE          *string  `json:"commentGTE,omitempty"`
	CommentLT           *string  `json:"commentLT,omitempty"`
	CommentLTE          *string  `json:"commentLTE,omitempty"`
	CommentContains     *string  `json:"commentContains,omitempty"`
	CommentHasPrefix    *string  `json:"commentHasPrefix,omitempty"`
	CommentHasSuffix    *string  `json:"commentHasSuffix,omitempty"`
	CommentIsNil        bool     `json:"commentIsNil,omitempty"`
	CommentNotNil       bool     `json:"commentNotNil,omitempty"`
	CommentEqualFold    *string  `json:"commentEqualFold,omitempty"`
	CommentContainsFold *string  `json:"commentContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "status" field predicates.
	Status      *returncolli.Status  `json:"status,omitempty"`
	StatusNEQ   *returncolli.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []returncolli.Status `json:"statusIn,omitempty"`
	StatusNotIn []returncolli.Status `json:"statusNotIn,omitempty"`

	// "email_received" field predicates.
	EmailReceived       *time.Time  `json:"emailReceived,omitempty"`
	EmailReceivedNEQ    *time.Time  `json:"emailReceivedNEQ,omitempty"`
	EmailReceivedIn     []time.Time `json:"emailReceivedIn,omitempty"`
	EmailReceivedNotIn  []time.Time `json:"emailReceivedNotIn,omitempty"`
	EmailReceivedGT     *time.Time  `json:"emailReceivedGT,omitempty"`
	EmailReceivedGTE    *time.Time  `json:"emailReceivedGTE,omitempty"`
	EmailReceivedLT     *time.Time  `json:"emailReceivedLT,omitempty"`
	EmailReceivedLTE    *time.Time  `json:"emailReceivedLTE,omitempty"`
	EmailReceivedIsNil  bool        `json:"emailReceivedIsNil,omitempty"`
	EmailReceivedNotNil bool        `json:"emailReceivedNotNil,omitempty"`

	// "email_accepted" field predicates.
	EmailAccepted       *time.Time  `json:"emailAccepted,omitempty"`
	EmailAcceptedNEQ    *time.Time  `json:"emailAcceptedNEQ,omitempty"`
	EmailAcceptedIn     []time.Time `json:"emailAcceptedIn,omitempty"`
	EmailAcceptedNotIn  []time.Time `json:"emailAcceptedNotIn,omitempty"`
	EmailAcceptedGT     *time.Time  `json:"emailAcceptedGT,omitempty"`
	EmailAcceptedGTE    *time.Time  `json:"emailAcceptedGTE,omitempty"`
	EmailAcceptedLT     *time.Time  `json:"emailAcceptedLT,omitempty"`
	EmailAcceptedLTE    *time.Time  `json:"emailAcceptedLTE,omitempty"`
	EmailAcceptedIsNil  bool        `json:"emailAcceptedIsNil,omitempty"`
	EmailAcceptedNotNil bool        `json:"emailAcceptedNotNil,omitempty"`

	// "email_confirmation_label" field predicates.
	EmailConfirmationLabel       *time.Time  `json:"emailConfirmationLabel,omitempty"`
	EmailConfirmationLabelNEQ    *time.Time  `json:"emailConfirmationLabelNEQ,omitempty"`
	EmailConfirmationLabelIn     []time.Time `json:"emailConfirmationLabelIn,omitempty"`
	EmailConfirmationLabelNotIn  []time.Time `json:"emailConfirmationLabelNotIn,omitempty"`
	EmailConfirmationLabelGT     *time.Time  `json:"emailConfirmationLabelGT,omitempty"`
	EmailConfirmationLabelGTE    *time.Time  `json:"emailConfirmationLabelGTE,omitempty"`
	EmailConfirmationLabelLT     *time.Time  `json:"emailConfirmationLabelLT,omitempty"`
	EmailConfirmationLabelLTE    *time.Time  `json:"emailConfirmationLabelLTE,omitempty"`
	EmailConfirmationLabelIsNil  bool        `json:"emailConfirmationLabelIsNil,omitempty"`
	EmailConfirmationLabelNotNil bool        `json:"emailConfirmationLabelNotNil,omitempty"`

	// "email_confirmation_qr_code" field predicates.
	EmailConfirmationQrCode       *time.Time  `json:"emailConfirmationQrCode,omitempty"`
	EmailConfirmationQrCodeNEQ    *time.Time  `json:"emailConfirmationQrCodeNEQ,omitempty"`
	EmailConfirmationQrCodeIn     []time.Time `json:"emailConfirmationQrCodeIn,omitempty"`
	EmailConfirmationQrCodeNotIn  []time.Time `json:"emailConfirmationQrCodeNotIn,omitempty"`
	EmailConfirmationQrCodeGT     *time.Time  `json:"emailConfirmationQrCodeGT,omitempty"`
	EmailConfirmationQrCodeGTE    *time.Time  `json:"emailConfirmationQrCodeGTE,omitempty"`
	EmailConfirmationQrCodeLT     *time.Time  `json:"emailConfirmationQrCodeLT,omitempty"`
	EmailConfirmationQrCodeLTE    *time.Time  `json:"emailConfirmationQrCodeLTE,omitempty"`
	EmailConfirmationQrCodeIsNil  bool        `json:"emailConfirmationQrCodeIsNil,omitempty"`
	EmailConfirmationQrCodeNotNil bool        `json:"emailConfirmationQrCodeNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "recipient" edge predicates.
	HasRecipient     *bool                `json:"hasRecipient,omitempty"`
	HasRecipientWith []*AddressWhereInput `json:"hasRecipientWith,omitempty"`

	// "sender" edge predicates.
	HasSender     *bool                `json:"hasSender,omitempty"`
	HasSenderWith []*AddressWhereInput `json:"hasSenderWith,omitempty"`

	// "order" edge predicates.
	HasOrder     *bool              `json:"hasOrder,omitempty"`
	HasOrderWith []*OrderWhereInput `json:"hasOrderWith,omitempty"`

	// "delivery_option" edge predicates.
	HasDeliveryOption     *bool                       `json:"hasDeliveryOption,omitempty"`
	HasDeliveryOptionWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionWith,omitempty"`

	// "return_portal" edge predicates.
	HasReturnPortal     *bool                     `json:"hasReturnPortal,omitempty"`
	HasReturnPortalWith []*ReturnPortalWhereInput `json:"hasReturnPortalWith,omitempty"`

	// "packaging" edge predicates.
	HasPackaging     *bool                  `json:"hasPackaging,omitempty"`
	HasPackagingWith []*PackagingWhereInput `json:"hasPackagingWith,omitempty"`

	// "return_order_line" edge predicates.
	HasReturnOrderLine     *bool                        `json:"hasReturnOrderLine,omitempty"`
	HasReturnOrderLineWith []*ReturnOrderLineWhereInput `json:"hasReturnOrderLineWith,omitempty"`

	// "return_colli_history" edge predicates.
	HasReturnColliHistory     *bool                           `json:"hasReturnColliHistory,omitempty"`
	HasReturnColliHistoryWith []*ReturnColliHistoryWhereInput `json:"hasReturnColliHistoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReturnColliWhereInput) AddPredicates(predicates ...predicate.ReturnColli) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReturnColliWhereInput filter on the ReturnColliQuery builder.
func (i *ReturnColliWhereInput) Filter(q *ReturnColliQuery) (*ReturnColliQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReturnColliWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReturnColliWhereInput is returned in case the ReturnColliWhereInput is empty.
var ErrEmptyReturnColliWhereInput = errors.New("ent: empty predicate ReturnColliWhereInput")

// P returns a predicate for filtering returncollis.
// An error is returned if the input is empty or invalid.
func (i *ReturnColliWhereInput) P() (predicate.ReturnColli, error) {
	var predicates []predicate.ReturnColli
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, returncolli.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReturnColli, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, returncolli.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReturnColli, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, returncolli.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, returncolli.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, returncolli.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, returncolli.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, returncolli.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, returncolli.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, returncolli.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, returncolli.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, returncolli.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, returncolli.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, returncolli.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, returncolli.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, returncolli.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, returncolli.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, returncolli.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, returncolli.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, returncolli.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, returncolli.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, returncolli.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, returncolli.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, returncolli.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, returncolli.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ExpectedAt != nil {
		predicates = append(predicates, returncolli.ExpectedAtEQ(*i.ExpectedAt))
	}
	if i.ExpectedAtNEQ != nil {
		predicates = append(predicates, returncolli.ExpectedAtNEQ(*i.ExpectedAtNEQ))
	}
	if len(i.ExpectedAtIn) > 0 {
		predicates = append(predicates, returncolli.ExpectedAtIn(i.ExpectedAtIn...))
	}
	if len(i.ExpectedAtNotIn) > 0 {
		predicates = append(predicates, returncolli.ExpectedAtNotIn(i.ExpectedAtNotIn...))
	}
	if i.ExpectedAtGT != nil {
		predicates = append(predicates, returncolli.ExpectedAtGT(*i.ExpectedAtGT))
	}
	if i.ExpectedAtGTE != nil {
		predicates = append(predicates, returncolli.ExpectedAtGTE(*i.ExpectedAtGTE))
	}
	if i.ExpectedAtLT != nil {
		predicates = append(predicates, returncolli.ExpectedAtLT(*i.ExpectedAtLT))
	}
	if i.ExpectedAtLTE != nil {
		predicates = append(predicates, returncolli.ExpectedAtLTE(*i.ExpectedAtLTE))
	}
	if i.ExpectedAtIsNil {
		predicates = append(predicates, returncolli.ExpectedAtIsNil())
	}
	if i.ExpectedAtNotNil {
		predicates = append(predicates, returncolli.ExpectedAtNotNil())
	}
	if i.LabelPdf != nil {
		predicates = append(predicates, returncolli.LabelPdfEQ(*i.LabelPdf))
	}
	if i.LabelPdfNEQ != nil {
		predicates = append(predicates, returncolli.LabelPdfNEQ(*i.LabelPdfNEQ))
	}
	if len(i.LabelPdfIn) > 0 {
		predicates = append(predicates, returncolli.LabelPdfIn(i.LabelPdfIn...))
	}
	if len(i.LabelPdfNotIn) > 0 {
		predicates = append(predicates, returncolli.LabelPdfNotIn(i.LabelPdfNotIn...))
	}
	if i.LabelPdfGT != nil {
		predicates = append(predicates, returncolli.LabelPdfGT(*i.LabelPdfGT))
	}
	if i.LabelPdfGTE != nil {
		predicates = append(predicates, returncolli.LabelPdfGTE(*i.LabelPdfGTE))
	}
	if i.LabelPdfLT != nil {
		predicates = append(predicates, returncolli.LabelPdfLT(*i.LabelPdfLT))
	}
	if i.LabelPdfLTE != nil {
		predicates = append(predicates, returncolli.LabelPdfLTE(*i.LabelPdfLTE))
	}
	if i.LabelPdfContains != nil {
		predicates = append(predicates, returncolli.LabelPdfContains(*i.LabelPdfContains))
	}
	if i.LabelPdfHasPrefix != nil {
		predicates = append(predicates, returncolli.LabelPdfHasPrefix(*i.LabelPdfHasPrefix))
	}
	if i.LabelPdfHasSuffix != nil {
		predicates = append(predicates, returncolli.LabelPdfHasSuffix(*i.LabelPdfHasSuffix))
	}
	if i.LabelPdfIsNil {
		predicates = append(predicates, returncolli.LabelPdfIsNil())
	}
	if i.LabelPdfNotNil {
		predicates = append(predicates, returncolli.LabelPdfNotNil())
	}
	if i.LabelPdfEqualFold != nil {
		predicates = append(predicates, returncolli.LabelPdfEqualFold(*i.LabelPdfEqualFold))
	}
	if i.LabelPdfContainsFold != nil {
		predicates = append(predicates, returncolli.LabelPdfContainsFold(*i.LabelPdfContainsFold))
	}
	if i.LabelPng != nil {
		predicates = append(predicates, returncolli.LabelPngEQ(*i.LabelPng))
	}
	if i.LabelPngNEQ != nil {
		predicates = append(predicates, returncolli.LabelPngNEQ(*i.LabelPngNEQ))
	}
	if len(i.LabelPngIn) > 0 {
		predicates = append(predicates, returncolli.LabelPngIn(i.LabelPngIn...))
	}
	if len(i.LabelPngNotIn) > 0 {
		predicates = append(predicates, returncolli.LabelPngNotIn(i.LabelPngNotIn...))
	}
	if i.LabelPngGT != nil {
		predicates = append(predicates, returncolli.LabelPngGT(*i.LabelPngGT))
	}
	if i.LabelPngGTE != nil {
		predicates = append(predicates, returncolli.LabelPngGTE(*i.LabelPngGTE))
	}
	if i.LabelPngLT != nil {
		predicates = append(predicates, returncolli.LabelPngLT(*i.LabelPngLT))
	}
	if i.LabelPngLTE != nil {
		predicates = append(predicates, returncolli.LabelPngLTE(*i.LabelPngLTE))
	}
	if i.LabelPngContains != nil {
		predicates = append(predicates, returncolli.LabelPngContains(*i.LabelPngContains))
	}
	if i.LabelPngHasPrefix != nil {
		predicates = append(predicates, returncolli.LabelPngHasPrefix(*i.LabelPngHasPrefix))
	}
	if i.LabelPngHasSuffix != nil {
		predicates = append(predicates, returncolli.LabelPngHasSuffix(*i.LabelPngHasSuffix))
	}
	if i.LabelPngIsNil {
		predicates = append(predicates, returncolli.LabelPngIsNil())
	}
	if i.LabelPngNotNil {
		predicates = append(predicates, returncolli.LabelPngNotNil())
	}
	if i.LabelPngEqualFold != nil {
		predicates = append(predicates, returncolli.LabelPngEqualFold(*i.LabelPngEqualFold))
	}
	if i.LabelPngContainsFold != nil {
		predicates = append(predicates, returncolli.LabelPngContainsFold(*i.LabelPngContainsFold))
	}
	if i.QrCodePng != nil {
		predicates = append(predicates, returncolli.QrCodePngEQ(*i.QrCodePng))
	}
	if i.QrCodePngNEQ != nil {
		predicates = append(predicates, returncolli.QrCodePngNEQ(*i.QrCodePngNEQ))
	}
	if len(i.QrCodePngIn) > 0 {
		predicates = append(predicates, returncolli.QrCodePngIn(i.QrCodePngIn...))
	}
	if len(i.QrCodePngNotIn) > 0 {
		predicates = append(predicates, returncolli.QrCodePngNotIn(i.QrCodePngNotIn...))
	}
	if i.QrCodePngGT != nil {
		predicates = append(predicates, returncolli.QrCodePngGT(*i.QrCodePngGT))
	}
	if i.QrCodePngGTE != nil {
		predicates = append(predicates, returncolli.QrCodePngGTE(*i.QrCodePngGTE))
	}
	if i.QrCodePngLT != nil {
		predicates = append(predicates, returncolli.QrCodePngLT(*i.QrCodePngLT))
	}
	if i.QrCodePngLTE != nil {
		predicates = append(predicates, returncolli.QrCodePngLTE(*i.QrCodePngLTE))
	}
	if i.QrCodePngContains != nil {
		predicates = append(predicates, returncolli.QrCodePngContains(*i.QrCodePngContains))
	}
	if i.QrCodePngHasPrefix != nil {
		predicates = append(predicates, returncolli.QrCodePngHasPrefix(*i.QrCodePngHasPrefix))
	}
	if i.QrCodePngHasSuffix != nil {
		predicates = append(predicates, returncolli.QrCodePngHasSuffix(*i.QrCodePngHasSuffix))
	}
	if i.QrCodePngIsNil {
		predicates = append(predicates, returncolli.QrCodePngIsNil())
	}
	if i.QrCodePngNotNil {
		predicates = append(predicates, returncolli.QrCodePngNotNil())
	}
	if i.QrCodePngEqualFold != nil {
		predicates = append(predicates, returncolli.QrCodePngEqualFold(*i.QrCodePngEqualFold))
	}
	if i.QrCodePngContainsFold != nil {
		predicates = append(predicates, returncolli.QrCodePngContainsFold(*i.QrCodePngContainsFold))
	}
	if i.Comment != nil {
		predicates = append(predicates, returncolli.CommentEQ(*i.Comment))
	}
	if i.CommentNEQ != nil {
		predicates = append(predicates, returncolli.CommentNEQ(*i.CommentNEQ))
	}
	if len(i.CommentIn) > 0 {
		predicates = append(predicates, returncolli.CommentIn(i.CommentIn...))
	}
	if len(i.CommentNotIn) > 0 {
		predicates = append(predicates, returncolli.CommentNotIn(i.CommentNotIn...))
	}
	if i.CommentGT != nil {
		predicates = append(predicates, returncolli.CommentGT(*i.CommentGT))
	}
	if i.CommentGTE != nil {
		predicates = append(predicates, returncolli.CommentGTE(*i.CommentGTE))
	}
	if i.CommentLT != nil {
		predicates = append(predicates, returncolli.CommentLT(*i.CommentLT))
	}
	if i.CommentLTE != nil {
		predicates = append(predicates, returncolli.CommentLTE(*i.CommentLTE))
	}
	if i.CommentContains != nil {
		predicates = append(predicates, returncolli.CommentContains(*i.CommentContains))
	}
	if i.CommentHasPrefix != nil {
		predicates = append(predicates, returncolli.CommentHasPrefix(*i.CommentHasPrefix))
	}
	if i.CommentHasSuffix != nil {
		predicates = append(predicates, returncolli.CommentHasSuffix(*i.CommentHasSuffix))
	}
	if i.CommentIsNil {
		predicates = append(predicates, returncolli.CommentIsNil())
	}
	if i.CommentNotNil {
		predicates = append(predicates, returncolli.CommentNotNil())
	}
	if i.CommentEqualFold != nil {
		predicates = append(predicates, returncolli.CommentEqualFold(*i.CommentEqualFold))
	}
	if i.CommentContainsFold != nil {
		predicates = append(predicates, returncolli.CommentContainsFold(*i.CommentContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, returncolli.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, returncolli.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, returncolli.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, returncolli.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, returncolli.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, returncolli.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, returncolli.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, returncolli.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, returncolli.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, returncolli.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, returncolli.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, returncolli.StatusNotIn(i.StatusNotIn...))
	}
	if i.EmailReceived != nil {
		predicates = append(predicates, returncolli.EmailReceivedEQ(*i.EmailReceived))
	}
	if i.EmailReceivedNEQ != nil {
		predicates = append(predicates, returncolli.EmailReceivedNEQ(*i.EmailReceivedNEQ))
	}
	if len(i.EmailReceivedIn) > 0 {
		predicates = append(predicates, returncolli.EmailReceivedIn(i.EmailReceivedIn...))
	}
	if len(i.EmailReceivedNotIn) > 0 {
		predicates = append(predicates, returncolli.EmailReceivedNotIn(i.EmailReceivedNotIn...))
	}
	if i.EmailReceivedGT != nil {
		predicates = append(predicates, returncolli.EmailReceivedGT(*i.EmailReceivedGT))
	}
	if i.EmailReceivedGTE != nil {
		predicates = append(predicates, returncolli.EmailReceivedGTE(*i.EmailReceivedGTE))
	}
	if i.EmailReceivedLT != nil {
		predicates = append(predicates, returncolli.EmailReceivedLT(*i.EmailReceivedLT))
	}
	if i.EmailReceivedLTE != nil {
		predicates = append(predicates, returncolli.EmailReceivedLTE(*i.EmailReceivedLTE))
	}
	if i.EmailReceivedIsNil {
		predicates = append(predicates, returncolli.EmailReceivedIsNil())
	}
	if i.EmailReceivedNotNil {
		predicates = append(predicates, returncolli.EmailReceivedNotNil())
	}
	if i.EmailAccepted != nil {
		predicates = append(predicates, returncolli.EmailAcceptedEQ(*i.EmailAccepted))
	}
	if i.EmailAcceptedNEQ != nil {
		predicates = append(predicates, returncolli.EmailAcceptedNEQ(*i.EmailAcceptedNEQ))
	}
	if len(i.EmailAcceptedIn) > 0 {
		predicates = append(predicates, returncolli.EmailAcceptedIn(i.EmailAcceptedIn...))
	}
	if len(i.EmailAcceptedNotIn) > 0 {
		predicates = append(predicates, returncolli.EmailAcceptedNotIn(i.EmailAcceptedNotIn...))
	}
	if i.EmailAcceptedGT != nil {
		predicates = append(predicates, returncolli.EmailAcceptedGT(*i.EmailAcceptedGT))
	}
	if i.EmailAcceptedGTE != nil {
		predicates = append(predicates, returncolli.EmailAcceptedGTE(*i.EmailAcceptedGTE))
	}
	if i.EmailAcceptedLT != nil {
		predicates = append(predicates, returncolli.EmailAcceptedLT(*i.EmailAcceptedLT))
	}
	if i.EmailAcceptedLTE != nil {
		predicates = append(predicates, returncolli.EmailAcceptedLTE(*i.EmailAcceptedLTE))
	}
	if i.EmailAcceptedIsNil {
		predicates = append(predicates, returncolli.EmailAcceptedIsNil())
	}
	if i.EmailAcceptedNotNil {
		predicates = append(predicates, returncolli.EmailAcceptedNotNil())
	}
	if i.EmailConfirmationLabel != nil {
		predicates = append(predicates, returncolli.EmailConfirmationLabelEQ(*i.EmailConfirmationLabel))
	}
	if i.EmailConfirmationLabelNEQ != nil {
		predicates = append(predicates, returncolli.EmailConfirmationLabelNEQ(*i.EmailConfirmationLabelNEQ))
	}
	if len(i.EmailConfirmationLabelIn) > 0 {
		predicates = append(predicates, returncolli.EmailConfirmationLabelIn(i.EmailConfirmationLabelIn...))
	}
	if len(i.EmailConfirmationLabelNotIn) > 0 {
		predicates = append(predicates, returncolli.EmailConfirmationLabelNotIn(i.EmailConfirmationLabelNotIn...))
	}
	if i.EmailConfirmationLabelGT != nil {
		predicates = append(predicates, returncolli.EmailConfirmationLabelGT(*i.EmailConfirmationLabelGT))
	}
	if i.EmailConfirmationLabelGTE != nil {
		predicates = append(predicates, returncolli.EmailConfirmationLabelGTE(*i.EmailConfirmationLabelGTE))
	}
	if i.EmailConfirmationLabelLT != nil {
		predicates = append(predicates, returncolli.EmailConfirmationLabelLT(*i.EmailConfirmationLabelLT))
	}
	if i.EmailConfirmationLabelLTE != nil {
		predicates = append(predicates, returncolli.EmailConfirmationLabelLTE(*i.EmailConfirmationLabelLTE))
	}
	if i.EmailConfirmationLabelIsNil {
		predicates = append(predicates, returncolli.EmailConfirmationLabelIsNil())
	}
	if i.EmailConfirmationLabelNotNil {
		predicates = append(predicates, returncolli.EmailConfirmationLabelNotNil())
	}
	if i.EmailConfirmationQrCode != nil {
		predicates = append(predicates, returncolli.EmailConfirmationQrCodeEQ(*i.EmailConfirmationQrCode))
	}
	if i.EmailConfirmationQrCodeNEQ != nil {
		predicates = append(predicates, returncolli.EmailConfirmationQrCodeNEQ(*i.EmailConfirmationQrCodeNEQ))
	}
	if len(i.EmailConfirmationQrCodeIn) > 0 {
		predicates = append(predicates, returncolli.EmailConfirmationQrCodeIn(i.EmailConfirmationQrCodeIn...))
	}
	if len(i.EmailConfirmationQrCodeNotIn) > 0 {
		predicates = append(predicates, returncolli.EmailConfirmationQrCodeNotIn(i.EmailConfirmationQrCodeNotIn...))
	}
	if i.EmailConfirmationQrCodeGT != nil {
		predicates = append(predicates, returncolli.EmailConfirmationQrCodeGT(*i.EmailConfirmationQrCodeGT))
	}
	if i.EmailConfirmationQrCodeGTE != nil {
		predicates = append(predicates, returncolli.EmailConfirmationQrCodeGTE(*i.EmailConfirmationQrCodeGTE))
	}
	if i.EmailConfirmationQrCodeLT != nil {
		predicates = append(predicates, returncolli.EmailConfirmationQrCodeLT(*i.EmailConfirmationQrCodeLT))
	}
	if i.EmailConfirmationQrCodeLTE != nil {
		predicates = append(predicates, returncolli.EmailConfirmationQrCodeLTE(*i.EmailConfirmationQrCodeLTE))
	}
	if i.EmailConfirmationQrCodeIsNil {
		predicates = append(predicates, returncolli.EmailConfirmationQrCodeIsNil())
	}
	if i.EmailConfirmationQrCodeNotNil {
		predicates = append(predicates, returncolli.EmailConfirmationQrCodeNotNil())
	}

	if i.HasTenant != nil {
		p := returncolli.HasTenant()
		if !*i.HasTenant {
			p = returncolli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncolli.HasTenantWith(with...))
	}
	if i.HasRecipient != nil {
		p := returncolli.HasRecipient()
		if !*i.HasRecipient {
			p = returncolli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasRecipientWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasRecipientWith))
		for _, w := range i.HasRecipientWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasRecipientWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncolli.HasRecipientWith(with...))
	}
	if i.HasSender != nil {
		p := returncolli.HasSender()
		if !*i.HasSender {
			p = returncolli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSenderWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasSenderWith))
		for _, w := range i.HasSenderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSenderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncolli.HasSenderWith(with...))
	}
	if i.HasOrder != nil {
		p := returncolli.HasOrder()
		if !*i.HasOrder {
			p = returncolli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrderWith) > 0 {
		with := make([]predicate.Order, 0, len(i.HasOrderWith))
		for _, w := range i.HasOrderWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrderWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncolli.HasOrderWith(with...))
	}
	if i.HasDeliveryOption != nil {
		p := returncolli.HasDeliveryOption()
		if !*i.HasDeliveryOption {
			p = returncolli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionWith))
		for _, w := range i.HasDeliveryOptionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncolli.HasDeliveryOptionWith(with...))
	}
	if i.HasReturnPortal != nil {
		p := returncolli.HasReturnPortal()
		if !*i.HasReturnPortal {
			p = returncolli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalWith) > 0 {
		with := make([]predicate.ReturnPortal, 0, len(i.HasReturnPortalWith))
		for _, w := range i.HasReturnPortalWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncolli.HasReturnPortalWith(with...))
	}
	if i.HasPackaging != nil {
		p := returncolli.HasPackaging()
		if !*i.HasPackaging {
			p = returncolli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingWith) > 0 {
		with := make([]predicate.Packaging, 0, len(i.HasPackagingWith))
		for _, w := range i.HasPackagingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncolli.HasPackagingWith(with...))
	}
	if i.HasReturnOrderLine != nil {
		p := returncolli.HasReturnOrderLine()
		if !*i.HasReturnOrderLine {
			p = returncolli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnOrderLineWith) > 0 {
		with := make([]predicate.ReturnOrderLine, 0, len(i.HasReturnOrderLineWith))
		for _, w := range i.HasReturnOrderLineWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnOrderLineWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncolli.HasReturnOrderLineWith(with...))
	}
	if i.HasReturnColliHistory != nil {
		p := returncolli.HasReturnColliHistory()
		if !*i.HasReturnColliHistory {
			p = returncolli.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnColliHistoryWith) > 0 {
		with := make([]predicate.ReturnColliHistory, 0, len(i.HasReturnColliHistoryWith))
		for _, w := range i.HasReturnColliHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnColliHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncolli.HasReturnColliHistoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReturnColliWhereInput
	case 1:
		return predicates[0], nil
	default:
		return returncolli.And(predicates...), nil
	}
}

// ReturnColliHistoryWhereInput represents a where input for filtering ReturnColliHistory queries.
type ReturnColliHistoryWhereInput struct {
	Predicates []predicate.ReturnColliHistory  `json:"-"`
	Not        *ReturnColliHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ReturnColliHistoryWhereInput `json:"or,omitempty"`
	And        []*ReturnColliHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "type" field predicates.
	Type      *returncollihistory.Type  `json:"type,omitempty"`
	TypeNEQ   *returncollihistory.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []returncollihistory.Type `json:"typeIn,omitempty"`
	TypeNotIn []returncollihistory.Type `json:"typeNotIn,omitempty"`

	// "change_history" edge predicates.
	HasChangeHistory     *bool                      `json:"hasChangeHistory,omitempty"`
	HasChangeHistoryWith []*ChangeHistoryWhereInput `json:"hasChangeHistoryWith,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "return_colli" edge predicates.
	HasReturnColli     *bool                    `json:"hasReturnColli,omitempty"`
	HasReturnColliWith []*ReturnColliWhereInput `json:"hasReturnColliWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReturnColliHistoryWhereInput) AddPredicates(predicates ...predicate.ReturnColliHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReturnColliHistoryWhereInput filter on the ReturnColliHistoryQuery builder.
func (i *ReturnColliHistoryWhereInput) Filter(q *ReturnColliHistoryQuery) (*ReturnColliHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReturnColliHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReturnColliHistoryWhereInput is returned in case the ReturnColliHistoryWhereInput is empty.
var ErrEmptyReturnColliHistoryWhereInput = errors.New("ent: empty predicate ReturnColliHistoryWhereInput")

// P returns a predicate for filtering returncollihistories.
// An error is returned if the input is empty or invalid.
func (i *ReturnColliHistoryWhereInput) P() (predicate.ReturnColliHistory, error) {
	var predicates []predicate.ReturnColliHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, returncollihistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReturnColliHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, returncollihistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReturnColliHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, returncollihistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, returncollihistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, returncollihistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, returncollihistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, returncollihistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, returncollihistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, returncollihistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, returncollihistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, returncollihistory.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, returncollihistory.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, returncollihistory.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, returncollihistory.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, returncollihistory.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, returncollihistory.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, returncollihistory.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, returncollihistory.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, returncollihistory.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, returncollihistory.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, returncollihistory.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, returncollihistory.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, returncollihistory.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, returncollihistory.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, returncollihistory.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, returncollihistory.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, returncollihistory.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, returncollihistory.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, returncollihistory.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, returncollihistory.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, returncollihistory.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, returncollihistory.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, returncollihistory.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, returncollihistory.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, returncollihistory.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, returncollihistory.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, returncollihistory.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, returncollihistory.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, returncollihistory.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, returncollihistory.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, returncollihistory.TypeNotIn(i.TypeNotIn...))
	}

	if i.HasChangeHistory != nil {
		p := returncollihistory.HasChangeHistory()
		if !*i.HasChangeHistory {
			p = returncollihistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChangeHistoryWith) > 0 {
		with := make([]predicate.ChangeHistory, 0, len(i.HasChangeHistoryWith))
		for _, w := range i.HasChangeHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChangeHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncollihistory.HasChangeHistoryWith(with...))
	}
	if i.HasTenant != nil {
		p := returncollihistory.HasTenant()
		if !*i.HasTenant {
			p = returncollihistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncollihistory.HasTenantWith(with...))
	}
	if i.HasReturnColli != nil {
		p := returncollihistory.HasReturnColli()
		if !*i.HasReturnColli {
			p = returncollihistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnColliWith) > 0 {
		with := make([]predicate.ReturnColli, 0, len(i.HasReturnColliWith))
		for _, w := range i.HasReturnColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returncollihistory.HasReturnColliWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReturnColliHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return returncollihistory.And(predicates...), nil
	}
}

// ReturnOrderLineWhereInput represents a where input for filtering ReturnOrderLine queries.
type ReturnOrderLineWhereInput struct {
	Predicates []predicate.ReturnOrderLine  `json:"-"`
	Not        *ReturnOrderLineWhereInput   `json:"not,omitempty"`
	Or         []*ReturnOrderLineWhereInput `json:"or,omitempty"`
	And        []*ReturnOrderLineWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "units" field predicates.
	Units      *int  `json:"units,omitempty"`
	UnitsNEQ   *int  `json:"unitsNEQ,omitempty"`
	UnitsIn    []int `json:"unitsIn,omitempty"`
	UnitsNotIn []int `json:"unitsNotIn,omitempty"`
	UnitsGT    *int  `json:"unitsGT,omitempty"`
	UnitsGTE   *int  `json:"unitsGTE,omitempty"`
	UnitsLT    *int  `json:"unitsLT,omitempty"`
	UnitsLTE   *int  `json:"unitsLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "return_colli" edge predicates.
	HasReturnColli     *bool                    `json:"hasReturnColli,omitempty"`
	HasReturnColliWith []*ReturnColliWhereInput `json:"hasReturnColliWith,omitempty"`

	// "order_line" edge predicates.
	HasOrderLine     *bool                  `json:"hasOrderLine,omitempty"`
	HasOrderLineWith []*OrderLineWhereInput `json:"hasOrderLineWith,omitempty"`

	// "return_portal_claim" edge predicates.
	HasReturnPortalClaim     *bool                          `json:"hasReturnPortalClaim,omitempty"`
	HasReturnPortalClaimWith []*ReturnPortalClaimWhereInput `json:"hasReturnPortalClaimWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReturnOrderLineWhereInput) AddPredicates(predicates ...predicate.ReturnOrderLine) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReturnOrderLineWhereInput filter on the ReturnOrderLineQuery builder.
func (i *ReturnOrderLineWhereInput) Filter(q *ReturnOrderLineQuery) (*ReturnOrderLineQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReturnOrderLineWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReturnOrderLineWhereInput is returned in case the ReturnOrderLineWhereInput is empty.
var ErrEmptyReturnOrderLineWhereInput = errors.New("ent: empty predicate ReturnOrderLineWhereInput")

// P returns a predicate for filtering returnorderlines.
// An error is returned if the input is empty or invalid.
func (i *ReturnOrderLineWhereInput) P() (predicate.ReturnOrderLine, error) {
	var predicates []predicate.ReturnOrderLine
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, returnorderline.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReturnOrderLine, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, returnorderline.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReturnOrderLine, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, returnorderline.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, returnorderline.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, returnorderline.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, returnorderline.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, returnorderline.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, returnorderline.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, returnorderline.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, returnorderline.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, returnorderline.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, returnorderline.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, returnorderline.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, returnorderline.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, returnorderline.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, returnorderline.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, returnorderline.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, returnorderline.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, returnorderline.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, returnorderline.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, returnorderline.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, returnorderline.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, returnorderline.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, returnorderline.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Units != nil {
		predicates = append(predicates, returnorderline.UnitsEQ(*i.Units))
	}
	if i.UnitsNEQ != nil {
		predicates = append(predicates, returnorderline.UnitsNEQ(*i.UnitsNEQ))
	}
	if len(i.UnitsIn) > 0 {
		predicates = append(predicates, returnorderline.UnitsIn(i.UnitsIn...))
	}
	if len(i.UnitsNotIn) > 0 {
		predicates = append(predicates, returnorderline.UnitsNotIn(i.UnitsNotIn...))
	}
	if i.UnitsGT != nil {
		predicates = append(predicates, returnorderline.UnitsGT(*i.UnitsGT))
	}
	if i.UnitsGTE != nil {
		predicates = append(predicates, returnorderline.UnitsGTE(*i.UnitsGTE))
	}
	if i.UnitsLT != nil {
		predicates = append(predicates, returnorderline.UnitsLT(*i.UnitsLT))
	}
	if i.UnitsLTE != nil {
		predicates = append(predicates, returnorderline.UnitsLTE(*i.UnitsLTE))
	}

	if i.HasTenant != nil {
		p := returnorderline.HasTenant()
		if !*i.HasTenant {
			p = returnorderline.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnorderline.HasTenantWith(with...))
	}
	if i.HasReturnColli != nil {
		p := returnorderline.HasReturnColli()
		if !*i.HasReturnColli {
			p = returnorderline.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnColliWith) > 0 {
		with := make([]predicate.ReturnColli, 0, len(i.HasReturnColliWith))
		for _, w := range i.HasReturnColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnorderline.HasReturnColliWith(with...))
	}
	if i.HasOrderLine != nil {
		p := returnorderline.HasOrderLine()
		if !*i.HasOrderLine {
			p = returnorderline.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOrderLineWith) > 0 {
		with := make([]predicate.OrderLine, 0, len(i.HasOrderLineWith))
		for _, w := range i.HasOrderLineWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOrderLineWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnorderline.HasOrderLineWith(with...))
	}
	if i.HasReturnPortalClaim != nil {
		p := returnorderline.HasReturnPortalClaim()
		if !*i.HasReturnPortalClaim {
			p = returnorderline.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalClaimWith) > 0 {
		with := make([]predicate.ReturnPortalClaim, 0, len(i.HasReturnPortalClaimWith))
		for _, w := range i.HasReturnPortalClaimWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalClaimWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnorderline.HasReturnPortalClaimWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReturnOrderLineWhereInput
	case 1:
		return predicates[0], nil
	default:
		return returnorderline.And(predicates...), nil
	}
}

// ReturnPortalWhereInput represents a where input for filtering ReturnPortal queries.
type ReturnPortalWhereInput struct {
	Predicates []predicate.ReturnPortal  `json:"-"`
	Not        *ReturnPortalWhereInput   `json:"not,omitempty"`
	Or         []*ReturnPortalWhereInput `json:"or,omitempty"`
	And        []*ReturnPortalWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "return_open_hours" field predicates.
	ReturnOpenHours      *int  `json:"returnOpenHours,omitempty"`
	ReturnOpenHoursNEQ   *int  `json:"returnOpenHoursNEQ,omitempty"`
	ReturnOpenHoursIn    []int `json:"returnOpenHoursIn,omitempty"`
	ReturnOpenHoursNotIn []int `json:"returnOpenHoursNotIn,omitempty"`
	ReturnOpenHoursGT    *int  `json:"returnOpenHoursGT,omitempty"`
	ReturnOpenHoursGTE   *int  `json:"returnOpenHoursGTE,omitempty"`
	ReturnOpenHoursLT    *int  `json:"returnOpenHoursLT,omitempty"`
	ReturnOpenHoursLTE   *int  `json:"returnOpenHoursLTE,omitempty"`

	// "automatically_accept" field predicates.
	AutomaticallyAccept    *bool `json:"automaticallyAccept,omitempty"`
	AutomaticallyAcceptNEQ *bool `json:"automaticallyAcceptNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "return_portal_claim" edge predicates.
	HasReturnPortalClaim     *bool                          `json:"hasReturnPortalClaim,omitempty"`
	HasReturnPortalClaimWith []*ReturnPortalClaimWhereInput `json:"hasReturnPortalClaimWith,omitempty"`

	// "return_location" edge predicates.
	HasReturnLocation     *bool                 `json:"hasReturnLocation,omitempty"`
	HasReturnLocationWith []*LocationWhereInput `json:"hasReturnLocationWith,omitempty"`

	// "delivery_options" edge predicates.
	HasDeliveryOptions     *bool                       `json:"hasDeliveryOptions,omitempty"`
	HasDeliveryOptionsWith []*DeliveryOptionWhereInput `json:"hasDeliveryOptionsWith,omitempty"`

	// "connection" edge predicates.
	HasConnection     *bool                   `json:"hasConnection,omitempty"`
	HasConnectionWith []*ConnectionWhereInput `json:"hasConnectionWith,omitempty"`

	// "email_confirmation_label" edge predicates.
	HasEmailConfirmationLabel     *bool                      `json:"hasEmailConfirmationLabel,omitempty"`
	HasEmailConfirmationLabelWith []*EmailTemplateWhereInput `json:"hasEmailConfirmationLabelWith,omitempty"`

	// "email_confirmation_qr_code" edge predicates.
	HasEmailConfirmationQrCode     *bool                      `json:"hasEmailConfirmationQrCode,omitempty"`
	HasEmailConfirmationQrCodeWith []*EmailTemplateWhereInput `json:"hasEmailConfirmationQrCodeWith,omitempty"`

	// "email_received" edge predicates.
	HasEmailReceived     *bool                      `json:"hasEmailReceived,omitempty"`
	HasEmailReceivedWith []*EmailTemplateWhereInput `json:"hasEmailReceivedWith,omitempty"`

	// "email_accepted" edge predicates.
	HasEmailAccepted     *bool                      `json:"hasEmailAccepted,omitempty"`
	HasEmailAcceptedWith []*EmailTemplateWhereInput `json:"hasEmailAcceptedWith,omitempty"`

	// "return_colli" edge predicates.
	HasReturnColli     *bool                    `json:"hasReturnColli,omitempty"`
	HasReturnColliWith []*ReturnColliWhereInput `json:"hasReturnColliWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReturnPortalWhereInput) AddPredicates(predicates ...predicate.ReturnPortal) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReturnPortalWhereInput filter on the ReturnPortalQuery builder.
func (i *ReturnPortalWhereInput) Filter(q *ReturnPortalQuery) (*ReturnPortalQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReturnPortalWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReturnPortalWhereInput is returned in case the ReturnPortalWhereInput is empty.
var ErrEmptyReturnPortalWhereInput = errors.New("ent: empty predicate ReturnPortalWhereInput")

// P returns a predicate for filtering returnportals.
// An error is returned if the input is empty or invalid.
func (i *ReturnPortalWhereInput) P() (predicate.ReturnPortal, error) {
	var predicates []predicate.ReturnPortal
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, returnportal.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReturnPortal, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, returnportal.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReturnPortal, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, returnportal.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, returnportal.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, returnportal.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, returnportal.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, returnportal.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, returnportal.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, returnportal.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, returnportal.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, returnportal.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, returnportal.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, returnportal.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, returnportal.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, returnportal.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, returnportal.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, returnportal.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, returnportal.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, returnportal.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, returnportal.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, returnportal.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, returnportal.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, returnportal.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, returnportal.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, returnportal.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, returnportal.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, returnportal.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, returnportal.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, returnportal.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, returnportal.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, returnportal.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, returnportal.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, returnportal.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, returnportal.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, returnportal.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, returnportal.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, returnportal.NameContainsFold(*i.NameContainsFold))
	}
	if i.ReturnOpenHours != nil {
		predicates = append(predicates, returnportal.ReturnOpenHoursEQ(*i.ReturnOpenHours))
	}
	if i.ReturnOpenHoursNEQ != nil {
		predicates = append(predicates, returnportal.ReturnOpenHoursNEQ(*i.ReturnOpenHoursNEQ))
	}
	if len(i.ReturnOpenHoursIn) > 0 {
		predicates = append(predicates, returnportal.ReturnOpenHoursIn(i.ReturnOpenHoursIn...))
	}
	if len(i.ReturnOpenHoursNotIn) > 0 {
		predicates = append(predicates, returnportal.ReturnOpenHoursNotIn(i.ReturnOpenHoursNotIn...))
	}
	if i.ReturnOpenHoursGT != nil {
		predicates = append(predicates, returnportal.ReturnOpenHoursGT(*i.ReturnOpenHoursGT))
	}
	if i.ReturnOpenHoursGTE != nil {
		predicates = append(predicates, returnportal.ReturnOpenHoursGTE(*i.ReturnOpenHoursGTE))
	}
	if i.ReturnOpenHoursLT != nil {
		predicates = append(predicates, returnportal.ReturnOpenHoursLT(*i.ReturnOpenHoursLT))
	}
	if i.ReturnOpenHoursLTE != nil {
		predicates = append(predicates, returnportal.ReturnOpenHoursLTE(*i.ReturnOpenHoursLTE))
	}
	if i.AutomaticallyAccept != nil {
		predicates = append(predicates, returnportal.AutomaticallyAcceptEQ(*i.AutomaticallyAccept))
	}
	if i.AutomaticallyAcceptNEQ != nil {
		predicates = append(predicates, returnportal.AutomaticallyAcceptNEQ(*i.AutomaticallyAcceptNEQ))
	}

	if i.HasTenant != nil {
		p := returnportal.HasTenant()
		if !*i.HasTenant {
			p = returnportal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportal.HasTenantWith(with...))
	}
	if i.HasReturnPortalClaim != nil {
		p := returnportal.HasReturnPortalClaim()
		if !*i.HasReturnPortalClaim {
			p = returnportal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalClaimWith) > 0 {
		with := make([]predicate.ReturnPortalClaim, 0, len(i.HasReturnPortalClaimWith))
		for _, w := range i.HasReturnPortalClaimWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalClaimWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportal.HasReturnPortalClaimWith(with...))
	}
	if i.HasReturnLocation != nil {
		p := returnportal.HasReturnLocation()
		if !*i.HasReturnLocation {
			p = returnportal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasReturnLocationWith))
		for _, w := range i.HasReturnLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportal.HasReturnLocationWith(with...))
	}
	if i.HasDeliveryOptions != nil {
		p := returnportal.HasDeliveryOptions()
		if !*i.HasDeliveryOptions {
			p = returnportal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDeliveryOptionsWith) > 0 {
		with := make([]predicate.DeliveryOption, 0, len(i.HasDeliveryOptionsWith))
		for _, w := range i.HasDeliveryOptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDeliveryOptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportal.HasDeliveryOptionsWith(with...))
	}
	if i.HasConnection != nil {
		p := returnportal.HasConnection()
		if !*i.HasConnection {
			p = returnportal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectionWith) > 0 {
		with := make([]predicate.Connection, 0, len(i.HasConnectionWith))
		for _, w := range i.HasConnectionWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectionWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportal.HasConnectionWith(with...))
	}
	if i.HasEmailConfirmationLabel != nil {
		p := returnportal.HasEmailConfirmationLabel()
		if !*i.HasEmailConfirmationLabel {
			p = returnportal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmailConfirmationLabelWith) > 0 {
		with := make([]predicate.EmailTemplate, 0, len(i.HasEmailConfirmationLabelWith))
		for _, w := range i.HasEmailConfirmationLabelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmailConfirmationLabelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportal.HasEmailConfirmationLabelWith(with...))
	}
	if i.HasEmailConfirmationQrCode != nil {
		p := returnportal.HasEmailConfirmationQrCode()
		if !*i.HasEmailConfirmationQrCode {
			p = returnportal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmailConfirmationQrCodeWith) > 0 {
		with := make([]predicate.EmailTemplate, 0, len(i.HasEmailConfirmationQrCodeWith))
		for _, w := range i.HasEmailConfirmationQrCodeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmailConfirmationQrCodeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportal.HasEmailConfirmationQrCodeWith(with...))
	}
	if i.HasEmailReceived != nil {
		p := returnportal.HasEmailReceived()
		if !*i.HasEmailReceived {
			p = returnportal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmailReceivedWith) > 0 {
		with := make([]predicate.EmailTemplate, 0, len(i.HasEmailReceivedWith))
		for _, w := range i.HasEmailReceivedWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmailReceivedWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportal.HasEmailReceivedWith(with...))
	}
	if i.HasEmailAccepted != nil {
		p := returnportal.HasEmailAccepted()
		if !*i.HasEmailAccepted {
			p = returnportal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasEmailAcceptedWith) > 0 {
		with := make([]predicate.EmailTemplate, 0, len(i.HasEmailAcceptedWith))
		for _, w := range i.HasEmailAcceptedWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasEmailAcceptedWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportal.HasEmailAcceptedWith(with...))
	}
	if i.HasReturnColli != nil {
		p := returnportal.HasReturnColli()
		if !*i.HasReturnColli {
			p = returnportal.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnColliWith) > 0 {
		with := make([]predicate.ReturnColli, 0, len(i.HasReturnColliWith))
		for _, w := range i.HasReturnColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportal.HasReturnColliWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReturnPortalWhereInput
	case 1:
		return predicates[0], nil
	default:
		return returnportal.And(predicates...), nil
	}
}

// ReturnPortalClaimWhereInput represents a where input for filtering ReturnPortalClaim queries.
type ReturnPortalClaimWhereInput struct {
	Predicates []predicate.ReturnPortalClaim  `json:"-"`
	Not        *ReturnPortalClaimWhereInput   `json:"not,omitempty"`
	Or         []*ReturnPortalClaimWhereInput `json:"or,omitempty"`
	And        []*ReturnPortalClaimWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "restockable" field predicates.
	Restockable    *bool `json:"restockable,omitempty"`
	RestockableNEQ *bool `json:"restockableNEQ,omitempty"`

	// "archived" field predicates.
	Archived    *bool `json:"archived,omitempty"`
	ArchivedNEQ *bool `json:"archivedNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "return_portal" edge predicates.
	HasReturnPortal     *bool                     `json:"hasReturnPortal,omitempty"`
	HasReturnPortalWith []*ReturnPortalWhereInput `json:"hasReturnPortalWith,omitempty"`

	// "return_location" edge predicates.
	HasReturnLocation     *bool                 `json:"hasReturnLocation,omitempty"`
	HasReturnLocationWith []*LocationWhereInput `json:"hasReturnLocationWith,omitempty"`

	// "return_order_line" edge predicates.
	HasReturnOrderLine     *bool                        `json:"hasReturnOrderLine,omitempty"`
	HasReturnOrderLineWith []*ReturnOrderLineWhereInput `json:"hasReturnOrderLineWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ReturnPortalClaimWhereInput) AddPredicates(predicates ...predicate.ReturnPortalClaim) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ReturnPortalClaimWhereInput filter on the ReturnPortalClaimQuery builder.
func (i *ReturnPortalClaimWhereInput) Filter(q *ReturnPortalClaimQuery) (*ReturnPortalClaimQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyReturnPortalClaimWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyReturnPortalClaimWhereInput is returned in case the ReturnPortalClaimWhereInput is empty.
var ErrEmptyReturnPortalClaimWhereInput = errors.New("ent: empty predicate ReturnPortalClaimWhereInput")

// P returns a predicate for filtering returnportalclaims.
// An error is returned if the input is empty or invalid.
func (i *ReturnPortalClaimWhereInput) P() (predicate.ReturnPortalClaim, error) {
	var predicates []predicate.ReturnPortalClaim
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, returnportalclaim.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ReturnPortalClaim, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, returnportalclaim.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ReturnPortalClaim, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, returnportalclaim.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, returnportalclaim.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, returnportalclaim.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, returnportalclaim.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, returnportalclaim.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, returnportalclaim.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, returnportalclaim.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, returnportalclaim.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, returnportalclaim.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, returnportalclaim.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, returnportalclaim.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, returnportalclaim.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, returnportalclaim.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, returnportalclaim.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, returnportalclaim.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, returnportalclaim.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, returnportalclaim.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, returnportalclaim.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, returnportalclaim.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, returnportalclaim.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, returnportalclaim.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, returnportalclaim.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, returnportalclaim.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, returnportalclaim.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, returnportalclaim.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, returnportalclaim.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, returnportalclaim.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, returnportalclaim.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, returnportalclaim.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, returnportalclaim.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, returnportalclaim.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, returnportalclaim.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, returnportalclaim.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, returnportalclaim.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, returnportalclaim.NameContainsFold(*i.NameContainsFold))
	}
	if i.Description != nil {
		predicates = append(predicates, returnportalclaim.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, returnportalclaim.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, returnportalclaim.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, returnportalclaim.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, returnportalclaim.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, returnportalclaim.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, returnportalclaim.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, returnportalclaim.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, returnportalclaim.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, returnportalclaim.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, returnportalclaim.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, returnportalclaim.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, returnportalclaim.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Restockable != nil {
		predicates = append(predicates, returnportalclaim.RestockableEQ(*i.Restockable))
	}
	if i.RestockableNEQ != nil {
		predicates = append(predicates, returnportalclaim.RestockableNEQ(*i.RestockableNEQ))
	}
	if i.Archived != nil {
		predicates = append(predicates, returnportalclaim.ArchivedEQ(*i.Archived))
	}
	if i.ArchivedNEQ != nil {
		predicates = append(predicates, returnportalclaim.ArchivedNEQ(*i.ArchivedNEQ))
	}

	if i.HasTenant != nil {
		p := returnportalclaim.HasTenant()
		if !*i.HasTenant {
			p = returnportalclaim.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportalclaim.HasTenantWith(with...))
	}
	if i.HasReturnPortal != nil {
		p := returnportalclaim.HasReturnPortal()
		if !*i.HasReturnPortal {
			p = returnportalclaim.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnPortalWith) > 0 {
		with := make([]predicate.ReturnPortal, 0, len(i.HasReturnPortalWith))
		for _, w := range i.HasReturnPortalWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnPortalWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportalclaim.HasReturnPortalWith(with...))
	}
	if i.HasReturnLocation != nil {
		p := returnportalclaim.HasReturnLocation()
		if !*i.HasReturnLocation {
			p = returnportalclaim.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnLocationWith) > 0 {
		with := make([]predicate.Location, 0, len(i.HasReturnLocationWith))
		for _, w := range i.HasReturnLocationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnLocationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportalclaim.HasReturnLocationWith(with...))
	}
	if i.HasReturnOrderLine != nil {
		p := returnportalclaim.HasReturnOrderLine()
		if !*i.HasReturnOrderLine {
			p = returnportalclaim.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasReturnOrderLineWith) > 0 {
		with := make([]predicate.ReturnOrderLine, 0, len(i.HasReturnOrderLineWith))
		for _, w := range i.HasReturnOrderLineWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasReturnOrderLineWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, returnportalclaim.HasReturnOrderLineWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyReturnPortalClaimWhereInput
	case 1:
		return predicates[0], nil
	default:
		return returnportalclaim.And(predicates...), nil
	}
}

// SeatGroupWhereInput represents a where input for filtering SeatGroup queries.
type SeatGroupWhereInput struct {
	Predicates []predicate.SeatGroup  `json:"-"`
	Not        *SeatGroupWhereInput   `json:"not,omitempty"`
	Or         []*SeatGroupWhereInput `json:"or,omitempty"`
	And        []*SeatGroupWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "assigned_access_right" edge predicates.
	HasAssignedAccessRight     *bool                    `json:"hasAssignedAccessRight,omitempty"`
	HasAssignedAccessRightWith []*AccessRightWhereInput `json:"hasAssignedAccessRightWith,omitempty"`

	// "seat_group_access_right" edge predicates.
	HasSeatGroupAccessRight     *bool                             `json:"hasSeatGroupAccessRight,omitempty"`
	HasSeatGroupAccessRightWith []*SeatGroupAccessRightWhereInput `json:"hasSeatGroupAccessRightWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SeatGroupWhereInput) AddPredicates(predicates ...predicate.SeatGroup) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SeatGroupWhereInput filter on the SeatGroupQuery builder.
func (i *SeatGroupWhereInput) Filter(q *SeatGroupQuery) (*SeatGroupQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySeatGroupWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySeatGroupWhereInput is returned in case the SeatGroupWhereInput is empty.
var ErrEmptySeatGroupWhereInput = errors.New("ent: empty predicate SeatGroupWhereInput")

// P returns a predicate for filtering seatgroups.
// An error is returned if the input is empty or invalid.
func (i *SeatGroupWhereInput) P() (predicate.SeatGroup, error) {
	var predicates []predicate.SeatGroup
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, seatgroup.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SeatGroup, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, seatgroup.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SeatGroup, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, seatgroup.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, seatgroup.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, seatgroup.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, seatgroup.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, seatgroup.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, seatgroup.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, seatgroup.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, seatgroup.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, seatgroup.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, seatgroup.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, seatgroup.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, seatgroup.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, seatgroup.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, seatgroup.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, seatgroup.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, seatgroup.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, seatgroup.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, seatgroup.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, seatgroup.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, seatgroup.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, seatgroup.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, seatgroup.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, seatgroup.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, seatgroup.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, seatgroup.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, seatgroup.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, seatgroup.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, seatgroup.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, seatgroup.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, seatgroup.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, seatgroup.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, seatgroup.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, seatgroup.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, seatgroup.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, seatgroup.NameContainsFold(*i.NameContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, seatgroup.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, seatgroup.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, seatgroup.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, seatgroup.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, seatgroup.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, seatgroup.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, seatgroup.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, seatgroup.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, seatgroup.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, seatgroup.CreatedAtNotNil())
	}

	if i.HasTenant != nil {
		p := seatgroup.HasTenant()
		if !*i.HasTenant {
			p = seatgroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, seatgroup.HasTenantWith(with...))
	}
	if i.HasUser != nil {
		p := seatgroup.HasUser()
		if !*i.HasUser {
			p = seatgroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, seatgroup.HasUserWith(with...))
	}
	if i.HasAssignedAccessRight != nil {
		p := seatgroup.HasAssignedAccessRight()
		if !*i.HasAssignedAccessRight {
			p = seatgroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAssignedAccessRightWith) > 0 {
		with := make([]predicate.AccessRight, 0, len(i.HasAssignedAccessRightWith))
		for _, w := range i.HasAssignedAccessRightWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAssignedAccessRightWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, seatgroup.HasAssignedAccessRightWith(with...))
	}
	if i.HasSeatGroupAccessRight != nil {
		p := seatgroup.HasSeatGroupAccessRight()
		if !*i.HasSeatGroupAccessRight {
			p = seatgroup.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSeatGroupAccessRightWith) > 0 {
		with := make([]predicate.SeatGroupAccessRight, 0, len(i.HasSeatGroupAccessRightWith))
		for _, w := range i.HasSeatGroupAccessRightWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSeatGroupAccessRightWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, seatgroup.HasSeatGroupAccessRightWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySeatGroupWhereInput
	case 1:
		return predicates[0], nil
	default:
		return seatgroup.And(predicates...), nil
	}
}

// SeatGroupAccessRightWhereInput represents a where input for filtering SeatGroupAccessRight queries.
type SeatGroupAccessRightWhereInput struct {
	Predicates []predicate.SeatGroupAccessRight  `json:"-"`
	Not        *SeatGroupAccessRightWhereInput   `json:"not,omitempty"`
	Or         []*SeatGroupAccessRightWhereInput `json:"or,omitempty"`
	And        []*SeatGroupAccessRightWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "level" field predicates.
	Level      *seatgroupaccessright.Level  `json:"level,omitempty"`
	LevelNEQ   *seatgroupaccessright.Level  `json:"levelNEQ,omitempty"`
	LevelIn    []seatgroupaccessright.Level `json:"levelIn,omitempty"`
	LevelNotIn []seatgroupaccessright.Level `json:"levelNotIn,omitempty"`

	// "access_right_id" field predicates.
	AccessRightID             *pulid.ID  `json:"accessRightID,omitempty"`
	AccessRightIDNEQ          *pulid.ID  `json:"accessRightIDNEQ,omitempty"`
	AccessRightIDIn           []pulid.ID `json:"accessRightIDIn,omitempty"`
	AccessRightIDNotIn        []pulid.ID `json:"accessRightIDNotIn,omitempty"`
	AccessRightIDGT           *pulid.ID  `json:"accessRightIDGT,omitempty"`
	AccessRightIDGTE          *pulid.ID  `json:"accessRightIDGTE,omitempty"`
	AccessRightIDLT           *pulid.ID  `json:"accessRightIDLT,omitempty"`
	AccessRightIDLTE          *pulid.ID  `json:"accessRightIDLTE,omitempty"`
	AccessRightIDContains     *pulid.ID  `json:"accessRightIDContains,omitempty"`
	AccessRightIDHasPrefix    *pulid.ID  `json:"accessRightIDHasPrefix,omitempty"`
	AccessRightIDHasSuffix    *pulid.ID  `json:"accessRightIDHasSuffix,omitempty"`
	AccessRightIDEqualFold    *pulid.ID  `json:"accessRightIDEqualFold,omitempty"`
	AccessRightIDContainsFold *pulid.ID  `json:"accessRightIDContainsFold,omitempty"`

	// "seat_group_id" field predicates.
	SeatGroupID             *pulid.ID  `json:"seatGroupID,omitempty"`
	SeatGroupIDNEQ          *pulid.ID  `json:"seatGroupIDNEQ,omitempty"`
	SeatGroupIDIn           []pulid.ID `json:"seatGroupIDIn,omitempty"`
	SeatGroupIDNotIn        []pulid.ID `json:"seatGroupIDNotIn,omitempty"`
	SeatGroupIDGT           *pulid.ID  `json:"seatGroupIDGT,omitempty"`
	SeatGroupIDGTE          *pulid.ID  `json:"seatGroupIDGTE,omitempty"`
	SeatGroupIDLT           *pulid.ID  `json:"seatGroupIDLT,omitempty"`
	SeatGroupIDLTE          *pulid.ID  `json:"seatGroupIDLTE,omitempty"`
	SeatGroupIDContains     *pulid.ID  `json:"seatGroupIDContains,omitempty"`
	SeatGroupIDHasPrefix    *pulid.ID  `json:"seatGroupIDHasPrefix,omitempty"`
	SeatGroupIDHasSuffix    *pulid.ID  `json:"seatGroupIDHasSuffix,omitempty"`
	SeatGroupIDEqualFold    *pulid.ID  `json:"seatGroupIDEqualFold,omitempty"`
	SeatGroupIDContainsFold *pulid.ID  `json:"seatGroupIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "access_right" edge predicates.
	HasAccessRight     *bool                    `json:"hasAccessRight,omitempty"`
	HasAccessRightWith []*AccessRightWhereInput `json:"hasAccessRightWith,omitempty"`

	// "seat_group" edge predicates.
	HasSeatGroup     *bool                  `json:"hasSeatGroup,omitempty"`
	HasSeatGroupWith []*SeatGroupWhereInput `json:"hasSeatGroupWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SeatGroupAccessRightWhereInput) AddPredicates(predicates ...predicate.SeatGroupAccessRight) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SeatGroupAccessRightWhereInput filter on the SeatGroupAccessRightQuery builder.
func (i *SeatGroupAccessRightWhereInput) Filter(q *SeatGroupAccessRightQuery) (*SeatGroupAccessRightQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySeatGroupAccessRightWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySeatGroupAccessRightWhereInput is returned in case the SeatGroupAccessRightWhereInput is empty.
var ErrEmptySeatGroupAccessRightWhereInput = errors.New("ent: empty predicate SeatGroupAccessRightWhereInput")

// P returns a predicate for filtering seatgroupaccessrights.
// An error is returned if the input is empty or invalid.
func (i *SeatGroupAccessRightWhereInput) P() (predicate.SeatGroupAccessRight, error) {
	var predicates []predicate.SeatGroupAccessRight
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, seatgroupaccessright.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SeatGroupAccessRight, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, seatgroupaccessright.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SeatGroupAccessRight, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, seatgroupaccessright.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, seatgroupaccessright.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, seatgroupaccessright.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, seatgroupaccessright.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, seatgroupaccessright.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, seatgroupaccessright.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, seatgroupaccessright.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, seatgroupaccessright.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, seatgroupaccessright.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, seatgroupaccessright.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, seatgroupaccessright.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, seatgroupaccessright.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Level != nil {
		predicates = append(predicates, seatgroupaccessright.LevelEQ(*i.Level))
	}
	if i.LevelNEQ != nil {
		predicates = append(predicates, seatgroupaccessright.LevelNEQ(*i.LevelNEQ))
	}
	if len(i.LevelIn) > 0 {
		predicates = append(predicates, seatgroupaccessright.LevelIn(i.LevelIn...))
	}
	if len(i.LevelNotIn) > 0 {
		predicates = append(predicates, seatgroupaccessright.LevelNotIn(i.LevelNotIn...))
	}
	if i.AccessRightID != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDEQ(*i.AccessRightID))
	}
	if i.AccessRightIDNEQ != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDNEQ(*i.AccessRightIDNEQ))
	}
	if len(i.AccessRightIDIn) > 0 {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDIn(i.AccessRightIDIn...))
	}
	if len(i.AccessRightIDNotIn) > 0 {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDNotIn(i.AccessRightIDNotIn...))
	}
	if i.AccessRightIDGT != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDGT(*i.AccessRightIDGT))
	}
	if i.AccessRightIDGTE != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDGTE(*i.AccessRightIDGTE))
	}
	if i.AccessRightIDLT != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDLT(*i.AccessRightIDLT))
	}
	if i.AccessRightIDLTE != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDLTE(*i.AccessRightIDLTE))
	}
	if i.AccessRightIDContains != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDContains(*i.AccessRightIDContains))
	}
	if i.AccessRightIDHasPrefix != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDHasPrefix(*i.AccessRightIDHasPrefix))
	}
	if i.AccessRightIDHasSuffix != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDHasSuffix(*i.AccessRightIDHasSuffix))
	}
	if i.AccessRightIDEqualFold != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDEqualFold(*i.AccessRightIDEqualFold))
	}
	if i.AccessRightIDContainsFold != nil {
		predicates = append(predicates, seatgroupaccessright.AccessRightIDContainsFold(*i.AccessRightIDContainsFold))
	}
	if i.SeatGroupID != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDEQ(*i.SeatGroupID))
	}
	if i.SeatGroupIDNEQ != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDNEQ(*i.SeatGroupIDNEQ))
	}
	if len(i.SeatGroupIDIn) > 0 {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDIn(i.SeatGroupIDIn...))
	}
	if len(i.SeatGroupIDNotIn) > 0 {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDNotIn(i.SeatGroupIDNotIn...))
	}
	if i.SeatGroupIDGT != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDGT(*i.SeatGroupIDGT))
	}
	if i.SeatGroupIDGTE != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDGTE(*i.SeatGroupIDGTE))
	}
	if i.SeatGroupIDLT != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDLT(*i.SeatGroupIDLT))
	}
	if i.SeatGroupIDLTE != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDLTE(*i.SeatGroupIDLTE))
	}
	if i.SeatGroupIDContains != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDContains(*i.SeatGroupIDContains))
	}
	if i.SeatGroupIDHasPrefix != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDHasPrefix(*i.SeatGroupIDHasPrefix))
	}
	if i.SeatGroupIDHasSuffix != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDHasSuffix(*i.SeatGroupIDHasSuffix))
	}
	if i.SeatGroupIDEqualFold != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDEqualFold(*i.SeatGroupIDEqualFold))
	}
	if i.SeatGroupIDContainsFold != nil {
		predicates = append(predicates, seatgroupaccessright.SeatGroupIDContainsFold(*i.SeatGroupIDContainsFold))
	}

	if i.HasTenant != nil {
		p := seatgroupaccessright.HasTenant()
		if !*i.HasTenant {
			p = seatgroupaccessright.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, seatgroupaccessright.HasTenantWith(with...))
	}
	if i.HasAccessRight != nil {
		p := seatgroupaccessright.HasAccessRight()
		if !*i.HasAccessRight {
			p = seatgroupaccessright.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAccessRightWith) > 0 {
		with := make([]predicate.AccessRight, 0, len(i.HasAccessRightWith))
		for _, w := range i.HasAccessRightWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAccessRightWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, seatgroupaccessright.HasAccessRightWith(with...))
	}
	if i.HasSeatGroup != nil {
		p := seatgroupaccessright.HasSeatGroup()
		if !*i.HasSeatGroup {
			p = seatgroupaccessright.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSeatGroupWith) > 0 {
		with := make([]predicate.SeatGroup, 0, len(i.HasSeatGroupWith))
		for _, w := range i.HasSeatGroupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSeatGroupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, seatgroupaccessright.HasSeatGroupWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySeatGroupAccessRightWhereInput
	case 1:
		return predicates[0], nil
	default:
		return seatgroupaccessright.And(predicates...), nil
	}
}

// ShipmentWhereInput represents a where input for filtering Shipment queries.
type ShipmentWhereInput struct {
	Predicates []predicate.Shipment  `json:"-"`
	Not        *ShipmentWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentWhereInput `json:"or,omitempty"`
	And        []*ShipmentWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "shipment_public_id" field predicates.
	ShipmentPublicID             *string  `json:"shipmentPublicID,omitempty"`
	ShipmentPublicIDNEQ          *string  `json:"shipmentPublicIDNEQ,omitempty"`
	ShipmentPublicIDIn           []string `json:"shipmentPublicIDIn,omitempty"`
	ShipmentPublicIDNotIn        []string `json:"shipmentPublicIDNotIn,omitempty"`
	ShipmentPublicIDGT           *string  `json:"shipmentPublicIDGT,omitempty"`
	ShipmentPublicIDGTE          *string  `json:"shipmentPublicIDGTE,omitempty"`
	ShipmentPublicIDLT           *string  `json:"shipmentPublicIDLT,omitempty"`
	ShipmentPublicIDLTE          *string  `json:"shipmentPublicIDLTE,omitempty"`
	ShipmentPublicIDContains     *string  `json:"shipmentPublicIDContains,omitempty"`
	ShipmentPublicIDHasPrefix    *string  `json:"shipmentPublicIDHasPrefix,omitempty"`
	ShipmentPublicIDHasSuffix    *string  `json:"shipmentPublicIDHasSuffix,omitempty"`
	ShipmentPublicIDEqualFold    *string  `json:"shipmentPublicIDEqualFold,omitempty"`
	ShipmentPublicIDContainsFold *string  `json:"shipmentPublicIDContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "status" field predicates.
	Status      *shipment.Status  `json:"status,omitempty"`
	StatusNEQ   *shipment.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []shipment.Status `json:"statusIn,omitempty"`
	StatusNotIn []shipment.Status `json:"statusNotIn,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "carrier" edge predicates.
	HasCarrier     *bool                `json:"hasCarrier,omitempty"`
	HasCarrierWith []*CarrierWhereInput `json:"hasCarrierWith,omitempty"`

	// "shipment_history" edge predicates.
	HasShipmentHistory     *bool                        `json:"hasShipmentHistory,omitempty"`
	HasShipmentHistoryWith []*ShipmentHistoryWhereInput `json:"hasShipmentHistoryWith,omitempty"`

	// "shipment_bring" edge predicates.
	HasShipmentBring     *bool                      `json:"hasShipmentBring,omitempty"`
	HasShipmentBringWith []*ShipmentBringWhereInput `json:"hasShipmentBringWith,omitempty"`

	// "shipment_dao" edge predicates.
	HasShipmentDAO     *bool                    `json:"hasShipmentDAO,omitempty"`
	HasShipmentDAOWith []*ShipmentDAOWhereInput `json:"hasShipmentDAOWith,omitempty"`

	// "shipment_df" edge predicates.
	HasShipmentDF     *bool                   `json:"hasShipmentDF,omitempty"`
	HasShipmentDFWith []*ShipmentDFWhereInput `json:"hasShipmentDFWith,omitempty"`

	// "shipment_dsv" edge predicates.
	HasShipmentDSV     *bool                    `json:"hasShipmentDSV,omitempty"`
	HasShipmentDSVWith []*ShipmentDSVWhereInput `json:"hasShipmentDSVWith,omitempty"`

	// "shipment_easy_post" edge predicates.
	HasShipmentEasyPost     *bool                         `json:"hasShipmentEasyPost,omitempty"`
	HasShipmentEasyPostWith []*ShipmentEasyPostWhereInput `json:"hasShipmentEasyPostWith,omitempty"`

	// "shipment_post_nord" edge predicates.
	HasShipmentPostNord     *bool                         `json:"hasShipmentPostNord,omitempty"`
	HasShipmentPostNordWith []*ShipmentPostNordWhereInput `json:"hasShipmentPostNordWith,omitempty"`

	// "shipment_gls" edge predicates.
	HasShipmentGLS     *bool                    `json:"hasShipmentGLS,omitempty"`
	HasShipmentGLSWith []*ShipmentGLSWhereInput `json:"hasShipmentGLSWith,omitempty"`

	// "shipment_usps" edge predicates.
	HasShipmentUSPS     *bool                     `json:"hasShipmentUSPS,omitempty"`
	HasShipmentUSPSWith []*ShipmentUSPSWhereInput `json:"hasShipmentUSPSWith,omitempty"`

	// "consolidation" edge predicates.
	HasConsolidation     *bool                      `json:"hasConsolidation,omitempty"`
	HasConsolidationWith []*ConsolidationWhereInput `json:"hasConsolidationWith,omitempty"`

	// "old_consolidation" edge predicates.
	HasOldConsolidation     *bool                      `json:"hasOldConsolidation,omitempty"`
	HasOldConsolidationWith []*ConsolidationWhereInput `json:"hasOldConsolidationWith,omitempty"`

	// "shipment_parcel" edge predicates.
	HasShipmentParcel     *bool                       `json:"hasShipmentParcel,omitempty"`
	HasShipmentParcelWith []*ShipmentParcelWhereInput `json:"hasShipmentParcelWith,omitempty"`

	// "shipment_pallet" edge predicates.
	HasShipmentPallet     *bool                       `json:"hasShipmentPallet,omitempty"`
	HasShipmentPalletWith []*ShipmentPalletWhereInput `json:"hasShipmentPalletWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentWhereInput) AddPredicates(predicates ...predicate.Shipment) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentWhereInput filter on the ShipmentQuery builder.
func (i *ShipmentWhereInput) Filter(q *ShipmentQuery) (*ShipmentQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentWhereInput is returned in case the ShipmentWhereInput is empty.
var ErrEmptyShipmentWhereInput = errors.New("ent: empty predicate ShipmentWhereInput")

// P returns a predicate for filtering shipments.
// An error is returned if the input is empty or invalid.
func (i *ShipmentWhereInput) P() (predicate.Shipment, error) {
	var predicates []predicate.Shipment
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipment.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Shipment, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipment.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Shipment, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipment.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipment.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipment.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipment.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipment.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipment.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipment.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipment.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipment.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipment.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipment.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipment.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipment.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipment.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipment.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipment.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipment.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipment.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipment.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipment.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipment.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipment.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ShipmentPublicID != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDEQ(*i.ShipmentPublicID))
	}
	if i.ShipmentPublicIDNEQ != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDNEQ(*i.ShipmentPublicIDNEQ))
	}
	if len(i.ShipmentPublicIDIn) > 0 {
		predicates = append(predicates, shipment.ShipmentPublicIDIn(i.ShipmentPublicIDIn...))
	}
	if len(i.ShipmentPublicIDNotIn) > 0 {
		predicates = append(predicates, shipment.ShipmentPublicIDNotIn(i.ShipmentPublicIDNotIn...))
	}
	if i.ShipmentPublicIDGT != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDGT(*i.ShipmentPublicIDGT))
	}
	if i.ShipmentPublicIDGTE != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDGTE(*i.ShipmentPublicIDGTE))
	}
	if i.ShipmentPublicIDLT != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDLT(*i.ShipmentPublicIDLT))
	}
	if i.ShipmentPublicIDLTE != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDLTE(*i.ShipmentPublicIDLTE))
	}
	if i.ShipmentPublicIDContains != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDContains(*i.ShipmentPublicIDContains))
	}
	if i.ShipmentPublicIDHasPrefix != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDHasPrefix(*i.ShipmentPublicIDHasPrefix))
	}
	if i.ShipmentPublicIDHasSuffix != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDHasSuffix(*i.ShipmentPublicIDHasSuffix))
	}
	if i.ShipmentPublicIDEqualFold != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDEqualFold(*i.ShipmentPublicIDEqualFold))
	}
	if i.ShipmentPublicIDContainsFold != nil {
		predicates = append(predicates, shipment.ShipmentPublicIDContainsFold(*i.ShipmentPublicIDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, shipment.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, shipment.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, shipment.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, shipment.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, shipment.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, shipment.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, shipment.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, shipment.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.Status != nil {
		predicates = append(predicates, shipment.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, shipment.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, shipment.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, shipment.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasTenant != nil {
		p := shipment.HasTenant()
		if !*i.HasTenant {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasTenantWith(with...))
	}
	if i.HasCarrier != nil {
		p := shipment.HasCarrier()
		if !*i.HasCarrier {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCarrierWith) > 0 {
		with := make([]predicate.Carrier, 0, len(i.HasCarrierWith))
		for _, w := range i.HasCarrierWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCarrierWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasCarrierWith(with...))
	}
	if i.HasShipmentHistory != nil {
		p := shipment.HasShipmentHistory()
		if !*i.HasShipmentHistory {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentHistoryWith) > 0 {
		with := make([]predicate.ShipmentHistory, 0, len(i.HasShipmentHistoryWith))
		for _, w := range i.HasShipmentHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentHistoryWith(with...))
	}
	if i.HasShipmentBring != nil {
		p := shipment.HasShipmentBring()
		if !*i.HasShipmentBring {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentBringWith) > 0 {
		with := make([]predicate.ShipmentBring, 0, len(i.HasShipmentBringWith))
		for _, w := range i.HasShipmentBringWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentBringWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentBringWith(with...))
	}
	if i.HasShipmentDAO != nil {
		p := shipment.HasShipmentDAO()
		if !*i.HasShipmentDAO {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentDAOWith) > 0 {
		with := make([]predicate.ShipmentDAO, 0, len(i.HasShipmentDAOWith))
		for _, w := range i.HasShipmentDAOWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentDAOWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentDAOWith(with...))
	}
	if i.HasShipmentDF != nil {
		p := shipment.HasShipmentDF()
		if !*i.HasShipmentDF {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentDFWith) > 0 {
		with := make([]predicate.ShipmentDF, 0, len(i.HasShipmentDFWith))
		for _, w := range i.HasShipmentDFWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentDFWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentDFWith(with...))
	}
	if i.HasShipmentDSV != nil {
		p := shipment.HasShipmentDSV()
		if !*i.HasShipmentDSV {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentDSVWith) > 0 {
		with := make([]predicate.ShipmentDSV, 0, len(i.HasShipmentDSVWith))
		for _, w := range i.HasShipmentDSVWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentDSVWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentDSVWith(with...))
	}
	if i.HasShipmentEasyPost != nil {
		p := shipment.HasShipmentEasyPost()
		if !*i.HasShipmentEasyPost {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentEasyPostWith) > 0 {
		with := make([]predicate.ShipmentEasyPost, 0, len(i.HasShipmentEasyPostWith))
		for _, w := range i.HasShipmentEasyPostWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentEasyPostWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentEasyPostWith(with...))
	}
	if i.HasShipmentPostNord != nil {
		p := shipment.HasShipmentPostNord()
		if !*i.HasShipmentPostNord {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentPostNordWith) > 0 {
		with := make([]predicate.ShipmentPostNord, 0, len(i.HasShipmentPostNordWith))
		for _, w := range i.HasShipmentPostNordWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentPostNordWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentPostNordWith(with...))
	}
	if i.HasShipmentGLS != nil {
		p := shipment.HasShipmentGLS()
		if !*i.HasShipmentGLS {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentGLSWith) > 0 {
		with := make([]predicate.ShipmentGLS, 0, len(i.HasShipmentGLSWith))
		for _, w := range i.HasShipmentGLSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentGLSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentGLSWith(with...))
	}
	if i.HasShipmentUSPS != nil {
		p := shipment.HasShipmentUSPS()
		if !*i.HasShipmentUSPS {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentUSPSWith) > 0 {
		with := make([]predicate.ShipmentUSPS, 0, len(i.HasShipmentUSPSWith))
		for _, w := range i.HasShipmentUSPSWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentUSPSWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentUSPSWith(with...))
	}
	if i.HasConsolidation != nil {
		p := shipment.HasConsolidation()
		if !*i.HasConsolidation {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConsolidationWith) > 0 {
		with := make([]predicate.Consolidation, 0, len(i.HasConsolidationWith))
		for _, w := range i.HasConsolidationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConsolidationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasConsolidationWith(with...))
	}
	if i.HasOldConsolidation != nil {
		p := shipment.HasOldConsolidation()
		if !*i.HasOldConsolidation {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOldConsolidationWith) > 0 {
		with := make([]predicate.Consolidation, 0, len(i.HasOldConsolidationWith))
		for _, w := range i.HasOldConsolidationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOldConsolidationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasOldConsolidationWith(with...))
	}
	if i.HasShipmentParcel != nil {
		p := shipment.HasShipmentParcel()
		if !*i.HasShipmentParcel {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentParcelWith) > 0 {
		with := make([]predicate.ShipmentParcel, 0, len(i.HasShipmentParcelWith))
		for _, w := range i.HasShipmentParcelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentParcelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentParcelWith(with...))
	}
	if i.HasShipmentPallet != nil {
		p := shipment.HasShipmentPallet()
		if !*i.HasShipmentPallet {
			p = shipment.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentPalletWith) > 0 {
		with := make([]predicate.ShipmentPallet, 0, len(i.HasShipmentPalletWith))
		for _, w := range i.HasShipmentPalletWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentPalletWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipment.HasShipmentPalletWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipment.And(predicates...), nil
	}
}

// ShipmentBringWhereInput represents a where input for filtering ShipmentBring queries.
type ShipmentBringWhereInput struct {
	Predicates []predicate.ShipmentBring  `json:"-"`
	Not        *ShipmentBringWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentBringWhereInput `json:"or,omitempty"`
	And        []*ShipmentBringWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "consignment_number" field predicates.
	ConsignmentNumber             *string  `json:"consignmentNumber,omitempty"`
	ConsignmentNumberNEQ          *string  `json:"consignmentNumberNEQ,omitempty"`
	ConsignmentNumberIn           []string `json:"consignmentNumberIn,omitempty"`
	ConsignmentNumberNotIn        []string `json:"consignmentNumberNotIn,omitempty"`
	ConsignmentNumberGT           *string  `json:"consignmentNumberGT,omitempty"`
	ConsignmentNumberGTE          *string  `json:"consignmentNumberGTE,omitempty"`
	ConsignmentNumberLT           *string  `json:"consignmentNumberLT,omitempty"`
	ConsignmentNumberLTE          *string  `json:"consignmentNumberLTE,omitempty"`
	ConsignmentNumberContains     *string  `json:"consignmentNumberContains,omitempty"`
	ConsignmentNumberHasPrefix    *string  `json:"consignmentNumberHasPrefix,omitempty"`
	ConsignmentNumberHasSuffix    *string  `json:"consignmentNumberHasSuffix,omitempty"`
	ConsignmentNumberEqualFold    *string  `json:"consignmentNumberEqualFold,omitempty"`
	ConsignmentNumberContainsFold *string  `json:"consignmentNumberContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentBringWhereInput) AddPredicates(predicates ...predicate.ShipmentBring) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentBringWhereInput filter on the ShipmentBringQuery builder.
func (i *ShipmentBringWhereInput) Filter(q *ShipmentBringQuery) (*ShipmentBringQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentBringWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentBringWhereInput is returned in case the ShipmentBringWhereInput is empty.
var ErrEmptyShipmentBringWhereInput = errors.New("ent: empty predicate ShipmentBringWhereInput")

// P returns a predicate for filtering shipmentbrings.
// An error is returned if the input is empty or invalid.
func (i *ShipmentBringWhereInput) P() (predicate.ShipmentBring, error) {
	var predicates []predicate.ShipmentBring
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmentbring.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentBring, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmentbring.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentBring, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmentbring.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmentbring.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmentbring.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmentbring.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmentbring.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmentbring.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmentbring.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmentbring.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmentbring.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmentbring.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmentbring.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmentbring.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmentbring.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmentbring.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmentbring.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmentbring.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmentbring.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmentbring.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmentbring.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmentbring.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmentbring.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmentbring.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ConsignmentNumber != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberEQ(*i.ConsignmentNumber))
	}
	if i.ConsignmentNumberNEQ != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberNEQ(*i.ConsignmentNumberNEQ))
	}
	if len(i.ConsignmentNumberIn) > 0 {
		predicates = append(predicates, shipmentbring.ConsignmentNumberIn(i.ConsignmentNumberIn...))
	}
	if len(i.ConsignmentNumberNotIn) > 0 {
		predicates = append(predicates, shipmentbring.ConsignmentNumberNotIn(i.ConsignmentNumberNotIn...))
	}
	if i.ConsignmentNumberGT != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberGT(*i.ConsignmentNumberGT))
	}
	if i.ConsignmentNumberGTE != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberGTE(*i.ConsignmentNumberGTE))
	}
	if i.ConsignmentNumberLT != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberLT(*i.ConsignmentNumberLT))
	}
	if i.ConsignmentNumberLTE != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberLTE(*i.ConsignmentNumberLTE))
	}
	if i.ConsignmentNumberContains != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberContains(*i.ConsignmentNumberContains))
	}
	if i.ConsignmentNumberHasPrefix != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberHasPrefix(*i.ConsignmentNumberHasPrefix))
	}
	if i.ConsignmentNumberHasSuffix != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberHasSuffix(*i.ConsignmentNumberHasSuffix))
	}
	if i.ConsignmentNumberEqualFold != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberEqualFold(*i.ConsignmentNumberEqualFold))
	}
	if i.ConsignmentNumberContainsFold != nil {
		predicates = append(predicates, shipmentbring.ConsignmentNumberContainsFold(*i.ConsignmentNumberContainsFold))
	}

	if i.HasTenant != nil {
		p := shipmentbring.HasTenant()
		if !*i.HasTenant {
			p = shipmentbring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentbring.HasTenantWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmentbring.HasShipment()
		if !*i.HasShipment {
			p = shipmentbring.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentbring.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentBringWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmentbring.And(predicates...), nil
	}
}

// ShipmentDAOWhereInput represents a where input for filtering ShipmentDAO queries.
type ShipmentDAOWhereInput struct {
	Predicates []predicate.ShipmentDAO  `json:"-"`
	Not        *ShipmentDAOWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentDAOWhereInput `json:"or,omitempty"`
	And        []*ShipmentDAOWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "barcode_id" field predicates.
	BarcodeID             *string  `json:"barcodeID,omitempty"`
	BarcodeIDNEQ          *string  `json:"barcodeIDNEQ,omitempty"`
	BarcodeIDIn           []string `json:"barcodeIDIn,omitempty"`
	BarcodeIDNotIn        []string `json:"barcodeIDNotIn,omitempty"`
	BarcodeIDGT           *string  `json:"barcodeIDGT,omitempty"`
	BarcodeIDGTE          *string  `json:"barcodeIDGTE,omitempty"`
	BarcodeIDLT           *string  `json:"barcodeIDLT,omitempty"`
	BarcodeIDLTE          *string  `json:"barcodeIDLTE,omitempty"`
	BarcodeIDContains     *string  `json:"barcodeIDContains,omitempty"`
	BarcodeIDHasPrefix    *string  `json:"barcodeIDHasPrefix,omitempty"`
	BarcodeIDHasSuffix    *string  `json:"barcodeIDHasSuffix,omitempty"`
	BarcodeIDEqualFold    *string  `json:"barcodeIDEqualFold,omitempty"`
	BarcodeIDContainsFold *string  `json:"barcodeIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentDAOWhereInput) AddPredicates(predicates ...predicate.ShipmentDAO) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentDAOWhereInput filter on the ShipmentDAOQuery builder.
func (i *ShipmentDAOWhereInput) Filter(q *ShipmentDAOQuery) (*ShipmentDAOQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentDAOWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentDAOWhereInput is returned in case the ShipmentDAOWhereInput is empty.
var ErrEmptyShipmentDAOWhereInput = errors.New("ent: empty predicate ShipmentDAOWhereInput")

// P returns a predicate for filtering shipmentdaos.
// An error is returned if the input is empty or invalid.
func (i *ShipmentDAOWhereInput) P() (predicate.ShipmentDAO, error) {
	var predicates []predicate.ShipmentDAO
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmentdao.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentDAO, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmentdao.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentDAO, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmentdao.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmentdao.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmentdao.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmentdao.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmentdao.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmentdao.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmentdao.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmentdao.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmentdao.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmentdao.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmentdao.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmentdao.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmentdao.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmentdao.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmentdao.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmentdao.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmentdao.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmentdao.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmentdao.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmentdao.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmentdao.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmentdao.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.BarcodeID != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDEQ(*i.BarcodeID))
	}
	if i.BarcodeIDNEQ != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDNEQ(*i.BarcodeIDNEQ))
	}
	if len(i.BarcodeIDIn) > 0 {
		predicates = append(predicates, shipmentdao.BarcodeIDIn(i.BarcodeIDIn...))
	}
	if len(i.BarcodeIDNotIn) > 0 {
		predicates = append(predicates, shipmentdao.BarcodeIDNotIn(i.BarcodeIDNotIn...))
	}
	if i.BarcodeIDGT != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDGT(*i.BarcodeIDGT))
	}
	if i.BarcodeIDGTE != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDGTE(*i.BarcodeIDGTE))
	}
	if i.BarcodeIDLT != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDLT(*i.BarcodeIDLT))
	}
	if i.BarcodeIDLTE != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDLTE(*i.BarcodeIDLTE))
	}
	if i.BarcodeIDContains != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDContains(*i.BarcodeIDContains))
	}
	if i.BarcodeIDHasPrefix != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDHasPrefix(*i.BarcodeIDHasPrefix))
	}
	if i.BarcodeIDHasSuffix != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDHasSuffix(*i.BarcodeIDHasSuffix))
	}
	if i.BarcodeIDEqualFold != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDEqualFold(*i.BarcodeIDEqualFold))
	}
	if i.BarcodeIDContainsFold != nil {
		predicates = append(predicates, shipmentdao.BarcodeIDContainsFold(*i.BarcodeIDContainsFold))
	}

	if i.HasTenant != nil {
		p := shipmentdao.HasTenant()
		if !*i.HasTenant {
			p = shipmentdao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentdao.HasTenantWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmentdao.HasShipment()
		if !*i.HasShipment {
			p = shipmentdao.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentdao.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentDAOWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmentdao.And(predicates...), nil
	}
}

// ShipmentDFWhereInput represents a where input for filtering ShipmentDF queries.
type ShipmentDFWhereInput struct {
	Predicates []predicate.ShipmentDF  `json:"-"`
	Not        *ShipmentDFWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentDFWhereInput `json:"or,omitempty"`
	And        []*ShipmentDFWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentDFWhereInput) AddPredicates(predicates ...predicate.ShipmentDF) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentDFWhereInput filter on the ShipmentDFQuery builder.
func (i *ShipmentDFWhereInput) Filter(q *ShipmentDFQuery) (*ShipmentDFQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentDFWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentDFWhereInput is returned in case the ShipmentDFWhereInput is empty.
var ErrEmptyShipmentDFWhereInput = errors.New("ent: empty predicate ShipmentDFWhereInput")

// P returns a predicate for filtering shipmentdfs.
// An error is returned if the input is empty or invalid.
func (i *ShipmentDFWhereInput) P() (predicate.ShipmentDF, error) {
	var predicates []predicate.ShipmentDF
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmentdf.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentDF, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmentdf.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentDF, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmentdf.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmentdf.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmentdf.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmentdf.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmentdf.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmentdf.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmentdf.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmentdf.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmentdf.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmentdf.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmentdf.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmentdf.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmentdf.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmentdf.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmentdf.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmentdf.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmentdf.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmentdf.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmentdf.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmentdf.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmentdf.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmentdf.TenantIDContainsFold(*i.TenantIDContainsFold))
	}

	if i.HasTenant != nil {
		p := shipmentdf.HasTenant()
		if !*i.HasTenant {
			p = shipmentdf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentdf.HasTenantWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmentdf.HasShipment()
		if !*i.HasShipment {
			p = shipmentdf.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentdf.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentDFWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmentdf.And(predicates...), nil
	}
}

// ShipmentDSVWhereInput represents a where input for filtering ShipmentDSV queries.
type ShipmentDSVWhereInput struct {
	Predicates []predicate.ShipmentDSV  `json:"-"`
	Not        *ShipmentDSVWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentDSVWhereInput `json:"or,omitempty"`
	And        []*ShipmentDSVWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "barcode_id" field predicates.
	BarcodeID             *string  `json:"barcodeID,omitempty"`
	BarcodeIDNEQ          *string  `json:"barcodeIDNEQ,omitempty"`
	BarcodeIDIn           []string `json:"barcodeIDIn,omitempty"`
	BarcodeIDNotIn        []string `json:"barcodeIDNotIn,omitempty"`
	BarcodeIDGT           *string  `json:"barcodeIDGT,omitempty"`
	BarcodeIDGTE          *string  `json:"barcodeIDGTE,omitempty"`
	BarcodeIDLT           *string  `json:"barcodeIDLT,omitempty"`
	BarcodeIDLTE          *string  `json:"barcodeIDLTE,omitempty"`
	BarcodeIDContains     *string  `json:"barcodeIDContains,omitempty"`
	BarcodeIDHasPrefix    *string  `json:"barcodeIDHasPrefix,omitempty"`
	BarcodeIDHasSuffix    *string  `json:"barcodeIDHasSuffix,omitempty"`
	BarcodeIDEqualFold    *string  `json:"barcodeIDEqualFold,omitempty"`
	BarcodeIDContainsFold *string  `json:"barcodeIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentDSVWhereInput) AddPredicates(predicates ...predicate.ShipmentDSV) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentDSVWhereInput filter on the ShipmentDSVQuery builder.
func (i *ShipmentDSVWhereInput) Filter(q *ShipmentDSVQuery) (*ShipmentDSVQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentDSVWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentDSVWhereInput is returned in case the ShipmentDSVWhereInput is empty.
var ErrEmptyShipmentDSVWhereInput = errors.New("ent: empty predicate ShipmentDSVWhereInput")

// P returns a predicate for filtering shipmentdsvs.
// An error is returned if the input is empty or invalid.
func (i *ShipmentDSVWhereInput) P() (predicate.ShipmentDSV, error) {
	var predicates []predicate.ShipmentDSV
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmentdsv.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentDSV, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmentdsv.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentDSV, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmentdsv.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmentdsv.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmentdsv.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmentdsv.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmentdsv.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmentdsv.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmentdsv.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmentdsv.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmentdsv.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmentdsv.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmentdsv.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmentdsv.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmentdsv.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmentdsv.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmentdsv.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmentdsv.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmentdsv.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmentdsv.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmentdsv.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmentdsv.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmentdsv.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmentdsv.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.BarcodeID != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDEQ(*i.BarcodeID))
	}
	if i.BarcodeIDNEQ != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDNEQ(*i.BarcodeIDNEQ))
	}
	if len(i.BarcodeIDIn) > 0 {
		predicates = append(predicates, shipmentdsv.BarcodeIDIn(i.BarcodeIDIn...))
	}
	if len(i.BarcodeIDNotIn) > 0 {
		predicates = append(predicates, shipmentdsv.BarcodeIDNotIn(i.BarcodeIDNotIn...))
	}
	if i.BarcodeIDGT != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDGT(*i.BarcodeIDGT))
	}
	if i.BarcodeIDGTE != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDGTE(*i.BarcodeIDGTE))
	}
	if i.BarcodeIDLT != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDLT(*i.BarcodeIDLT))
	}
	if i.BarcodeIDLTE != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDLTE(*i.BarcodeIDLTE))
	}
	if i.BarcodeIDContains != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDContains(*i.BarcodeIDContains))
	}
	if i.BarcodeIDHasPrefix != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDHasPrefix(*i.BarcodeIDHasPrefix))
	}
	if i.BarcodeIDHasSuffix != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDHasSuffix(*i.BarcodeIDHasSuffix))
	}
	if i.BarcodeIDEqualFold != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDEqualFold(*i.BarcodeIDEqualFold))
	}
	if i.BarcodeIDContainsFold != nil {
		predicates = append(predicates, shipmentdsv.BarcodeIDContainsFold(*i.BarcodeIDContainsFold))
	}

	if i.HasTenant != nil {
		p := shipmentdsv.HasTenant()
		if !*i.HasTenant {
			p = shipmentdsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentdsv.HasTenantWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmentdsv.HasShipment()
		if !*i.HasShipment {
			p = shipmentdsv.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentdsv.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentDSVWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmentdsv.And(predicates...), nil
	}
}

// ShipmentEasyPostWhereInput represents a where input for filtering ShipmentEasyPost queries.
type ShipmentEasyPostWhereInput struct {
	Predicates []predicate.ShipmentEasyPost  `json:"-"`
	Not        *ShipmentEasyPostWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentEasyPostWhereInput `json:"or,omitempty"`
	And        []*ShipmentEasyPostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tracking_number" field predicates.
	TrackingNumber             *string  `json:"trackingNumber,omitempty"`
	TrackingNumberNEQ          *string  `json:"trackingNumberNEQ,omitempty"`
	TrackingNumberIn           []string `json:"trackingNumberIn,omitempty"`
	TrackingNumberNotIn        []string `json:"trackingNumberNotIn,omitempty"`
	TrackingNumberGT           *string  `json:"trackingNumberGT,omitempty"`
	TrackingNumberGTE          *string  `json:"trackingNumberGTE,omitempty"`
	TrackingNumberLT           *string  `json:"trackingNumberLT,omitempty"`
	TrackingNumberLTE          *string  `json:"trackingNumberLTE,omitempty"`
	TrackingNumberContains     *string  `json:"trackingNumberContains,omitempty"`
	TrackingNumberHasPrefix    *string  `json:"trackingNumberHasPrefix,omitempty"`
	TrackingNumberHasSuffix    *string  `json:"trackingNumberHasSuffix,omitempty"`
	TrackingNumberIsNil        bool     `json:"trackingNumberIsNil,omitempty"`
	TrackingNumberNotNil       bool     `json:"trackingNumberNotNil,omitempty"`
	TrackingNumberEqualFold    *string  `json:"trackingNumberEqualFold,omitempty"`
	TrackingNumberContainsFold *string  `json:"trackingNumberContainsFold,omitempty"`

	// "ep_shipment_id" field predicates.
	EpShipmentID             *string  `json:"epShipmentID,omitempty"`
	EpShipmentIDNEQ          *string  `json:"epShipmentIDNEQ,omitempty"`
	EpShipmentIDIn           []string `json:"epShipmentIDIn,omitempty"`
	EpShipmentIDNotIn        []string `json:"epShipmentIDNotIn,omitempty"`
	EpShipmentIDGT           *string  `json:"epShipmentIDGT,omitempty"`
	EpShipmentIDGTE          *string  `json:"epShipmentIDGTE,omitempty"`
	EpShipmentIDLT           *string  `json:"epShipmentIDLT,omitempty"`
	EpShipmentIDLTE          *string  `json:"epShipmentIDLTE,omitempty"`
	EpShipmentIDContains     *string  `json:"epShipmentIDContains,omitempty"`
	EpShipmentIDHasPrefix    *string  `json:"epShipmentIDHasPrefix,omitempty"`
	EpShipmentIDHasSuffix    *string  `json:"epShipmentIDHasSuffix,omitempty"`
	EpShipmentIDIsNil        bool     `json:"epShipmentIDIsNil,omitempty"`
	EpShipmentIDNotNil       bool     `json:"epShipmentIDNotNil,omitempty"`
	EpShipmentIDEqualFold    *string  `json:"epShipmentIDEqualFold,omitempty"`
	EpShipmentIDContainsFold *string  `json:"epShipmentIDContainsFold,omitempty"`

	// "rate" field predicates.
	Rate       *float64  `json:"rate,omitempty"`
	RateNEQ    *float64  `json:"rateNEQ,omitempty"`
	RateIn     []float64 `json:"rateIn,omitempty"`
	RateNotIn  []float64 `json:"rateNotIn,omitempty"`
	RateGT     *float64  `json:"rateGT,omitempty"`
	RateGTE    *float64  `json:"rateGTE,omitempty"`
	RateLT     *float64  `json:"rateLT,omitempty"`
	RateLTE    *float64  `json:"rateLTE,omitempty"`
	RateIsNil  bool      `json:"rateIsNil,omitempty"`
	RateNotNil bool      `json:"rateNotNil,omitempty"`

	// "est_delivery_date" field predicates.
	EstDeliveryDate       *time.Time  `json:"estDeliveryDate,omitempty"`
	EstDeliveryDateNEQ    *time.Time  `json:"estDeliveryDateNEQ,omitempty"`
	EstDeliveryDateIn     []time.Time `json:"estDeliveryDateIn,omitempty"`
	EstDeliveryDateNotIn  []time.Time `json:"estDeliveryDateNotIn,omitempty"`
	EstDeliveryDateGT     *time.Time  `json:"estDeliveryDateGT,omitempty"`
	EstDeliveryDateGTE    *time.Time  `json:"estDeliveryDateGTE,omitempty"`
	EstDeliveryDateLT     *time.Time  `json:"estDeliveryDateLT,omitempty"`
	EstDeliveryDateLTE    *time.Time  `json:"estDeliveryDateLTE,omitempty"`
	EstDeliveryDateIsNil  bool        `json:"estDeliveryDateIsNil,omitempty"`
	EstDeliveryDateNotNil bool        `json:"estDeliveryDateNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentEasyPostWhereInput) AddPredicates(predicates ...predicate.ShipmentEasyPost) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentEasyPostWhereInput filter on the ShipmentEasyPostQuery builder.
func (i *ShipmentEasyPostWhereInput) Filter(q *ShipmentEasyPostQuery) (*ShipmentEasyPostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentEasyPostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentEasyPostWhereInput is returned in case the ShipmentEasyPostWhereInput is empty.
var ErrEmptyShipmentEasyPostWhereInput = errors.New("ent: empty predicate ShipmentEasyPostWhereInput")

// P returns a predicate for filtering shipmenteasyposts.
// An error is returned if the input is empty or invalid.
func (i *ShipmentEasyPostWhereInput) P() (predicate.ShipmentEasyPost, error) {
	var predicates []predicate.ShipmentEasyPost
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmenteasypost.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentEasyPost, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmenteasypost.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentEasyPost, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmenteasypost.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmenteasypost.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmenteasypost.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmenteasypost.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmenteasypost.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmenteasypost.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmenteasypost.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmenteasypost.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmenteasypost.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmenteasypost.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmenteasypost.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmenteasypost.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.TrackingNumber != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberEQ(*i.TrackingNumber))
	}
	if i.TrackingNumberNEQ != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberNEQ(*i.TrackingNumberNEQ))
	}
	if len(i.TrackingNumberIn) > 0 {
		predicates = append(predicates, shipmenteasypost.TrackingNumberIn(i.TrackingNumberIn...))
	}
	if len(i.TrackingNumberNotIn) > 0 {
		predicates = append(predicates, shipmenteasypost.TrackingNumberNotIn(i.TrackingNumberNotIn...))
	}
	if i.TrackingNumberGT != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberGT(*i.TrackingNumberGT))
	}
	if i.TrackingNumberGTE != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberGTE(*i.TrackingNumberGTE))
	}
	if i.TrackingNumberLT != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberLT(*i.TrackingNumberLT))
	}
	if i.TrackingNumberLTE != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberLTE(*i.TrackingNumberLTE))
	}
	if i.TrackingNumberContains != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberContains(*i.TrackingNumberContains))
	}
	if i.TrackingNumberHasPrefix != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberHasPrefix(*i.TrackingNumberHasPrefix))
	}
	if i.TrackingNumberHasSuffix != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberHasSuffix(*i.TrackingNumberHasSuffix))
	}
	if i.TrackingNumberIsNil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberIsNil())
	}
	if i.TrackingNumberNotNil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberNotNil())
	}
	if i.TrackingNumberEqualFold != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberEqualFold(*i.TrackingNumberEqualFold))
	}
	if i.TrackingNumberContainsFold != nil {
		predicates = append(predicates, shipmenteasypost.TrackingNumberContainsFold(*i.TrackingNumberContainsFold))
	}
	if i.EpShipmentID != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDEQ(*i.EpShipmentID))
	}
	if i.EpShipmentIDNEQ != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDNEQ(*i.EpShipmentIDNEQ))
	}
	if len(i.EpShipmentIDIn) > 0 {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDIn(i.EpShipmentIDIn...))
	}
	if len(i.EpShipmentIDNotIn) > 0 {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDNotIn(i.EpShipmentIDNotIn...))
	}
	if i.EpShipmentIDGT != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDGT(*i.EpShipmentIDGT))
	}
	if i.EpShipmentIDGTE != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDGTE(*i.EpShipmentIDGTE))
	}
	if i.EpShipmentIDLT != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDLT(*i.EpShipmentIDLT))
	}
	if i.EpShipmentIDLTE != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDLTE(*i.EpShipmentIDLTE))
	}
	if i.EpShipmentIDContains != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDContains(*i.EpShipmentIDContains))
	}
	if i.EpShipmentIDHasPrefix != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDHasPrefix(*i.EpShipmentIDHasPrefix))
	}
	if i.EpShipmentIDHasSuffix != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDHasSuffix(*i.EpShipmentIDHasSuffix))
	}
	if i.EpShipmentIDIsNil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDIsNil())
	}
	if i.EpShipmentIDNotNil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDNotNil())
	}
	if i.EpShipmentIDEqualFold != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDEqualFold(*i.EpShipmentIDEqualFold))
	}
	if i.EpShipmentIDContainsFold != nil {
		predicates = append(predicates, shipmenteasypost.EpShipmentIDContainsFold(*i.EpShipmentIDContainsFold))
	}
	if i.Rate != nil {
		predicates = append(predicates, shipmenteasypost.RateEQ(*i.Rate))
	}
	if i.RateNEQ != nil {
		predicates = append(predicates, shipmenteasypost.RateNEQ(*i.RateNEQ))
	}
	if len(i.RateIn) > 0 {
		predicates = append(predicates, shipmenteasypost.RateIn(i.RateIn...))
	}
	if len(i.RateNotIn) > 0 {
		predicates = append(predicates, shipmenteasypost.RateNotIn(i.RateNotIn...))
	}
	if i.RateGT != nil {
		predicates = append(predicates, shipmenteasypost.RateGT(*i.RateGT))
	}
	if i.RateGTE != nil {
		predicates = append(predicates, shipmenteasypost.RateGTE(*i.RateGTE))
	}
	if i.RateLT != nil {
		predicates = append(predicates, shipmenteasypost.RateLT(*i.RateLT))
	}
	if i.RateLTE != nil {
		predicates = append(predicates, shipmenteasypost.RateLTE(*i.RateLTE))
	}
	if i.RateIsNil {
		predicates = append(predicates, shipmenteasypost.RateIsNil())
	}
	if i.RateNotNil {
		predicates = append(predicates, shipmenteasypost.RateNotNil())
	}
	if i.EstDeliveryDate != nil {
		predicates = append(predicates, shipmenteasypost.EstDeliveryDateEQ(*i.EstDeliveryDate))
	}
	if i.EstDeliveryDateNEQ != nil {
		predicates = append(predicates, shipmenteasypost.EstDeliveryDateNEQ(*i.EstDeliveryDateNEQ))
	}
	if len(i.EstDeliveryDateIn) > 0 {
		predicates = append(predicates, shipmenteasypost.EstDeliveryDateIn(i.EstDeliveryDateIn...))
	}
	if len(i.EstDeliveryDateNotIn) > 0 {
		predicates = append(predicates, shipmenteasypost.EstDeliveryDateNotIn(i.EstDeliveryDateNotIn...))
	}
	if i.EstDeliveryDateGT != nil {
		predicates = append(predicates, shipmenteasypost.EstDeliveryDateGT(*i.EstDeliveryDateGT))
	}
	if i.EstDeliveryDateGTE != nil {
		predicates = append(predicates, shipmenteasypost.EstDeliveryDateGTE(*i.EstDeliveryDateGTE))
	}
	if i.EstDeliveryDateLT != nil {
		predicates = append(predicates, shipmenteasypost.EstDeliveryDateLT(*i.EstDeliveryDateLT))
	}
	if i.EstDeliveryDateLTE != nil {
		predicates = append(predicates, shipmenteasypost.EstDeliveryDateLTE(*i.EstDeliveryDateLTE))
	}
	if i.EstDeliveryDateIsNil {
		predicates = append(predicates, shipmenteasypost.EstDeliveryDateIsNil())
	}
	if i.EstDeliveryDateNotNil {
		predicates = append(predicates, shipmenteasypost.EstDeliveryDateNotNil())
	}

	if i.HasTenant != nil {
		p := shipmenteasypost.HasTenant()
		if !*i.HasTenant {
			p = shipmenteasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmenteasypost.HasTenantWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmenteasypost.HasShipment()
		if !*i.HasShipment {
			p = shipmenteasypost.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmenteasypost.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentEasyPostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmenteasypost.And(predicates...), nil
	}
}

// ShipmentGLSWhereInput represents a where input for filtering ShipmentGLS queries.
type ShipmentGLSWhereInput struct {
	Predicates []predicate.ShipmentGLS  `json:"-"`
	Not        *ShipmentGLSWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentGLSWhereInput `json:"or,omitempty"`
	And        []*ShipmentGLSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "consignment_id" field predicates.
	ConsignmentID             *string  `json:"consignmentID,omitempty"`
	ConsignmentIDNEQ          *string  `json:"consignmentIDNEQ,omitempty"`
	ConsignmentIDIn           []string `json:"consignmentIDIn,omitempty"`
	ConsignmentIDNotIn        []string `json:"consignmentIDNotIn,omitempty"`
	ConsignmentIDGT           *string  `json:"consignmentIDGT,omitempty"`
	ConsignmentIDGTE          *string  `json:"consignmentIDGTE,omitempty"`
	ConsignmentIDLT           *string  `json:"consignmentIDLT,omitempty"`
	ConsignmentIDLTE          *string  `json:"consignmentIDLTE,omitempty"`
	ConsignmentIDContains     *string  `json:"consignmentIDContains,omitempty"`
	ConsignmentIDHasPrefix    *string  `json:"consignmentIDHasPrefix,omitempty"`
	ConsignmentIDHasSuffix    *string  `json:"consignmentIDHasSuffix,omitempty"`
	ConsignmentIDEqualFold    *string  `json:"consignmentIDEqualFold,omitempty"`
	ConsignmentIDContainsFold *string  `json:"consignmentIDContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentGLSWhereInput) AddPredicates(predicates ...predicate.ShipmentGLS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentGLSWhereInput filter on the ShipmentGLSQuery builder.
func (i *ShipmentGLSWhereInput) Filter(q *ShipmentGLSQuery) (*ShipmentGLSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentGLSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentGLSWhereInput is returned in case the ShipmentGLSWhereInput is empty.
var ErrEmptyShipmentGLSWhereInput = errors.New("ent: empty predicate ShipmentGLSWhereInput")

// P returns a predicate for filtering shipmentglss.
// An error is returned if the input is empty or invalid.
func (i *ShipmentGLSWhereInput) P() (predicate.ShipmentGLS, error) {
	var predicates []predicate.ShipmentGLS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmentgls.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentGLS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmentgls.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentGLS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmentgls.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmentgls.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmentgls.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmentgls.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmentgls.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmentgls.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmentgls.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmentgls.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmentgls.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmentgls.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmentgls.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmentgls.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmentgls.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmentgls.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmentgls.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmentgls.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmentgls.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmentgls.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmentgls.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmentgls.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmentgls.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmentgls.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ConsignmentID != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDEQ(*i.ConsignmentID))
	}
	if i.ConsignmentIDNEQ != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDNEQ(*i.ConsignmentIDNEQ))
	}
	if len(i.ConsignmentIDIn) > 0 {
		predicates = append(predicates, shipmentgls.ConsignmentIDIn(i.ConsignmentIDIn...))
	}
	if len(i.ConsignmentIDNotIn) > 0 {
		predicates = append(predicates, shipmentgls.ConsignmentIDNotIn(i.ConsignmentIDNotIn...))
	}
	if i.ConsignmentIDGT != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDGT(*i.ConsignmentIDGT))
	}
	if i.ConsignmentIDGTE != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDGTE(*i.ConsignmentIDGTE))
	}
	if i.ConsignmentIDLT != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDLT(*i.ConsignmentIDLT))
	}
	if i.ConsignmentIDLTE != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDLTE(*i.ConsignmentIDLTE))
	}
	if i.ConsignmentIDContains != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDContains(*i.ConsignmentIDContains))
	}
	if i.ConsignmentIDHasPrefix != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDHasPrefix(*i.ConsignmentIDHasPrefix))
	}
	if i.ConsignmentIDHasSuffix != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDHasSuffix(*i.ConsignmentIDHasSuffix))
	}
	if i.ConsignmentIDEqualFold != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDEqualFold(*i.ConsignmentIDEqualFold))
	}
	if i.ConsignmentIDContainsFold != nil {
		predicates = append(predicates, shipmentgls.ConsignmentIDContainsFold(*i.ConsignmentIDContainsFold))
	}

	if i.HasTenant != nil {
		p := shipmentgls.HasTenant()
		if !*i.HasTenant {
			p = shipmentgls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentgls.HasTenantWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmentgls.HasShipment()
		if !*i.HasShipment {
			p = shipmentgls.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentgls.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentGLSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmentgls.And(predicates...), nil
	}
}

// ShipmentHistoryWhereInput represents a where input for filtering ShipmentHistory queries.
type ShipmentHistoryWhereInput struct {
	Predicates []predicate.ShipmentHistory  `json:"-"`
	Not        *ShipmentHistoryWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentHistoryWhereInput `json:"or,omitempty"`
	And        []*ShipmentHistoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "type" field predicates.
	Type      *shipmenthistory.Type  `json:"type,omitempty"`
	TypeNEQ   *shipmenthistory.Type  `json:"typeNEQ,omitempty"`
	TypeIn    []shipmenthistory.Type `json:"typeIn,omitempty"`
	TypeNotIn []shipmenthistory.Type `json:"typeNotIn,omitempty"`

	// "change_history" edge predicates.
	HasChangeHistory     *bool                      `json:"hasChangeHistory,omitempty"`
	HasChangeHistoryWith []*ChangeHistoryWhereInput `json:"hasChangeHistoryWith,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentHistoryWhereInput) AddPredicates(predicates ...predicate.ShipmentHistory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentHistoryWhereInput filter on the ShipmentHistoryQuery builder.
func (i *ShipmentHistoryWhereInput) Filter(q *ShipmentHistoryQuery) (*ShipmentHistoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentHistoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentHistoryWhereInput is returned in case the ShipmentHistoryWhereInput is empty.
var ErrEmptyShipmentHistoryWhereInput = errors.New("ent: empty predicate ShipmentHistoryWhereInput")

// P returns a predicate for filtering shipmenthistories.
// An error is returned if the input is empty or invalid.
func (i *ShipmentHistoryWhereInput) P() (predicate.ShipmentHistory, error) {
	var predicates []predicate.ShipmentHistory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmenthistory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentHistory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmenthistory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentHistory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmenthistory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmenthistory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmenthistory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmenthistory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmenthistory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmenthistory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmenthistory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmenthistory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmenthistory.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmenthistory.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmenthistory.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmenthistory.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmenthistory.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmenthistory.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmenthistory.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmenthistory.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmenthistory.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmenthistory.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmenthistory.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmenthistory.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmenthistory.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmenthistory.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Type != nil {
		predicates = append(predicates, shipmenthistory.TypeEQ(*i.Type))
	}
	if i.TypeNEQ != nil {
		predicates = append(predicates, shipmenthistory.TypeNEQ(*i.TypeNEQ))
	}
	if len(i.TypeIn) > 0 {
		predicates = append(predicates, shipmenthistory.TypeIn(i.TypeIn...))
	}
	if len(i.TypeNotIn) > 0 {
		predicates = append(predicates, shipmenthistory.TypeNotIn(i.TypeNotIn...))
	}

	if i.HasChangeHistory != nil {
		p := shipmenthistory.HasChangeHistory()
		if !*i.HasChangeHistory {
			p = shipmenthistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChangeHistoryWith) > 0 {
		with := make([]predicate.ChangeHistory, 0, len(i.HasChangeHistoryWith))
		for _, w := range i.HasChangeHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChangeHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmenthistory.HasChangeHistoryWith(with...))
	}
	if i.HasTenant != nil {
		p := shipmenthistory.HasTenant()
		if !*i.HasTenant {
			p = shipmenthistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmenthistory.HasTenantWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmenthistory.HasShipment()
		if !*i.HasShipment {
			p = shipmenthistory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmenthistory.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentHistoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmenthistory.And(predicates...), nil
	}
}

// ShipmentPalletWhereInput represents a where input for filtering ShipmentPallet queries.
type ShipmentPalletWhereInput struct {
	Predicates []predicate.ShipmentPallet  `json:"-"`
	Not        *ShipmentPalletWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentPalletWhereInput `json:"or,omitempty"`
	And        []*ShipmentPalletWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "barcode" field predicates.
	Barcode             *string  `json:"barcode,omitempty"`
	BarcodeNEQ          *string  `json:"barcodeNEQ,omitempty"`
	BarcodeIn           []string `json:"barcodeIn,omitempty"`
	BarcodeNotIn        []string `json:"barcodeNotIn,omitempty"`
	BarcodeGT           *string  `json:"barcodeGT,omitempty"`
	BarcodeGTE          *string  `json:"barcodeGTE,omitempty"`
	BarcodeLT           *string  `json:"barcodeLT,omitempty"`
	BarcodeLTE          *string  `json:"barcodeLTE,omitempty"`
	BarcodeContains     *string  `json:"barcodeContains,omitempty"`
	BarcodeHasPrefix    *string  `json:"barcodeHasPrefix,omitempty"`
	BarcodeHasSuffix    *string  `json:"barcodeHasSuffix,omitempty"`
	BarcodeEqualFold    *string  `json:"barcodeEqualFold,omitempty"`
	BarcodeContainsFold *string  `json:"barcodeContainsFold,omitempty"`

	// "colli_number" field predicates.
	ColliNumber             *string  `json:"colliNumber,omitempty"`
	ColliNumberNEQ          *string  `json:"colliNumberNEQ,omitempty"`
	ColliNumberIn           []string `json:"colliNumberIn,omitempty"`
	ColliNumberNotIn        []string `json:"colliNumberNotIn,omitempty"`
	ColliNumberGT           *string  `json:"colliNumberGT,omitempty"`
	ColliNumberGTE          *string  `json:"colliNumberGTE,omitempty"`
	ColliNumberLT           *string  `json:"colliNumberLT,omitempty"`
	ColliNumberLTE          *string  `json:"colliNumberLTE,omitempty"`
	ColliNumberContains     *string  `json:"colliNumberContains,omitempty"`
	ColliNumberHasPrefix    *string  `json:"colliNumberHasPrefix,omitempty"`
	ColliNumberHasSuffix    *string  `json:"colliNumberHasSuffix,omitempty"`
	ColliNumberEqualFold    *string  `json:"colliNumberEqualFold,omitempty"`
	ColliNumberContainsFold *string  `json:"colliNumberContainsFold,omitempty"`

	// "carrier_id" field predicates.
	CarrierID             *string  `json:"carrierID,omitempty"`
	CarrierIDNEQ          *string  `json:"carrierIDNEQ,omitempty"`
	CarrierIDIn           []string `json:"carrierIDIn,omitempty"`
	CarrierIDNotIn        []string `json:"carrierIDNotIn,omitempty"`
	CarrierIDGT           *string  `json:"carrierIDGT,omitempty"`
	CarrierIDGTE          *string  `json:"carrierIDGTE,omitempty"`
	CarrierIDLT           *string  `json:"carrierIDLT,omitempty"`
	CarrierIDLTE          *string  `json:"carrierIDLTE,omitempty"`
	CarrierIDContains     *string  `json:"carrierIDContains,omitempty"`
	CarrierIDHasPrefix    *string  `json:"carrierIDHasPrefix,omitempty"`
	CarrierIDHasSuffix    *string  `json:"carrierIDHasSuffix,omitempty"`
	CarrierIDEqualFold    *string  `json:"carrierIDEqualFold,omitempty"`
	CarrierIDContainsFold *string  `json:"carrierIDContainsFold,omitempty"`

	// "label_pdf" field predicates.
	LabelPdf             *string  `json:"labelPdf,omitempty"`
	LabelPdfNEQ          *string  `json:"labelPdfNEQ,omitempty"`
	LabelPdfIn           []string `json:"labelPdfIn,omitempty"`
	LabelPdfNotIn        []string `json:"labelPdfNotIn,omitempty"`
	LabelPdfGT           *string  `json:"labelPdfGT,omitempty"`
	LabelPdfGTE          *string  `json:"labelPdfGTE,omitempty"`
	LabelPdfLT           *string  `json:"labelPdfLT,omitempty"`
	LabelPdfLTE          *string  `json:"labelPdfLTE,omitempty"`
	LabelPdfContains     *string  `json:"labelPdfContains,omitempty"`
	LabelPdfHasPrefix    *string  `json:"labelPdfHasPrefix,omitempty"`
	LabelPdfHasSuffix    *string  `json:"labelPdfHasSuffix,omitempty"`
	LabelPdfIsNil        bool     `json:"labelPdfIsNil,omitempty"`
	LabelPdfNotNil       bool     `json:"labelPdfNotNil,omitempty"`
	LabelPdfEqualFold    *string  `json:"labelPdfEqualFold,omitempty"`
	LabelPdfContainsFold *string  `json:"labelPdfContainsFold,omitempty"`

	// "label_zpl" field predicates.
	LabelZpl             *string  `json:"labelZpl,omitempty"`
	LabelZplNEQ          *string  `json:"labelZplNEQ,omitempty"`
	LabelZplIn           []string `json:"labelZplIn,omitempty"`
	LabelZplNotIn        []string `json:"labelZplNotIn,omitempty"`
	LabelZplGT           *string  `json:"labelZplGT,omitempty"`
	LabelZplGTE          *string  `json:"labelZplGTE,omitempty"`
	LabelZplLT           *string  `json:"labelZplLT,omitempty"`
	LabelZplLTE          *string  `json:"labelZplLTE,omitempty"`
	LabelZplContains     *string  `json:"labelZplContains,omitempty"`
	LabelZplHasPrefix    *string  `json:"labelZplHasPrefix,omitempty"`
	LabelZplHasSuffix    *string  `json:"labelZplHasSuffix,omitempty"`
	LabelZplIsNil        bool     `json:"labelZplIsNil,omitempty"`
	LabelZplNotNil       bool     `json:"labelZplNotNil,omitempty"`
	LabelZplEqualFold    *string  `json:"labelZplEqualFold,omitempty"`
	LabelZplContainsFold *string  `json:"labelZplContainsFold,omitempty"`

	// "status" field predicates.
	Status      *shipmentpallet.Status  `json:"status,omitempty"`
	StatusNEQ   *shipmentpallet.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []shipmentpallet.Status `json:"statusIn,omitempty"`
	StatusNotIn []shipmentpallet.Status `json:"statusNotIn,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "pallet" edge predicates.
	HasPallet     *bool               `json:"hasPallet,omitempty"`
	HasPalletWith []*PalletWhereInput `json:"hasPalletWith,omitempty"`

	// "old_pallet" edge predicates.
	HasOldPallet     *bool               `json:"hasOldPallet,omitempty"`
	HasOldPalletWith []*PalletWhereInput `json:"hasOldPalletWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentPalletWhereInput) AddPredicates(predicates ...predicate.ShipmentPallet) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentPalletWhereInput filter on the ShipmentPalletQuery builder.
func (i *ShipmentPalletWhereInput) Filter(q *ShipmentPalletQuery) (*ShipmentPalletQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentPalletWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentPalletWhereInput is returned in case the ShipmentPalletWhereInput is empty.
var ErrEmptyShipmentPalletWhereInput = errors.New("ent: empty predicate ShipmentPalletWhereInput")

// P returns a predicate for filtering shipmentpallets.
// An error is returned if the input is empty or invalid.
func (i *ShipmentPalletWhereInput) P() (predicate.ShipmentPallet, error) {
	var predicates []predicate.ShipmentPallet
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmentpallet.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentPallet, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmentpallet.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentPallet, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmentpallet.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmentpallet.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmentpallet.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmentpallet.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmentpallet.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmentpallet.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmentpallet.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmentpallet.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmentpallet.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmentpallet.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmentpallet.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmentpallet.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmentpallet.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmentpallet.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmentpallet.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmentpallet.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmentpallet.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmentpallet.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmentpallet.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmentpallet.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmentpallet.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmentpallet.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Barcode != nil {
		predicates = append(predicates, shipmentpallet.BarcodeEQ(*i.Barcode))
	}
	if i.BarcodeNEQ != nil {
		predicates = append(predicates, shipmentpallet.BarcodeNEQ(*i.BarcodeNEQ))
	}
	if len(i.BarcodeIn) > 0 {
		predicates = append(predicates, shipmentpallet.BarcodeIn(i.BarcodeIn...))
	}
	if len(i.BarcodeNotIn) > 0 {
		predicates = append(predicates, shipmentpallet.BarcodeNotIn(i.BarcodeNotIn...))
	}
	if i.BarcodeGT != nil {
		predicates = append(predicates, shipmentpallet.BarcodeGT(*i.BarcodeGT))
	}
	if i.BarcodeGTE != nil {
		predicates = append(predicates, shipmentpallet.BarcodeGTE(*i.BarcodeGTE))
	}
	if i.BarcodeLT != nil {
		predicates = append(predicates, shipmentpallet.BarcodeLT(*i.BarcodeLT))
	}
	if i.BarcodeLTE != nil {
		predicates = append(predicates, shipmentpallet.BarcodeLTE(*i.BarcodeLTE))
	}
	if i.BarcodeContains != nil {
		predicates = append(predicates, shipmentpallet.BarcodeContains(*i.BarcodeContains))
	}
	if i.BarcodeHasPrefix != nil {
		predicates = append(predicates, shipmentpallet.BarcodeHasPrefix(*i.BarcodeHasPrefix))
	}
	if i.BarcodeHasSuffix != nil {
		predicates = append(predicates, shipmentpallet.BarcodeHasSuffix(*i.BarcodeHasSuffix))
	}
	if i.BarcodeEqualFold != nil {
		predicates = append(predicates, shipmentpallet.BarcodeEqualFold(*i.BarcodeEqualFold))
	}
	if i.BarcodeContainsFold != nil {
		predicates = append(predicates, shipmentpallet.BarcodeContainsFold(*i.BarcodeContainsFold))
	}
	if i.ColliNumber != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberEQ(*i.ColliNumber))
	}
	if i.ColliNumberNEQ != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberNEQ(*i.ColliNumberNEQ))
	}
	if len(i.ColliNumberIn) > 0 {
		predicates = append(predicates, shipmentpallet.ColliNumberIn(i.ColliNumberIn...))
	}
	if len(i.ColliNumberNotIn) > 0 {
		predicates = append(predicates, shipmentpallet.ColliNumberNotIn(i.ColliNumberNotIn...))
	}
	if i.ColliNumberGT != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberGT(*i.ColliNumberGT))
	}
	if i.ColliNumberGTE != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberGTE(*i.ColliNumberGTE))
	}
	if i.ColliNumberLT != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberLT(*i.ColliNumberLT))
	}
	if i.ColliNumberLTE != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberLTE(*i.ColliNumberLTE))
	}
	if i.ColliNumberContains != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberContains(*i.ColliNumberContains))
	}
	if i.ColliNumberHasPrefix != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberHasPrefix(*i.ColliNumberHasPrefix))
	}
	if i.ColliNumberHasSuffix != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberHasSuffix(*i.ColliNumberHasSuffix))
	}
	if i.ColliNumberEqualFold != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberEqualFold(*i.ColliNumberEqualFold))
	}
	if i.ColliNumberContainsFold != nil {
		predicates = append(predicates, shipmentpallet.ColliNumberContainsFold(*i.ColliNumberContainsFold))
	}
	if i.CarrierID != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDEQ(*i.CarrierID))
	}
	if i.CarrierIDNEQ != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDNEQ(*i.CarrierIDNEQ))
	}
	if len(i.CarrierIDIn) > 0 {
		predicates = append(predicates, shipmentpallet.CarrierIDIn(i.CarrierIDIn...))
	}
	if len(i.CarrierIDNotIn) > 0 {
		predicates = append(predicates, shipmentpallet.CarrierIDNotIn(i.CarrierIDNotIn...))
	}
	if i.CarrierIDGT != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDGT(*i.CarrierIDGT))
	}
	if i.CarrierIDGTE != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDGTE(*i.CarrierIDGTE))
	}
	if i.CarrierIDLT != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDLT(*i.CarrierIDLT))
	}
	if i.CarrierIDLTE != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDLTE(*i.CarrierIDLTE))
	}
	if i.CarrierIDContains != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDContains(*i.CarrierIDContains))
	}
	if i.CarrierIDHasPrefix != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDHasPrefix(*i.CarrierIDHasPrefix))
	}
	if i.CarrierIDHasSuffix != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDHasSuffix(*i.CarrierIDHasSuffix))
	}
	if i.CarrierIDEqualFold != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDEqualFold(*i.CarrierIDEqualFold))
	}
	if i.CarrierIDContainsFold != nil {
		predicates = append(predicates, shipmentpallet.CarrierIDContainsFold(*i.CarrierIDContainsFold))
	}
	if i.LabelPdf != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfEQ(*i.LabelPdf))
	}
	if i.LabelPdfNEQ != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfNEQ(*i.LabelPdfNEQ))
	}
	if len(i.LabelPdfIn) > 0 {
		predicates = append(predicates, shipmentpallet.LabelPdfIn(i.LabelPdfIn...))
	}
	if len(i.LabelPdfNotIn) > 0 {
		predicates = append(predicates, shipmentpallet.LabelPdfNotIn(i.LabelPdfNotIn...))
	}
	if i.LabelPdfGT != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfGT(*i.LabelPdfGT))
	}
	if i.LabelPdfGTE != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfGTE(*i.LabelPdfGTE))
	}
	if i.LabelPdfLT != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfLT(*i.LabelPdfLT))
	}
	if i.LabelPdfLTE != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfLTE(*i.LabelPdfLTE))
	}
	if i.LabelPdfContains != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfContains(*i.LabelPdfContains))
	}
	if i.LabelPdfHasPrefix != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfHasPrefix(*i.LabelPdfHasPrefix))
	}
	if i.LabelPdfHasSuffix != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfHasSuffix(*i.LabelPdfHasSuffix))
	}
	if i.LabelPdfIsNil {
		predicates = append(predicates, shipmentpallet.LabelPdfIsNil())
	}
	if i.LabelPdfNotNil {
		predicates = append(predicates, shipmentpallet.LabelPdfNotNil())
	}
	if i.LabelPdfEqualFold != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfEqualFold(*i.LabelPdfEqualFold))
	}
	if i.LabelPdfContainsFold != nil {
		predicates = append(predicates, shipmentpallet.LabelPdfContainsFold(*i.LabelPdfContainsFold))
	}
	if i.LabelZpl != nil {
		predicates = append(predicates, shipmentpallet.LabelZplEQ(*i.LabelZpl))
	}
	if i.LabelZplNEQ != nil {
		predicates = append(predicates, shipmentpallet.LabelZplNEQ(*i.LabelZplNEQ))
	}
	if len(i.LabelZplIn) > 0 {
		predicates = append(predicates, shipmentpallet.LabelZplIn(i.LabelZplIn...))
	}
	if len(i.LabelZplNotIn) > 0 {
		predicates = append(predicates, shipmentpallet.LabelZplNotIn(i.LabelZplNotIn...))
	}
	if i.LabelZplGT != nil {
		predicates = append(predicates, shipmentpallet.LabelZplGT(*i.LabelZplGT))
	}
	if i.LabelZplGTE != nil {
		predicates = append(predicates, shipmentpallet.LabelZplGTE(*i.LabelZplGTE))
	}
	if i.LabelZplLT != nil {
		predicates = append(predicates, shipmentpallet.LabelZplLT(*i.LabelZplLT))
	}
	if i.LabelZplLTE != nil {
		predicates = append(predicates, shipmentpallet.LabelZplLTE(*i.LabelZplLTE))
	}
	if i.LabelZplContains != nil {
		predicates = append(predicates, shipmentpallet.LabelZplContains(*i.LabelZplContains))
	}
	if i.LabelZplHasPrefix != nil {
		predicates = append(predicates, shipmentpallet.LabelZplHasPrefix(*i.LabelZplHasPrefix))
	}
	if i.LabelZplHasSuffix != nil {
		predicates = append(predicates, shipmentpallet.LabelZplHasSuffix(*i.LabelZplHasSuffix))
	}
	if i.LabelZplIsNil {
		predicates = append(predicates, shipmentpallet.LabelZplIsNil())
	}
	if i.LabelZplNotNil {
		predicates = append(predicates, shipmentpallet.LabelZplNotNil())
	}
	if i.LabelZplEqualFold != nil {
		predicates = append(predicates, shipmentpallet.LabelZplEqualFold(*i.LabelZplEqualFold))
	}
	if i.LabelZplContainsFold != nil {
		predicates = append(predicates, shipmentpallet.LabelZplContainsFold(*i.LabelZplContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, shipmentpallet.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, shipmentpallet.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, shipmentpallet.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, shipmentpallet.StatusNotIn(i.StatusNotIn...))
	}

	if i.HasTenant != nil {
		p := shipmentpallet.HasTenant()
		if !*i.HasTenant {
			p = shipmentpallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentpallet.HasTenantWith(with...))
	}
	if i.HasPallet != nil {
		p := shipmentpallet.HasPallet()
		if !*i.HasPallet {
			p = shipmentpallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPalletWith) > 0 {
		with := make([]predicate.Pallet, 0, len(i.HasPalletWith))
		for _, w := range i.HasPalletWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPalletWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentpallet.HasPalletWith(with...))
	}
	if i.HasOldPallet != nil {
		p := shipmentpallet.HasOldPallet()
		if !*i.HasOldPallet {
			p = shipmentpallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOldPalletWith) > 0 {
		with := make([]predicate.Pallet, 0, len(i.HasOldPalletWith))
		for _, w := range i.HasOldPalletWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOldPalletWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentpallet.HasOldPalletWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmentpallet.HasShipment()
		if !*i.HasShipment {
			p = shipmentpallet.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentpallet.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentPalletWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmentpallet.And(predicates...), nil
	}
}

// ShipmentParcelWhereInput represents a where input for filtering ShipmentParcel queries.
type ShipmentParcelWhereInput struct {
	Predicates []predicate.ShipmentParcel  `json:"-"`
	Not        *ShipmentParcelWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentParcelWhereInput `json:"or,omitempty"`
	And        []*ShipmentParcelWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "item_id" field predicates.
	ItemID             *string  `json:"itemID,omitempty"`
	ItemIDNEQ          *string  `json:"itemIDNEQ,omitempty"`
	ItemIDIn           []string `json:"itemIDIn,omitempty"`
	ItemIDNotIn        []string `json:"itemIDNotIn,omitempty"`
	ItemIDGT           *string  `json:"itemIDGT,omitempty"`
	ItemIDGTE          *string  `json:"itemIDGTE,omitempty"`
	ItemIDLT           *string  `json:"itemIDLT,omitempty"`
	ItemIDLTE          *string  `json:"itemIDLTE,omitempty"`
	ItemIDContains     *string  `json:"itemIDContains,omitempty"`
	ItemIDHasPrefix    *string  `json:"itemIDHasPrefix,omitempty"`
	ItemIDHasSuffix    *string  `json:"itemIDHasSuffix,omitempty"`
	ItemIDIsNil        bool     `json:"itemIDIsNil,omitempty"`
	ItemIDNotNil       bool     `json:"itemIDNotNil,omitempty"`
	ItemIDEqualFold    *string  `json:"itemIDEqualFold,omitempty"`
	ItemIDContainsFold *string  `json:"itemIDContainsFold,omitempty"`

	// "status" field predicates.
	Status      *shipmentparcel.Status  `json:"status,omitempty"`
	StatusNEQ   *shipmentparcel.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []shipmentparcel.Status `json:"statusIn,omitempty"`
	StatusNotIn []shipmentparcel.Status `json:"statusNotIn,omitempty"`

	// "expected_at" field predicates.
	ExpectedAt       *time.Time  `json:"expectedAt,omitempty"`
	ExpectedAtNEQ    *time.Time  `json:"expectedAtNEQ,omitempty"`
	ExpectedAtIn     []time.Time `json:"expectedAtIn,omitempty"`
	ExpectedAtNotIn  []time.Time `json:"expectedAtNotIn,omitempty"`
	ExpectedAtGT     *time.Time  `json:"expectedAtGT,omitempty"`
	ExpectedAtGTE    *time.Time  `json:"expectedAtGTE,omitempty"`
	ExpectedAtLT     *time.Time  `json:"expectedAtLT,omitempty"`
	ExpectedAtLTE    *time.Time  `json:"expectedAtLTE,omitempty"`
	ExpectedAtIsNil  bool        `json:"expectedAtIsNil,omitempty"`
	ExpectedAtNotNil bool        `json:"expectedAtNotNil,omitempty"`

	// "fulfillment_synced_at" field predicates.
	FulfillmentSyncedAt       *time.Time  `json:"fulfillmentSyncedAt,omitempty"`
	FulfillmentSyncedAtNEQ    *time.Time  `json:"fulfillmentSyncedAtNEQ,omitempty"`
	FulfillmentSyncedAtIn     []time.Time `json:"fulfillmentSyncedAtIn,omitempty"`
	FulfillmentSyncedAtNotIn  []time.Time `json:"fulfillmentSyncedAtNotIn,omitempty"`
	FulfillmentSyncedAtGT     *time.Time  `json:"fulfillmentSyncedAtGT,omitempty"`
	FulfillmentSyncedAtGTE    *time.Time  `json:"fulfillmentSyncedAtGTE,omitempty"`
	FulfillmentSyncedAtLT     *time.Time  `json:"fulfillmentSyncedAtLT,omitempty"`
	FulfillmentSyncedAtLTE    *time.Time  `json:"fulfillmentSyncedAtLTE,omitempty"`
	FulfillmentSyncedAtIsNil  bool        `json:"fulfillmentSyncedAtIsNil,omitempty"`
	FulfillmentSyncedAtNotNil bool        `json:"fulfillmentSyncedAtNotNil,omitempty"`

	// "cancel_synced_at" field predicates.
	CancelSyncedAt       *time.Time  `json:"cancelSyncedAt,omitempty"`
	CancelSyncedAtNEQ    *time.Time  `json:"cancelSyncedAtNEQ,omitempty"`
	CancelSyncedAtIn     []time.Time `json:"cancelSyncedAtIn,omitempty"`
	CancelSyncedAtNotIn  []time.Time `json:"cancelSyncedAtNotIn,omitempty"`
	CancelSyncedAtGT     *time.Time  `json:"cancelSyncedAtGT,omitempty"`
	CancelSyncedAtGTE    *time.Time  `json:"cancelSyncedAtGTE,omitempty"`
	CancelSyncedAtLT     *time.Time  `json:"cancelSyncedAtLT,omitempty"`
	CancelSyncedAtLTE    *time.Time  `json:"cancelSyncedAtLTE,omitempty"`
	CancelSyncedAtIsNil  bool        `json:"cancelSyncedAtIsNil,omitempty"`
	CancelSyncedAtNotNil bool        `json:"cancelSyncedAtNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`

	// "colli" edge predicates.
	HasColli     *bool              `json:"hasColli,omitempty"`
	HasColliWith []*ColliWhereInput `json:"hasColliWith,omitempty"`

	// "old_colli" edge predicates.
	HasOldColli     *bool              `json:"hasOldColli,omitempty"`
	HasOldColliWith []*ColliWhereInput `json:"hasOldColliWith,omitempty"`

	// "workspace_recent_scan" edge predicates.
	HasWorkspaceRecentScan     *bool                            `json:"hasWorkspaceRecentScan,omitempty"`
	HasWorkspaceRecentScanWith []*WorkspaceRecentScanWhereInput `json:"hasWorkspaceRecentScanWith,omitempty"`

	// "packaging" edge predicates.
	HasPackaging     *bool                  `json:"hasPackaging,omitempty"`
	HasPackagingWith []*PackagingWhereInput `json:"hasPackagingWith,omitempty"`

	// "print_job" edge predicates.
	HasPrintJob     *bool                 `json:"hasPrintJob,omitempty"`
	HasPrintJobWith []*PrintJobWhereInput `json:"hasPrintJobWith,omitempty"`

	// "document_file" edge predicates.
	HasDocumentFile     *bool                     `json:"hasDocumentFile,omitempty"`
	HasDocumentFileWith []*DocumentFileWhereInput `json:"hasDocumentFileWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentParcelWhereInput) AddPredicates(predicates ...predicate.ShipmentParcel) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentParcelWhereInput filter on the ShipmentParcelQuery builder.
func (i *ShipmentParcelWhereInput) Filter(q *ShipmentParcelQuery) (*ShipmentParcelQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentParcelWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentParcelWhereInput is returned in case the ShipmentParcelWhereInput is empty.
var ErrEmptyShipmentParcelWhereInput = errors.New("ent: empty predicate ShipmentParcelWhereInput")

// P returns a predicate for filtering shipmentparcels.
// An error is returned if the input is empty or invalid.
func (i *ShipmentParcelWhereInput) P() (predicate.ShipmentParcel, error) {
	var predicates []predicate.ShipmentParcel
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmentparcel.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentParcel, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmentparcel.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentParcel, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmentparcel.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmentparcel.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmentparcel.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmentparcel.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmentparcel.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmentparcel.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmentparcel.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmentparcel.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmentparcel.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmentparcel.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmentparcel.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmentparcel.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmentparcel.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmentparcel.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmentparcel.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmentparcel.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmentparcel.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmentparcel.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmentparcel.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmentparcel.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmentparcel.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmentparcel.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ItemID != nil {
		predicates = append(predicates, shipmentparcel.ItemIDEQ(*i.ItemID))
	}
	if i.ItemIDNEQ != nil {
		predicates = append(predicates, shipmentparcel.ItemIDNEQ(*i.ItemIDNEQ))
	}
	if len(i.ItemIDIn) > 0 {
		predicates = append(predicates, shipmentparcel.ItemIDIn(i.ItemIDIn...))
	}
	if len(i.ItemIDNotIn) > 0 {
		predicates = append(predicates, shipmentparcel.ItemIDNotIn(i.ItemIDNotIn...))
	}
	if i.ItemIDGT != nil {
		predicates = append(predicates, shipmentparcel.ItemIDGT(*i.ItemIDGT))
	}
	if i.ItemIDGTE != nil {
		predicates = append(predicates, shipmentparcel.ItemIDGTE(*i.ItemIDGTE))
	}
	if i.ItemIDLT != nil {
		predicates = append(predicates, shipmentparcel.ItemIDLT(*i.ItemIDLT))
	}
	if i.ItemIDLTE != nil {
		predicates = append(predicates, shipmentparcel.ItemIDLTE(*i.ItemIDLTE))
	}
	if i.ItemIDContains != nil {
		predicates = append(predicates, shipmentparcel.ItemIDContains(*i.ItemIDContains))
	}
	if i.ItemIDHasPrefix != nil {
		predicates = append(predicates, shipmentparcel.ItemIDHasPrefix(*i.ItemIDHasPrefix))
	}
	if i.ItemIDHasSuffix != nil {
		predicates = append(predicates, shipmentparcel.ItemIDHasSuffix(*i.ItemIDHasSuffix))
	}
	if i.ItemIDIsNil {
		predicates = append(predicates, shipmentparcel.ItemIDIsNil())
	}
	if i.ItemIDNotNil {
		predicates = append(predicates, shipmentparcel.ItemIDNotNil())
	}
	if i.ItemIDEqualFold != nil {
		predicates = append(predicates, shipmentparcel.ItemIDEqualFold(*i.ItemIDEqualFold))
	}
	if i.ItemIDContainsFold != nil {
		predicates = append(predicates, shipmentparcel.ItemIDContainsFold(*i.ItemIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, shipmentparcel.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, shipmentparcel.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, shipmentparcel.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, shipmentparcel.StatusNotIn(i.StatusNotIn...))
	}
	if i.ExpectedAt != nil {
		predicates = append(predicates, shipmentparcel.ExpectedAtEQ(*i.ExpectedAt))
	}
	if i.ExpectedAtNEQ != nil {
		predicates = append(predicates, shipmentparcel.ExpectedAtNEQ(*i.ExpectedAtNEQ))
	}
	if len(i.ExpectedAtIn) > 0 {
		predicates = append(predicates, shipmentparcel.ExpectedAtIn(i.ExpectedAtIn...))
	}
	if len(i.ExpectedAtNotIn) > 0 {
		predicates = append(predicates, shipmentparcel.ExpectedAtNotIn(i.ExpectedAtNotIn...))
	}
	if i.ExpectedAtGT != nil {
		predicates = append(predicates, shipmentparcel.ExpectedAtGT(*i.ExpectedAtGT))
	}
	if i.ExpectedAtGTE != nil {
		predicates = append(predicates, shipmentparcel.ExpectedAtGTE(*i.ExpectedAtGTE))
	}
	if i.ExpectedAtLT != nil {
		predicates = append(predicates, shipmentparcel.ExpectedAtLT(*i.ExpectedAtLT))
	}
	if i.ExpectedAtLTE != nil {
		predicates = append(predicates, shipmentparcel.ExpectedAtLTE(*i.ExpectedAtLTE))
	}
	if i.ExpectedAtIsNil {
		predicates = append(predicates, shipmentparcel.ExpectedAtIsNil())
	}
	if i.ExpectedAtNotNil {
		predicates = append(predicates, shipmentparcel.ExpectedAtNotNil())
	}
	if i.FulfillmentSyncedAt != nil {
		predicates = append(predicates, shipmentparcel.FulfillmentSyncedAtEQ(*i.FulfillmentSyncedAt))
	}
	if i.FulfillmentSyncedAtNEQ != nil {
		predicates = append(predicates, shipmentparcel.FulfillmentSyncedAtNEQ(*i.FulfillmentSyncedAtNEQ))
	}
	if len(i.FulfillmentSyncedAtIn) > 0 {
		predicates = append(predicates, shipmentparcel.FulfillmentSyncedAtIn(i.FulfillmentSyncedAtIn...))
	}
	if len(i.FulfillmentSyncedAtNotIn) > 0 {
		predicates = append(predicates, shipmentparcel.FulfillmentSyncedAtNotIn(i.FulfillmentSyncedAtNotIn...))
	}
	if i.FulfillmentSyncedAtGT != nil {
		predicates = append(predicates, shipmentparcel.FulfillmentSyncedAtGT(*i.FulfillmentSyncedAtGT))
	}
	if i.FulfillmentSyncedAtGTE != nil {
		predicates = append(predicates, shipmentparcel.FulfillmentSyncedAtGTE(*i.FulfillmentSyncedAtGTE))
	}
	if i.FulfillmentSyncedAtLT != nil {
		predicates = append(predicates, shipmentparcel.FulfillmentSyncedAtLT(*i.FulfillmentSyncedAtLT))
	}
	if i.FulfillmentSyncedAtLTE != nil {
		predicates = append(predicates, shipmentparcel.FulfillmentSyncedAtLTE(*i.FulfillmentSyncedAtLTE))
	}
	if i.FulfillmentSyncedAtIsNil {
		predicates = append(predicates, shipmentparcel.FulfillmentSyncedAtIsNil())
	}
	if i.FulfillmentSyncedAtNotNil {
		predicates = append(predicates, shipmentparcel.FulfillmentSyncedAtNotNil())
	}
	if i.CancelSyncedAt != nil {
		predicates = append(predicates, shipmentparcel.CancelSyncedAtEQ(*i.CancelSyncedAt))
	}
	if i.CancelSyncedAtNEQ != nil {
		predicates = append(predicates, shipmentparcel.CancelSyncedAtNEQ(*i.CancelSyncedAtNEQ))
	}
	if len(i.CancelSyncedAtIn) > 0 {
		predicates = append(predicates, shipmentparcel.CancelSyncedAtIn(i.CancelSyncedAtIn...))
	}
	if len(i.CancelSyncedAtNotIn) > 0 {
		predicates = append(predicates, shipmentparcel.CancelSyncedAtNotIn(i.CancelSyncedAtNotIn...))
	}
	if i.CancelSyncedAtGT != nil {
		predicates = append(predicates, shipmentparcel.CancelSyncedAtGT(*i.CancelSyncedAtGT))
	}
	if i.CancelSyncedAtGTE != nil {
		predicates = append(predicates, shipmentparcel.CancelSyncedAtGTE(*i.CancelSyncedAtGTE))
	}
	if i.CancelSyncedAtLT != nil {
		predicates = append(predicates, shipmentparcel.CancelSyncedAtLT(*i.CancelSyncedAtLT))
	}
	if i.CancelSyncedAtLTE != nil {
		predicates = append(predicates, shipmentparcel.CancelSyncedAtLTE(*i.CancelSyncedAtLTE))
	}
	if i.CancelSyncedAtIsNil {
		predicates = append(predicates, shipmentparcel.CancelSyncedAtIsNil())
	}
	if i.CancelSyncedAtNotNil {
		predicates = append(predicates, shipmentparcel.CancelSyncedAtNotNil())
	}

	if i.HasTenant != nil {
		p := shipmentparcel.HasTenant()
		if !*i.HasTenant {
			p = shipmentparcel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentparcel.HasTenantWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmentparcel.HasShipment()
		if !*i.HasShipment {
			p = shipmentparcel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentparcel.HasShipmentWith(with...))
	}
	if i.HasColli != nil {
		p := shipmentparcel.HasColli()
		if !*i.HasColli {
			p = shipmentparcel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasColliWith))
		for _, w := range i.HasColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentparcel.HasColliWith(with...))
	}
	if i.HasOldColli != nil {
		p := shipmentparcel.HasOldColli()
		if !*i.HasOldColli {
			p = shipmentparcel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOldColliWith) > 0 {
		with := make([]predicate.Colli, 0, len(i.HasOldColliWith))
		for _, w := range i.HasOldColliWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOldColliWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentparcel.HasOldColliWith(with...))
	}
	if i.HasWorkspaceRecentScan != nil {
		p := shipmentparcel.HasWorkspaceRecentScan()
		if !*i.HasWorkspaceRecentScan {
			p = shipmentparcel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkspaceRecentScanWith) > 0 {
		with := make([]predicate.WorkspaceRecentScan, 0, len(i.HasWorkspaceRecentScanWith))
		for _, w := range i.HasWorkspaceRecentScanWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkspaceRecentScanWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentparcel.HasWorkspaceRecentScanWith(with...))
	}
	if i.HasPackaging != nil {
		p := shipmentparcel.HasPackaging()
		if !*i.HasPackaging {
			p = shipmentparcel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPackagingWith) > 0 {
		with := make([]predicate.Packaging, 0, len(i.HasPackagingWith))
		for _, w := range i.HasPackagingWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPackagingWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentparcel.HasPackagingWith(with...))
	}
	if i.HasPrintJob != nil {
		p := shipmentparcel.HasPrintJob()
		if !*i.HasPrintJob {
			p = shipmentparcel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPrintJobWith) > 0 {
		with := make([]predicate.PrintJob, 0, len(i.HasPrintJobWith))
		for _, w := range i.HasPrintJobWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPrintJobWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentparcel.HasPrintJobWith(with...))
	}
	if i.HasDocumentFile != nil {
		p := shipmentparcel.HasDocumentFile()
		if !*i.HasDocumentFile {
			p = shipmentparcel.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDocumentFileWith) > 0 {
		with := make([]predicate.DocumentFile, 0, len(i.HasDocumentFileWith))
		for _, w := range i.HasDocumentFileWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDocumentFileWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentparcel.HasDocumentFileWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentParcelWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmentparcel.And(predicates...), nil
	}
}

// ShipmentPostNordWhereInput represents a where input for filtering ShipmentPostNord queries.
type ShipmentPostNordWhereInput struct {
	Predicates []predicate.ShipmentPostNord  `json:"-"`
	Not        *ShipmentPostNordWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentPostNordWhereInput `json:"or,omitempty"`
	And        []*ShipmentPostNordWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "booking_id" field predicates.
	BookingID             *string  `json:"bookingID,omitempty"`
	BookingIDNEQ          *string  `json:"bookingIDNEQ,omitempty"`
	BookingIDIn           []string `json:"bookingIDIn,omitempty"`
	BookingIDNotIn        []string `json:"bookingIDNotIn,omitempty"`
	BookingIDGT           *string  `json:"bookingIDGT,omitempty"`
	BookingIDGTE          *string  `json:"bookingIDGTE,omitempty"`
	BookingIDLT           *string  `json:"bookingIDLT,omitempty"`
	BookingIDLTE          *string  `json:"bookingIDLTE,omitempty"`
	BookingIDContains     *string  `json:"bookingIDContains,omitempty"`
	BookingIDHasPrefix    *string  `json:"bookingIDHasPrefix,omitempty"`
	BookingIDHasSuffix    *string  `json:"bookingIDHasSuffix,omitempty"`
	BookingIDEqualFold    *string  `json:"bookingIDEqualFold,omitempty"`
	BookingIDContainsFold *string  `json:"bookingIDContainsFold,omitempty"`

	// "item_id" field predicates.
	ItemID             *string  `json:"itemID,omitempty"`
	ItemIDNEQ          *string  `json:"itemIDNEQ,omitempty"`
	ItemIDIn           []string `json:"itemIDIn,omitempty"`
	ItemIDNotIn        []string `json:"itemIDNotIn,omitempty"`
	ItemIDGT           *string  `json:"itemIDGT,omitempty"`
	ItemIDGTE          *string  `json:"itemIDGTE,omitempty"`
	ItemIDLT           *string  `json:"itemIDLT,omitempty"`
	ItemIDLTE          *string  `json:"itemIDLTE,omitempty"`
	ItemIDContains     *string  `json:"itemIDContains,omitempty"`
	ItemIDHasPrefix    *string  `json:"itemIDHasPrefix,omitempty"`
	ItemIDHasSuffix    *string  `json:"itemIDHasSuffix,omitempty"`
	ItemIDEqualFold    *string  `json:"itemIDEqualFold,omitempty"`
	ItemIDContainsFold *string  `json:"itemIDContainsFold,omitempty"`

	// "shipment_reference_no" field predicates.
	ShipmentReferenceNo             *string  `json:"shipmentReferenceNo,omitempty"`
	ShipmentReferenceNoNEQ          *string  `json:"shipmentReferenceNoNEQ,omitempty"`
	ShipmentReferenceNoIn           []string `json:"shipmentReferenceNoIn,omitempty"`
	ShipmentReferenceNoNotIn        []string `json:"shipmentReferenceNoNotIn,omitempty"`
	ShipmentReferenceNoGT           *string  `json:"shipmentReferenceNoGT,omitempty"`
	ShipmentReferenceNoGTE          *string  `json:"shipmentReferenceNoGTE,omitempty"`
	ShipmentReferenceNoLT           *string  `json:"shipmentReferenceNoLT,omitempty"`
	ShipmentReferenceNoLTE          *string  `json:"shipmentReferenceNoLTE,omitempty"`
	ShipmentReferenceNoContains     *string  `json:"shipmentReferenceNoContains,omitempty"`
	ShipmentReferenceNoHasPrefix    *string  `json:"shipmentReferenceNoHasPrefix,omitempty"`
	ShipmentReferenceNoHasSuffix    *string  `json:"shipmentReferenceNoHasSuffix,omitempty"`
	ShipmentReferenceNoEqualFold    *string  `json:"shipmentReferenceNoEqualFold,omitempty"`
	ShipmentReferenceNoContainsFold *string  `json:"shipmentReferenceNoContainsFold,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentPostNordWhereInput) AddPredicates(predicates ...predicate.ShipmentPostNord) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentPostNordWhereInput filter on the ShipmentPostNordQuery builder.
func (i *ShipmentPostNordWhereInput) Filter(q *ShipmentPostNordQuery) (*ShipmentPostNordQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentPostNordWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentPostNordWhereInput is returned in case the ShipmentPostNordWhereInput is empty.
var ErrEmptyShipmentPostNordWhereInput = errors.New("ent: empty predicate ShipmentPostNordWhereInput")

// P returns a predicate for filtering shipmentpostnords.
// An error is returned if the input is empty or invalid.
func (i *ShipmentPostNordWhereInput) P() (predicate.ShipmentPostNord, error) {
	var predicates []predicate.ShipmentPostNord
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmentpostnord.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentPostNord, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmentpostnord.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentPostNord, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmentpostnord.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmentpostnord.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmentpostnord.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmentpostnord.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmentpostnord.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmentpostnord.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmentpostnord.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmentpostnord.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmentpostnord.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmentpostnord.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmentpostnord.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmentpostnord.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.BookingID != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDEQ(*i.BookingID))
	}
	if i.BookingIDNEQ != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDNEQ(*i.BookingIDNEQ))
	}
	if len(i.BookingIDIn) > 0 {
		predicates = append(predicates, shipmentpostnord.BookingIDIn(i.BookingIDIn...))
	}
	if len(i.BookingIDNotIn) > 0 {
		predicates = append(predicates, shipmentpostnord.BookingIDNotIn(i.BookingIDNotIn...))
	}
	if i.BookingIDGT != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDGT(*i.BookingIDGT))
	}
	if i.BookingIDGTE != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDGTE(*i.BookingIDGTE))
	}
	if i.BookingIDLT != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDLT(*i.BookingIDLT))
	}
	if i.BookingIDLTE != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDLTE(*i.BookingIDLTE))
	}
	if i.BookingIDContains != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDContains(*i.BookingIDContains))
	}
	if i.BookingIDHasPrefix != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDHasPrefix(*i.BookingIDHasPrefix))
	}
	if i.BookingIDHasSuffix != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDHasSuffix(*i.BookingIDHasSuffix))
	}
	if i.BookingIDEqualFold != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDEqualFold(*i.BookingIDEqualFold))
	}
	if i.BookingIDContainsFold != nil {
		predicates = append(predicates, shipmentpostnord.BookingIDContainsFold(*i.BookingIDContainsFold))
	}
	if i.ItemID != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDEQ(*i.ItemID))
	}
	if i.ItemIDNEQ != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDNEQ(*i.ItemIDNEQ))
	}
	if len(i.ItemIDIn) > 0 {
		predicates = append(predicates, shipmentpostnord.ItemIDIn(i.ItemIDIn...))
	}
	if len(i.ItemIDNotIn) > 0 {
		predicates = append(predicates, shipmentpostnord.ItemIDNotIn(i.ItemIDNotIn...))
	}
	if i.ItemIDGT != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDGT(*i.ItemIDGT))
	}
	if i.ItemIDGTE != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDGTE(*i.ItemIDGTE))
	}
	if i.ItemIDLT != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDLT(*i.ItemIDLT))
	}
	if i.ItemIDLTE != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDLTE(*i.ItemIDLTE))
	}
	if i.ItemIDContains != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDContains(*i.ItemIDContains))
	}
	if i.ItemIDHasPrefix != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDHasPrefix(*i.ItemIDHasPrefix))
	}
	if i.ItemIDHasSuffix != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDHasSuffix(*i.ItemIDHasSuffix))
	}
	if i.ItemIDEqualFold != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDEqualFold(*i.ItemIDEqualFold))
	}
	if i.ItemIDContainsFold != nil {
		predicates = append(predicates, shipmentpostnord.ItemIDContainsFold(*i.ItemIDContainsFold))
	}
	if i.ShipmentReferenceNo != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoEQ(*i.ShipmentReferenceNo))
	}
	if i.ShipmentReferenceNoNEQ != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoNEQ(*i.ShipmentReferenceNoNEQ))
	}
	if len(i.ShipmentReferenceNoIn) > 0 {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoIn(i.ShipmentReferenceNoIn...))
	}
	if len(i.ShipmentReferenceNoNotIn) > 0 {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoNotIn(i.ShipmentReferenceNoNotIn...))
	}
	if i.ShipmentReferenceNoGT != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoGT(*i.ShipmentReferenceNoGT))
	}
	if i.ShipmentReferenceNoGTE != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoGTE(*i.ShipmentReferenceNoGTE))
	}
	if i.ShipmentReferenceNoLT != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoLT(*i.ShipmentReferenceNoLT))
	}
	if i.ShipmentReferenceNoLTE != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoLTE(*i.ShipmentReferenceNoLTE))
	}
	if i.ShipmentReferenceNoContains != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoContains(*i.ShipmentReferenceNoContains))
	}
	if i.ShipmentReferenceNoHasPrefix != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoHasPrefix(*i.ShipmentReferenceNoHasPrefix))
	}
	if i.ShipmentReferenceNoHasSuffix != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoHasSuffix(*i.ShipmentReferenceNoHasSuffix))
	}
	if i.ShipmentReferenceNoEqualFold != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoEqualFold(*i.ShipmentReferenceNoEqualFold))
	}
	if i.ShipmentReferenceNoContainsFold != nil {
		predicates = append(predicates, shipmentpostnord.ShipmentReferenceNoContainsFold(*i.ShipmentReferenceNoContainsFold))
	}

	if i.HasTenant != nil {
		p := shipmentpostnord.HasTenant()
		if !*i.HasTenant {
			p = shipmentpostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentpostnord.HasTenantWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmentpostnord.HasShipment()
		if !*i.HasShipment {
			p = shipmentpostnord.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentpostnord.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentPostNordWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmentpostnord.And(predicates...), nil
	}
}

// ShipmentUSPSWhereInput represents a where input for filtering ShipmentUSPS queries.
type ShipmentUSPSWhereInput struct {
	Predicates []predicate.ShipmentUSPS  `json:"-"`
	Not        *ShipmentUSPSWhereInput   `json:"not,omitempty"`
	Or         []*ShipmentUSPSWhereInput `json:"or,omitempty"`
	And        []*ShipmentUSPSWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "tracking_number" field predicates.
	TrackingNumber             *string  `json:"trackingNumber,omitempty"`
	TrackingNumberNEQ          *string  `json:"trackingNumberNEQ,omitempty"`
	TrackingNumberIn           []string `json:"trackingNumberIn,omitempty"`
	TrackingNumberNotIn        []string `json:"trackingNumberNotIn,omitempty"`
	TrackingNumberGT           *string  `json:"trackingNumberGT,omitempty"`
	TrackingNumberGTE          *string  `json:"trackingNumberGTE,omitempty"`
	TrackingNumberLT           *string  `json:"trackingNumberLT,omitempty"`
	TrackingNumberLTE          *string  `json:"trackingNumberLTE,omitempty"`
	TrackingNumberContains     *string  `json:"trackingNumberContains,omitempty"`
	TrackingNumberHasPrefix    *string  `json:"trackingNumberHasPrefix,omitempty"`
	TrackingNumberHasSuffix    *string  `json:"trackingNumberHasSuffix,omitempty"`
	TrackingNumberIsNil        bool     `json:"trackingNumberIsNil,omitempty"`
	TrackingNumberNotNil       bool     `json:"trackingNumberNotNil,omitempty"`
	TrackingNumberEqualFold    *string  `json:"trackingNumberEqualFold,omitempty"`
	TrackingNumberContainsFold *string  `json:"trackingNumberContainsFold,omitempty"`

	// "postage" field predicates.
	Postage       *float64  `json:"postage,omitempty"`
	PostageNEQ    *float64  `json:"postageNEQ,omitempty"`
	PostageIn     []float64 `json:"postageIn,omitempty"`
	PostageNotIn  []float64 `json:"postageNotIn,omitempty"`
	PostageGT     *float64  `json:"postageGT,omitempty"`
	PostageGTE    *float64  `json:"postageGTE,omitempty"`
	PostageLT     *float64  `json:"postageLT,omitempty"`
	PostageLTE    *float64  `json:"postageLTE,omitempty"`
	PostageIsNil  bool      `json:"postageIsNil,omitempty"`
	PostageNotNil bool      `json:"postageNotNil,omitempty"`

	// "scheduled_delivery_date" field predicates.
	ScheduledDeliveryDate       *time.Time  `json:"scheduledDeliveryDate,omitempty"`
	ScheduledDeliveryDateNEQ    *time.Time  `json:"scheduledDeliveryDateNEQ,omitempty"`
	ScheduledDeliveryDateIn     []time.Time `json:"scheduledDeliveryDateIn,omitempty"`
	ScheduledDeliveryDateNotIn  []time.Time `json:"scheduledDeliveryDateNotIn,omitempty"`
	ScheduledDeliveryDateGT     *time.Time  `json:"scheduledDeliveryDateGT,omitempty"`
	ScheduledDeliveryDateGTE    *time.Time  `json:"scheduledDeliveryDateGTE,omitempty"`
	ScheduledDeliveryDateLT     *time.Time  `json:"scheduledDeliveryDateLT,omitempty"`
	ScheduledDeliveryDateLTE    *time.Time  `json:"scheduledDeliveryDateLTE,omitempty"`
	ScheduledDeliveryDateIsNil  bool        `json:"scheduledDeliveryDateIsNil,omitempty"`
	ScheduledDeliveryDateNotNil bool        `json:"scheduledDeliveryDateNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment" edge predicates.
	HasShipment     *bool                 `json:"hasShipment,omitempty"`
	HasShipmentWith []*ShipmentWhereInput `json:"hasShipmentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *ShipmentUSPSWhereInput) AddPredicates(predicates ...predicate.ShipmentUSPS) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the ShipmentUSPSWhereInput filter on the ShipmentUSPSQuery builder.
func (i *ShipmentUSPSWhereInput) Filter(q *ShipmentUSPSQuery) (*ShipmentUSPSQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyShipmentUSPSWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyShipmentUSPSWhereInput is returned in case the ShipmentUSPSWhereInput is empty.
var ErrEmptyShipmentUSPSWhereInput = errors.New("ent: empty predicate ShipmentUSPSWhereInput")

// P returns a predicate for filtering shipmentuspss.
// An error is returned if the input is empty or invalid.
func (i *ShipmentUSPSWhereInput) P() (predicate.ShipmentUSPS, error) {
	var predicates []predicate.ShipmentUSPS
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, shipmentusps.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.ShipmentUSPS, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, shipmentusps.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.ShipmentUSPS, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, shipmentusps.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, shipmentusps.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, shipmentusps.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, shipmentusps.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, shipmentusps.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, shipmentusps.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, shipmentusps.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, shipmentusps.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, shipmentusps.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, shipmentusps.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, shipmentusps.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, shipmentusps.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, shipmentusps.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, shipmentusps.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, shipmentusps.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, shipmentusps.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, shipmentusps.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, shipmentusps.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, shipmentusps.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, shipmentusps.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, shipmentusps.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, shipmentusps.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.TrackingNumber != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberEQ(*i.TrackingNumber))
	}
	if i.TrackingNumberNEQ != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberNEQ(*i.TrackingNumberNEQ))
	}
	if len(i.TrackingNumberIn) > 0 {
		predicates = append(predicates, shipmentusps.TrackingNumberIn(i.TrackingNumberIn...))
	}
	if len(i.TrackingNumberNotIn) > 0 {
		predicates = append(predicates, shipmentusps.TrackingNumberNotIn(i.TrackingNumberNotIn...))
	}
	if i.TrackingNumberGT != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberGT(*i.TrackingNumberGT))
	}
	if i.TrackingNumberGTE != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberGTE(*i.TrackingNumberGTE))
	}
	if i.TrackingNumberLT != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberLT(*i.TrackingNumberLT))
	}
	if i.TrackingNumberLTE != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberLTE(*i.TrackingNumberLTE))
	}
	if i.TrackingNumberContains != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberContains(*i.TrackingNumberContains))
	}
	if i.TrackingNumberHasPrefix != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberHasPrefix(*i.TrackingNumberHasPrefix))
	}
	if i.TrackingNumberHasSuffix != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberHasSuffix(*i.TrackingNumberHasSuffix))
	}
	if i.TrackingNumberIsNil {
		predicates = append(predicates, shipmentusps.TrackingNumberIsNil())
	}
	if i.TrackingNumberNotNil {
		predicates = append(predicates, shipmentusps.TrackingNumberNotNil())
	}
	if i.TrackingNumberEqualFold != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberEqualFold(*i.TrackingNumberEqualFold))
	}
	if i.TrackingNumberContainsFold != nil {
		predicates = append(predicates, shipmentusps.TrackingNumberContainsFold(*i.TrackingNumberContainsFold))
	}
	if i.Postage != nil {
		predicates = append(predicates, shipmentusps.PostageEQ(*i.Postage))
	}
	if i.PostageNEQ != nil {
		predicates = append(predicates, shipmentusps.PostageNEQ(*i.PostageNEQ))
	}
	if len(i.PostageIn) > 0 {
		predicates = append(predicates, shipmentusps.PostageIn(i.PostageIn...))
	}
	if len(i.PostageNotIn) > 0 {
		predicates = append(predicates, shipmentusps.PostageNotIn(i.PostageNotIn...))
	}
	if i.PostageGT != nil {
		predicates = append(predicates, shipmentusps.PostageGT(*i.PostageGT))
	}
	if i.PostageGTE != nil {
		predicates = append(predicates, shipmentusps.PostageGTE(*i.PostageGTE))
	}
	if i.PostageLT != nil {
		predicates = append(predicates, shipmentusps.PostageLT(*i.PostageLT))
	}
	if i.PostageLTE != nil {
		predicates = append(predicates, shipmentusps.PostageLTE(*i.PostageLTE))
	}
	if i.PostageIsNil {
		predicates = append(predicates, shipmentusps.PostageIsNil())
	}
	if i.PostageNotNil {
		predicates = append(predicates, shipmentusps.PostageNotNil())
	}
	if i.ScheduledDeliveryDate != nil {
		predicates = append(predicates, shipmentusps.ScheduledDeliveryDateEQ(*i.ScheduledDeliveryDate))
	}
	if i.ScheduledDeliveryDateNEQ != nil {
		predicates = append(predicates, shipmentusps.ScheduledDeliveryDateNEQ(*i.ScheduledDeliveryDateNEQ))
	}
	if len(i.ScheduledDeliveryDateIn) > 0 {
		predicates = append(predicates, shipmentusps.ScheduledDeliveryDateIn(i.ScheduledDeliveryDateIn...))
	}
	if len(i.ScheduledDeliveryDateNotIn) > 0 {
		predicates = append(predicates, shipmentusps.ScheduledDeliveryDateNotIn(i.ScheduledDeliveryDateNotIn...))
	}
	if i.ScheduledDeliveryDateGT != nil {
		predicates = append(predicates, shipmentusps.ScheduledDeliveryDateGT(*i.ScheduledDeliveryDateGT))
	}
	if i.ScheduledDeliveryDateGTE != nil {
		predicates = append(predicates, shipmentusps.ScheduledDeliveryDateGTE(*i.ScheduledDeliveryDateGTE))
	}
	if i.ScheduledDeliveryDateLT != nil {
		predicates = append(predicates, shipmentusps.ScheduledDeliveryDateLT(*i.ScheduledDeliveryDateLT))
	}
	if i.ScheduledDeliveryDateLTE != nil {
		predicates = append(predicates, shipmentusps.ScheduledDeliveryDateLTE(*i.ScheduledDeliveryDateLTE))
	}
	if i.ScheduledDeliveryDateIsNil {
		predicates = append(predicates, shipmentusps.ScheduledDeliveryDateIsNil())
	}
	if i.ScheduledDeliveryDateNotNil {
		predicates = append(predicates, shipmentusps.ScheduledDeliveryDateNotNil())
	}

	if i.HasTenant != nil {
		p := shipmentusps.HasTenant()
		if !*i.HasTenant {
			p = shipmentusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentusps.HasTenantWith(with...))
	}
	if i.HasShipment != nil {
		p := shipmentusps.HasShipment()
		if !*i.HasShipment {
			p = shipmentusps.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentWith) > 0 {
		with := make([]predicate.Shipment, 0, len(i.HasShipmentWith))
		for _, w := range i.HasShipmentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, shipmentusps.HasShipmentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyShipmentUSPSWhereInput
	case 1:
		return predicates[0], nil
	default:
		return shipmentusps.And(predicates...), nil
	}
}

// SignupOptionsWhereInput represents a where input for filtering SignupOptions queries.
type SignupOptionsWhereInput struct {
	Predicates []predicate.SignupOptions  `json:"-"`
	Not        *SignupOptionsWhereInput   `json:"not,omitempty"`
	Or         []*SignupOptionsWhereInput `json:"or,omitempty"`
	And        []*SignupOptionsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "better_delivery_options" field predicates.
	BetterDeliveryOptions    *bool `json:"betterDeliveryOptions,omitempty"`
	BetterDeliveryOptionsNEQ *bool `json:"betterDeliveryOptionsNEQ,omitempty"`

	// "improve_pick_pack" field predicates.
	ImprovePickPack    *bool `json:"improvePickPack,omitempty"`
	ImprovePickPackNEQ *bool `json:"improvePickPackNEQ,omitempty"`

	// "shipping_label" field predicates.
	ShippingLabel    *bool `json:"shippingLabel,omitempty"`
	ShippingLabelNEQ *bool `json:"shippingLabelNEQ,omitempty"`

	// "custom_docs" field predicates.
	CustomDocs    *bool `json:"customDocs,omitempty"`
	CustomDocsNEQ *bool `json:"customDocsNEQ,omitempty"`

	// "reduced_costs" field predicates.
	ReducedCosts    *bool `json:"reducedCosts,omitempty"`
	ReducedCostsNEQ *bool `json:"reducedCostsNEQ,omitempty"`

	// "easy_returns" field predicates.
	EasyReturns    *bool `json:"easyReturns,omitempty"`
	EasyReturnsNEQ *bool `json:"easyReturnsNEQ,omitempty"`

	// "click_collect" field predicates.
	ClickCollect    *bool `json:"clickCollect,omitempty"`
	ClickCollectNEQ *bool `json:"clickCollectNEQ,omitempty"`

	// "num_shipments" field predicates.
	NumShipments      *int  `json:"numShipments,omitempty"`
	NumShipmentsNEQ   *int  `json:"numShipmentsNEQ,omitempty"`
	NumShipmentsIn    []int `json:"numShipmentsIn,omitempty"`
	NumShipmentsNotIn []int `json:"numShipmentsNotIn,omitempty"`
	NumShipmentsGT    *int  `json:"numShipmentsGT,omitempty"`
	NumShipmentsGTE   *int  `json:"numShipmentsGTE,omitempty"`
	NumShipmentsLT    *int  `json:"numShipmentsLT,omitempty"`
	NumShipmentsLTE   *int  `json:"numShipmentsLTE,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SignupOptionsWhereInput) AddPredicates(predicates ...predicate.SignupOptions) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SignupOptionsWhereInput filter on the SignupOptionsQuery builder.
func (i *SignupOptionsWhereInput) Filter(q *SignupOptionsQuery) (*SignupOptionsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySignupOptionsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySignupOptionsWhereInput is returned in case the SignupOptionsWhereInput is empty.
var ErrEmptySignupOptionsWhereInput = errors.New("ent: empty predicate SignupOptionsWhereInput")

// P returns a predicate for filtering signupoptionsslice.
// An error is returned if the input is empty or invalid.
func (i *SignupOptionsWhereInput) P() (predicate.SignupOptions, error) {
	var predicates []predicate.SignupOptions
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, signupoptions.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SignupOptions, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, signupoptions.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SignupOptions, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, signupoptions.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, signupoptions.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, signupoptions.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, signupoptions.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, signupoptions.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, signupoptions.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, signupoptions.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, signupoptions.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, signupoptions.IDLTE(*i.IDLTE))
	}
	if i.BetterDeliveryOptions != nil {
		predicates = append(predicates, signupoptions.BetterDeliveryOptionsEQ(*i.BetterDeliveryOptions))
	}
	if i.BetterDeliveryOptionsNEQ != nil {
		predicates = append(predicates, signupoptions.BetterDeliveryOptionsNEQ(*i.BetterDeliveryOptionsNEQ))
	}
	if i.ImprovePickPack != nil {
		predicates = append(predicates, signupoptions.ImprovePickPackEQ(*i.ImprovePickPack))
	}
	if i.ImprovePickPackNEQ != nil {
		predicates = append(predicates, signupoptions.ImprovePickPackNEQ(*i.ImprovePickPackNEQ))
	}
	if i.ShippingLabel != nil {
		predicates = append(predicates, signupoptions.ShippingLabelEQ(*i.ShippingLabel))
	}
	if i.ShippingLabelNEQ != nil {
		predicates = append(predicates, signupoptions.ShippingLabelNEQ(*i.ShippingLabelNEQ))
	}
	if i.CustomDocs != nil {
		predicates = append(predicates, signupoptions.CustomDocsEQ(*i.CustomDocs))
	}
	if i.CustomDocsNEQ != nil {
		predicates = append(predicates, signupoptions.CustomDocsNEQ(*i.CustomDocsNEQ))
	}
	if i.ReducedCosts != nil {
		predicates = append(predicates, signupoptions.ReducedCostsEQ(*i.ReducedCosts))
	}
	if i.ReducedCostsNEQ != nil {
		predicates = append(predicates, signupoptions.ReducedCostsNEQ(*i.ReducedCostsNEQ))
	}
	if i.EasyReturns != nil {
		predicates = append(predicates, signupoptions.EasyReturnsEQ(*i.EasyReturns))
	}
	if i.EasyReturnsNEQ != nil {
		predicates = append(predicates, signupoptions.EasyReturnsNEQ(*i.EasyReturnsNEQ))
	}
	if i.ClickCollect != nil {
		predicates = append(predicates, signupoptions.ClickCollectEQ(*i.ClickCollect))
	}
	if i.ClickCollectNEQ != nil {
		predicates = append(predicates, signupoptions.ClickCollectNEQ(*i.ClickCollectNEQ))
	}
	if i.NumShipments != nil {
		predicates = append(predicates, signupoptions.NumShipmentsEQ(*i.NumShipments))
	}
	if i.NumShipmentsNEQ != nil {
		predicates = append(predicates, signupoptions.NumShipmentsNEQ(*i.NumShipmentsNEQ))
	}
	if len(i.NumShipmentsIn) > 0 {
		predicates = append(predicates, signupoptions.NumShipmentsIn(i.NumShipmentsIn...))
	}
	if len(i.NumShipmentsNotIn) > 0 {
		predicates = append(predicates, signupoptions.NumShipmentsNotIn(i.NumShipmentsNotIn...))
	}
	if i.NumShipmentsGT != nil {
		predicates = append(predicates, signupoptions.NumShipmentsGT(*i.NumShipmentsGT))
	}
	if i.NumShipmentsGTE != nil {
		predicates = append(predicates, signupoptions.NumShipmentsGTE(*i.NumShipmentsGTE))
	}
	if i.NumShipmentsLT != nil {
		predicates = append(predicates, signupoptions.NumShipmentsLT(*i.NumShipmentsLT))
	}
	if i.NumShipmentsLTE != nil {
		predicates = append(predicates, signupoptions.NumShipmentsLTE(*i.NumShipmentsLTE))
	}

	if i.HasUsers != nil {
		p := signupoptions.HasUsers()
		if !*i.HasUsers {
			p = signupoptions.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, signupoptions.HasUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySignupOptionsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return signupoptions.And(predicates...), nil
	}
}

// SystemEventsWhereInput represents a where input for filtering SystemEvents queries.
type SystemEventsWhereInput struct {
	Predicates []predicate.SystemEvents  `json:"-"`
	Not        *SystemEventsWhereInput   `json:"not,omitempty"`
	Or         []*SystemEventsWhereInput `json:"or,omitempty"`
	And        []*SystemEventsWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "event_type" field predicates.
	EventType      *systemevents.EventType  `json:"eventType,omitempty"`
	EventTypeNEQ   *systemevents.EventType  `json:"eventTypeNEQ,omitempty"`
	EventTypeIn    []systemevents.EventType `json:"eventTypeIn,omitempty"`
	EventTypeNotIn []systemevents.EventType `json:"eventTypeNotIn,omitempty"`

	// "event_type_id" field predicates.
	EventTypeID             *string  `json:"eventTypeID,omitempty"`
	EventTypeIDNEQ          *string  `json:"eventTypeIDNEQ,omitempty"`
	EventTypeIDIn           []string `json:"eventTypeIDIn,omitempty"`
	EventTypeIDNotIn        []string `json:"eventTypeIDNotIn,omitempty"`
	EventTypeIDGT           *string  `json:"eventTypeIDGT,omitempty"`
	EventTypeIDGTE          *string  `json:"eventTypeIDGTE,omitempty"`
	EventTypeIDLT           *string  `json:"eventTypeIDLT,omitempty"`
	EventTypeIDLTE          *string  `json:"eventTypeIDLTE,omitempty"`
	EventTypeIDContains     *string  `json:"eventTypeIDContains,omitempty"`
	EventTypeIDHasPrefix    *string  `json:"eventTypeIDHasPrefix,omitempty"`
	EventTypeIDHasSuffix    *string  `json:"eventTypeIDHasSuffix,omitempty"`
	EventTypeIDIsNil        bool     `json:"eventTypeIDIsNil,omitempty"`
	EventTypeIDNotNil       bool     `json:"eventTypeIDNotNil,omitempty"`
	EventTypeIDEqualFold    *string  `json:"eventTypeIDEqualFold,omitempty"`
	EventTypeIDContainsFold *string  `json:"eventTypeIDContainsFold,omitempty"`

	// "status" field predicates.
	Status      *systemevents.Status  `json:"status,omitempty"`
	StatusNEQ   *systemevents.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []systemevents.Status `json:"statusIn,omitempty"`
	StatusNotIn []systemevents.Status `json:"statusNotIn,omitempty"`

	// "description" field predicates.
	Description             *string  `json:"description,omitempty"`
	DescriptionNEQ          *string  `json:"descriptionNEQ,omitempty"`
	DescriptionIn           []string `json:"descriptionIn,omitempty"`
	DescriptionNotIn        []string `json:"descriptionNotIn,omitempty"`
	DescriptionGT           *string  `json:"descriptionGT,omitempty"`
	DescriptionGTE          *string  `json:"descriptionGTE,omitempty"`
	DescriptionLT           *string  `json:"descriptionLT,omitempty"`
	DescriptionLTE          *string  `json:"descriptionLTE,omitempty"`
	DescriptionContains     *string  `json:"descriptionContains,omitempty"`
	DescriptionHasPrefix    *string  `json:"descriptionHasPrefix,omitempty"`
	DescriptionHasSuffix    *string  `json:"descriptionHasSuffix,omitempty"`
	DescriptionEqualFold    *string  `json:"descriptionEqualFold,omitempty"`
	DescriptionContainsFold *string  `json:"descriptionContainsFold,omitempty"`

	// "data" field predicates.
	Data             *string  `json:"data,omitempty"`
	DataNEQ          *string  `json:"dataNEQ,omitempty"`
	DataIn           []string `json:"dataIn,omitempty"`
	DataNotIn        []string `json:"dataNotIn,omitempty"`
	DataGT           *string  `json:"dataGT,omitempty"`
	DataGTE          *string  `json:"dataGTE,omitempty"`
	DataLT           *string  `json:"dataLT,omitempty"`
	DataLTE          *string  `json:"dataLTE,omitempty"`
	DataContains     *string  `json:"dataContains,omitempty"`
	DataHasPrefix    *string  `json:"dataHasPrefix,omitempty"`
	DataHasSuffix    *string  `json:"dataHasSuffix,omitempty"`
	DataIsNil        bool     `json:"dataIsNil,omitempty"`
	DataNotNil       bool     `json:"dataNotNil,omitempty"`
	DataEqualFold    *string  `json:"dataEqualFold,omitempty"`
	DataContainsFold *string  `json:"dataContainsFold,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt      *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ   *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn    []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT    *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE   *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT    *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE   *time.Time  `json:"updatedAtLTE,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SystemEventsWhereInput) AddPredicates(predicates ...predicate.SystemEvents) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SystemEventsWhereInput filter on the SystemEventsQuery builder.
func (i *SystemEventsWhereInput) Filter(q *SystemEventsQuery) (*SystemEventsQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySystemEventsWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySystemEventsWhereInput is returned in case the SystemEventsWhereInput is empty.
var ErrEmptySystemEventsWhereInput = errors.New("ent: empty predicate SystemEventsWhereInput")

// P returns a predicate for filtering systemeventsslice.
// An error is returned if the input is empty or invalid.
func (i *SystemEventsWhereInput) P() (predicate.SystemEvents, error) {
	var predicates []predicate.SystemEvents
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, systemevents.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.SystemEvents, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, systemevents.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.SystemEvents, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, systemevents.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, systemevents.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, systemevents.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, systemevents.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, systemevents.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, systemevents.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, systemevents.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, systemevents.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, systemevents.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, systemevents.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, systemevents.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, systemevents.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, systemevents.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, systemevents.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, systemevents.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, systemevents.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, systemevents.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, systemevents.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, systemevents.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, systemevents.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, systemevents.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, systemevents.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.EventType != nil {
		predicates = append(predicates, systemevents.EventTypeEQ(*i.EventType))
	}
	if i.EventTypeNEQ != nil {
		predicates = append(predicates, systemevents.EventTypeNEQ(*i.EventTypeNEQ))
	}
	if len(i.EventTypeIn) > 0 {
		predicates = append(predicates, systemevents.EventTypeIn(i.EventTypeIn...))
	}
	if len(i.EventTypeNotIn) > 0 {
		predicates = append(predicates, systemevents.EventTypeNotIn(i.EventTypeNotIn...))
	}
	if i.EventTypeID != nil {
		predicates = append(predicates, systemevents.EventTypeIDEQ(*i.EventTypeID))
	}
	if i.EventTypeIDNEQ != nil {
		predicates = append(predicates, systemevents.EventTypeIDNEQ(*i.EventTypeIDNEQ))
	}
	if len(i.EventTypeIDIn) > 0 {
		predicates = append(predicates, systemevents.EventTypeIDIn(i.EventTypeIDIn...))
	}
	if len(i.EventTypeIDNotIn) > 0 {
		predicates = append(predicates, systemevents.EventTypeIDNotIn(i.EventTypeIDNotIn...))
	}
	if i.EventTypeIDGT != nil {
		predicates = append(predicates, systemevents.EventTypeIDGT(*i.EventTypeIDGT))
	}
	if i.EventTypeIDGTE != nil {
		predicates = append(predicates, systemevents.EventTypeIDGTE(*i.EventTypeIDGTE))
	}
	if i.EventTypeIDLT != nil {
		predicates = append(predicates, systemevents.EventTypeIDLT(*i.EventTypeIDLT))
	}
	if i.EventTypeIDLTE != nil {
		predicates = append(predicates, systemevents.EventTypeIDLTE(*i.EventTypeIDLTE))
	}
	if i.EventTypeIDContains != nil {
		predicates = append(predicates, systemevents.EventTypeIDContains(*i.EventTypeIDContains))
	}
	if i.EventTypeIDHasPrefix != nil {
		predicates = append(predicates, systemevents.EventTypeIDHasPrefix(*i.EventTypeIDHasPrefix))
	}
	if i.EventTypeIDHasSuffix != nil {
		predicates = append(predicates, systemevents.EventTypeIDHasSuffix(*i.EventTypeIDHasSuffix))
	}
	if i.EventTypeIDIsNil {
		predicates = append(predicates, systemevents.EventTypeIDIsNil())
	}
	if i.EventTypeIDNotNil {
		predicates = append(predicates, systemevents.EventTypeIDNotNil())
	}
	if i.EventTypeIDEqualFold != nil {
		predicates = append(predicates, systemevents.EventTypeIDEqualFold(*i.EventTypeIDEqualFold))
	}
	if i.EventTypeIDContainsFold != nil {
		predicates = append(predicates, systemevents.EventTypeIDContainsFold(*i.EventTypeIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, systemevents.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, systemevents.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, systemevents.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, systemevents.StatusNotIn(i.StatusNotIn...))
	}
	if i.Description != nil {
		predicates = append(predicates, systemevents.DescriptionEQ(*i.Description))
	}
	if i.DescriptionNEQ != nil {
		predicates = append(predicates, systemevents.DescriptionNEQ(*i.DescriptionNEQ))
	}
	if len(i.DescriptionIn) > 0 {
		predicates = append(predicates, systemevents.DescriptionIn(i.DescriptionIn...))
	}
	if len(i.DescriptionNotIn) > 0 {
		predicates = append(predicates, systemevents.DescriptionNotIn(i.DescriptionNotIn...))
	}
	if i.DescriptionGT != nil {
		predicates = append(predicates, systemevents.DescriptionGT(*i.DescriptionGT))
	}
	if i.DescriptionGTE != nil {
		predicates = append(predicates, systemevents.DescriptionGTE(*i.DescriptionGTE))
	}
	if i.DescriptionLT != nil {
		predicates = append(predicates, systemevents.DescriptionLT(*i.DescriptionLT))
	}
	if i.DescriptionLTE != nil {
		predicates = append(predicates, systemevents.DescriptionLTE(*i.DescriptionLTE))
	}
	if i.DescriptionContains != nil {
		predicates = append(predicates, systemevents.DescriptionContains(*i.DescriptionContains))
	}
	if i.DescriptionHasPrefix != nil {
		predicates = append(predicates, systemevents.DescriptionHasPrefix(*i.DescriptionHasPrefix))
	}
	if i.DescriptionHasSuffix != nil {
		predicates = append(predicates, systemevents.DescriptionHasSuffix(*i.DescriptionHasSuffix))
	}
	if i.DescriptionEqualFold != nil {
		predicates = append(predicates, systemevents.DescriptionEqualFold(*i.DescriptionEqualFold))
	}
	if i.DescriptionContainsFold != nil {
		predicates = append(predicates, systemevents.DescriptionContainsFold(*i.DescriptionContainsFold))
	}
	if i.Data != nil {
		predicates = append(predicates, systemevents.DataEQ(*i.Data))
	}
	if i.DataNEQ != nil {
		predicates = append(predicates, systemevents.DataNEQ(*i.DataNEQ))
	}
	if len(i.DataIn) > 0 {
		predicates = append(predicates, systemevents.DataIn(i.DataIn...))
	}
	if len(i.DataNotIn) > 0 {
		predicates = append(predicates, systemevents.DataNotIn(i.DataNotIn...))
	}
	if i.DataGT != nil {
		predicates = append(predicates, systemevents.DataGT(*i.DataGT))
	}
	if i.DataGTE != nil {
		predicates = append(predicates, systemevents.DataGTE(*i.DataGTE))
	}
	if i.DataLT != nil {
		predicates = append(predicates, systemevents.DataLT(*i.DataLT))
	}
	if i.DataLTE != nil {
		predicates = append(predicates, systemevents.DataLTE(*i.DataLTE))
	}
	if i.DataContains != nil {
		predicates = append(predicates, systemevents.DataContains(*i.DataContains))
	}
	if i.DataHasPrefix != nil {
		predicates = append(predicates, systemevents.DataHasPrefix(*i.DataHasPrefix))
	}
	if i.DataHasSuffix != nil {
		predicates = append(predicates, systemevents.DataHasSuffix(*i.DataHasSuffix))
	}
	if i.DataIsNil {
		predicates = append(predicates, systemevents.DataIsNil())
	}
	if i.DataNotNil {
		predicates = append(predicates, systemevents.DataNotNil())
	}
	if i.DataEqualFold != nil {
		predicates = append(predicates, systemevents.DataEqualFold(*i.DataEqualFold))
	}
	if i.DataContainsFold != nil {
		predicates = append(predicates, systemevents.DataContainsFold(*i.DataContainsFold))
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, systemevents.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, systemevents.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, systemevents.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, systemevents.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, systemevents.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, systemevents.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, systemevents.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, systemevents.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, systemevents.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, systemevents.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, systemevents.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, systemevents.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, systemevents.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, systemevents.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, systemevents.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, systemevents.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, systemevents.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, systemevents.CreatedAtNotNil())
	}

	if i.HasTenant != nil {
		p := systemevents.HasTenant()
		if !*i.HasTenant {
			p = systemevents.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, systemevents.HasTenantWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySystemEventsWhereInput
	case 1:
		return predicates[0], nil
	default:
		return systemevents.And(predicates...), nil
	}
}

// TenantWhereInput represents a where input for filtering Tenant queries.
type TenantWhereInput struct {
	Predicates []predicate.Tenant  `json:"-"`
	Not        *TenantWhereInput   `json:"not,omitempty"`
	Or         []*TenantWhereInput `json:"or,omitempty"`
	And        []*TenantWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "vat_number" field predicates.
	VatNumber             *string  `json:"vatNumber,omitempty"`
	VatNumberNEQ          *string  `json:"vatNumberNEQ,omitempty"`
	VatNumberIn           []string `json:"vatNumberIn,omitempty"`
	VatNumberNotIn        []string `json:"vatNumberNotIn,omitempty"`
	VatNumberGT           *string  `json:"vatNumberGT,omitempty"`
	VatNumberGTE          *string  `json:"vatNumberGTE,omitempty"`
	VatNumberLT           *string  `json:"vatNumberLT,omitempty"`
	VatNumberLTE          *string  `json:"vatNumberLTE,omitempty"`
	VatNumberContains     *string  `json:"vatNumberContains,omitempty"`
	VatNumberHasPrefix    *string  `json:"vatNumberHasPrefix,omitempty"`
	VatNumberHasSuffix    *string  `json:"vatNumberHasSuffix,omitempty"`
	VatNumberIsNil        bool     `json:"vatNumberIsNil,omitempty"`
	VatNumberNotNil       bool     `json:"vatNumberNotNil,omitempty"`
	VatNumberEqualFold    *string  `json:"vatNumberEqualFold,omitempty"`
	VatNumberContainsFold *string  `json:"vatNumberContainsFold,omitempty"`

	// "invoice_reference" field predicates.
	InvoiceReference             *string  `json:"invoiceReference,omitempty"`
	InvoiceReferenceNEQ          *string  `json:"invoiceReferenceNEQ,omitempty"`
	InvoiceReferenceIn           []string `json:"invoiceReferenceIn,omitempty"`
	InvoiceReferenceNotIn        []string `json:"invoiceReferenceNotIn,omitempty"`
	InvoiceReferenceGT           *string  `json:"invoiceReferenceGT,omitempty"`
	InvoiceReferenceGTE          *string  `json:"invoiceReferenceGTE,omitempty"`
	InvoiceReferenceLT           *string  `json:"invoiceReferenceLT,omitempty"`
	InvoiceReferenceLTE          *string  `json:"invoiceReferenceLTE,omitempty"`
	InvoiceReferenceContains     *string  `json:"invoiceReferenceContains,omitempty"`
	InvoiceReferenceHasPrefix    *string  `json:"invoiceReferenceHasPrefix,omitempty"`
	InvoiceReferenceHasSuffix    *string  `json:"invoiceReferenceHasSuffix,omitempty"`
	InvoiceReferenceIsNil        bool     `json:"invoiceReferenceIsNil,omitempty"`
	InvoiceReferenceNotNil       bool     `json:"invoiceReferenceNotNil,omitempty"`
	InvoiceReferenceEqualFold    *string  `json:"invoiceReferenceEqualFold,omitempty"`
	InvoiceReferenceContainsFold *string  `json:"invoiceReferenceContainsFold,omitempty"`

	// "connect_option_carriers" edge predicates.
	HasConnectOptionCarriers     *bool                             `json:"hasConnectOptionCarriers,omitempty"`
	HasConnectOptionCarriersWith []*ConnectOptionCarrierWhereInput `json:"hasConnectOptionCarriersWith,omitempty"`

	// "connect_option_platforms" edge predicates.
	HasConnectOptionPlatforms     *bool                              `json:"hasConnectOptionPlatforms,omitempty"`
	HasConnectOptionPlatformsWith []*ConnectOptionPlatformWhereInput `json:"hasConnectOptionPlatformsWith,omitempty"`

	// "plan" edge predicates.
	HasPlan     *bool             `json:"hasPlan,omitempty"`
	HasPlanWith []*PlanWhereInput `json:"hasPlanWith,omitempty"`

	// "company_address" edge predicates.
	HasCompanyAddress     *bool                `json:"hasCompanyAddress,omitempty"`
	HasCompanyAddressWith []*AddressWhereInput `json:"hasCompanyAddressWith,omitempty"`

	// "default_language" edge predicates.
	HasDefaultLanguage     *bool                 `json:"hasDefaultLanguage,omitempty"`
	HasDefaultLanguageWith []*LanguageWhereInput `json:"hasDefaultLanguageWith,omitempty"`

	// "billing_contact" edge predicates.
	HasBillingContact     *bool                `json:"hasBillingContact,omitempty"`
	HasBillingContactWith []*ContactWhereInput `json:"hasBillingContactWith,omitempty"`

	// "admin_contact" edge predicates.
	HasAdminContact     *bool                `json:"hasAdminContact,omitempty"`
	HasAdminContactWith []*ContactWhereInput `json:"hasAdminContactWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TenantWhereInput) AddPredicates(predicates ...predicate.Tenant) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TenantWhereInput filter on the TenantQuery builder.
func (i *TenantWhereInput) Filter(q *TenantQuery) (*TenantQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTenantWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTenantWhereInput is returned in case the TenantWhereInput is empty.
var ErrEmptyTenantWhereInput = errors.New("ent: empty predicate TenantWhereInput")

// P returns a predicate for filtering tenants.
// An error is returned if the input is empty or invalid.
func (i *TenantWhereInput) P() (predicate.Tenant, error) {
	var predicates []predicate.Tenant
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, tenant.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Tenant, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, tenant.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Tenant, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, tenant.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, tenant.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, tenant.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, tenant.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, tenant.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, tenant.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, tenant.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, tenant.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, tenant.IDLTE(*i.IDLTE))
	}
	if i.Name != nil {
		predicates = append(predicates, tenant.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, tenant.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, tenant.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, tenant.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, tenant.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, tenant.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, tenant.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, tenant.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, tenant.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, tenant.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, tenant.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, tenant.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, tenant.NameContainsFold(*i.NameContainsFold))
	}
	if i.VatNumber != nil {
		predicates = append(predicates, tenant.VatNumberEQ(*i.VatNumber))
	}
	if i.VatNumberNEQ != nil {
		predicates = append(predicates, tenant.VatNumberNEQ(*i.VatNumberNEQ))
	}
	if len(i.VatNumberIn) > 0 {
		predicates = append(predicates, tenant.VatNumberIn(i.VatNumberIn...))
	}
	if len(i.VatNumberNotIn) > 0 {
		predicates = append(predicates, tenant.VatNumberNotIn(i.VatNumberNotIn...))
	}
	if i.VatNumberGT != nil {
		predicates = append(predicates, tenant.VatNumberGT(*i.VatNumberGT))
	}
	if i.VatNumberGTE != nil {
		predicates = append(predicates, tenant.VatNumberGTE(*i.VatNumberGTE))
	}
	if i.VatNumberLT != nil {
		predicates = append(predicates, tenant.VatNumberLT(*i.VatNumberLT))
	}
	if i.VatNumberLTE != nil {
		predicates = append(predicates, tenant.VatNumberLTE(*i.VatNumberLTE))
	}
	if i.VatNumberContains != nil {
		predicates = append(predicates, tenant.VatNumberContains(*i.VatNumberContains))
	}
	if i.VatNumberHasPrefix != nil {
		predicates = append(predicates, tenant.VatNumberHasPrefix(*i.VatNumberHasPrefix))
	}
	if i.VatNumberHasSuffix != nil {
		predicates = append(predicates, tenant.VatNumberHasSuffix(*i.VatNumberHasSuffix))
	}
	if i.VatNumberIsNil {
		predicates = append(predicates, tenant.VatNumberIsNil())
	}
	if i.VatNumberNotNil {
		predicates = append(predicates, tenant.VatNumberNotNil())
	}
	if i.VatNumberEqualFold != nil {
		predicates = append(predicates, tenant.VatNumberEqualFold(*i.VatNumberEqualFold))
	}
	if i.VatNumberContainsFold != nil {
		predicates = append(predicates, tenant.VatNumberContainsFold(*i.VatNumberContainsFold))
	}
	if i.InvoiceReference != nil {
		predicates = append(predicates, tenant.InvoiceReferenceEQ(*i.InvoiceReference))
	}
	if i.InvoiceReferenceNEQ != nil {
		predicates = append(predicates, tenant.InvoiceReferenceNEQ(*i.InvoiceReferenceNEQ))
	}
	if len(i.InvoiceReferenceIn) > 0 {
		predicates = append(predicates, tenant.InvoiceReferenceIn(i.InvoiceReferenceIn...))
	}
	if len(i.InvoiceReferenceNotIn) > 0 {
		predicates = append(predicates, tenant.InvoiceReferenceNotIn(i.InvoiceReferenceNotIn...))
	}
	if i.InvoiceReferenceGT != nil {
		predicates = append(predicates, tenant.InvoiceReferenceGT(*i.InvoiceReferenceGT))
	}
	if i.InvoiceReferenceGTE != nil {
		predicates = append(predicates, tenant.InvoiceReferenceGTE(*i.InvoiceReferenceGTE))
	}
	if i.InvoiceReferenceLT != nil {
		predicates = append(predicates, tenant.InvoiceReferenceLT(*i.InvoiceReferenceLT))
	}
	if i.InvoiceReferenceLTE != nil {
		predicates = append(predicates, tenant.InvoiceReferenceLTE(*i.InvoiceReferenceLTE))
	}
	if i.InvoiceReferenceContains != nil {
		predicates = append(predicates, tenant.InvoiceReferenceContains(*i.InvoiceReferenceContains))
	}
	if i.InvoiceReferenceHasPrefix != nil {
		predicates = append(predicates, tenant.InvoiceReferenceHasPrefix(*i.InvoiceReferenceHasPrefix))
	}
	if i.InvoiceReferenceHasSuffix != nil {
		predicates = append(predicates, tenant.InvoiceReferenceHasSuffix(*i.InvoiceReferenceHasSuffix))
	}
	if i.InvoiceReferenceIsNil {
		predicates = append(predicates, tenant.InvoiceReferenceIsNil())
	}
	if i.InvoiceReferenceNotNil {
		predicates = append(predicates, tenant.InvoiceReferenceNotNil())
	}
	if i.InvoiceReferenceEqualFold != nil {
		predicates = append(predicates, tenant.InvoiceReferenceEqualFold(*i.InvoiceReferenceEqualFold))
	}
	if i.InvoiceReferenceContainsFold != nil {
		predicates = append(predicates, tenant.InvoiceReferenceContainsFold(*i.InvoiceReferenceContainsFold))
	}

	if i.HasConnectOptionCarriers != nil {
		p := tenant.HasConnectOptionCarriers()
		if !*i.HasConnectOptionCarriers {
			p = tenant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectOptionCarriersWith) > 0 {
		with := make([]predicate.ConnectOptionCarrier, 0, len(i.HasConnectOptionCarriersWith))
		for _, w := range i.HasConnectOptionCarriersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectOptionCarriersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tenant.HasConnectOptionCarriersWith(with...))
	}
	if i.HasConnectOptionPlatforms != nil {
		p := tenant.HasConnectOptionPlatforms()
		if !*i.HasConnectOptionPlatforms {
			p = tenant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasConnectOptionPlatformsWith) > 0 {
		with := make([]predicate.ConnectOptionPlatform, 0, len(i.HasConnectOptionPlatformsWith))
		for _, w := range i.HasConnectOptionPlatformsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasConnectOptionPlatformsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tenant.HasConnectOptionPlatformsWith(with...))
	}
	if i.HasPlan != nil {
		p := tenant.HasPlan()
		if !*i.HasPlan {
			p = tenant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlanWith) > 0 {
		with := make([]predicate.Plan, 0, len(i.HasPlanWith))
		for _, w := range i.HasPlanWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPlanWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tenant.HasPlanWith(with...))
	}
	if i.HasCompanyAddress != nil {
		p := tenant.HasCompanyAddress()
		if !*i.HasCompanyAddress {
			p = tenant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasCompanyAddressWith) > 0 {
		with := make([]predicate.Address, 0, len(i.HasCompanyAddressWith))
		for _, w := range i.HasCompanyAddressWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasCompanyAddressWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tenant.HasCompanyAddressWith(with...))
	}
	if i.HasDefaultLanguage != nil {
		p := tenant.HasDefaultLanguage()
		if !*i.HasDefaultLanguage {
			p = tenant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasDefaultLanguageWith) > 0 {
		with := make([]predicate.Language, 0, len(i.HasDefaultLanguageWith))
		for _, w := range i.HasDefaultLanguageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasDefaultLanguageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tenant.HasDefaultLanguageWith(with...))
	}
	if i.HasBillingContact != nil {
		p := tenant.HasBillingContact()
		if !*i.HasBillingContact {
			p = tenant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasBillingContactWith) > 0 {
		with := make([]predicate.Contact, 0, len(i.HasBillingContactWith))
		for _, w := range i.HasBillingContactWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasBillingContactWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tenant.HasBillingContactWith(with...))
	}
	if i.HasAdminContact != nil {
		p := tenant.HasAdminContact()
		if !*i.HasAdminContact {
			p = tenant.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAdminContactWith) > 0 {
		with := make([]predicate.Contact, 0, len(i.HasAdminContactWith))
		for _, w := range i.HasAdminContactWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAdminContactWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, tenant.HasAdminContactWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTenantWhereInput
	case 1:
		return predicates[0], nil
	default:
		return tenant.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "surname" field predicates.
	Surname             *string  `json:"surname,omitempty"`
	SurnameNEQ          *string  `json:"surnameNEQ,omitempty"`
	SurnameIn           []string `json:"surnameIn,omitempty"`
	SurnameNotIn        []string `json:"surnameNotIn,omitempty"`
	SurnameGT           *string  `json:"surnameGT,omitempty"`
	SurnameGTE          *string  `json:"surnameGTE,omitempty"`
	SurnameLT           *string  `json:"surnameLT,omitempty"`
	SurnameLTE          *string  `json:"surnameLTE,omitempty"`
	SurnameContains     *string  `json:"surnameContains,omitempty"`
	SurnameHasPrefix    *string  `json:"surnameHasPrefix,omitempty"`
	SurnameHasSuffix    *string  `json:"surnameHasSuffix,omitempty"`
	SurnameIsNil        bool     `json:"surnameIsNil,omitempty"`
	SurnameNotNil       bool     `json:"surnameNotNil,omitempty"`
	SurnameEqualFold    *string  `json:"surnameEqualFold,omitempty"`
	SurnameContainsFold *string  `json:"surnameContainsFold,omitempty"`

	// "phone_number" field predicates.
	PhoneNumber             *string  `json:"phoneNumber,omitempty"`
	PhoneNumberNEQ          *string  `json:"phoneNumberNEQ,omitempty"`
	PhoneNumberIn           []string `json:"phoneNumberIn,omitempty"`
	PhoneNumberNotIn        []string `json:"phoneNumberNotIn,omitempty"`
	PhoneNumberGT           *string  `json:"phoneNumberGT,omitempty"`
	PhoneNumberGTE          *string  `json:"phoneNumberGTE,omitempty"`
	PhoneNumberLT           *string  `json:"phoneNumberLT,omitempty"`
	PhoneNumberLTE          *string  `json:"phoneNumberLTE,omitempty"`
	PhoneNumberContains     *string  `json:"phoneNumberContains,omitempty"`
	PhoneNumberHasPrefix    *string  `json:"phoneNumberHasPrefix,omitempty"`
	PhoneNumberHasSuffix    *string  `json:"phoneNumberHasSuffix,omitempty"`
	PhoneNumberIsNil        bool     `json:"phoneNumberIsNil,omitempty"`
	PhoneNumberNotNil       bool     `json:"phoneNumberNotNil,omitempty"`
	PhoneNumberEqualFold    *string  `json:"phoneNumberEqualFold,omitempty"`
	PhoneNumberContainsFold *string  `json:"phoneNumberContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "hash" field predicates.
	Hash             *string  `json:"hash,omitempty"`
	HashNEQ          *string  `json:"hashNEQ,omitempty"`
	HashIn           []string `json:"hashIn,omitempty"`
	HashNotIn        []string `json:"hashNotIn,omitempty"`
	HashGT           *string  `json:"hashGT,omitempty"`
	HashGTE          *string  `json:"hashGTE,omitempty"`
	HashLT           *string  `json:"hashLT,omitempty"`
	HashLTE          *string  `json:"hashLTE,omitempty"`
	HashContains     *string  `json:"hashContains,omitempty"`
	HashHasPrefix    *string  `json:"hashHasPrefix,omitempty"`
	HashHasSuffix    *string  `json:"hashHasSuffix,omitempty"`
	HashEqualFold    *string  `json:"hashEqualFold,omitempty"`
	HashContainsFold *string  `json:"hashContainsFold,omitempty"`

	// "is_account_owner" field predicates.
	IsAccountOwner    *bool `json:"isAccountOwner,omitempty"`
	IsAccountOwnerNEQ *bool `json:"isAccountOwnerNEQ,omitempty"`

	// "is_global_admin" field predicates.
	IsGlobalAdmin    *bool `json:"isGlobalAdmin,omitempty"`
	IsGlobalAdminNEQ *bool `json:"isGlobalAdminNEQ,omitempty"`

	// "marketing_consent" field predicates.
	MarketingConsent       *bool `json:"marketingConsent,omitempty"`
	MarketingConsentNEQ    *bool `json:"marketingConsentNEQ,omitempty"`
	MarketingConsentIsNil  bool  `json:"marketingConsentIsNil,omitempty"`
	MarketingConsentNotNil bool  `json:"marketingConsentNotNil,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "archived_at" field predicates.
	ArchivedAt       *time.Time  `json:"archivedAt,omitempty"`
	ArchivedAtNEQ    *time.Time  `json:"archivedAtNEQ,omitempty"`
	ArchivedAtIn     []time.Time `json:"archivedAtIn,omitempty"`
	ArchivedAtNotIn  []time.Time `json:"archivedAtNotIn,omitempty"`
	ArchivedAtGT     *time.Time  `json:"archivedAtGT,omitempty"`
	ArchivedAtGTE    *time.Time  `json:"archivedAtGTE,omitempty"`
	ArchivedAtLT     *time.Time  `json:"archivedAtLT,omitempty"`
	ArchivedAtLTE    *time.Time  `json:"archivedAtLTE,omitempty"`
	ArchivedAtIsNil  bool        `json:"archivedAtIsNil,omitempty"`
	ArchivedAtNotNil bool        `json:"archivedAtNotNil,omitempty"`

	// "pickup_day" field predicates.
	PickupDay      *user.PickupDay  `json:"pickupDay,omitempty"`
	PickupDayNEQ   *user.PickupDay  `json:"pickupDayNEQ,omitempty"`
	PickupDayIn    []user.PickupDay `json:"pickupDayIn,omitempty"`
	PickupDayNotIn []user.PickupDay `json:"pickupDayNotIn,omitempty"`

	// "pickup_day_last_changed" field predicates.
	PickupDayLastChanged       *time.Time  `json:"pickupDayLastChanged,omitempty"`
	PickupDayLastChangedNEQ    *time.Time  `json:"pickupDayLastChangedNEQ,omitempty"`
	PickupDayLastChangedIn     []time.Time `json:"pickupDayLastChangedIn,omitempty"`
	PickupDayLastChangedNotIn  []time.Time `json:"pickupDayLastChangedNotIn,omitempty"`
	PickupDayLastChangedGT     *time.Time  `json:"pickupDayLastChangedGT,omitempty"`
	PickupDayLastChangedGTE    *time.Time  `json:"pickupDayLastChangedGTE,omitempty"`
	PickupDayLastChangedLT     *time.Time  `json:"pickupDayLastChangedLT,omitempty"`
	PickupDayLastChangedLTE    *time.Time  `json:"pickupDayLastChangedLTE,omitempty"`
	PickupDayLastChangedIsNil  bool        `json:"pickupDayLastChangedIsNil,omitempty"`
	PickupDayLastChangedNotNil bool        `json:"pickupDayLastChangedNotNil,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "otk_requests" edge predicates.
	HasOtkRequests     *bool                    `json:"hasOtkRequests,omitempty"`
	HasOtkRequestsWith []*OTKRequestsWhereInput `json:"hasOtkRequestsWith,omitempty"`

	// "signup_options" edge predicates.
	HasSignupOptions     *bool                      `json:"hasSignupOptions,omitempty"`
	HasSignupOptionsWith []*SignupOptionsWhereInput `json:"hasSignupOptionsWith,omitempty"`

	// "language" edge predicates.
	HasLanguage     *bool                 `json:"hasLanguage,omitempty"`
	HasLanguageWith []*LanguageWhereInput `json:"hasLanguageWith,omitempty"`

	// "change_history" edge predicates.
	HasChangeHistory     *bool                      `json:"hasChangeHistory,omitempty"`
	HasChangeHistoryWith []*ChangeHistoryWhereInput `json:"hasChangeHistoryWith,omitempty"`

	// "plan_history_user" edge predicates.
	HasPlanHistoryUser     *bool                    `json:"hasPlanHistoryUser,omitempty"`
	HasPlanHistoryUserWith []*PlanHistoryWhereInput `json:"hasPlanHistoryUserWith,omitempty"`

	// "api_token" edge predicates.
	HasAPIToken     *bool                 `json:"hasAPIToken,omitempty"`
	HasAPITokenWith []*APITokenWhereInput `json:"hasAPITokenWith,omitempty"`

	// "selected_workstation" edge predicates.
	HasSelectedWorkstation     *bool                    `json:"hasSelectedWorkstation,omitempty"`
	HasSelectedWorkstationWith []*WorkstationWhereInput `json:"hasSelectedWorkstationWith,omitempty"`

	// "seat_group" edge predicates.
	HasSeatGroup     *bool                  `json:"hasSeatGroup,omitempty"`
	HasSeatGroupWith []*SeatGroupWhereInput `json:"hasSeatGroupWith,omitempty"`

	// "workspace_recent_scan" edge predicates.
	HasWorkspaceRecentScan     *bool                            `json:"hasWorkspaceRecentScan,omitempty"`
	HasWorkspaceRecentScanWith []*WorkspaceRecentScanWhereInput `json:"hasWorkspaceRecentScanWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, user.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, user.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, user.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, user.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, user.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, user.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, user.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, user.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, user.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, user.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, user.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, user.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, user.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, user.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, user.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, user.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, user.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, user.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, user.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, user.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, user.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, user.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, user.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, user.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, user.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, user.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, user.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, user.NameContainsFold(*i.NameContainsFold))
	}
	if i.Surname != nil {
		predicates = append(predicates, user.SurnameEQ(*i.Surname))
	}
	if i.SurnameNEQ != nil {
		predicates = append(predicates, user.SurnameNEQ(*i.SurnameNEQ))
	}
	if len(i.SurnameIn) > 0 {
		predicates = append(predicates, user.SurnameIn(i.SurnameIn...))
	}
	if len(i.SurnameNotIn) > 0 {
		predicates = append(predicates, user.SurnameNotIn(i.SurnameNotIn...))
	}
	if i.SurnameGT != nil {
		predicates = append(predicates, user.SurnameGT(*i.SurnameGT))
	}
	if i.SurnameGTE != nil {
		predicates = append(predicates, user.SurnameGTE(*i.SurnameGTE))
	}
	if i.SurnameLT != nil {
		predicates = append(predicates, user.SurnameLT(*i.SurnameLT))
	}
	if i.SurnameLTE != nil {
		predicates = append(predicates, user.SurnameLTE(*i.SurnameLTE))
	}
	if i.SurnameContains != nil {
		predicates = append(predicates, user.SurnameContains(*i.SurnameContains))
	}
	if i.SurnameHasPrefix != nil {
		predicates = append(predicates, user.SurnameHasPrefix(*i.SurnameHasPrefix))
	}
	if i.SurnameHasSuffix != nil {
		predicates = append(predicates, user.SurnameHasSuffix(*i.SurnameHasSuffix))
	}
	if i.SurnameIsNil {
		predicates = append(predicates, user.SurnameIsNil())
	}
	if i.SurnameNotNil {
		predicates = append(predicates, user.SurnameNotNil())
	}
	if i.SurnameEqualFold != nil {
		predicates = append(predicates, user.SurnameEqualFold(*i.SurnameEqualFold))
	}
	if i.SurnameContainsFold != nil {
		predicates = append(predicates, user.SurnameContainsFold(*i.SurnameContainsFold))
	}
	if i.PhoneNumber != nil {
		predicates = append(predicates, user.PhoneNumberEQ(*i.PhoneNumber))
	}
	if i.PhoneNumberNEQ != nil {
		predicates = append(predicates, user.PhoneNumberNEQ(*i.PhoneNumberNEQ))
	}
	if len(i.PhoneNumberIn) > 0 {
		predicates = append(predicates, user.PhoneNumberIn(i.PhoneNumberIn...))
	}
	if len(i.PhoneNumberNotIn) > 0 {
		predicates = append(predicates, user.PhoneNumberNotIn(i.PhoneNumberNotIn...))
	}
	if i.PhoneNumberGT != nil {
		predicates = append(predicates, user.PhoneNumberGT(*i.PhoneNumberGT))
	}
	if i.PhoneNumberGTE != nil {
		predicates = append(predicates, user.PhoneNumberGTE(*i.PhoneNumberGTE))
	}
	if i.PhoneNumberLT != nil {
		predicates = append(predicates, user.PhoneNumberLT(*i.PhoneNumberLT))
	}
	if i.PhoneNumberLTE != nil {
		predicates = append(predicates, user.PhoneNumberLTE(*i.PhoneNumberLTE))
	}
	if i.PhoneNumberContains != nil {
		predicates = append(predicates, user.PhoneNumberContains(*i.PhoneNumberContains))
	}
	if i.PhoneNumberHasPrefix != nil {
		predicates = append(predicates, user.PhoneNumberHasPrefix(*i.PhoneNumberHasPrefix))
	}
	if i.PhoneNumberHasSuffix != nil {
		predicates = append(predicates, user.PhoneNumberHasSuffix(*i.PhoneNumberHasSuffix))
	}
	if i.PhoneNumberIsNil {
		predicates = append(predicates, user.PhoneNumberIsNil())
	}
	if i.PhoneNumberNotNil {
		predicates = append(predicates, user.PhoneNumberNotNil())
	}
	if i.PhoneNumberEqualFold != nil {
		predicates = append(predicates, user.PhoneNumberEqualFold(*i.PhoneNumberEqualFold))
	}
	if i.PhoneNumberContainsFold != nil {
		predicates = append(predicates, user.PhoneNumberContainsFold(*i.PhoneNumberContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, user.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, user.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Hash != nil {
		predicates = append(predicates, user.HashEQ(*i.Hash))
	}
	if i.HashNEQ != nil {
		predicates = append(predicates, user.HashNEQ(*i.HashNEQ))
	}
	if len(i.HashIn) > 0 {
		predicates = append(predicates, user.HashIn(i.HashIn...))
	}
	if len(i.HashNotIn) > 0 {
		predicates = append(predicates, user.HashNotIn(i.HashNotIn...))
	}
	if i.HashGT != nil {
		predicates = append(predicates, user.HashGT(*i.HashGT))
	}
	if i.HashGTE != nil {
		predicates = append(predicates, user.HashGTE(*i.HashGTE))
	}
	if i.HashLT != nil {
		predicates = append(predicates, user.HashLT(*i.HashLT))
	}
	if i.HashLTE != nil {
		predicates = append(predicates, user.HashLTE(*i.HashLTE))
	}
	if i.HashContains != nil {
		predicates = append(predicates, user.HashContains(*i.HashContains))
	}
	if i.HashHasPrefix != nil {
		predicates = append(predicates, user.HashHasPrefix(*i.HashHasPrefix))
	}
	if i.HashHasSuffix != nil {
		predicates = append(predicates, user.HashHasSuffix(*i.HashHasSuffix))
	}
	if i.HashEqualFold != nil {
		predicates = append(predicates, user.HashEqualFold(*i.HashEqualFold))
	}
	if i.HashContainsFold != nil {
		predicates = append(predicates, user.HashContainsFold(*i.HashContainsFold))
	}
	if i.IsAccountOwner != nil {
		predicates = append(predicates, user.IsAccountOwnerEQ(*i.IsAccountOwner))
	}
	if i.IsAccountOwnerNEQ != nil {
		predicates = append(predicates, user.IsAccountOwnerNEQ(*i.IsAccountOwnerNEQ))
	}
	if i.IsGlobalAdmin != nil {
		predicates = append(predicates, user.IsGlobalAdminEQ(*i.IsGlobalAdmin))
	}
	if i.IsGlobalAdminNEQ != nil {
		predicates = append(predicates, user.IsGlobalAdminNEQ(*i.IsGlobalAdminNEQ))
	}
	if i.MarketingConsent != nil {
		predicates = append(predicates, user.MarketingConsentEQ(*i.MarketingConsent))
	}
	if i.MarketingConsentNEQ != nil {
		predicates = append(predicates, user.MarketingConsentNEQ(*i.MarketingConsentNEQ))
	}
	if i.MarketingConsentIsNil {
		predicates = append(predicates, user.MarketingConsentIsNil())
	}
	if i.MarketingConsentNotNil {
		predicates = append(predicates, user.MarketingConsentNotNil())
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, user.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, user.CreatedAtNotNil())
	}
	if i.ArchivedAt != nil {
		predicates = append(predicates, user.ArchivedAtEQ(*i.ArchivedAt))
	}
	if i.ArchivedAtNEQ != nil {
		predicates = append(predicates, user.ArchivedAtNEQ(*i.ArchivedAtNEQ))
	}
	if len(i.ArchivedAtIn) > 0 {
		predicates = append(predicates, user.ArchivedAtIn(i.ArchivedAtIn...))
	}
	if len(i.ArchivedAtNotIn) > 0 {
		predicates = append(predicates, user.ArchivedAtNotIn(i.ArchivedAtNotIn...))
	}
	if i.ArchivedAtGT != nil {
		predicates = append(predicates, user.ArchivedAtGT(*i.ArchivedAtGT))
	}
	if i.ArchivedAtGTE != nil {
		predicates = append(predicates, user.ArchivedAtGTE(*i.ArchivedAtGTE))
	}
	if i.ArchivedAtLT != nil {
		predicates = append(predicates, user.ArchivedAtLT(*i.ArchivedAtLT))
	}
	if i.ArchivedAtLTE != nil {
		predicates = append(predicates, user.ArchivedAtLTE(*i.ArchivedAtLTE))
	}
	if i.ArchivedAtIsNil {
		predicates = append(predicates, user.ArchivedAtIsNil())
	}
	if i.ArchivedAtNotNil {
		predicates = append(predicates, user.ArchivedAtNotNil())
	}
	if i.PickupDay != nil {
		predicates = append(predicates, user.PickupDayEQ(*i.PickupDay))
	}
	if i.PickupDayNEQ != nil {
		predicates = append(predicates, user.PickupDayNEQ(*i.PickupDayNEQ))
	}
	if len(i.PickupDayIn) > 0 {
		predicates = append(predicates, user.PickupDayIn(i.PickupDayIn...))
	}
	if len(i.PickupDayNotIn) > 0 {
		predicates = append(predicates, user.PickupDayNotIn(i.PickupDayNotIn...))
	}
	if i.PickupDayLastChanged != nil {
		predicates = append(predicates, user.PickupDayLastChangedEQ(*i.PickupDayLastChanged))
	}
	if i.PickupDayLastChangedNEQ != nil {
		predicates = append(predicates, user.PickupDayLastChangedNEQ(*i.PickupDayLastChangedNEQ))
	}
	if len(i.PickupDayLastChangedIn) > 0 {
		predicates = append(predicates, user.PickupDayLastChangedIn(i.PickupDayLastChangedIn...))
	}
	if len(i.PickupDayLastChangedNotIn) > 0 {
		predicates = append(predicates, user.PickupDayLastChangedNotIn(i.PickupDayLastChangedNotIn...))
	}
	if i.PickupDayLastChangedGT != nil {
		predicates = append(predicates, user.PickupDayLastChangedGT(*i.PickupDayLastChangedGT))
	}
	if i.PickupDayLastChangedGTE != nil {
		predicates = append(predicates, user.PickupDayLastChangedGTE(*i.PickupDayLastChangedGTE))
	}
	if i.PickupDayLastChangedLT != nil {
		predicates = append(predicates, user.PickupDayLastChangedLT(*i.PickupDayLastChangedLT))
	}
	if i.PickupDayLastChangedLTE != nil {
		predicates = append(predicates, user.PickupDayLastChangedLTE(*i.PickupDayLastChangedLTE))
	}
	if i.PickupDayLastChangedIsNil {
		predicates = append(predicates, user.PickupDayLastChangedIsNil())
	}
	if i.PickupDayLastChangedNotNil {
		predicates = append(predicates, user.PickupDayLastChangedNotNil())
	}

	if i.HasTenant != nil {
		p := user.HasTenant()
		if !*i.HasTenant {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasTenantWith(with...))
	}
	if i.HasOtkRequests != nil {
		p := user.HasOtkRequests()
		if !*i.HasOtkRequests {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasOtkRequestsWith) > 0 {
		with := make([]predicate.OTKRequests, 0, len(i.HasOtkRequestsWith))
		for _, w := range i.HasOtkRequestsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasOtkRequestsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasOtkRequestsWith(with...))
	}
	if i.HasSignupOptions != nil {
		p := user.HasSignupOptions()
		if !*i.HasSignupOptions {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSignupOptionsWith) > 0 {
		with := make([]predicate.SignupOptions, 0, len(i.HasSignupOptionsWith))
		for _, w := range i.HasSignupOptionsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSignupOptionsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSignupOptionsWith(with...))
	}
	if i.HasLanguage != nil {
		p := user.HasLanguage()
		if !*i.HasLanguage {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasLanguageWith) > 0 {
		with := make([]predicate.Language, 0, len(i.HasLanguageWith))
		for _, w := range i.HasLanguageWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasLanguageWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasLanguageWith(with...))
	}
	if i.HasChangeHistory != nil {
		p := user.HasChangeHistory()
		if !*i.HasChangeHistory {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChangeHistoryWith) > 0 {
		with := make([]predicate.ChangeHistory, 0, len(i.HasChangeHistoryWith))
		for _, w := range i.HasChangeHistoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChangeHistoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasChangeHistoryWith(with...))
	}
	if i.HasPlanHistoryUser != nil {
		p := user.HasPlanHistoryUser()
		if !*i.HasPlanHistoryUser {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPlanHistoryUserWith) > 0 {
		with := make([]predicate.PlanHistory, 0, len(i.HasPlanHistoryUserWith))
		for _, w := range i.HasPlanHistoryUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPlanHistoryUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasPlanHistoryUserWith(with...))
	}
	if i.HasAPIToken != nil {
		p := user.HasAPIToken()
		if !*i.HasAPIToken {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasAPITokenWith) > 0 {
		with := make([]predicate.APIToken, 0, len(i.HasAPITokenWith))
		for _, w := range i.HasAPITokenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasAPITokenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasAPITokenWith(with...))
	}
	if i.HasSelectedWorkstation != nil {
		p := user.HasSelectedWorkstation()
		if !*i.HasSelectedWorkstation {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSelectedWorkstationWith) > 0 {
		with := make([]predicate.Workstation, 0, len(i.HasSelectedWorkstationWith))
		for _, w := range i.HasSelectedWorkstationWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSelectedWorkstationWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSelectedWorkstationWith(with...))
	}
	if i.HasSeatGroup != nil {
		p := user.HasSeatGroup()
		if !*i.HasSeatGroup {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSeatGroupWith) > 0 {
		with := make([]predicate.SeatGroup, 0, len(i.HasSeatGroupWith))
		for _, w := range i.HasSeatGroupWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSeatGroupWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasSeatGroupWith(with...))
	}
	if i.HasWorkspaceRecentScan != nil {
		p := user.HasWorkspaceRecentScan()
		if !*i.HasWorkspaceRecentScan {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkspaceRecentScanWith) > 0 {
		with := make([]predicate.WorkspaceRecentScan, 0, len(i.HasWorkspaceRecentScanWith))
		for _, w := range i.HasWorkspaceRecentScanWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkspaceRecentScanWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasWorkspaceRecentScanWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// UserSeatWhereInput represents a where input for filtering UserSeat queries.
type UserSeatWhereInput struct {
	Predicates []predicate.UserSeat  `json:"-"`
	Not        *UserSeatWhereInput   `json:"not,omitempty"`
	Or         []*UserSeatWhereInput `json:"or,omitempty"`
	And        []*UserSeatWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "surname" field predicates.
	Surname             *string  `json:"surname,omitempty"`
	SurnameNEQ          *string  `json:"surnameNEQ,omitempty"`
	SurnameIn           []string `json:"surnameIn,omitempty"`
	SurnameNotIn        []string `json:"surnameNotIn,omitempty"`
	SurnameGT           *string  `json:"surnameGT,omitempty"`
	SurnameGTE          *string  `json:"surnameGTE,omitempty"`
	SurnameLT           *string  `json:"surnameLT,omitempty"`
	SurnameLTE          *string  `json:"surnameLTE,omitempty"`
	SurnameContains     *string  `json:"surnameContains,omitempty"`
	SurnameHasPrefix    *string  `json:"surnameHasPrefix,omitempty"`
	SurnameHasSuffix    *string  `json:"surnameHasSuffix,omitempty"`
	SurnameIsNil        bool     `json:"surnameIsNil,omitempty"`
	SurnameNotNil       bool     `json:"surnameNotNil,omitempty"`
	SurnameEqualFold    *string  `json:"surnameEqualFold,omitempty"`
	SurnameContainsFold *string  `json:"surnameContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserSeatWhereInput) AddPredicates(predicates ...predicate.UserSeat) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserSeatWhereInput filter on the UserSeatQuery builder.
func (i *UserSeatWhereInput) Filter(q *UserSeatQuery) (*UserSeatQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserSeatWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserSeatWhereInput is returned in case the UserSeatWhereInput is empty.
var ErrEmptyUserSeatWhereInput = errors.New("ent: empty predicate UserSeatWhereInput")

// P returns a predicate for filtering userseats.
// An error is returned if the input is empty or invalid.
func (i *UserSeatWhereInput) P() (predicate.UserSeat, error) {
	var predicates []predicate.UserSeat
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, userseat.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.UserSeat, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, userseat.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.UserSeat, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, userseat.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, userseat.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, userseat.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, userseat.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, userseat.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, userseat.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, userseat.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, userseat.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, userseat.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, userseat.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, userseat.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, userseat.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, userseat.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, userseat.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, userseat.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, userseat.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, userseat.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, userseat.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, userseat.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, userseat.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, userseat.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, userseat.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.Name != nil {
		predicates = append(predicates, userseat.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, userseat.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, userseat.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, userseat.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, userseat.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, userseat.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, userseat.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, userseat.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, userseat.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, userseat.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, userseat.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, userseat.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, userseat.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, userseat.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, userseat.NameContainsFold(*i.NameContainsFold))
	}
	if i.Surname != nil {
		predicates = append(predicates, userseat.SurnameEQ(*i.Surname))
	}
	if i.SurnameNEQ != nil {
		predicates = append(predicates, userseat.SurnameNEQ(*i.SurnameNEQ))
	}
	if len(i.SurnameIn) > 0 {
		predicates = append(predicates, userseat.SurnameIn(i.SurnameIn...))
	}
	if len(i.SurnameNotIn) > 0 {
		predicates = append(predicates, userseat.SurnameNotIn(i.SurnameNotIn...))
	}
	if i.SurnameGT != nil {
		predicates = append(predicates, userseat.SurnameGT(*i.SurnameGT))
	}
	if i.SurnameGTE != nil {
		predicates = append(predicates, userseat.SurnameGTE(*i.SurnameGTE))
	}
	if i.SurnameLT != nil {
		predicates = append(predicates, userseat.SurnameLT(*i.SurnameLT))
	}
	if i.SurnameLTE != nil {
		predicates = append(predicates, userseat.SurnameLTE(*i.SurnameLTE))
	}
	if i.SurnameContains != nil {
		predicates = append(predicates, userseat.SurnameContains(*i.SurnameContains))
	}
	if i.SurnameHasPrefix != nil {
		predicates = append(predicates, userseat.SurnameHasPrefix(*i.SurnameHasPrefix))
	}
	if i.SurnameHasSuffix != nil {
		predicates = append(predicates, userseat.SurnameHasSuffix(*i.SurnameHasSuffix))
	}
	if i.SurnameIsNil {
		predicates = append(predicates, userseat.SurnameIsNil())
	}
	if i.SurnameNotNil {
		predicates = append(predicates, userseat.SurnameNotNil())
	}
	if i.SurnameEqualFold != nil {
		predicates = append(predicates, userseat.SurnameEqualFold(*i.SurnameEqualFold))
	}
	if i.SurnameContainsFold != nil {
		predicates = append(predicates, userseat.SurnameContainsFold(*i.SurnameContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, userseat.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, userseat.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, userseat.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, userseat.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, userseat.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, userseat.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, userseat.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, userseat.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, userseat.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, userseat.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, userseat.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, userseat.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, userseat.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, userseat.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, userseat.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, userseat.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, userseat.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, userseat.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, userseat.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, userseat.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, userseat.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasTenant != nil {
		p := userseat.HasTenant()
		if !*i.HasTenant {
			p = userseat.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, userseat.HasTenantWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserSeatWhereInput
	case 1:
		return predicates[0], nil
	default:
		return userseat.And(predicates...), nil
	}
}

// WorkspaceRecentScanWhereInput represents a where input for filtering WorkspaceRecentScan queries.
type WorkspaceRecentScanWhereInput struct {
	Predicates []predicate.WorkspaceRecentScan  `json:"-"`
	Not        *WorkspaceRecentScanWhereInput   `json:"not,omitempty"`
	Or         []*WorkspaceRecentScanWhereInput `json:"or,omitempty"`
	And        []*WorkspaceRecentScanWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "shipment_parcel" edge predicates.
	HasShipmentParcel     *bool                       `json:"hasShipmentParcel,omitempty"`
	HasShipmentParcelWith []*ShipmentParcelWhereInput `json:"hasShipmentParcelWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorkspaceRecentScanWhereInput) AddPredicates(predicates ...predicate.WorkspaceRecentScan) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorkspaceRecentScanWhereInput filter on the WorkspaceRecentScanQuery builder.
func (i *WorkspaceRecentScanWhereInput) Filter(q *WorkspaceRecentScanQuery) (*WorkspaceRecentScanQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorkspaceRecentScanWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorkspaceRecentScanWhereInput is returned in case the WorkspaceRecentScanWhereInput is empty.
var ErrEmptyWorkspaceRecentScanWhereInput = errors.New("ent: empty predicate WorkspaceRecentScanWhereInput")

// P returns a predicate for filtering workspacerecentscans.
// An error is returned if the input is empty or invalid.
func (i *WorkspaceRecentScanWhereInput) P() (predicate.WorkspaceRecentScan, error) {
	var predicates []predicate.WorkspaceRecentScan
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, workspacerecentscan.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WorkspaceRecentScan, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, workspacerecentscan.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WorkspaceRecentScan, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, workspacerecentscan.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, workspacerecentscan.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, workspacerecentscan.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, workspacerecentscan.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, workspacerecentscan.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, workspacerecentscan.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, workspacerecentscan.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, workspacerecentscan.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, workspacerecentscan.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, workspacerecentscan.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, workspacerecentscan.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, workspacerecentscan.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, workspacerecentscan.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, workspacerecentscan.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, workspacerecentscan.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, workspacerecentscan.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, workspacerecentscan.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, workspacerecentscan.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, workspacerecentscan.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, workspacerecentscan.CreatedAtLTE(*i.CreatedAtLTE))
	}

	if i.HasTenant != nil {
		p := workspacerecentscan.HasTenant()
		if !*i.HasTenant {
			p = workspacerecentscan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workspacerecentscan.HasTenantWith(with...))
	}
	if i.HasShipmentParcel != nil {
		p := workspacerecentscan.HasShipmentParcel()
		if !*i.HasShipmentParcel {
			p = workspacerecentscan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasShipmentParcelWith) > 0 {
		with := make([]predicate.ShipmentParcel, 0, len(i.HasShipmentParcelWith))
		for _, w := range i.HasShipmentParcelWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasShipmentParcelWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workspacerecentscan.HasShipmentParcelWith(with...))
	}
	if i.HasUser != nil {
		p := workspacerecentscan.HasUser()
		if !*i.HasUser {
			p = workspacerecentscan.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workspacerecentscan.HasUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorkspaceRecentScanWhereInput
	case 1:
		return predicates[0], nil
	default:
		return workspacerecentscan.And(predicates...), nil
	}
}

// WorkstationWhereInput represents a where input for filtering Workstation queries.
type WorkstationWhereInput struct {
	Predicates []predicate.Workstation  `json:"-"`
	Not        *WorkstationWhereInput   `json:"not,omitempty"`
	Or         []*WorkstationWhereInput `json:"or,omitempty"`
	And        []*WorkstationWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID      *pulid.ID  `json:"id,omitempty"`
	IDNEQ   *pulid.ID  `json:"idNEQ,omitempty"`
	IDIn    []pulid.ID `json:"idIn,omitempty"`
	IDNotIn []pulid.ID `json:"idNotIn,omitempty"`
	IDGT    *pulid.ID  `json:"idGT,omitempty"`
	IDGTE   *pulid.ID  `json:"idGTE,omitempty"`
	IDLT    *pulid.ID  `json:"idLT,omitempty"`
	IDLTE   *pulid.ID  `json:"idLTE,omitempty"`

	// "tenant_id" field predicates.
	TenantID             *pulid.ID  `json:"tenantID,omitempty"`
	TenantIDNEQ          *pulid.ID  `json:"tenantIDNEQ,omitempty"`
	TenantIDIn           []pulid.ID `json:"tenantIDIn,omitempty"`
	TenantIDNotIn        []pulid.ID `json:"tenantIDNotIn,omitempty"`
	TenantIDGT           *pulid.ID  `json:"tenantIDGT,omitempty"`
	TenantIDGTE          *pulid.ID  `json:"tenantIDGTE,omitempty"`
	TenantIDLT           *pulid.ID  `json:"tenantIDLT,omitempty"`
	TenantIDLTE          *pulid.ID  `json:"tenantIDLTE,omitempty"`
	TenantIDContains     *pulid.ID  `json:"tenantIDContains,omitempty"`
	TenantIDHasPrefix    *pulid.ID  `json:"tenantIDHasPrefix,omitempty"`
	TenantIDHasSuffix    *pulid.ID  `json:"tenantIDHasSuffix,omitempty"`
	TenantIDEqualFold    *pulid.ID  `json:"tenantIDEqualFold,omitempty"`
	TenantIDContainsFold *pulid.ID  `json:"tenantIDContainsFold,omitempty"`

	// "archived_at" field predicates.
	ArchivedAt       *time.Time  `json:"archivedAt,omitempty"`
	ArchivedAtNEQ    *time.Time  `json:"archivedAtNEQ,omitempty"`
	ArchivedAtIn     []time.Time `json:"archivedAtIn,omitempty"`
	ArchivedAtNotIn  []time.Time `json:"archivedAtNotIn,omitempty"`
	ArchivedAtGT     *time.Time  `json:"archivedAtGT,omitempty"`
	ArchivedAtGTE    *time.Time  `json:"archivedAtGTE,omitempty"`
	ArchivedAtLT     *time.Time  `json:"archivedAtLT,omitempty"`
	ArchivedAtLTE    *time.Time  `json:"archivedAtLTE,omitempty"`
	ArchivedAtIsNil  bool        `json:"archivedAtIsNil,omitempty"`
	ArchivedAtNotNil bool        `json:"archivedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "device_type" field predicates.
	DeviceType      *workstation.DeviceType  `json:"deviceType,omitempty"`
	DeviceTypeNEQ   *workstation.DeviceType  `json:"deviceTypeNEQ,omitempty"`
	DeviceTypeIn    []workstation.DeviceType `json:"deviceTypeIn,omitempty"`
	DeviceTypeNotIn []workstation.DeviceType `json:"deviceTypeNotIn,omitempty"`

	// "registration_code" field predicates.
	RegistrationCode             *string  `json:"registrationCode,omitempty"`
	RegistrationCodeNEQ          *string  `json:"registrationCodeNEQ,omitempty"`
	RegistrationCodeIn           []string `json:"registrationCodeIn,omitempty"`
	RegistrationCodeNotIn        []string `json:"registrationCodeNotIn,omitempty"`
	RegistrationCodeGT           *string  `json:"registrationCodeGT,omitempty"`
	RegistrationCodeGTE          *string  `json:"registrationCodeGTE,omitempty"`
	RegistrationCodeLT           *string  `json:"registrationCodeLT,omitempty"`
	RegistrationCodeLTE          *string  `json:"registrationCodeLTE,omitempty"`
	RegistrationCodeContains     *string  `json:"registrationCodeContains,omitempty"`
	RegistrationCodeHasPrefix    *string  `json:"registrationCodeHasPrefix,omitempty"`
	RegistrationCodeHasSuffix    *string  `json:"registrationCodeHasSuffix,omitempty"`
	RegistrationCodeEqualFold    *string  `json:"registrationCodeEqualFold,omitempty"`
	RegistrationCodeContainsFold *string  `json:"registrationCodeContainsFold,omitempty"`

	// "workstation_id" field predicates.
	WorkstationID             *pulid.ID  `json:"workstationID,omitempty"`
	WorkstationIDNEQ          *pulid.ID  `json:"workstationIDNEQ,omitempty"`
	WorkstationIDIn           []pulid.ID `json:"workstationIDIn,omitempty"`
	WorkstationIDNotIn        []pulid.ID `json:"workstationIDNotIn,omitempty"`
	WorkstationIDGT           *pulid.ID  `json:"workstationIDGT,omitempty"`
	WorkstationIDGTE          *pulid.ID  `json:"workstationIDGTE,omitempty"`
	WorkstationIDLT           *pulid.ID  `json:"workstationIDLT,omitempty"`
	WorkstationIDLTE          *pulid.ID  `json:"workstationIDLTE,omitempty"`
	WorkstationIDContains     *pulid.ID  `json:"workstationIDContains,omitempty"`
	WorkstationIDHasPrefix    *pulid.ID  `json:"workstationIDHasPrefix,omitempty"`
	WorkstationIDHasSuffix    *pulid.ID  `json:"workstationIDHasSuffix,omitempty"`
	WorkstationIDEqualFold    *pulid.ID  `json:"workstationIDEqualFold,omitempty"`
	WorkstationIDContainsFold *pulid.ID  `json:"workstationIDContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt      *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ   *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn    []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT    *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE   *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT    *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE   *time.Time  `json:"createdAtLTE,omitempty"`

	// "last_ping" field predicates.
	LastPing       *time.Time  `json:"lastPing,omitempty"`
	LastPingNEQ    *time.Time  `json:"lastPingNEQ,omitempty"`
	LastPingIn     []time.Time `json:"lastPingIn,omitempty"`
	LastPingNotIn  []time.Time `json:"lastPingNotIn,omitempty"`
	LastPingGT     *time.Time  `json:"lastPingGT,omitempty"`
	LastPingGTE    *time.Time  `json:"lastPingGTE,omitempty"`
	LastPingLT     *time.Time  `json:"lastPingLT,omitempty"`
	LastPingLTE    *time.Time  `json:"lastPingLTE,omitempty"`
	LastPingIsNil  bool        `json:"lastPingIsNil,omitempty"`
	LastPingNotNil bool        `json:"lastPingNotNil,omitempty"`

	// "status" field predicates.
	Status      *workstation.Status  `json:"status,omitempty"`
	StatusNEQ   *workstation.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []workstation.Status `json:"statusIn,omitempty"`
	StatusNotIn []workstation.Status `json:"statusNotIn,omitempty"`

	// "auto_print_receiver" field predicates.
	AutoPrintReceiver    *bool `json:"autoPrintReceiver,omitempty"`
	AutoPrintReceiverNEQ *bool `json:"autoPrintReceiverNEQ,omitempty"`

	// "tenant" edge predicates.
	HasTenant     *bool               `json:"hasTenant,omitempty"`
	HasTenantWith []*TenantWhereInput `json:"hasTenantWith,omitempty"`

	// "printer" edge predicates.
	HasPrinter     *bool                `json:"hasPrinter,omitempty"`
	HasPrinterWith []*PrinterWhereInput `json:"hasPrinterWith,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "selected_user" edge predicates.
	HasSelectedUser     *bool             `json:"hasSelectedUser,omitempty"`
	HasSelectedUserWith []*UserWhereInput `json:"hasSelectedUserWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorkstationWhereInput) AddPredicates(predicates ...predicate.Workstation) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorkstationWhereInput filter on the WorkstationQuery builder.
func (i *WorkstationWhereInput) Filter(q *WorkstationQuery) (*WorkstationQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorkstationWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorkstationWhereInput is returned in case the WorkstationWhereInput is empty.
var ErrEmptyWorkstationWhereInput = errors.New("ent: empty predicate WorkstationWhereInput")

// P returns a predicate for filtering workstations.
// An error is returned if the input is empty or invalid.
func (i *WorkstationWhereInput) P() (predicate.Workstation, error) {
	var predicates []predicate.Workstation
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, workstation.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Workstation, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, workstation.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Workstation, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, workstation.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, workstation.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, workstation.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, workstation.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, workstation.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, workstation.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, workstation.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, workstation.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, workstation.IDLTE(*i.IDLTE))
	}
	if i.TenantID != nil {
		predicates = append(predicates, workstation.TenantIDEQ(*i.TenantID))
	}
	if i.TenantIDNEQ != nil {
		predicates = append(predicates, workstation.TenantIDNEQ(*i.TenantIDNEQ))
	}
	if len(i.TenantIDIn) > 0 {
		predicates = append(predicates, workstation.TenantIDIn(i.TenantIDIn...))
	}
	if len(i.TenantIDNotIn) > 0 {
		predicates = append(predicates, workstation.TenantIDNotIn(i.TenantIDNotIn...))
	}
	if i.TenantIDGT != nil {
		predicates = append(predicates, workstation.TenantIDGT(*i.TenantIDGT))
	}
	if i.TenantIDGTE != nil {
		predicates = append(predicates, workstation.TenantIDGTE(*i.TenantIDGTE))
	}
	if i.TenantIDLT != nil {
		predicates = append(predicates, workstation.TenantIDLT(*i.TenantIDLT))
	}
	if i.TenantIDLTE != nil {
		predicates = append(predicates, workstation.TenantIDLTE(*i.TenantIDLTE))
	}
	if i.TenantIDContains != nil {
		predicates = append(predicates, workstation.TenantIDContains(*i.TenantIDContains))
	}
	if i.TenantIDHasPrefix != nil {
		predicates = append(predicates, workstation.TenantIDHasPrefix(*i.TenantIDHasPrefix))
	}
	if i.TenantIDHasSuffix != nil {
		predicates = append(predicates, workstation.TenantIDHasSuffix(*i.TenantIDHasSuffix))
	}
	if i.TenantIDEqualFold != nil {
		predicates = append(predicates, workstation.TenantIDEqualFold(*i.TenantIDEqualFold))
	}
	if i.TenantIDContainsFold != nil {
		predicates = append(predicates, workstation.TenantIDContainsFold(*i.TenantIDContainsFold))
	}
	if i.ArchivedAt != nil {
		predicates = append(predicates, workstation.ArchivedAtEQ(*i.ArchivedAt))
	}
	if i.ArchivedAtNEQ != nil {
		predicates = append(predicates, workstation.ArchivedAtNEQ(*i.ArchivedAtNEQ))
	}
	if len(i.ArchivedAtIn) > 0 {
		predicates = append(predicates, workstation.ArchivedAtIn(i.ArchivedAtIn...))
	}
	if len(i.ArchivedAtNotIn) > 0 {
		predicates = append(predicates, workstation.ArchivedAtNotIn(i.ArchivedAtNotIn...))
	}
	if i.ArchivedAtGT != nil {
		predicates = append(predicates, workstation.ArchivedAtGT(*i.ArchivedAtGT))
	}
	if i.ArchivedAtGTE != nil {
		predicates = append(predicates, workstation.ArchivedAtGTE(*i.ArchivedAtGTE))
	}
	if i.ArchivedAtLT != nil {
		predicates = append(predicates, workstation.ArchivedAtLT(*i.ArchivedAtLT))
	}
	if i.ArchivedAtLTE != nil {
		predicates = append(predicates, workstation.ArchivedAtLTE(*i.ArchivedAtLTE))
	}
	if i.ArchivedAtIsNil {
		predicates = append(predicates, workstation.ArchivedAtIsNil())
	}
	if i.ArchivedAtNotNil {
		predicates = append(predicates, workstation.ArchivedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, workstation.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, workstation.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, workstation.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, workstation.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, workstation.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, workstation.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, workstation.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, workstation.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, workstation.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, workstation.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, workstation.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, workstation.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, workstation.NameContainsFold(*i.NameContainsFold))
	}
	if i.DeviceType != nil {
		predicates = append(predicates, workstation.DeviceTypeEQ(*i.DeviceType))
	}
	if i.DeviceTypeNEQ != nil {
		predicates = append(predicates, workstation.DeviceTypeNEQ(*i.DeviceTypeNEQ))
	}
	if len(i.DeviceTypeIn) > 0 {
		predicates = append(predicates, workstation.DeviceTypeIn(i.DeviceTypeIn...))
	}
	if len(i.DeviceTypeNotIn) > 0 {
		predicates = append(predicates, workstation.DeviceTypeNotIn(i.DeviceTypeNotIn...))
	}
	if i.RegistrationCode != nil {
		predicates = append(predicates, workstation.RegistrationCodeEQ(*i.RegistrationCode))
	}
	if i.RegistrationCodeNEQ != nil {
		predicates = append(predicates, workstation.RegistrationCodeNEQ(*i.RegistrationCodeNEQ))
	}
	if len(i.RegistrationCodeIn) > 0 {
		predicates = append(predicates, workstation.RegistrationCodeIn(i.RegistrationCodeIn...))
	}
	if len(i.RegistrationCodeNotIn) > 0 {
		predicates = append(predicates, workstation.RegistrationCodeNotIn(i.RegistrationCodeNotIn...))
	}
	if i.RegistrationCodeGT != nil {
		predicates = append(predicates, workstation.RegistrationCodeGT(*i.RegistrationCodeGT))
	}
	if i.RegistrationCodeGTE != nil {
		predicates = append(predicates, workstation.RegistrationCodeGTE(*i.RegistrationCodeGTE))
	}
	if i.RegistrationCodeLT != nil {
		predicates = append(predicates, workstation.RegistrationCodeLT(*i.RegistrationCodeLT))
	}
	if i.RegistrationCodeLTE != nil {
		predicates = append(predicates, workstation.RegistrationCodeLTE(*i.RegistrationCodeLTE))
	}
	if i.RegistrationCodeContains != nil {
		predicates = append(predicates, workstation.RegistrationCodeContains(*i.RegistrationCodeContains))
	}
	if i.RegistrationCodeHasPrefix != nil {
		predicates = append(predicates, workstation.RegistrationCodeHasPrefix(*i.RegistrationCodeHasPrefix))
	}
	if i.RegistrationCodeHasSuffix != nil {
		predicates = append(predicates, workstation.RegistrationCodeHasSuffix(*i.RegistrationCodeHasSuffix))
	}
	if i.RegistrationCodeEqualFold != nil {
		predicates = append(predicates, workstation.RegistrationCodeEqualFold(*i.RegistrationCodeEqualFold))
	}
	if i.RegistrationCodeContainsFold != nil {
		predicates = append(predicates, workstation.RegistrationCodeContainsFold(*i.RegistrationCodeContainsFold))
	}
	if i.WorkstationID != nil {
		predicates = append(predicates, workstation.WorkstationIDEQ(*i.WorkstationID))
	}
	if i.WorkstationIDNEQ != nil {
		predicates = append(predicates, workstation.WorkstationIDNEQ(*i.WorkstationIDNEQ))
	}
	if len(i.WorkstationIDIn) > 0 {
		predicates = append(predicates, workstation.WorkstationIDIn(i.WorkstationIDIn...))
	}
	if len(i.WorkstationIDNotIn) > 0 {
		predicates = append(predicates, workstation.WorkstationIDNotIn(i.WorkstationIDNotIn...))
	}
	if i.WorkstationIDGT != nil {
		predicates = append(predicates, workstation.WorkstationIDGT(*i.WorkstationIDGT))
	}
	if i.WorkstationIDGTE != nil {
		predicates = append(predicates, workstation.WorkstationIDGTE(*i.WorkstationIDGTE))
	}
	if i.WorkstationIDLT != nil {
		predicates = append(predicates, workstation.WorkstationIDLT(*i.WorkstationIDLT))
	}
	if i.WorkstationIDLTE != nil {
		predicates = append(predicates, workstation.WorkstationIDLTE(*i.WorkstationIDLTE))
	}
	if i.WorkstationIDContains != nil {
		predicates = append(predicates, workstation.WorkstationIDContains(*i.WorkstationIDContains))
	}
	if i.WorkstationIDHasPrefix != nil {
		predicates = append(predicates, workstation.WorkstationIDHasPrefix(*i.WorkstationIDHasPrefix))
	}
	if i.WorkstationIDHasSuffix != nil {
		predicates = append(predicates, workstation.WorkstationIDHasSuffix(*i.WorkstationIDHasSuffix))
	}
	if i.WorkstationIDEqualFold != nil {
		predicates = append(predicates, workstation.WorkstationIDEqualFold(*i.WorkstationIDEqualFold))
	}
	if i.WorkstationIDContainsFold != nil {
		predicates = append(predicates, workstation.WorkstationIDContainsFold(*i.WorkstationIDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, workstation.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, workstation.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, workstation.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, workstation.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, workstation.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, workstation.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, workstation.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, workstation.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.LastPing != nil {
		predicates = append(predicates, workstation.LastPingEQ(*i.LastPing))
	}
	if i.LastPingNEQ != nil {
		predicates = append(predicates, workstation.LastPingNEQ(*i.LastPingNEQ))
	}
	if len(i.LastPingIn) > 0 {
		predicates = append(predicates, workstation.LastPingIn(i.LastPingIn...))
	}
	if len(i.LastPingNotIn) > 0 {
		predicates = append(predicates, workstation.LastPingNotIn(i.LastPingNotIn...))
	}
	if i.LastPingGT != nil {
		predicates = append(predicates, workstation.LastPingGT(*i.LastPingGT))
	}
	if i.LastPingGTE != nil {
		predicates = append(predicates, workstation.LastPingGTE(*i.LastPingGTE))
	}
	if i.LastPingLT != nil {
		predicates = append(predicates, workstation.LastPingLT(*i.LastPingLT))
	}
	if i.LastPingLTE != nil {
		predicates = append(predicates, workstation.LastPingLTE(*i.LastPingLTE))
	}
	if i.LastPingIsNil {
		predicates = append(predicates, workstation.LastPingIsNil())
	}
	if i.LastPingNotNil {
		predicates = append(predicates, workstation.LastPingNotNil())
	}
	if i.Status != nil {
		predicates = append(predicates, workstation.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, workstation.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, workstation.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, workstation.StatusNotIn(i.StatusNotIn...))
	}
	if i.AutoPrintReceiver != nil {
		predicates = append(predicates, workstation.AutoPrintReceiverEQ(*i.AutoPrintReceiver))
	}
	if i.AutoPrintReceiverNEQ != nil {
		predicates = append(predicates, workstation.AutoPrintReceiverNEQ(*i.AutoPrintReceiverNEQ))
	}

	if i.HasTenant != nil {
		p := workstation.HasTenant()
		if !*i.HasTenant {
			p = workstation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasTenantWith) > 0 {
		with := make([]predicate.Tenant, 0, len(i.HasTenantWith))
		for _, w := range i.HasTenantWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasTenantWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workstation.HasTenantWith(with...))
	}
	if i.HasPrinter != nil {
		p := workstation.HasPrinter()
		if !*i.HasPrinter {
			p = workstation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPrinterWith) > 0 {
		with := make([]predicate.Printer, 0, len(i.HasPrinterWith))
		for _, w := range i.HasPrinterWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPrinterWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workstation.HasPrinterWith(with...))
	}
	if i.HasUser != nil {
		p := workstation.HasUser()
		if !*i.HasUser {
			p = workstation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workstation.HasUserWith(with...))
	}
	if i.HasSelectedUser != nil {
		p := workstation.HasSelectedUser()
		if !*i.HasSelectedUser {
			p = workstation.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSelectedUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasSelectedUserWith))
		for _, w := range i.HasSelectedUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSelectedUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workstation.HasSelectedUserWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorkstationWhereInput
	case 1:
		return predicates[0], nil
	default:
		return workstation.And(predicates...), nil
	}
}
