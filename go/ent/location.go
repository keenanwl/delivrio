// Code generated by ent, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"delivrio.io/go/ent/address"
	"delivrio.io/go/ent/location"
	"delivrio.io/go/ent/tenant"
	"delivrio.io/shared-utils/pulid"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

// Location is the model entity for the Location schema.
type Location struct {
	config `json:"-"`
	// ID of the ent.
	ID pulid.ID `json:"id,omitempty"`
	// TenantID holds the value of the "tenant_id" field.
	TenantID pulid.ID `json:"tenant_id,omitempty"`
	// Location name, not used in the address
	Name string `json:"name,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the LocationQuery when eager-loading is set.
	Edges            LocationEdges `json:"edges"`
	location_address *pulid.ID
	selectValues     sql.SelectValues
}

// LocationEdges holds the relations/edges for other nodes in the graph.
type LocationEdges struct {
	// Tenant holds the value of the tenant edge.
	Tenant *Tenant `json:"tenant,omitempty"`
	// Address holds the value of the address edge.
	Address *Address `json:"address,omitempty"`
	// LocationTags holds the value of the location_tags edge.
	LocationTags []*LocationTag `json:"location_tags,omitempty"`
	// SenderConnection holds the value of the sender_connection edge.
	SenderConnection []*Connection `json:"sender_connection,omitempty"`
	// PickupConnection holds the value of the pickup_connection edge.
	PickupConnection []*Connection `json:"pickup_connection,omitempty"`
	// ReturnConnection holds the value of the return_connection edge.
	ReturnConnection []*Connection `json:"return_connection,omitempty"`
	// SellerConnection holds the value of the seller_connection edge.
	SellerConnection []*Connection `json:"seller_connection,omitempty"`
	// ReturnPortal holds the value of the return_portal edge.
	ReturnPortal []*ReturnPortal `json:"return_portal,omitempty"`
	// DeliveryOption holds the value of the delivery_option edge.
	DeliveryOption []*DeliveryOption `json:"delivery_option,omitempty"`
	// Colli holds the value of the colli edge.
	Colli []*Colli `json:"colli,omitempty"`
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [10]bool
	// totalCount holds the count of the edges above.
	totalCount [10]map[string]int

	namedLocationTags     map[string][]*LocationTag
	namedSenderConnection map[string][]*Connection
	namedPickupConnection map[string][]*Connection
	namedReturnConnection map[string][]*Connection
	namedSellerConnection map[string][]*Connection
	namedReturnPortal     map[string][]*ReturnPortal
	namedDeliveryOption   map[string][]*DeliveryOption
	namedColli            map[string][]*Colli
}

// TenantOrErr returns the Tenant value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e LocationEdges) TenantOrErr() (*Tenant, error) {
	if e.Tenant != nil {
		return e.Tenant, nil
	} else if e.loadedTypes[0] {
		return nil, &NotFoundError{label: tenant.Label}
	}
	return nil, &NotLoadedError{edge: "tenant"}
}

// AddressOrErr returns the Address value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e LocationEdges) AddressOrErr() (*Address, error) {
	if e.Address != nil {
		return e.Address, nil
	} else if e.loadedTypes[1] {
		return nil, &NotFoundError{label: address.Label}
	}
	return nil, &NotLoadedError{edge: "address"}
}

// LocationTagsOrErr returns the LocationTags value or an error if the edge
// was not loaded in eager-loading.
func (e LocationEdges) LocationTagsOrErr() ([]*LocationTag, error) {
	if e.loadedTypes[2] {
		return e.LocationTags, nil
	}
	return nil, &NotLoadedError{edge: "location_tags"}
}

// SenderConnectionOrErr returns the SenderConnection value or an error if the edge
// was not loaded in eager-loading.
func (e LocationEdges) SenderConnectionOrErr() ([]*Connection, error) {
	if e.loadedTypes[3] {
		return e.SenderConnection, nil
	}
	return nil, &NotLoadedError{edge: "sender_connection"}
}

// PickupConnectionOrErr returns the PickupConnection value or an error if the edge
// was not loaded in eager-loading.
func (e LocationEdges) PickupConnectionOrErr() ([]*Connection, error) {
	if e.loadedTypes[4] {
		return e.PickupConnection, nil
	}
	return nil, &NotLoadedError{edge: "pickup_connection"}
}

// ReturnConnectionOrErr returns the ReturnConnection value or an error if the edge
// was not loaded in eager-loading.
func (e LocationEdges) ReturnConnectionOrErr() ([]*Connection, error) {
	if e.loadedTypes[5] {
		return e.ReturnConnection, nil
	}
	return nil, &NotLoadedError{edge: "return_connection"}
}

// SellerConnectionOrErr returns the SellerConnection value or an error if the edge
// was not loaded in eager-loading.
func (e LocationEdges) SellerConnectionOrErr() ([]*Connection, error) {
	if e.loadedTypes[6] {
		return e.SellerConnection, nil
	}
	return nil, &NotLoadedError{edge: "seller_connection"}
}

// ReturnPortalOrErr returns the ReturnPortal value or an error if the edge
// was not loaded in eager-loading.
func (e LocationEdges) ReturnPortalOrErr() ([]*ReturnPortal, error) {
	if e.loadedTypes[7] {
		return e.ReturnPortal, nil
	}
	return nil, &NotLoadedError{edge: "return_portal"}
}

// DeliveryOptionOrErr returns the DeliveryOption value or an error if the edge
// was not loaded in eager-loading.
func (e LocationEdges) DeliveryOptionOrErr() ([]*DeliveryOption, error) {
	if e.loadedTypes[8] {
		return e.DeliveryOption, nil
	}
	return nil, &NotLoadedError{edge: "delivery_option"}
}

// ColliOrErr returns the Colli value or an error if the edge
// was not loaded in eager-loading.
func (e LocationEdges) ColliOrErr() ([]*Colli, error) {
	if e.loadedTypes[9] {
		return e.Colli, nil
	}
	return nil, &NotLoadedError{edge: "colli"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Location) scanValues(columns []string) ([]any, error) {
	values := make([]any, len(columns))
	for i := range columns {
		switch columns[i] {
		case location.FieldID, location.FieldTenantID:
			values[i] = new(pulid.ID)
		case location.FieldName:
			values[i] = new(sql.NullString)
		case location.ForeignKeys[0]: // location_address
			values[i] = &sql.NullScanner{S: new(pulid.ID)}
		default:
			values[i] = new(sql.UnknownType)
		}
	}
	return values, nil
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Location fields.
func (l *Location) assignValues(columns []string, values []any) error {
	if m, n := len(values), len(columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	for i := range columns {
		switch columns[i] {
		case location.FieldID:
			if value, ok := values[i].(*pulid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field id", values[i])
			} else if value != nil {
				l.ID = *value
			}
		case location.FieldTenantID:
			if value, ok := values[i].(*pulid.ID); !ok {
				return fmt.Errorf("unexpected type %T for field tenant_id", values[i])
			} else if value != nil {
				l.TenantID = *value
			}
		case location.FieldName:
			if value, ok := values[i].(*sql.NullString); !ok {
				return fmt.Errorf("unexpected type %T for field name", values[i])
			} else if value.Valid {
				l.Name = value.String
			}
		case location.ForeignKeys[0]:
			if value, ok := values[i].(*sql.NullScanner); !ok {
				return fmt.Errorf("unexpected type %T for field location_address", values[i])
			} else if value.Valid {
				l.location_address = new(pulid.ID)
				*l.location_address = *value.S.(*pulid.ID)
			}
		default:
			l.selectValues.Set(columns[i], values[i])
		}
	}
	return nil
}

// Value returns the ent.Value that was dynamically selected and assigned to the Location.
// This includes values selected through modifiers, order, etc.
func (l *Location) Value(name string) (ent.Value, error) {
	return l.selectValues.Get(name)
}

// QueryTenant queries the "tenant" edge of the Location entity.
func (l *Location) QueryTenant() *TenantQuery {
	return NewLocationClient(l.config).QueryTenant(l)
}

// QueryAddress queries the "address" edge of the Location entity.
func (l *Location) QueryAddress() *AddressQuery {
	return NewLocationClient(l.config).QueryAddress(l)
}

// QueryLocationTags queries the "location_tags" edge of the Location entity.
func (l *Location) QueryLocationTags() *LocationTagQuery {
	return NewLocationClient(l.config).QueryLocationTags(l)
}

// QuerySenderConnection queries the "sender_connection" edge of the Location entity.
func (l *Location) QuerySenderConnection() *ConnectionQuery {
	return NewLocationClient(l.config).QuerySenderConnection(l)
}

// QueryPickupConnection queries the "pickup_connection" edge of the Location entity.
func (l *Location) QueryPickupConnection() *ConnectionQuery {
	return NewLocationClient(l.config).QueryPickupConnection(l)
}

// QueryReturnConnection queries the "return_connection" edge of the Location entity.
func (l *Location) QueryReturnConnection() *ConnectionQuery {
	return NewLocationClient(l.config).QueryReturnConnection(l)
}

// QuerySellerConnection queries the "seller_connection" edge of the Location entity.
func (l *Location) QuerySellerConnection() *ConnectionQuery {
	return NewLocationClient(l.config).QuerySellerConnection(l)
}

// QueryReturnPortal queries the "return_portal" edge of the Location entity.
func (l *Location) QueryReturnPortal() *ReturnPortalQuery {
	return NewLocationClient(l.config).QueryReturnPortal(l)
}

// QueryDeliveryOption queries the "delivery_option" edge of the Location entity.
func (l *Location) QueryDeliveryOption() *DeliveryOptionQuery {
	return NewLocationClient(l.config).QueryDeliveryOption(l)
}

// QueryColli queries the "colli" edge of the Location entity.
func (l *Location) QueryColli() *ColliQuery {
	return NewLocationClient(l.config).QueryColli(l)
}

// Update returns a builder for updating this Location.
// Note that you need to call Location.Unwrap() before calling this method if this Location
// was returned from a transaction, and the transaction was committed or rolled back.
func (l *Location) Update() *LocationUpdateOne {
	return NewLocationClient(l.config).UpdateOne(l)
}

// Unwrap unwraps the Location entity that was returned from a transaction after it was closed,
// so that all future queries will be executed through the driver which created the transaction.
func (l *Location) Unwrap() *Location {
	_tx, ok := l.config.driver.(*txDriver)
	if !ok {
		panic("ent: Location is not a transactional entity")
	}
	l.config.driver = _tx.drv
	return l
}

// String implements the fmt.Stringer.
func (l *Location) String() string {
	var builder strings.Builder
	builder.WriteString("Location(")
	builder.WriteString(fmt.Sprintf("id=%v, ", l.ID))
	builder.WriteString("tenant_id=")
	builder.WriteString(fmt.Sprintf("%v", l.TenantID))
	builder.WriteString(", ")
	builder.WriteString("name=")
	builder.WriteString(l.Name)
	builder.WriteByte(')')
	return builder.String()
}

// NamedLocationTags returns the LocationTags named value or an error if the edge was not
// loaded in eager-loading with this name.
func (l *Location) NamedLocationTags(name string) ([]*LocationTag, error) {
	if l.Edges.namedLocationTags == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := l.Edges.namedLocationTags[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (l *Location) appendNamedLocationTags(name string, edges ...*LocationTag) {
	if l.Edges.namedLocationTags == nil {
		l.Edges.namedLocationTags = make(map[string][]*LocationTag)
	}
	if len(edges) == 0 {
		l.Edges.namedLocationTags[name] = []*LocationTag{}
	} else {
		l.Edges.namedLocationTags[name] = append(l.Edges.namedLocationTags[name], edges...)
	}
}

// NamedSenderConnection returns the SenderConnection named value or an error if the edge was not
// loaded in eager-loading with this name.
func (l *Location) NamedSenderConnection(name string) ([]*Connection, error) {
	if l.Edges.namedSenderConnection == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := l.Edges.namedSenderConnection[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (l *Location) appendNamedSenderConnection(name string, edges ...*Connection) {
	if l.Edges.namedSenderConnection == nil {
		l.Edges.namedSenderConnection = make(map[string][]*Connection)
	}
	if len(edges) == 0 {
		l.Edges.namedSenderConnection[name] = []*Connection{}
	} else {
		l.Edges.namedSenderConnection[name] = append(l.Edges.namedSenderConnection[name], edges...)
	}
}

// NamedPickupConnection returns the PickupConnection named value or an error if the edge was not
// loaded in eager-loading with this name.
func (l *Location) NamedPickupConnection(name string) ([]*Connection, error) {
	if l.Edges.namedPickupConnection == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := l.Edges.namedPickupConnection[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (l *Location) appendNamedPickupConnection(name string, edges ...*Connection) {
	if l.Edges.namedPickupConnection == nil {
		l.Edges.namedPickupConnection = make(map[string][]*Connection)
	}
	if len(edges) == 0 {
		l.Edges.namedPickupConnection[name] = []*Connection{}
	} else {
		l.Edges.namedPickupConnection[name] = append(l.Edges.namedPickupConnection[name], edges...)
	}
}

// NamedReturnConnection returns the ReturnConnection named value or an error if the edge was not
// loaded in eager-loading with this name.
func (l *Location) NamedReturnConnection(name string) ([]*Connection, error) {
	if l.Edges.namedReturnConnection == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := l.Edges.namedReturnConnection[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (l *Location) appendNamedReturnConnection(name string, edges ...*Connection) {
	if l.Edges.namedReturnConnection == nil {
		l.Edges.namedReturnConnection = make(map[string][]*Connection)
	}
	if len(edges) == 0 {
		l.Edges.namedReturnConnection[name] = []*Connection{}
	} else {
		l.Edges.namedReturnConnection[name] = append(l.Edges.namedReturnConnection[name], edges...)
	}
}

// NamedSellerConnection returns the SellerConnection named value or an error if the edge was not
// loaded in eager-loading with this name.
func (l *Location) NamedSellerConnection(name string) ([]*Connection, error) {
	if l.Edges.namedSellerConnection == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := l.Edges.namedSellerConnection[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (l *Location) appendNamedSellerConnection(name string, edges ...*Connection) {
	if l.Edges.namedSellerConnection == nil {
		l.Edges.namedSellerConnection = make(map[string][]*Connection)
	}
	if len(edges) == 0 {
		l.Edges.namedSellerConnection[name] = []*Connection{}
	} else {
		l.Edges.namedSellerConnection[name] = append(l.Edges.namedSellerConnection[name], edges...)
	}
}

// NamedReturnPortal returns the ReturnPortal named value or an error if the edge was not
// loaded in eager-loading with this name.
func (l *Location) NamedReturnPortal(name string) ([]*ReturnPortal, error) {
	if l.Edges.namedReturnPortal == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := l.Edges.namedReturnPortal[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (l *Location) appendNamedReturnPortal(name string, edges ...*ReturnPortal) {
	if l.Edges.namedReturnPortal == nil {
		l.Edges.namedReturnPortal = make(map[string][]*ReturnPortal)
	}
	if len(edges) == 0 {
		l.Edges.namedReturnPortal[name] = []*ReturnPortal{}
	} else {
		l.Edges.namedReturnPortal[name] = append(l.Edges.namedReturnPortal[name], edges...)
	}
}

// NamedDeliveryOption returns the DeliveryOption named value or an error if the edge was not
// loaded in eager-loading with this name.
func (l *Location) NamedDeliveryOption(name string) ([]*DeliveryOption, error) {
	if l.Edges.namedDeliveryOption == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := l.Edges.namedDeliveryOption[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (l *Location) appendNamedDeliveryOption(name string, edges ...*DeliveryOption) {
	if l.Edges.namedDeliveryOption == nil {
		l.Edges.namedDeliveryOption = make(map[string][]*DeliveryOption)
	}
	if len(edges) == 0 {
		l.Edges.namedDeliveryOption[name] = []*DeliveryOption{}
	} else {
		l.Edges.namedDeliveryOption[name] = append(l.Edges.namedDeliveryOption[name], edges...)
	}
}

// NamedColli returns the Colli named value or an error if the edge was not
// loaded in eager-loading with this name.
func (l *Location) NamedColli(name string) ([]*Colli, error) {
	if l.Edges.namedColli == nil {
		return nil, &NotLoadedError{edge: name}
	}
	nodes, ok := l.Edges.namedColli[name]
	if !ok {
		return nil, &NotLoadedError{edge: name}
	}
	return nodes, nil
}

func (l *Location) appendNamedColli(name string, edges ...*Colli) {
	if l.Edges.namedColli == nil {
		l.Edges.namedColli = make(map[string][]*Colli)
	}
	if len(edges) == 0 {
		l.Edges.namedColli[name] = []*Colli{}
	} else {
		l.Edges.namedColli[name] = append(l.Edges.namedColli[name], edges...)
	}
}

// Locations is a parsable slice of Location.
type Locations []*Location
