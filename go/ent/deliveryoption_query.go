// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"errors"
	"fmt"
	"math"

	"delivrio.io/go/ent/carrier"
	"delivrio.io/go/ent/carrierservice"
	"delivrio.io/go/ent/colli"
	"delivrio.io/go/ent/connection"
	"delivrio.io/go/ent/consolidation"
	"delivrio.io/go/ent/deliveryoption"
	"delivrio.io/go/ent/deliveryoptionbring"
	"delivrio.io/go/ent/deliveryoptiondao"
	"delivrio.io/go/ent/deliveryoptiondf"
	"delivrio.io/go/ent/deliveryoptiondsv"
	"delivrio.io/go/ent/deliveryoptioneasypost"
	"delivrio.io/go/ent/deliveryoptiongls"
	"delivrio.io/go/ent/deliveryoptionpostnord"
	"delivrio.io/go/ent/deliveryoptionusps"
	"delivrio.io/go/ent/deliveryrule"
	"delivrio.io/go/ent/emailtemplate"
	"delivrio.io/go/ent/hypothesistestdeliveryoption"
	"delivrio.io/go/ent/hypothesistestdeliveryoptionlookup"
	"delivrio.io/go/ent/location"
	"delivrio.io/go/ent/packaging"
	"delivrio.io/go/ent/predicate"
	"delivrio.io/go/ent/returncolli"
	"delivrio.io/go/ent/returnportal"
	"delivrio.io/go/ent/tenant"
	"delivrio.io/shared-utils/pulid"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
	"entgo.io/ent/schema/field"
)

// DeliveryOptionQuery is the builder for querying DeliveryOption entities.
type DeliveryOptionQuery struct {
	config
	ctx                                           *QueryContext
	order                                         []deliveryoption.OrderOption
	inters                                        []Interceptor
	predicates                                    []predicate.DeliveryOption
	withTenant                                    *TenantQuery
	withCarrier                                   *CarrierQuery
	withDeliveryRule                              *DeliveryRuleQuery
	withDeliveryOptionDAO                         *DeliveryOptionDAOQuery
	withDeliveryOptionDF                          *DeliveryOptionDFQuery
	withDeliveryOptionDSV                         *DeliveryOptionDSVQuery
	withDeliveryOptionEasyPost                    *DeliveryOptionEasyPostQuery
	withDeliveryOptionGLS                         *DeliveryOptionGLSQuery
	withDeliveryOptionPostNord                    *DeliveryOptionPostNordQuery
	withDeliveryOptionUSPS                        *DeliveryOptionUSPSQuery
	withDeliveryOptionBring                       *DeliveryOptionBringQuery
	withReturnPortals                             *ReturnPortalQuery
	withColli                                     *ColliQuery
	withReturnColli                               *ReturnColliQuery
	withCarrierService                            *CarrierServiceQuery
	withConnection                                *ConnectionQuery
	withConnectionDefault                         *ConnectionQuery
	withHypothesisTestDeliveryOptionGroupOne      *HypothesisTestDeliveryOptionQuery
	withHypothesisTestDeliveryOptionGroupTwo      *HypothesisTestDeliveryOptionQuery
	withHypothesisTestDeliveryOptionLookup        *HypothesisTestDeliveryOptionLookupQuery
	withClickCollectLocation                      *LocationQuery
	withEmailClickCollectAtStore                  *EmailTemplateQuery
	withConsolidation                             *ConsolidationQuery
	withDefaultPackaging                          *PackagingQuery
	withFKs                                       bool
	modifiers                                     []func(*sql.Selector)
	loadTotal                                     []func(context.Context, []*DeliveryOption) error
	withNamedDeliveryRule                         map[string]*DeliveryRuleQuery
	withNamedReturnPortals                        map[string]*ReturnPortalQuery
	withNamedColli                                map[string]*ColliQuery
	withNamedReturnColli                          map[string]*ReturnColliQuery
	withNamedHypothesisTestDeliveryOptionGroupOne map[string]*HypothesisTestDeliveryOptionQuery
	withNamedHypothesisTestDeliveryOptionGroupTwo map[string]*HypothesisTestDeliveryOptionQuery
	withNamedHypothesisTestDeliveryOptionLookup   map[string]*HypothesisTestDeliveryOptionLookupQuery
	withNamedClickCollectLocation                 map[string]*LocationQuery
	withNamedConsolidation                        map[string]*ConsolidationQuery
	// intermediate query (i.e. traversal path).
	sql  *sql.Selector
	path func(context.Context) (*sql.Selector, error)
}

// Where adds a new predicate for the DeliveryOptionQuery builder.
func (doq *DeliveryOptionQuery) Where(ps ...predicate.DeliveryOption) *DeliveryOptionQuery {
	doq.predicates = append(doq.predicates, ps...)
	return doq
}

// Limit the number of records to be returned by this query.
func (doq *DeliveryOptionQuery) Limit(limit int) *DeliveryOptionQuery {
	doq.ctx.Limit = &limit
	return doq
}

// Offset to start from.
func (doq *DeliveryOptionQuery) Offset(offset int) *DeliveryOptionQuery {
	doq.ctx.Offset = &offset
	return doq
}

// Unique configures the query builder to filter duplicate records on query.
// By default, unique is set to true, and can be disabled using this method.
func (doq *DeliveryOptionQuery) Unique(unique bool) *DeliveryOptionQuery {
	doq.ctx.Unique = &unique
	return doq
}

// Order specifies how the records should be ordered.
func (doq *DeliveryOptionQuery) Order(o ...deliveryoption.OrderOption) *DeliveryOptionQuery {
	doq.order = append(doq.order, o...)
	return doq
}

// QueryTenant chains the current query on the "tenant" edge.
func (doq *DeliveryOptionQuery) QueryTenant() *TenantQuery {
	query := (&TenantClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(tenant.Table, tenant.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, deliveryoption.TenantTable, deliveryoption.TenantColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCarrier chains the current query on the "carrier" edge.
func (doq *DeliveryOptionQuery) QueryCarrier() *CarrierQuery {
	query := (&CarrierClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(carrier.Table, carrier.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, deliveryoption.CarrierTable, deliveryoption.CarrierColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDeliveryRule chains the current query on the "delivery_rule" edge.
func (doq *DeliveryOptionQuery) QueryDeliveryRule() *DeliveryRuleQuery {
	query := (&DeliveryRuleClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(deliveryrule.Table, deliveryrule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, deliveryoption.DeliveryRuleTable, deliveryoption.DeliveryRuleColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDeliveryOptionDAO chains the current query on the "delivery_option_dao" edge.
func (doq *DeliveryOptionQuery) QueryDeliveryOptionDAO() *DeliveryOptionDAOQuery {
	query := (&DeliveryOptionDAOClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(deliveryoptiondao.Table, deliveryoptiondao.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, deliveryoption.DeliveryOptionDAOTable, deliveryoption.DeliveryOptionDAOColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDeliveryOptionDF chains the current query on the "delivery_option_df" edge.
func (doq *DeliveryOptionQuery) QueryDeliveryOptionDF() *DeliveryOptionDFQuery {
	query := (&DeliveryOptionDFClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(deliveryoptiondf.Table, deliveryoptiondf.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, deliveryoption.DeliveryOptionDFTable, deliveryoption.DeliveryOptionDFColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDeliveryOptionDSV chains the current query on the "delivery_option_dsv" edge.
func (doq *DeliveryOptionQuery) QueryDeliveryOptionDSV() *DeliveryOptionDSVQuery {
	query := (&DeliveryOptionDSVClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(deliveryoptiondsv.Table, deliveryoptiondsv.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, deliveryoption.DeliveryOptionDSVTable, deliveryoption.DeliveryOptionDSVColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDeliveryOptionEasyPost chains the current query on the "delivery_option_easy_post" edge.
func (doq *DeliveryOptionQuery) QueryDeliveryOptionEasyPost() *DeliveryOptionEasyPostQuery {
	query := (&DeliveryOptionEasyPostClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(deliveryoptioneasypost.Table, deliveryoptioneasypost.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, deliveryoption.DeliveryOptionEasyPostTable, deliveryoption.DeliveryOptionEasyPostColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDeliveryOptionGLS chains the current query on the "delivery_option_gls" edge.
func (doq *DeliveryOptionQuery) QueryDeliveryOptionGLS() *DeliveryOptionGLSQuery {
	query := (&DeliveryOptionGLSClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(deliveryoptiongls.Table, deliveryoptiongls.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, deliveryoption.DeliveryOptionGLSTable, deliveryoption.DeliveryOptionGLSColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDeliveryOptionPostNord chains the current query on the "delivery_option_post_nord" edge.
func (doq *DeliveryOptionQuery) QueryDeliveryOptionPostNord() *DeliveryOptionPostNordQuery {
	query := (&DeliveryOptionPostNordClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(deliveryoptionpostnord.Table, deliveryoptionpostnord.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, deliveryoption.DeliveryOptionPostNordTable, deliveryoption.DeliveryOptionPostNordColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDeliveryOptionUSPS chains the current query on the "delivery_option_usps" edge.
func (doq *DeliveryOptionQuery) QueryDeliveryOptionUSPS() *DeliveryOptionUSPSQuery {
	query := (&DeliveryOptionUSPSClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(deliveryoptionusps.Table, deliveryoptionusps.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, deliveryoption.DeliveryOptionUSPSTable, deliveryoption.DeliveryOptionUSPSColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDeliveryOptionBring chains the current query on the "delivery_option_bring" edge.
func (doq *DeliveryOptionQuery) QueryDeliveryOptionBring() *DeliveryOptionBringQuery {
	query := (&DeliveryOptionBringClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(deliveryoptionbring.Table, deliveryoptionbring.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, false, deliveryoption.DeliveryOptionBringTable, deliveryoption.DeliveryOptionBringColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryReturnPortals chains the current query on the "return_portals" edge.
func (doq *DeliveryOptionQuery) QueryReturnPortals() *ReturnPortalQuery {
	query := (&ReturnPortalClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(returnportal.Table, returnportal.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, deliveryoption.ReturnPortalsTable, deliveryoption.ReturnPortalsPrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryColli chains the current query on the "colli" edge.
func (doq *DeliveryOptionQuery) QueryColli() *ColliQuery {
	query := (&ColliClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(colli.Table, colli.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, deliveryoption.ColliTable, deliveryoption.ColliColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryReturnColli chains the current query on the "return_colli" edge.
func (doq *DeliveryOptionQuery) QueryReturnColli() *ReturnColliQuery {
	query := (&ReturnColliClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(returncolli.Table, returncolli.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, deliveryoption.ReturnColliTable, deliveryoption.ReturnColliColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryCarrierService chains the current query on the "carrier_service" edge.
func (doq *DeliveryOptionQuery) QueryCarrierService() *CarrierServiceQuery {
	query := (&CarrierServiceClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(carrierservice.Table, carrierservice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, deliveryoption.CarrierServiceTable, deliveryoption.CarrierServiceColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryConnection chains the current query on the "connection" edge.
func (doq *DeliveryOptionQuery) QueryConnection() *ConnectionQuery {
	query := (&ConnectionClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(connection.Table, connection.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, deliveryoption.ConnectionTable, deliveryoption.ConnectionColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryConnectionDefault chains the current query on the "connection_default" edge.
func (doq *DeliveryOptionQuery) QueryConnectionDefault() *ConnectionQuery {
	query := (&ConnectionClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(connection.Table, connection.FieldID),
			sqlgraph.Edge(sqlgraph.O2O, true, deliveryoption.ConnectionDefaultTable, deliveryoption.ConnectionDefaultColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryHypothesisTestDeliveryOptionGroupOne chains the current query on the "hypothesis_test_delivery_option_group_one" edge.
func (doq *DeliveryOptionQuery) QueryHypothesisTestDeliveryOptionGroupOne() *HypothesisTestDeliveryOptionQuery {
	query := (&HypothesisTestDeliveryOptionClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(hypothesistestdeliveryoption.Table, hypothesistestdeliveryoption.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, deliveryoption.HypothesisTestDeliveryOptionGroupOneTable, deliveryoption.HypothesisTestDeliveryOptionGroupOnePrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryHypothesisTestDeliveryOptionGroupTwo chains the current query on the "hypothesis_test_delivery_option_group_two" edge.
func (doq *DeliveryOptionQuery) QueryHypothesisTestDeliveryOptionGroupTwo() *HypothesisTestDeliveryOptionQuery {
	query := (&HypothesisTestDeliveryOptionClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(hypothesistestdeliveryoption.Table, hypothesistestdeliveryoption.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, deliveryoption.HypothesisTestDeliveryOptionGroupTwoTable, deliveryoption.HypothesisTestDeliveryOptionGroupTwoPrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryHypothesisTestDeliveryOptionLookup chains the current query on the "hypothesis_test_delivery_option_lookup" edge.
func (doq *DeliveryOptionQuery) QueryHypothesisTestDeliveryOptionLookup() *HypothesisTestDeliveryOptionLookupQuery {
	query := (&HypothesisTestDeliveryOptionLookupClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(hypothesistestdeliveryoptionlookup.Table, hypothesistestdeliveryoptionlookup.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, deliveryoption.HypothesisTestDeliveryOptionLookupTable, deliveryoption.HypothesisTestDeliveryOptionLookupColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryClickCollectLocation chains the current query on the "click_collect_location" edge.
func (doq *DeliveryOptionQuery) QueryClickCollectLocation() *LocationQuery {
	query := (&LocationClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(location.Table, location.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, deliveryoption.ClickCollectLocationTable, deliveryoption.ClickCollectLocationPrimaryKey...),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryEmailClickCollectAtStore chains the current query on the "email_click_collect_at_store" edge.
func (doq *DeliveryOptionQuery) QueryEmailClickCollectAtStore() *EmailTemplateQuery {
	query := (&EmailTemplateClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(emailtemplate.Table, emailtemplate.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, deliveryoption.EmailClickCollectAtStoreTable, deliveryoption.EmailClickCollectAtStoreColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryConsolidation chains the current query on the "consolidation" edge.
func (doq *DeliveryOptionQuery) QueryConsolidation() *ConsolidationQuery {
	query := (&ConsolidationClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(consolidation.Table, consolidation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, deliveryoption.ConsolidationTable, deliveryoption.ConsolidationColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// QueryDefaultPackaging chains the current query on the "default_packaging" edge.
func (doq *DeliveryOptionQuery) QueryDefaultPackaging() *PackagingQuery {
	query := (&PackagingClient{config: doq.config}).Query()
	query.path = func(ctx context.Context) (fromU *sql.Selector, err error) {
		if err := doq.prepareQuery(ctx); err != nil {
			return nil, err
		}
		selector := doq.sqlQuery(ctx)
		if err := selector.Err(); err != nil {
			return nil, err
		}
		step := sqlgraph.NewStep(
			sqlgraph.From(deliveryoption.Table, deliveryoption.FieldID, selector),
			sqlgraph.To(packaging.Table, packaging.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, deliveryoption.DefaultPackagingTable, deliveryoption.DefaultPackagingColumn),
		)
		fromU = sqlgraph.SetNeighbors(doq.driver.Dialect(), step)
		return fromU, nil
	}
	return query
}

// First returns the first DeliveryOption entity from the query.
// Returns a *NotFoundError when no DeliveryOption was found.
func (doq *DeliveryOptionQuery) First(ctx context.Context) (*DeliveryOption, error) {
	nodes, err := doq.Limit(1).All(setContextOp(ctx, doq.ctx, ent.OpQueryFirst))
	if err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nil, &NotFoundError{deliveryoption.Label}
	}
	return nodes[0], nil
}

// FirstX is like First, but panics if an error occurs.
func (doq *DeliveryOptionQuery) FirstX(ctx context.Context) *DeliveryOption {
	node, err := doq.First(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return node
}

// FirstID returns the first DeliveryOption ID from the query.
// Returns a *NotFoundError when no DeliveryOption ID was found.
func (doq *DeliveryOptionQuery) FirstID(ctx context.Context) (id pulid.ID, err error) {
	var ids []pulid.ID
	if ids, err = doq.Limit(1).IDs(setContextOp(ctx, doq.ctx, ent.OpQueryFirstID)); err != nil {
		return
	}
	if len(ids) == 0 {
		err = &NotFoundError{deliveryoption.Label}
		return
	}
	return ids[0], nil
}

// FirstIDX is like FirstID, but panics if an error occurs.
func (doq *DeliveryOptionQuery) FirstIDX(ctx context.Context) pulid.ID {
	id, err := doq.FirstID(ctx)
	if err != nil && !IsNotFound(err) {
		panic(err)
	}
	return id
}

// Only returns a single DeliveryOption entity found by the query, ensuring it only returns one.
// Returns a *NotSingularError when more than one DeliveryOption entity is found.
// Returns a *NotFoundError when no DeliveryOption entities are found.
func (doq *DeliveryOptionQuery) Only(ctx context.Context) (*DeliveryOption, error) {
	nodes, err := doq.Limit(2).All(setContextOp(ctx, doq.ctx, ent.OpQueryOnly))
	if err != nil {
		return nil, err
	}
	switch len(nodes) {
	case 1:
		return nodes[0], nil
	case 0:
		return nil, &NotFoundError{deliveryoption.Label}
	default:
		return nil, &NotSingularError{deliveryoption.Label}
	}
}

// OnlyX is like Only, but panics if an error occurs.
func (doq *DeliveryOptionQuery) OnlyX(ctx context.Context) *DeliveryOption {
	node, err := doq.Only(ctx)
	if err != nil {
		panic(err)
	}
	return node
}

// OnlyID is like Only, but returns the only DeliveryOption ID in the query.
// Returns a *NotSingularError when more than one DeliveryOption ID is found.
// Returns a *NotFoundError when no entities are found.
func (doq *DeliveryOptionQuery) OnlyID(ctx context.Context) (id pulid.ID, err error) {
	var ids []pulid.ID
	if ids, err = doq.Limit(2).IDs(setContextOp(ctx, doq.ctx, ent.OpQueryOnlyID)); err != nil {
		return
	}
	switch len(ids) {
	case 1:
		id = ids[0]
	case 0:
		err = &NotFoundError{deliveryoption.Label}
	default:
		err = &NotSingularError{deliveryoption.Label}
	}
	return
}

// OnlyIDX is like OnlyID, but panics if an error occurs.
func (doq *DeliveryOptionQuery) OnlyIDX(ctx context.Context) pulid.ID {
	id, err := doq.OnlyID(ctx)
	if err != nil {
		panic(err)
	}
	return id
}

// All executes the query and returns a list of DeliveryOptions.
func (doq *DeliveryOptionQuery) All(ctx context.Context) ([]*DeliveryOption, error) {
	ctx = setContextOp(ctx, doq.ctx, ent.OpQueryAll)
	if err := doq.prepareQuery(ctx); err != nil {
		return nil, err
	}
	qr := querierAll[[]*DeliveryOption, *DeliveryOptionQuery]()
	return withInterceptors[[]*DeliveryOption](ctx, doq, qr, doq.inters)
}

// AllX is like All, but panics if an error occurs.
func (doq *DeliveryOptionQuery) AllX(ctx context.Context) []*DeliveryOption {
	nodes, err := doq.All(ctx)
	if err != nil {
		panic(err)
	}
	return nodes
}

// IDs executes the query and returns a list of DeliveryOption IDs.
func (doq *DeliveryOptionQuery) IDs(ctx context.Context) (ids []pulid.ID, err error) {
	if doq.ctx.Unique == nil && doq.path != nil {
		doq.Unique(true)
	}
	ctx = setContextOp(ctx, doq.ctx, ent.OpQueryIDs)
	if err = doq.Select(deliveryoption.FieldID).Scan(ctx, &ids); err != nil {
		return nil, err
	}
	return ids, nil
}

// IDsX is like IDs, but panics if an error occurs.
func (doq *DeliveryOptionQuery) IDsX(ctx context.Context) []pulid.ID {
	ids, err := doq.IDs(ctx)
	if err != nil {
		panic(err)
	}
	return ids
}

// Count returns the count of the given query.
func (doq *DeliveryOptionQuery) Count(ctx context.Context) (int, error) {
	ctx = setContextOp(ctx, doq.ctx, ent.OpQueryCount)
	if err := doq.prepareQuery(ctx); err != nil {
		return 0, err
	}
	return withInterceptors[int](ctx, doq, querierCount[*DeliveryOptionQuery](), doq.inters)
}

// CountX is like Count, but panics if an error occurs.
func (doq *DeliveryOptionQuery) CountX(ctx context.Context) int {
	count, err := doq.Count(ctx)
	if err != nil {
		panic(err)
	}
	return count
}

// Exist returns true if the query has elements in the graph.
func (doq *DeliveryOptionQuery) Exist(ctx context.Context) (bool, error) {
	ctx = setContextOp(ctx, doq.ctx, ent.OpQueryExist)
	switch _, err := doq.FirstID(ctx); {
	case IsNotFound(err):
		return false, nil
	case err != nil:
		return false, fmt.Errorf("ent: check existence: %w", err)
	default:
		return true, nil
	}
}

// ExistX is like Exist, but panics if an error occurs.
func (doq *DeliveryOptionQuery) ExistX(ctx context.Context) bool {
	exist, err := doq.Exist(ctx)
	if err != nil {
		panic(err)
	}
	return exist
}

// Clone returns a duplicate of the DeliveryOptionQuery builder, including all associated steps. It can be
// used to prepare common query builders and use them differently after the clone is made.
func (doq *DeliveryOptionQuery) Clone() *DeliveryOptionQuery {
	if doq == nil {
		return nil
	}
	return &DeliveryOptionQuery{
		config:                                   doq.config,
		ctx:                                      doq.ctx.Clone(),
		order:                                    append([]deliveryoption.OrderOption{}, doq.order...),
		inters:                                   append([]Interceptor{}, doq.inters...),
		predicates:                               append([]predicate.DeliveryOption{}, doq.predicates...),
		withTenant:                               doq.withTenant.Clone(),
		withCarrier:                              doq.withCarrier.Clone(),
		withDeliveryRule:                         doq.withDeliveryRule.Clone(),
		withDeliveryOptionDAO:                    doq.withDeliveryOptionDAO.Clone(),
		withDeliveryOptionDF:                     doq.withDeliveryOptionDF.Clone(),
		withDeliveryOptionDSV:                    doq.withDeliveryOptionDSV.Clone(),
		withDeliveryOptionEasyPost:               doq.withDeliveryOptionEasyPost.Clone(),
		withDeliveryOptionGLS:                    doq.withDeliveryOptionGLS.Clone(),
		withDeliveryOptionPostNord:               doq.withDeliveryOptionPostNord.Clone(),
		withDeliveryOptionUSPS:                   doq.withDeliveryOptionUSPS.Clone(),
		withDeliveryOptionBring:                  doq.withDeliveryOptionBring.Clone(),
		withReturnPortals:                        doq.withReturnPortals.Clone(),
		withColli:                                doq.withColli.Clone(),
		withReturnColli:                          doq.withReturnColli.Clone(),
		withCarrierService:                       doq.withCarrierService.Clone(),
		withConnection:                           doq.withConnection.Clone(),
		withConnectionDefault:                    doq.withConnectionDefault.Clone(),
		withHypothesisTestDeliveryOptionGroupOne: doq.withHypothesisTestDeliveryOptionGroupOne.Clone(),
		withHypothesisTestDeliveryOptionGroupTwo: doq.withHypothesisTestDeliveryOptionGroupTwo.Clone(),
		withHypothesisTestDeliveryOptionLookup:   doq.withHypothesisTestDeliveryOptionLookup.Clone(),
		withClickCollectLocation:                 doq.withClickCollectLocation.Clone(),
		withEmailClickCollectAtStore:             doq.withEmailClickCollectAtStore.Clone(),
		withConsolidation:                        doq.withConsolidation.Clone(),
		withDefaultPackaging:                     doq.withDefaultPackaging.Clone(),
		// clone intermediate query.
		sql:  doq.sql.Clone(),
		path: doq.path,
	}
}

// WithTenant tells the query-builder to eager-load the nodes that are connected to
// the "tenant" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithTenant(opts ...func(*TenantQuery)) *DeliveryOptionQuery {
	query := (&TenantClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withTenant = query
	return doq
}

// WithCarrier tells the query-builder to eager-load the nodes that are connected to
// the "carrier" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithCarrier(opts ...func(*CarrierQuery)) *DeliveryOptionQuery {
	query := (&CarrierClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withCarrier = query
	return doq
}

// WithDeliveryRule tells the query-builder to eager-load the nodes that are connected to
// the "delivery_rule" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithDeliveryRule(opts ...func(*DeliveryRuleQuery)) *DeliveryOptionQuery {
	query := (&DeliveryRuleClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withDeliveryRule = query
	return doq
}

// WithDeliveryOptionDAO tells the query-builder to eager-load the nodes that are connected to
// the "delivery_option_dao" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithDeliveryOptionDAO(opts ...func(*DeliveryOptionDAOQuery)) *DeliveryOptionQuery {
	query := (&DeliveryOptionDAOClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withDeliveryOptionDAO = query
	return doq
}

// WithDeliveryOptionDF tells the query-builder to eager-load the nodes that are connected to
// the "delivery_option_df" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithDeliveryOptionDF(opts ...func(*DeliveryOptionDFQuery)) *DeliveryOptionQuery {
	query := (&DeliveryOptionDFClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withDeliveryOptionDF = query
	return doq
}

// WithDeliveryOptionDSV tells the query-builder to eager-load the nodes that are connected to
// the "delivery_option_dsv" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithDeliveryOptionDSV(opts ...func(*DeliveryOptionDSVQuery)) *DeliveryOptionQuery {
	query := (&DeliveryOptionDSVClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withDeliveryOptionDSV = query
	return doq
}

// WithDeliveryOptionEasyPost tells the query-builder to eager-load the nodes that are connected to
// the "delivery_option_easy_post" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithDeliveryOptionEasyPost(opts ...func(*DeliveryOptionEasyPostQuery)) *DeliveryOptionQuery {
	query := (&DeliveryOptionEasyPostClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withDeliveryOptionEasyPost = query
	return doq
}

// WithDeliveryOptionGLS tells the query-builder to eager-load the nodes that are connected to
// the "delivery_option_gls" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithDeliveryOptionGLS(opts ...func(*DeliveryOptionGLSQuery)) *DeliveryOptionQuery {
	query := (&DeliveryOptionGLSClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withDeliveryOptionGLS = query
	return doq
}

// WithDeliveryOptionPostNord tells the query-builder to eager-load the nodes that are connected to
// the "delivery_option_post_nord" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithDeliveryOptionPostNord(opts ...func(*DeliveryOptionPostNordQuery)) *DeliveryOptionQuery {
	query := (&DeliveryOptionPostNordClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withDeliveryOptionPostNord = query
	return doq
}

// WithDeliveryOptionUSPS tells the query-builder to eager-load the nodes that are connected to
// the "delivery_option_usps" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithDeliveryOptionUSPS(opts ...func(*DeliveryOptionUSPSQuery)) *DeliveryOptionQuery {
	query := (&DeliveryOptionUSPSClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withDeliveryOptionUSPS = query
	return doq
}

// WithDeliveryOptionBring tells the query-builder to eager-load the nodes that are connected to
// the "delivery_option_bring" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithDeliveryOptionBring(opts ...func(*DeliveryOptionBringQuery)) *DeliveryOptionQuery {
	query := (&DeliveryOptionBringClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withDeliveryOptionBring = query
	return doq
}

// WithReturnPortals tells the query-builder to eager-load the nodes that are connected to
// the "return_portals" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithReturnPortals(opts ...func(*ReturnPortalQuery)) *DeliveryOptionQuery {
	query := (&ReturnPortalClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withReturnPortals = query
	return doq
}

// WithColli tells the query-builder to eager-load the nodes that are connected to
// the "colli" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithColli(opts ...func(*ColliQuery)) *DeliveryOptionQuery {
	query := (&ColliClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withColli = query
	return doq
}

// WithReturnColli tells the query-builder to eager-load the nodes that are connected to
// the "return_colli" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithReturnColli(opts ...func(*ReturnColliQuery)) *DeliveryOptionQuery {
	query := (&ReturnColliClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withReturnColli = query
	return doq
}

// WithCarrierService tells the query-builder to eager-load the nodes that are connected to
// the "carrier_service" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithCarrierService(opts ...func(*CarrierServiceQuery)) *DeliveryOptionQuery {
	query := (&CarrierServiceClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withCarrierService = query
	return doq
}

// WithConnection tells the query-builder to eager-load the nodes that are connected to
// the "connection" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithConnection(opts ...func(*ConnectionQuery)) *DeliveryOptionQuery {
	query := (&ConnectionClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withConnection = query
	return doq
}

// WithConnectionDefault tells the query-builder to eager-load the nodes that are connected to
// the "connection_default" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithConnectionDefault(opts ...func(*ConnectionQuery)) *DeliveryOptionQuery {
	query := (&ConnectionClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withConnectionDefault = query
	return doq
}

// WithHypothesisTestDeliveryOptionGroupOne tells the query-builder to eager-load the nodes that are connected to
// the "hypothesis_test_delivery_option_group_one" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithHypothesisTestDeliveryOptionGroupOne(opts ...func(*HypothesisTestDeliveryOptionQuery)) *DeliveryOptionQuery {
	query := (&HypothesisTestDeliveryOptionClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withHypothesisTestDeliveryOptionGroupOne = query
	return doq
}

// WithHypothesisTestDeliveryOptionGroupTwo tells the query-builder to eager-load the nodes that are connected to
// the "hypothesis_test_delivery_option_group_two" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithHypothesisTestDeliveryOptionGroupTwo(opts ...func(*HypothesisTestDeliveryOptionQuery)) *DeliveryOptionQuery {
	query := (&HypothesisTestDeliveryOptionClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withHypothesisTestDeliveryOptionGroupTwo = query
	return doq
}

// WithHypothesisTestDeliveryOptionLookup tells the query-builder to eager-load the nodes that are connected to
// the "hypothesis_test_delivery_option_lookup" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithHypothesisTestDeliveryOptionLookup(opts ...func(*HypothesisTestDeliveryOptionLookupQuery)) *DeliveryOptionQuery {
	query := (&HypothesisTestDeliveryOptionLookupClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withHypothesisTestDeliveryOptionLookup = query
	return doq
}

// WithClickCollectLocation tells the query-builder to eager-load the nodes that are connected to
// the "click_collect_location" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithClickCollectLocation(opts ...func(*LocationQuery)) *DeliveryOptionQuery {
	query := (&LocationClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withClickCollectLocation = query
	return doq
}

// WithEmailClickCollectAtStore tells the query-builder to eager-load the nodes that are connected to
// the "email_click_collect_at_store" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithEmailClickCollectAtStore(opts ...func(*EmailTemplateQuery)) *DeliveryOptionQuery {
	query := (&EmailTemplateClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withEmailClickCollectAtStore = query
	return doq
}

// WithConsolidation tells the query-builder to eager-load the nodes that are connected to
// the "consolidation" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithConsolidation(opts ...func(*ConsolidationQuery)) *DeliveryOptionQuery {
	query := (&ConsolidationClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withConsolidation = query
	return doq
}

// WithDefaultPackaging tells the query-builder to eager-load the nodes that are connected to
// the "default_packaging" edge. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithDefaultPackaging(opts ...func(*PackagingQuery)) *DeliveryOptionQuery {
	query := (&PackagingClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	doq.withDefaultPackaging = query
	return doq
}

// GroupBy is used to group vertices by one or more fields/columns.
// It is often used with aggregate functions, like: count, max, mean, min, sum.
//
// Example:
//
//	var v []struct {
//		TenantID pulid.ID `json:"tenant_id,omitempty"`
//		Count int `json:"count,omitempty"`
//	}
//
//	client.DeliveryOption.Query().
//		GroupBy(deliveryoption.FieldTenantID).
//		Aggregate(ent.Count()).
//		Scan(ctx, &v)
func (doq *DeliveryOptionQuery) GroupBy(field string, fields ...string) *DeliveryOptionGroupBy {
	doq.ctx.Fields = append([]string{field}, fields...)
	grbuild := &DeliveryOptionGroupBy{build: doq}
	grbuild.flds = &doq.ctx.Fields
	grbuild.label = deliveryoption.Label
	grbuild.scan = grbuild.Scan
	return grbuild
}

// Select allows the selection one or more fields/columns for the given query,
// instead of selecting all fields in the entity.
//
// Example:
//
//	var v []struct {
//		TenantID pulid.ID `json:"tenant_id,omitempty"`
//	}
//
//	client.DeliveryOption.Query().
//		Select(deliveryoption.FieldTenantID).
//		Scan(ctx, &v)
func (doq *DeliveryOptionQuery) Select(fields ...string) *DeliveryOptionSelect {
	doq.ctx.Fields = append(doq.ctx.Fields, fields...)
	sbuild := &DeliveryOptionSelect{DeliveryOptionQuery: doq}
	sbuild.label = deliveryoption.Label
	sbuild.flds, sbuild.scan = &doq.ctx.Fields, sbuild.Scan
	return sbuild
}

// Aggregate returns a DeliveryOptionSelect configured with the given aggregations.
func (doq *DeliveryOptionQuery) Aggregate(fns ...AggregateFunc) *DeliveryOptionSelect {
	return doq.Select().Aggregate(fns...)
}

func (doq *DeliveryOptionQuery) prepareQuery(ctx context.Context) error {
	for _, inter := range doq.inters {
		if inter == nil {
			return fmt.Errorf("ent: uninitialized interceptor (forgotten import ent/runtime?)")
		}
		if trv, ok := inter.(Traverser); ok {
			if err := trv.Traverse(ctx, doq); err != nil {
				return err
			}
		}
	}
	for _, f := range doq.ctx.Fields {
		if !deliveryoption.ValidColumn(f) {
			return &ValidationError{Name: f, err: fmt.Errorf("ent: invalid field %q for query", f)}
		}
	}
	if doq.path != nil {
		prev, err := doq.path(ctx)
		if err != nil {
			return err
		}
		doq.sql = prev
	}
	if deliveryoption.Policy == nil {
		return errors.New("ent: uninitialized deliveryoption.Policy (forgotten import ent/runtime?)")
	}
	if err := deliveryoption.Policy.EvalQuery(ctx, doq); err != nil {
		return err
	}
	return nil
}

func (doq *DeliveryOptionQuery) sqlAll(ctx context.Context, hooks ...queryHook) ([]*DeliveryOption, error) {
	var (
		nodes       = []*DeliveryOption{}
		withFKs     = doq.withFKs
		_spec       = doq.querySpec()
		loadedTypes = [24]bool{
			doq.withTenant != nil,
			doq.withCarrier != nil,
			doq.withDeliveryRule != nil,
			doq.withDeliveryOptionDAO != nil,
			doq.withDeliveryOptionDF != nil,
			doq.withDeliveryOptionDSV != nil,
			doq.withDeliveryOptionEasyPost != nil,
			doq.withDeliveryOptionGLS != nil,
			doq.withDeliveryOptionPostNord != nil,
			doq.withDeliveryOptionUSPS != nil,
			doq.withDeliveryOptionBring != nil,
			doq.withReturnPortals != nil,
			doq.withColli != nil,
			doq.withReturnColli != nil,
			doq.withCarrierService != nil,
			doq.withConnection != nil,
			doq.withConnectionDefault != nil,
			doq.withHypothesisTestDeliveryOptionGroupOne != nil,
			doq.withHypothesisTestDeliveryOptionGroupTwo != nil,
			doq.withHypothesisTestDeliveryOptionLookup != nil,
			doq.withClickCollectLocation != nil,
			doq.withEmailClickCollectAtStore != nil,
			doq.withConsolidation != nil,
			doq.withDefaultPackaging != nil,
		}
	)
	if doq.withCarrier != nil || doq.withCarrierService != nil || doq.withConnection != nil || doq.withConnectionDefault != nil || doq.withEmailClickCollectAtStore != nil || doq.withDefaultPackaging != nil {
		withFKs = true
	}
	if withFKs {
		_spec.Node.Columns = append(_spec.Node.Columns, deliveryoption.ForeignKeys...)
	}
	_spec.ScanValues = func(columns []string) ([]any, error) {
		return (*DeliveryOption).scanValues(nil, columns)
	}
	_spec.Assign = func(columns []string, values []any) error {
		node := &DeliveryOption{config: doq.config}
		nodes = append(nodes, node)
		node.Edges.loadedTypes = loadedTypes
		return node.assignValues(columns, values)
	}
	if len(doq.modifiers) > 0 {
		_spec.Modifiers = doq.modifiers
	}
	for i := range hooks {
		hooks[i](ctx, _spec)
	}
	if err := sqlgraph.QueryNodes(ctx, doq.driver, _spec); err != nil {
		return nil, err
	}
	if len(nodes) == 0 {
		return nodes, nil
	}
	if query := doq.withTenant; query != nil {
		if err := doq.loadTenant(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *Tenant) { n.Edges.Tenant = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withCarrier; query != nil {
		if err := doq.loadCarrier(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *Carrier) { n.Edges.Carrier = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withDeliveryRule; query != nil {
		if err := doq.loadDeliveryRule(ctx, query, nodes,
			func(n *DeliveryOption) { n.Edges.DeliveryRule = []*DeliveryRule{} },
			func(n *DeliveryOption, e *DeliveryRule) { n.Edges.DeliveryRule = append(n.Edges.DeliveryRule, e) }); err != nil {
			return nil, err
		}
	}
	if query := doq.withDeliveryOptionDAO; query != nil {
		if err := doq.loadDeliveryOptionDAO(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *DeliveryOptionDAO) { n.Edges.DeliveryOptionDAO = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withDeliveryOptionDF; query != nil {
		if err := doq.loadDeliveryOptionDF(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *DeliveryOptionDF) { n.Edges.DeliveryOptionDF = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withDeliveryOptionDSV; query != nil {
		if err := doq.loadDeliveryOptionDSV(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *DeliveryOptionDSV) { n.Edges.DeliveryOptionDSV = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withDeliveryOptionEasyPost; query != nil {
		if err := doq.loadDeliveryOptionEasyPost(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *DeliveryOptionEasyPost) { n.Edges.DeliveryOptionEasyPost = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withDeliveryOptionGLS; query != nil {
		if err := doq.loadDeliveryOptionGLS(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *DeliveryOptionGLS) { n.Edges.DeliveryOptionGLS = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withDeliveryOptionPostNord; query != nil {
		if err := doq.loadDeliveryOptionPostNord(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *DeliveryOptionPostNord) { n.Edges.DeliveryOptionPostNord = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withDeliveryOptionUSPS; query != nil {
		if err := doq.loadDeliveryOptionUSPS(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *DeliveryOptionUSPS) { n.Edges.DeliveryOptionUSPS = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withDeliveryOptionBring; query != nil {
		if err := doq.loadDeliveryOptionBring(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *DeliveryOptionBring) { n.Edges.DeliveryOptionBring = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withReturnPortals; query != nil {
		if err := doq.loadReturnPortals(ctx, query, nodes,
			func(n *DeliveryOption) { n.Edges.ReturnPortals = []*ReturnPortal{} },
			func(n *DeliveryOption, e *ReturnPortal) { n.Edges.ReturnPortals = append(n.Edges.ReturnPortals, e) }); err != nil {
			return nil, err
		}
	}
	if query := doq.withColli; query != nil {
		if err := doq.loadColli(ctx, query, nodes,
			func(n *DeliveryOption) { n.Edges.Colli = []*Colli{} },
			func(n *DeliveryOption, e *Colli) { n.Edges.Colli = append(n.Edges.Colli, e) }); err != nil {
			return nil, err
		}
	}
	if query := doq.withReturnColli; query != nil {
		if err := doq.loadReturnColli(ctx, query, nodes,
			func(n *DeliveryOption) { n.Edges.ReturnColli = []*ReturnColli{} },
			func(n *DeliveryOption, e *ReturnColli) { n.Edges.ReturnColli = append(n.Edges.ReturnColli, e) }); err != nil {
			return nil, err
		}
	}
	if query := doq.withCarrierService; query != nil {
		if err := doq.loadCarrierService(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *CarrierService) { n.Edges.CarrierService = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withConnection; query != nil {
		if err := doq.loadConnection(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *Connection) { n.Edges.Connection = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withConnectionDefault; query != nil {
		if err := doq.loadConnectionDefault(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *Connection) { n.Edges.ConnectionDefault = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withHypothesisTestDeliveryOptionGroupOne; query != nil {
		if err := doq.loadHypothesisTestDeliveryOptionGroupOne(ctx, query, nodes,
			func(n *DeliveryOption) {
				n.Edges.HypothesisTestDeliveryOptionGroupOne = []*HypothesisTestDeliveryOption{}
			},
			func(n *DeliveryOption, e *HypothesisTestDeliveryOption) {
				n.Edges.HypothesisTestDeliveryOptionGroupOne = append(n.Edges.HypothesisTestDeliveryOptionGroupOne, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := doq.withHypothesisTestDeliveryOptionGroupTwo; query != nil {
		if err := doq.loadHypothesisTestDeliveryOptionGroupTwo(ctx, query, nodes,
			func(n *DeliveryOption) {
				n.Edges.HypothesisTestDeliveryOptionGroupTwo = []*HypothesisTestDeliveryOption{}
			},
			func(n *DeliveryOption, e *HypothesisTestDeliveryOption) {
				n.Edges.HypothesisTestDeliveryOptionGroupTwo = append(n.Edges.HypothesisTestDeliveryOptionGroupTwo, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := doq.withHypothesisTestDeliveryOptionLookup; query != nil {
		if err := doq.loadHypothesisTestDeliveryOptionLookup(ctx, query, nodes,
			func(n *DeliveryOption) {
				n.Edges.HypothesisTestDeliveryOptionLookup = []*HypothesisTestDeliveryOptionLookup{}
			},
			func(n *DeliveryOption, e *HypothesisTestDeliveryOptionLookup) {
				n.Edges.HypothesisTestDeliveryOptionLookup = append(n.Edges.HypothesisTestDeliveryOptionLookup, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := doq.withClickCollectLocation; query != nil {
		if err := doq.loadClickCollectLocation(ctx, query, nodes,
			func(n *DeliveryOption) { n.Edges.ClickCollectLocation = []*Location{} },
			func(n *DeliveryOption, e *Location) {
				n.Edges.ClickCollectLocation = append(n.Edges.ClickCollectLocation, e)
			}); err != nil {
			return nil, err
		}
	}
	if query := doq.withEmailClickCollectAtStore; query != nil {
		if err := doq.loadEmailClickCollectAtStore(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *EmailTemplate) { n.Edges.EmailClickCollectAtStore = e }); err != nil {
			return nil, err
		}
	}
	if query := doq.withConsolidation; query != nil {
		if err := doq.loadConsolidation(ctx, query, nodes,
			func(n *DeliveryOption) { n.Edges.Consolidation = []*Consolidation{} },
			func(n *DeliveryOption, e *Consolidation) { n.Edges.Consolidation = append(n.Edges.Consolidation, e) }); err != nil {
			return nil, err
		}
	}
	if query := doq.withDefaultPackaging; query != nil {
		if err := doq.loadDefaultPackaging(ctx, query, nodes, nil,
			func(n *DeliveryOption, e *Packaging) { n.Edges.DefaultPackaging = e }); err != nil {
			return nil, err
		}
	}
	for name, query := range doq.withNamedDeliveryRule {
		if err := doq.loadDeliveryRule(ctx, query, nodes,
			func(n *DeliveryOption) { n.appendNamedDeliveryRule(name) },
			func(n *DeliveryOption, e *DeliveryRule) { n.appendNamedDeliveryRule(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range doq.withNamedReturnPortals {
		if err := doq.loadReturnPortals(ctx, query, nodes,
			func(n *DeliveryOption) { n.appendNamedReturnPortals(name) },
			func(n *DeliveryOption, e *ReturnPortal) { n.appendNamedReturnPortals(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range doq.withNamedColli {
		if err := doq.loadColli(ctx, query, nodes,
			func(n *DeliveryOption) { n.appendNamedColli(name) },
			func(n *DeliveryOption, e *Colli) { n.appendNamedColli(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range doq.withNamedReturnColli {
		if err := doq.loadReturnColli(ctx, query, nodes,
			func(n *DeliveryOption) { n.appendNamedReturnColli(name) },
			func(n *DeliveryOption, e *ReturnColli) { n.appendNamedReturnColli(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range doq.withNamedHypothesisTestDeliveryOptionGroupOne {
		if err := doq.loadHypothesisTestDeliveryOptionGroupOne(ctx, query, nodes,
			func(n *DeliveryOption) { n.appendNamedHypothesisTestDeliveryOptionGroupOne(name) },
			func(n *DeliveryOption, e *HypothesisTestDeliveryOption) {
				n.appendNamedHypothesisTestDeliveryOptionGroupOne(name, e)
			}); err != nil {
			return nil, err
		}
	}
	for name, query := range doq.withNamedHypothesisTestDeliveryOptionGroupTwo {
		if err := doq.loadHypothesisTestDeliveryOptionGroupTwo(ctx, query, nodes,
			func(n *DeliveryOption) { n.appendNamedHypothesisTestDeliveryOptionGroupTwo(name) },
			func(n *DeliveryOption, e *HypothesisTestDeliveryOption) {
				n.appendNamedHypothesisTestDeliveryOptionGroupTwo(name, e)
			}); err != nil {
			return nil, err
		}
	}
	for name, query := range doq.withNamedHypothesisTestDeliveryOptionLookup {
		if err := doq.loadHypothesisTestDeliveryOptionLookup(ctx, query, nodes,
			func(n *DeliveryOption) { n.appendNamedHypothesisTestDeliveryOptionLookup(name) },
			func(n *DeliveryOption, e *HypothesisTestDeliveryOptionLookup) {
				n.appendNamedHypothesisTestDeliveryOptionLookup(name, e)
			}); err != nil {
			return nil, err
		}
	}
	for name, query := range doq.withNamedClickCollectLocation {
		if err := doq.loadClickCollectLocation(ctx, query, nodes,
			func(n *DeliveryOption) { n.appendNamedClickCollectLocation(name) },
			func(n *DeliveryOption, e *Location) { n.appendNamedClickCollectLocation(name, e) }); err != nil {
			return nil, err
		}
	}
	for name, query := range doq.withNamedConsolidation {
		if err := doq.loadConsolidation(ctx, query, nodes,
			func(n *DeliveryOption) { n.appendNamedConsolidation(name) },
			func(n *DeliveryOption, e *Consolidation) { n.appendNamedConsolidation(name, e) }); err != nil {
			return nil, err
		}
	}
	for i := range doq.loadTotal {
		if err := doq.loadTotal[i](ctx, nodes); err != nil {
			return nil, err
		}
	}
	return nodes, nil
}

func (doq *DeliveryOptionQuery) loadTenant(ctx context.Context, query *TenantQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *Tenant)) error {
	ids := make([]pulid.ID, 0, len(nodes))
	nodeids := make(map[pulid.ID][]*DeliveryOption)
	for i := range nodes {
		fk := nodes[i].TenantID
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(tenant.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "tenant_id" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadCarrier(ctx context.Context, query *CarrierQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *Carrier)) error {
	ids := make([]pulid.ID, 0, len(nodes))
	nodeids := make(map[pulid.ID][]*DeliveryOption)
	for i := range nodes {
		if nodes[i].delivery_option_carrier == nil {
			continue
		}
		fk := *nodes[i].delivery_option_carrier
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(carrier.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "delivery_option_carrier" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadDeliveryRule(ctx context.Context, query *DeliveryRuleQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *DeliveryRule)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.DeliveryRule(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.DeliveryRuleColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.delivery_option_delivery_rule
		if fk == nil {
			return fmt.Errorf(`foreign-key "delivery_option_delivery_rule" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "delivery_option_delivery_rule" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadDeliveryOptionDAO(ctx context.Context, query *DeliveryOptionDAOQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *DeliveryOptionDAO)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.DeliveryOptionDAO(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.DeliveryOptionDAOColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.delivery_option_delivery_option_dao
		if fk == nil {
			return fmt.Errorf(`foreign-key "delivery_option_delivery_option_dao" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "delivery_option_delivery_option_dao" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadDeliveryOptionDF(ctx context.Context, query *DeliveryOptionDFQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *DeliveryOptionDF)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.DeliveryOptionDF(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.DeliveryOptionDFColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.delivery_option_delivery_option_df
		if fk == nil {
			return fmt.Errorf(`foreign-key "delivery_option_delivery_option_df" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "delivery_option_delivery_option_df" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadDeliveryOptionDSV(ctx context.Context, query *DeliveryOptionDSVQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *DeliveryOptionDSV)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.DeliveryOptionDSV(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.DeliveryOptionDSVColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.delivery_option_delivery_option_dsv
		if fk == nil {
			return fmt.Errorf(`foreign-key "delivery_option_delivery_option_dsv" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "delivery_option_delivery_option_dsv" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadDeliveryOptionEasyPost(ctx context.Context, query *DeliveryOptionEasyPostQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *DeliveryOptionEasyPost)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.DeliveryOptionEasyPost(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.DeliveryOptionEasyPostColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.delivery_option_delivery_option_easy_post
		if fk == nil {
			return fmt.Errorf(`foreign-key "delivery_option_delivery_option_easy_post" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "delivery_option_delivery_option_easy_post" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadDeliveryOptionGLS(ctx context.Context, query *DeliveryOptionGLSQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *DeliveryOptionGLS)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.DeliveryOptionGLS(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.DeliveryOptionGLSColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.delivery_option_delivery_option_gls
		if fk == nil {
			return fmt.Errorf(`foreign-key "delivery_option_delivery_option_gls" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "delivery_option_delivery_option_gls" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadDeliveryOptionPostNord(ctx context.Context, query *DeliveryOptionPostNordQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *DeliveryOptionPostNord)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.DeliveryOptionPostNord(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.DeliveryOptionPostNordColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.delivery_option_delivery_option_post_nord
		if fk == nil {
			return fmt.Errorf(`foreign-key "delivery_option_delivery_option_post_nord" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "delivery_option_delivery_option_post_nord" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadDeliveryOptionUSPS(ctx context.Context, query *DeliveryOptionUSPSQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *DeliveryOptionUSPS)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.DeliveryOptionUSPS(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.DeliveryOptionUSPSColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.delivery_option_delivery_option_usps
		if fk == nil {
			return fmt.Errorf(`foreign-key "delivery_option_delivery_option_usps" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "delivery_option_delivery_option_usps" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadDeliveryOptionBring(ctx context.Context, query *DeliveryOptionBringQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *DeliveryOptionBring)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
	}
	query.withFKs = true
	query.Where(predicate.DeliveryOptionBring(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.DeliveryOptionBringColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.delivery_option_delivery_option_bring
		if fk == nil {
			return fmt.Errorf(`foreign-key "delivery_option_delivery_option_bring" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "delivery_option_delivery_option_bring" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadReturnPortals(ctx context.Context, query *ReturnPortalQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *ReturnPortal)) error {
	edgeIDs := make([]driver.Value, len(nodes))
	byID := make(map[pulid.ID]*DeliveryOption)
	nids := make(map[pulid.ID]map[*DeliveryOption]struct{})
	for i, node := range nodes {
		edgeIDs[i] = node.ID
		byID[node.ID] = node
		if init != nil {
			init(node)
		}
	}
	query.Where(func(s *sql.Selector) {
		joinT := sql.Table(deliveryoption.ReturnPortalsTable)
		s.Join(joinT).On(s.C(returnportal.FieldID), joinT.C(deliveryoption.ReturnPortalsPrimaryKey[0]))
		s.Where(sql.InValues(joinT.C(deliveryoption.ReturnPortalsPrimaryKey[1]), edgeIDs...))
		columns := s.SelectedColumns()
		s.Select(joinT.C(deliveryoption.ReturnPortalsPrimaryKey[1]))
		s.AppendSelect(columns...)
		s.SetDistinct(false)
	})
	if err := query.prepareQuery(ctx); err != nil {
		return err
	}
	qr := QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		return query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) {
			assign := spec.Assign
			values := spec.ScanValues
			spec.ScanValues = func(columns []string) ([]any, error) {
				values, err := values(columns[1:])
				if err != nil {
					return nil, err
				}
				return append([]any{new(pulid.ID)}, values...), nil
			}
			spec.Assign = func(columns []string, values []any) error {
				outValue := *values[0].(*pulid.ID)
				inValue := *values[1].(*pulid.ID)
				if nids[inValue] == nil {
					nids[inValue] = map[*DeliveryOption]struct{}{byID[outValue]: {}}
					return assign(columns[1:], values[1:])
				}
				nids[inValue][byID[outValue]] = struct{}{}
				return nil
			}
		})
	})
	neighbors, err := withInterceptors[[]*ReturnPortal](ctx, query, qr, query.inters)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected "return_portals" node returned %v`, n.ID)
		}
		for kn := range nodes {
			assign(kn, n)
		}
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadColli(ctx context.Context, query *ColliQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *Colli)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Colli(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.ColliColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.colli_delivery_option
		if fk == nil {
			return fmt.Errorf(`foreign-key "colli_delivery_option" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "colli_delivery_option" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadReturnColli(ctx context.Context, query *ReturnColliQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *ReturnColli)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.ReturnColli(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.ReturnColliColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.return_colli_delivery_option
		if fk == nil {
			return fmt.Errorf(`foreign-key "return_colli_delivery_option" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "return_colli_delivery_option" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadCarrierService(ctx context.Context, query *CarrierServiceQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *CarrierService)) error {
	ids := make([]pulid.ID, 0, len(nodes))
	nodeids := make(map[pulid.ID][]*DeliveryOption)
	for i := range nodes {
		if nodes[i].delivery_option_carrier_service == nil {
			continue
		}
		fk := *nodes[i].delivery_option_carrier_service
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(carrierservice.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "delivery_option_carrier_service" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadConnection(ctx context.Context, query *ConnectionQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *Connection)) error {
	ids := make([]pulid.ID, 0, len(nodes))
	nodeids := make(map[pulid.ID][]*DeliveryOption)
	for i := range nodes {
		if nodes[i].connection_delivery_option == nil {
			continue
		}
		fk := *nodes[i].connection_delivery_option
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(connection.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "connection_delivery_option" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadConnectionDefault(ctx context.Context, query *ConnectionQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *Connection)) error {
	ids := make([]pulid.ID, 0, len(nodes))
	nodeids := make(map[pulid.ID][]*DeliveryOption)
	for i := range nodes {
		if nodes[i].connection_default_delivery_option == nil {
			continue
		}
		fk := *nodes[i].connection_default_delivery_option
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(connection.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "connection_default_delivery_option" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadHypothesisTestDeliveryOptionGroupOne(ctx context.Context, query *HypothesisTestDeliveryOptionQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *HypothesisTestDeliveryOption)) error {
	edgeIDs := make([]driver.Value, len(nodes))
	byID := make(map[pulid.ID]*DeliveryOption)
	nids := make(map[pulid.ID]map[*DeliveryOption]struct{})
	for i, node := range nodes {
		edgeIDs[i] = node.ID
		byID[node.ID] = node
		if init != nil {
			init(node)
		}
	}
	query.Where(func(s *sql.Selector) {
		joinT := sql.Table(deliveryoption.HypothesisTestDeliveryOptionGroupOneTable)
		s.Join(joinT).On(s.C(hypothesistestdeliveryoption.FieldID), joinT.C(deliveryoption.HypothesisTestDeliveryOptionGroupOnePrimaryKey[0]))
		s.Where(sql.InValues(joinT.C(deliveryoption.HypothesisTestDeliveryOptionGroupOnePrimaryKey[1]), edgeIDs...))
		columns := s.SelectedColumns()
		s.Select(joinT.C(deliveryoption.HypothesisTestDeliveryOptionGroupOnePrimaryKey[1]))
		s.AppendSelect(columns...)
		s.SetDistinct(false)
	})
	if err := query.prepareQuery(ctx); err != nil {
		return err
	}
	qr := QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		return query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) {
			assign := spec.Assign
			values := spec.ScanValues
			spec.ScanValues = func(columns []string) ([]any, error) {
				values, err := values(columns[1:])
				if err != nil {
					return nil, err
				}
				return append([]any{new(pulid.ID)}, values...), nil
			}
			spec.Assign = func(columns []string, values []any) error {
				outValue := *values[0].(*pulid.ID)
				inValue := *values[1].(*pulid.ID)
				if nids[inValue] == nil {
					nids[inValue] = map[*DeliveryOption]struct{}{byID[outValue]: {}}
					return assign(columns[1:], values[1:])
				}
				nids[inValue][byID[outValue]] = struct{}{}
				return nil
			}
		})
	})
	neighbors, err := withInterceptors[[]*HypothesisTestDeliveryOption](ctx, query, qr, query.inters)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected "hypothesis_test_delivery_option_group_one" node returned %v`, n.ID)
		}
		for kn := range nodes {
			assign(kn, n)
		}
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadHypothesisTestDeliveryOptionGroupTwo(ctx context.Context, query *HypothesisTestDeliveryOptionQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *HypothesisTestDeliveryOption)) error {
	edgeIDs := make([]driver.Value, len(nodes))
	byID := make(map[pulid.ID]*DeliveryOption)
	nids := make(map[pulid.ID]map[*DeliveryOption]struct{})
	for i, node := range nodes {
		edgeIDs[i] = node.ID
		byID[node.ID] = node
		if init != nil {
			init(node)
		}
	}
	query.Where(func(s *sql.Selector) {
		joinT := sql.Table(deliveryoption.HypothesisTestDeliveryOptionGroupTwoTable)
		s.Join(joinT).On(s.C(hypothesistestdeliveryoption.FieldID), joinT.C(deliveryoption.HypothesisTestDeliveryOptionGroupTwoPrimaryKey[0]))
		s.Where(sql.InValues(joinT.C(deliveryoption.HypothesisTestDeliveryOptionGroupTwoPrimaryKey[1]), edgeIDs...))
		columns := s.SelectedColumns()
		s.Select(joinT.C(deliveryoption.HypothesisTestDeliveryOptionGroupTwoPrimaryKey[1]))
		s.AppendSelect(columns...)
		s.SetDistinct(false)
	})
	if err := query.prepareQuery(ctx); err != nil {
		return err
	}
	qr := QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		return query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) {
			assign := spec.Assign
			values := spec.ScanValues
			spec.ScanValues = func(columns []string) ([]any, error) {
				values, err := values(columns[1:])
				if err != nil {
					return nil, err
				}
				return append([]any{new(pulid.ID)}, values...), nil
			}
			spec.Assign = func(columns []string, values []any) error {
				outValue := *values[0].(*pulid.ID)
				inValue := *values[1].(*pulid.ID)
				if nids[inValue] == nil {
					nids[inValue] = map[*DeliveryOption]struct{}{byID[outValue]: {}}
					return assign(columns[1:], values[1:])
				}
				nids[inValue][byID[outValue]] = struct{}{}
				return nil
			}
		})
	})
	neighbors, err := withInterceptors[[]*HypothesisTestDeliveryOption](ctx, query, qr, query.inters)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected "hypothesis_test_delivery_option_group_two" node returned %v`, n.ID)
		}
		for kn := range nodes {
			assign(kn, n)
		}
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadHypothesisTestDeliveryOptionLookup(ctx context.Context, query *HypothesisTestDeliveryOptionLookupQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *HypothesisTestDeliveryOptionLookup)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.HypothesisTestDeliveryOptionLookup(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.HypothesisTestDeliveryOptionLookupColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.hypothesis_test_delivery_option_lookup_delivery_option
		if fk == nil {
			return fmt.Errorf(`foreign-key "hypothesis_test_delivery_option_lookup_delivery_option" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "hypothesis_test_delivery_option_lookup_delivery_option" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadClickCollectLocation(ctx context.Context, query *LocationQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *Location)) error {
	edgeIDs := make([]driver.Value, len(nodes))
	byID := make(map[pulid.ID]*DeliveryOption)
	nids := make(map[pulid.ID]map[*DeliveryOption]struct{})
	for i, node := range nodes {
		edgeIDs[i] = node.ID
		byID[node.ID] = node
		if init != nil {
			init(node)
		}
	}
	query.Where(func(s *sql.Selector) {
		joinT := sql.Table(deliveryoption.ClickCollectLocationTable)
		s.Join(joinT).On(s.C(location.FieldID), joinT.C(deliveryoption.ClickCollectLocationPrimaryKey[1]))
		s.Where(sql.InValues(joinT.C(deliveryoption.ClickCollectLocationPrimaryKey[0]), edgeIDs...))
		columns := s.SelectedColumns()
		s.Select(joinT.C(deliveryoption.ClickCollectLocationPrimaryKey[0]))
		s.AppendSelect(columns...)
		s.SetDistinct(false)
	})
	if err := query.prepareQuery(ctx); err != nil {
		return err
	}
	qr := QuerierFunc(func(ctx context.Context, q Query) (Value, error) {
		return query.sqlAll(ctx, func(_ context.Context, spec *sqlgraph.QuerySpec) {
			assign := spec.Assign
			values := spec.ScanValues
			spec.ScanValues = func(columns []string) ([]any, error) {
				values, err := values(columns[1:])
				if err != nil {
					return nil, err
				}
				return append([]any{new(pulid.ID)}, values...), nil
			}
			spec.Assign = func(columns []string, values []any) error {
				outValue := *values[0].(*pulid.ID)
				inValue := *values[1].(*pulid.ID)
				if nids[inValue] == nil {
					nids[inValue] = map[*DeliveryOption]struct{}{byID[outValue]: {}}
					return assign(columns[1:], values[1:])
				}
				nids[inValue][byID[outValue]] = struct{}{}
				return nil
			}
		})
	})
	neighbors, err := withInterceptors[[]*Location](ctx, query, qr, query.inters)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected "click_collect_location" node returned %v`, n.ID)
		}
		for kn := range nodes {
			assign(kn, n)
		}
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadEmailClickCollectAtStore(ctx context.Context, query *EmailTemplateQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *EmailTemplate)) error {
	ids := make([]pulid.ID, 0, len(nodes))
	nodeids := make(map[pulid.ID][]*DeliveryOption)
	for i := range nodes {
		if nodes[i].delivery_option_email_click_collect_at_store == nil {
			continue
		}
		fk := *nodes[i].delivery_option_email_click_collect_at_store
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(emailtemplate.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "delivery_option_email_click_collect_at_store" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadConsolidation(ctx context.Context, query *ConsolidationQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *Consolidation)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[pulid.ID]*DeliveryOption)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	query.withFKs = true
	query.Where(predicate.Consolidation(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(deliveryoption.ConsolidationColumn), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.consolidation_delivery_option
		if fk == nil {
			return fmt.Errorf(`foreign-key "consolidation_delivery_option" is nil for node %v`, n.ID)
		}
		node, ok := nodeids[*fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "consolidation_delivery_option" returned %v for node %v`, *fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
func (doq *DeliveryOptionQuery) loadDefaultPackaging(ctx context.Context, query *PackagingQuery, nodes []*DeliveryOption, init func(*DeliveryOption), assign func(*DeliveryOption, *Packaging)) error {
	ids := make([]pulid.ID, 0, len(nodes))
	nodeids := make(map[pulid.ID][]*DeliveryOption)
	for i := range nodes {
		if nodes[i].delivery_option_default_packaging == nil {
			continue
		}
		fk := *nodes[i].delivery_option_default_packaging
		if _, ok := nodeids[fk]; !ok {
			ids = append(ids, fk)
		}
		nodeids[fk] = append(nodeids[fk], nodes[i])
	}
	if len(ids) == 0 {
		return nil
	}
	query.Where(packaging.IDIn(ids...))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		nodes, ok := nodeids[n.ID]
		if !ok {
			return fmt.Errorf(`unexpected foreign-key "delivery_option_default_packaging" returned %v`, n.ID)
		}
		for i := range nodes {
			assign(nodes[i], n)
		}
	}
	return nil
}

func (doq *DeliveryOptionQuery) sqlCount(ctx context.Context) (int, error) {
	_spec := doq.querySpec()
	if len(doq.modifiers) > 0 {
		_spec.Modifiers = doq.modifiers
	}
	_spec.Node.Columns = doq.ctx.Fields
	if len(doq.ctx.Fields) > 0 {
		_spec.Unique = doq.ctx.Unique != nil && *doq.ctx.Unique
	}
	return sqlgraph.CountNodes(ctx, doq.driver, _spec)
}

func (doq *DeliveryOptionQuery) querySpec() *sqlgraph.QuerySpec {
	_spec := sqlgraph.NewQuerySpec(deliveryoption.Table, deliveryoption.Columns, sqlgraph.NewFieldSpec(deliveryoption.FieldID, field.TypeString))
	_spec.From = doq.sql
	if unique := doq.ctx.Unique; unique != nil {
		_spec.Unique = *unique
	} else if doq.path != nil {
		_spec.Unique = true
	}
	if fields := doq.ctx.Fields; len(fields) > 0 {
		_spec.Node.Columns = make([]string, 0, len(fields))
		_spec.Node.Columns = append(_spec.Node.Columns, deliveryoption.FieldID)
		for i := range fields {
			if fields[i] != deliveryoption.FieldID {
				_spec.Node.Columns = append(_spec.Node.Columns, fields[i])
			}
		}
		if doq.withTenant != nil {
			_spec.Node.AddColumnOnce(deliveryoption.FieldTenantID)
		}
	}
	if ps := doq.predicates; len(ps) > 0 {
		_spec.Predicate = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	if limit := doq.ctx.Limit; limit != nil {
		_spec.Limit = *limit
	}
	if offset := doq.ctx.Offset; offset != nil {
		_spec.Offset = *offset
	}
	if ps := doq.order; len(ps) > 0 {
		_spec.Order = func(selector *sql.Selector) {
			for i := range ps {
				ps[i](selector)
			}
		}
	}
	return _spec
}

func (doq *DeliveryOptionQuery) sqlQuery(ctx context.Context) *sql.Selector {
	builder := sql.Dialect(doq.driver.Dialect())
	t1 := builder.Table(deliveryoption.Table)
	columns := doq.ctx.Fields
	if len(columns) == 0 {
		columns = deliveryoption.Columns
	}
	selector := builder.Select(t1.Columns(columns...)...).From(t1)
	if doq.sql != nil {
		selector = doq.sql
		selector.Select(selector.Columns(columns...)...)
	}
	if doq.ctx.Unique != nil && *doq.ctx.Unique {
		selector.Distinct()
	}
	for _, p := range doq.predicates {
		p(selector)
	}
	for _, p := range doq.order {
		p(selector)
	}
	if offset := doq.ctx.Offset; offset != nil {
		// limit is mandatory for offset clause. We start
		// with default value, and override it below if needed.
		selector.Offset(*offset).Limit(math.MaxInt32)
	}
	if limit := doq.ctx.Limit; limit != nil {
		selector.Limit(*limit)
	}
	return selector
}

// WithNamedDeliveryRule tells the query-builder to eager-load the nodes that are connected to the "delivery_rule"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithNamedDeliveryRule(name string, opts ...func(*DeliveryRuleQuery)) *DeliveryOptionQuery {
	query := (&DeliveryRuleClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if doq.withNamedDeliveryRule == nil {
		doq.withNamedDeliveryRule = make(map[string]*DeliveryRuleQuery)
	}
	doq.withNamedDeliveryRule[name] = query
	return doq
}

// WithNamedReturnPortals tells the query-builder to eager-load the nodes that are connected to the "return_portals"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithNamedReturnPortals(name string, opts ...func(*ReturnPortalQuery)) *DeliveryOptionQuery {
	query := (&ReturnPortalClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if doq.withNamedReturnPortals == nil {
		doq.withNamedReturnPortals = make(map[string]*ReturnPortalQuery)
	}
	doq.withNamedReturnPortals[name] = query
	return doq
}

// WithNamedColli tells the query-builder to eager-load the nodes that are connected to the "colli"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithNamedColli(name string, opts ...func(*ColliQuery)) *DeliveryOptionQuery {
	query := (&ColliClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if doq.withNamedColli == nil {
		doq.withNamedColli = make(map[string]*ColliQuery)
	}
	doq.withNamedColli[name] = query
	return doq
}

// WithNamedReturnColli tells the query-builder to eager-load the nodes that are connected to the "return_colli"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithNamedReturnColli(name string, opts ...func(*ReturnColliQuery)) *DeliveryOptionQuery {
	query := (&ReturnColliClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if doq.withNamedReturnColli == nil {
		doq.withNamedReturnColli = make(map[string]*ReturnColliQuery)
	}
	doq.withNamedReturnColli[name] = query
	return doq
}

// WithNamedHypothesisTestDeliveryOptionGroupOne tells the query-builder to eager-load the nodes that are connected to the "hypothesis_test_delivery_option_group_one"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithNamedHypothesisTestDeliveryOptionGroupOne(name string, opts ...func(*HypothesisTestDeliveryOptionQuery)) *DeliveryOptionQuery {
	query := (&HypothesisTestDeliveryOptionClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if doq.withNamedHypothesisTestDeliveryOptionGroupOne == nil {
		doq.withNamedHypothesisTestDeliveryOptionGroupOne = make(map[string]*HypothesisTestDeliveryOptionQuery)
	}
	doq.withNamedHypothesisTestDeliveryOptionGroupOne[name] = query
	return doq
}

// WithNamedHypothesisTestDeliveryOptionGroupTwo tells the query-builder to eager-load the nodes that are connected to the "hypothesis_test_delivery_option_group_two"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithNamedHypothesisTestDeliveryOptionGroupTwo(name string, opts ...func(*HypothesisTestDeliveryOptionQuery)) *DeliveryOptionQuery {
	query := (&HypothesisTestDeliveryOptionClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if doq.withNamedHypothesisTestDeliveryOptionGroupTwo == nil {
		doq.withNamedHypothesisTestDeliveryOptionGroupTwo = make(map[string]*HypothesisTestDeliveryOptionQuery)
	}
	doq.withNamedHypothesisTestDeliveryOptionGroupTwo[name] = query
	return doq
}

// WithNamedHypothesisTestDeliveryOptionLookup tells the query-builder to eager-load the nodes that are connected to the "hypothesis_test_delivery_option_lookup"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithNamedHypothesisTestDeliveryOptionLookup(name string, opts ...func(*HypothesisTestDeliveryOptionLookupQuery)) *DeliveryOptionQuery {
	query := (&HypothesisTestDeliveryOptionLookupClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if doq.withNamedHypothesisTestDeliveryOptionLookup == nil {
		doq.withNamedHypothesisTestDeliveryOptionLookup = make(map[string]*HypothesisTestDeliveryOptionLookupQuery)
	}
	doq.withNamedHypothesisTestDeliveryOptionLookup[name] = query
	return doq
}

// WithNamedClickCollectLocation tells the query-builder to eager-load the nodes that are connected to the "click_collect_location"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithNamedClickCollectLocation(name string, opts ...func(*LocationQuery)) *DeliveryOptionQuery {
	query := (&LocationClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if doq.withNamedClickCollectLocation == nil {
		doq.withNamedClickCollectLocation = make(map[string]*LocationQuery)
	}
	doq.withNamedClickCollectLocation[name] = query
	return doq
}

// WithNamedConsolidation tells the query-builder to eager-load the nodes that are connected to the "consolidation"
// edge with the given name. The optional arguments are used to configure the query builder of the edge.
func (doq *DeliveryOptionQuery) WithNamedConsolidation(name string, opts ...func(*ConsolidationQuery)) *DeliveryOptionQuery {
	query := (&ConsolidationClient{config: doq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	if doq.withNamedConsolidation == nil {
		doq.withNamedConsolidation = make(map[string]*ConsolidationQuery)
	}
	doq.withNamedConsolidation[name] = query
	return doq
}

// DeliveryOptionGroupBy is the group-by builder for DeliveryOption entities.
type DeliveryOptionGroupBy struct {
	selector
	build *DeliveryOptionQuery
}

// Aggregate adds the given aggregation functions to the group-by query.
func (dogb *DeliveryOptionGroupBy) Aggregate(fns ...AggregateFunc) *DeliveryOptionGroupBy {
	dogb.fns = append(dogb.fns, fns...)
	return dogb
}

// Scan applies the selector query and scans the result into the given value.
func (dogb *DeliveryOptionGroupBy) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, dogb.build.ctx, ent.OpQueryGroupBy)
	if err := dogb.build.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*DeliveryOptionQuery, *DeliveryOptionGroupBy](ctx, dogb.build, dogb, dogb.build.inters, v)
}

func (dogb *DeliveryOptionGroupBy) sqlScan(ctx context.Context, root *DeliveryOptionQuery, v any) error {
	selector := root.sqlQuery(ctx).Select()
	aggregation := make([]string, 0, len(dogb.fns))
	for _, fn := range dogb.fns {
		aggregation = append(aggregation, fn(selector))
	}
	if len(selector.SelectedColumns()) == 0 {
		columns := make([]string, 0, len(*dogb.flds)+len(dogb.fns))
		for _, f := range *dogb.flds {
			columns = append(columns, selector.C(f))
		}
		columns = append(columns, aggregation...)
		selector.Select(columns...)
	}
	selector.GroupBy(selector.Columns(*dogb.flds...)...)
	if err := selector.Err(); err != nil {
		return err
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := dogb.build.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}

// DeliveryOptionSelect is the builder for selecting fields of DeliveryOption entities.
type DeliveryOptionSelect struct {
	*DeliveryOptionQuery
	selector
}

// Aggregate adds the given aggregation functions to the selector query.
func (dos *DeliveryOptionSelect) Aggregate(fns ...AggregateFunc) *DeliveryOptionSelect {
	dos.fns = append(dos.fns, fns...)
	return dos
}

// Scan applies the selector query and scans the result into the given value.
func (dos *DeliveryOptionSelect) Scan(ctx context.Context, v any) error {
	ctx = setContextOp(ctx, dos.ctx, ent.OpQuerySelect)
	if err := dos.prepareQuery(ctx); err != nil {
		return err
	}
	return scanWithInterceptors[*DeliveryOptionQuery, *DeliveryOptionSelect](ctx, dos.DeliveryOptionQuery, dos, dos.inters, v)
}

func (dos *DeliveryOptionSelect) sqlScan(ctx context.Context, root *DeliveryOptionQuery, v any) error {
	selector := root.sqlQuery(ctx)
	aggregation := make([]string, 0, len(dos.fns))
	for _, fn := range dos.fns {
		aggregation = append(aggregation, fn(selector))
	}
	switch n := len(*dos.selector.flds); {
	case n == 0 && len(aggregation) > 0:
		selector.Select(aggregation...)
	case n != 0 && len(aggregation) > 0:
		selector.AppendSelect(aggregation...)
	}
	rows := &sql.Rows{}
	query, args := selector.Query()
	if err := dos.driver.Query(ctx, query, args, rows); err != nil {
		return err
	}
	defer rows.Close()
	return sql.ScanSlice(rows, v)
}
