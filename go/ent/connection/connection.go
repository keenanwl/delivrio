// Code generated by ent, DO NOT EDIT.

package connection

import (
	"delivrio.io/shared-utils/pulid"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

const (
	// Label holds the string label denoting the connection type in the database.
	Label = "connection"
	// FieldID holds the string denoting the id field in the database.
	FieldID = "id"
	// FieldTenantID holds the string denoting the tenant_id field in the database.
	FieldTenantID = "tenant_id"
	// FieldName holds the string denoting the name field in the database.
	FieldName = "name"
	// FieldSyncOrders holds the string denoting the sync_orders field in the database.
	FieldSyncOrders = "sync_orders"
	// FieldSyncProducts holds the string denoting the sync_products field in the database.
	FieldSyncProducts = "sync_products"
	// FieldFulfillAutomatically holds the string denoting the fulfill_automatically field in the database.
	FieldFulfillAutomatically = "fulfill_automatically"
	// FieldDispatchAutomatically holds the string denoting the dispatch_automatically field in the database.
	FieldDispatchAutomatically = "dispatch_automatically"
	// FieldConvertCurrency holds the string denoting the convert_currency field in the database.
	FieldConvertCurrency = "convert_currency"
	// FieldAutoPrintParcelSlip holds the string denoting the auto_print_parcel_slip field in the database.
	FieldAutoPrintParcelSlip = "auto_print_parcel_slip"
	// EdgeTenant holds the string denoting the tenant edge name in mutations.
	EdgeTenant = "tenant"
	// EdgeConnectionBrand holds the string denoting the connection_brand edge name in mutations.
	EdgeConnectionBrand = "connection_brand"
	// EdgeConnectionShopify holds the string denoting the connection_shopify edge name in mutations.
	EdgeConnectionShopify = "connection_shopify"
	// EdgeOrders holds the string denoting the orders edge name in mutations.
	EdgeOrders = "orders"
	// EdgeSenderLocation holds the string denoting the sender_location edge name in mutations.
	EdgeSenderLocation = "sender_location"
	// EdgePickupLocation holds the string denoting the pickup_location edge name in mutations.
	EdgePickupLocation = "pickup_location"
	// EdgeReturnLocation holds the string denoting the return_location edge name in mutations.
	EdgeReturnLocation = "return_location"
	// EdgeSellerLocation holds the string denoting the seller_location edge name in mutations.
	EdgeSellerLocation = "seller_location"
	// EdgeDeliveryOption holds the string denoting the delivery_option edge name in mutations.
	EdgeDeliveryOption = "delivery_option"
	// EdgeDefaultDeliveryOption holds the string denoting the default_delivery_option edge name in mutations.
	EdgeDefaultDeliveryOption = "default_delivery_option"
	// EdgeReturnPortal holds the string denoting the return_portal edge name in mutations.
	EdgeReturnPortal = "return_portal"
	// EdgeHypothesisTest holds the string denoting the hypothesis_test edge name in mutations.
	EdgeHypothesisTest = "hypothesis_test"
	// EdgeNotifications holds the string denoting the notifications edge name in mutations.
	EdgeNotifications = "notifications"
	// EdgeCurrency holds the string denoting the currency edge name in mutations.
	EdgeCurrency = "currency"
	// EdgePackingSlipTemplate holds the string denoting the packing_slip_template edge name in mutations.
	EdgePackingSlipTemplate = "packing_slip_template"
	// EdgeConnectionLookup holds the string denoting the connection_lookup edge name in mutations.
	EdgeConnectionLookup = "connection_lookup"
	// Table holds the table name of the connection in the database.
	Table = "connections"
	// TenantTable is the table that holds the tenant relation/edge.
	TenantTable = "connections"
	// TenantInverseTable is the table name for the Tenant entity.
	// It exists in this package in order to avoid circular dependency with the "tenant" package.
	TenantInverseTable = "tenants"
	// TenantColumn is the table column denoting the tenant relation/edge.
	TenantColumn = "tenant_id"
	// ConnectionBrandTable is the table that holds the connection_brand relation/edge.
	ConnectionBrandTable = "connections"
	// ConnectionBrandInverseTable is the table name for the ConnectionBrand entity.
	// It exists in this package in order to avoid circular dependency with the "connectionbrand" package.
	ConnectionBrandInverseTable = "connection_brands"
	// ConnectionBrandColumn is the table column denoting the connection_brand relation/edge.
	ConnectionBrandColumn = "connection_connection_brand"
	// ConnectionShopifyTable is the table that holds the connection_shopify relation/edge.
	ConnectionShopifyTable = "connection_shopifies"
	// ConnectionShopifyInverseTable is the table name for the ConnectionShopify entity.
	// It exists in this package in order to avoid circular dependency with the "connectionshopify" package.
	ConnectionShopifyInverseTable = "connection_shopifies"
	// ConnectionShopifyColumn is the table column denoting the connection_shopify relation/edge.
	ConnectionShopifyColumn = "connection_connection_shopify"
	// OrdersTable is the table that holds the orders relation/edge.
	OrdersTable = "orders"
	// OrdersInverseTable is the table name for the Order entity.
	// It exists in this package in order to avoid circular dependency with the "order" package.
	OrdersInverseTable = "orders"
	// OrdersColumn is the table column denoting the orders relation/edge.
	OrdersColumn = "connection_orders"
	// SenderLocationTable is the table that holds the sender_location relation/edge.
	SenderLocationTable = "connections"
	// SenderLocationInverseTable is the table name for the Location entity.
	// It exists in this package in order to avoid circular dependency with the "location" package.
	SenderLocationInverseTable = "locations"
	// SenderLocationColumn is the table column denoting the sender_location relation/edge.
	SenderLocationColumn = "connection_sender_location"
	// PickupLocationTable is the table that holds the pickup_location relation/edge.
	PickupLocationTable = "connections"
	// PickupLocationInverseTable is the table name for the Location entity.
	// It exists in this package in order to avoid circular dependency with the "location" package.
	PickupLocationInverseTable = "locations"
	// PickupLocationColumn is the table column denoting the pickup_location relation/edge.
	PickupLocationColumn = "connection_pickup_location"
	// ReturnLocationTable is the table that holds the return_location relation/edge.
	ReturnLocationTable = "connections"
	// ReturnLocationInverseTable is the table name for the Location entity.
	// It exists in this package in order to avoid circular dependency with the "location" package.
	ReturnLocationInverseTable = "locations"
	// ReturnLocationColumn is the table column denoting the return_location relation/edge.
	ReturnLocationColumn = "connection_return_location"
	// SellerLocationTable is the table that holds the seller_location relation/edge.
	SellerLocationTable = "connections"
	// SellerLocationInverseTable is the table name for the Location entity.
	// It exists in this package in order to avoid circular dependency with the "location" package.
	SellerLocationInverseTable = "locations"
	// SellerLocationColumn is the table column denoting the seller_location relation/edge.
	SellerLocationColumn = "connection_seller_location"
	// DeliveryOptionTable is the table that holds the delivery_option relation/edge.
	DeliveryOptionTable = "delivery_options"
	// DeliveryOptionInverseTable is the table name for the DeliveryOption entity.
	// It exists in this package in order to avoid circular dependency with the "deliveryoption" package.
	DeliveryOptionInverseTable = "delivery_options"
	// DeliveryOptionColumn is the table column denoting the delivery_option relation/edge.
	DeliveryOptionColumn = "connection_delivery_option"
	// DefaultDeliveryOptionTable is the table that holds the default_delivery_option relation/edge.
	DefaultDeliveryOptionTable = "delivery_options"
	// DefaultDeliveryOptionInverseTable is the table name for the DeliveryOption entity.
	// It exists in this package in order to avoid circular dependency with the "deliveryoption" package.
	DefaultDeliveryOptionInverseTable = "delivery_options"
	// DefaultDeliveryOptionColumn is the table column denoting the default_delivery_option relation/edge.
	DefaultDeliveryOptionColumn = "connection_default_delivery_option"
	// ReturnPortalTable is the table that holds the return_portal relation/edge.
	ReturnPortalTable = "connections"
	// ReturnPortalInverseTable is the table name for the ReturnPortal entity.
	// It exists in this package in order to avoid circular dependency with the "returnportal" package.
	ReturnPortalInverseTable = "return_portals"
	// ReturnPortalColumn is the table column denoting the return_portal relation/edge.
	ReturnPortalColumn = "return_portal_connection"
	// HypothesisTestTable is the table that holds the hypothesis_test relation/edge.
	HypothesisTestTable = "hypothesis_tests"
	// HypothesisTestInverseTable is the table name for the HypothesisTest entity.
	// It exists in this package in order to avoid circular dependency with the "hypothesistest" package.
	HypothesisTestInverseTable = "hypothesis_tests"
	// HypothesisTestColumn is the table column denoting the hypothesis_test relation/edge.
	HypothesisTestColumn = "hypothesis_test_connection"
	// NotificationsTable is the table that holds the notifications relation/edge.
	NotificationsTable = "notifications"
	// NotificationsInverseTable is the table name for the Notification entity.
	// It exists in this package in order to avoid circular dependency with the "notification" package.
	NotificationsInverseTable = "notifications"
	// NotificationsColumn is the table column denoting the notifications relation/edge.
	NotificationsColumn = "notification_connection"
	// CurrencyTable is the table that holds the currency relation/edge.
	CurrencyTable = "connections"
	// CurrencyInverseTable is the table name for the Currency entity.
	// It exists in this package in order to avoid circular dependency with the "currency" package.
	CurrencyInverseTable = "currencies"
	// CurrencyColumn is the table column denoting the currency relation/edge.
	CurrencyColumn = "connection_currency"
	// PackingSlipTemplateTable is the table that holds the packing_slip_template relation/edge.
	PackingSlipTemplateTable = "connections"
	// PackingSlipTemplateInverseTable is the table name for the Document entity.
	// It exists in this package in order to avoid circular dependency with the "document" package.
	PackingSlipTemplateInverseTable = "documents"
	// PackingSlipTemplateColumn is the table column denoting the packing_slip_template relation/edge.
	PackingSlipTemplateColumn = "connection_packing_slip_template"
	// ConnectionLookupTable is the table that holds the connection_lookup relation/edge.
	ConnectionLookupTable = "connection_lookups"
	// ConnectionLookupInverseTable is the table name for the ConnectionLookup entity.
	// It exists in this package in order to avoid circular dependency with the "connectionlookup" package.
	ConnectionLookupInverseTable = "connection_lookups"
	// ConnectionLookupColumn is the table column denoting the connection_lookup relation/edge.
	ConnectionLookupColumn = "connection_lookup_connections"
)

// Columns holds all SQL columns for connection fields.
var Columns = []string{
	FieldID,
	FieldTenantID,
	FieldName,
	FieldSyncOrders,
	FieldSyncProducts,
	FieldFulfillAutomatically,
	FieldDispatchAutomatically,
	FieldConvertCurrency,
	FieldAutoPrintParcelSlip,
}

// ForeignKeys holds the SQL foreign-keys that are owned by the "connections"
// table and are not defined as standalone fields in the schema.
var ForeignKeys = []string{
	"connection_connection_brand",
	"connection_sender_location",
	"connection_pickup_location",
	"connection_return_location",
	"connection_seller_location",
	"connection_currency",
	"connection_packing_slip_template",
	"return_portal_connection",
}

// ValidColumn reports if the column name is valid (part of the table columns).
func ValidColumn(column string) bool {
	for i := range Columns {
		if column == Columns[i] {
			return true
		}
	}
	for i := range ForeignKeys {
		if column == ForeignKeys[i] {
			return true
		}
	}
	return false
}

// Note that the variables below are initialized by the runtime
// package on the initialization of the application. Therefore,
// it should be imported in the main as follows:
//
//	import _ "delivrio.io/go/ent/runtime"
var (
	Hooks  [2]ent.Hook
	Policy ent.Policy
	// DefaultSyncOrders holds the default value on creation for the "sync_orders" field.
	DefaultSyncOrders bool
	// DefaultSyncProducts holds the default value on creation for the "sync_products" field.
	DefaultSyncProducts bool
	// DefaultFulfillAutomatically holds the default value on creation for the "fulfill_automatically" field.
	DefaultFulfillAutomatically bool
	// DefaultDispatchAutomatically holds the default value on creation for the "dispatch_automatically" field.
	DefaultDispatchAutomatically bool
	// DefaultConvertCurrency holds the default value on creation for the "convert_currency" field.
	DefaultConvertCurrency bool
	// DefaultAutoPrintParcelSlip holds the default value on creation for the "auto_print_parcel_slip" field.
	DefaultAutoPrintParcelSlip bool
	// DefaultID holds the default value on creation for the "id" field.
	DefaultID func() pulid.ID
)

// OrderOption defines the ordering options for the Connection queries.
type OrderOption func(*sql.Selector)

// ByID orders the results by the id field.
func ByID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldID, opts...).ToFunc()
}

// ByTenantID orders the results by the tenant_id field.
func ByTenantID(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldTenantID, opts...).ToFunc()
}

// ByName orders the results by the name field.
func ByName(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldName, opts...).ToFunc()
}

// BySyncOrders orders the results by the sync_orders field.
func BySyncOrders(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSyncOrders, opts...).ToFunc()
}

// BySyncProducts orders the results by the sync_products field.
func BySyncProducts(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldSyncProducts, opts...).ToFunc()
}

// ByFulfillAutomatically orders the results by the fulfill_automatically field.
func ByFulfillAutomatically(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldFulfillAutomatically, opts...).ToFunc()
}

// ByDispatchAutomatically orders the results by the dispatch_automatically field.
func ByDispatchAutomatically(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldDispatchAutomatically, opts...).ToFunc()
}

// ByConvertCurrency orders the results by the convert_currency field.
func ByConvertCurrency(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldConvertCurrency, opts...).ToFunc()
}

// ByAutoPrintParcelSlip orders the results by the auto_print_parcel_slip field.
func ByAutoPrintParcelSlip(opts ...sql.OrderTermOption) OrderOption {
	return sql.OrderByField(FieldAutoPrintParcelSlip, opts...).ToFunc()
}

// ByTenantField orders the results by tenant field.
func ByTenantField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newTenantStep(), sql.OrderByField(field, opts...))
	}
}

// ByConnectionBrandField orders the results by connection_brand field.
func ByConnectionBrandField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newConnectionBrandStep(), sql.OrderByField(field, opts...))
	}
}

// ByConnectionShopifyField orders the results by connection_shopify field.
func ByConnectionShopifyField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newConnectionShopifyStep(), sql.OrderByField(field, opts...))
	}
}

// ByOrdersCount orders the results by orders count.
func ByOrdersCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newOrdersStep(), opts...)
	}
}

// ByOrders orders the results by orders terms.
func ByOrders(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newOrdersStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// BySenderLocationField orders the results by sender_location field.
func BySenderLocationField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSenderLocationStep(), sql.OrderByField(field, opts...))
	}
}

// ByPickupLocationField orders the results by pickup_location field.
func ByPickupLocationField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPickupLocationStep(), sql.OrderByField(field, opts...))
	}
}

// ByReturnLocationField orders the results by return_location field.
func ByReturnLocationField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newReturnLocationStep(), sql.OrderByField(field, opts...))
	}
}

// BySellerLocationField orders the results by seller_location field.
func BySellerLocationField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newSellerLocationStep(), sql.OrderByField(field, opts...))
	}
}

// ByDeliveryOptionCount orders the results by delivery_option count.
func ByDeliveryOptionCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newDeliveryOptionStep(), opts...)
	}
}

// ByDeliveryOption orders the results by delivery_option terms.
func ByDeliveryOption(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newDeliveryOptionStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByDefaultDeliveryOptionField orders the results by default_delivery_option field.
func ByDefaultDeliveryOptionField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newDefaultDeliveryOptionStep(), sql.OrderByField(field, opts...))
	}
}

// ByReturnPortalField orders the results by return_portal field.
func ByReturnPortalField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newReturnPortalStep(), sql.OrderByField(field, opts...))
	}
}

// ByHypothesisTestCount orders the results by hypothesis_test count.
func ByHypothesisTestCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newHypothesisTestStep(), opts...)
	}
}

// ByHypothesisTest orders the results by hypothesis_test terms.
func ByHypothesisTest(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newHypothesisTestStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByNotificationsCount orders the results by notifications count.
func ByNotificationsCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newNotificationsStep(), opts...)
	}
}

// ByNotifications orders the results by notifications terms.
func ByNotifications(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newNotificationsStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}

// ByCurrencyField orders the results by currency field.
func ByCurrencyField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newCurrencyStep(), sql.OrderByField(field, opts...))
	}
}

// ByPackingSlipTemplateField orders the results by packing_slip_template field.
func ByPackingSlipTemplateField(field string, opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newPackingSlipTemplateStep(), sql.OrderByField(field, opts...))
	}
}

// ByConnectionLookupCount orders the results by connection_lookup count.
func ByConnectionLookupCount(opts ...sql.OrderTermOption) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborsCount(s, newConnectionLookupStep(), opts...)
	}
}

// ByConnectionLookup orders the results by connection_lookup terms.
func ByConnectionLookup(term sql.OrderTerm, terms ...sql.OrderTerm) OrderOption {
	return func(s *sql.Selector) {
		sqlgraph.OrderByNeighborTerms(s, newConnectionLookupStep(), append([]sql.OrderTerm{term}, terms...)...)
	}
}
func newTenantStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(TenantInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, TenantTable, TenantColumn),
	)
}
func newConnectionBrandStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ConnectionBrandInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, ConnectionBrandTable, ConnectionBrandColumn),
	)
}
func newConnectionShopifyStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ConnectionShopifyInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, ConnectionShopifyTable, ConnectionShopifyColumn),
	)
}
func newOrdersStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(OrdersInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, OrdersTable, OrdersColumn),
	)
}
func newSenderLocationStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SenderLocationInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, SenderLocationTable, SenderLocationColumn),
	)
}
func newPickupLocationStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PickupLocationInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, PickupLocationTable, PickupLocationColumn),
	)
}
func newReturnLocationStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ReturnLocationInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, ReturnLocationTable, ReturnLocationColumn),
	)
}
func newSellerLocationStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(SellerLocationInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, SellerLocationTable, SellerLocationColumn),
	)
}
func newDeliveryOptionStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(DeliveryOptionInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, false, DeliveryOptionTable, DeliveryOptionColumn),
	)
}
func newDefaultDeliveryOptionStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(DefaultDeliveryOptionInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, false, DefaultDeliveryOptionTable, DefaultDeliveryOptionColumn),
	)
}
func newReturnPortalStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ReturnPortalInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2O, true, ReturnPortalTable, ReturnPortalColumn),
	)
}
func newHypothesisTestStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(HypothesisTestInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, true, HypothesisTestTable, HypothesisTestColumn),
	)
}
func newNotificationsStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(NotificationsInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, true, NotificationsTable, NotificationsColumn),
	)
}
func newCurrencyStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(CurrencyInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, CurrencyTable, CurrencyColumn),
	)
}
func newPackingSlipTemplateStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(PackingSlipTemplateInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.M2O, false, PackingSlipTemplateTable, PackingSlipTemplateColumn),
	)
}
func newConnectionLookupStep() *sqlgraph.Step {
	return sqlgraph.NewStep(
		sqlgraph.From(Table, FieldID),
		sqlgraph.To(ConnectionLookupInverseTable, FieldID),
		sqlgraph.Edge(sqlgraph.O2M, true, ConnectionLookupTable, ConnectionLookupColumn),
	)
}
