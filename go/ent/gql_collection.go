// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"

	"delivrio.io/go/ent/accessright"
	"delivrio.io/go/ent/address"
	"delivrio.io/go/ent/addressglobal"
	"delivrio.io/go/ent/apitoken"
	"delivrio.io/go/ent/businesshoursperiod"
	"delivrio.io/go/ent/carrier"
	"delivrio.io/go/ent/carrieradditionalservicebring"
	"delivrio.io/go/ent/carrieradditionalservicedao"
	"delivrio.io/go/ent/carrieradditionalservicedf"
	"delivrio.io/go/ent/carrieradditionalservicedsv"
	"delivrio.io/go/ent/carrieradditionalserviceeasypost"
	"delivrio.io/go/ent/carrieradditionalservicegls"
	"delivrio.io/go/ent/carrieradditionalservicepostnord"
	"delivrio.io/go/ent/carrieradditionalserviceusps"
	"delivrio.io/go/ent/carrierbrand"
	"delivrio.io/go/ent/carrierbring"
	"delivrio.io/go/ent/carrierdao"
	"delivrio.io/go/ent/carrierdf"
	"delivrio.io/go/ent/carrierdsv"
	"delivrio.io/go/ent/carriereasypost"
	"delivrio.io/go/ent/carriergls"
	"delivrio.io/go/ent/carrierpostnord"
	"delivrio.io/go/ent/carrierservice"
	"delivrio.io/go/ent/carrierservicebring"
	"delivrio.io/go/ent/carrierservicegls"
	"delivrio.io/go/ent/carrierservicepostnord"
	"delivrio.io/go/ent/carrierusps"
	"delivrio.io/go/ent/changehistory"
	"delivrio.io/go/ent/colli"
	"delivrio.io/go/ent/connection"
	"delivrio.io/go/ent/connectionbrand"
	"delivrio.io/go/ent/connectionlookup"
	"delivrio.io/go/ent/connectionshopify"
	"delivrio.io/go/ent/connectoptioncarrier"
	"delivrio.io/go/ent/connectoptionplatform"
	"delivrio.io/go/ent/consolidation"
	"delivrio.io/go/ent/contact"
	"delivrio.io/go/ent/country"
	"delivrio.io/go/ent/countryharmonizedcode"
	"delivrio.io/go/ent/currency"
	"delivrio.io/go/ent/deliveryoption"
	"delivrio.io/go/ent/deliveryoptionbring"
	"delivrio.io/go/ent/deliveryoptiondao"
	"delivrio.io/go/ent/deliveryoptiondf"
	"delivrio.io/go/ent/deliveryoptiondsv"
	"delivrio.io/go/ent/deliveryoptioneasypost"
	"delivrio.io/go/ent/deliveryoptiongls"
	"delivrio.io/go/ent/deliveryoptionpostnord"
	"delivrio.io/go/ent/deliveryoptionusps"
	"delivrio.io/go/ent/deliveryrule"
	"delivrio.io/go/ent/deliveryruleconstraint"
	"delivrio.io/go/ent/deliveryruleconstraintgroup"
	"delivrio.io/go/ent/document"
	"delivrio.io/go/ent/documentfile"
	"delivrio.io/go/ent/emailtemplate"
	"delivrio.io/go/ent/hypothesistest"
	"delivrio.io/go/ent/hypothesistestdeliveryoption"
	"delivrio.io/go/ent/hypothesistestdeliveryoptionlookup"
	"delivrio.io/go/ent/hypothesistestdeliveryoptionrequest"
	"delivrio.io/go/ent/inventoryitem"
	"delivrio.io/go/ent/language"
	"delivrio.io/go/ent/location"
	"delivrio.io/go/ent/locationtag"
	"delivrio.io/go/ent/notification"
	"delivrio.io/go/ent/order"
	"delivrio.io/go/ent/orderhistory"
	"delivrio.io/go/ent/orderline"
	"delivrio.io/go/ent/ordersender"
	"delivrio.io/go/ent/otkrequests"
	"delivrio.io/go/ent/packaging"
	"delivrio.io/go/ent/packagingdf"
	"delivrio.io/go/ent/packagingusps"
	"delivrio.io/go/ent/packaginguspsprocessingcategory"
	"delivrio.io/go/ent/packaginguspsrateindicator"
	"delivrio.io/go/ent/pallet"
	"delivrio.io/go/ent/parcelshop"
	"delivrio.io/go/ent/parcelshopbring"
	"delivrio.io/go/ent/parcelshopdao"
	"delivrio.io/go/ent/parcelshopgls"
	"delivrio.io/go/ent/parcelshoppostnord"
	"delivrio.io/go/ent/plan"
	"delivrio.io/go/ent/planhistory"
	"delivrio.io/go/ent/printer"
	"delivrio.io/go/ent/printjob"
	"delivrio.io/go/ent/product"
	"delivrio.io/go/ent/productimage"
	"delivrio.io/go/ent/producttag"
	"delivrio.io/go/ent/productvariant"
	"delivrio.io/go/ent/returncolli"
	"delivrio.io/go/ent/returncollihistory"
	"delivrio.io/go/ent/returnorderline"
	"delivrio.io/go/ent/returnportal"
	"delivrio.io/go/ent/returnportalclaim"
	"delivrio.io/go/ent/seatgroup"
	"delivrio.io/go/ent/seatgroupaccessright"
	"delivrio.io/go/ent/shipment"
	"delivrio.io/go/ent/shipmentbring"
	"delivrio.io/go/ent/shipmentdao"
	"delivrio.io/go/ent/shipmentdf"
	"delivrio.io/go/ent/shipmentdsv"
	"delivrio.io/go/ent/shipmenteasypost"
	"delivrio.io/go/ent/shipmentgls"
	"delivrio.io/go/ent/shipmenthistory"
	"delivrio.io/go/ent/shipmentpallet"
	"delivrio.io/go/ent/shipmentparcel"
	"delivrio.io/go/ent/shipmentpostnord"
	"delivrio.io/go/ent/shipmentusps"
	"delivrio.io/go/ent/signupoptions"
	"delivrio.io/go/ent/systemevents"
	"delivrio.io/go/ent/tenant"
	"delivrio.io/go/ent/user"
	"delivrio.io/go/ent/userseat"
	"delivrio.io/go/ent/workspacerecentscan"
	"delivrio.io/go/ent/workstation"
	"entgo.io/contrib/entgql"
	"github.com/99designs/gqlgen/graphql"
)

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (at *APITokenQuery) CollectFields(ctx context.Context, satisfies ...string) (*APITokenQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return at, nil
	}
	if err := at.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return at, nil
}

func (at *APITokenQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(apitoken.Columns))
		selectedFields = []string{apitoken.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			at.withTenant = query
			if _, ok := fieldSeen[apitoken.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldTenantID)
				fieldSeen[apitoken.FieldTenantID] = struct{}{}
			}

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: at.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			at.withUser = query
		case "tenantID":
			if _, ok := fieldSeen[apitoken.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldTenantID)
				fieldSeen[apitoken.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[apitoken.FieldName]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldName)
				fieldSeen[apitoken.FieldName] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[apitoken.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldCreatedAt)
				fieldSeen[apitoken.FieldCreatedAt] = struct{}{}
			}
		case "lastUsed":
			if _, ok := fieldSeen[apitoken.FieldLastUsed]; !ok {
				selectedFields = append(selectedFields, apitoken.FieldLastUsed)
				fieldSeen[apitoken.FieldLastUsed] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		at.Select(selectedFields...)
	}
	return nil
}

type apitokenPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []APITokenPaginateOption
}

func newAPITokenPaginateArgs(rv map[string]any) *apitokenPaginateArgs {
	args := &apitokenPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*APITokenWhereInput); ok {
		args.opts = append(args.opts, WithAPITokenFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ar *AccessRightQuery) CollectFields(ctx context.Context, satisfies ...string) (*AccessRightQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ar, nil
	}
	if err := ar.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ar, nil
}

func (ar *AccessRightQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(accessright.Columns))
		selectedFields = []string{accessright.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "assignedAccessRight":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SeatGroupClient{config: ar.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, seatgroupImplementors)...); err != nil {
				return err
			}
			ar.WithNamedAssignedAccessRight(alias, func(wq *SeatGroupQuery) {
				*wq = *query
			})

		case "seatGroupAccessRight":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SeatGroupAccessRightClient{config: ar.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, seatgroupaccessrightImplementors)...); err != nil {
				return err
			}
			ar.WithNamedSeatGroupAccessRight(alias, func(wq *SeatGroupAccessRightQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[accessright.FieldLabel]; !ok {
				selectedFields = append(selectedFields, accessright.FieldLabel)
				fieldSeen[accessright.FieldLabel] = struct{}{}
			}
		case "internalID":
			if _, ok := fieldSeen[accessright.FieldInternalID]; !ok {
				selectedFields = append(selectedFields, accessright.FieldInternalID)
				fieldSeen[accessright.FieldInternalID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ar.Select(selectedFields...)
	}
	return nil
}

type accessrightPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AccessRightPaginateOption
}

func newAccessRightPaginateArgs(rv map[string]any) *accessrightPaginateArgs {
	args := &accessrightPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*AccessRightWhereInput); ok {
		args.opts = append(args.opts, WithAccessRightFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (a *AddressQuery) CollectFields(ctx context.Context, satisfies ...string) (*AddressQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return a, nil
	}
	if err := a.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return a, nil
}

func (a *AddressQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(address.Columns))
		selectedFields = []string{address.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			a.withTenant = query
			if _, ok := fieldSeen[address.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, address.FieldTenantID)
				fieldSeen[address.FieldTenantID] = struct{}{}
			}

		case "recipientColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			a.WithNamedRecipientColli(alias, func(wq *ColliQuery) {
				*wq = *query
			})

		case "recipientConsolidation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConsolidationClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, consolidationImplementors)...); err != nil {
				return err
			}
			a.withRecipientConsolidation = query

		case "companyAddress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			a.WithNamedCompanyAddress(alias, func(wq *TenantQuery) {
				*wq = *query
			})

		case "location":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			a.WithNamedLocation(alias, func(wq *LocationQuery) {
				*wq = *query
			})

		case "senderColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			a.WithNamedSenderColli(alias, func(wq *ColliQuery) {
				*wq = *query
			})

		case "senderConsolidation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConsolidationClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, consolidationImplementors)...); err != nil {
				return err
			}
			a.withSenderConsolidation = query

		case "returnSenderColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnColliClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returncolliImplementors)...); err != nil {
				return err
			}
			a.WithNamedReturnSenderColli(alias, func(wq *ReturnColliQuery) {
				*wq = *query
			})

		case "returnRecipientColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnColliClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returncolliImplementors)...); err != nil {
				return err
			}
			a.WithNamedReturnRecipientColli(alias, func(wq *ReturnColliQuery) {
				*wq = *query
			})

		case "country":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: a.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			a.withCountry = query
		case "tenantID":
			if _, ok := fieldSeen[address.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, address.FieldTenantID)
				fieldSeen[address.FieldTenantID] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[address.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, address.FieldFirstName)
				fieldSeen[address.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[address.FieldLastName]; !ok {
				selectedFields = append(selectedFields, address.FieldLastName)
				fieldSeen[address.FieldLastName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[address.FieldEmail]; !ok {
				selectedFields = append(selectedFields, address.FieldEmail)
				fieldSeen[address.FieldEmail] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[address.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, address.FieldPhoneNumber)
				fieldSeen[address.FieldPhoneNumber] = struct{}{}
			}
		case "phoneNumber2":
			if _, ok := fieldSeen[address.FieldPhoneNumber2]; !ok {
				selectedFields = append(selectedFields, address.FieldPhoneNumber2)
				fieldSeen[address.FieldPhoneNumber2] = struct{}{}
			}
		case "vatNumber":
			if _, ok := fieldSeen[address.FieldVatNumber]; !ok {
				selectedFields = append(selectedFields, address.FieldVatNumber)
				fieldSeen[address.FieldVatNumber] = struct{}{}
			}
		case "company":
			if _, ok := fieldSeen[address.FieldCompany]; !ok {
				selectedFields = append(selectedFields, address.FieldCompany)
				fieldSeen[address.FieldCompany] = struct{}{}
			}
		case "addressOne":
			if _, ok := fieldSeen[address.FieldAddressOne]; !ok {
				selectedFields = append(selectedFields, address.FieldAddressOne)
				fieldSeen[address.FieldAddressOne] = struct{}{}
			}
		case "addressTwo":
			if _, ok := fieldSeen[address.FieldAddressTwo]; !ok {
				selectedFields = append(selectedFields, address.FieldAddressTwo)
				fieldSeen[address.FieldAddressTwo] = struct{}{}
			}
		case "city":
			if _, ok := fieldSeen[address.FieldCity]; !ok {
				selectedFields = append(selectedFields, address.FieldCity)
				fieldSeen[address.FieldCity] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[address.FieldState]; !ok {
				selectedFields = append(selectedFields, address.FieldState)
				fieldSeen[address.FieldState] = struct{}{}
			}
		case "zip":
			if _, ok := fieldSeen[address.FieldZip]; !ok {
				selectedFields = append(selectedFields, address.FieldZip)
				fieldSeen[address.FieldZip] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		a.Select(selectedFields...)
	}
	return nil
}

type addressPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AddressPaginateOption
}

func newAddressPaginateArgs(rv map[string]any) *addressPaginateArgs {
	args := &addressPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*AddressWhereInput); ok {
		args.opts = append(args.opts, WithAddressFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ag *AddressGlobalQuery) CollectFields(ctx context.Context, satisfies ...string) (*AddressGlobalQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ag, nil
	}
	if err := ag.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ag, nil
}

func (ag *AddressGlobalQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(addressglobal.Columns))
		selectedFields = []string{addressglobal.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "parcelShopPostNordDelivery":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopPostNordClient{config: ag.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshoppostnordImplementors)...); err != nil {
				return err
			}
			ag.withParcelShopPostNordDelivery = query

		case "parcelShopBringDelivery":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopBringClient{config: ag.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopbringImplementors)...); err != nil {
				return err
			}
			ag.withParcelShopBringDelivery = query

		case "parcelShop":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopClient{config: ag.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopImplementors)...); err != nil {
				return err
			}
			ag.withParcelShop = query

		case "country":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: ag.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			ag.withCountry = query
		case "company":
			if _, ok := fieldSeen[addressglobal.FieldCompany]; !ok {
				selectedFields = append(selectedFields, addressglobal.FieldCompany)
				fieldSeen[addressglobal.FieldCompany] = struct{}{}
			}
		case "addressOne":
			if _, ok := fieldSeen[addressglobal.FieldAddressOne]; !ok {
				selectedFields = append(selectedFields, addressglobal.FieldAddressOne)
				fieldSeen[addressglobal.FieldAddressOne] = struct{}{}
			}
		case "addressTwo":
			if _, ok := fieldSeen[addressglobal.FieldAddressTwo]; !ok {
				selectedFields = append(selectedFields, addressglobal.FieldAddressTwo)
				fieldSeen[addressglobal.FieldAddressTwo] = struct{}{}
			}
		case "city":
			if _, ok := fieldSeen[addressglobal.FieldCity]; !ok {
				selectedFields = append(selectedFields, addressglobal.FieldCity)
				fieldSeen[addressglobal.FieldCity] = struct{}{}
			}
		case "state":
			if _, ok := fieldSeen[addressglobal.FieldState]; !ok {
				selectedFields = append(selectedFields, addressglobal.FieldState)
				fieldSeen[addressglobal.FieldState] = struct{}{}
			}
		case "zip":
			if _, ok := fieldSeen[addressglobal.FieldZip]; !ok {
				selectedFields = append(selectedFields, addressglobal.FieldZip)
				fieldSeen[addressglobal.FieldZip] = struct{}{}
			}
		case "latitude":
			if _, ok := fieldSeen[addressglobal.FieldLatitude]; !ok {
				selectedFields = append(selectedFields, addressglobal.FieldLatitude)
				fieldSeen[addressglobal.FieldLatitude] = struct{}{}
			}
		case "longitude":
			if _, ok := fieldSeen[addressglobal.FieldLongitude]; !ok {
				selectedFields = append(selectedFields, addressglobal.FieldLongitude)
				fieldSeen[addressglobal.FieldLongitude] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ag.Select(selectedFields...)
	}
	return nil
}

type addressglobalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []AddressGlobalPaginateOption
}

func newAddressGlobalPaginateArgs(rv map[string]any) *addressglobalPaginateArgs {
	args := &addressglobalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*AddressGlobalWhereInput); ok {
		args.opts = append(args.opts, WithAddressGlobalFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (bhp *BusinessHoursPeriodQuery) CollectFields(ctx context.Context, satisfies ...string) (*BusinessHoursPeriodQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return bhp, nil
	}
	if err := bhp.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return bhp, nil
}

func (bhp *BusinessHoursPeriodQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(businesshoursperiod.Columns))
		selectedFields = []string{businesshoursperiod.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "parcelShop":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopClient{config: bhp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopImplementors)...); err != nil {
				return err
			}
			bhp.withParcelShop = query
		case "dayOfWeek":
			if _, ok := fieldSeen[businesshoursperiod.FieldDayOfWeek]; !ok {
				selectedFields = append(selectedFields, businesshoursperiod.FieldDayOfWeek)
				fieldSeen[businesshoursperiod.FieldDayOfWeek] = struct{}{}
			}
		case "opening":
			if _, ok := fieldSeen[businesshoursperiod.FieldOpening]; !ok {
				selectedFields = append(selectedFields, businesshoursperiod.FieldOpening)
				fieldSeen[businesshoursperiod.FieldOpening] = struct{}{}
			}
		case "closing":
			if _, ok := fieldSeen[businesshoursperiod.FieldClosing]; !ok {
				selectedFields = append(selectedFields, businesshoursperiod.FieldClosing)
				fieldSeen[businesshoursperiod.FieldClosing] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		bhp.Select(selectedFields...)
	}
	return nil
}

type businesshoursperiodPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []BusinessHoursPeriodPaginateOption
}

func newBusinessHoursPeriodPaginateArgs(rv map[string]any) *businesshoursperiodPaginateArgs {
	args := &businesshoursperiodPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*BusinessHoursPeriodWhereInput); ok {
		args.opts = append(args.opts, WithBusinessHoursPeriodFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CarrierQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CarrierQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrier.Columns))
		selectedFields = []string{carrier.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			c.withTenant = query
			if _, ok := fieldSeen[carrier.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrier.FieldTenantID)
				fieldSeen[carrier.FieldTenantID] = struct{}{}
			}

		case "carrierBrand":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierBrandClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierbrandImplementors)...); err != nil {
				return err
			}
			c.withCarrierBrand = query

		case "carrierDAO":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierDAOClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierdaoImplementors)...); err != nil {
				return err
			}
			c.withCarrierDAO = query

		case "carrierDF":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierDFClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierdfImplementors)...); err != nil {
				return err
			}
			c.withCarrierDF = query

		case "carrierDSV":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierDSVClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierdsvImplementors)...); err != nil {
				return err
			}
			c.withCarrierDSV = query

		case "carrierEasyPost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierEasyPostClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carriereasypostImplementors)...); err != nil {
				return err
			}
			c.withCarrierEasyPost = query

		case "carrierGLS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierGLSClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierglsImplementors)...); err != nil {
				return err
			}
			c.withCarrierGLS = query

		case "carrierPostNord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierPostNordClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierpostnordImplementors)...); err != nil {
				return err
			}
			c.withCarrierPostNord = query

		case "carrierUSPS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierUSPSClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrieruspsImplementors)...); err != nil {
				return err
			}
			c.withCarrierUSPS = query

		case "carrierBring":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierBringClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierbringImplementors)...); err != nil {
				return err
			}
			c.withCarrierBring = query

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			c.WithNamedDeliveryOption(alias, func(wq *DeliveryOptionQuery) {
				*wq = *query
			})

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			c.WithNamedShipment(alias, func(wq *ShipmentQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[carrier.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrier.FieldTenantID)
				fieldSeen[carrier.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[carrier.FieldName]; !ok {
				selectedFields = append(selectedFields, carrier.FieldName)
				fieldSeen[carrier.FieldName] = struct{}{}
			}
		case "syncCancelation":
			if _, ok := fieldSeen[carrier.FieldSyncCancelation]; !ok {
				selectedFields = append(selectedFields, carrier.FieldSyncCancelation)
				fieldSeen[carrier.FieldSyncCancelation] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type carrierPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierPaginateOption
}

func newCarrierPaginateArgs(rv map[string]any) *carrierPaginateArgs {
	args := &carrierPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierWhereInput); ok {
		args.opts = append(args.opts, WithCarrierFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (casb *CarrierAdditionalServiceBringQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierAdditionalServiceBringQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return casb, nil
	}
	if err := casb.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return casb, nil
}

func (casb *CarrierAdditionalServiceBringQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrieradditionalservicebring.Columns))
		selectedFields = []string{carrieradditionalservicebring.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierServiceBring":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceBringClient{config: casb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierservicebringImplementors)...); err != nil {
				return err
			}
			casb.withCarrierServiceBring = query

		case "deliveryOptionBring":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionBringClient{config: casb.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionbringImplementors)...); err != nil {
				return err
			}
			casb.WithNamedDeliveryOptionBring(alias, func(wq *DeliveryOptionBringQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrieradditionalservicebring.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicebring.FieldLabel)
				fieldSeen[carrieradditionalservicebring.FieldLabel] = struct{}{}
			}
		case "apiCodeBooking":
			if _, ok := fieldSeen[carrieradditionalservicebring.FieldAPICodeBooking]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicebring.FieldAPICodeBooking)
				fieldSeen[carrieradditionalservicebring.FieldAPICodeBooking] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		casb.Select(selectedFields...)
	}
	return nil
}

type carrieradditionalservicebringPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierAdditionalServiceBringPaginateOption
}

func newCarrierAdditionalServiceBringPaginateArgs(rv map[string]any) *carrieradditionalservicebringPaginateArgs {
	args := &carrieradditionalservicebringPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierAdditionalServiceBringWhereInput); ok {
		args.opts = append(args.opts, WithCarrierAdditionalServiceBringFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (casd *CarrierAdditionalServiceDAOQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierAdditionalServiceDAOQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return casd, nil
	}
	if err := casd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return casd, nil
}

func (casd *CarrierAdditionalServiceDAOQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrieradditionalservicedao.Columns))
		selectedFields = []string{carrieradditionalservicedao.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierServiceDAO":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceDAOClient{config: casd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrierservicedaoImplementors)...); err != nil {
				return err
			}
			casd.WithNamedCarrierServiceDAO(alias, func(wq *CarrierServiceDAOQuery) {
				*wq = *query
			})

		case "deliveryOptionDAO":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionDAOClient{config: casd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptiondaoImplementors)...); err != nil {
				return err
			}
			casd.WithNamedDeliveryOptionDAO(alias, func(wq *DeliveryOptionDAOQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrieradditionalservicedao.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicedao.FieldLabel)
				fieldSeen[carrieradditionalservicedao.FieldLabel] = struct{}{}
			}
		case "apiCode":
			if _, ok := fieldSeen[carrieradditionalservicedao.FieldAPICode]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicedao.FieldAPICode)
				fieldSeen[carrieradditionalservicedao.FieldAPICode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		casd.Select(selectedFields...)
	}
	return nil
}

type carrieradditionalservicedaoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierAdditionalServiceDAOPaginateOption
}

func newCarrierAdditionalServiceDAOPaginateArgs(rv map[string]any) *carrieradditionalservicedaoPaginateArgs {
	args := &carrieradditionalservicedaoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierAdditionalServiceDAOWhereInput); ok {
		args.opts = append(args.opts, WithCarrierAdditionalServiceDAOFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (casd *CarrierAdditionalServiceDFQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierAdditionalServiceDFQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return casd, nil
	}
	if err := casd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return casd, nil
}

func (casd *CarrierAdditionalServiceDFQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrieradditionalservicedf.Columns))
		selectedFields = []string{carrieradditionalservicedf.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierServiceDF":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceDFClient{config: casd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrierservicedfImplementors)...); err != nil {
				return err
			}
			casd.WithNamedCarrierServiceDF(alias, func(wq *CarrierServiceDFQuery) {
				*wq = *query
			})

		case "deliveryOptionDF":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionDFClient{config: casd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptiondfImplementors)...); err != nil {
				return err
			}
			casd.WithNamedDeliveryOptionDF(alias, func(wq *DeliveryOptionDFQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrieradditionalservicedf.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicedf.FieldLabel)
				fieldSeen[carrieradditionalservicedf.FieldLabel] = struct{}{}
			}
		case "apiCode":
			if _, ok := fieldSeen[carrieradditionalservicedf.FieldAPICode]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicedf.FieldAPICode)
				fieldSeen[carrieradditionalservicedf.FieldAPICode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		casd.Select(selectedFields...)
	}
	return nil
}

type carrieradditionalservicedfPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierAdditionalServiceDFPaginateOption
}

func newCarrierAdditionalServiceDFPaginateArgs(rv map[string]any) *carrieradditionalservicedfPaginateArgs {
	args := &carrieradditionalservicedfPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierAdditionalServiceDFWhereInput); ok {
		args.opts = append(args.opts, WithCarrierAdditionalServiceDFFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (casd *CarrierAdditionalServiceDSVQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierAdditionalServiceDSVQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return casd, nil
	}
	if err := casd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return casd, nil
}

func (casd *CarrierAdditionalServiceDSVQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrieradditionalservicedsv.Columns))
		selectedFields = []string{carrieradditionalservicedsv.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierServiceDSV":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceDSVClient{config: casd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrierservicedsvImplementors)...); err != nil {
				return err
			}
			casd.WithNamedCarrierServiceDSV(alias, func(wq *CarrierServiceDSVQuery) {
				*wq = *query
			})

		case "deliveryOptionDSV":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionDSVClient{config: casd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptiondsvImplementors)...); err != nil {
				return err
			}
			casd.WithNamedDeliveryOptionDSV(alias, func(wq *DeliveryOptionDSVQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrieradditionalservicedsv.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicedsv.FieldLabel)
				fieldSeen[carrieradditionalservicedsv.FieldLabel] = struct{}{}
			}
		case "apiCode":
			if _, ok := fieldSeen[carrieradditionalservicedsv.FieldAPICode]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicedsv.FieldAPICode)
				fieldSeen[carrieradditionalservicedsv.FieldAPICode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		casd.Select(selectedFields...)
	}
	return nil
}

type carrieradditionalservicedsvPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierAdditionalServiceDSVPaginateOption
}

func newCarrierAdditionalServiceDSVPaginateArgs(rv map[string]any) *carrieradditionalservicedsvPaginateArgs {
	args := &carrieradditionalservicedsvPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierAdditionalServiceDSVWhereInput); ok {
		args.opts = append(args.opts, WithCarrierAdditionalServiceDSVFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (casep *CarrierAdditionalServiceEasyPostQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierAdditionalServiceEasyPostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return casep, nil
	}
	if err := casep.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return casep, nil
}

func (casep *CarrierAdditionalServiceEasyPostQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrieradditionalserviceeasypost.Columns))
		selectedFields = []string{carrieradditionalserviceeasypost.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierServiceEasyPost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceEasyPostClient{config: casep.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrierserviceeasypostImplementors)...); err != nil {
				return err
			}
			casep.WithNamedCarrierServiceEasyPost(alias, func(wq *CarrierServiceEasyPostQuery) {
				*wq = *query
			})

		case "deliveryOptionEasyPost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionEasyPostClient{config: casep.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptioneasypostImplementors)...); err != nil {
				return err
			}
			casep.WithNamedDeliveryOptionEasyPost(alias, func(wq *DeliveryOptionEasyPostQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrieradditionalserviceeasypost.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrieradditionalserviceeasypost.FieldLabel)
				fieldSeen[carrieradditionalserviceeasypost.FieldLabel] = struct{}{}
			}
		case "apiKey":
			if _, ok := fieldSeen[carrieradditionalserviceeasypost.FieldAPIKey]; !ok {
				selectedFields = append(selectedFields, carrieradditionalserviceeasypost.FieldAPIKey)
				fieldSeen[carrieradditionalserviceeasypost.FieldAPIKey] = struct{}{}
			}
		case "apiValue":
			if _, ok := fieldSeen[carrieradditionalserviceeasypost.FieldAPIValue]; !ok {
				selectedFields = append(selectedFields, carrieradditionalserviceeasypost.FieldAPIValue)
				fieldSeen[carrieradditionalserviceeasypost.FieldAPIValue] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		casep.Select(selectedFields...)
	}
	return nil
}

type carrieradditionalserviceeasypostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierAdditionalServiceEasyPostPaginateOption
}

func newCarrierAdditionalServiceEasyPostPaginateArgs(rv map[string]any) *carrieradditionalserviceeasypostPaginateArgs {
	args := &carrieradditionalserviceeasypostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierAdditionalServiceEasyPostWhereInput); ok {
		args.opts = append(args.opts, WithCarrierAdditionalServiceEasyPostFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (casg *CarrierAdditionalServiceGLSQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierAdditionalServiceGLSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return casg, nil
	}
	if err := casg.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return casg, nil
}

func (casg *CarrierAdditionalServiceGLSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrieradditionalservicegls.Columns))
		selectedFields = []string{carrieradditionalservicegls.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierServiceGLS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceGLSClient{config: casg.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceglsImplementors)...); err != nil {
				return err
			}
			casg.withCarrierServiceGLS = query

		case "deliveryOptionGLS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionGLSClient{config: casg.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionglsImplementors)...); err != nil {
				return err
			}
			casg.WithNamedDeliveryOptionGLS(alias, func(wq *DeliveryOptionGLSQuery) {
				*wq = *query
			})

		case "countriesConsignee":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: casg.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			casg.WithNamedCountriesConsignee(alias, func(wq *CountryQuery) {
				*wq = *query
			})

		case "countriesConsignor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: casg.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			casg.WithNamedCountriesConsignor(alias, func(wq *CountryQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrieradditionalservicegls.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicegls.FieldLabel)
				fieldSeen[carrieradditionalservicegls.FieldLabel] = struct{}{}
			}
		case "mandatory":
			if _, ok := fieldSeen[carrieradditionalservicegls.FieldMandatory]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicegls.FieldMandatory)
				fieldSeen[carrieradditionalservicegls.FieldMandatory] = struct{}{}
			}
		case "allCountriesConsignor":
			if _, ok := fieldSeen[carrieradditionalservicegls.FieldAllCountriesConsignor]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicegls.FieldAllCountriesConsignor)
				fieldSeen[carrieradditionalservicegls.FieldAllCountriesConsignor] = struct{}{}
			}
		case "allCountriesConsignee":
			if _, ok := fieldSeen[carrieradditionalservicegls.FieldAllCountriesConsignee]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicegls.FieldAllCountriesConsignee)
				fieldSeen[carrieradditionalservicegls.FieldAllCountriesConsignee] = struct{}{}
			}
		case "internalID":
			if _, ok := fieldSeen[carrieradditionalservicegls.FieldInternalID]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicegls.FieldInternalID)
				fieldSeen[carrieradditionalservicegls.FieldInternalID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		casg.Select(selectedFields...)
	}
	return nil
}

type carrieradditionalserviceglsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierAdditionalServiceGLSPaginateOption
}

func newCarrierAdditionalServiceGLSPaginateArgs(rv map[string]any) *carrieradditionalserviceglsPaginateArgs {
	args := &carrieradditionalserviceglsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierAdditionalServiceGLSWhereInput); ok {
		args.opts = append(args.opts, WithCarrierAdditionalServiceGLSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (caspn *CarrierAdditionalServicePostNordQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierAdditionalServicePostNordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return caspn, nil
	}
	if err := caspn.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return caspn, nil
}

func (caspn *CarrierAdditionalServicePostNordQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrieradditionalservicepostnord.Columns))
		selectedFields = []string{carrieradditionalservicepostnord.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierServicePostNord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServicePostNordClient{config: caspn.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierservicepostnordImplementors)...); err != nil {
				return err
			}
			caspn.withCarrierServicePostNord = query

		case "deliveryOptionPostNord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionPostNordClient{config: caspn.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionpostnordImplementors)...); err != nil {
				return err
			}
			caspn.WithNamedDeliveryOptionPostNord(alias, func(wq *DeliveryOptionPostNordQuery) {
				*wq = *query
			})

		case "countriesConsignee":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: caspn.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			caspn.WithNamedCountriesConsignee(alias, func(wq *CountryQuery) {
				*wq = *query
			})

		case "countriesConsignor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: caspn.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			caspn.WithNamedCountriesConsignor(alias, func(wq *CountryQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrieradditionalservicepostnord.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicepostnord.FieldLabel)
				fieldSeen[carrieradditionalservicepostnord.FieldLabel] = struct{}{}
			}
		case "mandatory":
			if _, ok := fieldSeen[carrieradditionalservicepostnord.FieldMandatory]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicepostnord.FieldMandatory)
				fieldSeen[carrieradditionalservicepostnord.FieldMandatory] = struct{}{}
			}
		case "allCountriesConsignor":
			if _, ok := fieldSeen[carrieradditionalservicepostnord.FieldAllCountriesConsignor]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicepostnord.FieldAllCountriesConsignor)
				fieldSeen[carrieradditionalservicepostnord.FieldAllCountriesConsignor] = struct{}{}
			}
		case "allCountriesConsignee":
			if _, ok := fieldSeen[carrieradditionalservicepostnord.FieldAllCountriesConsignee]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicepostnord.FieldAllCountriesConsignee)
				fieldSeen[carrieradditionalservicepostnord.FieldAllCountriesConsignee] = struct{}{}
			}
		case "internalID":
			if _, ok := fieldSeen[carrieradditionalservicepostnord.FieldInternalID]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicepostnord.FieldInternalID)
				fieldSeen[carrieradditionalservicepostnord.FieldInternalID] = struct{}{}
			}
		case "apiCode":
			if _, ok := fieldSeen[carrieradditionalservicepostnord.FieldAPICode]; !ok {
				selectedFields = append(selectedFields, carrieradditionalservicepostnord.FieldAPICode)
				fieldSeen[carrieradditionalservicepostnord.FieldAPICode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		caspn.Select(selectedFields...)
	}
	return nil
}

type carrieradditionalservicepostnordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierAdditionalServicePostNordPaginateOption
}

func newCarrierAdditionalServicePostNordPaginateArgs(rv map[string]any) *carrieradditionalservicepostnordPaginateArgs {
	args := &carrieradditionalservicepostnordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierAdditionalServicePostNordWhereInput); ok {
		args.opts = append(args.opts, WithCarrierAdditionalServicePostNordFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (casu *CarrierAdditionalServiceUSPSQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierAdditionalServiceUSPSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return casu, nil
	}
	if err := casu.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return casu, nil
}

func (casu *CarrierAdditionalServiceUSPSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrieradditionalserviceusps.Columns))
		selectedFields = []string{carrieradditionalserviceusps.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierServiceUSPS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceUSPSClient{config: casu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceuspsImplementors)...); err != nil {
				return err
			}
			casu.withCarrierServiceUSPS = query

		case "deliveryOptionUSPS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionUSPSClient{config: casu.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionuspsImplementors)...); err != nil {
				return err
			}
			casu.WithNamedDeliveryOptionUSPS(alias, func(wq *DeliveryOptionUSPSQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrieradditionalserviceusps.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrieradditionalserviceusps.FieldLabel)
				fieldSeen[carrieradditionalserviceusps.FieldLabel] = struct{}{}
			}
		case "commonlyUsed":
			if _, ok := fieldSeen[carrieradditionalserviceusps.FieldCommonlyUsed]; !ok {
				selectedFields = append(selectedFields, carrieradditionalserviceusps.FieldCommonlyUsed)
				fieldSeen[carrieradditionalserviceusps.FieldCommonlyUsed] = struct{}{}
			}
		case "internalID":
			if _, ok := fieldSeen[carrieradditionalserviceusps.FieldInternalID]; !ok {
				selectedFields = append(selectedFields, carrieradditionalserviceusps.FieldInternalID)
				fieldSeen[carrieradditionalserviceusps.FieldInternalID] = struct{}{}
			}
		case "apiCode":
			if _, ok := fieldSeen[carrieradditionalserviceusps.FieldAPICode]; !ok {
				selectedFields = append(selectedFields, carrieradditionalserviceusps.FieldAPICode)
				fieldSeen[carrieradditionalserviceusps.FieldAPICode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		casu.Select(selectedFields...)
	}
	return nil
}

type carrieradditionalserviceuspsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierAdditionalServiceUSPSPaginateOption
}

func newCarrierAdditionalServiceUSPSPaginateArgs(rv map[string]any) *carrieradditionalserviceuspsPaginateArgs {
	args := &carrieradditionalserviceuspsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierAdditionalServiceUSPSWhereInput); ok {
		args.opts = append(args.opts, WithCarrierAdditionalServiceUSPSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cb *CarrierBrandQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierBrandQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cb, nil
	}
	if err := cb.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cb, nil
}

func (cb *CarrierBrandQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierbrand.Columns))
		selectedFields = []string{carrierbrand.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierService":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceClient{config: cb.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrierserviceImplementors)...); err != nil {
				return err
			}
			cb.WithNamedCarrierService(alias, func(wq *CarrierServiceQuery) {
				*wq = *query
			})

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: cb.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			cb.WithNamedCarrier(alias, func(wq *CarrierQuery) {
				*wq = *query
			})

		case "parcelShop":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopClient{config: cb.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, parcelshopImplementors)...); err != nil {
				return err
			}
			cb.WithNamedParcelShop(alias, func(wq *ParcelShopQuery) {
				*wq = *query
			})

		case "packaging":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingClient{config: cb.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, packagingImplementors)...); err != nil {
				return err
			}
			cb.WithNamedPackaging(alias, func(wq *PackagingQuery) {
				*wq = *query
			})

		case "document":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: cb.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentImplementors)...); err != nil {
				return err
			}
			cb.WithNamedDocument(alias, func(wq *DocumentQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrierbrand.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrierbrand.FieldLabel)
				fieldSeen[carrierbrand.FieldLabel] = struct{}{}
			}
		case "labelShort":
			if _, ok := fieldSeen[carrierbrand.FieldLabelShort]; !ok {
				selectedFields = append(selectedFields, carrierbrand.FieldLabelShort)
				fieldSeen[carrierbrand.FieldLabelShort] = struct{}{}
			}
		case "internalID":
			if _, ok := fieldSeen[carrierbrand.FieldInternalID]; !ok {
				selectedFields = append(selectedFields, carrierbrand.FieldInternalID)
				fieldSeen[carrierbrand.FieldInternalID] = struct{}{}
			}
		case "logoURL":
			if _, ok := fieldSeen[carrierbrand.FieldLogoURL]; !ok {
				selectedFields = append(selectedFields, carrierbrand.FieldLogoURL)
				fieldSeen[carrierbrand.FieldLogoURL] = struct{}{}
			}
		case "textColor":
			if _, ok := fieldSeen[carrierbrand.FieldTextColor]; !ok {
				selectedFields = append(selectedFields, carrierbrand.FieldTextColor)
				fieldSeen[carrierbrand.FieldTextColor] = struct{}{}
			}
		case "backgroundColor":
			if _, ok := fieldSeen[carrierbrand.FieldBackgroundColor]; !ok {
				selectedFields = append(selectedFields, carrierbrand.FieldBackgroundColor)
				fieldSeen[carrierbrand.FieldBackgroundColor] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cb.Select(selectedFields...)
	}
	return nil
}

type carrierbrandPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierBrandPaginateOption
}

func newCarrierBrandPaginateArgs(rv map[string]any) *carrierbrandPaginateArgs {
	args := &carrierbrandPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierBrandWhereInput); ok {
		args.opts = append(args.opts, WithCarrierBrandFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cb *CarrierBringQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierBringQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cb, nil
	}
	if err := cb.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cb, nil
}

func (cb *CarrierBringQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierbring.Columns))
		selectedFields = []string{carrierbring.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cb.withTenant = query
			if _, ok := fieldSeen[carrierbring.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierbring.FieldTenantID)
				fieldSeen[carrierbring.FieldTenantID] = struct{}{}
			}

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: cb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			cb.withCarrier = query
		case "tenantID":
			if _, ok := fieldSeen[carrierbring.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierbring.FieldTenantID)
				fieldSeen[carrierbring.FieldTenantID] = struct{}{}
			}
		case "apiKey":
			if _, ok := fieldSeen[carrierbring.FieldAPIKey]; !ok {
				selectedFields = append(selectedFields, carrierbring.FieldAPIKey)
				fieldSeen[carrierbring.FieldAPIKey] = struct{}{}
			}
		case "customerNumber":
			if _, ok := fieldSeen[carrierbring.FieldCustomerNumber]; !ok {
				selectedFields = append(selectedFields, carrierbring.FieldCustomerNumber)
				fieldSeen[carrierbring.FieldCustomerNumber] = struct{}{}
			}
		case "test":
			if _, ok := fieldSeen[carrierbring.FieldTest]; !ok {
				selectedFields = append(selectedFields, carrierbring.FieldTest)
				fieldSeen[carrierbring.FieldTest] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cb.Select(selectedFields...)
	}
	return nil
}

type carrierbringPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierBringPaginateOption
}

func newCarrierBringPaginateArgs(rv map[string]any) *carrierbringPaginateArgs {
	args := &carrierbringPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierBringWhereInput); ok {
		args.opts = append(args.opts, WithCarrierBringFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cd *CarrierDAOQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierDAOQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cd, nil
	}
	if err := cd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cd, nil
}

func (cd *CarrierDAOQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierdao.Columns))
		selectedFields = []string{carrierdao.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cd.withTenant = query
			if _, ok := fieldSeen[carrierdao.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierdao.FieldTenantID)
				fieldSeen[carrierdao.FieldTenantID] = struct{}{}
			}

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			cd.withCarrier = query
		case "tenantID":
			if _, ok := fieldSeen[carrierdao.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierdao.FieldTenantID)
				fieldSeen[carrierdao.FieldTenantID] = struct{}{}
			}
		case "customerID":
			if _, ok := fieldSeen[carrierdao.FieldCustomerID]; !ok {
				selectedFields = append(selectedFields, carrierdao.FieldCustomerID)
				fieldSeen[carrierdao.FieldCustomerID] = struct{}{}
			}
		case "apiKey":
			if _, ok := fieldSeen[carrierdao.FieldAPIKey]; !ok {
				selectedFields = append(selectedFields, carrierdao.FieldAPIKey)
				fieldSeen[carrierdao.FieldAPIKey] = struct{}{}
			}
		case "test":
			if _, ok := fieldSeen[carrierdao.FieldTest]; !ok {
				selectedFields = append(selectedFields, carrierdao.FieldTest)
				fieldSeen[carrierdao.FieldTest] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cd.Select(selectedFields...)
	}
	return nil
}

type carrierdaoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierDAOPaginateOption
}

func newCarrierDAOPaginateArgs(rv map[string]any) *carrierdaoPaginateArgs {
	args := &carrierdaoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierDAOWhereInput); ok {
		args.opts = append(args.opts, WithCarrierDAOFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cd *CarrierDFQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierDFQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cd, nil
	}
	if err := cd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cd, nil
}

func (cd *CarrierDFQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierdf.Columns))
		selectedFields = []string{carrierdf.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cd.withTenant = query
			if _, ok := fieldSeen[carrierdf.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierdf.FieldTenantID)
				fieldSeen[carrierdf.FieldTenantID] = struct{}{}
			}

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			cd.withCarrier = query
		case "tenantID":
			if _, ok := fieldSeen[carrierdf.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierdf.FieldTenantID)
				fieldSeen[carrierdf.FieldTenantID] = struct{}{}
			}
		case "customerID":
			if _, ok := fieldSeen[carrierdf.FieldCustomerID]; !ok {
				selectedFields = append(selectedFields, carrierdf.FieldCustomerID)
				fieldSeen[carrierdf.FieldCustomerID] = struct{}{}
			}
		case "agreementNumber":
			if _, ok := fieldSeen[carrierdf.FieldAgreementNumber]; !ok {
				selectedFields = append(selectedFields, carrierdf.FieldAgreementNumber)
				fieldSeen[carrierdf.FieldAgreementNumber] = struct{}{}
			}
		case "whoPays":
			if _, ok := fieldSeen[carrierdf.FieldWhoPays]; !ok {
				selectedFields = append(selectedFields, carrierdf.FieldWhoPays)
				fieldSeen[carrierdf.FieldWhoPays] = struct{}{}
			}
		case "test":
			if _, ok := fieldSeen[carrierdf.FieldTest]; !ok {
				selectedFields = append(selectedFields, carrierdf.FieldTest)
				fieldSeen[carrierdf.FieldTest] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cd.Select(selectedFields...)
	}
	return nil
}

type carrierdfPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierDFPaginateOption
}

func newCarrierDFPaginateArgs(rv map[string]any) *carrierdfPaginateArgs {
	args := &carrierdfPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierDFWhereInput); ok {
		args.opts = append(args.opts, WithCarrierDFFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cd *CarrierDSVQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierDSVQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cd, nil
	}
	if err := cd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cd, nil
}

func (cd *CarrierDSVQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierdsv.Columns))
		selectedFields = []string{carrierdsv.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cd.withTenant = query
			if _, ok := fieldSeen[carrierdsv.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierdsv.FieldTenantID)
				fieldSeen[carrierdsv.FieldTenantID] = struct{}{}
			}

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: cd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			cd.withCarrier = query
		case "tenantID":
			if _, ok := fieldSeen[carrierdsv.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierdsv.FieldTenantID)
				fieldSeen[carrierdsv.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cd.Select(selectedFields...)
	}
	return nil
}

type carrierdsvPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierDSVPaginateOption
}

func newCarrierDSVPaginateArgs(rv map[string]any) *carrierdsvPaginateArgs {
	args := &carrierdsvPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierDSVWhereInput); ok {
		args.opts = append(args.opts, WithCarrierDSVFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cep *CarrierEasyPostQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierEasyPostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cep, nil
	}
	if err := cep.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cep, nil
}

func (cep *CarrierEasyPostQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carriereasypost.Columns))
		selectedFields = []string{carriereasypost.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cep.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cep.withTenant = query
			if _, ok := fieldSeen[carriereasypost.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carriereasypost.FieldTenantID)
				fieldSeen[carriereasypost.FieldTenantID] = struct{}{}
			}

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: cep.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			cep.withCarrier = query
		case "tenantID":
			if _, ok := fieldSeen[carriereasypost.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carriereasypost.FieldTenantID)
				fieldSeen[carriereasypost.FieldTenantID] = struct{}{}
			}
		case "apiKey":
			if _, ok := fieldSeen[carriereasypost.FieldAPIKey]; !ok {
				selectedFields = append(selectedFields, carriereasypost.FieldAPIKey)
				fieldSeen[carriereasypost.FieldAPIKey] = struct{}{}
			}
		case "test":
			if _, ok := fieldSeen[carriereasypost.FieldTest]; !ok {
				selectedFields = append(selectedFields, carriereasypost.FieldTest)
				fieldSeen[carriereasypost.FieldTest] = struct{}{}
			}
		case "carrierAccounts":
			if _, ok := fieldSeen[carriereasypost.FieldCarrierAccounts]; !ok {
				selectedFields = append(selectedFields, carriereasypost.FieldCarrierAccounts)
				fieldSeen[carriereasypost.FieldCarrierAccounts] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cep.Select(selectedFields...)
	}
	return nil
}

type carriereasypostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierEasyPostPaginateOption
}

func newCarrierEasyPostPaginateArgs(rv map[string]any) *carriereasypostPaginateArgs {
	args := &carriereasypostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierEasyPostWhereInput); ok {
		args.opts = append(args.opts, WithCarrierEasyPostFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cg *CarrierGLSQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierGLSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cg, nil
	}
	if err := cg.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cg, nil
}

func (cg *CarrierGLSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carriergls.Columns))
		selectedFields = []string{carriergls.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cg.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cg.withTenant = query
			if _, ok := fieldSeen[carriergls.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carriergls.FieldTenantID)
				fieldSeen[carriergls.FieldTenantID] = struct{}{}
			}

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: cg.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			cg.withCarrier = query
		case "tenantID":
			if _, ok := fieldSeen[carriergls.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carriergls.FieldTenantID)
				fieldSeen[carriergls.FieldTenantID] = struct{}{}
			}
		case "contactID":
			if _, ok := fieldSeen[carriergls.FieldContactID]; !ok {
				selectedFields = append(selectedFields, carriergls.FieldContactID)
				fieldSeen[carriergls.FieldContactID] = struct{}{}
			}
		case "glsUsername":
			if _, ok := fieldSeen[carriergls.FieldGLSUsername]; !ok {
				selectedFields = append(selectedFields, carriergls.FieldGLSUsername)
				fieldSeen[carriergls.FieldGLSUsername] = struct{}{}
			}
		case "glsPassword":
			if _, ok := fieldSeen[carriergls.FieldGLSPassword]; !ok {
				selectedFields = append(selectedFields, carriergls.FieldGLSPassword)
				fieldSeen[carriergls.FieldGLSPassword] = struct{}{}
			}
		case "customerID":
			if _, ok := fieldSeen[carriergls.FieldCustomerID]; !ok {
				selectedFields = append(selectedFields, carriergls.FieldCustomerID)
				fieldSeen[carriergls.FieldCustomerID] = struct{}{}
			}
		case "glsCountryCode":
			if _, ok := fieldSeen[carriergls.FieldGLSCountryCode]; !ok {
				selectedFields = append(selectedFields, carriergls.FieldGLSCountryCode)
				fieldSeen[carriergls.FieldGLSCountryCode] = struct{}{}
			}
		case "syncShipmentCancellation":
			if _, ok := fieldSeen[carriergls.FieldSyncShipmentCancellation]; !ok {
				selectedFields = append(selectedFields, carriergls.FieldSyncShipmentCancellation)
				fieldSeen[carriergls.FieldSyncShipmentCancellation] = struct{}{}
			}
		case "printErrorOnLabel":
			if _, ok := fieldSeen[carriergls.FieldPrintErrorOnLabel]; !ok {
				selectedFields = append(selectedFields, carriergls.FieldPrintErrorOnLabel)
				fieldSeen[carriergls.FieldPrintErrorOnLabel] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cg.Select(selectedFields...)
	}
	return nil
}

type carrierglsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierGLSPaginateOption
}

func newCarrierGLSPaginateArgs(rv map[string]any) *carrierglsPaginateArgs {
	args := &carrierglsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierGLSWhereInput); ok {
		args.opts = append(args.opts, WithCarrierGLSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cpn *CarrierPostNordQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierPostNordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cpn, nil
	}
	if err := cpn.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cpn, nil
}

func (cpn *CarrierPostNordQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierpostnord.Columns))
		selectedFields = []string{carrierpostnord.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cpn.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cpn.withTenant = query
			if _, ok := fieldSeen[carrierpostnord.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierpostnord.FieldTenantID)
				fieldSeen[carrierpostnord.FieldTenantID] = struct{}{}
			}

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: cpn.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			cpn.withCarrier = query
		case "tenantID":
			if _, ok := fieldSeen[carrierpostnord.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierpostnord.FieldTenantID)
				fieldSeen[carrierpostnord.FieldTenantID] = struct{}{}
			}
		case "customerNumber":
			if _, ok := fieldSeen[carrierpostnord.FieldCustomerNumber]; !ok {
				selectedFields = append(selectedFields, carrierpostnord.FieldCustomerNumber)
				fieldSeen[carrierpostnord.FieldCustomerNumber] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cpn.Select(selectedFields...)
	}
	return nil
}

type carrierpostnordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierPostNordPaginateOption
}

func newCarrierPostNordPaginateArgs(rv map[string]any) *carrierpostnordPaginateArgs {
	args := &carrierpostnordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierPostNordWhereInput); ok {
		args.opts = append(args.opts, WithCarrierPostNordFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cs *CarrierServiceQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierServiceQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cs, nil
	}
	if err := cs.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cs, nil
}

func (cs *CarrierServiceQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierservice.Columns))
		selectedFields = []string{carrierservice.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierServicePostNord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServicePostNordClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierservicepostnordImplementors)...); err != nil {
				return err
			}
			cs.withCarrierServicePostNord = query

		case "carrierServiceDAO":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceDAOClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierservicedaoImplementors)...); err != nil {
				return err
			}
			cs.withCarrierServiceDAO = query

		case "carrierServiceDF":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceDFClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierservicedfImplementors)...); err != nil {
				return err
			}
			cs.withCarrierServiceDF = query

		case "carrierServiceDSV":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceDSVClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierservicedsvImplementors)...); err != nil {
				return err
			}
			cs.withCarrierServiceDSV = query

		case "carrierServEasyPost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceEasyPostClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceeasypostImplementors)...); err != nil {
				return err
			}
			cs.withCarrierServEasyPost = query

		case "carrierServiceGLS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceGLSClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceglsImplementors)...); err != nil {
				return err
			}
			cs.withCarrierServiceGLS = query

		case "carrierServiceUSPS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceUSPSClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceuspsImplementors)...); err != nil {
				return err
			}
			cs.withCarrierServiceUSPS = query

		case "carrierServiceBring":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceBringClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierservicebringImplementors)...); err != nil {
				return err
			}
			cs.withCarrierServiceBring = query

		case "carrierBrand":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierBrandClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierbrandImplementors)...); err != nil {
				return err
			}
			cs.withCarrierBrand = query

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			cs.WithNamedDeliveryOption(alias, func(wq *DeliveryOptionQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrierservice.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrierservice.FieldLabel)
				fieldSeen[carrierservice.FieldLabel] = struct{}{}
			}
		case "internalID":
			if _, ok := fieldSeen[carrierservice.FieldInternalID]; !ok {
				selectedFields = append(selectedFields, carrierservice.FieldInternalID)
				fieldSeen[carrierservice.FieldInternalID] = struct{}{}
			}
		case "return":
			if _, ok := fieldSeen[carrierservice.FieldReturn]; !ok {
				selectedFields = append(selectedFields, carrierservice.FieldReturn)
				fieldSeen[carrierservice.FieldReturn] = struct{}{}
			}
		case "consolidation":
			if _, ok := fieldSeen[carrierservice.FieldConsolidation]; !ok {
				selectedFields = append(selectedFields, carrierservice.FieldConsolidation)
				fieldSeen[carrierservice.FieldConsolidation] = struct{}{}
			}
		case "deliveryPointOptional":
			if _, ok := fieldSeen[carrierservice.FieldDeliveryPointOptional]; !ok {
				selectedFields = append(selectedFields, carrierservice.FieldDeliveryPointOptional)
				fieldSeen[carrierservice.FieldDeliveryPointOptional] = struct{}{}
			}
		case "deliveryPointRequired":
			if _, ok := fieldSeen[carrierservice.FieldDeliveryPointRequired]; !ok {
				selectedFields = append(selectedFields, carrierservice.FieldDeliveryPointRequired)
				fieldSeen[carrierservice.FieldDeliveryPointRequired] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cs.Select(selectedFields...)
	}
	return nil
}

type carrierservicePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierServicePaginateOption
}

func newCarrierServicePaginateArgs(rv map[string]any) *carrierservicePaginateArgs {
	args := &carrierservicePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierServiceWhereInput); ok {
		args.opts = append(args.opts, WithCarrierServiceFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (csb *CarrierServiceBringQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierServiceBringQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return csb, nil
	}
	if err := csb.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return csb, nil
}

func (csb *CarrierServiceBringQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierservicebring.Columns))
		selectedFields = []string{carrierservicebring.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierService":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceClient{config: csb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceImplementors)...); err != nil {
				return err
			}
			csb.withCarrierService = query

		case "carrierAdditionalServiceBring":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceBringClient{config: csb.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicebringImplementors)...); err != nil {
				return err
			}
			csb.WithNamedCarrierAdditionalServiceBring(alias, func(wq *CarrierAdditionalServiceBringQuery) {
				*wq = *query
			})
		case "apiServiceCode":
			if _, ok := fieldSeen[carrierservicebring.FieldAPIServiceCode]; !ok {
				selectedFields = append(selectedFields, carrierservicebring.FieldAPIServiceCode)
				fieldSeen[carrierservicebring.FieldAPIServiceCode] = struct{}{}
			}
		case "apiRequest":
			if _, ok := fieldSeen[carrierservicebring.FieldAPIRequest]; !ok {
				selectedFields = append(selectedFields, carrierservicebring.FieldAPIRequest)
				fieldSeen[carrierservicebring.FieldAPIRequest] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		csb.Select(selectedFields...)
	}
	return nil
}

type carrierservicebringPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierServiceBringPaginateOption
}

func newCarrierServiceBringPaginateArgs(rv map[string]any) *carrierservicebringPaginateArgs {
	args := &carrierservicebringPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierServiceBringWhereInput); ok {
		args.opts = append(args.opts, WithCarrierServiceBringFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (csd *CarrierServiceDAOQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierServiceDAOQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return csd, nil
	}
	if err := csd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return csd, nil
}

func (csd *CarrierServiceDAOQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierService":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceClient{config: csd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceImplementors)...); err != nil {
				return err
			}
			csd.withCarrierService = query

		case "carrierAdditionalServiceDAO":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceDAOClient{config: csd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicedaoImplementors)...); err != nil {
				return err
			}
			csd.WithNamedCarrierAdditionalServiceDAO(alias, func(wq *CarrierAdditionalServiceDAOQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type carrierservicedaoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierServiceDAOPaginateOption
}

func newCarrierServiceDAOPaginateArgs(rv map[string]any) *carrierservicedaoPaginateArgs {
	args := &carrierservicedaoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierServiceDAOWhereInput); ok {
		args.opts = append(args.opts, WithCarrierServiceDAOFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (csd *CarrierServiceDFQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierServiceDFQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return csd, nil
	}
	if err := csd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return csd, nil
}

func (csd *CarrierServiceDFQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierService":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceClient{config: csd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceImplementors)...); err != nil {
				return err
			}
			csd.withCarrierService = query

		case "carrierAdditionalServiceDF":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceDFClient{config: csd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicedfImplementors)...); err != nil {
				return err
			}
			csd.WithNamedCarrierAdditionalServiceDF(alias, func(wq *CarrierAdditionalServiceDFQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type carrierservicedfPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierServiceDFPaginateOption
}

func newCarrierServiceDFPaginateArgs(rv map[string]any) *carrierservicedfPaginateArgs {
	args := &carrierservicedfPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierServiceDFWhereInput); ok {
		args.opts = append(args.opts, WithCarrierServiceDFFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (csd *CarrierServiceDSVQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierServiceDSVQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return csd, nil
	}
	if err := csd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return csd, nil
}

func (csd *CarrierServiceDSVQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierService":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceClient{config: csd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceImplementors)...); err != nil {
				return err
			}
			csd.withCarrierService = query

		case "carrierAdditionalServiceDSV":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceDSVClient{config: csd.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicedsvImplementors)...); err != nil {
				return err
			}
			csd.WithNamedCarrierAdditionalServiceDSV(alias, func(wq *CarrierAdditionalServiceDSVQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type carrierservicedsvPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierServiceDSVPaginateOption
}

func newCarrierServiceDSVPaginateArgs(rv map[string]any) *carrierservicedsvPaginateArgs {
	args := &carrierservicedsvPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierServiceDSVWhereInput); ok {
		args.opts = append(args.opts, WithCarrierServiceDSVFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (csep *CarrierServiceEasyPostQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierServiceEasyPostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return csep, nil
	}
	if err := csep.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return csep, nil
}

func (csep *CarrierServiceEasyPostQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierService":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceClient{config: csep.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceImplementors)...); err != nil {
				return err
			}
			csep.withCarrierService = query

		case "carrierAddServEasyPost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceEasyPostClient{config: csep.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalserviceeasypostImplementors)...); err != nil {
				return err
			}
			csep.WithNamedCarrierAddServEasyPost(alias, func(wq *CarrierAdditionalServiceEasyPostQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type carrierserviceeasypostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierServiceEasyPostPaginateOption
}

func newCarrierServiceEasyPostPaginateArgs(rv map[string]any) *carrierserviceeasypostPaginateArgs {
	args := &carrierserviceeasypostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierServiceEasyPostWhereInput); ok {
		args.opts = append(args.opts, WithCarrierServiceEasyPostFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (csg *CarrierServiceGLSQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierServiceGLSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return csg, nil
	}
	if err := csg.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return csg, nil
}

func (csg *CarrierServiceGLSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierservicegls.Columns))
		selectedFields = []string{carrierservicegls.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierService":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceClient{config: csg.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceImplementors)...); err != nil {
				return err
			}
			csg.withCarrierService = query

		case "carrierAdditionalServiceGLS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceGLSClient{config: csg.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalserviceglsImplementors)...); err != nil {
				return err
			}
			csg.WithNamedCarrierAdditionalServiceGLS(alias, func(wq *CarrierAdditionalServiceGLSQuery) {
				*wq = *query
			})
		case "apiKey":
			if _, ok := fieldSeen[carrierservicegls.FieldAPIKey]; !ok {
				selectedFields = append(selectedFields, carrierservicegls.FieldAPIKey)
				fieldSeen[carrierservicegls.FieldAPIKey] = struct{}{}
			}
		case "apiValue":
			if _, ok := fieldSeen[carrierservicegls.FieldAPIValue]; !ok {
				selectedFields = append(selectedFields, carrierservicegls.FieldAPIValue)
				fieldSeen[carrierservicegls.FieldAPIValue] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		csg.Select(selectedFields...)
	}
	return nil
}

type carrierserviceglsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierServiceGLSPaginateOption
}

func newCarrierServiceGLSPaginateArgs(rv map[string]any) *carrierserviceglsPaginateArgs {
	args := &carrierserviceglsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierServiceGLSWhereInput); ok {
		args.opts = append(args.opts, WithCarrierServiceGLSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cspn *CarrierServicePostNordQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierServicePostNordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cspn, nil
	}
	if err := cspn.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cspn, nil
}

func (cspn *CarrierServicePostNordQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierservicepostnord.Columns))
		selectedFields = []string{carrierservicepostnord.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierService":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceClient{config: cspn.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceImplementors)...); err != nil {
				return err
			}
			cspn.withCarrierService = query

		case "carrierAddServPostNord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServicePostNordClient{config: cspn.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicepostnordImplementors)...); err != nil {
				return err
			}
			cspn.WithNamedCarrierAddServPostNord(alias, func(wq *CarrierAdditionalServicePostNordQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[carrierservicepostnord.FieldLabel]; !ok {
				selectedFields = append(selectedFields, carrierservicepostnord.FieldLabel)
				fieldSeen[carrierservicepostnord.FieldLabel] = struct{}{}
			}
		case "internalID":
			if _, ok := fieldSeen[carrierservicepostnord.FieldInternalID]; !ok {
				selectedFields = append(selectedFields, carrierservicepostnord.FieldInternalID)
				fieldSeen[carrierservicepostnord.FieldInternalID] = struct{}{}
			}
		case "apiCode":
			if _, ok := fieldSeen[carrierservicepostnord.FieldAPICode]; !ok {
				selectedFields = append(selectedFields, carrierservicepostnord.FieldAPICode)
				fieldSeen[carrierservicepostnord.FieldAPICode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cspn.Select(selectedFields...)
	}
	return nil
}

type carrierservicepostnordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierServicePostNordPaginateOption
}

func newCarrierServicePostNordPaginateArgs(rv map[string]any) *carrierservicepostnordPaginateArgs {
	args := &carrierservicepostnordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierServicePostNordWhereInput); ok {
		args.opts = append(args.opts, WithCarrierServicePostNordFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (csu *CarrierServiceUSPSQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierServiceUSPSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return csu, nil
	}
	if err := csu.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return csu, nil
}

func (csu *CarrierServiceUSPSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "carrierService":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceClient{config: csu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceImplementors)...); err != nil {
				return err
			}
			csu.withCarrierService = query

		case "carrierAdditionalServiceUSPS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceUSPSClient{config: csu.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalserviceuspsImplementors)...); err != nil {
				return err
			}
			csu.WithNamedCarrierAdditionalServiceUSPS(alias, func(wq *CarrierAdditionalServiceUSPSQuery) {
				*wq = *query
			})
		}
	}
	return nil
}

type carrierserviceuspsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierServiceUSPSPaginateOption
}

func newCarrierServiceUSPSPaginateArgs(rv map[string]any) *carrierserviceuspsPaginateArgs {
	args := &carrierserviceuspsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierServiceUSPSWhereInput); ok {
		args.opts = append(args.opts, WithCarrierServiceUSPSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cu *CarrierUSPSQuery) CollectFields(ctx context.Context, satisfies ...string) (*CarrierUSPSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cu, nil
	}
	if err := cu.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cu, nil
}

func (cu *CarrierUSPSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(carrierusps.Columns))
		selectedFields = []string{carrierusps.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cu.withTenant = query
			if _, ok := fieldSeen[carrierusps.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierusps.FieldTenantID)
				fieldSeen[carrierusps.FieldTenantID] = struct{}{}
			}

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: cu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			cu.withCarrier = query
		case "tenantID":
			if _, ok := fieldSeen[carrierusps.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, carrierusps.FieldTenantID)
				fieldSeen[carrierusps.FieldTenantID] = struct{}{}
			}
		case "isTestAPI":
			if _, ok := fieldSeen[carrierusps.FieldIsTestAPI]; !ok {
				selectedFields = append(selectedFields, carrierusps.FieldIsTestAPI)
				fieldSeen[carrierusps.FieldIsTestAPI] = struct{}{}
			}
		case "consumerKey":
			if _, ok := fieldSeen[carrierusps.FieldConsumerKey]; !ok {
				selectedFields = append(selectedFields, carrierusps.FieldConsumerKey)
				fieldSeen[carrierusps.FieldConsumerKey] = struct{}{}
			}
		case "consumerSecret":
			if _, ok := fieldSeen[carrierusps.FieldConsumerSecret]; !ok {
				selectedFields = append(selectedFields, carrierusps.FieldConsumerSecret)
				fieldSeen[carrierusps.FieldConsumerSecret] = struct{}{}
			}
		case "mid":
			if _, ok := fieldSeen[carrierusps.FieldMid]; !ok {
				selectedFields = append(selectedFields, carrierusps.FieldMid)
				fieldSeen[carrierusps.FieldMid] = struct{}{}
			}
		case "manifestMid":
			if _, ok := fieldSeen[carrierusps.FieldManifestMid]; !ok {
				selectedFields = append(selectedFields, carrierusps.FieldManifestMid)
				fieldSeen[carrierusps.FieldManifestMid] = struct{}{}
			}
		case "crid":
			if _, ok := fieldSeen[carrierusps.FieldCrid]; !ok {
				selectedFields = append(selectedFields, carrierusps.FieldCrid)
				fieldSeen[carrierusps.FieldCrid] = struct{}{}
			}
		case "epsAccountNumber":
			if _, ok := fieldSeen[carrierusps.FieldEpsAccountNumber]; !ok {
				selectedFields = append(selectedFields, carrierusps.FieldEpsAccountNumber)
				fieldSeen[carrierusps.FieldEpsAccountNumber] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cu.Select(selectedFields...)
	}
	return nil
}

type carrieruspsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CarrierUSPSPaginateOption
}

func newCarrierUSPSPaginateArgs(rv map[string]any) *carrieruspsPaginateArgs {
	args := &carrieruspsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CarrierUSPSWhereInput); ok {
		args.opts = append(args.opts, WithCarrierUSPSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ch *ChangeHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ChangeHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ch, nil
	}
	if err := ch.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ch, nil
}

func (ch *ChangeHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(changehistory.Columns))
		selectedFields = []string{changehistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: ch.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			ch.withTenant = query
			if _, ok := fieldSeen[changehistory.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, changehistory.FieldTenantID)
				fieldSeen[changehistory.FieldTenantID] = struct{}{}
			}

		case "planHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanHistoryClient{config: ch.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, planhistoryImplementors)...); err != nil {
				return err
			}
			ch.WithNamedPlanHistory(alias, func(wq *PlanHistoryQuery) {
				*wq = *query
			})

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ch.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ch.withUser = query

		case "orderHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderHistoryClient{config: ch.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orderhistoryImplementors)...); err != nil {
				return err
			}
			ch.WithNamedOrderHistory(alias, func(wq *OrderHistoryQuery) {
				*wq = *query
			})

		case "shipmentHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentHistoryClient{config: ch.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, shipmenthistoryImplementors)...); err != nil {
				return err
			}
			ch.WithNamedShipmentHistory(alias, func(wq *ShipmentHistoryQuery) {
				*wq = *query
			})

		case "returnColliHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnColliHistoryClient{config: ch.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returncollihistoryImplementors)...); err != nil {
				return err
			}
			ch.WithNamedReturnColliHistory(alias, func(wq *ReturnColliHistoryQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[changehistory.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, changehistory.FieldTenantID)
				fieldSeen[changehistory.FieldTenantID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[changehistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, changehistory.FieldCreatedAt)
				fieldSeen[changehistory.FieldCreatedAt] = struct{}{}
			}
		case "origin":
			if _, ok := fieldSeen[changehistory.FieldOrigin]; !ok {
				selectedFields = append(selectedFields, changehistory.FieldOrigin)
				fieldSeen[changehistory.FieldOrigin] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ch.Select(selectedFields...)
	}
	return nil
}

type changehistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ChangeHistoryPaginateOption
}

func newChangeHistoryPaginateArgs(rv map[string]any) *changehistoryPaginateArgs {
	args := &changehistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ChangeHistoryOrder{Field: &ChangeHistoryOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithChangeHistoryOrder(order))
			}
		case *ChangeHistoryOrder:
			if v != nil {
				args.opts = append(args.opts, WithChangeHistoryOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ChangeHistoryWhereInput); ok {
		args.opts = append(args.opts, WithChangeHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ColliQuery) CollectFields(ctx context.Context, satisfies ...string) (*ColliQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *ColliQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(colli.Columns))
		selectedFields = []string{colli.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			c.withTenant = query
			if _, ok := fieldSeen[colli.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, colli.FieldTenantID)
				fieldSeen[colli.FieldTenantID] = struct{}{}
			}

		case "recipient":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressImplementors)...); err != nil {
				return err
			}
			c.withRecipient = query

		case "sender":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressImplementors)...); err != nil {
				return err
			}
			c.withSender = query

		case "parcelShop":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopImplementors)...); err != nil {
				return err
			}
			c.withParcelShop = query

		case "clickCollectLocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			c.withClickCollectLocation = query

		case "orderLines":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderLineClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orderlineImplementors)...); err != nil {
				return err
			}
			c.WithNamedOrderLines(alias, func(wq *OrderLineQuery) {
				*wq = *query
			})

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			c.withDeliveryOption = query

		case "documentFile":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentFileClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, documentfileImplementors)...); err != nil {
				return err
			}
			c.WithNamedDocumentFile(alias, func(wq *DocumentFileQuery) {
				*wq = *query
			})

		case "shipmentParcel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentParcelClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentparcelImplementors)...); err != nil {
				return err
			}
			c.withShipmentParcel = query

		case "cancelledShipmentParcel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentParcelClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, shipmentparcelImplementors)...); err != nil {
				return err
			}
			c.WithNamedCancelledShipmentParcel(alias, func(wq *ShipmentParcelQuery) {
				*wq = *query
			})

		case "order":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, orderImplementors)...); err != nil {
				return err
			}
			c.withOrder = query

		case "packaging":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packagingImplementors)...); err != nil {
				return err
			}
			c.withPackaging = query

		case "printJob":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PrintJobClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, printjobImplementors)...); err != nil {
				return err
			}
			c.WithNamedPrintJob(alias, func(wq *PrintJobQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[colli.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, colli.FieldTenantID)
				fieldSeen[colli.FieldTenantID] = struct{}{}
			}
		case "internalBarcode":
			if _, ok := fieldSeen[colli.FieldInternalBarcode]; !ok {
				selectedFields = append(selectedFields, colli.FieldInternalBarcode)
				fieldSeen[colli.FieldInternalBarcode] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[colli.FieldStatus]; !ok {
				selectedFields = append(selectedFields, colli.FieldStatus)
				fieldSeen[colli.FieldStatus] = struct{}{}
			}
		case "slipPrintStatus":
			if _, ok := fieldSeen[colli.FieldSlipPrintStatus]; !ok {
				selectedFields = append(selectedFields, colli.FieldSlipPrintStatus)
				fieldSeen[colli.FieldSlipPrintStatus] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[colli.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, colli.FieldCreatedAt)
				fieldSeen[colli.FieldCreatedAt] = struct{}{}
			}
		case "emailPackingSlipPrintedAt":
			if _, ok := fieldSeen[colli.FieldEmailPackingSlipPrintedAt]; !ok {
				selectedFields = append(selectedFields, colli.FieldEmailPackingSlipPrintedAt)
				fieldSeen[colli.FieldEmailPackingSlipPrintedAt] = struct{}{}
			}
		case "emailLabelPrintedAt":
			if _, ok := fieldSeen[colli.FieldEmailLabelPrintedAt]; !ok {
				selectedFields = append(selectedFields, colli.FieldEmailLabelPrintedAt)
				fieldSeen[colli.FieldEmailLabelPrintedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type colliPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ColliPaginateOption
}

func newColliPaginateArgs(rv map[string]any) *colliPaginateArgs {
	args := &colliPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ColliWhereInput); ok {
		args.opts = append(args.opts, WithColliFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (coc *ConnectOptionCarrierQuery) CollectFields(ctx context.Context, satisfies ...string) (*ConnectOptionCarrierQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return coc, nil
	}
	if err := coc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return coc, nil
}

func (coc *ConnectOptionCarrierQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(connectoptioncarrier.Columns))
		selectedFields = []string{connectoptioncarrier.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: coc.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			coc.WithNamedTenant(alias, func(wq *TenantQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[connectoptioncarrier.FieldName]; !ok {
				selectedFields = append(selectedFields, connectoptioncarrier.FieldName)
				fieldSeen[connectoptioncarrier.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		coc.Select(selectedFields...)
	}
	return nil
}

type connectoptioncarrierPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ConnectOptionCarrierPaginateOption
}

func newConnectOptionCarrierPaginateArgs(rv map[string]any) *connectoptioncarrierPaginateArgs {
	args := &connectoptioncarrierPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ConnectOptionCarrierWhereInput); ok {
		args.opts = append(args.opts, WithConnectOptionCarrierFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cop *ConnectOptionPlatformQuery) CollectFields(ctx context.Context, satisfies ...string) (*ConnectOptionPlatformQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cop, nil
	}
	if err := cop.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cop, nil
}

func (cop *ConnectOptionPlatformQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(connectoptionplatform.Columns))
		selectedFields = []string{connectoptionplatform.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cop.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cop.WithNamedTenant(alias, func(wq *TenantQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[connectoptionplatform.FieldName]; !ok {
				selectedFields = append(selectedFields, connectoptionplatform.FieldName)
				fieldSeen[connectoptionplatform.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cop.Select(selectedFields...)
	}
	return nil
}

type connectoptionplatformPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ConnectOptionPlatformPaginateOption
}

func newConnectOptionPlatformPaginateArgs(rv map[string]any) *connectoptionplatformPaginateArgs {
	args := &connectoptionplatformPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ConnectOptionPlatformWhereInput); ok {
		args.opts = append(args.opts, WithConnectOptionPlatformFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ConnectionQuery) CollectFields(ctx context.Context, satisfies ...string) (*ConnectionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *ConnectionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(connection.Columns))
		selectedFields = []string{connection.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			c.withTenant = query
			if _, ok := fieldSeen[connection.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, connection.FieldTenantID)
				fieldSeen[connection.FieldTenantID] = struct{}{}
			}

		case "connectionBrand":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionBrandClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, connectionbrandImplementors)...); err != nil {
				return err
			}
			c.withConnectionBrand = query

		case "connectionShopify":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionShopifyClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, connectionshopifyImplementors)...); err != nil {
				return err
			}
			c.withConnectionShopify = query

		case "orders":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orderImplementors)...); err != nil {
				return err
			}
			c.WithNamedOrders(alias, func(wq *OrderQuery) {
				*wq = *query
			})

		case "senderLocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			c.withSenderLocation = query

		case "pickupLocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			c.withPickupLocation = query

		case "returnLocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			c.withReturnLocation = query

		case "sellerLocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			c.withSellerLocation = query

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			c.WithNamedDeliveryOption(alias, func(wq *DeliveryOptionQuery) {
				*wq = *query
			})

		case "defaultDeliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			c.withDefaultDeliveryOption = query

		case "returnPortal":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, returnportalImplementors)...); err != nil {
				return err
			}
			c.withReturnPortal = query

		case "hypothesisTest":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hypothesistestImplementors)...); err != nil {
				return err
			}
			c.WithNamedHypothesisTest(alias, func(wq *HypothesisTestQuery) {
				*wq = *query
			})

		case "notifications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NotificationClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, notificationImplementors)...); err != nil {
				return err
			}
			c.WithNamedNotifications(alias, func(wq *NotificationQuery) {
				*wq = *query
			})

		case "currency":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CurrencyClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, currencyImplementors)...); err != nil {
				return err
			}
			c.withCurrency = query

		case "packingSlipTemplate":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, documentImplementors)...); err != nil {
				return err
			}
			c.withPackingSlipTemplate = query

		case "connectionLookup":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionLookupClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, connectionlookupImplementors)...); err != nil {
				return err
			}
			c.WithNamedConnectionLookup(alias, func(wq *ConnectionLookupQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[connection.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, connection.FieldTenantID)
				fieldSeen[connection.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[connection.FieldName]; !ok {
				selectedFields = append(selectedFields, connection.FieldName)
				fieldSeen[connection.FieldName] = struct{}{}
			}
		case "syncOrders":
			if _, ok := fieldSeen[connection.FieldSyncOrders]; !ok {
				selectedFields = append(selectedFields, connection.FieldSyncOrders)
				fieldSeen[connection.FieldSyncOrders] = struct{}{}
			}
		case "syncProducts":
			if _, ok := fieldSeen[connection.FieldSyncProducts]; !ok {
				selectedFields = append(selectedFields, connection.FieldSyncProducts)
				fieldSeen[connection.FieldSyncProducts] = struct{}{}
			}
		case "fulfillAutomatically":
			if _, ok := fieldSeen[connection.FieldFulfillAutomatically]; !ok {
				selectedFields = append(selectedFields, connection.FieldFulfillAutomatically)
				fieldSeen[connection.FieldFulfillAutomatically] = struct{}{}
			}
		case "dispatchAutomatically":
			if _, ok := fieldSeen[connection.FieldDispatchAutomatically]; !ok {
				selectedFields = append(selectedFields, connection.FieldDispatchAutomatically)
				fieldSeen[connection.FieldDispatchAutomatically] = struct{}{}
			}
		case "convertCurrency":
			if _, ok := fieldSeen[connection.FieldConvertCurrency]; !ok {
				selectedFields = append(selectedFields, connection.FieldConvertCurrency)
				fieldSeen[connection.FieldConvertCurrency] = struct{}{}
			}
		case "autoPrintParcelSlip":
			if _, ok := fieldSeen[connection.FieldAutoPrintParcelSlip]; !ok {
				selectedFields = append(selectedFields, connection.FieldAutoPrintParcelSlip)
				fieldSeen[connection.FieldAutoPrintParcelSlip] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type connectionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ConnectionPaginateOption
}

func newConnectionPaginateArgs(rv map[string]any) *connectionPaginateArgs {
	args := &connectionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ConnectionWhereInput); ok {
		args.opts = append(args.opts, WithConnectionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cb *ConnectionBrandQuery) CollectFields(ctx context.Context, satisfies ...string) (*ConnectionBrandQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cb, nil
	}
	if err := cb.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cb, nil
}

func (cb *ConnectionBrandQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(connectionbrand.Columns))
		selectedFields = []string{connectionbrand.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "connection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: cb.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			cb.WithNamedConnection(alias, func(wq *ConnectionQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[connectionbrand.FieldLabel]; !ok {
				selectedFields = append(selectedFields, connectionbrand.FieldLabel)
				fieldSeen[connectionbrand.FieldLabel] = struct{}{}
			}
		case "internalID":
			if _, ok := fieldSeen[connectionbrand.FieldInternalID]; !ok {
				selectedFields = append(selectedFields, connectionbrand.FieldInternalID)
				fieldSeen[connectionbrand.FieldInternalID] = struct{}{}
			}
		case "logoURL":
			if _, ok := fieldSeen[connectionbrand.FieldLogoURL]; !ok {
				selectedFields = append(selectedFields, connectionbrand.FieldLogoURL)
				fieldSeen[connectionbrand.FieldLogoURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cb.Select(selectedFields...)
	}
	return nil
}

type connectionbrandPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ConnectionBrandPaginateOption
}

func newConnectionBrandPaginateArgs(rv map[string]any) *connectionbrandPaginateArgs {
	args := &connectionbrandPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ConnectionBrandWhereInput); ok {
		args.opts = append(args.opts, WithConnectionBrandFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cl *ConnectionLookupQuery) CollectFields(ctx context.Context, satisfies ...string) (*ConnectionLookupQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cl, nil
	}
	if err := cl.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cl, nil
}

func (cl *ConnectionLookupQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(connectionlookup.Columns))
		selectedFields = []string{connectionlookup.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cl.withTenant = query
			if _, ok := fieldSeen[connectionlookup.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, connectionlookup.FieldTenantID)
				fieldSeen[connectionlookup.FieldTenantID] = struct{}{}
			}

		case "connections":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: cl.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			cl.withConnections = query
		case "tenantID":
			if _, ok := fieldSeen[connectionlookup.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, connectionlookup.FieldTenantID)
				fieldSeen[connectionlookup.FieldTenantID] = struct{}{}
			}
		case "payload":
			if _, ok := fieldSeen[connectionlookup.FieldPayload]; !ok {
				selectedFields = append(selectedFields, connectionlookup.FieldPayload)
				fieldSeen[connectionlookup.FieldPayload] = struct{}{}
			}
		case "optionsOutputCount":
			if _, ok := fieldSeen[connectionlookup.FieldOptionsOutputCount]; !ok {
				selectedFields = append(selectedFields, connectionlookup.FieldOptionsOutputCount)
				fieldSeen[connectionlookup.FieldOptionsOutputCount] = struct{}{}
			}
		case "error":
			if _, ok := fieldSeen[connectionlookup.FieldError]; !ok {
				selectedFields = append(selectedFields, connectionlookup.FieldError)
				fieldSeen[connectionlookup.FieldError] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[connectionlookup.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, connectionlookup.FieldCreatedAt)
				fieldSeen[connectionlookup.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cl.Select(selectedFields...)
	}
	return nil
}

type connectionlookupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ConnectionLookupPaginateOption
}

func newConnectionLookupPaginateArgs(rv map[string]any) *connectionlookupPaginateArgs {
	args := &connectionlookupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ConnectionLookupOrder{Field: &ConnectionLookupOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithConnectionLookupOrder(order))
			}
		case *ConnectionLookupOrder:
			if v != nil {
				args.opts = append(args.opts, WithConnectionLookupOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ConnectionLookupWhereInput); ok {
		args.opts = append(args.opts, WithConnectionLookupFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (cs *ConnectionShopifyQuery) CollectFields(ctx context.Context, satisfies ...string) (*ConnectionShopifyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return cs, nil
	}
	if err := cs.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return cs, nil
}

func (cs *ConnectionShopifyQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(connectionshopify.Columns))
		selectedFields = []string{connectionshopify.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			cs.withTenant = query
			if _, ok := fieldSeen[connectionshopify.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, connectionshopify.FieldTenantID)
				fieldSeen[connectionshopify.FieldTenantID] = struct{}{}
			}

		case "connection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: cs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			cs.withConnection = query
		case "tenantID":
			if _, ok := fieldSeen[connectionshopify.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, connectionshopify.FieldTenantID)
				fieldSeen[connectionshopify.FieldTenantID] = struct{}{}
			}
		case "rateIntegration":
			if _, ok := fieldSeen[connectionshopify.FieldRateIntegration]; !ok {
				selectedFields = append(selectedFields, connectionshopify.FieldRateIntegration)
				fieldSeen[connectionshopify.FieldRateIntegration] = struct{}{}
			}
		case "storeURL":
			if _, ok := fieldSeen[connectionshopify.FieldStoreURL]; !ok {
				selectedFields = append(selectedFields, connectionshopify.FieldStoreURL)
				fieldSeen[connectionshopify.FieldStoreURL] = struct{}{}
			}
		case "apiKey":
			if _, ok := fieldSeen[connectionshopify.FieldAPIKey]; !ok {
				selectedFields = append(selectedFields, connectionshopify.FieldAPIKey)
				fieldSeen[connectionshopify.FieldAPIKey] = struct{}{}
			}
		case "lookupKey":
			if _, ok := fieldSeen[connectionshopify.FieldLookupKey]; !ok {
				selectedFields = append(selectedFields, connectionshopify.FieldLookupKey)
				fieldSeen[connectionshopify.FieldLookupKey] = struct{}{}
			}
		case "syncFrom":
			if _, ok := fieldSeen[connectionshopify.FieldSyncFrom]; !ok {
				selectedFields = append(selectedFields, connectionshopify.FieldSyncFrom)
				fieldSeen[connectionshopify.FieldSyncFrom] = struct{}{}
			}
		case "filterTags":
			if _, ok := fieldSeen[connectionshopify.FieldFilterTags]; !ok {
				selectedFields = append(selectedFields, connectionshopify.FieldFilterTags)
				fieldSeen[connectionshopify.FieldFilterTags] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		cs.Select(selectedFields...)
	}
	return nil
}

type connectionshopifyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ConnectionShopifyPaginateOption
}

func newConnectionShopifyPaginateArgs(rv map[string]any) *connectionshopifyPaginateArgs {
	args := &connectionshopifyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ConnectionShopifyWhereInput); ok {
		args.opts = append(args.opts, WithConnectionShopifyFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ConsolidationQuery) CollectFields(ctx context.Context, satisfies ...string) (*ConsolidationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *ConsolidationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(consolidation.Columns))
		selectedFields = []string{consolidation.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			c.withTenant = query
			if _, ok := fieldSeen[consolidation.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, consolidation.FieldTenantID)
				fieldSeen[consolidation.FieldTenantID] = struct{}{}
			}

		case "pallets":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PalletClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, palletImplementors)...); err != nil {
				return err
			}
			c.WithNamedPallets(alias, func(wq *PalletQuery) {
				*wq = *query
			})

		case "orders":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orderImplementors)...); err != nil {
				return err
			}
			c.WithNamedOrders(alias, func(wq *OrderQuery) {
				*wq = *query
			})

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			c.withDeliveryOption = query

		case "recipient":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressImplementors)...); err != nil {
				return err
			}
			c.withRecipient = query

		case "sender":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressImplementors)...); err != nil {
				return err
			}
			c.withSender = query

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			c.withShipment = query

		case "cancelledShipments":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			c.WithNamedCancelledShipments(alias, func(wq *ShipmentQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[consolidation.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, consolidation.FieldTenantID)
				fieldSeen[consolidation.FieldTenantID] = struct{}{}
			}
		case "publicID":
			if _, ok := fieldSeen[consolidation.FieldPublicID]; !ok {
				selectedFields = append(selectedFields, consolidation.FieldPublicID)
				fieldSeen[consolidation.FieldPublicID] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[consolidation.FieldDescription]; !ok {
				selectedFields = append(selectedFields, consolidation.FieldDescription)
				fieldSeen[consolidation.FieldDescription] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[consolidation.FieldStatus]; !ok {
				selectedFields = append(selectedFields, consolidation.FieldStatus)
				fieldSeen[consolidation.FieldStatus] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[consolidation.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, consolidation.FieldCreatedAt)
				fieldSeen[consolidation.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type consolidationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ConsolidationPaginateOption
}

func newConsolidationPaginateArgs(rv map[string]any) *consolidationPaginateArgs {
	args := &consolidationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ConsolidationOrder{Field: &ConsolidationOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithConsolidationOrder(order))
			}
		case *ConsolidationOrder:
			if v != nil {
				args.opts = append(args.opts, WithConsolidationOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ConsolidationWhereInput); ok {
		args.opts = append(args.opts, WithConsolidationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *ContactQuery) CollectFields(ctx context.Context, satisfies ...string) (*ContactQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *ContactQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(contact.Columns))
		selectedFields = []string{contact.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			c.withTenant = query
			if _, ok := fieldSeen[contact.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, contact.FieldTenantID)
				fieldSeen[contact.FieldTenantID] = struct{}{}
			}

		case "billingContact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			c.WithNamedBillingContact(alias, func(wq *TenantQuery) {
				*wq = *query
			})

		case "adminContact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			c.WithNamedAdminContact(alias, func(wq *TenantQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[contact.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, contact.FieldTenantID)
				fieldSeen[contact.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[contact.FieldName]; !ok {
				selectedFields = append(selectedFields, contact.FieldName)
				fieldSeen[contact.FieldName] = struct{}{}
			}
		case "surname":
			if _, ok := fieldSeen[contact.FieldSurname]; !ok {
				selectedFields = append(selectedFields, contact.FieldSurname)
				fieldSeen[contact.FieldSurname] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[contact.FieldEmail]; !ok {
				selectedFields = append(selectedFields, contact.FieldEmail)
				fieldSeen[contact.FieldEmail] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[contact.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, contact.FieldPhoneNumber)
				fieldSeen[contact.FieldPhoneNumber] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type contactPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ContactPaginateOption
}

func newContactPaginateArgs(rv map[string]any) *contactPaginateArgs {
	args := &contactPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ContactWhereInput); ok {
		args.opts = append(args.opts, WithContactFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CountryQuery) CollectFields(ctx context.Context, satisfies ...string) (*CountryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CountryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(country.Columns))
		selectedFields = []string{country.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "deliveryRule":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryRuleClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryruleImplementors)...); err != nil {
				return err
			}
			c.WithNamedDeliveryRule(alias, func(wq *DeliveryRuleQuery) {
				*wq = *query
			})

		case "address":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, addressImplementors)...); err != nil {
				return err
			}
			c.WithNamedAddress(alias, func(wq *AddressQuery) {
				*wq = *query
			})

		case "addressGlobal":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressGlobalClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, addressglobalImplementors)...); err != nil {
				return err
			}
			c.WithNamedAddressGlobal(alias, func(wq *AddressGlobalQuery) {
				*wq = *query
			})

		case "carrierAdditionalServicePostNordConsignee":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServicePostNordClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicepostnordImplementors)...); err != nil {
				return err
			}
			c.WithNamedCarrierAdditionalServicePostNordConsignee(alias, func(wq *CarrierAdditionalServicePostNordQuery) {
				*wq = *query
			})

		case "carrierAdditionalServicePostNordConsignor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServicePostNordClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicepostnordImplementors)...); err != nil {
				return err
			}
			c.WithNamedCarrierAdditionalServicePostNordConsignor(alias, func(wq *CarrierAdditionalServicePostNordQuery) {
				*wq = *query
			})

		case "carrierAdditionalServiceGLSConsignee":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceGLSClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalserviceglsImplementors)...); err != nil {
				return err
			}
			c.WithNamedCarrierAdditionalServiceGLSConsignee(alias, func(wq *CarrierAdditionalServiceGLSQuery) {
				*wq = *query
			})

		case "carrierAdditionalServiceGLSConsignor":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceGLSClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalserviceglsImplementors)...); err != nil {
				return err
			}
			c.WithNamedCarrierAdditionalServiceGLSConsignor(alias, func(wq *CarrierAdditionalServiceGLSQuery) {
				*wq = *query
			})

		case "countryHarmonizedCode":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryHarmonizedCodeClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, countryharmonizedcodeImplementors)...); err != nil {
				return err
			}
			c.WithNamedCountryHarmonizedCode(alias, func(wq *CountryHarmonizedCodeQuery) {
				*wq = *query
			})

		case "inventoryItem":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InventoryItemClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, inventoryitemImplementors)...); err != nil {
				return err
			}
			c.WithNamedInventoryItem(alias, func(wq *InventoryItemQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[country.FieldLabel]; !ok {
				selectedFields = append(selectedFields, country.FieldLabel)
				fieldSeen[country.FieldLabel] = struct{}{}
			}
		case "alpha2":
			if _, ok := fieldSeen[country.FieldAlpha2]; !ok {
				selectedFields = append(selectedFields, country.FieldAlpha2)
				fieldSeen[country.FieldAlpha2] = struct{}{}
			}
		case "alpha3":
			if _, ok := fieldSeen[country.FieldAlpha3]; !ok {
				selectedFields = append(selectedFields, country.FieldAlpha3)
				fieldSeen[country.FieldAlpha3] = struct{}{}
			}
		case "code":
			if _, ok := fieldSeen[country.FieldCode]; !ok {
				selectedFields = append(selectedFields, country.FieldCode)
				fieldSeen[country.FieldCode] = struct{}{}
			}
		case "region":
			if _, ok := fieldSeen[country.FieldRegion]; !ok {
				selectedFields = append(selectedFields, country.FieldRegion)
				fieldSeen[country.FieldRegion] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type countryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CountryPaginateOption
}

func newCountryPaginateArgs(rv map[string]any) *countryPaginateArgs {
	args := &countryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CountryWhereInput); ok {
		args.opts = append(args.opts, WithCountryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (chc *CountryHarmonizedCodeQuery) CollectFields(ctx context.Context, satisfies ...string) (*CountryHarmonizedCodeQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return chc, nil
	}
	if err := chc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return chc, nil
}

func (chc *CountryHarmonizedCodeQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(countryharmonizedcode.Columns))
		selectedFields = []string{countryharmonizedcode.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: chc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			chc.withTenant = query
			if _, ok := fieldSeen[countryharmonizedcode.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, countryharmonizedcode.FieldTenantID)
				fieldSeen[countryharmonizedcode.FieldTenantID] = struct{}{}
			}

		case "inventoryItem":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InventoryItemClient{config: chc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, inventoryitemImplementors)...); err != nil {
				return err
			}
			chc.withInventoryItem = query

		case "country":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: chc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			chc.withCountry = query
		case "tenantID":
			if _, ok := fieldSeen[countryharmonizedcode.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, countryharmonizedcode.FieldTenantID)
				fieldSeen[countryharmonizedcode.FieldTenantID] = struct{}{}
			}
		case "code":
			if _, ok := fieldSeen[countryharmonizedcode.FieldCode]; !ok {
				selectedFields = append(selectedFields, countryharmonizedcode.FieldCode)
				fieldSeen[countryharmonizedcode.FieldCode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		chc.Select(selectedFields...)
	}
	return nil
}

type countryharmonizedcodePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CountryHarmonizedCodePaginateOption
}

func newCountryHarmonizedCodePaginateArgs(rv map[string]any) *countryharmonizedcodePaginateArgs {
	args := &countryharmonizedcodePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CountryHarmonizedCodeWhereInput); ok {
		args.opts = append(args.opts, WithCountryHarmonizedCodeFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (c *CurrencyQuery) CollectFields(ctx context.Context, satisfies ...string) (*CurrencyQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return c, nil
	}
	if err := c.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return c, nil
}

func (c *CurrencyQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(currency.Columns))
		selectedFields = []string{currency.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "orderLine":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderLineClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orderlineImplementors)...); err != nil {
				return err
			}
			c.WithNamedOrderLine(alias, func(wq *OrderLineQuery) {
				*wq = *query
			})

		case "deliveryRule":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryRuleClient{config: c.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryruleImplementors)...); err != nil {
				return err
			}
			c.WithNamedDeliveryRule(alias, func(wq *DeliveryRuleQuery) {
				*wq = *query
			})
		case "display":
			if _, ok := fieldSeen[currency.FieldDisplay]; !ok {
				selectedFields = append(selectedFields, currency.FieldDisplay)
				fieldSeen[currency.FieldDisplay] = struct{}{}
			}
		case "currencyCode":
			if _, ok := fieldSeen[currency.FieldCurrencyCode]; !ok {
				selectedFields = append(selectedFields, currency.FieldCurrencyCode)
				fieldSeen[currency.FieldCurrencyCode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		c.Select(selectedFields...)
	}
	return nil
}

type currencyPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []CurrencyPaginateOption
}

func newCurrencyPaginateArgs(rv map[string]any) *currencyPaginateArgs {
	args := &currencyPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*CurrencyWhereInput); ok {
		args.opts = append(args.opts, WithCurrencyFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (do *DeliveryOptionQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryOptionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return do, nil
	}
	if err := do.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return do, nil
}

func (do *DeliveryOptionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryoption.Columns))
		selectedFields = []string{deliveryoption.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			do.withTenant = query
			if _, ok := fieldSeen[deliveryoption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldTenantID)
				fieldSeen[deliveryoption.FieldTenantID] = struct{}{}
			}

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			do.withCarrier = query

		case "deliveryRule":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryRuleClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryruleImplementors)...); err != nil {
				return err
			}
			do.WithNamedDeliveryRule(alias, func(wq *DeliveryRuleQuery) {
				*wq = *query
			})

		case "deliveryOptionDAO":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionDAOClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptiondaoImplementors)...); err != nil {
				return err
			}
			do.withDeliveryOptionDAO = query

		case "deliveryOptionDF":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionDFClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptiondfImplementors)...); err != nil {
				return err
			}
			do.withDeliveryOptionDF = query

		case "deliveryOptionDSV":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionDSVClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptiondsvImplementors)...); err != nil {
				return err
			}
			do.withDeliveryOptionDSV = query

		case "deliveryOptionEasyPost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionEasyPostClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptioneasypostImplementors)...); err != nil {
				return err
			}
			do.withDeliveryOptionEasyPost = query

		case "deliveryOptionGLS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionGLSClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionglsImplementors)...); err != nil {
				return err
			}
			do.withDeliveryOptionGLS = query

		case "deliveryOptionPostNord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionPostNordClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionpostnordImplementors)...); err != nil {
				return err
			}
			do.withDeliveryOptionPostNord = query

		case "deliveryOptionUSPS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionUSPSClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionuspsImplementors)...); err != nil {
				return err
			}
			do.withDeliveryOptionUSPS = query

		case "deliveryOptionBring":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionBringClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionbringImplementors)...); err != nil {
				return err
			}
			do.withDeliveryOptionBring = query

		case "returnPortals":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returnportalImplementors)...); err != nil {
				return err
			}
			do.WithNamedReturnPortals(alias, func(wq *ReturnPortalQuery) {
				*wq = *query
			})

		case "colli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			do.WithNamedColli(alias, func(wq *ColliQuery) {
				*wq = *query
			})

		case "returnColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnColliClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returncolliImplementors)...); err != nil {
				return err
			}
			do.WithNamedReturnColli(alias, func(wq *ReturnColliQuery) {
				*wq = *query
			})

		case "carrierService":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierServiceClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierserviceImplementors)...); err != nil {
				return err
			}
			do.withCarrierService = query

		case "connection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			do.withConnection = query

		case "connectionDefault":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			do.withConnectionDefault = query

		case "hypothesisTestDeliveryOptionGroupOne":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestDeliveryOptionClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hypothesistestdeliveryoptionImplementors)...); err != nil {
				return err
			}
			do.WithNamedHypothesisTestDeliveryOptionGroupOne(alias, func(wq *HypothesisTestDeliveryOptionQuery) {
				*wq = *query
			})

		case "hypothesisTestDeliveryOptionGroupTwo":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestDeliveryOptionClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hypothesistestdeliveryoptionImplementors)...); err != nil {
				return err
			}
			do.WithNamedHypothesisTestDeliveryOptionGroupTwo(alias, func(wq *HypothesisTestDeliveryOptionQuery) {
				*wq = *query
			})

		case "hypothesisTestDeliveryOptionLookup":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestDeliveryOptionLookupClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hypothesistestdeliveryoptionlookupImplementors)...); err != nil {
				return err
			}
			do.WithNamedHypothesisTestDeliveryOptionLookup(alias, func(wq *HypothesisTestDeliveryOptionLookupQuery) {
				*wq = *query
			})

		case "clickCollectLocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			do.WithNamedClickCollectLocation(alias, func(wq *LocationQuery) {
				*wq = *query
			})

		case "emailClickCollectAtStore":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EmailTemplateClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, emailtemplateImplementors)...); err != nil {
				return err
			}
			do.withEmailClickCollectAtStore = query

		case "consolidation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConsolidationClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, consolidationImplementors)...); err != nil {
				return err
			}
			do.WithNamedConsolidation(alias, func(wq *ConsolidationQuery) {
				*wq = *query
			})

		case "defaultPackaging":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingClient{config: do.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packagingImplementors)...); err != nil {
				return err
			}
			do.withDefaultPackaging = query
		case "tenantID":
			if _, ok := fieldSeen[deliveryoption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldTenantID)
				fieldSeen[deliveryoption.FieldTenantID] = struct{}{}
			}
		case "archivedAt":
			if _, ok := fieldSeen[deliveryoption.FieldArchivedAt]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldArchivedAt)
				fieldSeen[deliveryoption.FieldArchivedAt] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[deliveryoption.FieldName]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldName)
				fieldSeen[deliveryoption.FieldName] = struct{}{}
			}
		case "sortOrder":
			if _, ok := fieldSeen[deliveryoption.FieldSortOrder]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldSortOrder)
				fieldSeen[deliveryoption.FieldSortOrder] = struct{}{}
			}
		case "clickOptionDisplayCount":
			if _, ok := fieldSeen[deliveryoption.FieldClickOptionDisplayCount]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldClickOptionDisplayCount)
				fieldSeen[deliveryoption.FieldClickOptionDisplayCount] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[deliveryoption.FieldDescription]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldDescription)
				fieldSeen[deliveryoption.FieldDescription] = struct{}{}
			}
		case "clickCollect":
			if _, ok := fieldSeen[deliveryoption.FieldClickCollect]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldClickCollect)
				fieldSeen[deliveryoption.FieldClickCollect] = struct{}{}
			}
		case "overrideSenderAddress":
			if _, ok := fieldSeen[deliveryoption.FieldOverrideSenderAddress]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldOverrideSenderAddress)
				fieldSeen[deliveryoption.FieldOverrideSenderAddress] = struct{}{}
			}
		case "overrideReturnAddress":
			if _, ok := fieldSeen[deliveryoption.FieldOverrideReturnAddress]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldOverrideReturnAddress)
				fieldSeen[deliveryoption.FieldOverrideReturnAddress] = struct{}{}
			}
		case "hideDeliveryOption":
			if _, ok := fieldSeen[deliveryoption.FieldHideDeliveryOption]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldHideDeliveryOption)
				fieldSeen[deliveryoption.FieldHideDeliveryOption] = struct{}{}
			}
		case "deliveryEstimateFrom":
			if _, ok := fieldSeen[deliveryoption.FieldDeliveryEstimateFrom]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldDeliveryEstimateFrom)
				fieldSeen[deliveryoption.FieldDeliveryEstimateFrom] = struct{}{}
			}
		case "deliveryEstimateTo":
			if _, ok := fieldSeen[deliveryoption.FieldDeliveryEstimateTo]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldDeliveryEstimateTo)
				fieldSeen[deliveryoption.FieldDeliveryEstimateTo] = struct{}{}
			}
		case "webshipperIntegration":
			if _, ok := fieldSeen[deliveryoption.FieldWebshipperIntegration]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldWebshipperIntegration)
				fieldSeen[deliveryoption.FieldWebshipperIntegration] = struct{}{}
			}
		case "webshipperID":
			if _, ok := fieldSeen[deliveryoption.FieldWebshipperID]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldWebshipperID)
				fieldSeen[deliveryoption.FieldWebshipperID] = struct{}{}
			}
		case "shipmondoIntegration":
			if _, ok := fieldSeen[deliveryoption.FieldShipmondoIntegration]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldShipmondoIntegration)
				fieldSeen[deliveryoption.FieldShipmondoIntegration] = struct{}{}
			}
		case "shipmondoDeliveryOption":
			if _, ok := fieldSeen[deliveryoption.FieldShipmondoDeliveryOption]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldShipmondoDeliveryOption)
				fieldSeen[deliveryoption.FieldShipmondoDeliveryOption] = struct{}{}
			}
		case "customsEnabled":
			if _, ok := fieldSeen[deliveryoption.FieldCustomsEnabled]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldCustomsEnabled)
				fieldSeen[deliveryoption.FieldCustomsEnabled] = struct{}{}
			}
		case "customsSigner":
			if _, ok := fieldSeen[deliveryoption.FieldCustomsSigner]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldCustomsSigner)
				fieldSeen[deliveryoption.FieldCustomsSigner] = struct{}{}
			}
		case "hideIfCompanyEmpty":
			if _, ok := fieldSeen[deliveryoption.FieldHideIfCompanyEmpty]; !ok {
				selectedFields = append(selectedFields, deliveryoption.FieldHideIfCompanyEmpty)
				fieldSeen[deliveryoption.FieldHideIfCompanyEmpty] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		do.Select(selectedFields...)
	}
	return nil
}

type deliveryoptionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryOptionPaginateOption
}

func newDeliveryOptionPaginateArgs(rv map[string]any) *deliveryoptionPaginateArgs {
	args := &deliveryoptionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryOptionWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryOptionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dob *DeliveryOptionBringQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryOptionBringQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dob, nil
	}
	if err := dob.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dob, nil
}

func (dob *DeliveryOptionBringQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryoptionbring.Columns))
		selectedFields = []string{deliveryoptionbring.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: dob.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			dob.withTenant = query
			if _, ok := fieldSeen[deliveryoptionbring.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptionbring.FieldTenantID)
				fieldSeen[deliveryoptionbring.FieldTenantID] = struct{}{}
			}

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: dob.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			dob.withDeliveryOption = query

		case "carrierAdditionalServiceBring":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceBringClient{config: dob.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicebringImplementors)...); err != nil {
				return err
			}
			dob.WithNamedCarrierAdditionalServiceBring(alias, func(wq *CarrierAdditionalServiceBringQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[deliveryoptionbring.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptionbring.FieldTenantID)
				fieldSeen[deliveryoptionbring.FieldTenantID] = struct{}{}
			}
		case "electronicCustoms":
			if _, ok := fieldSeen[deliveryoptionbring.FieldElectronicCustoms]; !ok {
				selectedFields = append(selectedFields, deliveryoptionbring.FieldElectronicCustoms)
				fieldSeen[deliveryoptionbring.FieldElectronicCustoms] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dob.Select(selectedFields...)
	}
	return nil
}

type deliveryoptionbringPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryOptionBringPaginateOption
}

func newDeliveryOptionBringPaginateArgs(rv map[string]any) *deliveryoptionbringPaginateArgs {
	args := &deliveryoptionbringPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryOptionBringWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryOptionBringFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dod *DeliveryOptionDAOQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryOptionDAOQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dod, nil
	}
	if err := dod.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dod, nil
}

func (dod *DeliveryOptionDAOQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryoptiondao.Columns))
		selectedFields = []string{deliveryoptiondao.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: dod.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			dod.withTenant = query
			if _, ok := fieldSeen[deliveryoptiondao.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptiondao.FieldTenantID)
				fieldSeen[deliveryoptiondao.FieldTenantID] = struct{}{}
			}

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: dod.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			dod.withDeliveryOption = query

		case "carrierAdditionalServiceDAO":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceDAOClient{config: dod.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicedaoImplementors)...); err != nil {
				return err
			}
			dod.WithNamedCarrierAdditionalServiceDAO(alias, func(wq *CarrierAdditionalServiceDAOQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[deliveryoptiondao.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptiondao.FieldTenantID)
				fieldSeen[deliveryoptiondao.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dod.Select(selectedFields...)
	}
	return nil
}

type deliveryoptiondaoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryOptionDAOPaginateOption
}

func newDeliveryOptionDAOPaginateArgs(rv map[string]any) *deliveryoptiondaoPaginateArgs {
	args := &deliveryoptiondaoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryOptionDAOWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryOptionDAOFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dod *DeliveryOptionDFQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryOptionDFQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dod, nil
	}
	if err := dod.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dod, nil
}

func (dod *DeliveryOptionDFQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryoptiondf.Columns))
		selectedFields = []string{deliveryoptiondf.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: dod.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			dod.withTenant = query
			if _, ok := fieldSeen[deliveryoptiondf.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptiondf.FieldTenantID)
				fieldSeen[deliveryoptiondf.FieldTenantID] = struct{}{}
			}

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: dod.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			dod.withDeliveryOption = query

		case "carrierAdditionalServiceDF":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceDFClient{config: dod.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicedfImplementors)...); err != nil {
				return err
			}
			dod.WithNamedCarrierAdditionalServiceDF(alias, func(wq *CarrierAdditionalServiceDFQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[deliveryoptiondf.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptiondf.FieldTenantID)
				fieldSeen[deliveryoptiondf.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dod.Select(selectedFields...)
	}
	return nil
}

type deliveryoptiondfPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryOptionDFPaginateOption
}

func newDeliveryOptionDFPaginateArgs(rv map[string]any) *deliveryoptiondfPaginateArgs {
	args := &deliveryoptiondfPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryOptionDFWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryOptionDFFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dod *DeliveryOptionDSVQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryOptionDSVQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dod, nil
	}
	if err := dod.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dod, nil
}

func (dod *DeliveryOptionDSVQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryoptiondsv.Columns))
		selectedFields = []string{deliveryoptiondsv.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: dod.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			dod.withTenant = query
			if _, ok := fieldSeen[deliveryoptiondsv.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptiondsv.FieldTenantID)
				fieldSeen[deliveryoptiondsv.FieldTenantID] = struct{}{}
			}

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: dod.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			dod.withDeliveryOption = query

		case "carrierAdditionalServiceDSV":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceDSVClient{config: dod.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicedsvImplementors)...); err != nil {
				return err
			}
			dod.WithNamedCarrierAdditionalServiceDSV(alias, func(wq *CarrierAdditionalServiceDSVQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[deliveryoptiondsv.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptiondsv.FieldTenantID)
				fieldSeen[deliveryoptiondsv.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dod.Select(selectedFields...)
	}
	return nil
}

type deliveryoptiondsvPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryOptionDSVPaginateOption
}

func newDeliveryOptionDSVPaginateArgs(rv map[string]any) *deliveryoptiondsvPaginateArgs {
	args := &deliveryoptiondsvPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryOptionDSVWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryOptionDSVFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (doep *DeliveryOptionEasyPostQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryOptionEasyPostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return doep, nil
	}
	if err := doep.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return doep, nil
}

func (doep *DeliveryOptionEasyPostQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryoptioneasypost.Columns))
		selectedFields = []string{deliveryoptioneasypost.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: doep.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			doep.withTenant = query
			if _, ok := fieldSeen[deliveryoptioneasypost.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptioneasypost.FieldTenantID)
				fieldSeen[deliveryoptioneasypost.FieldTenantID] = struct{}{}
			}

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: doep.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			doep.withDeliveryOption = query

		case "carrierAddServEasyPost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceEasyPostClient{config: doep.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalserviceeasypostImplementors)...); err != nil {
				return err
			}
			doep.WithNamedCarrierAddServEasyPost(alias, func(wq *CarrierAdditionalServiceEasyPostQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[deliveryoptioneasypost.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptioneasypost.FieldTenantID)
				fieldSeen[deliveryoptioneasypost.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		doep.Select(selectedFields...)
	}
	return nil
}

type deliveryoptioneasypostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryOptionEasyPostPaginateOption
}

func newDeliveryOptionEasyPostPaginateArgs(rv map[string]any) *deliveryoptioneasypostPaginateArgs {
	args := &deliveryoptioneasypostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryOptionEasyPostWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryOptionEasyPostFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dog *DeliveryOptionGLSQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryOptionGLSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dog, nil
	}
	if err := dog.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dog, nil
}

func (dog *DeliveryOptionGLSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryoptiongls.Columns))
		selectedFields = []string{deliveryoptiongls.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: dog.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			dog.withTenant = query
			if _, ok := fieldSeen[deliveryoptiongls.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptiongls.FieldTenantID)
				fieldSeen[deliveryoptiongls.FieldTenantID] = struct{}{}
			}

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: dog.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			dog.withDeliveryOption = query

		case "carrierAdditionalServiceGLS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceGLSClient{config: dog.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalserviceglsImplementors)...); err != nil {
				return err
			}
			dog.WithNamedCarrierAdditionalServiceGLS(alias, func(wq *CarrierAdditionalServiceGLSQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[deliveryoptiongls.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptiongls.FieldTenantID)
				fieldSeen[deliveryoptiongls.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dog.Select(selectedFields...)
	}
	return nil
}

type deliveryoptionglsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryOptionGLSPaginateOption
}

func newDeliveryOptionGLSPaginateArgs(rv map[string]any) *deliveryoptionglsPaginateArgs {
	args := &deliveryoptionglsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryOptionGLSWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryOptionGLSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dopn *DeliveryOptionPostNordQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryOptionPostNordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dopn, nil
	}
	if err := dopn.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dopn, nil
}

func (dopn *DeliveryOptionPostNordQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryoptionpostnord.Columns))
		selectedFields = []string{deliveryoptionpostnord.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: dopn.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			dopn.withTenant = query
			if _, ok := fieldSeen[deliveryoptionpostnord.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptionpostnord.FieldTenantID)
				fieldSeen[deliveryoptionpostnord.FieldTenantID] = struct{}{}
			}

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: dopn.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			dopn.withDeliveryOption = query

		case "carrierAddServPostNord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServicePostNordClient{config: dopn.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalservicepostnordImplementors)...); err != nil {
				return err
			}
			dopn.WithNamedCarrierAddServPostNord(alias, func(wq *CarrierAdditionalServicePostNordQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[deliveryoptionpostnord.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptionpostnord.FieldTenantID)
				fieldSeen[deliveryoptionpostnord.FieldTenantID] = struct{}{}
			}
		case "formatZpl":
			if _, ok := fieldSeen[deliveryoptionpostnord.FieldFormatZpl]; !ok {
				selectedFields = append(selectedFields, deliveryoptionpostnord.FieldFormatZpl)
				fieldSeen[deliveryoptionpostnord.FieldFormatZpl] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dopn.Select(selectedFields...)
	}
	return nil
}

type deliveryoptionpostnordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryOptionPostNordPaginateOption
}

func newDeliveryOptionPostNordPaginateArgs(rv map[string]any) *deliveryoptionpostnordPaginateArgs {
	args := &deliveryoptionpostnordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryOptionPostNordWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryOptionPostNordFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dou *DeliveryOptionUSPSQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryOptionUSPSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dou, nil
	}
	if err := dou.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dou, nil
}

func (dou *DeliveryOptionUSPSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryoptionusps.Columns))
		selectedFields = []string{deliveryoptionusps.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: dou.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			dou.withTenant = query
			if _, ok := fieldSeen[deliveryoptionusps.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptionusps.FieldTenantID)
				fieldSeen[deliveryoptionusps.FieldTenantID] = struct{}{}
			}

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: dou.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			dou.withDeliveryOption = query

		case "carrierAdditionalServiceUSPS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierAdditionalServiceUSPSClient{config: dou.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, carrieradditionalserviceuspsImplementors)...); err != nil {
				return err
			}
			dou.WithNamedCarrierAdditionalServiceUSPS(alias, func(wq *CarrierAdditionalServiceUSPSQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[deliveryoptionusps.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryoptionusps.FieldTenantID)
				fieldSeen[deliveryoptionusps.FieldTenantID] = struct{}{}
			}
		case "formatZpl":
			if _, ok := fieldSeen[deliveryoptionusps.FieldFormatZpl]; !ok {
				selectedFields = append(selectedFields, deliveryoptionusps.FieldFormatZpl)
				fieldSeen[deliveryoptionusps.FieldFormatZpl] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dou.Select(selectedFields...)
	}
	return nil
}

type deliveryoptionuspsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryOptionUSPSPaginateOption
}

func newDeliveryOptionUSPSPaginateArgs(rv map[string]any) *deliveryoptionuspsPaginateArgs {
	args := &deliveryoptionuspsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryOptionUSPSWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryOptionUSPSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (dr *DeliveryRuleQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryRuleQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return dr, nil
	}
	if err := dr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return dr, nil
}

func (dr *DeliveryRuleQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryrule.Columns))
		selectedFields = []string{deliveryrule.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: dr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			dr.withTenant = query
			if _, ok := fieldSeen[deliveryrule.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryrule.FieldTenantID)
				fieldSeen[deliveryrule.FieldTenantID] = struct{}{}
			}

		case "deliveryRuleConstraintGroup":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryRuleConstraintGroupClient{config: dr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryruleconstraintgroupImplementors)...); err != nil {
				return err
			}
			dr.WithNamedDeliveryRuleConstraintGroup(alias, func(wq *DeliveryRuleConstraintGroupQuery) {
				*wq = *query
			})

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: dr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			dr.withDeliveryOption = query

		case "country":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: dr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			dr.WithNamedCountry(alias, func(wq *CountryQuery) {
				*wq = *query
			})

		case "currency":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CurrencyClient{config: dr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, currencyImplementors)...); err != nil {
				return err
			}
			dr.withCurrency = query
		case "tenantID":
			if _, ok := fieldSeen[deliveryrule.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryrule.FieldTenantID)
				fieldSeen[deliveryrule.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[deliveryrule.FieldName]; !ok {
				selectedFields = append(selectedFields, deliveryrule.FieldName)
				fieldSeen[deliveryrule.FieldName] = struct{}{}
			}
		case "price":
			if _, ok := fieldSeen[deliveryrule.FieldPrice]; !ok {
				selectedFields = append(selectedFields, deliveryrule.FieldPrice)
				fieldSeen[deliveryrule.FieldPrice] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		dr.Select(selectedFields...)
	}
	return nil
}

type deliveryrulePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryRulePaginateOption
}

func newDeliveryRulePaginateArgs(rv map[string]any) *deliveryrulePaginateArgs {
	args := &deliveryrulePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryRuleWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryRuleFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (drc *DeliveryRuleConstraintQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryRuleConstraintQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return drc, nil
	}
	if err := drc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return drc, nil
}

func (drc *DeliveryRuleConstraintQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryruleconstraint.Columns))
		selectedFields = []string{deliveryruleconstraint.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: drc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			drc.withTenant = query
			if _, ok := fieldSeen[deliveryruleconstraint.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryruleconstraint.FieldTenantID)
				fieldSeen[deliveryruleconstraint.FieldTenantID] = struct{}{}
			}

		case "deliveryRuleConstraintGroup":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryRuleConstraintGroupClient{config: drc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryruleconstraintgroupImplementors)...); err != nil {
				return err
			}
			drc.withDeliveryRuleConstraintGroup = query
		case "tenantID":
			if _, ok := fieldSeen[deliveryruleconstraint.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryruleconstraint.FieldTenantID)
				fieldSeen[deliveryruleconstraint.FieldTenantID] = struct{}{}
			}
		case "propertyType":
			if _, ok := fieldSeen[deliveryruleconstraint.FieldPropertyType]; !ok {
				selectedFields = append(selectedFields, deliveryruleconstraint.FieldPropertyType)
				fieldSeen[deliveryruleconstraint.FieldPropertyType] = struct{}{}
			}
		case "comparison":
			if _, ok := fieldSeen[deliveryruleconstraint.FieldComparison]; !ok {
				selectedFields = append(selectedFields, deliveryruleconstraint.FieldComparison)
				fieldSeen[deliveryruleconstraint.FieldComparison] = struct{}{}
			}
		case "selectedValue":
			if _, ok := fieldSeen[deliveryruleconstraint.FieldSelectedValue]; !ok {
				selectedFields = append(selectedFields, deliveryruleconstraint.FieldSelectedValue)
				fieldSeen[deliveryruleconstraint.FieldSelectedValue] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		drc.Select(selectedFields...)
	}
	return nil
}

type deliveryruleconstraintPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryRuleConstraintPaginateOption
}

func newDeliveryRuleConstraintPaginateArgs(rv map[string]any) *deliveryruleconstraintPaginateArgs {
	args := &deliveryruleconstraintPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryRuleConstraintWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryRuleConstraintFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (drcg *DeliveryRuleConstraintGroupQuery) CollectFields(ctx context.Context, satisfies ...string) (*DeliveryRuleConstraintGroupQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return drcg, nil
	}
	if err := drcg.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return drcg, nil
}

func (drcg *DeliveryRuleConstraintGroupQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(deliveryruleconstraintgroup.Columns))
		selectedFields = []string{deliveryruleconstraintgroup.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: drcg.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			drcg.withTenant = query
			if _, ok := fieldSeen[deliveryruleconstraintgroup.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryruleconstraintgroup.FieldTenantID)
				fieldSeen[deliveryruleconstraintgroup.FieldTenantID] = struct{}{}
			}

		case "deliveryRuleConstraints":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryRuleConstraintClient{config: drcg.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryruleconstraintImplementors)...); err != nil {
				return err
			}
			drcg.WithNamedDeliveryRuleConstraints(alias, func(wq *DeliveryRuleConstraintQuery) {
				*wq = *query
			})

		case "deliveryRule":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryRuleClient{config: drcg.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryruleImplementors)...); err != nil {
				return err
			}
			drcg.withDeliveryRule = query
		case "tenantID":
			if _, ok := fieldSeen[deliveryruleconstraintgroup.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, deliveryruleconstraintgroup.FieldTenantID)
				fieldSeen[deliveryruleconstraintgroup.FieldTenantID] = struct{}{}
			}
		case "constraintLogic":
			if _, ok := fieldSeen[deliveryruleconstraintgroup.FieldConstraintLogic]; !ok {
				selectedFields = append(selectedFields, deliveryruleconstraintgroup.FieldConstraintLogic)
				fieldSeen[deliveryruleconstraintgroup.FieldConstraintLogic] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		drcg.Select(selectedFields...)
	}
	return nil
}

type deliveryruleconstraintgroupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DeliveryRuleConstraintGroupPaginateOption
}

func newDeliveryRuleConstraintGroupPaginateArgs(rv map[string]any) *deliveryruleconstraintgroupPaginateArgs {
	args := &deliveryruleconstraintgroupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DeliveryRuleConstraintGroupWhereInput); ok {
		args.opts = append(args.opts, WithDeliveryRuleConstraintGroupFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (d *DocumentQuery) CollectFields(ctx context.Context, satisfies ...string) (*DocumentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return d, nil
	}
	if err := d.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return d, nil
}

func (d *DocumentQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(document.Columns))
		selectedFields = []string{document.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			d.withTenant = query
			if _, ok := fieldSeen[document.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, document.FieldTenantID)
				fieldSeen[document.FieldTenantID] = struct{}{}
			}

		case "carrierBrand":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierBrandClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierbrandImplementors)...); err != nil {
				return err
			}
			d.withCarrierBrand = query

		case "connectionPackingSlip":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: d.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			d.WithNamedConnectionPackingSlip(alias, func(wq *ConnectionQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[document.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, document.FieldTenantID)
				fieldSeen[document.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[document.FieldName]; !ok {
				selectedFields = append(selectedFields, document.FieldName)
				fieldSeen[document.FieldName] = struct{}{}
			}
		case "htmlTemplate":
			if _, ok := fieldSeen[document.FieldHTMLTemplate]; !ok {
				selectedFields = append(selectedFields, document.FieldHTMLTemplate)
				fieldSeen[document.FieldHTMLTemplate] = struct{}{}
			}
		case "htmlHeader":
			if _, ok := fieldSeen[document.FieldHTMLHeader]; !ok {
				selectedFields = append(selectedFields, document.FieldHTMLHeader)
				fieldSeen[document.FieldHTMLHeader] = struct{}{}
			}
		case "htmlFooter":
			if _, ok := fieldSeen[document.FieldHTMLFooter]; !ok {
				selectedFields = append(selectedFields, document.FieldHTMLFooter)
				fieldSeen[document.FieldHTMLFooter] = struct{}{}
			}
		case "lastBase64Pdf":
			if _, ok := fieldSeen[document.FieldLastBase64Pdf]; !ok {
				selectedFields = append(selectedFields, document.FieldLastBase64Pdf)
				fieldSeen[document.FieldLastBase64Pdf] = struct{}{}
			}
		case "mergeType":
			if _, ok := fieldSeen[document.FieldMergeType]; !ok {
				selectedFields = append(selectedFields, document.FieldMergeType)
				fieldSeen[document.FieldMergeType] = struct{}{}
			}
		case "paperSize":
			if _, ok := fieldSeen[document.FieldPaperSize]; !ok {
				selectedFields = append(selectedFields, document.FieldPaperSize)
				fieldSeen[document.FieldPaperSize] = struct{}{}
			}
		case "startAt":
			if _, ok := fieldSeen[document.FieldStartAt]; !ok {
				selectedFields = append(selectedFields, document.FieldStartAt)
				fieldSeen[document.FieldStartAt] = struct{}{}
			}
		case "endAt":
			if _, ok := fieldSeen[document.FieldEndAt]; !ok {
				selectedFields = append(selectedFields, document.FieldEndAt)
				fieldSeen[document.FieldEndAt] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[document.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, document.FieldCreatedAt)
				fieldSeen[document.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		d.Select(selectedFields...)
	}
	return nil
}

type documentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DocumentPaginateOption
}

func newDocumentPaginateArgs(rv map[string]any) *documentPaginateArgs {
	args := &documentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DocumentWhereInput); ok {
		args.opts = append(args.opts, WithDocumentFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (df *DocumentFileQuery) CollectFields(ctx context.Context, satisfies ...string) (*DocumentFileQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return df, nil
	}
	if err := df.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return df, nil
}

func (df *DocumentFileQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(documentfile.Columns))
		selectedFields = []string{documentfile.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: df.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			df.withTenant = query
			if _, ok := fieldSeen[documentfile.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, documentfile.FieldTenantID)
				fieldSeen[documentfile.FieldTenantID] = struct{}{}
			}

		case "colli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: df.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			df.withColli = query

		case "shipmentParcel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentParcelClient{config: df.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentparcelImplementors)...); err != nil {
				return err
			}
			df.withShipmentParcel = query
		case "tenantID":
			if _, ok := fieldSeen[documentfile.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, documentfile.FieldTenantID)
				fieldSeen[documentfile.FieldTenantID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[documentfile.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, documentfile.FieldCreatedAt)
				fieldSeen[documentfile.FieldCreatedAt] = struct{}{}
			}
		case "storageType":
			if _, ok := fieldSeen[documentfile.FieldStorageType]; !ok {
				selectedFields = append(selectedFields, documentfile.FieldStorageType)
				fieldSeen[documentfile.FieldStorageType] = struct{}{}
			}
		case "storagePath":
			if _, ok := fieldSeen[documentfile.FieldStoragePath]; !ok {
				selectedFields = append(selectedFields, documentfile.FieldStoragePath)
				fieldSeen[documentfile.FieldStoragePath] = struct{}{}
			}
		case "storagePathZpl":
			if _, ok := fieldSeen[documentfile.FieldStoragePathZpl]; !ok {
				selectedFields = append(selectedFields, documentfile.FieldStoragePathZpl)
				fieldSeen[documentfile.FieldStoragePathZpl] = struct{}{}
			}
		case "docType":
			if _, ok := fieldSeen[documentfile.FieldDocType]; !ok {
				selectedFields = append(selectedFields, documentfile.FieldDocType)
				fieldSeen[documentfile.FieldDocType] = struct{}{}
			}
		case "dataPdfBase64":
			if _, ok := fieldSeen[documentfile.FieldDataPdfBase64]; !ok {
				selectedFields = append(selectedFields, documentfile.FieldDataPdfBase64)
				fieldSeen[documentfile.FieldDataPdfBase64] = struct{}{}
			}
		case "dataZplBase64":
			if _, ok := fieldSeen[documentfile.FieldDataZplBase64]; !ok {
				selectedFields = append(selectedFields, documentfile.FieldDataZplBase64)
				fieldSeen[documentfile.FieldDataZplBase64] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		df.Select(selectedFields...)
	}
	return nil
}

type documentfilePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []DocumentFilePaginateOption
}

func newDocumentFilePaginateArgs(rv map[string]any) *documentfilePaginateArgs {
	args := &documentfilePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*DocumentFileWhereInput); ok {
		args.opts = append(args.opts, WithDocumentFileFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (et *EmailTemplateQuery) CollectFields(ctx context.Context, satisfies ...string) (*EmailTemplateQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return et, nil
	}
	if err := et.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return et, nil
}

func (et *EmailTemplateQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(emailtemplate.Columns))
		selectedFields = []string{emailtemplate.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			et.withTenant = query
			if _, ok := fieldSeen[emailtemplate.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, emailtemplate.FieldTenantID)
				fieldSeen[emailtemplate.FieldTenantID] = struct{}{}
			}

		case "returnPortalConfirmationLabel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returnportalImplementors)...); err != nil {
				return err
			}
			et.WithNamedReturnPortalConfirmationLabel(alias, func(wq *ReturnPortalQuery) {
				*wq = *query
			})

		case "returnPortalConfirmationQrCode":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returnportalImplementors)...); err != nil {
				return err
			}
			et.WithNamedReturnPortalConfirmationQrCode(alias, func(wq *ReturnPortalQuery) {
				*wq = *query
			})

		case "returnPortalReceived":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returnportalImplementors)...); err != nil {
				return err
			}
			et.WithNamedReturnPortalReceived(alias, func(wq *ReturnPortalQuery) {
				*wq = *query
			})

		case "returnPortalAccepted":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returnportalImplementors)...); err != nil {
				return err
			}
			et.WithNamedReturnPortalAccepted(alias, func(wq *ReturnPortalQuery) {
				*wq = *query
			})

		case "deliveryOptionClickCollectAtStore":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			et.WithNamedDeliveryOptionClickCollectAtStore(alias, func(wq *DeliveryOptionQuery) {
				*wq = *query
			})

		case "notifications":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&NotificationClient{config: et.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, notificationImplementors)...); err != nil {
				return err
			}
			et.WithNamedNotifications(alias, func(wq *NotificationQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[emailtemplate.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, emailtemplate.FieldTenantID)
				fieldSeen[emailtemplate.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[emailtemplate.FieldName]; !ok {
				selectedFields = append(selectedFields, emailtemplate.FieldName)
				fieldSeen[emailtemplate.FieldName] = struct{}{}
			}
		case "subject":
			if _, ok := fieldSeen[emailtemplate.FieldSubject]; !ok {
				selectedFields = append(selectedFields, emailtemplate.FieldSubject)
				fieldSeen[emailtemplate.FieldSubject] = struct{}{}
			}
		case "htmlTemplate":
			if _, ok := fieldSeen[emailtemplate.FieldHTMLTemplate]; !ok {
				selectedFields = append(selectedFields, emailtemplate.FieldHTMLTemplate)
				fieldSeen[emailtemplate.FieldHTMLTemplate] = struct{}{}
			}
		case "mergeType":
			if _, ok := fieldSeen[emailtemplate.FieldMergeType]; !ok {
				selectedFields = append(selectedFields, emailtemplate.FieldMergeType)
				fieldSeen[emailtemplate.FieldMergeType] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[emailtemplate.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, emailtemplate.FieldCreatedAt)
				fieldSeen[emailtemplate.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[emailtemplate.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, emailtemplate.FieldUpdatedAt)
				fieldSeen[emailtemplate.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		et.Select(selectedFields...)
	}
	return nil
}

type emailtemplatePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []EmailTemplatePaginateOption
}

func newEmailTemplatePaginateArgs(rv map[string]any) *emailtemplatePaginateArgs {
	args := &emailtemplatePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*EmailTemplateWhereInput); ok {
		args.opts = append(args.opts, WithEmailTemplateFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ht *HypothesisTestQuery) CollectFields(ctx context.Context, satisfies ...string) (*HypothesisTestQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ht, nil
	}
	if err := ht.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ht, nil
}

func (ht *HypothesisTestQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hypothesistest.Columns))
		selectedFields = []string{hypothesistest.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: ht.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			ht.withTenant = query
			if _, ok := fieldSeen[hypothesistest.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, hypothesistest.FieldTenantID)
				fieldSeen[hypothesistest.FieldTenantID] = struct{}{}
			}

		case "hypothesisTestDeliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestDeliveryOptionClient{config: ht.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, hypothesistestdeliveryoptionImplementors)...); err != nil {
				return err
			}
			ht.withHypothesisTestDeliveryOption = query

		case "connection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: ht.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			ht.withConnection = query
		case "tenantID":
			if _, ok := fieldSeen[hypothesistest.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, hypothesistest.FieldTenantID)
				fieldSeen[hypothesistest.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[hypothesistest.FieldName]; !ok {
				selectedFields = append(selectedFields, hypothesistest.FieldName)
				fieldSeen[hypothesistest.FieldName] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[hypothesistest.FieldActive]; !ok {
				selectedFields = append(selectedFields, hypothesistest.FieldActive)
				fieldSeen[hypothesistest.FieldActive] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ht.Select(selectedFields...)
	}
	return nil
}

type hypothesistestPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HypothesisTestPaginateOption
}

func newHypothesisTestPaginateArgs(rv map[string]any) *hypothesistestPaginateArgs {
	args := &hypothesistestPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*HypothesisTestWhereInput); ok {
		args.opts = append(args.opts, WithHypothesisTestFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (htdo *HypothesisTestDeliveryOptionQuery) CollectFields(ctx context.Context, satisfies ...string) (*HypothesisTestDeliveryOptionQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return htdo, nil
	}
	if err := htdo.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return htdo, nil
}

func (htdo *HypothesisTestDeliveryOptionQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hypothesistestdeliveryoption.Columns))
		selectedFields = []string{hypothesistestdeliveryoption.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: htdo.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			htdo.withTenant = query
			if _, ok := fieldSeen[hypothesistestdeliveryoption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoption.FieldTenantID)
				fieldSeen[hypothesistestdeliveryoption.FieldTenantID] = struct{}{}
			}

		case "hypothesisTest":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestClient{config: htdo.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, hypothesistestImplementors)...); err != nil {
				return err
			}
			htdo.withHypothesisTest = query

		case "hypothesisTestDeliveryOptionRequest":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestDeliveryOptionRequestClient{config: htdo.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hypothesistestdeliveryoptionrequestImplementors)...); err != nil {
				return err
			}
			htdo.WithNamedHypothesisTestDeliveryOptionRequest(alias, func(wq *HypothesisTestDeliveryOptionRequestQuery) {
				*wq = *query
			})

		case "deliveryOptionGroupOne":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: htdo.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			htdo.WithNamedDeliveryOptionGroupOne(alias, func(wq *DeliveryOptionQuery) {
				*wq = *query
			})

		case "deliveryOptionGroupTwo":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: htdo.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			htdo.WithNamedDeliveryOptionGroupTwo(alias, func(wq *DeliveryOptionQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[hypothesistestdeliveryoption.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoption.FieldTenantID)
				fieldSeen[hypothesistestdeliveryoption.FieldTenantID] = struct{}{}
			}
		case "randomizeWithinGroupSort":
			if _, ok := fieldSeen[hypothesistestdeliveryoption.FieldRandomizeWithinGroupSort]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoption.FieldRandomizeWithinGroupSort)
				fieldSeen[hypothesistestdeliveryoption.FieldRandomizeWithinGroupSort] = struct{}{}
			}
		case "byIntervalRotation":
			if _, ok := fieldSeen[hypothesistestdeliveryoption.FieldByIntervalRotation]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoption.FieldByIntervalRotation)
				fieldSeen[hypothesistestdeliveryoption.FieldByIntervalRotation] = struct{}{}
			}
		case "rotationIntervalHours":
			if _, ok := fieldSeen[hypothesistestdeliveryoption.FieldRotationIntervalHours]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoption.FieldRotationIntervalHours)
				fieldSeen[hypothesistestdeliveryoption.FieldRotationIntervalHours] = struct{}{}
			}
		case "byOrder":
			if _, ok := fieldSeen[hypothesistestdeliveryoption.FieldByOrder]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoption.FieldByOrder)
				fieldSeen[hypothesistestdeliveryoption.FieldByOrder] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		htdo.Select(selectedFields...)
	}
	return nil
}

type hypothesistestdeliveryoptionPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HypothesisTestDeliveryOptionPaginateOption
}

func newHypothesisTestDeliveryOptionPaginateArgs(rv map[string]any) *hypothesistestdeliveryoptionPaginateArgs {
	args := &hypothesistestdeliveryoptionPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*HypothesisTestDeliveryOptionWhereInput); ok {
		args.opts = append(args.opts, WithHypothesisTestDeliveryOptionFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (htdol *HypothesisTestDeliveryOptionLookupQuery) CollectFields(ctx context.Context, satisfies ...string) (*HypothesisTestDeliveryOptionLookupQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return htdol, nil
	}
	if err := htdol.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return htdol, nil
}

func (htdol *HypothesisTestDeliveryOptionLookupQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hypothesistestdeliveryoptionlookup.Columns))
		selectedFields = []string{hypothesistestdeliveryoptionlookup.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: htdol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			htdol.withTenant = query
			if _, ok := fieldSeen[hypothesistestdeliveryoptionlookup.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoptionlookup.FieldTenantID)
				fieldSeen[hypothesistestdeliveryoptionlookup.FieldTenantID] = struct{}{}
			}

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: htdol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			htdol.withDeliveryOption = query

		case "hypothesisTestDeliveryOptionRequest":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestDeliveryOptionRequestClient{config: htdol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, hypothesistestdeliveryoptionrequestImplementors)...); err != nil {
				return err
			}
			htdol.withHypothesisTestDeliveryOptionRequest = query
		case "tenantID":
			if _, ok := fieldSeen[hypothesistestdeliveryoptionlookup.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoptionlookup.FieldTenantID)
				fieldSeen[hypothesistestdeliveryoptionlookup.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		htdol.Select(selectedFields...)
	}
	return nil
}

type hypothesistestdeliveryoptionlookupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HypothesisTestDeliveryOptionLookupPaginateOption
}

func newHypothesisTestDeliveryOptionLookupPaginateArgs(rv map[string]any) *hypothesistestdeliveryoptionlookupPaginateArgs {
	args := &hypothesistestdeliveryoptionlookupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*HypothesisTestDeliveryOptionLookupWhereInput); ok {
		args.opts = append(args.opts, WithHypothesisTestDeliveryOptionLookupFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (htdor *HypothesisTestDeliveryOptionRequestQuery) CollectFields(ctx context.Context, satisfies ...string) (*HypothesisTestDeliveryOptionRequestQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return htdor, nil
	}
	if err := htdor.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return htdor, nil
}

func (htdor *HypothesisTestDeliveryOptionRequestQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(hypothesistestdeliveryoptionrequest.Columns))
		selectedFields = []string{hypothesistestdeliveryoptionrequest.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: htdor.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			htdor.withTenant = query
			if _, ok := fieldSeen[hypothesistestdeliveryoptionrequest.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoptionrequest.FieldTenantID)
				fieldSeen[hypothesistestdeliveryoptionrequest.FieldTenantID] = struct{}{}
			}

		case "hypothesisTestDeliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestDeliveryOptionClient{config: htdor.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, hypothesistestdeliveryoptionImplementors)...); err != nil {
				return err
			}
			htdor.withHypothesisTestDeliveryOption = query

		case "order":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderClient{config: htdor.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, orderImplementors)...); err != nil {
				return err
			}
			htdor.withOrder = query

		case "hypothesisTestDeliveryOptionLookup":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestDeliveryOptionLookupClient{config: htdor.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, hypothesistestdeliveryoptionlookupImplementors)...); err != nil {
				return err
			}
			htdor.WithNamedHypothesisTestDeliveryOptionLookup(alias, func(wq *HypothesisTestDeliveryOptionLookupQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[hypothesistestdeliveryoptionrequest.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoptionrequest.FieldTenantID)
				fieldSeen[hypothesistestdeliveryoptionrequest.FieldTenantID] = struct{}{}
			}
		case "orderHash":
			if _, ok := fieldSeen[hypothesistestdeliveryoptionrequest.FieldOrderHash]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoptionrequest.FieldOrderHash)
				fieldSeen[hypothesistestdeliveryoptionrequest.FieldOrderHash] = struct{}{}
			}
		case "shippingAddressHash":
			if _, ok := fieldSeen[hypothesistestdeliveryoptionrequest.FieldShippingAddressHash]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoptionrequest.FieldShippingAddressHash)
				fieldSeen[hypothesistestdeliveryoptionrequest.FieldShippingAddressHash] = struct{}{}
			}
		case "isControlGroup":
			if _, ok := fieldSeen[hypothesistestdeliveryoptionrequest.FieldIsControlGroup]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoptionrequest.FieldIsControlGroup)
				fieldSeen[hypothesistestdeliveryoptionrequest.FieldIsControlGroup] = struct{}{}
			}
		case "requestCount":
			if _, ok := fieldSeen[hypothesistestdeliveryoptionrequest.FieldRequestCount]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoptionrequest.FieldRequestCount)
				fieldSeen[hypothesistestdeliveryoptionrequest.FieldRequestCount] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[hypothesistestdeliveryoptionrequest.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoptionrequest.FieldCreatedAt)
				fieldSeen[hypothesistestdeliveryoptionrequest.FieldCreatedAt] = struct{}{}
			}
		case "lastRequestedAt":
			if _, ok := fieldSeen[hypothesistestdeliveryoptionrequest.FieldLastRequestedAt]; !ok {
				selectedFields = append(selectedFields, hypothesistestdeliveryoptionrequest.FieldLastRequestedAt)
				fieldSeen[hypothesistestdeliveryoptionrequest.FieldLastRequestedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		htdor.Select(selectedFields...)
	}
	return nil
}

type hypothesistestdeliveryoptionrequestPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []HypothesisTestDeliveryOptionRequestPaginateOption
}

func newHypothesisTestDeliveryOptionRequestPaginateArgs(rv map[string]any) *hypothesistestdeliveryoptionrequestPaginateArgs {
	args := &hypothesistestdeliveryoptionrequestPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*HypothesisTestDeliveryOptionRequestWhereInput); ok {
		args.opts = append(args.opts, WithHypothesisTestDeliveryOptionRequestFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ii *InventoryItemQuery) CollectFields(ctx context.Context, satisfies ...string) (*InventoryItemQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ii, nil
	}
	if err := ii.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ii, nil
}

func (ii *InventoryItemQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(inventoryitem.Columns))
		selectedFields = []string{inventoryitem.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: ii.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			ii.withTenant = query
			if _, ok := fieldSeen[inventoryitem.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, inventoryitem.FieldTenantID)
				fieldSeen[inventoryitem.FieldTenantID] = struct{}{}
			}

		case "countryHarmonizedCode":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryHarmonizedCodeClient{config: ii.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, countryharmonizedcodeImplementors)...); err != nil {
				return err
			}
			ii.WithNamedCountryHarmonizedCode(alias, func(wq *CountryHarmonizedCodeQuery) {
				*wq = *query
			})

		case "countryOfOrigin":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CountryClient{config: ii.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, countryImplementors)...); err != nil {
				return err
			}
			ii.withCountryOfOrigin = query

		case "productVariant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductVariantClient{config: ii.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, productvariantImplementors)...); err != nil {
				return err
			}
			ii.withProductVariant = query
		case "tenantID":
			if _, ok := fieldSeen[inventoryitem.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, inventoryitem.FieldTenantID)
				fieldSeen[inventoryitem.FieldTenantID] = struct{}{}
			}
		case "externalID":
			if _, ok := fieldSeen[inventoryitem.FieldExternalID]; !ok {
				selectedFields = append(selectedFields, inventoryitem.FieldExternalID)
				fieldSeen[inventoryitem.FieldExternalID] = struct{}{}
			}
		case "code":
			if _, ok := fieldSeen[inventoryitem.FieldCode]; !ok {
				selectedFields = append(selectedFields, inventoryitem.FieldCode)
				fieldSeen[inventoryitem.FieldCode] = struct{}{}
			}
		case "sku":
			if _, ok := fieldSeen[inventoryitem.FieldSku]; !ok {
				selectedFields = append(selectedFields, inventoryitem.FieldSku)
				fieldSeen[inventoryitem.FieldSku] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ii.Select(selectedFields...)
	}
	return nil
}

type inventoryitemPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []InventoryItemPaginateOption
}

func newInventoryItemPaginateArgs(rv map[string]any) *inventoryitemPaginateArgs {
	args := &inventoryitemPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*InventoryItemWhereInput); ok {
		args.opts = append(args.opts, WithInventoryItemFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (l *LanguageQuery) CollectFields(ctx context.Context, satisfies ...string) (*LanguageQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return l, nil
	}
	if err := l.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return l, nil
}

func (l *LanguageQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(language.Columns))
		selectedFields = []string{language.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			l.WithNamedUsers(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "language":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			l.WithNamedLanguage(alias, func(wq *TenantQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[language.FieldLabel]; !ok {
				selectedFields = append(selectedFields, language.FieldLabel)
				fieldSeen[language.FieldLabel] = struct{}{}
			}
		case "internalID":
			if _, ok := fieldSeen[language.FieldInternalID]; !ok {
				selectedFields = append(selectedFields, language.FieldInternalID)
				fieldSeen[language.FieldInternalID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		l.Select(selectedFields...)
	}
	return nil
}

type languagePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LanguagePaginateOption
}

func newLanguagePaginateArgs(rv map[string]any) *languagePaginateArgs {
	args := &languagePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*LanguageWhereInput); ok {
		args.opts = append(args.opts, WithLanguageFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (l *LocationQuery) CollectFields(ctx context.Context, satisfies ...string) (*LocationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return l, nil
	}
	if err := l.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return l, nil
}

func (l *LocationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(location.Columns))
		selectedFields = []string{location.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			l.withTenant = query
			if _, ok := fieldSeen[location.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, location.FieldTenantID)
				fieldSeen[location.FieldTenantID] = struct{}{}
			}

		case "address":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressImplementors)...); err != nil {
				return err
			}
			l.withAddress = query

		case "locationTags":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationTagClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, locationtagImplementors)...); err != nil {
				return err
			}
			l.WithNamedLocationTags(alias, func(wq *LocationTagQuery) {
				*wq = *query
			})

		case "senderConnection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			l.WithNamedSenderConnection(alias, func(wq *ConnectionQuery) {
				*wq = *query
			})

		case "pickupConnection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			l.WithNamedPickupConnection(alias, func(wq *ConnectionQuery) {
				*wq = *query
			})

		case "returnConnection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			l.WithNamedReturnConnection(alias, func(wq *ConnectionQuery) {
				*wq = *query
			})

		case "sellerConnection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			l.WithNamedSellerConnection(alias, func(wq *ConnectionQuery) {
				*wq = *query
			})

		case "returnPortal":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returnportalImplementors)...); err != nil {
				return err
			}
			l.WithNamedReturnPortal(alias, func(wq *ReturnPortalQuery) {
				*wq = *query
			})

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			l.WithNamedDeliveryOption(alias, func(wq *DeliveryOptionQuery) {
				*wq = *query
			})

		case "colli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: l.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			l.WithNamedColli(alias, func(wq *ColliQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[location.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, location.FieldTenantID)
				fieldSeen[location.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[location.FieldName]; !ok {
				selectedFields = append(selectedFields, location.FieldName)
				fieldSeen[location.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		l.Select(selectedFields...)
	}
	return nil
}

type locationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LocationPaginateOption
}

func newLocationPaginateArgs(rv map[string]any) *locationPaginateArgs {
	args := &locationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*LocationWhereInput); ok {
		args.opts = append(args.opts, WithLocationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (lt *LocationTagQuery) CollectFields(ctx context.Context, satisfies ...string) (*LocationTagQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return lt, nil
	}
	if err := lt.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return lt, nil
}

func (lt *LocationTagQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(locationtag.Columns))
		selectedFields = []string{locationtag.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "location":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: lt.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			lt.WithNamedLocation(alias, func(wq *LocationQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[locationtag.FieldLabel]; !ok {
				selectedFields = append(selectedFields, locationtag.FieldLabel)
				fieldSeen[locationtag.FieldLabel] = struct{}{}
			}
		case "internalID":
			if _, ok := fieldSeen[locationtag.FieldInternalID]; !ok {
				selectedFields = append(selectedFields, locationtag.FieldInternalID)
				fieldSeen[locationtag.FieldInternalID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		lt.Select(selectedFields...)
	}
	return nil
}

type locationtagPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []LocationTagPaginateOption
}

func newLocationTagPaginateArgs(rv map[string]any) *locationtagPaginateArgs {
	args := &locationtagPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*LocationTagWhereInput); ok {
		args.opts = append(args.opts, WithLocationTagFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (n *NotificationQuery) CollectFields(ctx context.Context, satisfies ...string) (*NotificationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return n, nil
	}
	if err := n.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return n, nil
}

func (n *NotificationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(notification.Columns))
		selectedFields = []string{notification.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			n.withTenant = query
			if _, ok := fieldSeen[notification.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, notification.FieldTenantID)
				fieldSeen[notification.FieldTenantID] = struct{}{}
			}

		case "connection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			n.withConnection = query

		case "emailTemplate":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EmailTemplateClient{config: n.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, emailtemplateImplementors)...); err != nil {
				return err
			}
			n.withEmailTemplate = query
		case "tenantID":
			if _, ok := fieldSeen[notification.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, notification.FieldTenantID)
				fieldSeen[notification.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[notification.FieldName]; !ok {
				selectedFields = append(selectedFields, notification.FieldName)
				fieldSeen[notification.FieldName] = struct{}{}
			}
		case "active":
			if _, ok := fieldSeen[notification.FieldActive]; !ok {
				selectedFields = append(selectedFields, notification.FieldActive)
				fieldSeen[notification.FieldActive] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		n.Select(selectedFields...)
	}
	return nil
}

type notificationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []NotificationPaginateOption
}

func newNotificationPaginateArgs(rv map[string]any) *notificationPaginateArgs {
	args := &notificationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*NotificationWhereInput); ok {
		args.opts = append(args.opts, WithNotificationFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (or *OTKRequestsQuery) CollectFields(ctx context.Context, satisfies ...string) (*OTKRequestsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return or, nil
	}
	if err := or.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return or, nil
}

func (or *OTKRequestsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(otkrequests.Columns))
		selectedFields = []string{otkrequests.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: or.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			or.withTenant = query
			if _, ok := fieldSeen[otkrequests.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, otkrequests.FieldTenantID)
				fieldSeen[otkrequests.FieldTenantID] = struct{}{}
			}

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: or.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			or.withUsers = query
		case "tenantID":
			if _, ok := fieldSeen[otkrequests.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, otkrequests.FieldTenantID)
				fieldSeen[otkrequests.FieldTenantID] = struct{}{}
			}
		case "otk":
			if _, ok := fieldSeen[otkrequests.FieldOtk]; !ok {
				selectedFields = append(selectedFields, otkrequests.FieldOtk)
				fieldSeen[otkrequests.FieldOtk] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		or.Select(selectedFields...)
	}
	return nil
}

type otkrequestsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OTKRequestsPaginateOption
}

func newOTKRequestsPaginateArgs(rv map[string]any) *otkrequestsPaginateArgs {
	args := &otkrequestsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OTKRequestsWhereInput); ok {
		args.opts = append(args.opts, WithOTKRequestsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (o *OrderQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrderQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return o, nil
	}
	if err := o.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return o, nil
}

func (o *OrderQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(order.Columns))
		selectedFields = []string{order.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			o.withTenant = query
			if _, ok := fieldSeen[order.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, order.FieldTenantID)
				fieldSeen[order.FieldTenantID] = struct{}{}
			}

		case "orderHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderHistoryClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orderhistoryImplementors)...); err != nil {
				return err
			}
			o.WithNamedOrderHistory(alias, func(wq *OrderHistoryQuery) {
				*wq = *query
			})

		case "connection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			o.withConnection = query

		case "colli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			o.WithNamedColli(alias, func(wq *ColliQuery) {
				*wq = *query
			})

		case "returnColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnColliClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returncolliImplementors)...); err != nil {
				return err
			}
			o.WithNamedReturnColli(alias, func(wq *ReturnColliQuery) {
				*wq = *query
			})

		case "hypothesisTestDeliveryOptionRequest":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&HypothesisTestDeliveryOptionRequestClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, hypothesistestdeliveryoptionrequestImplementors)...); err != nil {
				return err
			}
			o.withHypothesisTestDeliveryOptionRequest = query

		case "pallet":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PalletClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, palletImplementors)...); err != nil {
				return err
			}
			o.withPallet = query

		case "consolidation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConsolidationClient{config: o.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, consolidationImplementors)...); err != nil {
				return err
			}
			o.withConsolidation = query
		case "tenantID":
			if _, ok := fieldSeen[order.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, order.FieldTenantID)
				fieldSeen[order.FieldTenantID] = struct{}{}
			}
		case "orderPublicID":
			if _, ok := fieldSeen[order.FieldOrderPublicID]; !ok {
				selectedFields = append(selectedFields, order.FieldOrderPublicID)
				fieldSeen[order.FieldOrderPublicID] = struct{}{}
			}
		case "externalID":
			if _, ok := fieldSeen[order.FieldExternalID]; !ok {
				selectedFields = append(selectedFields, order.FieldExternalID)
				fieldSeen[order.FieldExternalID] = struct{}{}
			}
		case "commentInternal":
			if _, ok := fieldSeen[order.FieldCommentInternal]; !ok {
				selectedFields = append(selectedFields, order.FieldCommentInternal)
				fieldSeen[order.FieldCommentInternal] = struct{}{}
			}
		case "commentExternal":
			if _, ok := fieldSeen[order.FieldCommentExternal]; !ok {
				selectedFields = append(selectedFields, order.FieldCommentExternal)
				fieldSeen[order.FieldCommentExternal] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[order.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, order.FieldCreatedAt)
				fieldSeen[order.FieldCreatedAt] = struct{}{}
			}
		case "emailSyncConfirmationAt":
			if _, ok := fieldSeen[order.FieldEmailSyncConfirmationAt]; !ok {
				selectedFields = append(selectedFields, order.FieldEmailSyncConfirmationAt)
				fieldSeen[order.FieldEmailSyncConfirmationAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[order.FieldStatus]; !ok {
				selectedFields = append(selectedFields, order.FieldStatus)
				fieldSeen[order.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		o.Select(selectedFields...)
	}
	return nil
}

type orderPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrderPaginateOption
}

func newOrderPaginateArgs(rv map[string]any) *orderPaginateArgs {
	args := &orderPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &OrderOrder{Field: &OrderOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithOrderOrder(order))
			}
		case *OrderOrder:
			if v != nil {
				args.opts = append(args.opts, WithOrderOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*OrderWhereInput); ok {
		args.opts = append(args.opts, WithOrderFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (oh *OrderHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrderHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return oh, nil
	}
	if err := oh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return oh, nil
}

func (oh *OrderHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(orderhistory.Columns))
		selectedFields = []string{orderhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "changeHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChangeHistoryClient{config: oh.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, changehistoryImplementors)...); err != nil {
				return err
			}
			oh.withChangeHistory = query

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: oh.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			oh.withTenant = query
			if _, ok := fieldSeen[orderhistory.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, orderhistory.FieldTenantID)
				fieldSeen[orderhistory.FieldTenantID] = struct{}{}
			}

		case "order":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderClient{config: oh.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, orderImplementors)...); err != nil {
				return err
			}
			oh.withOrder = query
		case "tenantID":
			if _, ok := fieldSeen[orderhistory.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, orderhistory.FieldTenantID)
				fieldSeen[orderhistory.FieldTenantID] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[orderhistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, orderhistory.FieldDescription)
				fieldSeen[orderhistory.FieldDescription] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[orderhistory.FieldType]; !ok {
				selectedFields = append(selectedFields, orderhistory.FieldType)
				fieldSeen[orderhistory.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		oh.Select(selectedFields...)
	}
	return nil
}

type orderhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrderHistoryPaginateOption
}

func newOrderHistoryPaginateArgs(rv map[string]any) *orderhistoryPaginateArgs {
	args := &orderhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrderHistoryWhereInput); ok {
		args.opts = append(args.opts, WithOrderHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ol *OrderLineQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrderLineQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ol, nil
	}
	if err := ol.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ol, nil
}

func (ol *OrderLineQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(orderline.Columns))
		selectedFields = []string{orderline.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: ol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			ol.withTenant = query
			if _, ok := fieldSeen[orderline.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, orderline.FieldTenantID)
				fieldSeen[orderline.FieldTenantID] = struct{}{}
			}

		case "productVariant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductVariantClient{config: ol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, productvariantImplementors)...); err != nil {
				return err
			}
			ol.withProductVariant = query
			if _, ok := fieldSeen[orderline.FieldProductVariantID]; !ok {
				selectedFields = append(selectedFields, orderline.FieldProductVariantID)
				fieldSeen[orderline.FieldProductVariantID] = struct{}{}
			}

		case "colli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: ol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			ol.withColli = query
			if _, ok := fieldSeen[orderline.FieldColliID]; !ok {
				selectedFields = append(selectedFields, orderline.FieldColliID)
				fieldSeen[orderline.FieldColliID] = struct{}{}
			}

		case "returnOrderLine":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnOrderLineClient{config: ol.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returnorderlineImplementors)...); err != nil {
				return err
			}
			ol.WithNamedReturnOrderLine(alias, func(wq *ReturnOrderLineQuery) {
				*wq = *query
			})

		case "currency":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CurrencyClient{config: ol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, currencyImplementors)...); err != nil {
				return err
			}
			ol.withCurrency = query
		case "tenantID":
			if _, ok := fieldSeen[orderline.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, orderline.FieldTenantID)
				fieldSeen[orderline.FieldTenantID] = struct{}{}
			}
		case "unitPrice":
			if _, ok := fieldSeen[orderline.FieldUnitPrice]; !ok {
				selectedFields = append(selectedFields, orderline.FieldUnitPrice)
				fieldSeen[orderline.FieldUnitPrice] = struct{}{}
			}
		case "discountAllocationAmount":
			if _, ok := fieldSeen[orderline.FieldDiscountAllocationAmount]; !ok {
				selectedFields = append(selectedFields, orderline.FieldDiscountAllocationAmount)
				fieldSeen[orderline.FieldDiscountAllocationAmount] = struct{}{}
			}
		case "externalID":
			if _, ok := fieldSeen[orderline.FieldExternalID]; !ok {
				selectedFields = append(selectedFields, orderline.FieldExternalID)
				fieldSeen[orderline.FieldExternalID] = struct{}{}
			}
		case "units":
			if _, ok := fieldSeen[orderline.FieldUnits]; !ok {
				selectedFields = append(selectedFields, orderline.FieldUnits)
				fieldSeen[orderline.FieldUnits] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[orderline.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, orderline.FieldCreatedAt)
				fieldSeen[orderline.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[orderline.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, orderline.FieldUpdatedAt)
				fieldSeen[orderline.FieldUpdatedAt] = struct{}{}
			}
		case "productVariantID":
			if _, ok := fieldSeen[orderline.FieldProductVariantID]; !ok {
				selectedFields = append(selectedFields, orderline.FieldProductVariantID)
				fieldSeen[orderline.FieldProductVariantID] = struct{}{}
			}
		case "colliID":
			if _, ok := fieldSeen[orderline.FieldColliID]; !ok {
				selectedFields = append(selectedFields, orderline.FieldColliID)
				fieldSeen[orderline.FieldColliID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ol.Select(selectedFields...)
	}
	return nil
}

type orderlinePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrderLinePaginateOption
}

func newOrderLinePaginateArgs(rv map[string]any) *orderlinePaginateArgs {
	args := &orderlinePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrderLineWhereInput); ok {
		args.opts = append(args.opts, WithOrderLineFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (os *OrderSenderQuery) CollectFields(ctx context.Context, satisfies ...string) (*OrderSenderQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return os, nil
	}
	if err := os.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return os, nil
}

func (os *OrderSenderQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(ordersender.Columns))
		selectedFields = []string{ordersender.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: os.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			os.withTenant = query
			if _, ok := fieldSeen[ordersender.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, ordersender.FieldTenantID)
				fieldSeen[ordersender.FieldTenantID] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[ordersender.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, ordersender.FieldTenantID)
				fieldSeen[ordersender.FieldTenantID] = struct{}{}
			}
		case "firstName":
			if _, ok := fieldSeen[ordersender.FieldFirstName]; !ok {
				selectedFields = append(selectedFields, ordersender.FieldFirstName)
				fieldSeen[ordersender.FieldFirstName] = struct{}{}
			}
		case "lastName":
			if _, ok := fieldSeen[ordersender.FieldLastName]; !ok {
				selectedFields = append(selectedFields, ordersender.FieldLastName)
				fieldSeen[ordersender.FieldLastName] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[ordersender.FieldEmail]; !ok {
				selectedFields = append(selectedFields, ordersender.FieldEmail)
				fieldSeen[ordersender.FieldEmail] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[ordersender.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, ordersender.FieldPhoneNumber)
				fieldSeen[ordersender.FieldPhoneNumber] = struct{}{}
			}
		case "vatNumber":
			if _, ok := fieldSeen[ordersender.FieldVatNumber]; !ok {
				selectedFields = append(selectedFields, ordersender.FieldVatNumber)
				fieldSeen[ordersender.FieldVatNumber] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		os.Select(selectedFields...)
	}
	return nil
}

type ordersenderPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []OrderSenderPaginateOption
}

func newOrderSenderPaginateArgs(rv map[string]any) *ordersenderPaginateArgs {
	args := &ordersenderPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*OrderSenderWhereInput); ok {
		args.opts = append(args.opts, WithOrderSenderFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pa *PackagingQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackagingQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pa, nil
	}
	if err := pa.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pa, nil
}

func (pa *PackagingQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packaging.Columns))
		selectedFields = []string{packaging.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pa.withTenant = query
			if _, ok := fieldSeen[packaging.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, packaging.FieldTenantID)
				fieldSeen[packaging.FieldTenantID] = struct{}{}
			}

		case "shipmentParcel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentParcelClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, shipmentparcelImplementors)...); err != nil {
				return err
			}
			pa.WithNamedShipmentParcel(alias, func(wq *ShipmentParcelQuery) {
				*wq = *query
			})

		case "pallet":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PalletClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, palletImplementors)...); err != nil {
				return err
			}
			pa.WithNamedPallet(alias, func(wq *PalletQuery) {
				*wq = *query
			})

		case "colli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			pa.WithNamedColli(alias, func(wq *ColliQuery) {
				*wq = *query
			})

		case "returnColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnColliClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returncolliImplementors)...); err != nil {
				return err
			}
			pa.WithNamedReturnColli(alias, func(wq *ReturnColliQuery) {
				*wq = *query
			})

		case "packagingDF":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingDFClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packagingdfImplementors)...); err != nil {
				return err
			}
			pa.withPackagingDF = query

		case "packagingUSPS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingUSPSClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packaginguspsImplementors)...); err != nil {
				return err
			}
			pa.withPackagingUSPS = query

		case "carrierBrand":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierBrandClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierbrandImplementors)...); err != nil {
				return err
			}
			pa.withCarrierBrand = query

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			pa.WithNamedDeliveryOption(alias, func(wq *DeliveryOptionQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[packaging.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, packaging.FieldTenantID)
				fieldSeen[packaging.FieldTenantID] = struct{}{}
			}
		case "archivedAt":
			if _, ok := fieldSeen[packaging.FieldArchivedAt]; !ok {
				selectedFields = append(selectedFields, packaging.FieldArchivedAt)
				fieldSeen[packaging.FieldArchivedAt] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[packaging.FieldName]; !ok {
				selectedFields = append(selectedFields, packaging.FieldName)
				fieldSeen[packaging.FieldName] = struct{}{}
			}
		case "heightCm":
			if _, ok := fieldSeen[packaging.FieldHeightCm]; !ok {
				selectedFields = append(selectedFields, packaging.FieldHeightCm)
				fieldSeen[packaging.FieldHeightCm] = struct{}{}
			}
		case "widthCm":
			if _, ok := fieldSeen[packaging.FieldWidthCm]; !ok {
				selectedFields = append(selectedFields, packaging.FieldWidthCm)
				fieldSeen[packaging.FieldWidthCm] = struct{}{}
			}
		case "lengthCm":
			if _, ok := fieldSeen[packaging.FieldLengthCm]; !ok {
				selectedFields = append(selectedFields, packaging.FieldLengthCm)
				fieldSeen[packaging.FieldLengthCm] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pa.Select(selectedFields...)
	}
	return nil
}

type packagingPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackagingPaginateOption
}

func newPackagingPaginateArgs(rv map[string]any) *packagingPaginateArgs {
	args := &packagingPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PackagingWhereInput); ok {
		args.opts = append(args.opts, WithPackagingFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pd *PackagingDFQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackagingDFQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pd, nil
	}
	if err := pd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pd, nil
}

func (pd *PackagingDFQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packagingdf.Columns))
		selectedFields = []string{packagingdf.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pd.withTenant = query
			if _, ok := fieldSeen[packagingdf.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, packagingdf.FieldTenantID)
				fieldSeen[packagingdf.FieldTenantID] = struct{}{}
			}

		case "packaging":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingClient{config: pd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packagingImplementors)...); err != nil {
				return err
			}
			pd.withPackaging = query
		case "tenantID":
			if _, ok := fieldSeen[packagingdf.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, packagingdf.FieldTenantID)
				fieldSeen[packagingdf.FieldTenantID] = struct{}{}
			}
		case "apiType":
			if _, ok := fieldSeen[packagingdf.FieldAPIType]; !ok {
				selectedFields = append(selectedFields, packagingdf.FieldAPIType)
				fieldSeen[packagingdf.FieldAPIType] = struct{}{}
			}
		case "maxWeight":
			if _, ok := fieldSeen[packagingdf.FieldMaxWeight]; !ok {
				selectedFields = append(selectedFields, packagingdf.FieldMaxWeight)
				fieldSeen[packagingdf.FieldMaxWeight] = struct{}{}
			}
		case "minWeight":
			if _, ok := fieldSeen[packagingdf.FieldMinWeight]; !ok {
				selectedFields = append(selectedFields, packagingdf.FieldMinWeight)
				fieldSeen[packagingdf.FieldMinWeight] = struct{}{}
			}
		case "stackable":
			if _, ok := fieldSeen[packagingdf.FieldStackable]; !ok {
				selectedFields = append(selectedFields, packagingdf.FieldStackable)
				fieldSeen[packagingdf.FieldStackable] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pd.Select(selectedFields...)
	}
	return nil
}

type packagingdfPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackagingDFPaginateOption
}

func newPackagingDFPaginateArgs(rv map[string]any) *packagingdfPaginateArgs {
	args := &packagingdfPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PackagingDFWhereInput); ok {
		args.opts = append(args.opts, WithPackagingDFFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pu *PackagingUSPSQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackagingUSPSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pu, nil
	}
	if err := pu.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pu, nil
}

func (pu *PackagingUSPSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packagingusps.Columns))
		selectedFields = []string{packagingusps.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pu.withTenant = query
			if _, ok := fieldSeen[packagingusps.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, packagingusps.FieldTenantID)
				fieldSeen[packagingusps.FieldTenantID] = struct{}{}
			}

		case "packaging":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packagingImplementors)...); err != nil {
				return err
			}
			pu.withPackaging = query

		case "packagingUSPSRateIndicator":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingUSPSRateIndicatorClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packaginguspsrateindicatorImplementors)...); err != nil {
				return err
			}
			pu.withPackagingUSPSRateIndicator = query

		case "packagingUSPSProcessingCategory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingUSPSProcessingCategoryClient{config: pu.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packaginguspsprocessingcategoryImplementors)...); err != nil {
				return err
			}
			pu.withPackagingUSPSProcessingCategory = query
		case "tenantID":
			if _, ok := fieldSeen[packagingusps.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, packagingusps.FieldTenantID)
				fieldSeen[packagingusps.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pu.Select(selectedFields...)
	}
	return nil
}

type packaginguspsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackagingUSPSPaginateOption
}

func newPackagingUSPSPaginateArgs(rv map[string]any) *packaginguspsPaginateArgs {
	args := &packaginguspsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PackagingUSPSWhereInput); ok {
		args.opts = append(args.opts, WithPackagingUSPSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pupc *PackagingUSPSProcessingCategoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackagingUSPSProcessingCategoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pupc, nil
	}
	if err := pupc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pupc, nil
}

func (pupc *PackagingUSPSProcessingCategoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packaginguspsprocessingcategory.Columns))
		selectedFields = []string{packaginguspsprocessingcategory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {
		case "name":
			if _, ok := fieldSeen[packaginguspsprocessingcategory.FieldName]; !ok {
				selectedFields = append(selectedFields, packaginguspsprocessingcategory.FieldName)
				fieldSeen[packaginguspsprocessingcategory.FieldName] = struct{}{}
			}
		case "processingCategory":
			if _, ok := fieldSeen[packaginguspsprocessingcategory.FieldProcessingCategory]; !ok {
				selectedFields = append(selectedFields, packaginguspsprocessingcategory.FieldProcessingCategory)
				fieldSeen[packaginguspsprocessingcategory.FieldProcessingCategory] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pupc.Select(selectedFields...)
	}
	return nil
}

type packaginguspsprocessingcategoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackagingUSPSProcessingCategoryPaginateOption
}

func newPackagingUSPSProcessingCategoryPaginateArgs(rv map[string]any) *packaginguspsprocessingcategoryPaginateArgs {
	args := &packaginguspsprocessingcategoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PackagingUSPSProcessingCategoryWhereInput); ok {
		args.opts = append(args.opts, WithPackagingUSPSProcessingCategoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (puri *PackagingUSPSRateIndicatorQuery) CollectFields(ctx context.Context, satisfies ...string) (*PackagingUSPSRateIndicatorQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return puri, nil
	}
	if err := puri.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return puri, nil
}

func (puri *PackagingUSPSRateIndicatorQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(packaginguspsrateindicator.Columns))
		selectedFields = []string{packaginguspsrateindicator.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "packagingUSPS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingUSPSClient{config: puri.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, packaginguspsImplementors)...); err != nil {
				return err
			}
			puri.WithNamedPackagingUSPS(alias, func(wq *PackagingUSPSQuery) {
				*wq = *query
			})
		case "code":
			if _, ok := fieldSeen[packaginguspsrateindicator.FieldCode]; !ok {
				selectedFields = append(selectedFields, packaginguspsrateindicator.FieldCode)
				fieldSeen[packaginguspsrateindicator.FieldCode] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[packaginguspsrateindicator.FieldName]; !ok {
				selectedFields = append(selectedFields, packaginguspsrateindicator.FieldName)
				fieldSeen[packaginguspsrateindicator.FieldName] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		puri.Select(selectedFields...)
	}
	return nil
}

type packaginguspsrateindicatorPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PackagingUSPSRateIndicatorPaginateOption
}

func newPackagingUSPSRateIndicatorPaginateArgs(rv map[string]any) *packaginguspsrateindicatorPaginateArgs {
	args := &packaginguspsrateindicatorPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PackagingUSPSRateIndicatorWhereInput); ok {
		args.opts = append(args.opts, WithPackagingUSPSRateIndicatorFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pa *PalletQuery) CollectFields(ctx context.Context, satisfies ...string) (*PalletQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pa, nil
	}
	if err := pa.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pa, nil
}

func (pa *PalletQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(pallet.Columns))
		selectedFields = []string{pallet.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pa.withTenant = query
			if _, ok := fieldSeen[pallet.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, pallet.FieldTenantID)
				fieldSeen[pallet.FieldTenantID] = struct{}{}
			}

		case "orders":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orderImplementors)...); err != nil {
				return err
			}
			pa.WithNamedOrders(alias, func(wq *OrderQuery) {
				*wq = *query
			})

		case "packaging":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packagingImplementors)...); err != nil {
				return err
			}
			pa.withPackaging = query

		case "consolidation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConsolidationClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, consolidationImplementors)...); err != nil {
				return err
			}
			pa.withConsolidation = query

		case "shipmentPallet":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentPalletClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentpalletImplementors)...); err != nil {
				return err
			}
			pa.withShipmentPallet = query

		case "cancelledShipmentPallet":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentPalletClient{config: pa.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, shipmentpalletImplementors)...); err != nil {
				return err
			}
			pa.WithNamedCancelledShipmentPallet(alias, func(wq *ShipmentPalletQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[pallet.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, pallet.FieldTenantID)
				fieldSeen[pallet.FieldTenantID] = struct{}{}
			}
		case "publicID":
			if _, ok := fieldSeen[pallet.FieldPublicID]; !ok {
				selectedFields = append(selectedFields, pallet.FieldPublicID)
				fieldSeen[pallet.FieldPublicID] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[pallet.FieldDescription]; !ok {
				selectedFields = append(selectedFields, pallet.FieldDescription)
				fieldSeen[pallet.FieldDescription] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pa.Select(selectedFields...)
	}
	return nil
}

type palletPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PalletPaginateOption
}

func newPalletPaginateArgs(rv map[string]any) *palletPaginateArgs {
	args := &palletPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PalletWhereInput); ok {
		args.opts = append(args.opts, WithPalletFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ps *ParcelShopQuery) CollectFields(ctx context.Context, satisfies ...string) (*ParcelShopQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ps, nil
	}
	if err := ps.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ps, nil
}

func (ps *ParcelShopQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(parcelshop.Columns))
		selectedFields = []string{parcelshop.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "parcelShopDAO":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopDAOClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopdaoImplementors)...); err != nil {
				return err
			}
			ps.withParcelShopDAO = query

		case "parcelShopPostNord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopPostNordClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshoppostnordImplementors)...); err != nil {
				return err
			}
			ps.withParcelShopPostNord = query

		case "parcelShopGLS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopGLSClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopglsImplementors)...); err != nil {
				return err
			}
			ps.withParcelShopGLS = query

		case "parcelShopBring":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopBringClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopbringImplementors)...); err != nil {
				return err
			}
			ps.withParcelShopBring = query

		case "carrierBrand":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierBrandClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierbrandImplementors)...); err != nil {
				return err
			}
			ps.withCarrierBrand = query

		case "address":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressGlobalClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressglobalImplementors)...); err != nil {
				return err
			}
			ps.withAddress = query

		case "colli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			ps.WithNamedColli(alias, func(wq *ColliQuery) {
				*wq = *query
			})

		case "businessHoursPeriod":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&BusinessHoursPeriodClient{config: ps.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, businesshoursperiodImplementors)...); err != nil {
				return err
			}
			ps.WithNamedBusinessHoursPeriod(alias, func(wq *BusinessHoursPeriodQuery) {
				*wq = *query
			})
		case "name":
			if _, ok := fieldSeen[parcelshop.FieldName]; !ok {
				selectedFields = append(selectedFields, parcelshop.FieldName)
				fieldSeen[parcelshop.FieldName] = struct{}{}
			}
		case "lastUpdated":
			if _, ok := fieldSeen[parcelshop.FieldLastUpdated]; !ok {
				selectedFields = append(selectedFields, parcelshop.FieldLastUpdated)
				fieldSeen[parcelshop.FieldLastUpdated] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ps.Select(selectedFields...)
	}
	return nil
}

type parcelshopPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ParcelShopPaginateOption
}

func newParcelShopPaginateArgs(rv map[string]any) *parcelshopPaginateArgs {
	args := &parcelshopPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ParcelShopWhereInput); ok {
		args.opts = append(args.opts, WithParcelShopFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (psb *ParcelShopBringQuery) CollectFields(ctx context.Context, satisfies ...string) (*ParcelShopBringQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return psb, nil
	}
	if err := psb.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return psb, nil
}

func (psb *ParcelShopBringQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(parcelshopbring.Columns))
		selectedFields = []string{parcelshopbring.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "parcelShop":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopClient{config: psb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopImplementors)...); err != nil {
				return err
			}
			psb.withParcelShop = query

		case "addressDelivery":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressGlobalClient{config: psb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressglobalImplementors)...); err != nil {
				return err
			}
			psb.withAddressDelivery = query
		case "pointType":
			if _, ok := fieldSeen[parcelshopbring.FieldPointType]; !ok {
				selectedFields = append(selectedFields, parcelshopbring.FieldPointType)
				fieldSeen[parcelshopbring.FieldPointType] = struct{}{}
			}
		case "bringID":
			if _, ok := fieldSeen[parcelshopbring.FieldBringID]; !ok {
				selectedFields = append(selectedFields, parcelshopbring.FieldBringID)
				fieldSeen[parcelshopbring.FieldBringID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		psb.Select(selectedFields...)
	}
	return nil
}

type parcelshopbringPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ParcelShopBringPaginateOption
}

func newParcelShopBringPaginateArgs(rv map[string]any) *parcelshopbringPaginateArgs {
	args := &parcelshopbringPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ParcelShopBringWhereInput); ok {
		args.opts = append(args.opts, WithParcelShopBringFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (psd *ParcelShopDAOQuery) CollectFields(ctx context.Context, satisfies ...string) (*ParcelShopDAOQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return psd, nil
	}
	if err := psd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return psd, nil
}

func (psd *ParcelShopDAOQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(parcelshopdao.Columns))
		selectedFields = []string{parcelshopdao.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "parcelShop":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopClient{config: psd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopImplementors)...); err != nil {
				return err
			}
			psd.withParcelShop = query
		case "shopID":
			if _, ok := fieldSeen[parcelshopdao.FieldShopID]; !ok {
				selectedFields = append(selectedFields, parcelshopdao.FieldShopID)
				fieldSeen[parcelshopdao.FieldShopID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		psd.Select(selectedFields...)
	}
	return nil
}

type parcelshopdaoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ParcelShopDAOPaginateOption
}

func newParcelShopDAOPaginateArgs(rv map[string]any) *parcelshopdaoPaginateArgs {
	args := &parcelshopdaoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ParcelShopDAOWhereInput); ok {
		args.opts = append(args.opts, WithParcelShopDAOFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (psg *ParcelShopGLSQuery) CollectFields(ctx context.Context, satisfies ...string) (*ParcelShopGLSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return psg, nil
	}
	if err := psg.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return psg, nil
}

func (psg *ParcelShopGLSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(parcelshopgls.Columns))
		selectedFields = []string{parcelshopgls.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "parcelShop":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopClient{config: psg.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopImplementors)...); err != nil {
				return err
			}
			psg.withParcelShop = query
		case "glsParcelShopID":
			if _, ok := fieldSeen[parcelshopgls.FieldGLSParcelShopID]; !ok {
				selectedFields = append(selectedFields, parcelshopgls.FieldGLSParcelShopID)
				fieldSeen[parcelshopgls.FieldGLSParcelShopID] = struct{}{}
			}
		case "partnerID":
			if _, ok := fieldSeen[parcelshopgls.FieldPartnerID]; !ok {
				selectedFields = append(selectedFields, parcelshopgls.FieldPartnerID)
				fieldSeen[parcelshopgls.FieldPartnerID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[parcelshopgls.FieldType]; !ok {
				selectedFields = append(selectedFields, parcelshopgls.FieldType)
				fieldSeen[parcelshopgls.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		psg.Select(selectedFields...)
	}
	return nil
}

type parcelshopglsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ParcelShopGLSPaginateOption
}

func newParcelShopGLSPaginateArgs(rv map[string]any) *parcelshopglsPaginateArgs {
	args := &parcelshopglsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ParcelShopGLSWhereInput); ok {
		args.opts = append(args.opts, WithParcelShopGLSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pspn *ParcelShopPostNordQuery) CollectFields(ctx context.Context, satisfies ...string) (*ParcelShopPostNordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pspn, nil
	}
	if err := pspn.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pspn, nil
}

func (pspn *ParcelShopPostNordQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(parcelshoppostnord.Columns))
		selectedFields = []string{parcelshoppostnord.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "parcelShop":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ParcelShopClient{config: pspn.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, parcelshopImplementors)...); err != nil {
				return err
			}
			pspn.withParcelShop = query

		case "addressDelivery":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressGlobalClient{config: pspn.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressglobalImplementors)...); err != nil {
				return err
			}
			pspn.withAddressDelivery = query
		case "servicePointID":
			if _, ok := fieldSeen[parcelshoppostnord.FieldServicePointID]; !ok {
				selectedFields = append(selectedFields, parcelshoppostnord.FieldServicePointID)
				fieldSeen[parcelshoppostnord.FieldServicePointID] = struct{}{}
			}
		case "pudoid":
			if _, ok := fieldSeen[parcelshoppostnord.FieldPudoid]; !ok {
				selectedFields = append(selectedFields, parcelshoppostnord.FieldPudoid)
				fieldSeen[parcelshoppostnord.FieldPudoid] = struct{}{}
			}
		case "typeID":
			if _, ok := fieldSeen[parcelshoppostnord.FieldTypeID]; !ok {
				selectedFields = append(selectedFields, parcelshoppostnord.FieldTypeID)
				fieldSeen[parcelshoppostnord.FieldTypeID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pspn.Select(selectedFields...)
	}
	return nil
}

type parcelshoppostnordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ParcelShopPostNordPaginateOption
}

func newParcelShopPostNordPaginateArgs(rv map[string]any) *parcelshoppostnordPaginateArgs {
	args := &parcelshoppostnordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ParcelShopPostNordWhereInput); ok {
		args.opts = append(args.opts, WithParcelShopPostNordFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pl *PlanQuery) CollectFields(ctx context.Context, satisfies ...string) (*PlanQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pl, nil
	}
	if err := pl.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pl, nil
}

func (pl *PlanQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(plan.Columns))
		selectedFields = []string{plan.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pl.WithNamedTenant(alias, func(wq *TenantQuery) {
				*wq = *query
			})

		case "planHistoryPlan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanHistoryClient{config: pl.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, planhistoryImplementors)...); err != nil {
				return err
			}
			pl.WithNamedPlanHistoryPlan(alias, func(wq *PlanHistoryQuery) {
				*wq = *query
			})
		case "label":
			if _, ok := fieldSeen[plan.FieldLabel]; !ok {
				selectedFields = append(selectedFields, plan.FieldLabel)
				fieldSeen[plan.FieldLabel] = struct{}{}
			}
		case "rank":
			if _, ok := fieldSeen[plan.FieldRank]; !ok {
				selectedFields = append(selectedFields, plan.FieldRank)
				fieldSeen[plan.FieldRank] = struct{}{}
			}
		case "priceDkk":
			if _, ok := fieldSeen[plan.FieldPriceDkk]; !ok {
				selectedFields = append(selectedFields, plan.FieldPriceDkk)
				fieldSeen[plan.FieldPriceDkk] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[plan.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, plan.FieldCreatedAt)
				fieldSeen[plan.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pl.Select(selectedFields...)
	}
	return nil
}

type planPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PlanPaginateOption
}

func newPlanPaginateArgs(rv map[string]any) *planPaginateArgs {
	args := &planPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PlanWhereInput); ok {
		args.opts = append(args.opts, WithPlanFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (ph *PlanHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*PlanHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return ph, nil
	}
	if err := ph.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return ph, nil
}

func (ph *PlanHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(planhistory.Columns))
		selectedFields = []string{planhistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "changeHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChangeHistoryClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, changehistoryImplementors)...); err != nil {
				return err
			}
			ph.withChangeHistory = query

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			ph.withTenant = query
			if _, ok := fieldSeen[planhistory.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, planhistory.FieldTenantID)
				fieldSeen[planhistory.FieldTenantID] = struct{}{}
			}

		case "changedBy":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			ph.withChangedBy = query

		case "changedFrom":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: ph.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, planImplementors)...); err != nil {
				return err
			}
			ph.withChangedFrom = query
		case "tenantID":
			if _, ok := fieldSeen[planhistory.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, planhistory.FieldTenantID)
				fieldSeen[planhistory.FieldTenantID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[planhistory.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, planhistory.FieldCreatedAt)
				fieldSeen[planhistory.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		ph.Select(selectedFields...)
	}
	return nil
}

type planhistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PlanHistoryPaginateOption
}

func newPlanHistoryPaginateArgs(rv map[string]any) *planhistoryPaginateArgs {
	args := &planhistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PlanHistoryWhereInput); ok {
		args.opts = append(args.opts, WithPlanHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pj *PrintJobQuery) CollectFields(ctx context.Context, satisfies ...string) (*PrintJobQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pj, nil
	}
	if err := pj.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pj, nil
}

func (pj *PrintJobQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(printjob.Columns))
		selectedFields = []string{printjob.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pj.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pj.withTenant = query
			if _, ok := fieldSeen[printjob.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, printjob.FieldTenantID)
				fieldSeen[printjob.FieldTenantID] = struct{}{}
			}

		case "printer":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PrinterClient{config: pj.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, printerImplementors)...); err != nil {
				return err
			}
			pj.withPrinter = query

		case "colli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: pj.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			pj.withColli = query

		case "shipmentParcel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentParcelClient{config: pj.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentparcelImplementors)...); err != nil {
				return err
			}
			pj.withShipmentParcel = query
		case "tenantID":
			if _, ok := fieldSeen[printjob.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, printjob.FieldTenantID)
				fieldSeen[printjob.FieldTenantID] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[printjob.FieldStatus]; !ok {
				selectedFields = append(selectedFields, printjob.FieldStatus)
				fieldSeen[printjob.FieldStatus] = struct{}{}
			}
		case "fileExtension":
			if _, ok := fieldSeen[printjob.FieldFileExtension]; !ok {
				selectedFields = append(selectedFields, printjob.FieldFileExtension)
				fieldSeen[printjob.FieldFileExtension] = struct{}{}
			}
		case "documentType":
			if _, ok := fieldSeen[printjob.FieldDocumentType]; !ok {
				selectedFields = append(selectedFields, printjob.FieldDocumentType)
				fieldSeen[printjob.FieldDocumentType] = struct{}{}
			}
		case "printerMessages":
			if _, ok := fieldSeen[printjob.FieldPrinterMessages]; !ok {
				selectedFields = append(selectedFields, printjob.FieldPrinterMessages)
				fieldSeen[printjob.FieldPrinterMessages] = struct{}{}
			}
		case "base64PrintData":
			if _, ok := fieldSeen[printjob.FieldBase64PrintData]; !ok {
				selectedFields = append(selectedFields, printjob.FieldBase64PrintData)
				fieldSeen[printjob.FieldBase64PrintData] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[printjob.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, printjob.FieldCreatedAt)
				fieldSeen[printjob.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pj.Select(selectedFields...)
	}
	return nil
}

type printjobPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PrintJobPaginateOption
}

func newPrintJobPaginateArgs(rv map[string]any) *printjobPaginateArgs {
	args := &printjobPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PrintJobWhereInput); ok {
		args.opts = append(args.opts, WithPrintJobFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *PrinterQuery) CollectFields(ctx context.Context, satisfies ...string) (*PrinterQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *PrinterQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(printer.Columns))
		selectedFields = []string{printer.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pr.withTenant = query
			if _, ok := fieldSeen[printer.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, printer.FieldTenantID)
				fieldSeen[printer.FieldTenantID] = struct{}{}
			}

		case "workstation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&WorkstationClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, workstationImplementors)...); err != nil {
				return err
			}
			pr.withWorkstation = query

		case "printJobs":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PrintJobClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, printjobImplementors)...); err != nil {
				return err
			}
			pr.WithNamedPrintJobs(alias, func(wq *PrintJobQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[printer.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, printer.FieldTenantID)
				fieldSeen[printer.FieldTenantID] = struct{}{}
			}
		case "deviceID":
			if _, ok := fieldSeen[printer.FieldDeviceID]; !ok {
				selectedFields = append(selectedFields, printer.FieldDeviceID)
				fieldSeen[printer.FieldDeviceID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[printer.FieldName]; !ok {
				selectedFields = append(selectedFields, printer.FieldName)
				fieldSeen[printer.FieldName] = struct{}{}
			}
		case "labelZpl":
			if _, ok := fieldSeen[printer.FieldLabelZpl]; !ok {
				selectedFields = append(selectedFields, printer.FieldLabelZpl)
				fieldSeen[printer.FieldLabelZpl] = struct{}{}
			}
		case "labelPdf":
			if _, ok := fieldSeen[printer.FieldLabelPdf]; !ok {
				selectedFields = append(selectedFields, printer.FieldLabelPdf)
				fieldSeen[printer.FieldLabelPdf] = struct{}{}
			}
		case "labelPng":
			if _, ok := fieldSeen[printer.FieldLabelPng]; !ok {
				selectedFields = append(selectedFields, printer.FieldLabelPng)
				fieldSeen[printer.FieldLabelPng] = struct{}{}
			}
		case "document":
			if _, ok := fieldSeen[printer.FieldDocument]; !ok {
				selectedFields = append(selectedFields, printer.FieldDocument)
				fieldSeen[printer.FieldDocument] = struct{}{}
			}
		case "rotate180":
			if _, ok := fieldSeen[printer.FieldRotate180]; !ok {
				selectedFields = append(selectedFields, printer.FieldRotate180)
				fieldSeen[printer.FieldRotate180] = struct{}{}
			}
		case "useShell":
			if _, ok := fieldSeen[printer.FieldUseShell]; !ok {
				selectedFields = append(selectedFields, printer.FieldUseShell)
				fieldSeen[printer.FieldUseShell] = struct{}{}
			}
		case "printSize":
			if _, ok := fieldSeen[printer.FieldPrintSize]; !ok {
				selectedFields = append(selectedFields, printer.FieldPrintSize)
				fieldSeen[printer.FieldPrintSize] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[printer.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, printer.FieldCreatedAt)
				fieldSeen[printer.FieldCreatedAt] = struct{}{}
			}
		case "lastPing":
			if _, ok := fieldSeen[printer.FieldLastPing]; !ok {
				selectedFields = append(selectedFields, printer.FieldLastPing)
				fieldSeen[printer.FieldLastPing] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type printerPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []PrinterPaginateOption
}

func newPrinterPaginateArgs(rv map[string]any) *printerPaginateArgs {
	args := &printerPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*PrinterWhereInput); ok {
		args.opts = append(args.opts, WithPrinterFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pr *ProductQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProductQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pr, nil
	}
	if err := pr.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pr, nil
}

func (pr *ProductQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(product.Columns))
		selectedFields = []string{product.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pr.withTenant = query
			if _, ok := fieldSeen[product.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, product.FieldTenantID)
				fieldSeen[product.FieldTenantID] = struct{}{}
			}

		case "productTags":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductTagClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, producttagImplementors)...); err != nil {
				return err
			}
			pr.WithNamedProductTags(alias, func(wq *ProductTagQuery) {
				*wq = *query
			})

		case "productVariant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductVariantClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, productvariantImplementors)...); err != nil {
				return err
			}
			pr.WithNamedProductVariant(alias, func(wq *ProductVariantQuery) {
				*wq = *query
			})

		case "productImage":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductImageClient{config: pr.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, productimageImplementors)...); err != nil {
				return err
			}
			pr.WithNamedProductImage(alias, func(wq *ProductImageQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[product.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, product.FieldTenantID)
				fieldSeen[product.FieldTenantID] = struct{}{}
			}
		case "externalID":
			if _, ok := fieldSeen[product.FieldExternalID]; !ok {
				selectedFields = append(selectedFields, product.FieldExternalID)
				fieldSeen[product.FieldExternalID] = struct{}{}
			}
		case "title":
			if _, ok := fieldSeen[product.FieldTitle]; !ok {
				selectedFields = append(selectedFields, product.FieldTitle)
				fieldSeen[product.FieldTitle] = struct{}{}
			}
		case "bodyHTML":
			if _, ok := fieldSeen[product.FieldBodyHTML]; !ok {
				selectedFields = append(selectedFields, product.FieldBodyHTML)
				fieldSeen[product.FieldBodyHTML] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[product.FieldStatus]; !ok {
				selectedFields = append(selectedFields, product.FieldStatus)
				fieldSeen[product.FieldStatus] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[product.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, product.FieldCreatedAt)
				fieldSeen[product.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[product.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, product.FieldUpdatedAt)
				fieldSeen[product.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pr.Select(selectedFields...)
	}
	return nil
}

type productPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProductPaginateOption
}

func newProductPaginateArgs(rv map[string]any) *productPaginateArgs {
	args := &productPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProductWhereInput); ok {
		args.opts = append(args.opts, WithProductFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pi *ProductImageQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProductImageQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pi, nil
	}
	if err := pi.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pi, nil
}

func (pi *ProductImageQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(productimage.Columns))
		selectedFields = []string{productimage.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pi.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pi.withTenant = query
			if _, ok := fieldSeen[productimage.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, productimage.FieldTenantID)
				fieldSeen[productimage.FieldTenantID] = struct{}{}
			}

		case "product":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductClient{config: pi.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, productImplementors)...); err != nil {
				return err
			}
			pi.withProduct = query

		case "productVariant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductVariantClient{config: pi.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, productvariantImplementors)...); err != nil {
				return err
			}
			pi.WithNamedProductVariant(alias, func(wq *ProductVariantQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[productimage.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, productimage.FieldTenantID)
				fieldSeen[productimage.FieldTenantID] = struct{}{}
			}
		case "externalID":
			if _, ok := fieldSeen[productimage.FieldExternalID]; !ok {
				selectedFields = append(selectedFields, productimage.FieldExternalID)
				fieldSeen[productimage.FieldExternalID] = struct{}{}
			}
		case "url":
			if _, ok := fieldSeen[productimage.FieldURL]; !ok {
				selectedFields = append(selectedFields, productimage.FieldURL)
				fieldSeen[productimage.FieldURL] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pi.Select(selectedFields...)
	}
	return nil
}

type productimagePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProductImagePaginateOption
}

func newProductImagePaginateArgs(rv map[string]any) *productimagePaginateArgs {
	args := &productimagePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProductImageWhereInput); ok {
		args.opts = append(args.opts, WithProductImageFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pt *ProductTagQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProductTagQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pt, nil
	}
	if err := pt.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pt, nil
}

func (pt *ProductTagQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(producttag.Columns))
		selectedFields = []string{producttag.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pt.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pt.withTenant = query
			if _, ok := fieldSeen[producttag.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, producttag.FieldTenantID)
				fieldSeen[producttag.FieldTenantID] = struct{}{}
			}

		case "products":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductClient{config: pt.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, productImplementors)...); err != nil {
				return err
			}
			pt.WithNamedProducts(alias, func(wq *ProductQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[producttag.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, producttag.FieldTenantID)
				fieldSeen[producttag.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[producttag.FieldName]; !ok {
				selectedFields = append(selectedFields, producttag.FieldName)
				fieldSeen[producttag.FieldName] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[producttag.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, producttag.FieldCreatedAt)
				fieldSeen[producttag.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pt.Select(selectedFields...)
	}
	return nil
}

type producttagPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProductTagPaginateOption
}

func newProductTagPaginateArgs(rv map[string]any) *producttagPaginateArgs {
	args := &producttagPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProductTagWhereInput); ok {
		args.opts = append(args.opts, WithProductTagFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (pv *ProductVariantQuery) CollectFields(ctx context.Context, satisfies ...string) (*ProductVariantQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return pv, nil
	}
	if err := pv.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return pv, nil
}

func (pv *ProductVariantQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(productvariant.Columns))
		selectedFields = []string{productvariant.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: pv.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			pv.withTenant = query
			if _, ok := fieldSeen[productvariant.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldTenantID)
				fieldSeen[productvariant.FieldTenantID] = struct{}{}
			}

		case "product":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductClient{config: pv.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, productImplementors)...); err != nil {
				return err
			}
			pv.withProduct = query

		case "orderLines":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderLineClient{config: pv.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, orderlineImplementors)...); err != nil {
				return err
			}
			pv.WithNamedOrderLines(alias, func(wq *OrderLineQuery) {
				*wq = *query
			})

		case "productImage":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ProductImageClient{config: pv.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, productimageImplementors)...); err != nil {
				return err
			}
			pv.WithNamedProductImage(alias, func(wq *ProductImageQuery) {
				*wq = *query
			})

		case "inventoryItem":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&InventoryItemClient{config: pv.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, inventoryitemImplementors)...); err != nil {
				return err
			}
			pv.withInventoryItem = query
		case "tenantID":
			if _, ok := fieldSeen[productvariant.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldTenantID)
				fieldSeen[productvariant.FieldTenantID] = struct{}{}
			}
		case "archived":
			if _, ok := fieldSeen[productvariant.FieldArchived]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldArchived)
				fieldSeen[productvariant.FieldArchived] = struct{}{}
			}
		case "externalID":
			if _, ok := fieldSeen[productvariant.FieldExternalID]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldExternalID)
				fieldSeen[productvariant.FieldExternalID] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[productvariant.FieldDescription]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldDescription)
				fieldSeen[productvariant.FieldDescription] = struct{}{}
			}
		case "eanNumber":
			if _, ok := fieldSeen[productvariant.FieldEanNumber]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldEanNumber)
				fieldSeen[productvariant.FieldEanNumber] = struct{}{}
			}
		case "weightG":
			if _, ok := fieldSeen[productvariant.FieldWeightG]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldWeightG)
				fieldSeen[productvariant.FieldWeightG] = struct{}{}
			}
		case "dimensionLength":
			if _, ok := fieldSeen[productvariant.FieldDimensionLength]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldDimensionLength)
				fieldSeen[productvariant.FieldDimensionLength] = struct{}{}
			}
		case "dimensionWidth":
			if _, ok := fieldSeen[productvariant.FieldDimensionWidth]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldDimensionWidth)
				fieldSeen[productvariant.FieldDimensionWidth] = struct{}{}
			}
		case "dimensionHeight":
			if _, ok := fieldSeen[productvariant.FieldDimensionHeight]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldDimensionHeight)
				fieldSeen[productvariant.FieldDimensionHeight] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[productvariant.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldCreatedAt)
				fieldSeen[productvariant.FieldCreatedAt] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[productvariant.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, productvariant.FieldUpdatedAt)
				fieldSeen[productvariant.FieldUpdatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		pv.Select(selectedFields...)
	}
	return nil
}

type productvariantPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ProductVariantPaginateOption
}

func newProductVariantPaginateArgs(rv map[string]any) *productvariantPaginateArgs {
	args := &productvariantPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ProductVariantWhereInput); ok {
		args.opts = append(args.opts, WithProductVariantFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rc *ReturnColliQuery) CollectFields(ctx context.Context, satisfies ...string) (*ReturnColliQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rc, nil
	}
	if err := rc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rc, nil
}

func (rc *ReturnColliQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(returncolli.Columns))
		selectedFields = []string{returncolli.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			rc.withTenant = query
			if _, ok := fieldSeen[returncolli.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldTenantID)
				fieldSeen[returncolli.FieldTenantID] = struct{}{}
			}

		case "recipient":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressImplementors)...); err != nil {
				return err
			}
			rc.withRecipient = query

		case "sender":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressImplementors)...); err != nil {
				return err
			}
			rc.withSender = query

		case "order":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, orderImplementors)...); err != nil {
				return err
			}
			rc.withOrder = query

		case "deliveryOption":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			rc.withDeliveryOption = query

		case "returnPortal":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, returnportalImplementors)...); err != nil {
				return err
			}
			rc.withReturnPortal = query

		case "packaging":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packagingImplementors)...); err != nil {
				return err
			}
			rc.withPackaging = query

		case "returnOrderLine":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnOrderLineClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returnorderlineImplementors)...); err != nil {
				return err
			}
			rc.WithNamedReturnOrderLine(alias, func(wq *ReturnOrderLineQuery) {
				*wq = *query
			})

		case "returnColliHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnColliHistoryClient{config: rc.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returncollihistoryImplementors)...); err != nil {
				return err
			}
			rc.WithNamedReturnColliHistory(alias, func(wq *ReturnColliHistoryQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[returncolli.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldTenantID)
				fieldSeen[returncolli.FieldTenantID] = struct{}{}
			}
		case "expectedAt":
			if _, ok := fieldSeen[returncolli.FieldExpectedAt]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldExpectedAt)
				fieldSeen[returncolli.FieldExpectedAt] = struct{}{}
			}
		case "labelPdf":
			if _, ok := fieldSeen[returncolli.FieldLabelPdf]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldLabelPdf)
				fieldSeen[returncolli.FieldLabelPdf] = struct{}{}
			}
		case "labelPng":
			if _, ok := fieldSeen[returncolli.FieldLabelPng]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldLabelPng)
				fieldSeen[returncolli.FieldLabelPng] = struct{}{}
			}
		case "qrCodePng":
			if _, ok := fieldSeen[returncolli.FieldQrCodePng]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldQrCodePng)
				fieldSeen[returncolli.FieldQrCodePng] = struct{}{}
			}
		case "comment":
			if _, ok := fieldSeen[returncolli.FieldComment]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldComment)
				fieldSeen[returncolli.FieldComment] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[returncolli.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldCreatedAt)
				fieldSeen[returncolli.FieldCreatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[returncolli.FieldStatus]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldStatus)
				fieldSeen[returncolli.FieldStatus] = struct{}{}
			}
		case "emailReceived":
			if _, ok := fieldSeen[returncolli.FieldEmailReceived]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldEmailReceived)
				fieldSeen[returncolli.FieldEmailReceived] = struct{}{}
			}
		case "emailAccepted":
			if _, ok := fieldSeen[returncolli.FieldEmailAccepted]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldEmailAccepted)
				fieldSeen[returncolli.FieldEmailAccepted] = struct{}{}
			}
		case "emailConfirmationLabel":
			if _, ok := fieldSeen[returncolli.FieldEmailConfirmationLabel]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldEmailConfirmationLabel)
				fieldSeen[returncolli.FieldEmailConfirmationLabel] = struct{}{}
			}
		case "emailConfirmationQrCode":
			if _, ok := fieldSeen[returncolli.FieldEmailConfirmationQrCode]; !ok {
				selectedFields = append(selectedFields, returncolli.FieldEmailConfirmationQrCode)
				fieldSeen[returncolli.FieldEmailConfirmationQrCode] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		rc.Select(selectedFields...)
	}
	return nil
}

type returncolliPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ReturnColliPaginateOption
}

func newReturnColliPaginateArgs(rv map[string]any) *returncolliPaginateArgs {
	args := &returncolliPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ReturnColliOrder{Field: &ReturnColliOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithReturnColliOrder(order))
			}
		case *ReturnColliOrder:
			if v != nil {
				args.opts = append(args.opts, WithReturnColliOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ReturnColliWhereInput); ok {
		args.opts = append(args.opts, WithReturnColliFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rch *ReturnColliHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ReturnColliHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rch, nil
	}
	if err := rch.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rch, nil
}

func (rch *ReturnColliHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(returncollihistory.Columns))
		selectedFields = []string{returncollihistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "changeHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChangeHistoryClient{config: rch.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, changehistoryImplementors)...); err != nil {
				return err
			}
			rch.withChangeHistory = query

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: rch.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			rch.withTenant = query
			if _, ok := fieldSeen[returncollihistory.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, returncollihistory.FieldTenantID)
				fieldSeen[returncollihistory.FieldTenantID] = struct{}{}
			}

		case "returnColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnColliClient{config: rch.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, returncolliImplementors)...); err != nil {
				return err
			}
			rch.withReturnColli = query
		case "tenantID":
			if _, ok := fieldSeen[returncollihistory.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, returncollihistory.FieldTenantID)
				fieldSeen[returncollihistory.FieldTenantID] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[returncollihistory.FieldDescription]; !ok {
				selectedFields = append(selectedFields, returncollihistory.FieldDescription)
				fieldSeen[returncollihistory.FieldDescription] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[returncollihistory.FieldType]; !ok {
				selectedFields = append(selectedFields, returncollihistory.FieldType)
				fieldSeen[returncollihistory.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		rch.Select(selectedFields...)
	}
	return nil
}

type returncollihistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ReturnColliHistoryPaginateOption
}

func newReturnColliHistoryPaginateArgs(rv map[string]any) *returncollihistoryPaginateArgs {
	args := &returncollihistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ReturnColliHistoryWhereInput); ok {
		args.opts = append(args.opts, WithReturnColliHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rol *ReturnOrderLineQuery) CollectFields(ctx context.Context, satisfies ...string) (*ReturnOrderLineQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rol, nil
	}
	if err := rol.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rol, nil
}

func (rol *ReturnOrderLineQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(returnorderline.Columns))
		selectedFields = []string{returnorderline.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: rol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			rol.withTenant = query
			if _, ok := fieldSeen[returnorderline.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, returnorderline.FieldTenantID)
				fieldSeen[returnorderline.FieldTenantID] = struct{}{}
			}

		case "returnColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnColliClient{config: rol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, returncolliImplementors)...); err != nil {
				return err
			}
			rol.withReturnColli = query

		case "orderLine":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OrderLineClient{config: rol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, orderlineImplementors)...); err != nil {
				return err
			}
			rol.withOrderLine = query

		case "returnPortalClaim":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClaimClient{config: rol.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, returnportalclaimImplementors)...); err != nil {
				return err
			}
			rol.withReturnPortalClaim = query
		case "tenantID":
			if _, ok := fieldSeen[returnorderline.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, returnorderline.FieldTenantID)
				fieldSeen[returnorderline.FieldTenantID] = struct{}{}
			}
		case "units":
			if _, ok := fieldSeen[returnorderline.FieldUnits]; !ok {
				selectedFields = append(selectedFields, returnorderline.FieldUnits)
				fieldSeen[returnorderline.FieldUnits] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		rol.Select(selectedFields...)
	}
	return nil
}

type returnorderlinePaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ReturnOrderLinePaginateOption
}

func newReturnOrderLinePaginateArgs(rv map[string]any) *returnorderlinePaginateArgs {
	args := &returnorderlinePaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ReturnOrderLineWhereInput); ok {
		args.opts = append(args.opts, WithReturnOrderLineFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rp *ReturnPortalQuery) CollectFields(ctx context.Context, satisfies ...string) (*ReturnPortalQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rp, nil
	}
	if err := rp.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rp, nil
}

func (rp *ReturnPortalQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(returnportal.Columns))
		selectedFields = []string{returnportal.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: rp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			rp.withTenant = query
			if _, ok := fieldSeen[returnportal.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, returnportal.FieldTenantID)
				fieldSeen[returnportal.FieldTenantID] = struct{}{}
			}

		case "returnPortalClaim":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClaimClient{config: rp.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returnportalclaimImplementors)...); err != nil {
				return err
			}
			rp.WithNamedReturnPortalClaim(alias, func(wq *ReturnPortalClaimQuery) {
				*wq = *query
			})

		case "returnLocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: rp.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			rp.WithNamedReturnLocation(alias, func(wq *LocationQuery) {
				*wq = *query
			})

		case "deliveryOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DeliveryOptionClient{config: rp.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, deliveryoptionImplementors)...); err != nil {
				return err
			}
			rp.WithNamedDeliveryOptions(alias, func(wq *DeliveryOptionQuery) {
				*wq = *query
			})

		case "connection":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectionClient{config: rp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, connectionImplementors)...); err != nil {
				return err
			}
			rp.withConnection = query

		case "emailConfirmationLabel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EmailTemplateClient{config: rp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, emailtemplateImplementors)...); err != nil {
				return err
			}
			rp.withEmailConfirmationLabel = query

		case "emailConfirmationQrCode":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EmailTemplateClient{config: rp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, emailtemplateImplementors)...); err != nil {
				return err
			}
			rp.withEmailConfirmationQrCode = query

		case "emailReceived":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EmailTemplateClient{config: rp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, emailtemplateImplementors)...); err != nil {
				return err
			}
			rp.withEmailReceived = query

		case "emailAccepted":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&EmailTemplateClient{config: rp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, emailtemplateImplementors)...); err != nil {
				return err
			}
			rp.withEmailAccepted = query

		case "returnColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnColliClient{config: rp.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returncolliImplementors)...); err != nil {
				return err
			}
			rp.WithNamedReturnColli(alias, func(wq *ReturnColliQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[returnportal.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, returnportal.FieldTenantID)
				fieldSeen[returnportal.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[returnportal.FieldName]; !ok {
				selectedFields = append(selectedFields, returnportal.FieldName)
				fieldSeen[returnportal.FieldName] = struct{}{}
			}
		case "returnOpenHours":
			if _, ok := fieldSeen[returnportal.FieldReturnOpenHours]; !ok {
				selectedFields = append(selectedFields, returnportal.FieldReturnOpenHours)
				fieldSeen[returnportal.FieldReturnOpenHours] = struct{}{}
			}
		case "automaticallyAccept":
			if _, ok := fieldSeen[returnportal.FieldAutomaticallyAccept]; !ok {
				selectedFields = append(selectedFields, returnportal.FieldAutomaticallyAccept)
				fieldSeen[returnportal.FieldAutomaticallyAccept] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		rp.Select(selectedFields...)
	}
	return nil
}

type returnportalPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ReturnPortalPaginateOption
}

func newReturnPortalPaginateArgs(rv map[string]any) *returnportalPaginateArgs {
	args := &returnportalPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ReturnPortalWhereInput); ok {
		args.opts = append(args.opts, WithReturnPortalFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (rpc *ReturnPortalClaimQuery) CollectFields(ctx context.Context, satisfies ...string) (*ReturnPortalClaimQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return rpc, nil
	}
	if err := rpc.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return rpc, nil
}

func (rpc *ReturnPortalClaimQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(returnportalclaim.Columns))
		selectedFields = []string{returnportalclaim.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: rpc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			rpc.withTenant = query
			if _, ok := fieldSeen[returnportalclaim.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, returnportalclaim.FieldTenantID)
				fieldSeen[returnportalclaim.FieldTenantID] = struct{}{}
			}

		case "returnPortal":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnPortalClient{config: rpc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, returnportalImplementors)...); err != nil {
				return err
			}
			rpc.withReturnPortal = query

		case "returnLocation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LocationClient{config: rpc.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, locationImplementors)...); err != nil {
				return err
			}
			rpc.withReturnLocation = query

		case "returnOrderLine":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ReturnOrderLineClient{config: rpc.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, returnorderlineImplementors)...); err != nil {
				return err
			}
			rpc.WithNamedReturnOrderLine(alias, func(wq *ReturnOrderLineQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[returnportalclaim.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, returnportalclaim.FieldTenantID)
				fieldSeen[returnportalclaim.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[returnportalclaim.FieldName]; !ok {
				selectedFields = append(selectedFields, returnportalclaim.FieldName)
				fieldSeen[returnportalclaim.FieldName] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[returnportalclaim.FieldDescription]; !ok {
				selectedFields = append(selectedFields, returnportalclaim.FieldDescription)
				fieldSeen[returnportalclaim.FieldDescription] = struct{}{}
			}
		case "restockable":
			if _, ok := fieldSeen[returnportalclaim.FieldRestockable]; !ok {
				selectedFields = append(selectedFields, returnportalclaim.FieldRestockable)
				fieldSeen[returnportalclaim.FieldRestockable] = struct{}{}
			}
		case "archived":
			if _, ok := fieldSeen[returnportalclaim.FieldArchived]; !ok {
				selectedFields = append(selectedFields, returnportalclaim.FieldArchived)
				fieldSeen[returnportalclaim.FieldArchived] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		rpc.Select(selectedFields...)
	}
	return nil
}

type returnportalclaimPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ReturnPortalClaimPaginateOption
}

func newReturnPortalClaimPaginateArgs(rv map[string]any) *returnportalclaimPaginateArgs {
	args := &returnportalclaimPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ReturnPortalClaimWhereInput); ok {
		args.opts = append(args.opts, WithReturnPortalClaimFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sg *SeatGroupQuery) CollectFields(ctx context.Context, satisfies ...string) (*SeatGroupQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sg, nil
	}
	if err := sg.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sg, nil
}

func (sg *SeatGroupQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(seatgroup.Columns))
		selectedFields = []string{seatgroup.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sg.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sg.withTenant = query
			if _, ok := fieldSeen[seatgroup.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, seatgroup.FieldTenantID)
				fieldSeen[seatgroup.FieldTenantID] = struct{}{}
			}

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: sg.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			sg.WithNamedUser(alias, func(wq *UserQuery) {
				*wq = *query
			})

		case "assignedAccessRight":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AccessRightClient{config: sg.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, accessrightImplementors)...); err != nil {
				return err
			}
			sg.WithNamedAssignedAccessRight(alias, func(wq *AccessRightQuery) {
				*wq = *query
			})

		case "seatGroupAccessRight":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SeatGroupAccessRightClient{config: sg.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, seatgroupaccessrightImplementors)...); err != nil {
				return err
			}
			sg.WithNamedSeatGroupAccessRight(alias, func(wq *SeatGroupAccessRightQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[seatgroup.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, seatgroup.FieldTenantID)
				fieldSeen[seatgroup.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[seatgroup.FieldName]; !ok {
				selectedFields = append(selectedFields, seatgroup.FieldName)
				fieldSeen[seatgroup.FieldName] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[seatgroup.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, seatgroup.FieldCreatedAt)
				fieldSeen[seatgroup.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sg.Select(selectedFields...)
	}
	return nil
}

type seatgroupPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SeatGroupPaginateOption
}

func newSeatGroupPaginateArgs(rv map[string]any) *seatgroupPaginateArgs {
	args := &seatgroupPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SeatGroupWhereInput); ok {
		args.opts = append(args.opts, WithSeatGroupFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sgar *SeatGroupAccessRightQuery) CollectFields(ctx context.Context, satisfies ...string) (*SeatGroupAccessRightQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sgar, nil
	}
	if err := sgar.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sgar, nil
}

func (sgar *SeatGroupAccessRightQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(seatgroupaccessright.Columns))
		selectedFields = []string{seatgroupaccessright.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sgar.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sgar.withTenant = query
			if _, ok := fieldSeen[seatgroupaccessright.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, seatgroupaccessright.FieldTenantID)
				fieldSeen[seatgroupaccessright.FieldTenantID] = struct{}{}
			}

		case "accessRight":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AccessRightClient{config: sgar.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, accessrightImplementors)...); err != nil {
				return err
			}
			sgar.withAccessRight = query
			if _, ok := fieldSeen[seatgroupaccessright.FieldAccessRightID]; !ok {
				selectedFields = append(selectedFields, seatgroupaccessright.FieldAccessRightID)
				fieldSeen[seatgroupaccessright.FieldAccessRightID] = struct{}{}
			}

		case "seatGroup":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SeatGroupClient{config: sgar.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, seatgroupImplementors)...); err != nil {
				return err
			}
			sgar.withSeatGroup = query
			if _, ok := fieldSeen[seatgroupaccessright.FieldSeatGroupID]; !ok {
				selectedFields = append(selectedFields, seatgroupaccessright.FieldSeatGroupID)
				fieldSeen[seatgroupaccessright.FieldSeatGroupID] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[seatgroupaccessright.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, seatgroupaccessright.FieldTenantID)
				fieldSeen[seatgroupaccessright.FieldTenantID] = struct{}{}
			}
		case "level":
			if _, ok := fieldSeen[seatgroupaccessright.FieldLevel]; !ok {
				selectedFields = append(selectedFields, seatgroupaccessright.FieldLevel)
				fieldSeen[seatgroupaccessright.FieldLevel] = struct{}{}
			}
		case "accessRightID":
			if _, ok := fieldSeen[seatgroupaccessright.FieldAccessRightID]; !ok {
				selectedFields = append(selectedFields, seatgroupaccessright.FieldAccessRightID)
				fieldSeen[seatgroupaccessright.FieldAccessRightID] = struct{}{}
			}
		case "seatGroupID":
			if _, ok := fieldSeen[seatgroupaccessright.FieldSeatGroupID]; !ok {
				selectedFields = append(selectedFields, seatgroupaccessright.FieldSeatGroupID)
				fieldSeen[seatgroupaccessright.FieldSeatGroupID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sgar.Select(selectedFields...)
	}
	return nil
}

type seatgroupaccessrightPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SeatGroupAccessRightPaginateOption
}

func newSeatGroupAccessRightPaginateArgs(rv map[string]any) *seatgroupaccessrightPaginateArgs {
	args := &seatgroupaccessrightPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SeatGroupAccessRightWhereInput); ok {
		args.opts = append(args.opts, WithSeatGroupAccessRightFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (s *ShipmentQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return s, nil
	}
	if err := s.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return s, nil
}

func (s *ShipmentQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipment.Columns))
		selectedFields = []string{shipment.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			s.withTenant = query
			if _, ok := fieldSeen[shipment.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipment.FieldTenantID)
				fieldSeen[shipment.FieldTenantID] = struct{}{}
			}

		case "carrier":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&CarrierClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, carrierImplementors)...); err != nil {
				return err
			}
			s.withCarrier = query

		case "shipmentHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentHistoryClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, shipmenthistoryImplementors)...); err != nil {
				return err
			}
			s.WithNamedShipmentHistory(alias, func(wq *ShipmentHistoryQuery) {
				*wq = *query
			})

		case "shipmentBring":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentBringClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentbringImplementors)...); err != nil {
				return err
			}
			s.withShipmentBring = query

		case "shipmentDAO":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentDAOClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentdaoImplementors)...); err != nil {
				return err
			}
			s.withShipmentDAO = query

		case "shipmentDF":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentDFClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentdfImplementors)...); err != nil {
				return err
			}
			s.withShipmentDF = query

		case "shipmentDSV":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentDSVClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentdsvImplementors)...); err != nil {
				return err
			}
			s.withShipmentDSV = query

		case "shipmentEasyPost":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentEasyPostClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmenteasypostImplementors)...); err != nil {
				return err
			}
			s.withShipmentEasyPost = query

		case "shipmentPostNord":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentPostNordClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentpostnordImplementors)...); err != nil {
				return err
			}
			s.withShipmentPostNord = query

		case "shipmentGLS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentGLSClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentglsImplementors)...); err != nil {
				return err
			}
			s.withShipmentGLS = query

		case "shipmentUSPS":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentUSPSClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentuspsImplementors)...); err != nil {
				return err
			}
			s.withShipmentUSPS = query

		case "consolidation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConsolidationClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, consolidationImplementors)...); err != nil {
				return err
			}
			s.withConsolidation = query

		case "oldConsolidation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConsolidationClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, consolidationImplementors)...); err != nil {
				return err
			}
			s.WithNamedOldConsolidation(alias, func(wq *ConsolidationQuery) {
				*wq = *query
			})

		case "shipmentParcel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentParcelClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, shipmentparcelImplementors)...); err != nil {
				return err
			}
			s.WithNamedShipmentParcel(alias, func(wq *ShipmentParcelQuery) {
				*wq = *query
			})

		case "shipmentPallet":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentPalletClient{config: s.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, shipmentpalletImplementors)...); err != nil {
				return err
			}
			s.WithNamedShipmentPallet(alias, func(wq *ShipmentPalletQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[shipment.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipment.FieldTenantID)
				fieldSeen[shipment.FieldTenantID] = struct{}{}
			}
		case "shipmentPublicID":
			if _, ok := fieldSeen[shipment.FieldShipmentPublicID]; !ok {
				selectedFields = append(selectedFields, shipment.FieldShipmentPublicID)
				fieldSeen[shipment.FieldShipmentPublicID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[shipment.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, shipment.FieldCreatedAt)
				fieldSeen[shipment.FieldCreatedAt] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[shipment.FieldStatus]; !ok {
				selectedFields = append(selectedFields, shipment.FieldStatus)
				fieldSeen[shipment.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		s.Select(selectedFields...)
	}
	return nil
}

type shipmentPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentPaginateOption
}

func newShipmentPaginateArgs(rv map[string]any) *shipmentPaginateArgs {
	args := &shipmentPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ShipmentOrder{Field: &ShipmentOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithShipmentOrder(order))
			}
		case *ShipmentOrder:
			if v != nil {
				args.opts = append(args.opts, WithShipmentOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ShipmentWhereInput); ok {
		args.opts = append(args.opts, WithShipmentFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sb *ShipmentBringQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentBringQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sb, nil
	}
	if err := sb.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sb, nil
}

func (sb *ShipmentBringQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmentbring.Columns))
		selectedFields = []string{shipmentbring.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sb.withTenant = query
			if _, ok := fieldSeen[shipmentbring.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentbring.FieldTenantID)
				fieldSeen[shipmentbring.FieldTenantID] = struct{}{}
			}

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: sb.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			sb.withShipment = query
		case "tenantID":
			if _, ok := fieldSeen[shipmentbring.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentbring.FieldTenantID)
				fieldSeen[shipmentbring.FieldTenantID] = struct{}{}
			}
		case "consignmentNumber":
			if _, ok := fieldSeen[shipmentbring.FieldConsignmentNumber]; !ok {
				selectedFields = append(selectedFields, shipmentbring.FieldConsignmentNumber)
				fieldSeen[shipmentbring.FieldConsignmentNumber] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sb.Select(selectedFields...)
	}
	return nil
}

type shipmentbringPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentBringPaginateOption
}

func newShipmentBringPaginateArgs(rv map[string]any) *shipmentbringPaginateArgs {
	args := &shipmentbringPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ShipmentBringWhereInput); ok {
		args.opts = append(args.opts, WithShipmentBringFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sd *ShipmentDAOQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentDAOQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sd, nil
	}
	if err := sd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sd, nil
}

func (sd *ShipmentDAOQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmentdao.Columns))
		selectedFields = []string{shipmentdao.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sd.withTenant = query
			if _, ok := fieldSeen[shipmentdao.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentdao.FieldTenantID)
				fieldSeen[shipmentdao.FieldTenantID] = struct{}{}
			}

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: sd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			sd.withShipment = query
		case "tenantID":
			if _, ok := fieldSeen[shipmentdao.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentdao.FieldTenantID)
				fieldSeen[shipmentdao.FieldTenantID] = struct{}{}
			}
		case "barcodeID":
			if _, ok := fieldSeen[shipmentdao.FieldBarcodeID]; !ok {
				selectedFields = append(selectedFields, shipmentdao.FieldBarcodeID)
				fieldSeen[shipmentdao.FieldBarcodeID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sd.Select(selectedFields...)
	}
	return nil
}

type shipmentdaoPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentDAOPaginateOption
}

func newShipmentDAOPaginateArgs(rv map[string]any) *shipmentdaoPaginateArgs {
	args := &shipmentdaoPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ShipmentDAOWhereInput); ok {
		args.opts = append(args.opts, WithShipmentDAOFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sd *ShipmentDFQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentDFQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sd, nil
	}
	if err := sd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sd, nil
}

func (sd *ShipmentDFQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmentdf.Columns))
		selectedFields = []string{shipmentdf.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sd.withTenant = query
			if _, ok := fieldSeen[shipmentdf.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentdf.FieldTenantID)
				fieldSeen[shipmentdf.FieldTenantID] = struct{}{}
			}

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: sd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			sd.withShipment = query
		case "tenantID":
			if _, ok := fieldSeen[shipmentdf.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentdf.FieldTenantID)
				fieldSeen[shipmentdf.FieldTenantID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sd.Select(selectedFields...)
	}
	return nil
}

type shipmentdfPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentDFPaginateOption
}

func newShipmentDFPaginateArgs(rv map[string]any) *shipmentdfPaginateArgs {
	args := &shipmentdfPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ShipmentDFWhereInput); ok {
		args.opts = append(args.opts, WithShipmentDFFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sd *ShipmentDSVQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentDSVQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sd, nil
	}
	if err := sd.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sd, nil
}

func (sd *ShipmentDSVQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmentdsv.Columns))
		selectedFields = []string{shipmentdsv.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sd.withTenant = query
			if _, ok := fieldSeen[shipmentdsv.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentdsv.FieldTenantID)
				fieldSeen[shipmentdsv.FieldTenantID] = struct{}{}
			}

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: sd.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			sd.withShipment = query
		case "tenantID":
			if _, ok := fieldSeen[shipmentdsv.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentdsv.FieldTenantID)
				fieldSeen[shipmentdsv.FieldTenantID] = struct{}{}
			}
		case "barcodeID":
			if _, ok := fieldSeen[shipmentdsv.FieldBarcodeID]; !ok {
				selectedFields = append(selectedFields, shipmentdsv.FieldBarcodeID)
				fieldSeen[shipmentdsv.FieldBarcodeID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sd.Select(selectedFields...)
	}
	return nil
}

type shipmentdsvPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentDSVPaginateOption
}

func newShipmentDSVPaginateArgs(rv map[string]any) *shipmentdsvPaginateArgs {
	args := &shipmentdsvPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ShipmentDSVWhereInput); ok {
		args.opts = append(args.opts, WithShipmentDSVFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sep *ShipmentEasyPostQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentEasyPostQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sep, nil
	}
	if err := sep.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sep, nil
}

func (sep *ShipmentEasyPostQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmenteasypost.Columns))
		selectedFields = []string{shipmenteasypost.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sep.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sep.withTenant = query
			if _, ok := fieldSeen[shipmenteasypost.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmenteasypost.FieldTenantID)
				fieldSeen[shipmenteasypost.FieldTenantID] = struct{}{}
			}

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: sep.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			sep.withShipment = query
		case "tenantID":
			if _, ok := fieldSeen[shipmenteasypost.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmenteasypost.FieldTenantID)
				fieldSeen[shipmenteasypost.FieldTenantID] = struct{}{}
			}
		case "trackingNumber":
			if _, ok := fieldSeen[shipmenteasypost.FieldTrackingNumber]; !ok {
				selectedFields = append(selectedFields, shipmenteasypost.FieldTrackingNumber)
				fieldSeen[shipmenteasypost.FieldTrackingNumber] = struct{}{}
			}
		case "epShipmentID":
			if _, ok := fieldSeen[shipmenteasypost.FieldEpShipmentID]; !ok {
				selectedFields = append(selectedFields, shipmenteasypost.FieldEpShipmentID)
				fieldSeen[shipmenteasypost.FieldEpShipmentID] = struct{}{}
			}
		case "rate":
			if _, ok := fieldSeen[shipmenteasypost.FieldRate]; !ok {
				selectedFields = append(selectedFields, shipmenteasypost.FieldRate)
				fieldSeen[shipmenteasypost.FieldRate] = struct{}{}
			}
		case "estDeliveryDate":
			if _, ok := fieldSeen[shipmenteasypost.FieldEstDeliveryDate]; !ok {
				selectedFields = append(selectedFields, shipmenteasypost.FieldEstDeliveryDate)
				fieldSeen[shipmenteasypost.FieldEstDeliveryDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sep.Select(selectedFields...)
	}
	return nil
}

type shipmenteasypostPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentEasyPostPaginateOption
}

func newShipmentEasyPostPaginateArgs(rv map[string]any) *shipmenteasypostPaginateArgs {
	args := &shipmenteasypostPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ShipmentEasyPostWhereInput); ok {
		args.opts = append(args.opts, WithShipmentEasyPostFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sg *ShipmentGLSQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentGLSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sg, nil
	}
	if err := sg.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sg, nil
}

func (sg *ShipmentGLSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmentgls.Columns))
		selectedFields = []string{shipmentgls.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sg.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sg.withTenant = query
			if _, ok := fieldSeen[shipmentgls.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentgls.FieldTenantID)
				fieldSeen[shipmentgls.FieldTenantID] = struct{}{}
			}

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: sg.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			sg.withShipment = query
		case "tenantID":
			if _, ok := fieldSeen[shipmentgls.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentgls.FieldTenantID)
				fieldSeen[shipmentgls.FieldTenantID] = struct{}{}
			}
		case "consignmentID":
			if _, ok := fieldSeen[shipmentgls.FieldConsignmentID]; !ok {
				selectedFields = append(selectedFields, shipmentgls.FieldConsignmentID)
				fieldSeen[shipmentgls.FieldConsignmentID] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sg.Select(selectedFields...)
	}
	return nil
}

type shipmentglsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentGLSPaginateOption
}

func newShipmentGLSPaginateArgs(rv map[string]any) *shipmentglsPaginateArgs {
	args := &shipmentglsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ShipmentGLSWhereInput); ok {
		args.opts = append(args.opts, WithShipmentGLSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sh *ShipmentHistoryQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentHistoryQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sh, nil
	}
	if err := sh.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sh, nil
}

func (sh *ShipmentHistoryQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmenthistory.Columns))
		selectedFields = []string{shipmenthistory.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "changeHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChangeHistoryClient{config: sh.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, changehistoryImplementors)...); err != nil {
				return err
			}
			sh.withChangeHistory = query

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sh.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sh.withTenant = query
			if _, ok := fieldSeen[shipmenthistory.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmenthistory.FieldTenantID)
				fieldSeen[shipmenthistory.FieldTenantID] = struct{}{}
			}

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: sh.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			sh.withShipment = query
		case "tenantID":
			if _, ok := fieldSeen[shipmenthistory.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmenthistory.FieldTenantID)
				fieldSeen[shipmenthistory.FieldTenantID] = struct{}{}
			}
		case "type":
			if _, ok := fieldSeen[shipmenthistory.FieldType]; !ok {
				selectedFields = append(selectedFields, shipmenthistory.FieldType)
				fieldSeen[shipmenthistory.FieldType] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sh.Select(selectedFields...)
	}
	return nil
}

type shipmenthistoryPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentHistoryPaginateOption
}

func newShipmentHistoryPaginateArgs(rv map[string]any) *shipmenthistoryPaginateArgs {
	args := &shipmenthistoryPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ShipmentHistoryWhereInput); ok {
		args.opts = append(args.opts, WithShipmentHistoryFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sp *ShipmentPalletQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentPalletQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sp, nil
	}
	if err := sp.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sp, nil
}

func (sp *ShipmentPalletQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmentpallet.Columns))
		selectedFields = []string{shipmentpallet.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sp.withTenant = query
			if _, ok := fieldSeen[shipmentpallet.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentpallet.FieldTenantID)
				fieldSeen[shipmentpallet.FieldTenantID] = struct{}{}
			}

		case "pallet":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PalletClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, palletImplementors)...); err != nil {
				return err
			}
			sp.withPallet = query

		case "oldPallet":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PalletClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, palletImplementors)...); err != nil {
				return err
			}
			sp.WithNamedOldPallet(alias, func(wq *PalletQuery) {
				*wq = *query
			})

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			sp.withShipment = query
		case "tenantID":
			if _, ok := fieldSeen[shipmentpallet.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentpallet.FieldTenantID)
				fieldSeen[shipmentpallet.FieldTenantID] = struct{}{}
			}
		case "barcode":
			if _, ok := fieldSeen[shipmentpallet.FieldBarcode]; !ok {
				selectedFields = append(selectedFields, shipmentpallet.FieldBarcode)
				fieldSeen[shipmentpallet.FieldBarcode] = struct{}{}
			}
		case "colliNumber":
			if _, ok := fieldSeen[shipmentpallet.FieldColliNumber]; !ok {
				selectedFields = append(selectedFields, shipmentpallet.FieldColliNumber)
				fieldSeen[shipmentpallet.FieldColliNumber] = struct{}{}
			}
		case "carrierID":
			if _, ok := fieldSeen[shipmentpallet.FieldCarrierID]; !ok {
				selectedFields = append(selectedFields, shipmentpallet.FieldCarrierID)
				fieldSeen[shipmentpallet.FieldCarrierID] = struct{}{}
			}
		case "labelPdf":
			if _, ok := fieldSeen[shipmentpallet.FieldLabelPdf]; !ok {
				selectedFields = append(selectedFields, shipmentpallet.FieldLabelPdf)
				fieldSeen[shipmentpallet.FieldLabelPdf] = struct{}{}
			}
		case "labelZpl":
			if _, ok := fieldSeen[shipmentpallet.FieldLabelZpl]; !ok {
				selectedFields = append(selectedFields, shipmentpallet.FieldLabelZpl)
				fieldSeen[shipmentpallet.FieldLabelZpl] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[shipmentpallet.FieldStatus]; !ok {
				selectedFields = append(selectedFields, shipmentpallet.FieldStatus)
				fieldSeen[shipmentpallet.FieldStatus] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sp.Select(selectedFields...)
	}
	return nil
}

type shipmentpalletPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentPalletPaginateOption
}

func newShipmentPalletPaginateArgs(rv map[string]any) *shipmentpalletPaginateArgs {
	args := &shipmentpalletPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ShipmentPalletWhereInput); ok {
		args.opts = append(args.opts, WithShipmentPalletFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (sp *ShipmentParcelQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentParcelQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return sp, nil
	}
	if err := sp.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return sp, nil
}

func (sp *ShipmentParcelQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmentparcel.Columns))
		selectedFields = []string{shipmentparcel.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			sp.withTenant = query
			if _, ok := fieldSeen[shipmentparcel.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentparcel.FieldTenantID)
				fieldSeen[shipmentparcel.FieldTenantID] = struct{}{}
			}

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			sp.withShipment = query

		case "colli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			sp.withColli = query

		case "oldColli":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ColliClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, colliImplementors)...); err != nil {
				return err
			}
			sp.WithNamedOldColli(alias, func(wq *ColliQuery) {
				*wq = *query
			})

		case "workspaceRecentScan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&WorkspaceRecentScanClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, workspacerecentscanImplementors)...); err != nil {
				return err
			}
			sp.WithNamedWorkspaceRecentScan(alias, func(wq *WorkspaceRecentScanQuery) {
				*wq = *query
			})

		case "packaging":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PackagingClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, packagingImplementors)...); err != nil {
				return err
			}
			sp.withPackaging = query

		case "printJob":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PrintJobClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, printjobImplementors)...); err != nil {
				return err
			}
			sp.WithNamedPrintJob(alias, func(wq *PrintJobQuery) {
				*wq = *query
			})

		case "documentFile":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&DocumentFileClient{config: sp.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, documentfileImplementors)...); err != nil {
				return err
			}
			sp.withDocumentFile = query
		case "tenantID":
			if _, ok := fieldSeen[shipmentparcel.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentparcel.FieldTenantID)
				fieldSeen[shipmentparcel.FieldTenantID] = struct{}{}
			}
		case "itemID":
			if _, ok := fieldSeen[shipmentparcel.FieldItemID]; !ok {
				selectedFields = append(selectedFields, shipmentparcel.FieldItemID)
				fieldSeen[shipmentparcel.FieldItemID] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[shipmentparcel.FieldStatus]; !ok {
				selectedFields = append(selectedFields, shipmentparcel.FieldStatus)
				fieldSeen[shipmentparcel.FieldStatus] = struct{}{}
			}
		case "ccPickupSignatureUrls":
			if _, ok := fieldSeen[shipmentparcel.FieldCcPickupSignatureUrls]; !ok {
				selectedFields = append(selectedFields, shipmentparcel.FieldCcPickupSignatureUrls)
				fieldSeen[shipmentparcel.FieldCcPickupSignatureUrls] = struct{}{}
			}
		case "expectedAt":
			if _, ok := fieldSeen[shipmentparcel.FieldExpectedAt]; !ok {
				selectedFields = append(selectedFields, shipmentparcel.FieldExpectedAt)
				fieldSeen[shipmentparcel.FieldExpectedAt] = struct{}{}
			}
		case "fulfillmentSyncedAt":
			if _, ok := fieldSeen[shipmentparcel.FieldFulfillmentSyncedAt]; !ok {
				selectedFields = append(selectedFields, shipmentparcel.FieldFulfillmentSyncedAt)
				fieldSeen[shipmentparcel.FieldFulfillmentSyncedAt] = struct{}{}
			}
		case "cancelSyncedAt":
			if _, ok := fieldSeen[shipmentparcel.FieldCancelSyncedAt]; !ok {
				selectedFields = append(selectedFields, shipmentparcel.FieldCancelSyncedAt)
				fieldSeen[shipmentparcel.FieldCancelSyncedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		sp.Select(selectedFields...)
	}
	return nil
}

type shipmentparcelPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentParcelPaginateOption
}

func newShipmentParcelPaginateArgs(rv map[string]any) *shipmentparcelPaginateArgs {
	args := &shipmentparcelPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[orderByField]; ok {
		switch v := v.(type) {
		case map[string]any:
			var (
				err1, err2 error
				order      = &ShipmentParcelOrder{Field: &ShipmentParcelOrderField{}, Direction: entgql.OrderDirectionAsc}
			)
			if d, ok := v[directionField]; ok {
				err1 = order.Direction.UnmarshalGQL(d)
			}
			if f, ok := v[fieldField]; ok {
				err2 = order.Field.UnmarshalGQL(f)
			}
			if err1 == nil && err2 == nil {
				args.opts = append(args.opts, WithShipmentParcelOrder(order))
			}
		case *ShipmentParcelOrder:
			if v != nil {
				args.opts = append(args.opts, WithShipmentParcelOrder(v))
			}
		}
	}
	if v, ok := rv[whereField].(*ShipmentParcelWhereInput); ok {
		args.opts = append(args.opts, WithShipmentParcelFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (spn *ShipmentPostNordQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentPostNordQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return spn, nil
	}
	if err := spn.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return spn, nil
}

func (spn *ShipmentPostNordQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmentpostnord.Columns))
		selectedFields = []string{shipmentpostnord.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: spn.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			spn.withTenant = query
			if _, ok := fieldSeen[shipmentpostnord.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentpostnord.FieldTenantID)
				fieldSeen[shipmentpostnord.FieldTenantID] = struct{}{}
			}

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: spn.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			spn.withShipment = query
		case "tenantID":
			if _, ok := fieldSeen[shipmentpostnord.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentpostnord.FieldTenantID)
				fieldSeen[shipmentpostnord.FieldTenantID] = struct{}{}
			}
		case "bookingID":
			if _, ok := fieldSeen[shipmentpostnord.FieldBookingID]; !ok {
				selectedFields = append(selectedFields, shipmentpostnord.FieldBookingID)
				fieldSeen[shipmentpostnord.FieldBookingID] = struct{}{}
			}
		case "itemID":
			if _, ok := fieldSeen[shipmentpostnord.FieldItemID]; !ok {
				selectedFields = append(selectedFields, shipmentpostnord.FieldItemID)
				fieldSeen[shipmentpostnord.FieldItemID] = struct{}{}
			}
		case "shipmentReferenceNo":
			if _, ok := fieldSeen[shipmentpostnord.FieldShipmentReferenceNo]; !ok {
				selectedFields = append(selectedFields, shipmentpostnord.FieldShipmentReferenceNo)
				fieldSeen[shipmentpostnord.FieldShipmentReferenceNo] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		spn.Select(selectedFields...)
	}
	return nil
}

type shipmentpostnordPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentPostNordPaginateOption
}

func newShipmentPostNordPaginateArgs(rv map[string]any) *shipmentpostnordPaginateArgs {
	args := &shipmentpostnordPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ShipmentPostNordWhereInput); ok {
		args.opts = append(args.opts, WithShipmentPostNordFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (su *ShipmentUSPSQuery) CollectFields(ctx context.Context, satisfies ...string) (*ShipmentUSPSQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return su, nil
	}
	if err := su.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return su, nil
}

func (su *ShipmentUSPSQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(shipmentusps.Columns))
		selectedFields = []string{shipmentusps.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: su.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			su.withTenant = query
			if _, ok := fieldSeen[shipmentusps.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentusps.FieldTenantID)
				fieldSeen[shipmentusps.FieldTenantID] = struct{}{}
			}

		case "shipment":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentClient{config: su.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentImplementors)...); err != nil {
				return err
			}
			su.withShipment = query
		case "tenantID":
			if _, ok := fieldSeen[shipmentusps.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, shipmentusps.FieldTenantID)
				fieldSeen[shipmentusps.FieldTenantID] = struct{}{}
			}
		case "trackingNumber":
			if _, ok := fieldSeen[shipmentusps.FieldTrackingNumber]; !ok {
				selectedFields = append(selectedFields, shipmentusps.FieldTrackingNumber)
				fieldSeen[shipmentusps.FieldTrackingNumber] = struct{}{}
			}
		case "postage":
			if _, ok := fieldSeen[shipmentusps.FieldPostage]; !ok {
				selectedFields = append(selectedFields, shipmentusps.FieldPostage)
				fieldSeen[shipmentusps.FieldPostage] = struct{}{}
			}
		case "scheduledDeliveryDate":
			if _, ok := fieldSeen[shipmentusps.FieldScheduledDeliveryDate]; !ok {
				selectedFields = append(selectedFields, shipmentusps.FieldScheduledDeliveryDate)
				fieldSeen[shipmentusps.FieldScheduledDeliveryDate] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		su.Select(selectedFields...)
	}
	return nil
}

type shipmentuspsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []ShipmentUSPSPaginateOption
}

func newShipmentUSPSPaginateArgs(rv map[string]any) *shipmentuspsPaginateArgs {
	args := &shipmentuspsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*ShipmentUSPSWhereInput); ok {
		args.opts = append(args.opts, WithShipmentUSPSFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (so *SignupOptionsQuery) CollectFields(ctx context.Context, satisfies ...string) (*SignupOptionsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return so, nil
	}
	if err := so.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return so, nil
}

func (so *SignupOptionsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(signupoptions.Columns))
		selectedFields = []string{signupoptions.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "users":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: so.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			so.withUsers = query
		case "betterDeliveryOptions":
			if _, ok := fieldSeen[signupoptions.FieldBetterDeliveryOptions]; !ok {
				selectedFields = append(selectedFields, signupoptions.FieldBetterDeliveryOptions)
				fieldSeen[signupoptions.FieldBetterDeliveryOptions] = struct{}{}
			}
		case "improvePickPack":
			if _, ok := fieldSeen[signupoptions.FieldImprovePickPack]; !ok {
				selectedFields = append(selectedFields, signupoptions.FieldImprovePickPack)
				fieldSeen[signupoptions.FieldImprovePickPack] = struct{}{}
			}
		case "shippingLabel":
			if _, ok := fieldSeen[signupoptions.FieldShippingLabel]; !ok {
				selectedFields = append(selectedFields, signupoptions.FieldShippingLabel)
				fieldSeen[signupoptions.FieldShippingLabel] = struct{}{}
			}
		case "customDocs":
			if _, ok := fieldSeen[signupoptions.FieldCustomDocs]; !ok {
				selectedFields = append(selectedFields, signupoptions.FieldCustomDocs)
				fieldSeen[signupoptions.FieldCustomDocs] = struct{}{}
			}
		case "reducedCosts":
			if _, ok := fieldSeen[signupoptions.FieldReducedCosts]; !ok {
				selectedFields = append(selectedFields, signupoptions.FieldReducedCosts)
				fieldSeen[signupoptions.FieldReducedCosts] = struct{}{}
			}
		case "easyReturns":
			if _, ok := fieldSeen[signupoptions.FieldEasyReturns]; !ok {
				selectedFields = append(selectedFields, signupoptions.FieldEasyReturns)
				fieldSeen[signupoptions.FieldEasyReturns] = struct{}{}
			}
		case "clickCollect":
			if _, ok := fieldSeen[signupoptions.FieldClickCollect]; !ok {
				selectedFields = append(selectedFields, signupoptions.FieldClickCollect)
				fieldSeen[signupoptions.FieldClickCollect] = struct{}{}
			}
		case "numShipments":
			if _, ok := fieldSeen[signupoptions.FieldNumShipments]; !ok {
				selectedFields = append(selectedFields, signupoptions.FieldNumShipments)
				fieldSeen[signupoptions.FieldNumShipments] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		so.Select(selectedFields...)
	}
	return nil
}

type signupoptionsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SignupOptionsPaginateOption
}

func newSignupOptionsPaginateArgs(rv map[string]any) *signupoptionsPaginateArgs {
	args := &signupoptionsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SignupOptionsWhereInput); ok {
		args.opts = append(args.opts, WithSignupOptionsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (se *SystemEventsQuery) CollectFields(ctx context.Context, satisfies ...string) (*SystemEventsQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return se, nil
	}
	if err := se.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return se, nil
}

func (se *SystemEventsQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(systemevents.Columns))
		selectedFields = []string{systemevents.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: se.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			se.withTenant = query
			if _, ok := fieldSeen[systemevents.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, systemevents.FieldTenantID)
				fieldSeen[systemevents.FieldTenantID] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[systemevents.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, systemevents.FieldTenantID)
				fieldSeen[systemevents.FieldTenantID] = struct{}{}
			}
		case "eventType":
			if _, ok := fieldSeen[systemevents.FieldEventType]; !ok {
				selectedFields = append(selectedFields, systemevents.FieldEventType)
				fieldSeen[systemevents.FieldEventType] = struct{}{}
			}
		case "eventTypeID":
			if _, ok := fieldSeen[systemevents.FieldEventTypeID]; !ok {
				selectedFields = append(selectedFields, systemevents.FieldEventTypeID)
				fieldSeen[systemevents.FieldEventTypeID] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[systemevents.FieldStatus]; !ok {
				selectedFields = append(selectedFields, systemevents.FieldStatus)
				fieldSeen[systemevents.FieldStatus] = struct{}{}
			}
		case "description":
			if _, ok := fieldSeen[systemevents.FieldDescription]; !ok {
				selectedFields = append(selectedFields, systemevents.FieldDescription)
				fieldSeen[systemevents.FieldDescription] = struct{}{}
			}
		case "data":
			if _, ok := fieldSeen[systemevents.FieldData]; !ok {
				selectedFields = append(selectedFields, systemevents.FieldData)
				fieldSeen[systemevents.FieldData] = struct{}{}
			}
		case "updatedAt":
			if _, ok := fieldSeen[systemevents.FieldUpdatedAt]; !ok {
				selectedFields = append(selectedFields, systemevents.FieldUpdatedAt)
				fieldSeen[systemevents.FieldUpdatedAt] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[systemevents.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, systemevents.FieldCreatedAt)
				fieldSeen[systemevents.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		se.Select(selectedFields...)
	}
	return nil
}

type systemeventsPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []SystemEventsPaginateOption
}

func newSystemEventsPaginateArgs(rv map[string]any) *systemeventsPaginateArgs {
	args := &systemeventsPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*SystemEventsWhereInput); ok {
		args.opts = append(args.opts, WithSystemEventsFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (t *TenantQuery) CollectFields(ctx context.Context, satisfies ...string) (*TenantQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return t, nil
	}
	if err := t.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return t, nil
}

func (t *TenantQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(tenant.Columns))
		selectedFields = []string{tenant.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "connectOptionCarriers":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectOptionCarrierClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, connectoptioncarrierImplementors)...); err != nil {
				return err
			}
			t.WithNamedConnectOptionCarriers(alias, func(wq *ConnectOptionCarrierQuery) {
				*wq = *query
			})

		case "connectOptionPlatforms":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ConnectOptionPlatformClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, connectoptionplatformImplementors)...); err != nil {
				return err
			}
			t.WithNamedConnectOptionPlatforms(alias, func(wq *ConnectOptionPlatformQuery) {
				*wq = *query
			})

		case "plan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, planImplementors)...); err != nil {
				return err
			}
			t.withPlan = query

		case "companyAddress":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&AddressClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, addressImplementors)...); err != nil {
				return err
			}
			t.withCompanyAddress = query

		case "defaultLanguage":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LanguageClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, languageImplementors)...); err != nil {
				return err
			}
			t.withDefaultLanguage = query

		case "billingContact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContactClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, contactImplementors)...); err != nil {
				return err
			}
			t.withBillingContact = query

		case "adminContact":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ContactClient{config: t.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, contactImplementors)...); err != nil {
				return err
			}
			t.withAdminContact = query
		case "name":
			if _, ok := fieldSeen[tenant.FieldName]; !ok {
				selectedFields = append(selectedFields, tenant.FieldName)
				fieldSeen[tenant.FieldName] = struct{}{}
			}
		case "vatNumber":
			if _, ok := fieldSeen[tenant.FieldVatNumber]; !ok {
				selectedFields = append(selectedFields, tenant.FieldVatNumber)
				fieldSeen[tenant.FieldVatNumber] = struct{}{}
			}
		case "invoiceReference":
			if _, ok := fieldSeen[tenant.FieldInvoiceReference]; !ok {
				selectedFields = append(selectedFields, tenant.FieldInvoiceReference)
				fieldSeen[tenant.FieldInvoiceReference] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		t.Select(selectedFields...)
	}
	return nil
}

type tenantPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []TenantPaginateOption
}

func newTenantPaginateArgs(rv map[string]any) *tenantPaginateArgs {
	args := &tenantPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*TenantWhereInput); ok {
		args.opts = append(args.opts, WithTenantFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (u *UserQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return u, nil
	}
	if err := u.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return u, nil
}

func (u *UserQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(user.Columns))
		selectedFields = []string{user.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			u.withTenant = query
			if _, ok := fieldSeen[user.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, user.FieldTenantID)
				fieldSeen[user.FieldTenantID] = struct{}{}
			}

		case "otkRequests":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&OTKRequestsClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, otkrequestsImplementors)...); err != nil {
				return err
			}
			u.WithNamedOtkRequests(alias, func(wq *OTKRequestsQuery) {
				*wq = *query
			})

		case "signupOptions":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SignupOptionsClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, signupoptionsImplementors)...); err != nil {
				return err
			}
			u.withSignupOptions = query

		case "language":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&LanguageClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, languageImplementors)...); err != nil {
				return err
			}
			u.withLanguage = query

		case "changeHistory":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ChangeHistoryClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, changehistoryImplementors)...); err != nil {
				return err
			}
			u.WithNamedChangeHistory(alias, func(wq *ChangeHistoryQuery) {
				*wq = *query
			})

		case "planHistoryUser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PlanHistoryClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, planhistoryImplementors)...); err != nil {
				return err
			}
			u.WithNamedPlanHistoryUser(alias, func(wq *PlanHistoryQuery) {
				*wq = *query
			})

		case "apiToken":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&APITokenClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, apitokenImplementors)...); err != nil {
				return err
			}
			u.WithNamedAPIToken(alias, func(wq *APITokenQuery) {
				*wq = *query
			})

		case "selectedWorkstation":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&WorkstationClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, workstationImplementors)...); err != nil {
				return err
			}
			u.withSelectedWorkstation = query

		case "seatGroup":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&SeatGroupClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, seatgroupImplementors)...); err != nil {
				return err
			}
			u.withSeatGroup = query

		case "workspaceRecentScan":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&WorkspaceRecentScanClient{config: u.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, workspacerecentscanImplementors)...); err != nil {
				return err
			}
			u.WithNamedWorkspaceRecentScan(alias, func(wq *WorkspaceRecentScanQuery) {
				*wq = *query
			})
		case "tenantID":
			if _, ok := fieldSeen[user.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, user.FieldTenantID)
				fieldSeen[user.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[user.FieldName]; !ok {
				selectedFields = append(selectedFields, user.FieldName)
				fieldSeen[user.FieldName] = struct{}{}
			}
		case "surname":
			if _, ok := fieldSeen[user.FieldSurname]; !ok {
				selectedFields = append(selectedFields, user.FieldSurname)
				fieldSeen[user.FieldSurname] = struct{}{}
			}
		case "phoneNumber":
			if _, ok := fieldSeen[user.FieldPhoneNumber]; !ok {
				selectedFields = append(selectedFields, user.FieldPhoneNumber)
				fieldSeen[user.FieldPhoneNumber] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[user.FieldEmail]; !ok {
				selectedFields = append(selectedFields, user.FieldEmail)
				fieldSeen[user.FieldEmail] = struct{}{}
			}
		case "isAccountOwner":
			if _, ok := fieldSeen[user.FieldIsAccountOwner]; !ok {
				selectedFields = append(selectedFields, user.FieldIsAccountOwner)
				fieldSeen[user.FieldIsAccountOwner] = struct{}{}
			}
		case "isGlobalAdmin":
			if _, ok := fieldSeen[user.FieldIsGlobalAdmin]; !ok {
				selectedFields = append(selectedFields, user.FieldIsGlobalAdmin)
				fieldSeen[user.FieldIsGlobalAdmin] = struct{}{}
			}
		case "marketingConsent":
			if _, ok := fieldSeen[user.FieldMarketingConsent]; !ok {
				selectedFields = append(selectedFields, user.FieldMarketingConsent)
				fieldSeen[user.FieldMarketingConsent] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[user.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldCreatedAt)
				fieldSeen[user.FieldCreatedAt] = struct{}{}
			}
		case "archivedAt":
			if _, ok := fieldSeen[user.FieldArchivedAt]; !ok {
				selectedFields = append(selectedFields, user.FieldArchivedAt)
				fieldSeen[user.FieldArchivedAt] = struct{}{}
			}
		case "pickupDay":
			if _, ok := fieldSeen[user.FieldPickupDay]; !ok {
				selectedFields = append(selectedFields, user.FieldPickupDay)
				fieldSeen[user.FieldPickupDay] = struct{}{}
			}
		case "pickupDayLastChanged":
			if _, ok := fieldSeen[user.FieldPickupDayLastChanged]; !ok {
				selectedFields = append(selectedFields, user.FieldPickupDayLastChanged)
				fieldSeen[user.FieldPickupDayLastChanged] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		u.Select(selectedFields...)
	}
	return nil
}

type userPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserPaginateOption
}

func newUserPaginateArgs(rv map[string]any) *userPaginateArgs {
	args := &userPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserWhereInput); ok {
		args.opts = append(args.opts, WithUserFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (us *UserSeatQuery) CollectFields(ctx context.Context, satisfies ...string) (*UserSeatQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return us, nil
	}
	if err := us.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return us, nil
}

func (us *UserSeatQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(userseat.Columns))
		selectedFields = []string{userseat.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: us.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			us.withTenant = query
			if _, ok := fieldSeen[userseat.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, userseat.FieldTenantID)
				fieldSeen[userseat.FieldTenantID] = struct{}{}
			}
		case "tenantID":
			if _, ok := fieldSeen[userseat.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, userseat.FieldTenantID)
				fieldSeen[userseat.FieldTenantID] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[userseat.FieldName]; !ok {
				selectedFields = append(selectedFields, userseat.FieldName)
				fieldSeen[userseat.FieldName] = struct{}{}
			}
		case "surname":
			if _, ok := fieldSeen[userseat.FieldSurname]; !ok {
				selectedFields = append(selectedFields, userseat.FieldSurname)
				fieldSeen[userseat.FieldSurname] = struct{}{}
			}
		case "email":
			if _, ok := fieldSeen[userseat.FieldEmail]; !ok {
				selectedFields = append(selectedFields, userseat.FieldEmail)
				fieldSeen[userseat.FieldEmail] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[userseat.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, userseat.FieldCreatedAt)
				fieldSeen[userseat.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		us.Select(selectedFields...)
	}
	return nil
}

type userseatPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []UserSeatPaginateOption
}

func newUserSeatPaginateArgs(rv map[string]any) *userseatPaginateArgs {
	args := &userseatPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*UserSeatWhereInput); ok {
		args.opts = append(args.opts, WithUserSeatFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (wrs *WorkspaceRecentScanQuery) CollectFields(ctx context.Context, satisfies ...string) (*WorkspaceRecentScanQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return wrs, nil
	}
	if err := wrs.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return wrs, nil
}

func (wrs *WorkspaceRecentScanQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(workspacerecentscan.Columns))
		selectedFields = []string{workspacerecentscan.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: wrs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			wrs.withTenant = query
			if _, ok := fieldSeen[workspacerecentscan.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, workspacerecentscan.FieldTenantID)
				fieldSeen[workspacerecentscan.FieldTenantID] = struct{}{}
			}

		case "shipmentParcel":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&ShipmentParcelClient{config: wrs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, shipmentparcelImplementors)...); err != nil {
				return err
			}
			wrs.withShipmentParcel = query

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: wrs.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			wrs.withUser = query
		case "tenantID":
			if _, ok := fieldSeen[workspacerecentscan.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, workspacerecentscan.FieldTenantID)
				fieldSeen[workspacerecentscan.FieldTenantID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[workspacerecentscan.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, workspacerecentscan.FieldCreatedAt)
				fieldSeen[workspacerecentscan.FieldCreatedAt] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		wrs.Select(selectedFields...)
	}
	return nil
}

type workspacerecentscanPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WorkspaceRecentScanPaginateOption
}

func newWorkspaceRecentScanPaginateArgs(rv map[string]any) *workspacerecentscanPaginateArgs {
	args := &workspacerecentscanPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*WorkspaceRecentScanWhereInput); ok {
		args.opts = append(args.opts, WithWorkspaceRecentScanFilter(v.Filter))
	}
	return args
}

// CollectFields tells the query-builder to eagerly load connected nodes by resolver context.
func (w *WorkstationQuery) CollectFields(ctx context.Context, satisfies ...string) (*WorkstationQuery, error) {
	fc := graphql.GetFieldContext(ctx)
	if fc == nil {
		return w, nil
	}
	if err := w.collectField(ctx, false, graphql.GetOperationContext(ctx), fc.Field, nil, satisfies...); err != nil {
		return nil, err
	}
	return w, nil
}

func (w *WorkstationQuery) collectField(ctx context.Context, oneNode bool, opCtx *graphql.OperationContext, collected graphql.CollectedField, path []string, satisfies ...string) error {
	path = append([]string(nil), path...)
	var (
		unknownSeen    bool
		fieldSeen      = make(map[string]struct{}, len(workstation.Columns))
		selectedFields = []string{workstation.FieldID}
	)
	for _, field := range graphql.CollectFields(opCtx, collected.Selections, satisfies) {
		switch field.Name {

		case "tenant":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&TenantClient{config: w.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, tenantImplementors)...); err != nil {
				return err
			}
			w.withTenant = query
			if _, ok := fieldSeen[workstation.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, workstation.FieldTenantID)
				fieldSeen[workstation.FieldTenantID] = struct{}{}
			}

		case "printer":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&PrinterClient{config: w.config}).Query()
			)
			if err := query.collectField(ctx, false, opCtx, field, path, mayAddCondition(satisfies, printerImplementors)...); err != nil {
				return err
			}
			w.WithNamedPrinter(alias, func(wq *PrinterQuery) {
				*wq = *query
			})

		case "user":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: w.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			w.withUser = query

		case "selectedUser":
			var (
				alias = field.Alias
				path  = append(path, alias)
				query = (&UserClient{config: w.config}).Query()
			)
			if err := query.collectField(ctx, oneNode, opCtx, field, path, mayAddCondition(satisfies, userImplementors)...); err != nil {
				return err
			}
			w.withSelectedUser = query
		case "tenantID":
			if _, ok := fieldSeen[workstation.FieldTenantID]; !ok {
				selectedFields = append(selectedFields, workstation.FieldTenantID)
				fieldSeen[workstation.FieldTenantID] = struct{}{}
			}
		case "archivedAt":
			if _, ok := fieldSeen[workstation.FieldArchivedAt]; !ok {
				selectedFields = append(selectedFields, workstation.FieldArchivedAt)
				fieldSeen[workstation.FieldArchivedAt] = struct{}{}
			}
		case "name":
			if _, ok := fieldSeen[workstation.FieldName]; !ok {
				selectedFields = append(selectedFields, workstation.FieldName)
				fieldSeen[workstation.FieldName] = struct{}{}
			}
		case "deviceType":
			if _, ok := fieldSeen[workstation.FieldDeviceType]; !ok {
				selectedFields = append(selectedFields, workstation.FieldDeviceType)
				fieldSeen[workstation.FieldDeviceType] = struct{}{}
			}
		case "workstationID":
			if _, ok := fieldSeen[workstation.FieldWorkstationID]; !ok {
				selectedFields = append(selectedFields, workstation.FieldWorkstationID)
				fieldSeen[workstation.FieldWorkstationID] = struct{}{}
			}
		case "createdAt":
			if _, ok := fieldSeen[workstation.FieldCreatedAt]; !ok {
				selectedFields = append(selectedFields, workstation.FieldCreatedAt)
				fieldSeen[workstation.FieldCreatedAt] = struct{}{}
			}
		case "lastPing":
			if _, ok := fieldSeen[workstation.FieldLastPing]; !ok {
				selectedFields = append(selectedFields, workstation.FieldLastPing)
				fieldSeen[workstation.FieldLastPing] = struct{}{}
			}
		case "status":
			if _, ok := fieldSeen[workstation.FieldStatus]; !ok {
				selectedFields = append(selectedFields, workstation.FieldStatus)
				fieldSeen[workstation.FieldStatus] = struct{}{}
			}
		case "autoPrintReceiver":
			if _, ok := fieldSeen[workstation.FieldAutoPrintReceiver]; !ok {
				selectedFields = append(selectedFields, workstation.FieldAutoPrintReceiver)
				fieldSeen[workstation.FieldAutoPrintReceiver] = struct{}{}
			}
		case "id":
		case "__typename":
		default:
			unknownSeen = true
		}
	}
	if !unknownSeen {
		w.Select(selectedFields...)
	}
	return nil
}

type workstationPaginateArgs struct {
	first, last   *int
	after, before *Cursor
	opts          []WorkstationPaginateOption
}

func newWorkstationPaginateArgs(rv map[string]any) *workstationPaginateArgs {
	args := &workstationPaginateArgs{}
	if rv == nil {
		return args
	}
	if v := rv[firstField]; v != nil {
		args.first = v.(*int)
	}
	if v := rv[lastField]; v != nil {
		args.last = v.(*int)
	}
	if v := rv[afterField]; v != nil {
		args.after = v.(*Cursor)
	}
	if v := rv[beforeField]; v != nil {
		args.before = v.(*Cursor)
	}
	if v, ok := rv[whereField].(*WorkstationWhereInput); ok {
		args.opts = append(args.opts, WithWorkstationFilter(v.Filter))
	}
	return args
}

const (
	afterField     = "after"
	firstField     = "first"
	beforeField    = "before"
	lastField      = "last"
	orderByField   = "orderBy"
	directionField = "direction"
	fieldField     = "field"
	whereField     = "where"
)

func fieldArgs(ctx context.Context, whereInput any, path ...string) map[string]any {
	field := collectedField(ctx, path...)
	if field == nil || field.Arguments == nil {
		return nil
	}
	oc := graphql.GetOperationContext(ctx)
	args := field.ArgumentMap(oc.Variables)
	return unmarshalArgs(ctx, whereInput, args)
}

// unmarshalArgs allows extracting the field arguments from their raw representation.
func unmarshalArgs(ctx context.Context, whereInput any, args map[string]any) map[string]any {
	for _, k := range []string{firstField, lastField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		i, err := graphql.UnmarshalInt(v)
		if err == nil {
			args[k] = &i
		}
	}
	for _, k := range []string{beforeField, afterField} {
		v, ok := args[k]
		if !ok {
			continue
		}
		c := &Cursor{}
		if c.UnmarshalGQL(v) == nil {
			args[k] = c
		}
	}
	if v, ok := args[whereField]; ok && whereInput != nil {
		if err := graphql.UnmarshalInputFromContext(ctx, v, whereInput); err == nil {
			args[whereField] = whereInput
		}
	}

	return args
}

// mayAddCondition appends another type condition to the satisfies list
// if it does not exist in the list.
func mayAddCondition(satisfies []string, typeCond []string) []string {
Cond:
	for _, c := range typeCond {
		for _, s := range satisfies {
			if c == s {
				continue Cond
			}
		}
		satisfies = append(satisfies, c)
	}
	return satisfies
}
