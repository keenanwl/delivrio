// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"delivrio.io/print-client/ent/localdevice"
	"delivrio.io/print-client/ent/logerror"
	"delivrio.io/print-client/ent/predicate"
	"delivrio.io/print-client/ent/printjob"
	"delivrio.io/print-client/ent/recentscan"
	"delivrio.io/print-client/ent/remoteconnection"
	"delivrio.io/shared-utils/pulid"
	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeLocalDevice      = "LocalDevice"
	TypeLogError         = "LogError"
	TypePrintJob         = "PrintJob"
	TypeRecentScan       = "RecentScan"
	TypeRemoteConnection = "RemoteConnection"
	TypeUniqueComputer   = "UniqueComputer"
)

// LocalDeviceMutation represents an operation that mutates the LocalDevice nodes in the graph.
type LocalDeviceMutation struct {
	config
	op               Op
	typ              string
	id               *pulid.ID
	name             *string
	system_name      *string
	vendor_id        *int
	addvendor_id     *int
	product_id       *int
	addproduct_id    *int
	address          *string
	active           *bool
	archived         *bool
	category         *localdevice.Category
	clearedFields    map[string]struct{}
	print_job        map[pulid.ID]struct{}
	removedprint_job map[pulid.ID]struct{}
	clearedprint_job bool
	done             bool
	oldValue         func(context.Context) (*LocalDevice, error)
	predicates       []predicate.LocalDevice
}

var _ ent.Mutation = (*LocalDeviceMutation)(nil)

// localdeviceOption allows management of the mutation configuration using functional options.
type localdeviceOption func(*LocalDeviceMutation)

// newLocalDeviceMutation creates new mutation for the LocalDevice entity.
func newLocalDeviceMutation(c config, op Op, opts ...localdeviceOption) *LocalDeviceMutation {
	m := &LocalDeviceMutation{
		config:        c,
		op:            op,
		typ:           TypeLocalDevice,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLocalDeviceID sets the ID field of the mutation.
func withLocalDeviceID(id pulid.ID) localdeviceOption {
	return func(m *LocalDeviceMutation) {
		var (
			err   error
			once  sync.Once
			value *LocalDevice
		)
		m.oldValue = func(ctx context.Context) (*LocalDevice, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LocalDevice.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLocalDevice sets the old LocalDevice of the mutation.
func withLocalDevice(node *LocalDevice) localdeviceOption {
	return func(m *LocalDeviceMutation) {
		m.oldValue = func(context.Context) (*LocalDevice, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LocalDeviceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LocalDeviceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LocalDevice entities.
func (m *LocalDeviceMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LocalDeviceMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LocalDeviceMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LocalDevice.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *LocalDeviceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *LocalDeviceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the LocalDevice entity.
// If the LocalDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalDeviceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *LocalDeviceMutation) ResetName() {
	m.name = nil
}

// SetSystemName sets the "system_name" field.
func (m *LocalDeviceMutation) SetSystemName(s string) {
	m.system_name = &s
}

// SystemName returns the value of the "system_name" field in the mutation.
func (m *LocalDeviceMutation) SystemName() (r string, exists bool) {
	v := m.system_name
	if v == nil {
		return
	}
	return *v, true
}

// OldSystemName returns the old "system_name" field's value of the LocalDevice entity.
// If the LocalDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalDeviceMutation) OldSystemName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSystemName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSystemName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSystemName: %w", err)
	}
	return oldValue.SystemName, nil
}

// ResetSystemName resets all changes to the "system_name" field.
func (m *LocalDeviceMutation) ResetSystemName() {
	m.system_name = nil
}

// SetVendorID sets the "vendor_id" field.
func (m *LocalDeviceMutation) SetVendorID(i int) {
	m.vendor_id = &i
	m.addvendor_id = nil
}

// VendorID returns the value of the "vendor_id" field in the mutation.
func (m *LocalDeviceMutation) VendorID() (r int, exists bool) {
	v := m.vendor_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVendorID returns the old "vendor_id" field's value of the LocalDevice entity.
// If the LocalDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalDeviceMutation) OldVendorID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVendorID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVendorID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVendorID: %w", err)
	}
	return oldValue.VendorID, nil
}

// AddVendorID adds i to the "vendor_id" field.
func (m *LocalDeviceMutation) AddVendorID(i int) {
	if m.addvendor_id != nil {
		*m.addvendor_id += i
	} else {
		m.addvendor_id = &i
	}
}

// AddedVendorID returns the value that was added to the "vendor_id" field in this mutation.
func (m *LocalDeviceMutation) AddedVendorID() (r int, exists bool) {
	v := m.addvendor_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearVendorID clears the value of the "vendor_id" field.
func (m *LocalDeviceMutation) ClearVendorID() {
	m.vendor_id = nil
	m.addvendor_id = nil
	m.clearedFields[localdevice.FieldVendorID] = struct{}{}
}

// VendorIDCleared returns if the "vendor_id" field was cleared in this mutation.
func (m *LocalDeviceMutation) VendorIDCleared() bool {
	_, ok := m.clearedFields[localdevice.FieldVendorID]
	return ok
}

// ResetVendorID resets all changes to the "vendor_id" field.
func (m *LocalDeviceMutation) ResetVendorID() {
	m.vendor_id = nil
	m.addvendor_id = nil
	delete(m.clearedFields, localdevice.FieldVendorID)
}

// SetProductID sets the "product_id" field.
func (m *LocalDeviceMutation) SetProductID(i int) {
	m.product_id = &i
	m.addproduct_id = nil
}

// ProductID returns the value of the "product_id" field in the mutation.
func (m *LocalDeviceMutation) ProductID() (r int, exists bool) {
	v := m.product_id
	if v == nil {
		return
	}
	return *v, true
}

// OldProductID returns the old "product_id" field's value of the LocalDevice entity.
// If the LocalDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalDeviceMutation) OldProductID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProductID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProductID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProductID: %w", err)
	}
	return oldValue.ProductID, nil
}

// AddProductID adds i to the "product_id" field.
func (m *LocalDeviceMutation) AddProductID(i int) {
	if m.addproduct_id != nil {
		*m.addproduct_id += i
	} else {
		m.addproduct_id = &i
	}
}

// AddedProductID returns the value that was added to the "product_id" field in this mutation.
func (m *LocalDeviceMutation) AddedProductID() (r int, exists bool) {
	v := m.addproduct_id
	if v == nil {
		return
	}
	return *v, true
}

// ClearProductID clears the value of the "product_id" field.
func (m *LocalDeviceMutation) ClearProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	m.clearedFields[localdevice.FieldProductID] = struct{}{}
}

// ProductIDCleared returns if the "product_id" field was cleared in this mutation.
func (m *LocalDeviceMutation) ProductIDCleared() bool {
	_, ok := m.clearedFields[localdevice.FieldProductID]
	return ok
}

// ResetProductID resets all changes to the "product_id" field.
func (m *LocalDeviceMutation) ResetProductID() {
	m.product_id = nil
	m.addproduct_id = nil
	delete(m.clearedFields, localdevice.FieldProductID)
}

// SetAddress sets the "address" field.
func (m *LocalDeviceMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *LocalDeviceMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the LocalDevice entity.
// If the LocalDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalDeviceMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *LocalDeviceMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[localdevice.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *LocalDeviceMutation) AddressCleared() bool {
	_, ok := m.clearedFields[localdevice.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *LocalDeviceMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, localdevice.FieldAddress)
}

// SetActive sets the "active" field.
func (m *LocalDeviceMutation) SetActive(b bool) {
	m.active = &b
}

// Active returns the value of the "active" field in the mutation.
func (m *LocalDeviceMutation) Active() (r bool, exists bool) {
	v := m.active
	if v == nil {
		return
	}
	return *v, true
}

// OldActive returns the old "active" field's value of the LocalDevice entity.
// If the LocalDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalDeviceMutation) OldActive(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldActive is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldActive requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldActive: %w", err)
	}
	return oldValue.Active, nil
}

// ResetActive resets all changes to the "active" field.
func (m *LocalDeviceMutation) ResetActive() {
	m.active = nil
}

// SetArchived sets the "archived" field.
func (m *LocalDeviceMutation) SetArchived(b bool) {
	m.archived = &b
}

// Archived returns the value of the "archived" field in the mutation.
func (m *LocalDeviceMutation) Archived() (r bool, exists bool) {
	v := m.archived
	if v == nil {
		return
	}
	return *v, true
}

// OldArchived returns the old "archived" field's value of the LocalDevice entity.
// If the LocalDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalDeviceMutation) OldArchived(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldArchived is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldArchived requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldArchived: %w", err)
	}
	return oldValue.Archived, nil
}

// ResetArchived resets all changes to the "archived" field.
func (m *LocalDeviceMutation) ResetArchived() {
	m.archived = nil
}

// SetCategory sets the "category" field.
func (m *LocalDeviceMutation) SetCategory(l localdevice.Category) {
	m.category = &l
}

// Category returns the value of the "category" field in the mutation.
func (m *LocalDeviceMutation) Category() (r localdevice.Category, exists bool) {
	v := m.category
	if v == nil {
		return
	}
	return *v, true
}

// OldCategory returns the old "category" field's value of the LocalDevice entity.
// If the LocalDevice object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LocalDeviceMutation) OldCategory(ctx context.Context) (v localdevice.Category, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCategory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCategory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCategory: %w", err)
	}
	return oldValue.Category, nil
}

// ResetCategory resets all changes to the "category" field.
func (m *LocalDeviceMutation) ResetCategory() {
	m.category = nil
}

// AddPrintJobIDs adds the "print_job" edge to the PrintJob entity by ids.
func (m *LocalDeviceMutation) AddPrintJobIDs(ids ...pulid.ID) {
	if m.print_job == nil {
		m.print_job = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		m.print_job[ids[i]] = struct{}{}
	}
}

// ClearPrintJob clears the "print_job" edge to the PrintJob entity.
func (m *LocalDeviceMutation) ClearPrintJob() {
	m.clearedprint_job = true
}

// PrintJobCleared reports if the "print_job" edge to the PrintJob entity was cleared.
func (m *LocalDeviceMutation) PrintJobCleared() bool {
	return m.clearedprint_job
}

// RemovePrintJobIDs removes the "print_job" edge to the PrintJob entity by IDs.
func (m *LocalDeviceMutation) RemovePrintJobIDs(ids ...pulid.ID) {
	if m.removedprint_job == nil {
		m.removedprint_job = make(map[pulid.ID]struct{})
	}
	for i := range ids {
		delete(m.print_job, ids[i])
		m.removedprint_job[ids[i]] = struct{}{}
	}
}

// RemovedPrintJob returns the removed IDs of the "print_job" edge to the PrintJob entity.
func (m *LocalDeviceMutation) RemovedPrintJobIDs() (ids []pulid.ID) {
	for id := range m.removedprint_job {
		ids = append(ids, id)
	}
	return
}

// PrintJobIDs returns the "print_job" edge IDs in the mutation.
func (m *LocalDeviceMutation) PrintJobIDs() (ids []pulid.ID) {
	for id := range m.print_job {
		ids = append(ids, id)
	}
	return
}

// ResetPrintJob resets all changes to the "print_job" edge.
func (m *LocalDeviceMutation) ResetPrintJob() {
	m.print_job = nil
	m.clearedprint_job = false
	m.removedprint_job = nil
}

// Where appends a list predicates to the LocalDeviceMutation builder.
func (m *LocalDeviceMutation) Where(ps ...predicate.LocalDevice) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LocalDeviceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LocalDeviceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LocalDevice, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LocalDeviceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LocalDeviceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LocalDevice).
func (m *LocalDeviceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LocalDeviceMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.name != nil {
		fields = append(fields, localdevice.FieldName)
	}
	if m.system_name != nil {
		fields = append(fields, localdevice.FieldSystemName)
	}
	if m.vendor_id != nil {
		fields = append(fields, localdevice.FieldVendorID)
	}
	if m.product_id != nil {
		fields = append(fields, localdevice.FieldProductID)
	}
	if m.address != nil {
		fields = append(fields, localdevice.FieldAddress)
	}
	if m.active != nil {
		fields = append(fields, localdevice.FieldActive)
	}
	if m.archived != nil {
		fields = append(fields, localdevice.FieldArchived)
	}
	if m.category != nil {
		fields = append(fields, localdevice.FieldCategory)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LocalDeviceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case localdevice.FieldName:
		return m.Name()
	case localdevice.FieldSystemName:
		return m.SystemName()
	case localdevice.FieldVendorID:
		return m.VendorID()
	case localdevice.FieldProductID:
		return m.ProductID()
	case localdevice.FieldAddress:
		return m.Address()
	case localdevice.FieldActive:
		return m.Active()
	case localdevice.FieldArchived:
		return m.Archived()
	case localdevice.FieldCategory:
		return m.Category()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LocalDeviceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case localdevice.FieldName:
		return m.OldName(ctx)
	case localdevice.FieldSystemName:
		return m.OldSystemName(ctx)
	case localdevice.FieldVendorID:
		return m.OldVendorID(ctx)
	case localdevice.FieldProductID:
		return m.OldProductID(ctx)
	case localdevice.FieldAddress:
		return m.OldAddress(ctx)
	case localdevice.FieldActive:
		return m.OldActive(ctx)
	case localdevice.FieldArchived:
		return m.OldArchived(ctx)
	case localdevice.FieldCategory:
		return m.OldCategory(ctx)
	}
	return nil, fmt.Errorf("unknown LocalDevice field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocalDeviceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case localdevice.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case localdevice.FieldSystemName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSystemName(v)
		return nil
	case localdevice.FieldVendorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVendorID(v)
		return nil
	case localdevice.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProductID(v)
		return nil
	case localdevice.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case localdevice.FieldActive:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetActive(v)
		return nil
	case localdevice.FieldArchived:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetArchived(v)
		return nil
	case localdevice.FieldCategory:
		v, ok := value.(localdevice.Category)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCategory(v)
		return nil
	}
	return fmt.Errorf("unknown LocalDevice field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LocalDeviceMutation) AddedFields() []string {
	var fields []string
	if m.addvendor_id != nil {
		fields = append(fields, localdevice.FieldVendorID)
	}
	if m.addproduct_id != nil {
		fields = append(fields, localdevice.FieldProductID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LocalDeviceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case localdevice.FieldVendorID:
		return m.AddedVendorID()
	case localdevice.FieldProductID:
		return m.AddedProductID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LocalDeviceMutation) AddField(name string, value ent.Value) error {
	switch name {
	case localdevice.FieldVendorID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddVendorID(v)
		return nil
	case localdevice.FieldProductID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddProductID(v)
		return nil
	}
	return fmt.Errorf("unknown LocalDevice numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LocalDeviceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(localdevice.FieldVendorID) {
		fields = append(fields, localdevice.FieldVendorID)
	}
	if m.FieldCleared(localdevice.FieldProductID) {
		fields = append(fields, localdevice.FieldProductID)
	}
	if m.FieldCleared(localdevice.FieldAddress) {
		fields = append(fields, localdevice.FieldAddress)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LocalDeviceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LocalDeviceMutation) ClearField(name string) error {
	switch name {
	case localdevice.FieldVendorID:
		m.ClearVendorID()
		return nil
	case localdevice.FieldProductID:
		m.ClearProductID()
		return nil
	case localdevice.FieldAddress:
		m.ClearAddress()
		return nil
	}
	return fmt.Errorf("unknown LocalDevice nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LocalDeviceMutation) ResetField(name string) error {
	switch name {
	case localdevice.FieldName:
		m.ResetName()
		return nil
	case localdevice.FieldSystemName:
		m.ResetSystemName()
		return nil
	case localdevice.FieldVendorID:
		m.ResetVendorID()
		return nil
	case localdevice.FieldProductID:
		m.ResetProductID()
		return nil
	case localdevice.FieldAddress:
		m.ResetAddress()
		return nil
	case localdevice.FieldActive:
		m.ResetActive()
		return nil
	case localdevice.FieldArchived:
		m.ResetArchived()
		return nil
	case localdevice.FieldCategory:
		m.ResetCategory()
		return nil
	}
	return fmt.Errorf("unknown LocalDevice field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LocalDeviceMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.print_job != nil {
		edges = append(edges, localdevice.EdgePrintJob)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LocalDeviceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case localdevice.EdgePrintJob:
		ids := make([]ent.Value, 0, len(m.print_job))
		for id := range m.print_job {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LocalDeviceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedprint_job != nil {
		edges = append(edges, localdevice.EdgePrintJob)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LocalDeviceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case localdevice.EdgePrintJob:
		ids := make([]ent.Value, 0, len(m.removedprint_job))
		for id := range m.removedprint_job {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LocalDeviceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedprint_job {
		edges = append(edges, localdevice.EdgePrintJob)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LocalDeviceMutation) EdgeCleared(name string) bool {
	switch name {
	case localdevice.EdgePrintJob:
		return m.clearedprint_job
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LocalDeviceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown LocalDevice unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LocalDeviceMutation) ResetEdge(name string) error {
	switch name {
	case localdevice.EdgePrintJob:
		m.ResetPrintJob()
		return nil
	}
	return fmt.Errorf("unknown LocalDevice edge %s", name)
}

// LogErrorMutation represents an operation that mutates the LogError nodes in the graph.
type LogErrorMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.ID
	error         *string
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*LogError, error)
	predicates    []predicate.LogError
}

var _ ent.Mutation = (*LogErrorMutation)(nil)

// logerrorOption allows management of the mutation configuration using functional options.
type logerrorOption func(*LogErrorMutation)

// newLogErrorMutation creates new mutation for the LogError entity.
func newLogErrorMutation(c config, op Op, opts ...logerrorOption) *LogErrorMutation {
	m := &LogErrorMutation{
		config:        c,
		op:            op,
		typ:           TypeLogError,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withLogErrorID sets the ID field of the mutation.
func withLogErrorID(id pulid.ID) logerrorOption {
	return func(m *LogErrorMutation) {
		var (
			err   error
			once  sync.Once
			value *LogError
		)
		m.oldValue = func(ctx context.Context) (*LogError, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().LogError.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withLogError sets the old LogError of the mutation.
func withLogError(node *LogError) logerrorOption {
	return func(m *LogErrorMutation) {
		m.oldValue = func(context.Context) (*LogError, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m LogErrorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m LogErrorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of LogError entities.
func (m *LogErrorMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *LogErrorMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *LogErrorMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().LogError.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetError sets the "error" field.
func (m *LogErrorMutation) SetError(s string) {
	m.error = &s
}

// Error returns the value of the "error" field in the mutation.
func (m *LogErrorMutation) Error() (r string, exists bool) {
	v := m.error
	if v == nil {
		return
	}
	return *v, true
}

// OldError returns the old "error" field's value of the LogError entity.
// If the LogError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogErrorMutation) OldError(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldError is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldError requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldError: %w", err)
	}
	return oldValue.Error, nil
}

// ResetError resets all changes to the "error" field.
func (m *LogErrorMutation) ResetError() {
	m.error = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *LogErrorMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *LogErrorMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the LogError entity.
// If the LogError object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *LogErrorMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *LogErrorMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the LogErrorMutation builder.
func (m *LogErrorMutation) Where(ps ...predicate.LogError) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the LogErrorMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *LogErrorMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.LogError, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *LogErrorMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *LogErrorMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (LogError).
func (m *LogErrorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *LogErrorMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.error != nil {
		fields = append(fields, logerror.FieldError)
	}
	if m.created_at != nil {
		fields = append(fields, logerror.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *LogErrorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case logerror.FieldError:
		return m.Error()
	case logerror.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *LogErrorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case logerror.FieldError:
		return m.OldError(ctx)
	case logerror.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown LogError field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogErrorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case logerror.FieldError:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetError(v)
		return nil
	case logerror.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown LogError field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *LogErrorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *LogErrorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *LogErrorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown LogError numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *LogErrorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *LogErrorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *LogErrorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown LogError nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *LogErrorMutation) ResetField(name string) error {
	switch name {
	case logerror.FieldError:
		m.ResetError()
		return nil
	case logerror.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown LogError field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *LogErrorMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *LogErrorMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *LogErrorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *LogErrorMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *LogErrorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *LogErrorMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *LogErrorMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown LogError unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *LogErrorMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown LogError edge %s", name)
}

// PrintJobMutation represents an operation that mutates the PrintJob nodes in the graph.
type PrintJobMutation struct {
	config
	op                  Op
	typ                 string
	id                  *pulid.ID
	status              *printjob.Status
	file_extension      *printjob.FileExtension
	use_shell           *bool
	base64_print_data   *string
	messages            *[]string
	appendmessages      []string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	local_device        *pulid.ID
	clearedlocal_device bool
	done                bool
	oldValue            func(context.Context) (*PrintJob, error)
	predicates          []predicate.PrintJob
}

var _ ent.Mutation = (*PrintJobMutation)(nil)

// printjobOption allows management of the mutation configuration using functional options.
type printjobOption func(*PrintJobMutation)

// newPrintJobMutation creates new mutation for the PrintJob entity.
func newPrintJobMutation(c config, op Op, opts ...printjobOption) *PrintJobMutation {
	m := &PrintJobMutation{
		config:        c,
		op:            op,
		typ:           TypePrintJob,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrintJobID sets the ID field of the mutation.
func withPrintJobID(id pulid.ID) printjobOption {
	return func(m *PrintJobMutation) {
		var (
			err   error
			once  sync.Once
			value *PrintJob
		)
		m.oldValue = func(ctx context.Context) (*PrintJob, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PrintJob.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrintJob sets the old PrintJob of the mutation.
func withPrintJob(node *PrintJob) printjobOption {
	return func(m *PrintJobMutation) {
		m.oldValue = func(context.Context) (*PrintJob, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrintJobMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrintJobMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PrintJob entities.
func (m *PrintJobMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PrintJobMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PrintJobMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PrintJob.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetStatus sets the "status" field.
func (m *PrintJobMutation) SetStatus(pr printjob.Status) {
	m.status = &pr
}

// Status returns the value of the "status" field in the mutation.
func (m *PrintJobMutation) Status() (r printjob.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldStatus(ctx context.Context) (v printjob.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *PrintJobMutation) ResetStatus() {
	m.status = nil
}

// SetFileExtension sets the "file_extension" field.
func (m *PrintJobMutation) SetFileExtension(pe printjob.FileExtension) {
	m.file_extension = &pe
}

// FileExtension returns the value of the "file_extension" field in the mutation.
func (m *PrintJobMutation) FileExtension() (r printjob.FileExtension, exists bool) {
	v := m.file_extension
	if v == nil {
		return
	}
	return *v, true
}

// OldFileExtension returns the old "file_extension" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldFileExtension(ctx context.Context) (v printjob.FileExtension, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileExtension: %w", err)
	}
	return oldValue.FileExtension, nil
}

// ResetFileExtension resets all changes to the "file_extension" field.
func (m *PrintJobMutation) ResetFileExtension() {
	m.file_extension = nil
}

// SetUseShell sets the "use_shell" field.
func (m *PrintJobMutation) SetUseShell(b bool) {
	m.use_shell = &b
}

// UseShell returns the value of the "use_shell" field in the mutation.
func (m *PrintJobMutation) UseShell() (r bool, exists bool) {
	v := m.use_shell
	if v == nil {
		return
	}
	return *v, true
}

// OldUseShell returns the old "use_shell" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldUseShell(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUseShell is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUseShell requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUseShell: %w", err)
	}
	return oldValue.UseShell, nil
}

// ResetUseShell resets all changes to the "use_shell" field.
func (m *PrintJobMutation) ResetUseShell() {
	m.use_shell = nil
}

// SetBase64PrintData sets the "base64_print_data" field.
func (m *PrintJobMutation) SetBase64PrintData(s string) {
	m.base64_print_data = &s
}

// Base64PrintData returns the value of the "base64_print_data" field in the mutation.
func (m *PrintJobMutation) Base64PrintData() (r string, exists bool) {
	v := m.base64_print_data
	if v == nil {
		return
	}
	return *v, true
}

// OldBase64PrintData returns the old "base64_print_data" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldBase64PrintData(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBase64PrintData is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBase64PrintData requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBase64PrintData: %w", err)
	}
	return oldValue.Base64PrintData, nil
}

// ResetBase64PrintData resets all changes to the "base64_print_data" field.
func (m *PrintJobMutation) ResetBase64PrintData() {
	m.base64_print_data = nil
}

// SetMessages sets the "messages" field.
func (m *PrintJobMutation) SetMessages(s []string) {
	m.messages = &s
	m.appendmessages = nil
}

// Messages returns the value of the "messages" field in the mutation.
func (m *PrintJobMutation) Messages() (r []string, exists bool) {
	v := m.messages
	if v == nil {
		return
	}
	return *v, true
}

// OldMessages returns the old "messages" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldMessages(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMessages is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMessages requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMessages: %w", err)
	}
	return oldValue.Messages, nil
}

// AppendMessages adds s to the "messages" field.
func (m *PrintJobMutation) AppendMessages(s []string) {
	m.appendmessages = append(m.appendmessages, s...)
}

// AppendedMessages returns the list of values that were appended to the "messages" field in this mutation.
func (m *PrintJobMutation) AppendedMessages() ([]string, bool) {
	if len(m.appendmessages) == 0 {
		return nil, false
	}
	return m.appendmessages, true
}

// ClearMessages clears the value of the "messages" field.
func (m *PrintJobMutation) ClearMessages() {
	m.messages = nil
	m.appendmessages = nil
	m.clearedFields[printjob.FieldMessages] = struct{}{}
}

// MessagesCleared returns if the "messages" field was cleared in this mutation.
func (m *PrintJobMutation) MessagesCleared() bool {
	_, ok := m.clearedFields[printjob.FieldMessages]
	return ok
}

// ResetMessages resets all changes to the "messages" field.
func (m *PrintJobMutation) ResetMessages() {
	m.messages = nil
	m.appendmessages = nil
	delete(m.clearedFields, printjob.FieldMessages)
}

// SetCreatedAt sets the "created_at" field.
func (m *PrintJobMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PrintJobMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PrintJob entity.
// If the PrintJob object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PrintJobMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PrintJobMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLocalDeviceID sets the "local_device" edge to the LocalDevice entity by id.
func (m *PrintJobMutation) SetLocalDeviceID(id pulid.ID) {
	m.local_device = &id
}

// ClearLocalDevice clears the "local_device" edge to the LocalDevice entity.
func (m *PrintJobMutation) ClearLocalDevice() {
	m.clearedlocal_device = true
}

// LocalDeviceCleared reports if the "local_device" edge to the LocalDevice entity was cleared.
func (m *PrintJobMutation) LocalDeviceCleared() bool {
	return m.clearedlocal_device
}

// LocalDeviceID returns the "local_device" edge ID in the mutation.
func (m *PrintJobMutation) LocalDeviceID() (id pulid.ID, exists bool) {
	if m.local_device != nil {
		return *m.local_device, true
	}
	return
}

// LocalDeviceIDs returns the "local_device" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LocalDeviceID instead. It exists only for internal usage by the builders.
func (m *PrintJobMutation) LocalDeviceIDs() (ids []pulid.ID) {
	if id := m.local_device; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLocalDevice resets all changes to the "local_device" edge.
func (m *PrintJobMutation) ResetLocalDevice() {
	m.local_device = nil
	m.clearedlocal_device = false
}

// Where appends a list predicates to the PrintJobMutation builder.
func (m *PrintJobMutation) Where(ps ...predicate.PrintJob) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PrintJobMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PrintJobMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PrintJob, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PrintJobMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PrintJobMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PrintJob).
func (m *PrintJobMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PrintJobMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.status != nil {
		fields = append(fields, printjob.FieldStatus)
	}
	if m.file_extension != nil {
		fields = append(fields, printjob.FieldFileExtension)
	}
	if m.use_shell != nil {
		fields = append(fields, printjob.FieldUseShell)
	}
	if m.base64_print_data != nil {
		fields = append(fields, printjob.FieldBase64PrintData)
	}
	if m.messages != nil {
		fields = append(fields, printjob.FieldMessages)
	}
	if m.created_at != nil {
		fields = append(fields, printjob.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PrintJobMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case printjob.FieldStatus:
		return m.Status()
	case printjob.FieldFileExtension:
		return m.FileExtension()
	case printjob.FieldUseShell:
		return m.UseShell()
	case printjob.FieldBase64PrintData:
		return m.Base64PrintData()
	case printjob.FieldMessages:
		return m.Messages()
	case printjob.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PrintJobMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case printjob.FieldStatus:
		return m.OldStatus(ctx)
	case printjob.FieldFileExtension:
		return m.OldFileExtension(ctx)
	case printjob.FieldUseShell:
		return m.OldUseShell(ctx)
	case printjob.FieldBase64PrintData:
		return m.OldBase64PrintData(ctx)
	case printjob.FieldMessages:
		return m.OldMessages(ctx)
	case printjob.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown PrintJob field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrintJobMutation) SetField(name string, value ent.Value) error {
	switch name {
	case printjob.FieldStatus:
		v, ok := value.(printjob.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case printjob.FieldFileExtension:
		v, ok := value.(printjob.FileExtension)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileExtension(v)
		return nil
	case printjob.FieldUseShell:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUseShell(v)
		return nil
	case printjob.FieldBase64PrintData:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBase64PrintData(v)
		return nil
	case printjob.FieldMessages:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMessages(v)
		return nil
	case printjob.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown PrintJob field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PrintJobMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PrintJobMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PrintJobMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PrintJob numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PrintJobMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(printjob.FieldMessages) {
		fields = append(fields, printjob.FieldMessages)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PrintJobMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrintJobMutation) ClearField(name string) error {
	switch name {
	case printjob.FieldMessages:
		m.ClearMessages()
		return nil
	}
	return fmt.Errorf("unknown PrintJob nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PrintJobMutation) ResetField(name string) error {
	switch name {
	case printjob.FieldStatus:
		m.ResetStatus()
		return nil
	case printjob.FieldFileExtension:
		m.ResetFileExtension()
		return nil
	case printjob.FieldUseShell:
		m.ResetUseShell()
		return nil
	case printjob.FieldBase64PrintData:
		m.ResetBase64PrintData()
		return nil
	case printjob.FieldMessages:
		m.ResetMessages()
		return nil
	case printjob.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown PrintJob field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PrintJobMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.local_device != nil {
		edges = append(edges, printjob.EdgeLocalDevice)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PrintJobMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case printjob.EdgeLocalDevice:
		if id := m.local_device; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PrintJobMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PrintJobMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PrintJobMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedlocal_device {
		edges = append(edges, printjob.EdgeLocalDevice)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PrintJobMutation) EdgeCleared(name string) bool {
	switch name {
	case printjob.EdgeLocalDevice:
		return m.clearedlocal_device
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PrintJobMutation) ClearEdge(name string) error {
	switch name {
	case printjob.EdgeLocalDevice:
		m.ClearLocalDevice()
		return nil
	}
	return fmt.Errorf("unknown PrintJob unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PrintJobMutation) ResetEdge(name string) error {
	switch name {
	case printjob.EdgeLocalDevice:
		m.ResetLocalDevice()
		return nil
	}
	return fmt.Errorf("unknown PrintJob edge %s", name)
}

// RecentScanMutation represents an operation that mutates the RecentScan nodes in the graph.
type RecentScanMutation struct {
	config
	op            Op
	typ           string
	id            *int
	scan_value    *string
	response      *string
	scan_type     *recentscan.ScanType
	created_at    *time.Time
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*RecentScan, error)
	predicates    []predicate.RecentScan
}

var _ ent.Mutation = (*RecentScanMutation)(nil)

// recentscanOption allows management of the mutation configuration using functional options.
type recentscanOption func(*RecentScanMutation)

// newRecentScanMutation creates new mutation for the RecentScan entity.
func newRecentScanMutation(c config, op Op, opts ...recentscanOption) *RecentScanMutation {
	m := &RecentScanMutation{
		config:        c,
		op:            op,
		typ:           TypeRecentScan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRecentScanID sets the ID field of the mutation.
func withRecentScanID(id int) recentscanOption {
	return func(m *RecentScanMutation) {
		var (
			err   error
			once  sync.Once
			value *RecentScan
		)
		m.oldValue = func(ctx context.Context) (*RecentScan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RecentScan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRecentScan sets the old RecentScan of the mutation.
func withRecentScan(node *RecentScan) recentscanOption {
	return func(m *RecentScanMutation) {
		m.oldValue = func(context.Context) (*RecentScan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RecentScanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RecentScanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RecentScanMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RecentScanMutation) IDs(ctx context.Context) ([]int, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RecentScan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetScanValue sets the "scan_value" field.
func (m *RecentScanMutation) SetScanValue(s string) {
	m.scan_value = &s
}

// ScanValue returns the value of the "scan_value" field in the mutation.
func (m *RecentScanMutation) ScanValue() (r string, exists bool) {
	v := m.scan_value
	if v == nil {
		return
	}
	return *v, true
}

// OldScanValue returns the old "scan_value" field's value of the RecentScan entity.
// If the RecentScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentScanMutation) OldScanValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScanValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScanValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScanValue: %w", err)
	}
	return oldValue.ScanValue, nil
}

// ResetScanValue resets all changes to the "scan_value" field.
func (m *RecentScanMutation) ResetScanValue() {
	m.scan_value = nil
}

// SetResponse sets the "response" field.
func (m *RecentScanMutation) SetResponse(s string) {
	m.response = &s
}

// Response returns the value of the "response" field in the mutation.
func (m *RecentScanMutation) Response() (r string, exists bool) {
	v := m.response
	if v == nil {
		return
	}
	return *v, true
}

// OldResponse returns the old "response" field's value of the RecentScan entity.
// If the RecentScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentScanMutation) OldResponse(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldResponse is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldResponse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldResponse: %w", err)
	}
	return oldValue.Response, nil
}

// ResetResponse resets all changes to the "response" field.
func (m *RecentScanMutation) ResetResponse() {
	m.response = nil
}

// SetScanType sets the "scan_type" field.
func (m *RecentScanMutation) SetScanType(rt recentscan.ScanType) {
	m.scan_type = &rt
}

// ScanType returns the value of the "scan_type" field in the mutation.
func (m *RecentScanMutation) ScanType() (r recentscan.ScanType, exists bool) {
	v := m.scan_type
	if v == nil {
		return
	}
	return *v, true
}

// OldScanType returns the old "scan_type" field's value of the RecentScan entity.
// If the RecentScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentScanMutation) OldScanType(ctx context.Context) (v recentscan.ScanType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScanType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScanType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScanType: %w", err)
	}
	return oldValue.ScanType, nil
}

// ResetScanType resets all changes to the "scan_type" field.
func (m *RecentScanMutation) ResetScanType() {
	m.scan_type = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *RecentScanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *RecentScanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the RecentScan entity.
// If the RecentScan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RecentScanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *RecentScanMutation) ResetCreatedAt() {
	m.created_at = nil
}

// Where appends a list predicates to the RecentScanMutation builder.
func (m *RecentScanMutation) Where(ps ...predicate.RecentScan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RecentScanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RecentScanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RecentScan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RecentScanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RecentScanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RecentScan).
func (m *RecentScanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RecentScanMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.scan_value != nil {
		fields = append(fields, recentscan.FieldScanValue)
	}
	if m.response != nil {
		fields = append(fields, recentscan.FieldResponse)
	}
	if m.scan_type != nil {
		fields = append(fields, recentscan.FieldScanType)
	}
	if m.created_at != nil {
		fields = append(fields, recentscan.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RecentScanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case recentscan.FieldScanValue:
		return m.ScanValue()
	case recentscan.FieldResponse:
		return m.Response()
	case recentscan.FieldScanType:
		return m.ScanType()
	case recentscan.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RecentScanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case recentscan.FieldScanValue:
		return m.OldScanValue(ctx)
	case recentscan.FieldResponse:
		return m.OldResponse(ctx)
	case recentscan.FieldScanType:
		return m.OldScanType(ctx)
	case recentscan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown RecentScan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecentScanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case recentscan.FieldScanValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScanValue(v)
		return nil
	case recentscan.FieldResponse:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetResponse(v)
		return nil
	case recentscan.FieldScanType:
		v, ok := value.(recentscan.ScanType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScanType(v)
		return nil
	case recentscan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown RecentScan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RecentScanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RecentScanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RecentScanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RecentScan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RecentScanMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RecentScanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RecentScanMutation) ClearField(name string) error {
	return fmt.Errorf("unknown RecentScan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RecentScanMutation) ResetField(name string) error {
	switch name {
	case recentscan.FieldScanValue:
		m.ResetScanValue()
		return nil
	case recentscan.FieldResponse:
		m.ResetResponse()
		return nil
	case recentscan.FieldScanType:
		m.ResetScanType()
		return nil
	case recentscan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown RecentScan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RecentScanMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RecentScanMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RecentScanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RecentScanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RecentScanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RecentScanMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RecentScanMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RecentScan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RecentScanMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RecentScan edge %s", name)
}

// RemoteConnectionMutation represents an operation that mutates the RemoteConnection nodes in the graph.
type RemoteConnectionMutation struct {
	config
	op                 Op
	typ                string
	id                 *pulid.ID
	remote_url         *string
	registration_token *string
	workstation_name   *string
	last_ping          *time.Time
	clearedFields      map[string]struct{}
	done               bool
	oldValue           func(context.Context) (*RemoteConnection, error)
	predicates         []predicate.RemoteConnection
}

var _ ent.Mutation = (*RemoteConnectionMutation)(nil)

// remoteconnectionOption allows management of the mutation configuration using functional options.
type remoteconnectionOption func(*RemoteConnectionMutation)

// newRemoteConnectionMutation creates new mutation for the RemoteConnection entity.
func newRemoteConnectionMutation(c config, op Op, opts ...remoteconnectionOption) *RemoteConnectionMutation {
	m := &RemoteConnectionMutation{
		config:        c,
		op:            op,
		typ:           TypeRemoteConnection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRemoteConnectionID sets the ID field of the mutation.
func withRemoteConnectionID(id pulid.ID) remoteconnectionOption {
	return func(m *RemoteConnectionMutation) {
		var (
			err   error
			once  sync.Once
			value *RemoteConnection
		)
		m.oldValue = func(ctx context.Context) (*RemoteConnection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().RemoteConnection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRemoteConnection sets the old RemoteConnection of the mutation.
func withRemoteConnection(node *RemoteConnection) remoteconnectionOption {
	return func(m *RemoteConnectionMutation) {
		m.oldValue = func(context.Context) (*RemoteConnection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RemoteConnectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RemoteConnectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of RemoteConnection entities.
func (m *RemoteConnectionMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *RemoteConnectionMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *RemoteConnectionMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().RemoteConnection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetRemoteURL sets the "remote_url" field.
func (m *RemoteConnectionMutation) SetRemoteURL(s string) {
	m.remote_url = &s
}

// RemoteURL returns the value of the "remote_url" field in the mutation.
func (m *RemoteConnectionMutation) RemoteURL() (r string, exists bool) {
	v := m.remote_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRemoteURL returns the old "remote_url" field's value of the RemoteConnection entity.
// If the RemoteConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemoteConnectionMutation) OldRemoteURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRemoteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRemoteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRemoteURL: %w", err)
	}
	return oldValue.RemoteURL, nil
}

// ResetRemoteURL resets all changes to the "remote_url" field.
func (m *RemoteConnectionMutation) ResetRemoteURL() {
	m.remote_url = nil
}

// SetRegistrationToken sets the "registration_token" field.
func (m *RemoteConnectionMutation) SetRegistrationToken(s string) {
	m.registration_token = &s
}

// RegistrationToken returns the value of the "registration_token" field in the mutation.
func (m *RemoteConnectionMutation) RegistrationToken() (r string, exists bool) {
	v := m.registration_token
	if v == nil {
		return
	}
	return *v, true
}

// OldRegistrationToken returns the old "registration_token" field's value of the RemoteConnection entity.
// If the RemoteConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemoteConnectionMutation) OldRegistrationToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRegistrationToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRegistrationToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRegistrationToken: %w", err)
	}
	return oldValue.RegistrationToken, nil
}

// ResetRegistrationToken resets all changes to the "registration_token" field.
func (m *RemoteConnectionMutation) ResetRegistrationToken() {
	m.registration_token = nil
}

// SetWorkstationName sets the "workstation_name" field.
func (m *RemoteConnectionMutation) SetWorkstationName(s string) {
	m.workstation_name = &s
}

// WorkstationName returns the value of the "workstation_name" field in the mutation.
func (m *RemoteConnectionMutation) WorkstationName() (r string, exists bool) {
	v := m.workstation_name
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkstationName returns the old "workstation_name" field's value of the RemoteConnection entity.
// If the RemoteConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemoteConnectionMutation) OldWorkstationName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkstationName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkstationName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkstationName: %w", err)
	}
	return oldValue.WorkstationName, nil
}

// ResetWorkstationName resets all changes to the "workstation_name" field.
func (m *RemoteConnectionMutation) ResetWorkstationName() {
	m.workstation_name = nil
}

// SetLastPing sets the "last_ping" field.
func (m *RemoteConnectionMutation) SetLastPing(t time.Time) {
	m.last_ping = &t
}

// LastPing returns the value of the "last_ping" field in the mutation.
func (m *RemoteConnectionMutation) LastPing() (r time.Time, exists bool) {
	v := m.last_ping
	if v == nil {
		return
	}
	return *v, true
}

// OldLastPing returns the old "last_ping" field's value of the RemoteConnection entity.
// If the RemoteConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *RemoteConnectionMutation) OldLastPing(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastPing is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastPing requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastPing: %w", err)
	}
	return oldValue.LastPing, nil
}

// ClearLastPing clears the value of the "last_ping" field.
func (m *RemoteConnectionMutation) ClearLastPing() {
	m.last_ping = nil
	m.clearedFields[remoteconnection.FieldLastPing] = struct{}{}
}

// LastPingCleared returns if the "last_ping" field was cleared in this mutation.
func (m *RemoteConnectionMutation) LastPingCleared() bool {
	_, ok := m.clearedFields[remoteconnection.FieldLastPing]
	return ok
}

// ResetLastPing resets all changes to the "last_ping" field.
func (m *RemoteConnectionMutation) ResetLastPing() {
	m.last_ping = nil
	delete(m.clearedFields, remoteconnection.FieldLastPing)
}

// Where appends a list predicates to the RemoteConnectionMutation builder.
func (m *RemoteConnectionMutation) Where(ps ...predicate.RemoteConnection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the RemoteConnectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *RemoteConnectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.RemoteConnection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *RemoteConnectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *RemoteConnectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (RemoteConnection).
func (m *RemoteConnectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *RemoteConnectionMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.remote_url != nil {
		fields = append(fields, remoteconnection.FieldRemoteURL)
	}
	if m.registration_token != nil {
		fields = append(fields, remoteconnection.FieldRegistrationToken)
	}
	if m.workstation_name != nil {
		fields = append(fields, remoteconnection.FieldWorkstationName)
	}
	if m.last_ping != nil {
		fields = append(fields, remoteconnection.FieldLastPing)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *RemoteConnectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case remoteconnection.FieldRemoteURL:
		return m.RemoteURL()
	case remoteconnection.FieldRegistrationToken:
		return m.RegistrationToken()
	case remoteconnection.FieldWorkstationName:
		return m.WorkstationName()
	case remoteconnection.FieldLastPing:
		return m.LastPing()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *RemoteConnectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case remoteconnection.FieldRemoteURL:
		return m.OldRemoteURL(ctx)
	case remoteconnection.FieldRegistrationToken:
		return m.OldRegistrationToken(ctx)
	case remoteconnection.FieldWorkstationName:
		return m.OldWorkstationName(ctx)
	case remoteconnection.FieldLastPing:
		return m.OldLastPing(ctx)
	}
	return nil, fmt.Errorf("unknown RemoteConnection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemoteConnectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case remoteconnection.FieldRemoteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRemoteURL(v)
		return nil
	case remoteconnection.FieldRegistrationToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRegistrationToken(v)
		return nil
	case remoteconnection.FieldWorkstationName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkstationName(v)
		return nil
	case remoteconnection.FieldLastPing:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastPing(v)
		return nil
	}
	return fmt.Errorf("unknown RemoteConnection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *RemoteConnectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *RemoteConnectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *RemoteConnectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown RemoteConnection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *RemoteConnectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(remoteconnection.FieldLastPing) {
		fields = append(fields, remoteconnection.FieldLastPing)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *RemoteConnectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *RemoteConnectionMutation) ClearField(name string) error {
	switch name {
	case remoteconnection.FieldLastPing:
		m.ClearLastPing()
		return nil
	}
	return fmt.Errorf("unknown RemoteConnection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *RemoteConnectionMutation) ResetField(name string) error {
	switch name {
	case remoteconnection.FieldRemoteURL:
		m.ResetRemoteURL()
		return nil
	case remoteconnection.FieldRegistrationToken:
		m.ResetRegistrationToken()
		return nil
	case remoteconnection.FieldWorkstationName:
		m.ResetWorkstationName()
		return nil
	case remoteconnection.FieldLastPing:
		m.ResetLastPing()
		return nil
	}
	return fmt.Errorf("unknown RemoteConnection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *RemoteConnectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *RemoteConnectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *RemoteConnectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *RemoteConnectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *RemoteConnectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *RemoteConnectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *RemoteConnectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown RemoteConnection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *RemoteConnectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown RemoteConnection edge %s", name)
}

// UniqueComputerMutation represents an operation that mutates the UniqueComputer nodes in the graph.
type UniqueComputerMutation struct {
	config
	op            Op
	typ           string
	id            *pulid.ID
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*UniqueComputer, error)
	predicates    []predicate.UniqueComputer
}

var _ ent.Mutation = (*UniqueComputerMutation)(nil)

// uniquecomputerOption allows management of the mutation configuration using functional options.
type uniquecomputerOption func(*UniqueComputerMutation)

// newUniqueComputerMutation creates new mutation for the UniqueComputer entity.
func newUniqueComputerMutation(c config, op Op, opts ...uniquecomputerOption) *UniqueComputerMutation {
	m := &UniqueComputerMutation{
		config:        c,
		op:            op,
		typ:           TypeUniqueComputer,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUniqueComputerID sets the ID field of the mutation.
func withUniqueComputerID(id pulid.ID) uniquecomputerOption {
	return func(m *UniqueComputerMutation) {
		var (
			err   error
			once  sync.Once
			value *UniqueComputer
		)
		m.oldValue = func(ctx context.Context) (*UniqueComputer, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().UniqueComputer.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUniqueComputer sets the old UniqueComputer of the mutation.
func withUniqueComputer(node *UniqueComputer) uniquecomputerOption {
	return func(m *UniqueComputerMutation) {
		m.oldValue = func(context.Context) (*UniqueComputer, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UniqueComputerMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UniqueComputerMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of UniqueComputer entities.
func (m *UniqueComputerMutation) SetID(id pulid.ID) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UniqueComputerMutation) ID() (id pulid.ID, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UniqueComputerMutation) IDs(ctx context.Context) ([]pulid.ID, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []pulid.ID{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().UniqueComputer.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// Where appends a list predicates to the UniqueComputerMutation builder.
func (m *UniqueComputerMutation) Where(ps ...predicate.UniqueComputer) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UniqueComputerMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UniqueComputerMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.UniqueComputer, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UniqueComputerMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UniqueComputerMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (UniqueComputer).
func (m *UniqueComputerMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UniqueComputerMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UniqueComputerMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UniqueComputerMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown UniqueComputer field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UniqueComputerMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UniqueComputer field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UniqueComputerMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UniqueComputerMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UniqueComputerMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown UniqueComputer numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UniqueComputerMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UniqueComputerMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UniqueComputerMutation) ClearField(name string) error {
	return fmt.Errorf("unknown UniqueComputer nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UniqueComputerMutation) ResetField(name string) error {
	return fmt.Errorf("unknown UniqueComputer field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UniqueComputerMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UniqueComputerMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UniqueComputerMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UniqueComputerMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UniqueComputerMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UniqueComputerMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UniqueComputerMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown UniqueComputer unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UniqueComputerMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown UniqueComputer edge %s", name)
}
