// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"delivrio.io/print-client/ent/migrate"
	"delivrio.io/shared-utils/pulid"

	"delivrio.io/print-client/ent/localdevice"
	"delivrio.io/print-client/ent/logerror"
	"delivrio.io/print-client/ent/printjob"
	"delivrio.io/print-client/ent/recentscan"
	"delivrio.io/print-client/ent/remoteconnection"
	"delivrio.io/print-client/ent/uniquecomputer"
	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// LocalDevice is the client for interacting with the LocalDevice builders.
	LocalDevice *LocalDeviceClient
	// LogError is the client for interacting with the LogError builders.
	LogError *LogErrorClient
	// PrintJob is the client for interacting with the PrintJob builders.
	PrintJob *PrintJobClient
	// RecentScan is the client for interacting with the RecentScan builders.
	RecentScan *RecentScanClient
	// RemoteConnection is the client for interacting with the RemoteConnection builders.
	RemoteConnection *RemoteConnectionClient
	// UniqueComputer is the client for interacting with the UniqueComputer builders.
	UniqueComputer *UniqueComputerClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.LocalDevice = NewLocalDeviceClient(c.config)
	c.LogError = NewLogErrorClient(c.config)
	c.PrintJob = NewPrintJobClient(c.config)
	c.RecentScan = NewRecentScanClient(c.config)
	c.RemoteConnection = NewRemoteConnectionClient(c.config)
	c.UniqueComputer = NewUniqueComputerClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		LocalDevice:      NewLocalDeviceClient(cfg),
		LogError:         NewLogErrorClient(cfg),
		PrintJob:         NewPrintJobClient(cfg),
		RecentScan:       NewRecentScanClient(cfg),
		RemoteConnection: NewRemoteConnectionClient(cfg),
		UniqueComputer:   NewUniqueComputerClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:              ctx,
		config:           cfg,
		LocalDevice:      NewLocalDeviceClient(cfg),
		LogError:         NewLogErrorClient(cfg),
		PrintJob:         NewPrintJobClient(cfg),
		RecentScan:       NewRecentScanClient(cfg),
		RemoteConnection: NewRemoteConnectionClient(cfg),
		UniqueComputer:   NewUniqueComputerClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		LocalDevice.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.LocalDevice, c.LogError, c.PrintJob, c.RecentScan, c.RemoteConnection,
		c.UniqueComputer,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.LocalDevice, c.LogError, c.PrintJob, c.RecentScan, c.RemoteConnection,
		c.UniqueComputer,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *LocalDeviceMutation:
		return c.LocalDevice.mutate(ctx, m)
	case *LogErrorMutation:
		return c.LogError.mutate(ctx, m)
	case *PrintJobMutation:
		return c.PrintJob.mutate(ctx, m)
	case *RecentScanMutation:
		return c.RecentScan.mutate(ctx, m)
	case *RemoteConnectionMutation:
		return c.RemoteConnection.mutate(ctx, m)
	case *UniqueComputerMutation:
		return c.UniqueComputer.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// LocalDeviceClient is a client for the LocalDevice schema.
type LocalDeviceClient struct {
	config
}

// NewLocalDeviceClient returns a client for the LocalDevice from the given config.
func NewLocalDeviceClient(c config) *LocalDeviceClient {
	return &LocalDeviceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `localdevice.Hooks(f(g(h())))`.
func (c *LocalDeviceClient) Use(hooks ...Hook) {
	c.hooks.LocalDevice = append(c.hooks.LocalDevice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `localdevice.Intercept(f(g(h())))`.
func (c *LocalDeviceClient) Intercept(interceptors ...Interceptor) {
	c.inters.LocalDevice = append(c.inters.LocalDevice, interceptors...)
}

// Create returns a builder for creating a LocalDevice entity.
func (c *LocalDeviceClient) Create() *LocalDeviceCreate {
	mutation := newLocalDeviceMutation(c.config, OpCreate)
	return &LocalDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LocalDevice entities.
func (c *LocalDeviceClient) CreateBulk(builders ...*LocalDeviceCreate) *LocalDeviceCreateBulk {
	return &LocalDeviceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LocalDeviceClient) MapCreateBulk(slice any, setFunc func(*LocalDeviceCreate, int)) *LocalDeviceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LocalDeviceCreateBulk{err: fmt.Errorf("calling to LocalDeviceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LocalDeviceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LocalDeviceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LocalDevice.
func (c *LocalDeviceClient) Update() *LocalDeviceUpdate {
	mutation := newLocalDeviceMutation(c.config, OpUpdate)
	return &LocalDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LocalDeviceClient) UpdateOne(ld *LocalDevice) *LocalDeviceUpdateOne {
	mutation := newLocalDeviceMutation(c.config, OpUpdateOne, withLocalDevice(ld))
	return &LocalDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LocalDeviceClient) UpdateOneID(id pulid.ID) *LocalDeviceUpdateOne {
	mutation := newLocalDeviceMutation(c.config, OpUpdateOne, withLocalDeviceID(id))
	return &LocalDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LocalDevice.
func (c *LocalDeviceClient) Delete() *LocalDeviceDelete {
	mutation := newLocalDeviceMutation(c.config, OpDelete)
	return &LocalDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LocalDeviceClient) DeleteOne(ld *LocalDevice) *LocalDeviceDeleteOne {
	return c.DeleteOneID(ld.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LocalDeviceClient) DeleteOneID(id pulid.ID) *LocalDeviceDeleteOne {
	builder := c.Delete().Where(localdevice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LocalDeviceDeleteOne{builder}
}

// Query returns a query builder for LocalDevice.
func (c *LocalDeviceClient) Query() *LocalDeviceQuery {
	return &LocalDeviceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLocalDevice},
		inters: c.Interceptors(),
	}
}

// Get returns a LocalDevice entity by its id.
func (c *LocalDeviceClient) Get(ctx context.Context, id pulid.ID) (*LocalDevice, error) {
	return c.Query().Where(localdevice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LocalDeviceClient) GetX(ctx context.Context, id pulid.ID) *LocalDevice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPrintJob queries the print_job edge of a LocalDevice.
func (c *LocalDeviceClient) QueryPrintJob(ld *LocalDevice) *PrintJobQuery {
	query := (&PrintJobClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ld.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(localdevice.Table, localdevice.FieldID, id),
			sqlgraph.To(printjob.Table, printjob.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, localdevice.PrintJobTable, localdevice.PrintJobColumn),
		)
		fromV = sqlgraph.Neighbors(ld.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *LocalDeviceClient) Hooks() []Hook {
	return c.hooks.LocalDevice
}

// Interceptors returns the client interceptors.
func (c *LocalDeviceClient) Interceptors() []Interceptor {
	return c.inters.LocalDevice
}

func (c *LocalDeviceClient) mutate(ctx context.Context, m *LocalDeviceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LocalDeviceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LocalDeviceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LocalDeviceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LocalDeviceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LocalDevice mutation op: %q", m.Op())
	}
}

// LogErrorClient is a client for the LogError schema.
type LogErrorClient struct {
	config
}

// NewLogErrorClient returns a client for the LogError from the given config.
func NewLogErrorClient(c config) *LogErrorClient {
	return &LogErrorClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `logerror.Hooks(f(g(h())))`.
func (c *LogErrorClient) Use(hooks ...Hook) {
	c.hooks.LogError = append(c.hooks.LogError, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `logerror.Intercept(f(g(h())))`.
func (c *LogErrorClient) Intercept(interceptors ...Interceptor) {
	c.inters.LogError = append(c.inters.LogError, interceptors...)
}

// Create returns a builder for creating a LogError entity.
func (c *LogErrorClient) Create() *LogErrorCreate {
	mutation := newLogErrorMutation(c.config, OpCreate)
	return &LogErrorCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of LogError entities.
func (c *LogErrorClient) CreateBulk(builders ...*LogErrorCreate) *LogErrorCreateBulk {
	return &LogErrorCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *LogErrorClient) MapCreateBulk(slice any, setFunc func(*LogErrorCreate, int)) *LogErrorCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &LogErrorCreateBulk{err: fmt.Errorf("calling to LogErrorClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*LogErrorCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &LogErrorCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for LogError.
func (c *LogErrorClient) Update() *LogErrorUpdate {
	mutation := newLogErrorMutation(c.config, OpUpdate)
	return &LogErrorUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *LogErrorClient) UpdateOne(le *LogError) *LogErrorUpdateOne {
	mutation := newLogErrorMutation(c.config, OpUpdateOne, withLogError(le))
	return &LogErrorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *LogErrorClient) UpdateOneID(id pulid.ID) *LogErrorUpdateOne {
	mutation := newLogErrorMutation(c.config, OpUpdateOne, withLogErrorID(id))
	return &LogErrorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for LogError.
func (c *LogErrorClient) Delete() *LogErrorDelete {
	mutation := newLogErrorMutation(c.config, OpDelete)
	return &LogErrorDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *LogErrorClient) DeleteOne(le *LogError) *LogErrorDeleteOne {
	return c.DeleteOneID(le.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *LogErrorClient) DeleteOneID(id pulid.ID) *LogErrorDeleteOne {
	builder := c.Delete().Where(logerror.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &LogErrorDeleteOne{builder}
}

// Query returns a query builder for LogError.
func (c *LogErrorClient) Query() *LogErrorQuery {
	return &LogErrorQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeLogError},
		inters: c.Interceptors(),
	}
}

// Get returns a LogError entity by its id.
func (c *LogErrorClient) Get(ctx context.Context, id pulid.ID) (*LogError, error) {
	return c.Query().Where(logerror.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *LogErrorClient) GetX(ctx context.Context, id pulid.ID) *LogError {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *LogErrorClient) Hooks() []Hook {
	return c.hooks.LogError
}

// Interceptors returns the client interceptors.
func (c *LogErrorClient) Interceptors() []Interceptor {
	return c.inters.LogError
}

func (c *LogErrorClient) mutate(ctx context.Context, m *LogErrorMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&LogErrorCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&LogErrorUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&LogErrorUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&LogErrorDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown LogError mutation op: %q", m.Op())
	}
}

// PrintJobClient is a client for the PrintJob schema.
type PrintJobClient struct {
	config
}

// NewPrintJobClient returns a client for the PrintJob from the given config.
func NewPrintJobClient(c config) *PrintJobClient {
	return &PrintJobClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `printjob.Hooks(f(g(h())))`.
func (c *PrintJobClient) Use(hooks ...Hook) {
	c.hooks.PrintJob = append(c.hooks.PrintJob, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `printjob.Intercept(f(g(h())))`.
func (c *PrintJobClient) Intercept(interceptors ...Interceptor) {
	c.inters.PrintJob = append(c.inters.PrintJob, interceptors...)
}

// Create returns a builder for creating a PrintJob entity.
func (c *PrintJobClient) Create() *PrintJobCreate {
	mutation := newPrintJobMutation(c.config, OpCreate)
	return &PrintJobCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PrintJob entities.
func (c *PrintJobClient) CreateBulk(builders ...*PrintJobCreate) *PrintJobCreateBulk {
	return &PrintJobCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PrintJobClient) MapCreateBulk(slice any, setFunc func(*PrintJobCreate, int)) *PrintJobCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PrintJobCreateBulk{err: fmt.Errorf("calling to PrintJobClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PrintJobCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PrintJobCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PrintJob.
func (c *PrintJobClient) Update() *PrintJobUpdate {
	mutation := newPrintJobMutation(c.config, OpUpdate)
	return &PrintJobUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PrintJobClient) UpdateOne(pj *PrintJob) *PrintJobUpdateOne {
	mutation := newPrintJobMutation(c.config, OpUpdateOne, withPrintJob(pj))
	return &PrintJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PrintJobClient) UpdateOneID(id pulid.ID) *PrintJobUpdateOne {
	mutation := newPrintJobMutation(c.config, OpUpdateOne, withPrintJobID(id))
	return &PrintJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PrintJob.
func (c *PrintJobClient) Delete() *PrintJobDelete {
	mutation := newPrintJobMutation(c.config, OpDelete)
	return &PrintJobDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PrintJobClient) DeleteOne(pj *PrintJob) *PrintJobDeleteOne {
	return c.DeleteOneID(pj.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PrintJobClient) DeleteOneID(id pulid.ID) *PrintJobDeleteOne {
	builder := c.Delete().Where(printjob.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PrintJobDeleteOne{builder}
}

// Query returns a query builder for PrintJob.
func (c *PrintJobClient) Query() *PrintJobQuery {
	return &PrintJobQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePrintJob},
		inters: c.Interceptors(),
	}
}

// Get returns a PrintJob entity by its id.
func (c *PrintJobClient) Get(ctx context.Context, id pulid.ID) (*PrintJob, error) {
	return c.Query().Where(printjob.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PrintJobClient) GetX(ctx context.Context, id pulid.ID) *PrintJob {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryLocalDevice queries the local_device edge of a PrintJob.
func (c *PrintJobClient) QueryLocalDevice(pj *PrintJob) *LocalDeviceQuery {
	query := (&LocalDeviceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pj.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(printjob.Table, printjob.FieldID, id),
			sqlgraph.To(localdevice.Table, localdevice.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, printjob.LocalDeviceTable, printjob.LocalDeviceColumn),
		)
		fromV = sqlgraph.Neighbors(pj.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PrintJobClient) Hooks() []Hook {
	return c.hooks.PrintJob
}

// Interceptors returns the client interceptors.
func (c *PrintJobClient) Interceptors() []Interceptor {
	return c.inters.PrintJob
}

func (c *PrintJobClient) mutate(ctx context.Context, m *PrintJobMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PrintJobCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PrintJobUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PrintJobUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PrintJobDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PrintJob mutation op: %q", m.Op())
	}
}

// RecentScanClient is a client for the RecentScan schema.
type RecentScanClient struct {
	config
}

// NewRecentScanClient returns a client for the RecentScan from the given config.
func NewRecentScanClient(c config) *RecentScanClient {
	return &RecentScanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `recentscan.Hooks(f(g(h())))`.
func (c *RecentScanClient) Use(hooks ...Hook) {
	c.hooks.RecentScan = append(c.hooks.RecentScan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `recentscan.Intercept(f(g(h())))`.
func (c *RecentScanClient) Intercept(interceptors ...Interceptor) {
	c.inters.RecentScan = append(c.inters.RecentScan, interceptors...)
}

// Create returns a builder for creating a RecentScan entity.
func (c *RecentScanClient) Create() *RecentScanCreate {
	mutation := newRecentScanMutation(c.config, OpCreate)
	return &RecentScanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RecentScan entities.
func (c *RecentScanClient) CreateBulk(builders ...*RecentScanCreate) *RecentScanCreateBulk {
	return &RecentScanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RecentScanClient) MapCreateBulk(slice any, setFunc func(*RecentScanCreate, int)) *RecentScanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RecentScanCreateBulk{err: fmt.Errorf("calling to RecentScanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RecentScanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RecentScanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RecentScan.
func (c *RecentScanClient) Update() *RecentScanUpdate {
	mutation := newRecentScanMutation(c.config, OpUpdate)
	return &RecentScanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RecentScanClient) UpdateOne(rs *RecentScan) *RecentScanUpdateOne {
	mutation := newRecentScanMutation(c.config, OpUpdateOne, withRecentScan(rs))
	return &RecentScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RecentScanClient) UpdateOneID(id int) *RecentScanUpdateOne {
	mutation := newRecentScanMutation(c.config, OpUpdateOne, withRecentScanID(id))
	return &RecentScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RecentScan.
func (c *RecentScanClient) Delete() *RecentScanDelete {
	mutation := newRecentScanMutation(c.config, OpDelete)
	return &RecentScanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RecentScanClient) DeleteOne(rs *RecentScan) *RecentScanDeleteOne {
	return c.DeleteOneID(rs.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RecentScanClient) DeleteOneID(id int) *RecentScanDeleteOne {
	builder := c.Delete().Where(recentscan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RecentScanDeleteOne{builder}
}

// Query returns a query builder for RecentScan.
func (c *RecentScanClient) Query() *RecentScanQuery {
	return &RecentScanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRecentScan},
		inters: c.Interceptors(),
	}
}

// Get returns a RecentScan entity by its id.
func (c *RecentScanClient) Get(ctx context.Context, id int) (*RecentScan, error) {
	return c.Query().Where(recentscan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RecentScanClient) GetX(ctx context.Context, id int) *RecentScan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RecentScanClient) Hooks() []Hook {
	return c.hooks.RecentScan
}

// Interceptors returns the client interceptors.
func (c *RecentScanClient) Interceptors() []Interceptor {
	return c.inters.RecentScan
}

func (c *RecentScanClient) mutate(ctx context.Context, m *RecentScanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RecentScanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RecentScanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RecentScanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RecentScanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RecentScan mutation op: %q", m.Op())
	}
}

// RemoteConnectionClient is a client for the RemoteConnection schema.
type RemoteConnectionClient struct {
	config
}

// NewRemoteConnectionClient returns a client for the RemoteConnection from the given config.
func NewRemoteConnectionClient(c config) *RemoteConnectionClient {
	return &RemoteConnectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `remoteconnection.Hooks(f(g(h())))`.
func (c *RemoteConnectionClient) Use(hooks ...Hook) {
	c.hooks.RemoteConnection = append(c.hooks.RemoteConnection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `remoteconnection.Intercept(f(g(h())))`.
func (c *RemoteConnectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.RemoteConnection = append(c.inters.RemoteConnection, interceptors...)
}

// Create returns a builder for creating a RemoteConnection entity.
func (c *RemoteConnectionClient) Create() *RemoteConnectionCreate {
	mutation := newRemoteConnectionMutation(c.config, OpCreate)
	return &RemoteConnectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of RemoteConnection entities.
func (c *RemoteConnectionClient) CreateBulk(builders ...*RemoteConnectionCreate) *RemoteConnectionCreateBulk {
	return &RemoteConnectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *RemoteConnectionClient) MapCreateBulk(slice any, setFunc func(*RemoteConnectionCreate, int)) *RemoteConnectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &RemoteConnectionCreateBulk{err: fmt.Errorf("calling to RemoteConnectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*RemoteConnectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &RemoteConnectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for RemoteConnection.
func (c *RemoteConnectionClient) Update() *RemoteConnectionUpdate {
	mutation := newRemoteConnectionMutation(c.config, OpUpdate)
	return &RemoteConnectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *RemoteConnectionClient) UpdateOne(rc *RemoteConnection) *RemoteConnectionUpdateOne {
	mutation := newRemoteConnectionMutation(c.config, OpUpdateOne, withRemoteConnection(rc))
	return &RemoteConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *RemoteConnectionClient) UpdateOneID(id pulid.ID) *RemoteConnectionUpdateOne {
	mutation := newRemoteConnectionMutation(c.config, OpUpdateOne, withRemoteConnectionID(id))
	return &RemoteConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for RemoteConnection.
func (c *RemoteConnectionClient) Delete() *RemoteConnectionDelete {
	mutation := newRemoteConnectionMutation(c.config, OpDelete)
	return &RemoteConnectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *RemoteConnectionClient) DeleteOne(rc *RemoteConnection) *RemoteConnectionDeleteOne {
	return c.DeleteOneID(rc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *RemoteConnectionClient) DeleteOneID(id pulid.ID) *RemoteConnectionDeleteOne {
	builder := c.Delete().Where(remoteconnection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &RemoteConnectionDeleteOne{builder}
}

// Query returns a query builder for RemoteConnection.
func (c *RemoteConnectionClient) Query() *RemoteConnectionQuery {
	return &RemoteConnectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeRemoteConnection},
		inters: c.Interceptors(),
	}
}

// Get returns a RemoteConnection entity by its id.
func (c *RemoteConnectionClient) Get(ctx context.Context, id pulid.ID) (*RemoteConnection, error) {
	return c.Query().Where(remoteconnection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *RemoteConnectionClient) GetX(ctx context.Context, id pulid.ID) *RemoteConnection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *RemoteConnectionClient) Hooks() []Hook {
	return c.hooks.RemoteConnection
}

// Interceptors returns the client interceptors.
func (c *RemoteConnectionClient) Interceptors() []Interceptor {
	return c.inters.RemoteConnection
}

func (c *RemoteConnectionClient) mutate(ctx context.Context, m *RemoteConnectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&RemoteConnectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&RemoteConnectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&RemoteConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&RemoteConnectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown RemoteConnection mutation op: %q", m.Op())
	}
}

// UniqueComputerClient is a client for the UniqueComputer schema.
type UniqueComputerClient struct {
	config
}

// NewUniqueComputerClient returns a client for the UniqueComputer from the given config.
func NewUniqueComputerClient(c config) *UniqueComputerClient {
	return &UniqueComputerClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `uniquecomputer.Hooks(f(g(h())))`.
func (c *UniqueComputerClient) Use(hooks ...Hook) {
	c.hooks.UniqueComputer = append(c.hooks.UniqueComputer, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `uniquecomputer.Intercept(f(g(h())))`.
func (c *UniqueComputerClient) Intercept(interceptors ...Interceptor) {
	c.inters.UniqueComputer = append(c.inters.UniqueComputer, interceptors...)
}

// Create returns a builder for creating a UniqueComputer entity.
func (c *UniqueComputerClient) Create() *UniqueComputerCreate {
	mutation := newUniqueComputerMutation(c.config, OpCreate)
	return &UniqueComputerCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of UniqueComputer entities.
func (c *UniqueComputerClient) CreateBulk(builders ...*UniqueComputerCreate) *UniqueComputerCreateBulk {
	return &UniqueComputerCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UniqueComputerClient) MapCreateBulk(slice any, setFunc func(*UniqueComputerCreate, int)) *UniqueComputerCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UniqueComputerCreateBulk{err: fmt.Errorf("calling to UniqueComputerClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UniqueComputerCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UniqueComputerCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for UniqueComputer.
func (c *UniqueComputerClient) Update() *UniqueComputerUpdate {
	mutation := newUniqueComputerMutation(c.config, OpUpdate)
	return &UniqueComputerUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UniqueComputerClient) UpdateOne(uc *UniqueComputer) *UniqueComputerUpdateOne {
	mutation := newUniqueComputerMutation(c.config, OpUpdateOne, withUniqueComputer(uc))
	return &UniqueComputerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UniqueComputerClient) UpdateOneID(id pulid.ID) *UniqueComputerUpdateOne {
	mutation := newUniqueComputerMutation(c.config, OpUpdateOne, withUniqueComputerID(id))
	return &UniqueComputerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for UniqueComputer.
func (c *UniqueComputerClient) Delete() *UniqueComputerDelete {
	mutation := newUniqueComputerMutation(c.config, OpDelete)
	return &UniqueComputerDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UniqueComputerClient) DeleteOne(uc *UniqueComputer) *UniqueComputerDeleteOne {
	return c.DeleteOneID(uc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UniqueComputerClient) DeleteOneID(id pulid.ID) *UniqueComputerDeleteOne {
	builder := c.Delete().Where(uniquecomputer.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UniqueComputerDeleteOne{builder}
}

// Query returns a query builder for UniqueComputer.
func (c *UniqueComputerClient) Query() *UniqueComputerQuery {
	return &UniqueComputerQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUniqueComputer},
		inters: c.Interceptors(),
	}
}

// Get returns a UniqueComputer entity by its id.
func (c *UniqueComputerClient) Get(ctx context.Context, id pulid.ID) (*UniqueComputer, error) {
	return c.Query().Where(uniquecomputer.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UniqueComputerClient) GetX(ctx context.Context, id pulid.ID) *UniqueComputer {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *UniqueComputerClient) Hooks() []Hook {
	return c.hooks.UniqueComputer
}

// Interceptors returns the client interceptors.
func (c *UniqueComputerClient) Interceptors() []Interceptor {
	return c.inters.UniqueComputer
}

func (c *UniqueComputerClient) mutate(ctx context.Context, m *UniqueComputerMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UniqueComputerCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UniqueComputerUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UniqueComputerUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UniqueComputerDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown UniqueComputer mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		LocalDevice, LogError, PrintJob, RecentScan, RemoteConnection,
		UniqueComputer []ent.Hook
	}
	inters struct {
		LocalDevice, LogError, PrintJob, RecentScan, RemoteConnection,
		UniqueComputer []ent.Interceptor
	}
)
